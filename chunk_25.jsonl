{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving an edge from this CoNetwork and another CoNetwork return the corresponding edge id.", "response": "def remapped_edge(self, vertex_id_conversion, other_edge_id):\n        \"\"\"Given an edge (`vertex0_id`, `vertex1_id`) from a\n        different CoNetwork, return the corresponding edge id from this\n        CoNetwork (`self`).\n\n        Parameters\n        -----------\n        vertex_id_conversion : dict (int -> int)\n          the dict produced by `convert_pathway_mapping,` which maps\n          the other CoNetwork's vertex ids to this CoNetwork's vertex ids.\n        other_edge_id : tup(int, int)\n          the edge id for the edge in the other CoNetwork\n\n        Returns\n        -----------\n        tup(int, int), the corresponding edge id\n        \"\"\"\n        vertex0_id, vertex1_id = other_edge_id\n        self_vertex0 = vertex_id_conversion[vertex0_id]\n        self_vertex1 = vertex_id_conversion[vertex1_id]\n        edge_id = self.edge_tuple(self_vertex0, self_vertex1)\n        return edge_id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef edge_tuple(self, vertex0_id, vertex1_id):\n        pw0 = self.__getitem__(vertex0_id)\n        pw1 = self.__getitem__(vertex1_id)\n\n        if not pw0 or not pw1:\n            return None\n        if pw0 < pw1:\n            return (vertex0_id, vertex1_id)\n        elif pw0 > pw1:\n            return (vertex1_id, vertex0_id)\n        else:\n            return None", "response": "Return the edge id and edge id of the edge that is in the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_pathway(self, pathway):\n        if pathway not in self.pathways:\n            self.pathways[pathway] = self.n_pathways\n            self.n_pathways += 1\n        return self.pathways[pathway]", "response": "Adds a pathway to the pathway list. Returns the pathway number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_edge_pathways(self, edge_id):\n        vertex0_id, vertex1_id = edge_id\n        pw0 = self.get_pathway_from_vertex_id(vertex0_id)\n        pw1 = self.get_pathway_from_vertex_id(vertex1_id)\n        if not pw0 or not pw1:\n            return None\n        return (pw0, pw1)", "response": "Get the pathways associated with an edge."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vertex_obj_from_pathway(self, pathway):\n        if pathway in self.pathways:\n            vertex_id = self.pathways[pathway]\n            return self.vertices[vertex_id]\n        else:\n            return None", "response": "Get the vertex object that corresponds to a pathway name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_adjacent_pathways(self, pathway):\n        vertex_id = self.pathways[pathway]\n        adjacent = self.vertices[vertex_id].get_adjacent_vertex_ids()\n        adjacent_pathways = []\n        for adjacent_id in adjacent:\n            adjacent_pathways.append(self.get_pathway_from_vertex_id(\n                adjacent_id))\n        return adjacent_pathways", "response": "Get the pathways adjacent to this pathway in the network."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dataframe(self, drop_weights_below=0, whitelist=None):\n        network_df_cols = [\"pw0\", \"pw1\", \"weight\"]\n        if self.features:\n            network_df_cols.append(\"features\")\n        network_df = pd.DataFrame(columns=network_df_cols)\n        idx = 0\n        edge_pathways = set()\n        for (v0, v1), edge_obj in self.edges.items():\n            if (edge_obj.weight > drop_weights_below and\n                    (whitelist is None or (v0, v1) in whitelist)):\n                row = [self.__getitem__(v0),\n                       self.__getitem__(v1),\n                       edge_obj.weight]\n                edge_pathways.add(v0)\n                edge_pathways.add(v1)\n                if self.features:\n                    features = edge_obj.features_to_string()\n                    row.append(features)\n                network_df.loc[idx] = row\n                idx += 1  # faster to append by index.\n        network_df = network_df.sort_values(by=[\"weight\"],\n                                            ascending=False)\n        print(\"The pathway co-occurrence network \"\n              \"contains {0} pathways.\".format(\n                len(edge_pathways)))\n        return network_df", "response": "This method converts the pathway co - occurrence network to a pandas. DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_edge_to_vertex(self, vertex_id, edge):\n        connected_to = edge.connected_to(vertex_id)\n        if vertex_id not in self.vertices:\n            vertex_obj = Vertex(vertex_id)\n            self.vertices[vertex_id] = vertex_obj\n        self.vertices[vertex_id].edges[connected_to] = edge.weight", "response": "Adds the edge to the vertex s edges dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _augment_network(self, edge_dict):\n        for (vertex0, vertex1), feature_list in edge_dict.items():\n            edge_obj = Edge(vertex0, vertex1, feature_list)\n            self.edges[(vertex0, vertex1)] = edge_obj\n            self._add_edge_to_vertex(vertex0, edge_obj)\n            self._add_edge_to_vertex(vertex1, edge_obj)", "response": "Augment the CoNetwork object with the edges from a dictionary of edges."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a dictionary mapping each feature to the pathways overrepresented in the feature build a CoNetwork by creating edges for every pair of pathways in the feature.", "response": "def _edges_from_permutation(self, feature_pathway_dict):\n        \"\"\"Given a dictionary mapping each feature to the pathways\n        overrepresented in the feature, build a CoNetwork by\n        creating edges for every pairwise combination of pathways in a feature.\n        \"\"\"\n        network_edges = {}\n        for feature, pathway_list in feature_pathway_dict.items():\n            for i in range(len(pathway_list)):\n                for j in range(i + 1, len(pathway_list)):\n                    vertex_i = pathway_list[i]\n                    vertex_j = pathway_list[j]\n                    new_edge = self.edge_tuple(vertex_i, vertex_j)\n                    if new_edge not in network_edges:\n                        network_edges[new_edge] = []\n                    network_edges[new_edge].append(feature)\n        self._augment_network(network_edges)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a list of tuples of pathway and feature return a dictionary mapping each feature to the pathways overrepresented in the feature.", "response": "def _collect_pathways_by_feature(self, pathway_feature_tuples):\n        \"\"\"Given a tuple list [(pathway, feature)], create a dictionary\n        mapping each feature to the pathways overrepresented in the feature.\n        \"\"\"\n        pathways_in_feature = {}\n        for (pathway, feature) in pathway_feature_tuples:\n            vertex = self.add_pathway(pathway)\n            if feature not in pathways_in_feature:\n                pathways_in_feature[feature] = []\n            pathways_in_feature[feature].append(vertex)\n        return pathways_in_feature"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnormalizes text when fixed format is ON replace the first 6 chars by a space.", "response": "def normalize_text(self, text):\n        \"\"\"\n        Normalize text, when fixed format is ON, replace the first 6 chars by a space.\n        \"\"\"\n        if not self.editor.free_format:\n            text = ' ' * 6 + text[6:]\n        return text.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating over the health checks of the state.", "response": "async def health_check(cls) -> Iterator[HealthCheckFail]:\n        \"\"\"\n        Perform checks of the state itself. So far:\n\n        - For each method of the class, check for the presence of a\n          health_check() method. If the method is present then call it. This is\n          used to allow the context decorator to make some checks on the\n          structure of the class.\n        \"\"\"\n\n        for k, v in cls.__dict__.items():\n            if hasattr(v, 'health_check') and callable(v.health_check):\n                async for check in v.health_check(cls):\n                    yield check"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_neighborhood_network(self, node_name: str, order: int = 1) -> Graph:\n        logger.info(\"In get_neighborhood_graph()\")\n        neighbors = list(self.get_neighbor_names(node_name, order))\n        neighbor_network = self.graph.copy()\n        neighbor_network.delete_vertices(self.graph.vs.select(name_notin=neighbors))\n        return neighbor_network", "response": "Get the neighborhood graph of a node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_neighbor_names(self, node_name: str, order: int = 1) -> list:\n        logger.info(\"In get_neighbor_names()\")\n        node = self.graph.vs.find(name=node_name)\n        neighbors = self.graph.neighborhood(node, order=order)\n        names = self.graph.vs[neighbors][\"name\"]\n        names.append(node_name)\n        return list(names)", "response": "Get the neighbor names of a node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the intersection of two nodes s neighborhoods.", "response": "def get_neighborhood_overlap(self, node1, node2, connection_type=None):\n        \"\"\"Get the intersection of two nodes's neighborhoods.\n\n        Neighborhood is defined by parameter connection_type.\n        :param Vertex node1: First node.\n        :param Vertex node2: Second node.\n        :param Optional[str] connection_type: One of direct or second-degree. Defaults to direct.\n        :return: Overlap of the nodes' neighborhoods.\n        \"\"\"\n        if connection_type is None or connection_type == \"direct\":\n            order = 1\n        elif connection_type == \"second-degree\":\n            order = 2\n        else:\n            raise Exception(\n                \"Invalid option: {}. Valid options are direct and second-degree\".format(\n                    connection_type)\n            )\n\n        neighbors1 = self.graph.neighborhood(node1, order=order)\n        neighbors2 = self.graph.neighborhood(node2, order=order)\n        return set(neighbors1).intersection(neighbors2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(cls, parser, text, pos):  # pylint: disable=W0613\n        if not text.strip():\n            return text, SyntaxError(\"Invalid value\")\n\n        class Rule(object):\n            grammar = attr('value', SpiresSimpleValue), omit(re.compile(\".*\"))\n\n        try:\n            tree = pypeg2.parse(text, Rule, whitespace=\"\")\n        except SyntaxError:\n            return text, SyntaxError(\"Expected %r\" % cls)\n        else:\n            r = tree.value\n\n        if r.value.lower() in ('and', 'or', 'not'):\n            return text, SyntaxError(\"Invalid value %s\" % r.value)\n\n        return text[len(r.value):], r", "response": "Match simple values excluding some Keywords like and or"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a git command on the shell and returns the output of the command.", "response": "def execute(self, command,\n\t\t\t\tistream=None,\n\t\t\t\twith_keep_cwd=False,\n\t\t\t\twith_extended_output=False,\n\t\t\t\twith_exceptions=True,\n\t\t\t\tas_process=False, \n\t\t\t\toutput_stream=None, \n\t\t\t\t**subprocess_kwargs\n\t\t\t\t):\n\t\t\"\"\"Handles executing the command on the shell and consumes and returns\n\t\tthe returned information (stdout)\n\n\t\t:param command:\n\t\t\tThe command argument list to execute.\n\t\t\tIt should be a string, or a sequence of program arguments. The\n\t\t\tprogram to execute is the first item in the args sequence or string.\n\n\t\t:param istream:\n\t\t\tStandard input filehandle passed to subprocess.Popen.\n\n\t\t:param with_keep_cwd:\n\t\t\tWhether to use the current working directory from os.getcwd().\n\t\t\tThe cmd otherwise uses its own working_dir that it has been initialized\n\t\t\twith if possible.\n\n\t\t:param with_extended_output:\n\t\t\tWhether to return a (status, stdout, stderr) tuple.\n\n\t\t:param with_exceptions:\n\t\t\tWhether to raise an exception when git returns a non-zero status.\n\n\t\t:param as_process:\n\t\t\tWhether to return the created process instance directly from which \n\t\t\tstreams can be read on demand. This will render with_extended_output and \n\t\t\twith_exceptions ineffective - the caller will have \n\t\t\tto deal with the details himself.\n\t\t\tIt is important to note that the process will be placed into an AutoInterrupt\n\t\t\twrapper that will interrupt the process once it goes out of scope. If you \n\t\t\tuse the command in iterators, you should pass the whole process instance \n\t\t\tinstead of a single stream.\n\t\t\t\n\t\t:param output_stream:\n\t\t\tIf set to a file-like object, data produced by the git command will be \n\t\t\toutput to the given stream directly.\n\t\t\tThis feature only has any effect if as_process is False. Processes will\n\t\t\talways be created with a pipe due to issues with subprocess.\n\t\t\tThis merely is a workaround as data will be copied from the \n\t\t\toutput pipe to the given output stream directly.\n\t\t\t\n\t\t:param subprocess_kwargs:\n\t\t\tKeyword arguments to be passed to subprocess.Popen. Please note that \n\t\t\tsome of the valid kwargs are already set by this method, the ones you \n\t\t\tspecify may not be the same ones.\n\t\t\t\n\t\t:return:\n\t\t\t* str(output) if extended_output = False (Default)\n\t\t\t* tuple(int(status), str(stdout), str(stderr)) if extended_output = True\n\t\t\t \n\t\t\tif ouput_stream is True, the stdout value will be your output stream:\n\t\t\t* output_stream if extended_output = False\n\t\t\t* tuple(int(status), output_stream, str(stderr)) if extended_output = True\n\t\t\t\n\t\t:raise GitCommandError:\n\t\t\n\t\t:note:\n\t\t   If you add additional keyword arguments to the signature of this method, \n\t\t   you must update the execute_kwargs tuple housed in this module.\"\"\"\n\t\tif GIT_PYTHON_TRACE and not GIT_PYTHON_TRACE == 'full':\n\t\t\tprint ' '.join(command)\n\n\t\t# Allow the user to have the command executed in their working dir.\n\t\tif with_keep_cwd or self._working_dir is None:\n\t\t  cwd = os.getcwd()\n\t\telse:\n\t\t  cwd=self._working_dir\n\t\t  \n\t\t# Start the process\n\t\tproc = Popen(command,\n\t\t\t\t\t\tcwd=cwd,\n\t\t\t\t\t\tstdin=istream,\n\t\t\t\t\t\tstderr=PIPE,\n\t\t\t\t\t\tstdout=PIPE,\n\t\t\t\t\t\tclose_fds=(os.name=='posix'),# unsupported on linux\n\t\t\t\t\t\t**subprocess_kwargs\n\t\t\t\t\t\t)\n\t\tif as_process:\n\t\t\treturn self.AutoInterrupt(proc, command)\n\t\t\n\t\t# Wait for the process to return\n\t\tstatus = 0\n\t\tstdout_value = ''\n\t\tstderr_value = ''\n\t\ttry:\n\t\t\tif output_stream is None:\n\t\t\t\tstdout_value, stderr_value = proc.communicate() \n\t\t\t\t# strip trailing \"\\n\"\n\t\t\t\tif stdout_value.endswith(\"\\n\"):\n\t\t\t\t\tstdout_value = stdout_value[:-1]\n\t\t\t\tif stderr_value.endswith(\"\\n\"):\n\t\t\t\t\tstderr_value = stderr_value[:-1]\n\t\t\t\tstatus = proc.returncode\n\t\t\telse:\n\t\t\t\tstream_copy(proc.stdout, output_stream, self.max_chunk_size)\n\t\t\t\tstdout_value = output_stream\n\t\t\t\tstderr_value = proc.stderr.read()\n\t\t\t\t# strip trailing \"\\n\"\n\t\t\t\tif stderr_value.endswith(\"\\n\"):\n\t\t\t\t\tstderr_value = stderr_value[:-1]\n\t\t\t\tstatus = proc.wait()\n\t\t\t# END stdout handling\n\t\tfinally:\n\t\t\tproc.stdout.close()\n\t\t\tproc.stderr.close()\n\n\t\tif GIT_PYTHON_TRACE == 'full':\n\t\t\tcmdstr = \" \".join(command)\n\t\t\tif stderr_value:\n\t\t\t\tprint \"%s -> %d; stdout: '%s'; stderr: '%s'\" % (cmdstr, status, stdout_value, stderr_value)\n\t\t\telif stdout_value:\n\t\t\t\tprint \"%s -> %d; stdout: '%s'\" % (cmdstr, status, stdout_value)\n\t\t\telse:\n\t\t\t\tprint \"%s -> %d\" % (cmdstr, status)\n\t\t# END handle debug printing\n\n\t\tif with_exceptions and status != 0:\n\t\t\traise GitCommandError(command, status, stderr_value)\n\n\t\t# Allow access to the command's status code\n\t\tif with_extended_output:\n\t\t\treturn (status, stdout_value, stderr_value)\n\t\telse:\n\t\t\treturn stdout_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms Python style kwargs into git command line options.", "response": "def transform_kwargs(self, **kwargs):\n\t\t\"\"\"Transforms Python style kwargs into git command line options.\"\"\"\n\t\targs = list()\n\t\tfor k, v in kwargs.items():\n\t\t\tif len(k) == 1:\n\t\t\t\tif v is True:\n\t\t\t\t\targs.append(\"-%s\" % k)\n\t\t\t\telif type(v) is not bool:\n\t\t\t\t\targs.append(\"-%s%s\" % (k, v))\n\t\t\telse:\n\t\t\t\tif v is True:\n\t\t\t\t\targs.append(\"--%s\" % dashify(k))\n\t\t\t\telif type(v) is not bool:\n\t\t\t\t\targs.append(\"--%s=%s\" % (dashify(k), v))\n\t\treturn args"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _call_process(self, method, *args, **kwargs):\n\t\t# Handle optional arguments prior to calling transform_kwargs\n\t\t# otherwise these'll end up in args, which is bad.\n\t\t_kwargs = dict()\n\t\tfor kwarg in execute_kwargs:\n\t\t\ttry:\n\t\t\t\t_kwargs[kwarg] = kwargs.pop(kwarg)\n\t\t\texcept KeyError:\n\t\t\t\tpass\n\n\t\t# Prepare the argument list\n\t\topt_args = self.transform_kwargs(**kwargs)\n\t\t\n\t\text_args = self.__unpack_args([a for a in args if a is not None])\n\t\targs = opt_args + ext_args\n\n\t\tcall = [\"git\", dashify(method)]\n\t\tcall.extend(args)\n\n\t\treturn self.execute(call, **_kwargs)", "response": "Execute a git command with the specified arguments and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_object_header(self, ref):\n\t\tcmd = self.__get_persistent_cmd(\"cat_file_header\", \"cat_file\", batch_check=True)\n\t\treturn self.__get_object_header(cmd, ref)", "response": "This method will quickly examine the type and size of the object behind \n enumerated by the given ref."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stream_object_data(self, ref):\n\t\tcmd = self.__get_persistent_cmd(\"cat_file_all\", \"cat_file\", batch=True)\n\t\thexsha, typename, size = self.__get_object_header(cmd, ref)\n\t\treturn (hexsha, typename, size, self.CatFileContentStream(size, cmd.stdout))", "response": "As get_object_header but returns the data as a stream\n\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclean the received COBOL code.", "response": "def _clean_code(code):\n    \"\"\"\n    Cleans the received code (the parser does not like extra spaces not a VALUE\n    statement). Returns the cleaned code as a list of lines.\n\n    :param code: The COBOL code to clean\n\n    :return The list of code lines (cleaned)\n    \"\"\"\n    lines = []\n    # cleanup lines, the parser is very sensitive to extra spaces,...\n    for l in code.splitlines():\n        # remove last .\n        if l.endswith('.'):\n            l = l[:-1]\n        # the parser doe not like VALUE xxx.\n        if \"VALUE\" in l:\n            l = l[:l.find(\"VALUE\")]\n        # the parser does not like extra spaces between \"PIC X(xxx)\" and \".\"\n        indent = len(l) - len(l.lstrip())\n        tokens = l.split(\" \")\n        while \"\" in tokens:\n            tokens.remove(\"\")\n        if tokens and not tokens[-1].endswith(\".\"):\n            tokens[-1] += \".\"\n        lines.append(\" \" * indent + \" \".join(tokens))\n\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the list of pic fields info found in the specified text.", "response": "def get_field_infos(code, free_format):\n    \"\"\"\n    Gets the list of pic fields information from line |start| to line |end|.\n\n    :param code: code to parse\n\n    :returns: the list of pic fields info found in the specified text.\n    \"\"\"\n    offset = 0\n    field_infos = []\n    lines = _clean_code(code)\n\n    previous_offset = 0\n\n    for row in process_cobol(lines, free_format):\n        fi = PicFieldInfo()\n        fi.name = row[\"name\"]\n        fi.level = row[\"level\"]\n        fi.pic = row[\"pic\"]\n        fi.occurs = row[\"occurs\"]\n        fi.redefines = row[\"redefines\"]\n        fi.indexed_by = row[\"indexed_by\"]\n\n        # find item that was redefined and use its offset\n        if fi.redefines:\n            for fib in field_infos:\n                if fib.name == fi.redefines:\n                    offset = fib.offset\n\n        # level 1 should have their offset set to 1\n        if fi.level == 1:\n            offset = 1\n\n        # level 78 have no offset\n        if fi.level == 78:\n            offset = 0\n\n        # level 77 have offset always to 1\n        if fi.level == 77:\n            offset = 1\n\n        # set item offset\n        fi.offset = offset\n\n        # special case: level 88 have the same level as its parent\n        if fi.level == 88:\n            fi.offset = previous_offset\n        else:\n            previous_offset = offset\n\n        field_infos.append(fi)\n\n        # compute offset of next PIC field.\n        if row['pic']:\n            offset += row['pic_info']['length']\n\n    return field_infos"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Elevation of input locations LatLngSet", "response": "def GetElevation(self, LatLngSet, sensor = False):\n        '''Get Elevation of input locations\n        LatLngSet: An coordinate array will be converted to proper location format here\n        \n        Pls refer to the Google Maps Web API for the details of the remained parameters\n        '''\n        \n        locations = []\n        \n        for [lat, lng] in LatLngSet:\n            locations.append(str(lat) + \",\" + str(lng))\n        \n        locations = \"|\".join(locations)\n        \n        params = {\n            'locations': locations,\n            'sensor': str(sensor).lower()\n        }\n\n        if not self.premier:\n            url = self.get_url(params)\n        else:\n            url = self.get_signed_url(params)\n\n        return self.GetService_url(url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a Premier account signed url.", "response": "def get_signed_url(self, params):\n        '''Returns a Premier account signed url.'''\n        params['client'] = self.client_id\n        url_params = {'protocol': self.protocol, 'domain': self.domain,\n                      'service': self.service, 'params': urlencode(params)}\n                      \n        secret = base64.urlsafe_b64decode(self.secret_key)\n        url_params['url_part'] = (\n            '/maps/api/%(service)s/json?%(params)s' % url_params)\n        signature = hmac.new(secret, url_params['url_part'], hashlib.sha1)\n        url_params['signature'] = base64.urlsafe_b64encode(signature.digest())\n\n        return ('%(protocol)s://%(domain)s%(url_part)s'\n                '&signature=%(signature)s' % url_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _determine_case(was_upper, words, string):\n    case_type = 'unknown'\n    if was_upper:\n        case_type = 'upper'\n    elif string.islower():\n        case_type = 'lower'\n    elif len(words) > 0:\n        camel_case = words[0].islower()\n        pascal_case = words[0].istitle() or words[0].isupper()\n\n        if camel_case or pascal_case:\n            for word in words[1:]:\n                c = word.istitle() or word.isupper()\n                camel_case &= c\n                pascal_case &= c\n                if not c:\n                    break\n\n        if camel_case:\n            case_type = 'camel'\n        elif pascal_case:\n            case_type = 'pascal'\n        else:\n            case_type = 'mixed'\n\n    return case_type", "response": "Determines the type of string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetect acronyms by checking against a list of words represented by the range [ s i ).", "response": "def _advanced_acronym_detection(s, i, words, acronyms):\n    \"\"\"\n    Detect acronyms by checking against a list of acronyms.\n\n    Check a run of words represented by the range [s, i].\n    Return last index of new word groups.\n    \"\"\"\n    # Combine each letter into single string.\n    acstr = ''.join(words[s:i])\n\n    # List of ranges representing found acronyms.\n    range_list = []\n    # Set of remaining letters.\n    not_range = set(range(len(acstr)))\n\n    # Search for each acronym in acstr.\n    for acronym in acronyms:\n        # TODO: Sanitize acronyms to include only letters.\n        rac = regex.compile(unicode(acronym))\n\n        # Loop until all instances of the acronym are found,\n        # instead of just the first.\n        n = 0\n        while True:\n            m = rac.search(acstr, n)\n            if not m:\n                break\n\n            a, b = m.start(), m.end()\n            n = b\n\n            # Make sure found acronym doesn't overlap with others.\n            ok = True\n            for r in range_list:\n                if a < r[1] and b > r[0]:\n                    ok = False\n                    break\n\n            if ok:\n                range_list.append((a, b))\n                for j in xrange(a, b):\n                    not_range.remove(j)\n\n    # Add remaining letters as ranges.\n    for nr in not_range:\n        range_list.append((nr, nr + 1))\n\n    # No ranges will overlap, so it's safe to sort by lower bound,\n    # which sort() will do by default.\n    range_list.sort()\n\n    # Remove original letters in word list.\n    for _ in xrange(s, i):\n        del words[s]\n\n    # Replace them with new word grouping.\n    for j in xrange(len(range_list)):\n        r = range_list[j]\n        words.insert(s + j, acstr[r[0]:r[1]])\n\n    return s + len(range_list) - 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetects acronyms based on runs of upper-case letters.", "response": "def _simple_acronym_detection(s, i, words, *args):\n    \"\"\"Detect acronyms based on runs of upper-case letters.\"\"\"\n    # Combine each letter into a single string.\n    acronym = ''.join(words[s:i])\n\n    # Remove original letters in word list.\n    for _ in xrange(s, i):\n        del words[s]\n\n    # Replace them with new word grouping.\n    words.insert(s, ''.join(acronym))\n\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks acronyms against regex.", "response": "def _sanitize_acronyms(unsafe_acronyms):\n    \"\"\"\n    Check acronyms against regex.\n\n    Normalize valid acronyms to upper-case.\n    If an invalid acronym is encountered raise InvalidAcronymError.\n    \"\"\"\n    valid_acronym = regex.compile(u'^[\\p{Ll}\\p{Lu}\\p{Nd}]+$')\n    acronyms = []\n    for a in unsafe_acronyms:\n        if valid_acronym.match(a):\n            acronyms.append(a.upper())\n        else:\n            raise InvalidAcronymError(a)\n    return acronyms"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nnormalizing case of each word to PascalCase.", "response": "def _normalize_words(words, acronyms):\n    \"\"\"Normalize case of each word to PascalCase.\"\"\"\n    for i, _ in enumerate(words):\n        # if detect_acronyms:\n        if words[i].upper() in acronyms:\n            # Convert known acronyms to upper-case.\n            words[i] = words[i].upper()\n        else:\n            # Fallback behavior: Preserve case on upper-case words.\n            if not words[i].isupper():\n                words[i] = words[i].capitalize()\n    return words"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _separate_words(string):\n    words = []\n    separator = \"\"\n\n    # Index of current character. Initially 1 because we don't want to check\n    # if the 0th character is a boundary.\n    i = 1\n    # Index of first character in a sequence\n    s = 0\n    # Previous character.\n    p = string[0:1]\n\n    # Treat an all-caps stringiable as lower-case, so that every letter isn't\n    # counted as a boundary.\n    was_upper = False\n    if string.isupper():\n        string = string.lower()\n        was_upper = True\n\n    # Iterate over each character, checking for boundaries, or places where\n    # the stringiable should divided.\n    while i <= len(string):\n        c = string[i:i + 1]\n\n        split = False\n        if i < len(string):\n            # Detect upper-case letter as boundary.\n            if UPPER.match(c):\n                split = True\n            # Detect transition from separator to not separator.\n            elif NOTSEP.match(c) and SEP.match(p):\n                split = True\n            # Detect transition not separator to separator.\n            elif SEP.match(c) and NOTSEP.match(p):\n                split = True\n        else:\n            # The loop goes one extra iteration so that it can handle the\n            # remaining text after the last boundary.\n            split = True\n\n        if split:\n            if NOTSEP.match(p):\n                words.append(string[s:i])\n            else:\n                # stringiable contains at least one separator.\n                # Use the first one as the stringiable's primary separator.\n                if not separator:\n                    separator = string[s:s + 1]\n\n                # Use None to indicate a separator in the word list.\n                words.append(None)\n                # If separators weren't included in the list, then breaks\n                # between upper-case sequences (\"AAA_BBB\") would be\n                # disregarded; the letter-run detector would count them as one\n                # sequence (\"AAABBB\").\n            s = i\n\n        i += 1\n        p = c\n\n    return words, separator, was_upper", "response": "This function separates the string into a list of words."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_case(string, acronyms=None, preserve_case=False):\n    words, separator, was_upper = _separate_words(string)\n\n    if acronyms:\n        # Use advanced acronym detection with list\n        acronyms = _sanitize_acronyms(acronyms)\n        check_acronym = _advanced_acronym_detection\n    else:\n        acronyms = []\n        # Fallback to simple acronym detection.\n        check_acronym = _simple_acronym_detection\n\n    # Letter-run detector\n\n    # Index of current word.\n    i = 0\n    # Index of first letter in run.\n    s = None\n\n    # Find runs of single upper-case letters.\n    while i < len(words):\n        word = words[i]\n        if word is not None and UPPER.match(word):\n            if s is None:\n                s = i\n        elif s is not None:\n            i = check_acronym(s, i, words, acronyms) + 1\n            s = None\n\n        i += 1\n\n    if s is not None:\n        check_acronym(s, i, words, acronyms)\n\n    # Separators are no longer needed, so they can be removed. They *should*\n    # be removed, since it's supposed to be a *word* list.\n    words = [w for w in words if w is not None]\n\n    # Determine case type.\n    case_type = _determine_case(was_upper, words, string)\n\n    if preserve_case:\n        if was_upper:\n            words = [w.upper() for w in words]\n    else:\n        words = _normalize_words(words, acronyms)\n\n    return words, case_type, separator", "response": "Parses a stringiable into a list of words."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_template(self, name, **kwargs):\n        custom_template = getattr(self, 'template_' + name)\n        if custom_template:\n            return self.render(custom_template, **kwargs)\n        template = TEMPLATES.get(name)\n        return self.default_render(template, **kwargs)", "response": "Render a template with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_email(self, user, subject, msg):\n        print('To:', user)\n        print('Subject:', subject)\n        print(msg)", "response": "Send an email to the specified user."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the dictionary with the new data.", "response": "def update(self, new_data: IntentDict):\n        \"\"\"\n        Receive an update from the loaders.\n        \"\"\"\n\n        for locale, data in new_data.items():\n            if locale not in self.dict:\n                self.dict[locale] = {}\n\n            self.dict[locale].update(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, key: Text, locale: Optional[Text]) -> List[Tuple[Text, ...]]:\n\n        locale = self.choose_locale(locale)\n\n        return self.dict[locale][key]", "response": "Get a single set of intents."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def strings(self, request: Optional['Request']=None) \\\n            -> List[Tuple[Text, ...]]:\n        \"\"\"\n        For the given request, find the list of strings of that intent. If the\n        intent does not exist, it will raise a KeyError.\n        \"\"\"\n\n        if request:\n            locale = await request.get_locale()\n        else:\n            locale = None\n\n        return self.db.get(self.key, locale)", "response": "Returns the list of strings for the given intent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of valid standard names that are allowed to be unitless", "response": "def get_unitless_standard_names():\n    '''\n    Returns a list of valid standard_names that are allowed to be unitless\n    '''\n    global _UNITLESS_DB\n    if _UNITLESS_DB is None:\n        with open(resource_filename('cc_plugin_ncei', 'data/unitless.json'), 'r') as f:\n            _UNITLESS_DB = json.load(f)\n    return _UNITLESS_DB"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sea_names():\n    '''\n    Returns a list of NODC sea names\n\n    source of list: http://www.nodc.noaa.gov/General/NODC-Archive/seanames.xml\n    '''\n    global _SEA_NAMES\n    if _SEA_NAMES is None:\n        resource_text = get_data(\"cc_plugin_ncei\", \"data/seanames.xml\")\n        parser = etree.XMLParser(remove_blank_text=True)\n        root = etree.fromstring(resource_text, parser)\n        buf = {}\n        for seaname in root.findall('seaname'):\n            name = seaname.find('seaname').text\n            buf[name] = seaname.find('seacode').text if seaname.find('seacode') is not None else 'N/A'\n\n        _SEA_NAMES = buf\n    return _SEA_NAMES", "response": "Returns a list of NODC sea names available in the NODC - Archive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true if the dataset s variable is likely a geophysical variable", "response": "def is_geophysical(ds, variable):\n    '''\n    Returns true if the dataset's variable is likely a geophysical variable\n    '''\n    ncvar = ds.variables[variable]\n    # Does it have a standard name and units?\n    standard_name = getattr(ncvar, 'standard_name', '')\n    if not standard_name:\n        return False\n    if standard_name and standard_name not in get_unitless_standard_names():\n        units = getattr(ncvar, 'units', '')\n        if units == '':\n            return False\n    if not hasattr(ncvar, 'standard_name') or not hasattr(ncvar, 'units'):\n        return False\n    if getattr(ncvar, 'standard_name') in ('time', 'latitude', 'longitude', 'height', 'depth', 'altitude'):\n        return False\n    # Is it dimensionless?\n    if len(ncvar.shape) == 0:\n        return False\n    # Is it a QC Flag?\n    if 'status_flag' in ncvar.standard_name:\n        return False\n\n    if getattr(ncvar, 'cf_role', None):\n        return False\n\n    if getattr(ncvar, 'axis', None):\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_z_variable(nc):\n    '''\n    Returns the name of the variable that defines the Z axis or height/depth\n\n    :param netCDF4.Dataset nc: netCDF dataset\n    '''\n    axis_z = nc.get_variables_by_attributes(axis='Z')\n    if axis_z:\n        return axis_z[0].name\n    valid_standard_names = ('depth', 'height', 'altitude')\n    z = nc.get_variables_by_attributes(standard_name=lambda x: x in valid_standard_names)\n    if z:\n        return z[0].name\n    return", "response": "Returns the name of the variable that defines the Z axis or height or depth or altitude."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the variable for latitude", "response": "def get_lat_variable(nc):\n    '''\n    Returns the variable for latitude\n\n    :param netcdf4.dataset nc: an open netcdf dataset object\n    '''\n    if 'latitude' in nc.variables:\n        return 'latitude'\n    latitudes = nc.get_variables_by_attributes(standard_name=\"latitude\")\n    if latitudes:\n        return latitudes[0].name\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lon_variable(nc):\n    '''\n    Returns the variable for longitude\n\n    :param netCDF4.Dataset nc: netCDF dataset\n    '''\n    if 'longitude' in nc.variables:\n        return 'longitude'\n    longitudes = nc.get_variables_by_attributes(standard_name=\"longitude\")\n    if longitudes:\n        return longitudes[0].name\n    return None", "response": "Returns the variable for longitude\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_time_variable(ds):\n    '''\n    Returns the likeliest variable to be the time coordiante variable\n\n    :param netCDF4.Dataset ds: An open netCDF4 Dataset\n    '''\n    for var in ds.variables:\n        if getattr(ds.variables[var], 'axis', '') == 'T':\n            return var\n    else:\n        candidates = ds.get_variables_by_attributes(standard_name='time')\n        if len(candidates) == 1:\n            return candidates[0].name\n        else:  # Look for a coordinate variable time\n            for candidate in candidates:\n                if candidate.dimensions == (candidate.name,):\n                    return candidate.name\n\n    return None", "response": "Returns the likeliest variable to be the time coordiante variable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the name of the variable identified by a grid_mapping attribute", "response": "def get_crs_variable(ds):\n    '''\n    Returns the name of the variable identified by a grid_mapping attribute\n\n    :param netCDF4.Dataset ds: An open netCDF4 Dataset\n    '''\n    for var in ds.variables:\n        grid_mapping = getattr(ds.variables[var], 'grid_mapping', '')\n        if grid_mapping and grid_mapping in ds.variables:\n            return grid_mapping\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_timeseries(nc, variable):\n    '''\n    Returns true if the variable is a time series feature type.\n\n    :param netCDF4.Dataset nc: An open netCDF dataset\n    :param str variable: name of the variable to check\n    '''\n\n    # x, y, z, t(o)\n    # X(o)\n    dims = nc.variables[variable].dimensions\n\n    cmatrix = coordinate_dimension_matrix(nc)\n    for req in ('x', 'y', 't'):\n        if req not in cmatrix:\n            return False\n    if len(cmatrix['x']) != 0:\n        return False\n    if len(cmatrix['y']) != 0:\n        return False\n    if 'z' in cmatrix and len(cmatrix['z']) != 0:\n        return False\n    timevar = get_time_variable(nc)\n\n    # time has to be a coordinate variable in this case\n    if cmatrix['t'] != (timevar,):\n        return False\n    if dims == cmatrix['t']:\n        return True\n    return False", "response": "Returns true if the variable is a time series feature type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_single_trajectory(nc, variable):\n    '''\n    Returns true if the variable is a single trajectory feature\n\n    :param netCDF4.Dataset nc: An open netCDF dataset\n    :param str variable: name of the variable to check\n    '''\n    # x(t), y(t), z(t), t(t)\n    # X(t)\n    dims = nc.variables[variable].dimensions\n    cmatrix = coordinate_dimension_matrix(nc)\n\n    for req in ('x', 'y', 't'):\n        if req not in cmatrix:\n            return False\n    t = get_time_variable(nc)\n    if cmatrix['x'] != (t,):\n        return False\n    if cmatrix['x'] != cmatrix['y']:\n        return False\n    if cmatrix['x'] != cmatrix['t']:\n        return False\n    if 'z' in cmatrix and cmatrix['x'] != cmatrix['z']:\n        return False\n    if dims == cmatrix['x']:\n        return True\n    return False", "response": "Returns true if the variable is a single trajectory feature"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_2d_regular_grid(nc, variable):\n    '''\n    Returns True if the variable is a 2D Regular grid.\n\n    :param netCDF4.Dataset nc: An open netCDF dataset\n    :param str variable: name of the variable to check\n    '''\n    # x(x), y(y), t(t)\n    # X(t, y, x)\n\n    dims = nc.variables[variable].dimensions\n\n    cmatrix = coordinate_dimension_matrix(nc)\n\n    for req in ('x', 'y', 't'):\n        if req not in cmatrix:\n            return False\n\n    x = get_lon_variable(nc)\n    y = get_lat_variable(nc)\n    t = get_time_variable(nc)\n\n    if cmatrix['x'] != (x,):\n        return False\n    if cmatrix['y'] != (y,):\n        return False\n    if cmatrix['t'] != (t,):\n        return False\n\n    # Relaxed dimension ordering\n    if len(dims) == 3 and x in dims and y in dims and t in dims:\n        return True\n    return False", "response": "Returns True if the variable is a 2D Regular grid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_read(repo, **kwargs):\n    log.info('read: %s %s' %(repo, kwargs))\n    if type(repo) in [unicode, str]:\n        return {'name': 'Repo', 'desc': 'Welcome to Grit', 'comment': ''}\n    else:\n        return repo.serialize()", "response": "handles reading repo information"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles a new file.", "response": "def handle_new(path, **kwargs):\n    \"\"\":return: new repo.Local instance\"\"\"\n    log.info('new: %s %s' %(path, kwargs))\n    repo = Local.new(path=path, **kwargs)\n    return repo.serialize()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_tags(repo, **kwargs):\n    log.info('tags: %s %s' %(repo, kwargs))\n    return [str(t) for t in repo.tags(**kwargs)]", "response": "Returns a list of tags from a repository"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling versions of the repository.", "response": "def handle_versions(repo, **kwargs):\n    \"\"\":return: repo.versions()\"\"\"\n    log.info('versions: %s %s' %(repo, kwargs))\n    if not hasattr(repo, 'versions'):\n        return []\n    return [v.serialize() for v in repo.versions(**kwargs)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a submodule to the current node.", "response": "def handle_addSubmodule(repo, **kwargs):\n    \"\"\":return: repo.addSubmodule()\"\"\"\n    log.info('addSubmodule: %s %s' %(repo, kwargs))\n    try:\n        proxy = repo.addSubmodule(**kwargs)\n        return [serialize(proxy, type='submodule', url=proxy.url)]\n    except RepoError, e:\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_addVersion(repo, **kwargs):\n    log.info('addVersion: %s %s' %(repo, kwargs))\n    try:\n        v = repo.addVersion(**kwargs)\n        return v.serialize()\n    except RepoError, e:\n        raise", "response": "Add a version to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_upload(repo, **kwargs):\n    log.info('upload: %s' %(repo))\n    name = kwargs.get('filename', 'Untitled')\n    data = kwargs.get('filedata')\n    repo.addItem(Item.from_string(repo=repo, name=name, string=data))", "response": "Handle an upload of a file to a node"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dict_from_object(obj: object):\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "response": "Convert a object into dictionary with all of its readable attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef xgetattr(obj: object, name: str, default=_sentinel, getitem=False):\n\n    if isinstance(obj, dict):\n        if getitem:\n            # In tune with `dict.__getitem__` method.\n            return obj[name]\n        else:\n            # In tune with `dict.get` method.\n            val = obj.get(name, default)\n            return None if val is _sentinel else val\n    else:\n        # If object is not a dict, in tune with `getattr` method.\n        val = getattr(obj, name, default)\n        if val is _sentinel:\n            msg = '%r object has no attribute %r' % (obj.__class__, name)\n            raise AttributeError(msg)\n        else:\n            return val", "response": "Get attribute value from object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_config_files() -> List[Text]:\n\n    return [\n        os.path.join(os.path.dirname(__file__), 'default_settings.py'),\n        os.getenv(ENVIRONMENT_VARIABLE, ''),\n    ]", "response": "This function returns the list of configuration files that can be loaded from the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef camel_to_snake_case(name):\n    pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])'\n    return '_'.join(map(str.lower, re.findall(pattern, name)))", "response": "Takes a camelCased string and converts to snake_case."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the text only contains paired or paired.", "response": "def is_paired(text, open='(', close=')'):\n    \"\"\"Check if the text only contains:\n    1. blackslash escaped parentheses, or\n    2. parentheses paired.\n    \"\"\"\n    count = 0\n    escape = False\n    for c in text:\n        if escape:\n            escape = False\n        elif c == '\\\\':\n            escape = True\n        elif c == open:\n            count += 1\n        elif c == close:\n            if count == 0:\n                return False\n            count -= 1\n    return count == 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the line starts with given prefix and return the position of the end of the prefix.", "response": "def match_prefix(prefix, line):\n        \"\"\"Check if the line starts with given prefix and\n        return the position of the end of prefix.\n        If the prefix is not matched, return -1.\n        \"\"\"\n        m = re.match(prefix, line.expandtabs(4))\n        if not m:\n            if re.match(prefix, line.expandtabs(4).replace('\\n', ' ' * 99 + '\\n')):\n                return len(line) - 1\n            return -1\n        pos = m.end()\n        if pos == 0:\n            return 0\n        for i in range(1, len(line) + 1):\n            if len(line[:i].expandtabs(4)) >= pos:\n                return i"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests against the given regular expression and returns the match object.", "response": "def expect_re(self, regexp):\n        \"\"\"Test against the given regular expression and returns the match object.\n\n        :param regexp: the expression to be tested.\n        :returns: the match object.\n        \"\"\"\n        prefix_len = self.match_prefix(\n            self.prefix, self.next_line(require_prefix=False)\n        )\n        if prefix_len >= 0:\n            match = self._expect_re(regexp, self.pos + prefix_len)\n            self.match = match\n            return match\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next_line(self, require_prefix=True):\n        if require_prefix:\n            m = self.expect_re(r'(?m)[^\\n]*?$\\n?')\n        else:\n            m = self._expect_re(r'(?m)[^\\n]*$\\n?', self.pos)\n        self.match = m\n        if m:\n            return m.group()", "response": "Return the next line in the source."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconsume the body of source.", "response": "def consume(self):\n        \"\"\"Consume the body of source. ``pos`` will move forward.\"\"\"\n        if self.match:\n            self.pos = self.match.end()\n            if self.match.group()[-1] == '\\n':\n                self._update_prefix()\n            self.match = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _py_read1(fileObj, maxBuffer):\n    '''\n        _py_read1 - Pure python version of \"read1\", which allows non-blocking I/O on a potentially unfinished or  non-newline-ending stream. \n\n        @param maxBuffer - Max buffer size\n\n        @return - All data available on stream, regardless of newlines\n    '''\n    i = 0\n    ret = []\n    while i < maxBuffer:\n        c = fileObj.read(1)\n        if c == '':\n            # Stream has been closed\n            break\n        i += 1\n        ret.append(c)\n        # Use a very low timeout so we only grab more data if it's immediately available.\n        (readyToRead, junk1, junk2) = select.select([fileObj], [], [], .00001)\n        if not readyToRead:\n            break\n\n    return ''.join(ret)", "response": "Internal function for reading from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef asDict(self):\n        '''\n            asDict - Returns a copy of the current state as a dictionary. This copy will not be updated automatically.\n\n            @return <dict> - Dictionary with all fields in BackgroundTaskInfo.FIELDS\n        '''\n        ret = {}\n        for field in BackgroundTaskInfo.FIELDS:\n            ret[field] = getattr(self, field)\n        return ret", "response": "Returns a copy of the current state as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwait until the current process completes.", "response": "def waitToFinish(self, timeout=None, pollInterval=.1):\n        '''\n            waitToFinish - Wait (Block current thread), optionally with a timeout, until background task completes.\n\n            @param timeout <None/float> - None to wait forever, otherwise max number of seconds to wait\n            @param pollInterval <float> - Seconds between each poll. Keep high if interactivity is not important, low if it is.\n\n            @return - None if process did not complete (and timeout occured), otherwise the return code of the process is returned.\n        '''\n        if timeout is None:\n            while self.isFinished is False:\n                time.sleep(pollInterval)\n        else:\n            sleptFor = 0\n            while self.isFinished is False and sleptFor < timeout:\n                time.sleep(pollInterval)\n                sleptFor += pollInterval\n\n        return self.returnCode"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register(name, _callable=None):\n    def wrapper(_callable):\n        registered_checks[name] = _callable\n        return _callable\n\n    # If function or class is given, do the registeration\n    if _callable:\n        return wrapper(_callable)\n\n    return wrapper", "response": "A decorator used for registering a custom check."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the message dictionary for the current message.", "response": "def serialize(self):\n        \"\"\"\n        Generates the messaging-type-related part of the message dictionary.\n        \"\"\"\n\n        if self.response is not None:\n            return {'messaging_type': 'RESPONSE'}\n\n        if self.update is not None:\n            return {'messaging_type': 'UPDATE'}\n\n        if self.tag is not None:\n            return {\n                'messaging_type': 'MESSAGE_TAG',\n                'tag': self.tag.value,\n            }\n\n        if self.subscription is not None:\n            return {'messaging_type': 'NON_PROMOTIONAL_SUBSCRIPTION'}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def patch_register(self, register: Dict, request: 'Request'):\n\n        register['choices'] = {\n            o.slug: {\n                'intent': o.intent.key if o.intent else None,\n                'text': await render(o.text, request),\n            } for o in self.options\n            if isinstance(o, QuickRepliesList.TextOption)\n        }\n\n        return register", "response": "Patch the register with all options in the choices sub - register."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nam sharable if the tag is marked as and all buttons are sharable.", "response": "def is_sharable(self):\n        \"\"\"\n        Is sharable if marked as and if buttons are sharable (they might\n        hold sensitive data).\n        \"\"\"\n        return self.sharable and all(x.is_sharable() for x in self.buttons)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_sharable(self):\n        return bool(\n            self.sharable and\n            all(x.is_sharable() for x in self.elements)\n        )", "response": "Returns True if this entry is not sharable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tuple of all the values of this Enum", "response": "def values(cls):\n        \"\"\"\n        \n        Returns\n        -------\n        tuple\n            of all the values of this Enum\n        \n        \"\"\"\n        if not hasattr(cls, '__values_'):\n            cls.__values_ = tuple([c.value for c in list(cls)])\n        return cls.__values_"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the maximum length of the value of the key - value pairs in the database.", "response": "def max_value_length(cls):\n        \"\"\"\n        Not to be used when using numeric values.\n        \n        Returns\n        -------\n        int\n            the maximal length required by this Enum to be stored in the database\n\n        \"\"\"\n        if not hasattr(cls, '__max_value_length_'):\n            cls.__max_value_length_ = max([len(c.value) for c in list(cls)])\n        return cls.__max_value_length_"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef choices(cls):\n        # \"natural\" order, aka as given when instantiating\n        if not hasattr(cls, '__choices_'):\n            cls.__choices_ = tuple([c.choice for c in list(cls)])\n        return cls.__choices_", "response": "Generate the choices as required by Django models.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the object associated with this value if any.", "response": "def from_value(cls, value):\n        \"\"\"\n        Return the EChoice object associated with this value, if any.\n\n        Parameters\n        ----------\n        value\n            In the type of the `value` field, as set when instantiating this EChoice.\n\n        Returns\n        -------\n        EChoice\n\n        Raises\n        ------\n        KeyError\n            if `value` does not exist in any element\n\n        \"\"\"\n        warnings.warn(\"{0}.{1} will be deprecated in a future release. \"\n                      \"Please use {0}.{2} instead\".format(cls.__name__, cls.from_value.__name__, cls.get.__name__),\n                      PendingDeprecationWarning)\n        return cls[value]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef choices(cls, order='natural'):\n        INC, DEC, NAT = 'sorted', 'reverse', 'natural'\n        options = [INC, DEC, NAT]\n        assert order in options, \"Sorting order not recognized: {}. Available options are: {}\".format(order, options)\n        if order in [INC, DEC]:\n            reverse = order == DEC\n            if reverse:\n                attr = '__choices_reverse_'\n            else:\n                attr = '__choices_sorted_'\n            if not hasattr(cls, attr):\n                setattr(cls, attr, tuple([(c.value, c.label) for c in sorted(list(cls), reverse=reverse)]))\n            return getattr(cls, attr)\n        else:\n            return super(EOrderedChoice, cls).choices()", "response": "Generate the choices as required by Django models."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_edit(self, arg, arguments):\n\n        def _create_file(filename):\n            if not os.path.exists(filename):\n                file(filename, 'w+').close()\n\n        def _edit(prefix, editors, filename):\n            for editor in editors:\n                if os.path.exists(editor):\n                    _create_file(filename)\n                    os.system(\"{:} {:} {:}\".format(prefix, editor, filename))\n                    return True\n            return False\n\n\n        filename = arg\n\n        what =  platform.system().lower()\n        prefix = \"\"\n\n        print (what)\n        if 'darwin' in what:\n\n            editors = [\"/Applications/Aquamacs.app\",\n                       \"/Applications/Emacs.app\"]\n            prefix = \"open -a \"\n\n        elif \"linux\" in what:\n\n            editors = [\"/usr/bin/emacs\",\n                       \"/usr/bin/vi\",\n                       \"/usr/bin/vim\",\n                       \"/usr/bin/nano\"]\n\n        elif \"windows\" in what:\n\n            editors = [\"emacs\",\n                       \"vi\",\n                       \"vim\",\n                       \"nano\",\n                       \"notepad\",\n                       \"notepad++\"]\n\n        else:\n            Console.error(\"Please contact the developers to add an \"\n                          \"editor for your platform\")\n            return\n\n        if not _edit(prefix, editors, filename):\n            Console.error(\"Could not find working editor in {0}\"\n                          .format(str(editors)))", "response": "Edit the file with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nauthenticates the users based on the query-string-provided token", "response": "def bernard_auth(func):\n    \"\"\"\n    Authenticates the users based on the query-string-provided token\n    \"\"\"\n\n    @wraps(func)\n    async def wrapper(request: Request):\n        def get_query_token():\n            token_key = settings.WEBVIEW_TOKEN_KEY\n            return request.query.get(token_key, '')\n\n        def get_header_token():\n            header_key = settings.WEBVIEW_HEADER_NAME\n            return request.headers.get(header_key, '')\n\n        try:\n            token = next(filter(None, [\n                get_header_token(),\n                get_query_token(),\n            ]))\n        except StopIteration:\n            token = ''\n\n        try:\n            body = await request.json()\n        except ValueError:\n            body = None\n\n        msg, platform = await manager.message_from_token(token, body)\n\n        if not msg:\n            return json_response({\n                'status': 'unauthorized',\n                'message': 'No valid token found',\n            }, status=401)\n\n        return await func(msg, platform)\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding the front - end with details about the user.", "response": "async def postback_me(msg: BaseMessage, platform: Platform) -> Response:\n    \"\"\"\n    Provides the front-end with details about the user. This output can be\n    completed using the `api_postback_me` middleware hook.\n    \"\"\"\n\n    async def get_basic_info(_msg: BaseMessage, _platform: Platform):\n        user = _msg.get_user()\n\n        return {\n            'friendly_name': await user.get_friendly_name(),\n            'locale': await user.get_locale(),\n            'platform': _platform.NAME,\n        }\n\n    func = MiddlewareManager.instance().get('api_postback_me', get_basic_info)\n\n    return json_response(await func(msg, platform))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a message to the FSM as a Postback message.", "response": "async def postback_send(msg: BaseMessage, platform: Platform) -> Response:\n    \"\"\"\n    Injects the POST body into the FSM as a Postback message.\n    \"\"\"\n\n    await platform.inject_message(msg)\n\n    return json_response({\n        'status': 'ok',\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def postback_analytics(msg: BaseMessage, platform: Platform) -> Response:\n\n    try:\n        pb = msg.get_layers()[0]\n        assert isinstance(pb, Postback)\n\n        user = msg.get_user()\n        user_lang = await user.get_locale()\n        user_id = user.id\n\n        if pb.payload['event'] == 'page_view':\n            func = 'page_view'\n            path = pb.payload['path']\n            title = pb.payload.get('title', '')\n            args = [path, title, user_id, user_lang]\n        else:\n            return json_response({\n                'status': 'unknown event',\n                'message': f'\"{pb.payload[\"event\"]}\" is not a recognized '\n                           f'analytics event',\n            })\n\n        async for p in providers():\n            await getattr(p, func)(*args)\n\n    except (KeyError, IndexError, AssertionError, TypeError):\n        return json_response({\n            'status': 'missing data'\n        }, status=400)\n\n    else:\n        return json_response({\n            'status': 'ok',\n        })", "response": "Makes a call to an analytics function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef column_name(self, source, allele_group):\n        return self.column_format.format(\n            source=source,\n            allele_group=allele_group)", "response": "Returns the column name of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions or decorator which registers a given function as a recognized control command.", "response": "def register(name, func=None):\n    \"\"\"\n    Function or decorator which registers a given function as a\n    recognized control command.\n    \"\"\"\n\n    def decorator(func):\n        # Perform the registration\n        ControlDaemon._register(name, func)\n        return func\n\n    # If func was given, call the decorator, otherwise, return the\n    # decorator\n    if func:\n        return decorator(func)\n    else:\n        return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ping(daemon, channel, data=None):\n\n    if not channel:\n        # No place to reply to\n        return\n\n    # Get our configured node name\n    node_name = daemon.config['control'].get('node_name')\n\n    # Format the response\n    reply = ['pong']\n    if node_name or data:\n        reply.append(node_name or '')\n    if data:\n        reply.append(data)\n\n    # And send it\n    with utils.ignore_except():\n        daemon.db.publish(channel, ':'.join(reply))", "response": "Process the ping message and send it to the named channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses the reload message.", "response": "def reload(daemon, load_type=None, spread=None):\n    \"\"\"\n    Process the 'reload' control message.\n\n    :param daemon: The control daemon; used to get at the\n                   configuration and call the actual reload.\n    :param load_type: Optional type of reload.  If given as\n                      'immediate', reload is triggered\n                      immediately.  If given as 'spread', reload\n                      is triggered after a random period of time\n                      in the interval (0.0, spread).  Otherwise,\n                      reload will be as configured.\n    :param spread: Optional argument for 'spread' load_type.  Must\n                   be a float giving the maximum length of the\n                   interval, in seconds, over which the reload\n                   should be scheduled.  If not provided, falls\n                   back to configuration.\n\n    If a recognized load_type is not given, or is given as\n    'spread' but the spread parameter is not a valid float, the\n    configuration will be checked for the 'redis.reload_spread'\n    value.  If that is a valid value, the reload will be randomly\n    scheduled for some time within the interval (0.0,\n    redis.reload_spread).\n    \"\"\"\n\n    # Figure out what type of reload this needs to be\n    if load_type == 'immediate':\n        spread = None\n    elif load_type == 'spread':\n        try:\n            spread = float(spread)\n        except (TypeError, ValueError):\n            # Not a valid float; use the configured spread value\n            load_type = None\n    else:\n        load_type = None\n\n    if load_type is None:\n        # Use configured set-up; see if we have a spread\n        # configured\n        try:\n            spread = float(daemon.config['control']['reload_spread'])\n        except (TypeError, ValueError, KeyError):\n            # No valid configuration\n            spread = None\n\n    if spread:\n        # Apply a randomization to spread the load around\n        eventlet.spawn_after(random.random() * spread, daemon.reload)\n    else:\n        # Spawn in immediate mode\n        eventlet.spawn_n(daemon.reload)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the limit data to the given list of limits.", "response": "def set_limits(self, limits):\n        \"\"\"\n        Set the limit data to the given list of limits.  Limits are\n        specified as the raw msgpack string representing the limit.\n        Computes the checksum of the limits; if the checksum is\n        identical to the current one, no action is taken.\n        \"\"\"\n\n        # First task, build the checksum of the new limits\n        chksum = hashlib.md5()  # sufficient for our purposes\n        for lim in limits:\n            chksum.update(lim)\n        new_sum = chksum.hexdigest()\n\n        # Now install it\n        with self.limit_lock:\n            if self.limit_sum == new_sum:\n                # No changes\n                return\n            self.limit_data = [msgpack.loads(lim) for lim in limits]\n            self.limit_sum = new_sum"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_limits(self, limit_sum=None):\n\n        with self.limit_lock:\n            # Any changes?\n            if limit_sum and self.limit_sum == limit_sum:\n                raise NoChangeException()\n\n            # Return a tuple of the limits and limit sum\n            return (self.limit_sum, self.limit_data)", "response": "Gets the current limit data if it is different from the current limit data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart the ControlDaemon by launching the listening thread and then reloading the initial load.", "response": "def start(self):\n        \"\"\"\n        Starts the ControlDaemon by launching the listening thread and\n        triggering the initial limits load.\n        \"\"\"\n\n        # Spawn the listening thread\n        self.listen_thread = eventlet.spawn_n(self.listen)\n\n        # Now do the initial load\n        self.reload()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlisten for incoming control messages.", "response": "def listen(self):\n        \"\"\"\n        Listen for incoming control messages.\n\n        If the 'redis.shard_hint' configuration is set, its value will\n        be passed to the pubsub() method when setting up the\n        subscription.  The control channel to subscribe to is\n        specified by the 'redis.control_channel' configuration\n        ('control' by default).\n        \"\"\"\n\n        # Use a specific database handle, with override.  This allows\n        # the long-lived listen thread to be configured to use a\n        # different database or different database options.\n        db = self.config.get_database('control')\n\n        # Need a pub-sub object\n        kwargs = {}\n        if 'shard_hint' in self.config['control']:\n            kwargs['shard_hint'] = self.config['control']['shard_hint']\n        pubsub = db.pubsub(**kwargs)\n\n        # Subscribe to the right channel(s)...\n        channel = self.config['control'].get('channel', 'control')\n        pubsub.subscribe(channel)\n\n        # Now we listen...\n        for msg in pubsub.listen():\n            # Only interested in messages to our reload channel\n            if (msg['type'] in ('pmessage', 'message') and\n                    msg['channel'] == channel):\n                # Figure out what kind of message this is\n                command, _sep, args = msg['data'].partition(':')\n\n                # We must have some command...\n                if not command:\n                    continue\n\n                # Don't do anything with internal commands\n                if command[0] == '_':\n                    LOG.error(\"Cannot call internal command %r\" % command)\n                    continue\n\n                # Look up the command\n                if command in self._commands:\n                    func = self._commands[command]\n                else:\n                    # Try an entrypoint\n                    func = utils.find_entrypoint('turnstile.command', command,\n                                                 compat=False)\n                    self._commands[command] = func\n\n                # Don't do anything with missing commands\n                if not func:\n                    LOG.error(\"No such command %r\" % command)\n                    continue\n\n                # Execute the desired command\n                arglist = args.split(':') if args else []\n                try:\n                    func(self, *arglist)\n                except Exception:\n                    LOG.exception(\"Failed to execute command %r arguments %r\" %\n                                  (command, arglist))\n                    continue"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reload(self):\n\n        # Acquire the pending semaphore.  If we fail, exit--someone\n        # else is already doing the reload\n        if not self.pending.acquire(False):\n            return\n\n        # Do the remaining steps in a try/finally block so we make\n        # sure to release the semaphore\n        control_args = self.config['control']\n        try:\n            # Load all the limits\n            key = control_args.get('limits_key', 'limits')\n            self.limits.set_limits(self.db.zrange(key, 0, -1))\n        except Exception:\n            # Log an error\n            LOG.exception(\"Could not load limits\")\n\n            # Get our error set and publish channel\n            error_key = control_args.get('errors_key', 'errors')\n            error_channel = control_args.get('errors_channel', 'errors')\n\n            # Get an informative message\n            msg = \"Failed to load limits: \" + traceback.format_exc()\n\n            # Store the message into the error set.  We use a set here\n            # because it's likely that more than one node will\n            # generate the same message if there is an error, and this\n            # avoids an explosion in the size of the set.\n            with utils.ignore_except():\n                self.db.sadd(error_key, msg)\n\n            # Publish the message to a channel\n            with utils.ignore_except():\n                self.db.publish(error_channel, msg)\n        finally:\n            self.pending.release()", "response": "Reloads the limits configuration from the database and publishes the message to the error set."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a handle for the database.", "response": "def db(self):\n        \"\"\"\n        Obtain a handle for the database.  This allows lazy\n        initialization of the database handle.\n        \"\"\"\n\n        # Initialize the database handle from the middleware's copy of\n        # it\n        if not self._db:\n            self._db = self.middleware.db\n\n        return self._db"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_header(request, header_service):\n    service = request.META.get('HTTP_{}'.format(header_service), b'')\n    if isinstance(service, str):\n        # Work around django test client oddness\n        service = service.encode(HTTP_HEADER_ENCODING)\n    return service", "response": "Return request s X_POLYAXON_... : header as a bytestring."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nenforce a policy to a API.", "response": "def enforce_policy(rule):\n    \"\"\"Enforce a policy to a API.\"\"\"\n    def wrapper(func):\n        \"\"\"Decorator used for wrap API.\"\"\"\n        @functools.wraps(func)\n        def wrapped(*args, **kwargs):\n            if enforcer.enforce(rule, {}, g.cred):\n                return func(*args, **kwargs)\n\n        return wrapped\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_for_bottle(\n        auth, app, send_email=None, render=None,\n        session=None, request=None, urloptions=None):\n    import bottle\n\n    auth.request = request or bottle.request\n    if session is not None:\n        auth.session = session\n    if send_email:\n        auth.send_email = send_email\n\n    auth.render = render or bottle.template\n    bottle.BaseTemplate.defaults['csrf_token'] = auth.get_csrf_token\n    bottle.BaseTemplate.defaults['auth'] = auth\n\n    \"\"\"\n    Set the session **before** calling ``setup_for_bottle`` like this:\n\n        @hook('before_request')\n        def setup_request():\n            request.session = request.environ['beaker.session']\n    \"\"\"\n\n    @bottle.hook('before_request')\n    def after_request():\n        auth.session = session or getattr(bottle.request, 'session') \\\n            or bottle.request.environ.get('beaker.session')\n        assert auth.session, 'Session not found'\n\n        # By doing this, ``bottle.request`` now has a ``user`` attribute\n        # that it's replaced by the real user object the first time is used.\n        LazyUser(auth, bottle.request, user_name=auth.user_name)\n\n    if auth.views:\n        assert auth.render\n        setup_for_bottle_views(auth, app, urloptions)", "response": "Setup bottle for the given application."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self):\n        if not isinstance(self.config_text, str):\n            self.config_text = self.config_text.decode('utf-8')\n\n        if not self.config_text.strip():\n            self._errors.append(ConfigError(title='YAML is empty', description='Your configuration file appears to be empty.'))\n            return\n\n        # simple way to check that yaml itself is valid\n        try:\n            self.config_dict = yaml.safe_load(self.config_text)\n        except yaml.YAMLError as e:\n            error = ConfigError.create_from_yaml_error(e)\n            self._errors.append(error)\n            # could have more than 1 line, keep giong\n\n        if self.config_dict:\n            # we have valid yaml with data, so start checking the components\n            node_tree = yaml.compose(self.config_text)\n            # give it the parsed settings, and the node info\n            self.config_root = self.config_root_class(\n                value=self.config_dict,\n                value_node=node_tree,\n                context=self.context,\n                variables=self.variables,\n            )", "response": "loads the configuration file into memory"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize a new connection to the Redis database.", "response": "def initialize(config):\n    \"\"\"\n    Initialize a connection to the Redis database.\n    \"\"\"\n\n    # Determine the client class to use\n    if 'redis_client' in config:\n        client = utils.find_entrypoint('turnstile.redis_client',\n                                       config['redis_client'], required=True)\n    else:\n        client = redis.StrictRedis\n\n    # Extract relevant connection information from the configuration\n    kwargs = {}\n    for cfg_var, type_ in REDIS_CONFIGS.items():\n        if cfg_var in config:\n            kwargs[cfg_var] = type_(config[cfg_var])\n\n    # Make sure we have at a minimum the hostname\n    if 'host' not in kwargs and 'unix_socket_path' not in kwargs:\n        raise redis.ConnectionError(\"No host specified for redis database\")\n\n    # Look up the connection pool configuration\n    cpool_class = None\n    cpool = {}\n    extra_kwargs = {}\n    for key, value in config.items():\n        if key.startswith('connection_pool.'):\n            _dummy, _sep, varname = key.partition('.')\n            if varname == 'connection_class':\n                cpool[varname] = utils.find_entrypoint(\n                    'turnstile.connection_class', value, required=True)\n            elif varname == 'max_connections':\n                cpool[varname] = int(value)\n            elif varname == 'parser_class':\n                cpool[varname] = utils.find_entrypoint(\n                    'turnstile.parser_class', value, required=True)\n            else:\n                cpool[varname] = value\n        elif key not in REDIS_CONFIGS and key not in REDIS_EXCLUDES:\n            extra_kwargs[key] = value\n    if cpool:\n        cpool_class = redis.ConnectionPool\n\n    # Use custom connection pool class if requested...\n    if 'connection_pool' in config:\n        cpool_class = utils.find_entrypoint('turnstile.connection_pool',\n                                            config['connection_pool'],\n                                            required=True)\n\n    # If we're using a connection pool, we'll need to pass the keyword\n    # arguments to that instead of to redis\n    if cpool_class:\n        cpool.update(kwargs)\n\n        # Use a custom connection class?\n        if 'connection_class' not in cpool:\n            if 'unix_socket_path' in cpool:\n                if 'host' in cpool:\n                    del cpool['host']\n                if 'port' in cpool:\n                    del cpool['port']\n\n                cpool['path'] = cpool['unix_socket_path']\n                del cpool['unix_socket_path']\n\n                cpool['connection_class'] = redis.UnixDomainSocketConnection\n            else:\n                cpool['connection_class'] = redis.Connection\n\n        # Build the connection pool to use and set up to pass it into\n        # the redis constructor...\n        kwargs = dict(connection_pool=cpool_class(**cpool))\n\n    # Build and return the database\n    kwargs.update(extra_kwargs)\n    return client(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef limits_hydrate(db, lims):\n\n    return [limits.Limit.hydrate(db, lim) for lim in lims]", "response": "Helper function to hydrate a list of limits."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the list of limits in the database.", "response": "def limit_update(db, key, limits):\n    \"\"\"\n    Safely updates the list of limits in the database.\n\n    :param db: The database handle.\n    :param key: The key the limits are stored under.\n    :param limits: A list or sequence of limit objects, each\n                   understanding the dehydrate() method.\n\n    The limits list currently in the database will be atomically\n    changed to match the new list.  This is done using the pipeline()\n    method.\n    \"\"\"\n\n    # Start by dehydrating all the limits\n    desired = [msgpack.dumps(l.dehydrate()) for l in limits]\n    desired_set = set(desired)\n\n    # Now, let's update the limits\n    with db.pipeline() as pipe:\n        while True:\n            try:\n                # Watch for changes to the key\n                pipe.watch(key)\n\n                # Look up the existing limits\n                existing = set(pipe.zrange(key, 0, -1))\n\n                # Start the transaction...\n                pipe.multi()\n\n                # Remove limits we no longer have\n                for lim in existing - desired_set:\n                    pipe.zrem(key, lim)\n\n                # Update or add all our desired limits\n                for idx, lim in enumerate(desired):\n                    pipe.zadd(key, (idx + 1) * 10, lim)\n\n                # Execute the transaction\n                pipe.execute()\n            except redis.WatchError:\n                # Try again...\n                continue\n            else:\n                # We're all done!\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command(db, channel, command, *args):\n\n    # Build the command we're sending\n    cmd = [command]\n    cmd.extend(str(a) for a in args)\n\n    # Send it out\n    db.publish(channel, ':'.join(cmd))", "response": "Utility function to issue a command to all Turnstile instances."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _tokenize_latex(self, exp):\n        tokens = []\n        prevexp = \"\"\n        while exp:\n            t, exp = self._get_next_token(exp)\n            if t.strip() != \"\":\n                tokens.append(t)\n            if prevexp == exp:\n                break\n            prevexp = exp\n        return tokens", "response": "Internal method to tokenize latex tokens"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a query into an indexable string.", "response": "def _convert_query(self, query):\n        \"\"\"\n        Convert query into an indexable string.\n        \"\"\"\n        query = self.dictionary.doc2bow(self._tokenize_latex(query))\n        sims = self.index[query]\n        neighbors = sorted(sims, key=lambda item: -item[1])\n        neighbors = {\"neighbors\":[{self.columns[0]: {\"data\": self.docs[n[0]], \"fmt\": \"math\"}, self.columns[1]: {\"data\": float(n[1])}} for n in neighbors]} if neighbors else {\"neighbors\": []}\n        return neighbors"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_math(math_expression_lst, name = \"math.html\", out='html', formatter = lambda x: x):\n    try: shutil.rmtree('viz')\n    except: pass\n    pth = get_cur_path()+print_math_template_path\n    shutil.copytree(pth, 'viz')\n\n    # clean_str = formatter(math_expression_lst)\n    html_loc = None\n    if out == \"html\":\n        html_loc = pth+\"standalone_index.html\"\n\n    if out == \"notebook\":  \n        from IPython.display import display, HTML\n        html_loc = pth+\"notebook_index.html\"\n\n    html = open(html_loc).read()\n    html = html.replace(\"__MATH_LIST__\", json.dumps(math_expression_lst))\n\n    if out == \"notebook\": \n        display(HTML(html))\n    elif out == \"html\":\n        with open(name, \"w+\") as out_f:\n            out_f.write(html)", "response": "Print LaTeX math expressions into an HTML file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging an error or print in stdout if no logger.", "response": "def log_error(self, msg, *args):\n        \"\"\"Log an error or print in stdout if no logger.\"\"\"\n        if self._logger is not None:\n            self._logger.error(msg, *args)\n        else:\n            print(msg % args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns sensor attribute with precission or None.", "response": "def _get_value_opc_attr(self, attr_name, prec_decimals=2):\n        \"\"\"Return sensor attribute with precission, or None if not present.\"\"\"\n        try:\n            value = getattr(self, attr_name)\n            if value is not None:\n                return round(value, prec_decimals)\n        except I2cVariableNotImplemented:\n            pass\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns string representation of the current state of the sensor.", "response": "def current_state_str(self):\n        \"\"\"Return string representation of the current state of the sensor.\"\"\"\n        if self.sample_ok:\n            msg = ''\n            temperature = self._get_value_opc_attr('temperature')\n            if temperature is not None:\n                msg += 'Temp: %s \u00baC, ' % temperature\n            humidity = self._get_value_opc_attr('humidity')\n            if humidity is not None:\n                msg += 'Humid: %s %%, ' % humidity\n            pressure = self._get_value_opc_attr('pressure')\n            if pressure is not None:\n                msg += 'Press: %s mb, ' % pressure\n            light_level = self._get_value_opc_attr('light_level')\n            if light_level is not None:\n                msg += 'Light: %s lux, ' % light_level\n            return msg[:-2]\n        else:\n            return \"Bad sample\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the dew point temperature in \u00baC for the last measurement.", "response": "def dew_point_temperature(self):\n        \"\"\"Return the dew point temperature in \u00baC for the last measurement.\n\n        For sensors implementing temperature and humidity values.\n        Extracted from the HTU21D sensor spec sheet.\"\"\"\n        if self.sample_ok:\n            temperature = self._get_value_opc_attr('temperature', 3)\n            humidity = self._get_value_opc_attr('humidity', 3)\n            if temperature is not None and humidity is not None:\n                # Calc dew point temperature in celsius\n                coef_a, coef_b, coef_c = 8.1332, 1762.39, 235.66\n                part_press = 10 ** (coef_a - coef_b / (temperature + coef_c))\n                dewp = - coef_c\n                dewp -= coef_b / (log10(humidity * part_press / 100.) - coef_a)\n                return dewp\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _applyMultichan(samples, func):\n    # type: (np.ndarray, Callable[[np.ndarray], np.ndarray]) -> np.ndarray\n    \"\"\"\n    Apply func to each channel of audio data in samples\n    \"\"\"\n    if len(samples.shape) == 1 or samples.shape[1] == 1:\n        newsamples = func(samples)\n    else:\n        y = np.array([])\n        for i in range(samples.shape[1]):\n            y = np.concatenate((y, func(samples[:,i])))\n        newsamples = y.reshape(samples.shape[1], -1).T\n    return newsamples", "response": "Apply func to each channel of audio data in samples\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _resample_nnresample2(s, up, down, beta=5.0, L=16001, axis=0):\n    # type: (np.ndarray, float, float, float, int, int) -> np.ndarray\n    \"\"\"\n    Taken from https://github.com/jthiem/nnresample\n\n    Resample a signal from rate \"down\" to rate \"up\"\n    \n    Parameters\n    ----------\n    x : array_like\n        The data to be resampled.\n    up : int\n        The upsampling factor.\n    down : int\n        The downsampling factor.\n    beta : float\n        Beta factor for Kaiser window.  Determines tradeoff between\n        stopband attenuation and transition band width\n    L : int\n        FIR filter order.  Determines stopband attenuation.  The higher\n        the better, ath the cost of complexity.\n    axis : int, optional\n        The axis of `x` that is resampled. Default is 0.\n        \n    Returns\n    -------\n    resampled_x : array\n        The resampled array.\n        \n    Notes\n    -----\n    The function keeps a global cache of filters, since they are\n    determined entirely by up, down, beta, and L.  If a filter\n    has previously been used it is looked up instead of being\n    recomputed.\n    \"\"\"       \n    # check if a resampling filter with the chosen parameters already exists\n    params = (up, down, beta, L)\n    if params in _precomputed_filters.keys():\n        # if so, use it.\n        filt = _precomputed_filters[params]\n    else:\n        # if not, generate filter, store it, use it\n        filt = _nnresample_compute_filt(up, down, beta, L)\n        _precomputed_filters[params] = filt\n    return sig.resample_poly(s, up, down, window=np.array(filt), axis=axis)", "response": "Resample a signal from rate down to rate up."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _resample_obspy(samples, sr, newsr, window='hanning', lowpass=True):\n    # type: (np.ndarray, int, int, str, bool) -> np.ndarray\n    \"\"\"\n    Resample using Fourier method. The same as resample_scipy but with\n    low-pass filtering for upsampling\n\n    \"\"\"\n    from scipy.signal import resample\n    from math import ceil\n    factor = sr/float(newsr)\n    if newsr < sr and lowpass:\n        # be sure filter still behaves good\n        if factor > 16:\n            logger.info(\"Automatic filter design is unstable for resampling \"\n                        \"factors (current sampling rate/new sampling rate) \" \n                        \"above 16. Manual resampling is necessary.\")\n        freq = min(sr, newsr) * 0.5 / float(factor)\n        logger.debug(f\"resample_obspy: lowpass {freq}\")\n        samples = lowpass_cheby2(samples, freq=freq, sr=sr, maxorder=12)\n    num = int(ceil(len(samples) / factor))\n\n    return _applyMultichan(samples, \n                           lambda S: resample(S, num, window=window))", "response": "Resample using Fourier method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resample(samples, oldsr, newsr):\n    # type: (np.ndarray, int, int) -> np.ndarray\n    \"\"\"\n    Resample `samples` with given samplerate `sr` to new samplerate `newsr`\n\n    samples: mono or multichannel frames\n    oldsr  : original samplerate\n    newsr  : new sample rate\n\n    Returns: the new samples\n    \"\"\"\n    backends = [\n        _resample_samplerate,   # turns the samples into float32, which is ok for audio \n        _resample_scikits,\n        _resample_nnresample,   # very good results, follows libsamplerate closely\n        _resample_obspy,        # these last two introduce some error at the first samples\n        _resample_scipy\n    ]  # type: List[Callable[[np.ndarray, int, int], Opt[np.ndarray]]]\n\n    for backend in backends:\n        newsamples = backend(samples, oldsr, newsr)\n        if newsamples is not None:\n            return newsamples", "response": "Resample samples with given samplerate sr to new samplerate newsr"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns package version without importing it", "response": "def get_package_version():\n    \"\"\"return package version without importing it\"\"\"\n    base = os.path.abspath(os.path.dirname(__file__))\n    with open(os.path.join(base, 'policy', '__init__.py'),\n              mode='rt',\n              encoding='utf-8') as initf:\n        for line in initf:\n            m = version.match(line.strip())\n            if not m:\n                continue\n            return m.groups()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning package s long description", "response": "def get_long_description():\n    \"\"\"return package's long description\"\"\"\n    base = os.path.abspath(os.path.dirname(__file__))\n    readme_file = os.path.join(base, 'README.md')\n    with open(readme_file, mode='rt', encoding='utf-8') as readme:\n        return readme.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns package s install requires", "response": "def get_install_requires():\n    \"\"\"return package's install requires\"\"\"\n    base = os.path.abspath(os.path.dirname(__file__))\n    requirements_file = os.path.join(base, 'requirements.txt')\n    if not os.path.exists(requirements_file):\n        return []\n    with open(requirements_file, mode='rt', encoding='utf-8') as f:\n        return f.read().splitlines()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(flags):\n\n    dl = SheetDownloader(flags)\n    dl.init()\n\n    for file_info in settings.GOOGLE_SHEET_SYNC['files']:\n        print('Downloading {}'.format(file_info['path']))\n        dl.download_sheet(\n            file_info['path'],\n            file_info['sheet'],\n            file_info['range'],\n        )", "response": "Download all sheets as configured.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch the credentials (and cache them on disk).", "response": "def init(self):\n        \"\"\"\n        Fetch the credentials (and cache them on disk).\n        \"\"\"\n\n        self.credentials = self._get_credentials()\n        self.http = self.credentials.authorize(httplib2.Http())\n        self.service = discovery.build(\n            'sheets',\n            'v4',\n            http=self.http,\n            discoveryServiceUrl=DISCOVERY_URL,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets valid user credentials from storage.", "response": "def _get_credentials(self):\n        \"\"\"\n        Gets valid user credentials from storage.\n\n        If nothing has been stored, or if the stored credentials are invalid,\n        the OAuth2 flow is completed to obtain the new credentials.\n\n        Returns:\n            Credentials, the obtained credential.\n        \"\"\"\n\n        home_dir = os.path.expanduser('~')\n        credential_dir = os.path.join(home_dir, '.credentials')\n\n        if not os.path.exists(credential_dir):\n            os.makedirs(credential_dir)\n\n        credential_path = os.path.join(\n            credential_dir,\n            'bernard.sheets-sync.json',\n        )\n\n        store = Storage(credential_path)\n        credentials = store.get()\n\n        if not credentials or credentials.invalid:\n            with NamedTemporaryFile(suffix='.json') as f:\n                data = ujson.dumps(settings.GOOGLE_SHEET_SYNC['credentials'])\n                f.write(data.encode('utf-8'))\n                f.flush()\n                flow = client.flow_from_clientsecrets(f.name, SCOPES)\n\n            flow.user_agent = APPLICATION_NAME\n            credentials = tools.run_flow(flow, store, self.flags)\n            print('Storing credentials to ' + credential_path)\n\n        return credentials"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef download_sheet(self, file_path, sheet_id, cell_range):\n\n        result = self.service.spreadsheets().values().get(\n            spreadsheetId=sheet_id,\n            range=cell_range,\n        ).execute()\n\n        values = result.get('values', [])\n\n        with open(file_path, newline='', encoding='utf-8', mode='w') as f:\n            writer = csv.writer(f, lineterminator='\\n')\n\n            for row in values:\n                writer.writerow(row)", "response": "Download the cell range from the sheet and store it in the file_path file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_refresh_token(code, app_secret):\n        \"tokens = get_refresh_token(code:str,app_secret:str)\"\n        \"tokens['access_token']\"\n        \"tokens['username']\"\n        \"tokens['refresh_token']\"\n        token_api = \"https://steemconnect.com/api/oauth2/token?code={}&client_secret={}\".format(code, app_secret)\n        return requests.post(token_api).json()", "response": "Get a refresh token for the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getFriendlyString(self):\n        if self._friendlyString is not None:\n            return self._friendlyString\n\n        resultComponents = [\n            self.getIntMajor(),\n            self.getIntMinor(),\n            self.getIntBuild(),\n            self.getIntRevision()\n        ]\n\n        for i in range(len(resultComponents) - 1, -1, -1):\n            if resultComponents[i] == 0:\n                del resultComponents[i]\n            else:\n                break\n\n        result = \".\".join(map(str, resultComponents))\n\n        self._friendlyString = result\n\n        return result", "response": "Returns the version printed in a friendly way."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the versions of the suitable entries available in the directory.", "response": "def getVersions(self):\n        \"\"\"\n        Returns the versions of the suitable entries\n        available in the directory - an empty list\n        if no such entry is available\n        \"\"\"\n        if not os.path.exists(self._path):\n            return []\n\n        result = []\n\n        for entryName in os.listdir(self._path):\n            try:\n                entryVersion = Version(entryName)\n                result.append(entryVersion)\n            except InvalidVersionException:\n                continue\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setUsers(self, *args, **kwargs):\n        try:\n            usrs = [ us for us in self.mambuusersclass(branchId=self['id'], *args, **kwargs) if us['userState'] == \"ACTIVE\" ]\n        except AttributeError as ae:\n            from .mambuuser import MambuUsers\n            self.mambuusersclass = MambuUsers\n            usrs = [ us for us in self.mambuusersclass(branchId=self['id'], *args, **kwargs) if us['userState'] == \"ACTIVE\" ]\n        self['users'] = usrs\n\n        return 1", "response": "Adds the active users for this branch to a users field. Returns the number of requests done to Mambu."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef indent(self):\n        cursor = self.editor.textCursor()\n        assert isinstance(cursor, QtGui.QTextCursor)\n        if cursor.hasSelection():\n            self.indent_selection(cursor)\n        else:\n            # simply insert indentation at the cursor position\n            tab_len = self.editor.tab_length\n            if cursor.positionInBlock() < self.min_column and not cursor.atBlockEnd():\n                cursor.movePosition(cursor.Right, cursor.MoveAnchor, self.min_column)\n            cursor.beginEditBlock()\n            if self.editor.use_spaces_instead_of_tabs:\n                nb_space_to_add = tab_len - (cursor.positionInBlock() - self.min_column) % tab_len\n                cursor.insertText(nb_space_to_add * \" \")\n            else:\n                cursor.insertText('\\t')\n            cursor.endEditBlock()\n            self.editor.setTextCursor(cursor)", "response": "Indents text at cursor position."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unindent(self):\n\n        _logger().debug('unindent')\n        cursor = self.editor.textCursor()\n        _logger().debug('cursor has selection %r', cursor.hasSelection())\n        if cursor.hasSelection():\n            cursor.beginEditBlock()\n            self.unindent_selection(cursor)\n            cursor.endEditBlock()\n            self.editor.setTextCursor(cursor)\n        else:\n            tab_len = self.editor.tab_length\n            indentation = cursor.positionInBlock()\n            indentation -= self.min_column\n            if indentation == 0:\n                return\n            max_spaces = indentation % tab_len\n            if max_spaces == 0:\n                max_spaces = tab_len\n            spaces = self.count_deletable_spaces(cursor, max_spaces)\n            _logger().info('deleting %d space before cursor' % spaces)\n            cursor.beginEditBlock()\n            for _ in range(spaces):\n                cursor.deletePreviousChar()\n            cursor.endEditBlock()\n            self.editor.setTextCursor(cursor)\n            _logger().debug(cursor.block().text())", "response": "Un - indents the current line of text at the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef with_name(cls, name, id_user=0, **extra_data):\n        return cls(name=name, id_user=0, **extra_data)", "response": "Instantiate a WorkflowEngine given a name or UUID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload an existing workflow from the database given a UUID.", "response": "def from_uuid(cls, uuid, **extra_data):\n        \"\"\"Load an existing workflow from the database given a UUID.\n\n        :param uuid: pass a uuid to an existing workflow.\n        :type uuid: str\n        \"\"\"\n        model = Workflow.query.get(uuid)\n        if model is None:\n            raise LookupError(\n                \"No workflow with UUID {} was found\".format(uuid)\n            )\n        instance = cls(model=model, **extra_data)\n        instance.objects = WorkflowObjectModel.query.filter(\n            WorkflowObjectModel.id_workflow == uuid,\n            WorkflowObjectModel.id_parent == None,  # noqa\n        ).all()\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef final_objects(self):\n        return [obj for obj in self.database_objects\n                if obj.status in [obj.known_statuses.COMPLETED]]", "response": "Return the objects associated with this workflow."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef halted_objects(self):\n        return [obj for obj in self.database_objects\n                if obj.status in [obj.known_statuses.HALTED]]", "response": "Return the objects associated with this workflow."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef running_objects(self):\n        return [obj for obj in self.database_objects\n                if obj.status in [obj.known_statuses.RUNNING]]", "response": "Return the objects associated with this workflow."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, status=None):\n        if self.model is None:\n            raise WorkflowsMissingModel()\n\n        with db.session.begin_nested():\n            self.model.modified = datetime.now()\n            if status is not None:\n                self.model.status = status\n\n            if self.model.extra_data is None:\n                self.model.extra_data = dict()\n            flag_modified(self.model, 'extra_data')\n            db.session.merge(self.model)", "response": "Save object to persistent storage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncontinuing the workflow for one given object from restart_point.", "response": "def continue_object(self, workflow_object, restart_point='restart_task',\n                        task_offset=1, stop_on_halt=False):\n        \"\"\"Continue workflow for one given object from \"restart_point\".\n\n        :param object:\n        :param stop_on_halt:\n        :param restart_point: can be one of:\n            * restart_prev: will restart from the previous task\n            * continue_next: will continue to the next task\n            * restart_task: will restart the current task\n\n        You can use stop_on_error to raise exception's and stop the processing.\n        Use stop_on_halt to stop processing the workflow if HaltProcessing is\n        raised.\n        \"\"\"\n        translate = {\n            'restart_task': 'current',\n            'continue_next': 'next',\n            'restart_prev': 'prev',\n        }\n        self.state.callback_pos = workflow_object.callback_pos or [0]\n        self.restart(task=translate[restart_point], obj='first',\n                     objects=[workflow_object], stop_on_halt=stop_on_halt)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has_completed(self):\n        objects_in_db = WorkflowObjectModel.query.filter(\n            WorkflowObjectModel.id_workflow == self.uuid,\n            WorkflowObjectModel.id_parent == None,  # noqa\n        ).filter(WorkflowObjectModel.status.in_([\n            workflow_object_class.known_statuses.COMPLETED\n        ])).count()\n        return objects_in_db == len(list(self.objects))", "response": "Return True if the workflow has completed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfigures the workflow to run by the name passed in.", "response": "def set_workflow_by_name(self, workflow_name):\n        \"\"\"Configure the workflow to run by the name of this one.\n\n        Allows the modification of the workflow that the engine will run\n        by looking in the registry the name passed in parameter.\n\n        :param workflow_name: name of the workflow.\n        :type workflow_name: str\n        \"\"\"\n        from .proxies import workflows\n\n        if workflow_name not in workflows:\n            # No workflow with that name exists\n            raise WorkflowDefinitionError(\"Workflow '%s' does not exist\"\n                                          % (workflow_name,),\n                                          workflow_name=workflow_name)\n        self.workflow_definition = workflows[workflow_name]\n        self.callbacks.replace(self.workflow_definition.workflow)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef after_each_callback(eng, callback_func, obj):\n        obj.callback_pos = eng.state.callback_pos\n        obj.extra_data[\"_last_task_name\"] = callback_func.__name__\n        task_history = get_task_history(callback_func)\n        if \"_task_history\" not in obj.extra_data:\n            obj.extra_data[\"_task_history\"] = [task_history]\n        else:\n            obj.extra_data[\"_task_history\"].append(task_history)", "response": "Take action after every WF callback."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef before_object(eng, objects, obj):\n        super(InvenioProcessingFactory, InvenioProcessingFactory)\\\n            .before_object(\n            eng, objects, obj\n        )\n        if \"_error_msg\" in obj.extra_data:\n            del obj.extra_data[\"_error_msg\"]\n        db.session.commit()", "response": "Take action before the processing of an object begins."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef after_object(eng, objects, obj):\n        # We save each object once it is fully run through\n        super(InvenioProcessingFactory, InvenioProcessingFactory)\\\n            .after_object(eng, objects, obj)\n        obj.save(\n            status=obj.known_statuses.COMPLETED,\n            id_workflow=eng.model.uuid\n        )\n        db.session.commit()", "response": "Take action once the proccessing of an object completes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute before processing the workflow.", "response": "def before_processing(eng, objects):\n        \"\"\"Execute before processing the workflow.\"\"\"\n        super(InvenioProcessingFactory, InvenioProcessingFactory)\\\n            .before_processing(eng, objects)\n        eng.save(WorkflowStatus.RUNNING)\n        db.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef after_processing(eng, objects):\n        super(InvenioProcessingFactory, InvenioProcessingFactory)\\\n            .after_processing(eng, objects)\n        if eng.has_completed:\n            eng.save(WorkflowStatus.COMPLETED)\n        else:\n            eng.save(WorkflowStatus.HALTED)\n        db.session.commit()", "response": "Process to update status."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles general exceptions in workflow saving states.", "response": "def Exception(obj, eng, callbacks, exc_info):\n        \"\"\"Handle general exceptions in workflow, saving states.\"\"\"\n        exception_repr = ''.join(traceback.format_exception(*exc_info))\n        msg = \"Error:\\n%s\" % (exception_repr)\n        eng.log.error(msg)\n        if obj:\n            # Sets an error message as a tuple (title, details)\n            obj.extra_data['_error_msg'] = exception_repr\n            obj.save(\n                status=obj.known_statuses.ERROR,\n                callback_pos=eng.state.callback_pos,\n                id_workflow=eng.uuid\n            )\n        eng.save(WorkflowStatus.ERROR)\n        db.session.commit()\n\n        # Call super which will reraise\n        super(InvenioTransitionAction, InvenioTransitionAction).Exception(\n            obj, eng, callbacks, exc_info\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef WaitProcessing(obj, eng, callbacks, exc_info):\n        e = exc_info[1]\n        obj.set_action(e.action, e.message)\n        obj.save(status=eng.object_status.WAITING,\n                 callback_pos=eng.state.callback_pos,\n                 id_workflow=eng.uuid)\n        eng.save(WorkflowStatus.HALTED)\n        eng.log.warning(\"Workflow '%s' waiting at task %s with message: %s\",\n                        eng.name, eng.current_taskname or \"Unknown\", e.message)\n        db.session.commit()\n\n        # Call super which will reraise\n        TransitionActions.HaltProcessing(\n            obj, eng, callbacks, exc_info\n        )", "response": "Take actions when WaitProcessing is raised."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping the engne and mark the workflow as completed.", "response": "def StopProcessing(obj, eng, callbacks, exc_info):\n        \"\"\"Stop the engne and mark the workflow as completed.\"\"\"\n        e = exc_info[1]\n        obj.save(status=eng.object_status.COMPLETED,\n                 id_workflow=eng.uuid)\n        eng.save(WorkflowStatus.COMPLETED)\n        obj.log.warning(\n            \"Workflow '%s' stopped at task %s with message: %s\",\n            eng.name, eng.current_taskname or \"Unknown\", e.message\n        )\n        db.session.commit()\n\n        super(InvenioTransitionAction, InvenioTransitionAction).StopProcessing(\n            obj, eng, callbacks, exc_info\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake action when SkipToken is raised.", "response": "def SkipToken(obj, eng, callbacks, exc_info):\n        \"\"\"Take action when SkipToken is raised.\"\"\"\n        msg = \"Skipped running this object: {0}\".format(obj.id)\n        eng.log.debug(msg)\n        raise Continue"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef AbortProcessing(obj, eng, callbacks, exc_info):\n        msg = \"Processing was aborted for object: {0}\".format(obj.id)\n        eng.log.debug(msg)\n        raise Break", "response": "Take action when AbortProcessing is raised."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a Variant instance to a Locus object.", "response": "def to_locus(variant_or_locus):\n    \"\"\"\n    Return a Locus object for a Variant instance.\n\n    This is necessary since the read evidence module expects Variant instances\n    to have a locus attribute st to a varcode.Locus instance of interbase\n    genomic coordinates.  The rest of varcode uses a different Variant class,\n    but will eventually be transitioned to interbase coordinates.\n\n    See test/test_read_evidence.py for a definition of the Variant class that\n    the read_evidence module is meant to work with.\n\n    This function can be passed a regular varcode.Variant instance (with fields\n    start, end, contig, etc.), a different kind of variant object that has a\n    'locus' field, or a varcode.Locus. It will return a varcode.Locus instance.\n\n    This should all get cleaned up once varcode switches to interbase\n    coordinates and we standardize on a Variant class.\n    \"\"\"\n    if isinstance(variant_or_locus, Locus):\n        return variant_or_locus\n    try:\n        return variant_or_locus.locus\n    except AttributeError:\n        # IMPORTANT: if varcode someday changes from inclusive to interbase\n        # coordinates, this will need to be updated.\n        return Locus.from_inclusive_coordinates(\n            variant_or_locus.contig,\n            variant_or_locus.start,\n            variant_or_locus.end)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a 1 - base locus return the Pileup at that locus. Raises a KeyError if this PileupCollection does not have a Pileup at that locus.", "response": "def pileup(self, locus):\n        '''\n        Given a 1-base locus, return the Pileup at that locus.\n\n        Raises a KeyError if this PileupCollection does not have a Pileup at\n        the specified locus.\n        '''\n        locus = to_locus(locus)\n        if len(locus.positions) != 1:\n            raise ValueError(\"Not a single-base locus: %s\" % locus)\n        return self.pileups[locus]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef at(self, *loci):\n        '''\n        Return a new PileupCollection instance including only pileups for \n        the specified loci.\n        '''\n        loci = [to_locus(obj) for obj in loci]\n        single_position_loci = []\n        for locus in loci:\n            for position in locus.positions:\n                single_position_loci.append(\n                    Locus.from_interbase_coordinates(locus.contig, position))\n        pileups = dict(\n            (locus, self.pileups[locus]) for locus in single_position_loci)\n        return PileupCollection(pileups, self)", "response": "Return a new PileupCollection instance including only pileups for \n        the specified loci."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reads(self):\n        '''\n        The reads in this PileupCollection. All reads will have an alignment\n        that overlaps at least one of the included loci.\n\n        Since SAM (and pysam) have no real notion of a \"read\", the returned\n        instances are actually pysam.AlignedSegment instances, (i.e. \n        alignments). However, only one alignment will be returned by this\n        method per read.\n        \n        Returns\n        ----------\n        List of pysam.AlignedSegment instances. If a particular read has more\n        than one alignment in this PileupCollection (e.g. one primary and one\n        secondary), then the alignment returned is the one with the highest\n        mapping quality.\n        '''\n        # TODO: Optimize this.\n\n        def alignment_precedence(pysam_alignment_record):\n            return pysam_alignment_record.mapping_quality\n\n        result = {}\n        for pileup in self.pileups.values():\n            for e in pileup.elements:\n                key = read_key(e.alignment)\n                if key not in result or (\n                        alignment_precedence(e.alignment) >\n                        alignment_precedence(result[key])):\n                    result[key] = e.alignment\n        return list(result.values())", "response": "Returns a list of pysam. AlignedSegment instances for all reads in this PileupCollection."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a pandas. DataFrame containing the read attributes across the reads in this PileupCollection.", "response": "def read_attributes(self, attributes=None):\n        '''\n        Collect read attributes across reads in this PileupCollection into a\n        pandas.DataFrame.\n\n        Valid attributes are the following properties of a pysam.AlignedSegment\n        instance. See:\n            http://pysam.readthedocs.org/en/latest/api.html#pysam.AlignedSegment\n        for the meaning of these attributes.\n\n             * cigarstring\n             * flag\n             * inferred_length\n             * is_duplicate\n             * is_paired\n             * is_proper_pair\n             * is_qcfail\n             * is_read1\n             * is_read2\n             * is_reverse\n             * is_secondary\n             * is_unmapped\n             * mapping_quality\n             * mate_is_reverse\n             * mate_is_unmapped\n             * next_reference_id\n             * next_reference_start\n             * query_alignment_end\n             * query_alignment_length\n             * query_alignment_qualities\n             * query_alignment_sequence\n             * query_alignment_start\n             * query_length\n             * query_name\n             * reference_end\n             * reference_id\n             * reference_length\n             * reference_start\n             * template_length\n\n        (Note: the above list is parsed into the _READ_ATTRIBUTE_NAMES class\n        variable, so be careful when modifying it.)\n\n        Additionally, for alignment \"tags\" (arbitrary key values associated\n        with an alignment), a column of the form \"TAG_{tag name}\" is\n        included.\n\n        Finally, the column \"pysam_alignment_record\" gives the underlying\n        `pysam.AlignedSegment` instances.\n\n        Parameters\n        ----------\n        attributes (optional): list of strings\n            List of columns to include. If unspecified, all columns are\n            included in the result.\n\n        Returns\n        ----------\n        pandas.DataFrame of read attributes.\n\n        '''\n        def include(attribute):\n            return attributes is None or attribute in attributes\n\n        reads = self.reads()\n\n        possible_column_names = list(PileupCollection._READ_ATTRIBUTE_NAMES)\n        result = OrderedDict(\n            (name, [getattr(read, name) for read in reads])\n            for name in PileupCollection._READ_ATTRIBUTE_NAMES\n            if include(name))\n\n        # Add tag columns.\n        if reads:\n            tag_dicts = [dict(x.get_tags()) for x in reads]\n            tag_keys = set.union(\n                *[set(item.keys()) for item in tag_dicts])\n            for tag_key in sorted(tag_keys):\n                column_name = \"TAG_%s\" % tag_key\n                possible_column_names.append(column_name)\n                if include(column_name):\n                    result[column_name] = [d.get(tag_key) for d in tag_dicts]\n\n        # Lastly, we include the underlying pysam alignment record.\n        possible_column_names.append(\"pysam_alignment_record\")\n        if include(\"pysam_alignment_record\"):\n            result[\"pysam_alignment_record\"] = reads\n\n        # If particular attributes were requested, check that they're here.\n        if attributes is not None:\n            for attribute in attributes:\n                if attribute not in result:\n                    raise ValueError(\n                        \"No such attribute: %s. Valid attributes are: %s\"\n                        % (attribute, \" \".join(possible_column_names)))\n            assert set(attributes) == set(result)\n\n        return pandas.DataFrame(result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef group_by_allele(self, locus):\n        '''\n        Split the PileupCollection by the alleles suggested by the reads at the\n        specified locus.\n\n        If a read has an insertion immediately following the locus, then the\n        insertion is included in the allele. For example, if locus is the\n        1-base range [5,6), one allele might be \"AGA\", indicating that at\n        locus 5 some read has an \"A\" followed by a 2-base insertion (\"GA\"). If\n        a read has a deletion at the specified locus, the allele is the empty\n        string.\n\n        The given locus may include any number of bases. If the locus includes\n        multiple bases, then the alleles consist of all bases aligning to that\n        range in any read. Note that only sequences actually sequenced in a\n        particular read are included. For example, if one read has \"ATT\" at a\n        locus and another read has \"GCC\", then the alleles are \"ATT\" and\n        \"GCC\", but not \"GTT\". That is, the bases in each allele are phased. For\n        this reason, only reads that overlap the entire locus are included.\n\n        If the locus is an empty interval (e.g. [5,5) ), then the alleles\n        consist only of inserted bases. In this example, only bases inserted\n        immediately after locus 5 would be included (but *not* the base\n        actually at locus 5). In the previous insertion example, the allele\n        would be \"GA\", indicating a 2-base insertion. Reads that have no\n        insertion at that position (matches or deletions) would have the empty\n        string as their allele.\n\n        Parameters\n        ----------\n        locus : Locus\n            The reference locus, encompassing 0 or more bases.\n\n        Returns\n        ----------\n        A dict of string -> PileupCollection. The keys are nucleotide strings\n        giving the bases sequenced at the locus, and the values are\n        PileupCollection instances of the alignments that support that allele.\n\n        '''\n        locus = to_locus(locus)\n        read_to_allele = None\n        loci = []\n        if locus.positions:\n            # Our locus includes at least one reference base.\n            for position in locus.positions:\n                base_position = Locus.from_interbase_coordinates(\n                    locus.contig, position)\n                loci.append(base_position)\n                new_read_to_allele = {}\n                for element in self.pileups[base_position]:\n                    allele_prefix = \"\"\n                    key = alignment_key(element.alignment)\n                    if read_to_allele is not None:\n                        try:\n                            allele_prefix = read_to_allele[key]\n                        except KeyError:\n                            continue\n                    allele = allele_prefix + element.bases\n                    new_read_to_allele[key] = allele\n                read_to_allele = new_read_to_allele\n        else:\n            # Our locus is between reference bases.\n            position_before = Locus.from_interbase_coordinates(\n                locus.contig, locus.start)\n            loci.append(position_before)\n            read_to_allele = {}\n            for element in self.pileups[position_before]:\n                allele = element.bases[1:]\n                read_to_allele[alignment_key(element.alignment)] = allele\n\n        split = defaultdict(lambda: PileupCollection(pileups={}, parent=self))\n        for locus in loci:\n            pileup = self.pileups[locus]\n            for e in pileup.elements:\n                key = read_to_allele.get(alignment_key(e.alignment))\n                if key is not None:\n                    if locus in split[key].pileups:\n                        split[key].pileups[locus].append(e)\n                    else:\n                        split[key].pileups[locus] = Pileup(locus, [e])\n\n        # Sort by number of reads (descending). Break ties with the\n        # lexicographic ordering of the allele string.\n        def sorter(pair):\n            (allele, pileup_collection) = pair\n            return (-1 * pileup_collection.num_reads(), allele)\n        return OrderedDict(sorted(split.items(), key=sorter))", "response": "Split the PileupCollection by the alleles suggested by reads at the specified locus."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef allele_summary(self, locus, score=lambda x: x.num_reads()):\n        '''\n        Convenience method to summarize the evidence for each of the alleles\n        present at a locus. Applies a score function to the PileupCollection\n        associated with each allele.\n\n        See also `PileupCollection.group_by_allele`.\n\n        Parameters\n        ----------\n        locus : Locus\n            The reference locus, encompassing 0 or more bases.\n\n        score (optional) : PileupCollection -> object\n            Function to apply to summarize the evidence for each allele.\n            Default: count number of reads.\n\n        Returns\n        ----------\n        List of (allele, score) pairs.\n        '''\n        locus = to_locus(locus)\n        return [\n            (allele, score(x))\n            for (allele, x) in self.group_by_allele(locus).items()\n        ]", "response": "Convenience method to summarize the evidence for each allele in a locus."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a variant split the PileupCollection based on whether it the PileupCollection supports the reference allele and the alternate allele or neither.", "response": "def group_by_match(self, variant):\n        '''\n        Given a variant, split the PileupCollection based on whether it the\n        data supports the reference allele, the alternate allele, or neither.\n\n        Parameters\n        ----------\n        variant : Variant\n            The variant. Must have fields 'locus', 'ref', and 'alt'.\n\n        Returns\n        ----------\n        A MatchingEvidence named tuple with fields (ref, alt, other),\n        each of which is a string -> PileupCollection dict mapping alleles\n        to the PileupCollection of evidence supporting them.\n        '''\n        locus = to_locus(variant)\n        if len(variant.ref) != len(locus.positions):\n            logging.warning(\n                \"Ref is length %d but locus has %d bases in variant: %s\" %\n                (len(variant.ref), len(locus.positions), str(variant)))\n\n        alleles_dict = self.group_by_allele(locus)\n        single_base_loci = [\n            Locus.from_interbase_coordinates(locus.contig, position)\n            for position in locus.positions\n        ]\n        empty_pileups = dict(\n            (locus, Pileup(locus=locus, elements=[]))\n            for locus in single_base_loci)\n        empty_collection = PileupCollection(pileups=empty_pileups, parent=self)\n\n        ref = {variant.ref: alleles_dict.pop(variant.ref, empty_collection)}\n        alt = {variant.alt: alleles_dict.pop(variant.alt, empty_collection)}\n        other = alleles_dict\n\n        # TODO: consider end of read issues for insertions\n        return MatchingEvidence(ref, alt, other)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match_summary(self, variant, score=lambda x: x.num_reads()):\n        '''\n        Convenience method to summarize the evidence for and against a variant\n        using a user-specified score function.\n\n        See also `PileupCollection.group_by_match`.\n\n        Parameters\n        ----------\n        variant : Variant\n            The variant. Must have fields 'locus', 'ref', and 'alt'.\n\n        score (optional) : PileupCollection -> object\n            Function to apply to summarize the evidence for each allele.\n            Default: count number of reads.\n\n        Returns\n        ----------\n        List of (allele, score) pairs. This list will always have at least two\n        elements. The first pair in the list is the reference allele. The\n        second pair is the alternate. The subsequent items give the \"third\"\n        alleles (neither ref nor alt), if any.\n        '''\n        split = self.group_by_match(variant)\n\n        def name(allele_to_pileup_collection):\n            return \",\".join(allele_to_pileup_collection)\n\n        def aggregate_and_score(pileup_collections):\n            merged = PileupCollection.merge(*pileup_collections)\n            return score(merged)\n\n        result = [\n            (name(split.ref), aggregate_and_score(split.ref.values())),\n            (name(split.alt), aggregate_and_score(split.alt.values())),\n        ]\n        result.extend(\n            (allele, score(collection))\n            for (allele, collection) in split.other.items())\n        return result", "response": "Returns a summary of the evidence for and against a variant."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter(self,\n            drop_duplicates=False,\n            drop_improper_mate_pairs=False,\n            min_mapping_quality=None,\n            min_base_quality=None,\n            filters=None):\n        '''\n        Return a new PileupCollection that includes only pileup elements\n        satisfying the specified criteria.\n\n        Parameters\n        ----------\n        drop_duplicates (optional, default False) : boolean\n            Remove alignments with the is_duplicate flag.\n\n        drop_improper_mate_pairs (optional, default False) : boolean\n            Retain only alignments that have mapped mate pairs, where one\n            alignment in the pair is on the forward strand and the other\n            is on the reverse.\n\n        min_mapping_quality (optional) : int\n            If specified, retain only alignments with mapping quality >= the\n            specified threshold.\n\n        min_base_quality (optional) : int\n            If specified, retain only pileup elements where the base quality\n            for the bases aligning to the pileup's locus are >= the specified\n            threshold.\n\n        filters (optional) : list of PileupElement -> bool functions\n            User-specified filter functions to apply. This will be called on \n            each PileupElement, and should return True if the element should\n            be retained.\n\n        Returns\n        ----------\n        A new PileupCollection that includes the subset of the pileup elements\n        matching all the specified filters.\n        '''\n\n        if filters is None:\n            filters = []\n        if drop_duplicates:\n            filters.append(lambda e: not e.alignment.is_duplicate)\n        if drop_improper_mate_pairs:\n            filters.append(lambda e: e.alignment.is_proper_pair)\n        if min_mapping_quality is not None:\n            filters.append(\n                lambda e: e.alignment.mapping_quality >= min_mapping_quality)\n        if min_base_quality is not None:\n            filters.append(\n                lambda e: e.min_base_quality >= min_base_quality)\n        pileups = OrderedDict(\n            (locus, pileup.filter(filters))\n            for (locus, pileup)\n            in self.pileups.items())\n        return PileupCollection(pileups=pileups, parent=self)", "response": "Returns a new PileupCollection containing only the subset of the specified pileup elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge(self, *others):\n        '''\n        Return a new PileupCollection that is the union of self and the other\n        specified collections.\n        '''\n        new_pileups = {}\n        for collection in (self,) + others:\n            for (locus, pileup) in collection.pileups.items():\n                if locus in new_pileups:\n                    new_pileups[locus].update(pileup)\n                else:\n                    new_pileups[locus] = Pileup(locus, pileup.elements)\n        return PileupCollection(new_pileups, parent=self)", "response": "Return a new PileupCollection that is the union of self and the other PileupCollections."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a PileupCollection instance for a set of loci from a BAM file.", "response": "def from_bam(pysam_samfile, loci, normalized_contig_names=True):\n        '''\n        Create a PileupCollection for a set of loci from a BAM file.\n\n        Parameters\n        ----------\n        pysam_samfile : `pysam.Samfile` instance, or filename string\n            to a BAM file. The BAM file must be indexed.\n\n        loci : list of Locus instances\n            Loci to collect pileups for.\n\n        normalized_contig_names : whether the contig names have been normalized\n            (e.g. pyensembl removes the 'chr' prefix). Set to true to\n            de-normalize the names when querying the BAM file.\n\n        Returns\n        ----------\n        PileupCollection instance containing pileups for the specified loci.\n        All alignments in the BAM file are included (e.g. duplicate reads,\n        secondary alignments, etc.). See `PileupCollection.filter` if these\n        need to be removed. \n        '''\n\n        loci = [to_locus(obj) for obj in loci]\n\n        close_on_completion = False\n        if typechecks.is_string(pysam_samfile):\n            pysam_samfile = Samfile(pysam_samfile)\n            close_on_completion = True        \n\n        try:\n            # Map from pyensembl normalized chromosome names used in Variant to\n            # the names used in the BAM file.\n            if normalized_contig_names:\n                chromosome_name_map = {}\n                for name in pysam_samfile.references:\n                    normalized = pyensembl.locus.normalize_chromosome(name)\n                    chromosome_name_map[normalized] = name\n                    chromosome_name_map[name] = name\n            else:\n                chromosome_name_map = None\n\n            result = PileupCollection({})\n\n            # Optimization: we sort variants so our BAM reads are localized.\n            locus_iterator = itertools.chain.from_iterable(\n                (Locus.from_interbase_coordinates(locus_interval.contig, pos)\n                    for pos\n                    in locus_interval.positions)\n                for locus_interval in sorted(loci))\n            for locus in locus_iterator:\n                result.pileups[locus] = Pileup(locus, [])\n                if normalized_contig_names:\n                    try:\n                        chromosome = chromosome_name_map[locus.contig]\n                    except KeyError:\n                        logging.warn(\"No such contig in bam: %s\" % locus.contig)\n                        continue\n                else:\n                    chromosome = locus.contig\n                columns = pysam_samfile.pileup(\n                    chromosome,\n                    locus.position,\n                    locus.position + 1,  # exclusive, 0-indexed\n                    truncate=True,\n                    stepper=\"nofilter\")\n                try:\n                    column = next(columns)\n                except StopIteration:\n                    # No reads align to this locus.\n                    continue\n\n                # Note that storing the pileups here is necessary, since the\n                # subsequent assertion will invalidate our column.\n                pileups = column.pileups\n                assert list(columns) == []  # column is invalid after this.\n                for pileup_read in pileups:\n                    if not pileup_read.is_refskip:\n                        element = PileupElement.from_pysam_alignment(\n                            locus, pileup_read)\n                        result.pileups[locus].append(element)\n            return result\n        finally:\n            if close_on_completion:\n                pysam_samfile.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a parser returning Elastic Search DSL query instance.", "response": "def invenio_query_factory(parser=None, walkers=None):\n    \"\"\"Create a parser returning Elastic Search DSL query instance.\"\"\"\n    parser = parser or Main\n    walkers = walkers or [PypegConverter()]\n    walkers.append(ElasticSearchDSL())\n\n    def invenio_query(pattern):\n        query = pypeg2.parse(pattern, parser, whitespace=\"\")\n        for walker in walkers:\n            query = query.accept(walker)\n        return query\n    return invenio_query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_dimensions(self, dataset):\n        '''\n        Checks that the feature types of this dataset are consistent with a timeseries-profile-orthogonal dataset.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n        '''\n        results = []\n        required_ctx = TestCtx(BaseCheck.HIGH, 'All geophysical variables are timeseries-profile-orthogonal feature types')\n\n        message = '{} must be a valid profile-orthogonal feature type. It must have dimensions of (station, time, z).'\n        message += ' If it\\'s a single station, it must have dimensions (time, z). x and y dimensions must be scalar or have'\n        message += ' dimensions (station). time must be a coordinate variable with dimension (time) and z must be a'\n        message += ' coordinate variabel with dimension (z).'\n\n        for variable in util.get_geophysical_variables(dataset):\n            is_valid = util.is_timeseries_profile_single_station(dataset, variable)\n            is_valid = is_valid or util.is_timeseries_profile_multi_station(dataset, variable)\n            required_ctx.assert_true(\n                is_valid,\n                message.format(variable)\n            )\n        results.append(required_ctx.to_result())\n        return results", "response": "Checks that the feature types of this dataset are consistent with a timeseries - profile - orthogonal dataset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the name of the theme", "response": "def theme(name='readthedocs'):\n    \"\"\"set name to 'bootstrap' in case you want to use bootstrap.\n    This also requires the template sto be in the main dir\"\"\"\n    \n    os.environ['SPHINX_THEME'] = name\n    if os.environ['SPHINX_THEME'] == 'bootstrap':\n        local('cp docs/source/_templates/layout_bootstrap.html docs/source/_templates/layout.html')\n    elif name is 'readthedocs':\n        return\n    else:\n        local('cp docs/source/_templates/layout_simple.html docs/source/_templates/layout.html')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding the html file locally and view", "response": "def html(theme_name='readthedocs'):\n    # disable Flask RSTPAGES due to sphinx incompatibility\n    os.environ['RSTPAGES'] = 'FALSE'\n    theme(theme_name)\n    api()\n    man()\n    \"\"\"build the doc locally and view\"\"\"\n    clean()\n    local(\"cd docs; make html\")\n    local(\"fab security.check\")\n    local(\"touch docs/build/html/.nojekyll\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sign_message(body: ByteString, secret: Text) -> Text:\n\n    return 'sha1={}'.format(\n        hmac.new(secret.encode(), body, sha1).hexdigest()\n    )", "response": "Compute a message s signature."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _get_user(self):\n\n        if self._cache is None:\n            try:\n                self._cache = \\\n                    await self.facebook.get_user(self.fbid, self.page_id)\n            except PlatformOperationError:\n                self._cache = {}\n        return self._cache", "response": "Get the user dict from the cache or query it from the platform"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def get_friendly_name(self) -> Text:\n        u = await self._get_user()\n        f = u.get('first_name', '').strip()\n        l = u.get('last_name', '').strip()\n\n        return f or l", "response": "Get the friendly name of the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the gender from Facebook.", "response": "async def get_gender(self) -> User.Gender:\n        \"\"\"\n        Get the gender from Facebook.\n        \"\"\"\n        u = await self._get_user()\n\n        try:\n            return User.Gender(u.get('gender'))\n        except ValueError:\n            return User.Gender.unknown"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the time zone of the user s Facebook entry.", "response": "async def get_timezone(self) -> Optional[tzinfo]:\n        \"\"\"\n        We can't exactly know the time zone of the user from what Facebook\n        gives (fucking morons) but we can still give something that'll work\n        until next DST.\n        \"\"\"\n\n        u = await self._get_user()\n        diff = float(u.get('timezone', 0)) * 3600.0\n\n        return tz.tzoffset('ITC', diff)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_user(self) -> FacebookUser:\n        return FacebookUser(\n            self._event['sender']['id'],\n            self.get_page_id(),\n            self._facebook,\n            self,\n        )", "response": "Generate a Facebook user instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_layers(self) -> List[BaseLayer]:\n        out = []\n        msg = self._event.get('message', {})\n\n        if 'text' in msg:\n            out.append(lyr.RawText(msg['text']))\n\n        for attachment in msg.get('attachments') or []:\n            if attachment['type'] == 'image':\n                out.append(lyr.Image(UrlMedia(attachment['payload']['url'])))\n            elif attachment['type'] == 'audio':\n                out.append(lyr.Audio(UrlMedia(attachment['payload']['url'])))\n            elif attachment['type'] == 'file':\n                out.append(lyr.File(UrlMedia(attachment['payload']['url'])))\n            elif attachment['type'] == 'video':\n                out.append(lyr.Video(UrlMedia(attachment['payload']['url'])))\n            elif attachment['type'] == 'location':\n                # noinspection PyArgumentList\n                out.append(lyr.Location(lyr.Location.Point(\n                    lat=attachment['payload']['coordinates']['lat'],\n                    lon=attachment['payload']['coordinates']['long'],\n                )))\n\n        if 'quick_reply' in msg:\n            out.append(QuickReply(msg['quick_reply']['payload']))\n\n        if 'postback' in self._event:\n            payload = ujson.loads(self._event['postback']['payload'])\n            out.append(lyr.Postback(payload))\n\n        if 'optin' in self._event:\n            out.append(OptIn(self._event['optin']['ref']))\n\n        return out", "response": "Returns all layers that can be found in the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks that the configuration is correct.", "response": "async def self_check(cls):\n        \"\"\"\n        Check that the configuration is correct\n\n        - Presence of \"BERNARD_BASE_URL\" in the global configuration\n        - Presence of a \"WEBVIEW_SECRET_KEY\"\n        \"\"\"\n\n        async for check in super().self_check():\n            yield check\n\n        s = cls.settings()\n\n        if not hasattr(settings, 'BERNARD_BASE_URL'):\n            yield HealthCheckFail(\n                '00005',\n                '\"BERNARD_BASE_URL\" cannot be found in the configuration. The'\n                'Telegram platform needs it because it uses it to '\n                'automatically register its hook.'\n            )\n\n        if not hasattr(settings, 'WEBVIEW_SECRET_KEY'):\n            yield HealthCheckFail(\n                '00005',\n                '\"WEBVIEW_SECRET_KEY\" cannot be found in the configuration. '\n                'It is required in order to be able to create secure postback '\n                'URLs.'\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def check_hook(self, request: HttpRequest):\n\n        verify_token = request.query.get('hub.verify_token')\n\n        if not verify_token:\n            return json_response({\n                'error': 'No verification token was provided',\n            }, status=400)\n\n        if verify_token == self.verify_token:\n            return Response(text=request.query.get('hub.challenge', ''))\n\n        return json_response({\n            'error': 'could not find the page token in the configuration',\n        })", "response": "Called when Facebook checks the hook\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle events received from Facebook.", "response": "async def receive_events(self, request: HttpRequest):\n        \"\"\"\n        Events received from Facebook\n        \"\"\"\n\n        body = await request.read()\n        s = self.settings()\n\n        try:\n            content = ujson.loads(body)\n        except ValueError:\n            return json_response({\n                'error': True,\n                'message': 'Cannot decode body'\n            }, status=400)\n\n        secret = s['app_secret']\n        actual_sig = request.headers['X-Hub-Signature']\n        expected_sig = sign_message(body, secret)\n\n        if not hmac.compare_digest(actual_sig, expected_sig):\n            return json_response({\n                'error': True,\n                'message': 'Invalid signature',\n            }, status=401)\n\n        for entry in content['entry']:\n            for raw_message in entry.get('messaging', []):\n                message = FacebookMessage(raw_message, self)\n                await self.handle_event(message)\n\n        return json_response({\n            'ok': True,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def _deferred_init(self):\n\n        await self._check_subscriptions()\n        await self._set_whitelist()\n        await self._set_get_started()\n        await self._set_greeting_text()\n        await self._set_persistent_menu()", "response": "Called by the bot when the bot is not ready to run."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the value of specified fields from the messenger profile endpoint.", "response": "async def _get_messenger_profile(self, page, fields: List[Text]):\n        \"\"\"\n        Fetch the value of specified fields in order to avoid setting the same\n        field twice at the same value (since Facebook engineers are not able\n        to make menus that keep on working if set again).\n        \"\"\"\n\n        params = {\n            'access_token': page['page_token'],\n            'fields': ','.join(fields),\n        }\n\n        get = self.session.get(PROFILE_ENDPOINT, params=params)\n        async with get as r:\n            await self._handle_fb_response(r)\n\n            out = {}\n\n            for data in (await r.json())['data']:\n                out.update(data)\n\n            return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _send_to_messenger_profile(self, page, content):\n\n        log_name = ', '.join(repr(x) for x in content.keys())\n        page_id = page['page_id']\n\n        current = await self._get_messenger_profile(page, content.keys())\n\n        if dict_is_subset(content, current):\n            logger.info('Page %s: %s is already up to date', page_id, log_name)\n            return\n\n        params = {\n            'access_token': page['page_token'],\n        }\n\n        headers = {\n            'content-type': 'application/json',\n        }\n\n        post = self.session.post(\n            PROFILE_ENDPOINT,\n            params=params,\n            headers=headers,\n            data=ujson.dumps(content)\n        )\n\n        # noinspection PyBroadException\n        try:\n            async with post as r:\n                await self._handle_fb_response(r)\n        except Exception:\n            logger.exception('Page %s: %s could not be set', page_id, log_name)\n            reporter.report()\n        else:\n            logger.info('Page %s: %s was updated', page_id, log_name)", "response": "Send content to the messenger profile API."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the get started action for all configured pages.", "response": "async def _set_get_started(self):\n        \"\"\"\n        Set the \"get started\" action for all configured pages.\n        \"\"\"\n\n        page = self.settings()\n\n        if 'get_started' in page:\n            payload = page['get_started']\n        else:\n            payload = {'action': 'get_started'}\n\n        await self._send_to_messenger_profile(page, {\n            'get_started': {\n                'payload': ujson.dumps(payload),\n            },\n        })\n\n        logger.info('Get started set for page %s', page['page_id'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _set_greeting_text(self):\n\n        page = self.settings()\n\n        if 'greeting' in page:\n            await self._send_to_messenger_profile(page, {\n                'greeting': page['greeting'],\n            })\n\n            logger.info('Greeting text set for page %s', page['page_id'])", "response": "Set the greeting text of the page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndefine the persistent menu for all pages", "response": "async def _set_persistent_menu(self):\n        \"\"\"\n        Define the persistent menu for all pages\n        \"\"\"\n\n        page = self.settings()\n\n        if 'menu' in page:\n            await self._send_to_messenger_profile(page, {\n                'persistent_menu': page['menu'],\n            })\n\n            logger.info('Set menu for page %s', page['page_id'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def _set_whitelist(self):\n\n        page = self.settings()\n\n        if 'whitelist' in page:\n            await self._send_to_messenger_profile(page, {\n                'whitelisted_domains': page['whitelist'],\n            })\n\n            logger.info('Whitelisted %s for page %s',\n                        page['whitelist'],\n                        page['page_id'])", "response": "Set the whitelisted domains for the messenger extensions"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_subscriptions_endpoint(self):\n\n        s = self.settings()\n\n        params = {\n            'access_token': self.app_access_token,\n        }\n\n        return (\n            GRAPH_ENDPOINT.format(f'{s[\"app_id\"]}/subscriptions'),\n            params,\n        )", "response": "Generates the URL and tokens for the subscriptions endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting the currently active subscriptions", "response": "async def _get_subscriptions(self) -> Tuple[Set[Text], Text]:\n        \"\"\"\n        List the subscriptions currently active\n        \"\"\"\n\n        url, params = self._get_subscriptions_endpoint()\n\n        get = self.session.get(url, params=params)\n\n        async with get as r:\n            await self._handle_fb_response(r)\n            data = await r.json()\n\n            for scope in data['data']:\n                if scope['object'] == 'page':\n                    return (\n                        set(x['name'] for x in scope['fields']),\n                        scope['callback_url'],\n                    )\n\n        return set(), ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _set_subscriptions(self, subscriptions):\n\n        url, params = self._get_subscriptions_endpoint()\n\n        data = {\n            'object': 'page',\n            'callback_url': self.webhook_url,\n            'fields': ', '.join(subscriptions),\n            'verify_token': self.verify_token,\n        }\n\n        headers = {\n            'Content-Type': 'application/json',\n        }\n\n        post = self.session.post(\n            url,\n            params=params,\n            data=ujson.dumps(data),\n            headers=headers,\n        )\n\n        async with post as r:\n            await self._handle_fb_response(r)\n            data = await r.json()", "response": "Set the subscriptions to a specific list of values\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _check_subscriptions(self):\n\n        subscribed, url = await self._get_subscriptions()\n        expect = set(settings.FACEBOOK_SUBSCRIPTIONS)\n\n        if (expect - subscribed) or url != self.webhook_url:\n            await self._set_subscriptions(expect | subscribed)\n            logger.info('Updated webhook subscriptions')\n        else:\n            logger.info('No need to update webhook subscriptions')", "response": "Checks that all subscriptions are subscribed and update the webhook url if needed"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle an incoming message from Facebook.", "response": "async def handle_event(self, event: FacebookMessage):\n        \"\"\"\n        Handle an incoming message from Facebook.\n        \"\"\"\n        responder = FacebookResponder(self)\n        await self._notify(event, responder)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _access_token(self, request: Request=None, page_id: Text=''):\n\n        if not page_id:\n            msg = request.message  # type: FacebookMessage\n            page_id = msg.get_page_id()\n\n        page = self.settings()\n\n        if page['page_id'] == page_id:\n            return page['page_token']\n\n        raise PlatformOperationError('Trying to get access token of the '\n                                     'page \"{}\", which is not configured.'\n                                     .format(page_id))", "response": "Guess the access token for a specific request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _make_qr(self,\n                       qr: QuickRepliesList.BaseOption,\n                       request: Request):\n        \"\"\"\n        Generate a single quick reply's content.\n        \"\"\"\n\n        if isinstance(qr, QuickRepliesList.TextOption):\n            return {\n                'content_type': 'text',\n                'title': await render(qr.text, request),\n                'payload': qr.slug,\n            }\n        elif isinstance(qr, QuickRepliesList.LocationOption):\n            return {\n                'content_type': 'location',\n            }", "response": "Generate a single quick reply s content."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends text layers to the user.", "response": "async def _send_text(self, request: Request, stack: Stack):\n        \"\"\"\n        Send text layers to the user. Each layer will go in its own bubble.\n\n        Also, Facebook limits messages to 320 chars, so if any message is\n        longer than that it will be split into as many messages as needed to\n        be accepted by Facebook.\n        \"\"\"\n\n        parts = []\n\n        for layer in stack.layers:\n            if isinstance(layer, lyr.MultiText):\n                lines = await render(layer.text, request, multi_line=True)\n                for line in lines:\n                    for part in wrap(line, 320):\n                        parts.append(part)\n            elif isinstance(layer, (lyr.Text, lyr.RawText)):\n                text = await render(layer.text, request)\n                for part in wrap(text, 320):\n                    parts.append(part)\n\n        for part in parts[:-1]:\n            await self._send(request, {\n                'text': part,\n            }, stack)\n\n        part = parts[-1]\n\n        msg = {\n            'text': part,\n        }\n\n        await self._add_qr(stack, msg, request)\n        await self._send(request, msg, stack)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _send_generic_template(self, request: Request, stack: Stack):\n\n        gt = stack.get_layer(GenericTemplate)\n        payload = await gt.serialize(request)\n\n        msg = {\n            'attachment': {\n                'type': 'template',\n                'payload': payload\n            }\n        }\n\n        await self._add_qr(stack, msg, request)\n        await self._send(request, msg, stack)", "response": "Generates and sends a generic template."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _send_button_template(self, request: Request, stack: Stack):\n\n        gt = stack.get_layer(ButtonTemplate)\n\n        payload = {\n            'template_type': 'button',\n            'text': await render(gt.text, request),\n            'buttons': [await b.serialize(request) for b in gt.buttons],\n        }\n\n        msg = {\n            'attachment': {\n                'type': 'template',\n                'payload': payload\n            }\n        }\n\n        await self._add_qr(stack, msg, request)\n        await self._send(request, msg, stack)", "response": "Generates and sends a button template."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends to Facebook typing indications", "response": "async def _send_typing(self, request: Request, stack: Stack):\n        \"\"\"\n        Send to Facebook typing indications\n        \"\"\"\n\n        active = stack.get_layer(lyr.Typing).active\n\n        msg = ujson.dumps({\n            'recipient': {\n                'id': request.conversation.fbid,\n            },\n            'sender_action': 'typing_on' if active else 'typing_off',\n        })\n\n        headers = {\n            'content-type': 'application/json',\n        }\n\n        params = {\n            'access_token': self._access_token(request),\n        }\n\n        post = self.session.post(\n            MESSAGES_ENDPOINT,\n            params=params,\n            data=msg,\n            headers=headers,\n        )\n\n        logger.debug('Sending: %s', msg)\n\n        async with post as r:\n            await self._handle_fb_response(r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if Facebook was OK and raise an exception if it failed.", "response": "async def _handle_fb_response(self, response: aiohttp.ClientResponse):\n        \"\"\"\n        Check that Facebook was OK with the API call we just made and raise\n        an exception if it failed.\n        \"\"\"\n\n        ok = response.status == 200\n\n        if not ok:\n            # noinspection PyBroadException\n            try:\n                error = (await response.json())['error']['message']\n            except Exception:\n                error = '(nothing)'\n\n            raise PlatformOperationError('Facebook says: \"{}\"'\n                                         .format(error))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _send(self,\n                    request: Request,\n                    content: Dict[Text, Any],\n                    stack: Stack):\n        \"\"\"\n        Actually proceed to sending the message to the Facebook API.\n        \"\"\"\n\n        msg = {\n            'recipient': {\n                'id': request.conversation.fbid,\n            },\n            'message': content,\n        }\n\n        if stack and stack.has_layer(MessagingType):\n            mt = stack.get_layer(MessagingType)\n        else:\n            mt = MessagingType(response=True)\n\n        msg.update(mt.serialize())\n        msg_json = ujson.dumps(msg)\n\n        headers = {\n            'content-type': 'application/json',\n        }\n\n        params = {\n            'access_token': self._access_token(request),\n        }\n\n        post = self.session.post(\n            MESSAGES_ENDPOINT,\n            params=params,\n            data=msg_json,\n            headers=headers,\n        )\n\n        logger.debug('Sending: %s', msg_json)\n\n        async with post as r:\n            await self._handle_fb_response(r)", "response": "Send the message to Facebook API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_user(self, user_id, page_id):\n\n        access_token = self._access_token(page_id=page_id)\n\n        params = {\n            'fields': 'first_name,last_name,profile_pic,locale,timezone'\n                      ',gender',\n            'access_token': access_token,\n        }\n\n        url = GRAPH_ENDPOINT.format(user_id)\n\n        get = self.session.get(url, params=params)\n        async with get as r:\n            await self._handle_fb_response(r)\n            return await r.json()", "response": "Query a user from the API and return its JSON representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure that the given media is usable.", "response": "async def ensure_usable_media(self, media: BaseMedia) -> UrlMedia:\n        \"\"\"\n        So far, let's just accept URL media. We'll see in the future how it\n        goes.\n        \"\"\"\n\n        if not isinstance(media, UrlMedia):\n            raise ValueError('Facebook platform only accepts URL media')\n\n        return media"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a fake message for the given user_id page_id and payload.", "response": "def _make_fake_message(self, user_id, page_id, payload):\n        \"\"\"\n        Creates a fake message for the given user_id. It contains a postback\n        with the given payload.\n        \"\"\"\n\n        event = {\n            'sender': {\n                'id': user_id,\n            },\n            'recipient': {\n                'id': page_id,\n            },\n            'postback': {\n                'payload': ujson.dumps(payload),\n            },\n        }\n\n        return FacebookMessage(event, self, False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry to verify the signed request and returns a fake message.", "response": "def _message_from_sr(self, token: Text, payload: Any) \\\n            -> Optional[BaseMessage]:\n        \"\"\"\n        Tries to verify the signed request\n        \"\"\"\n\n        page = self.settings()\n        secret = page['app_secret']\n\n        try:\n            sr_data = SignedRequest.parse(token, secret)\n        except (TypeError, ValueError, SignedRequestError) as e:\n            return\n\n        return self._make_fake_message(\n            sr_data['psid'],\n            page['page_id'],\n            payload,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _message_from_token(self, token: Text, payload: Any) \\\n            -> Optional[BaseMessage]:\n        \"\"\"\n        Analyzes a signed token and generates the matching message\n        \"\"\"\n\n        try:\n            tk = jwt.decode(token, settings.WEBVIEW_SECRET_KEY)\n        except jwt.InvalidTokenError:\n            return\n\n        try:\n            user_id = tk['fb_psid']\n            assert isinstance(user_id, Text)\n            page_id = tk['fb_pid']\n            assert isinstance(page_id, Text)\n        except (KeyError, AssertionError):\n            return\n\n        if self.settings()['page_id'] == page_id:\n            return self._make_fake_message(user_id, page_id, payload)", "response": "Generates a fake message from a signed token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def message_from_token(self, token: Text, payload: Any) \\\n            -> Optional[BaseMessage]:\n        \"\"\"\n        There is two ways of getting a FB user: either with a signed request or\n        either with a platform token. Both are tried out.\n        \"\"\"\n\n        methods = [\n            self._message_from_sr,\n            self._message_from_token,\n        ]\n\n        for method in methods:\n            msg = method(token, payload)\n\n            if msg:\n                return msg", "response": "Get a message from a token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_layer(self, class_: Type[L], became: bool=True) -> bool:\n        return self.stack.has_layer(class_, became)", "response": "Returns true if the stack has a layer with the given class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a specific layer from the stack.", "response": "def get_layer(self, class_: Type[L], became: bool=True) -> L:\n        \"\"\"\n        Proxy to stack\n        \"\"\"\n        return self.stack.get_layer(class_, became)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the layers of the given class.", "response": "def get_layers(self, class_: Type[L], became: bool=True) -> List[L]:\n        \"\"\"\n        Proxy to stack\n        \"\"\"\n        return self.stack.get_layers(class_, became)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the locale to use for this request.", "response": "async def get_locale(self) -> Text:\n        \"\"\"\n        Get the locale to use for this request. It's either the overridden\n        locale or the locale provided by the platform.\n\n        :return: Locale to use for this request\n        \"\"\"\n\n        if self._locale_override:\n            return self._locale_override\n        else:\n            return await self.user.get_locale()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_trans_flags(self) -> 'Flags':\n\n        from bernard.middleware import MiddlewareManager\n\n        async def make_flags(request: Request) -> 'Flags':\n            return {}\n\n        mf = MiddlewareManager.instance().get('make_trans_flags', make_flags)\n        return await mf(self)", "response": "Returns the flags that should be applied to the translation of the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def sign_url(self, url, method=HASH):\n\n        token = await self.get_token()\n\n        if method == self.QUERY:\n            return patch_qs(url, {\n                settings.WEBVIEW_TOKEN_KEY: token,\n            })\n        elif method == self.HASH:\n            hash_id = 5\n            p = list(urlparse(url))\n            p[hash_id] = quote(token)\n            return urlunparse(p)\n        else:\n            raise ValueError(f'Invalid signing method \"{method}\"')", "response": "Sign an URL with this request s auth token"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef layers(self, value: List['BaseLayer']):\n        self._layers = list(value)  # type: List[BaseLayer]\n        self._index = self._make_index()\n        self._transformed = {}", "response": "Set the list of layers for this entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming the index computation.", "response": "def _make_index(self):\n        \"\"\"\n        Perform the index computation. It groups layers by type into a\n        dictionary, to allow quick access.\n        \"\"\"\n\n        out = {}\n\n        for layer in self._layers:\n            cls = layer.__class__\n            out[cls] = out.get(cls, []) + [layer]\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_layer(self, class_: Type[L], became: bool=True) -> bool:\n\n        return (class_ in self._index or\n                (became and class_ in self._transformed))", "response": "Test if a given layer type is present in the results."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the first layer of a given class.", "response": "def get_layer(self, class_: Type[L], became: bool=True) -> L:\n        \"\"\"\n        Return the first layer of a given class. If that layer is not present,\n        then raise a KeyError.\n\n        :param class_: class of the expected layer\n        :param became: Allow transformed layers in results\n        \"\"\"\n\n        try:\n            return self._index[class_][0]\n        except KeyError:\n            if became:\n                return self._transformed[class_][0]\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_layers(self, class_: Type[L], became: bool=True) -> List[L]:\n\n        out = self._index.get(class_, [])\n\n        if became:\n            out += self._transformed.get(class_, [])\n\n        return out", "response": "Returns the list of layers of a given class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_site_name(request):\n    urlparts = request.urlparts\n    return ':'.join([urlparts.hostname, str(urlparts.port)])", "response": "Return the domain part of the URL without scheme."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_full_path(request):\n    path = request.fullpath\n    query_string = request.environ.get('QUERY_STRING')\n    if query_string:\n        path += '?' + to_native(query_string)\n    return path", "response": "Return the current relative path including the query string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_full_url(request, url):\n    urlparts = request.urlparts\n    return '{scheme}://{site}/{url}'.format(\n        scheme=urlparts.scheme,\n        site=get_site_name(request),\n        url=url.lstrip('/'),\n    )", "response": "Get a relative URL and returns the absolute version."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an HTPP response containing the given body and mimetype.", "response": "def make_response(body, mimetype='text/html'):\n    \"\"\"Build a framework specific HTPP response, containing ``body`` and\n    marked as the type ``mimetype``.\n    \"\"\"\n    from bottle import response\n    response.content_type = mimetype\n    return body or u''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_trajectory_id(self, dataset):\n        '''\n        Checks that if a variable exists for the trajectory id it has the appropriate attributes\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n        '''\n        results = []\n        exists_ctx = TestCtx(BaseCheck.MEDIUM, 'Variable defining \"trajectory_id\" exists')\n        trajectory_ids = dataset.get_variables_by_attributes(cf_role='trajectory_id')\n        # No need to check\n        exists_ctx.assert_true(trajectory_ids, 'variable defining cf_role=\"trajectory_id\" exists')\n        if not trajectory_ids:\n            return exists_ctx.to_result()\n        results.append(exists_ctx.to_result())\n        test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for the {} variable'.format(trajectory_ids[0].name))\n        test_ctx.assert_true(\n            getattr(trajectory_ids[0], 'long_name', '') != \"\",\n            \"long_name attribute should exist and not be empty\"\n        )\n        results.append(test_ctx.to_result())\n        return results", "response": "Checks that a variable exists for the trajectory id it has the appropriate attributes for the trajectory id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_required_attributes(self, dataset):\n        '''\n        Feature type specific check of global required and highly recommended attributes.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n        '''\n        results = []\n        required_ctx = TestCtx(BaseCheck.HIGH, 'Required Global Attributes for Trajectory dataset')\n        required_ctx.assert_true(\n            getattr(dataset, 'nodc_template_version', '').lower() == self.valid_templates[0].lower(),\n            'nodc_template_version attribute must be {}'.format(self.valid_templates[0])\n        )\n        required_ctx.assert_true(\n            getattr(dataset, 'cdm_data_type', '') == 'Trajectory',\n            'cdm_data_type attribute must be set to Trajectory'\n        )\n        required_ctx.assert_true(\n            getattr(dataset, 'featureType', '') == 'trajectory',\n            'featureType attribute must be set to trajectory'\n        )\n        results.append(required_ctx.to_result())\n        return results", "response": "Feature type specific check of global required and highly recommended attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current user UID in the session.", "response": "def login(self, user, remember=True, session=None):\n        \"\"\"Sets the current user UID in the session.\n\n        Instead of just storing the user's id, it generates a hash from the\n        password *salt*. That way, an admin or the user herself can invalidate\n        the login in other computers just by changing (or re-saving)\n        her password.\n\n        \"\"\"\n        logger = logging.getLogger(__name__)\n        logger.debug(u'User `{0}` logged in'.format(user.login))\n        if session is None:\n            session = self.session\n        session['permanent'] = remember\n        session[self.session_key] = user.get_uhmac()\n        if callable(getattr(session, 'save', None)):\n            session.save()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the index of an element in the children of a parent.", "response": "def index(elem):\n    '''\n    Return the index position of an element in the children of a parent.\n    '''\n    parent = elem.getparent()\n    for x in range(0, len(parent.getchildren())):\n        if parent.getchildren()[x] == elem:\n            return x\n    return -1"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a parent element replace oldelem with newelem.", "response": "def replaceelement(oldelem, newelem):\n    '''\n    Given a parent element, replace oldelem with newelem.\n    '''\n    parent = oldelem.getparent()\n    if parent is not None:\n        size = len(parent.getchildren())\n        for x in range(0, size):\n            if parent.getchildren()[x] == oldelem:\n                parent.remove(oldelem)\n                parent.insert(x, newelem)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the content of an element into more ElementTree structures.", "response": "def parseelement(elem):\n    '''\n    Convert the content of an element into more ElementTree structures.\n    We do this because sometimes we want to set xml as the content of an element.\n    '''\n    xml = '<%(tag)s>%(content)s</%(tag)s>' % {'tag' : elem.tag, 'content' : elem.text}\n    et = etree.fromstring(xml)\n    replaceelement(elem, et)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_min_max_range(self, var, test_ctx):\n        if 'valid_range' in var.ncattrs():\n            test_ctx.assert_true(var.valid_range.dtype == var.dtype and\n                                 len(var.valid_range) == 2\n                                 and var.valid_range[0] <= var.valid_range[1],\n                                 \"valid_range must be a two element vector of min followed by max with the same data type as {}\".format(var.name)\n                                 )\n        else:\n            for bound in ('valid_min', 'valid_max'):\n                v_bound = getattr(var, bound, '')\n                warn_msg = '{} attribute should exist, have the same type as {}, and not be empty or valid_range should be defined'.format(bound, var.name)\n                # need to special case str attributes since they aren't directly\n                # comparable to numpy dtypes\n                if isinstance(v_bound, six.string_types):\n                    test_ctx.assert_true(v_bound != '' and\n                                         var.dtype.char == 'S', warn_msg)\n                # otherwise compare the numpy types directly\n                else:\n                    test_ctx.assert_true(v_bound.dtype == var.dtype, warn_msg)\n        return test_ctx", "response": "Checks that both valid_min and valid_max exist and that both valid_min and valid_max exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the latitude variable for validity", "response": "def check_lat(self, dataset):\n        '''\n        float lat(time) ;//....................................... Depending on the precision used for the variable, the data type could be int or double instead of float.\n                lat:long_name = \"\" ; //...................................... RECOMMENDED - Provide a descriptive, long name for this variable.\n                lat:standard_name = \"latitude\" ; //.......................... REQUIRED    - Do not change.\n                lat:units = \"degrees_north\" ; //............................. REQUIRED    - CF recommends degrees_north, but at least must use UDUNITS.\n                lat:axis = \"Y\" ; //.......................................... REQUIRED    - Do not change.\n                lat:valid_min = 0.0f ; //.................................... RECOMMENDED - Replace with correct value.\n                lat:valid_max = 0.0f ; //.................................... RECOMMENDED - Replace with correct value.\n                lat:_FillValue = 0.0f;//..................................... REQUIRED  if there could be missing values in the data.\n                lat:ancillary_variables = \"\" ; //............................ RECOMMENDED - List other variables providing information about this variable.\n                lat:comment = \"\" ; //........................................ RECOMMENDED - Add useful, additional information here.\n        '''\n\n        results = []\n        lat = util.get_lat_variable(dataset)\n        if not lat:\n            return Result(BaseCheck.HIGH, False, 'latitude', ['a variable for latitude doesn\\'t exist'])\n        lat_var = dataset.variables[lat]\n        test_ctx = TestCtx(BaseCheck.HIGH, 'Required attributes for variable {}'.format(lat))\n        test_ctx.assert_true(getattr(lat_var, 'standard_name', '') == 'latitude', 'standard_name attribute must be latitude')\n        units = getattr(lat_var, 'units', '')\n        test_ctx.assert_true(units and units_convertible(units, 'degrees_north'), 'units are valid UDUNITS for latitude')\n        test_ctx.assert_true(getattr(lat_var, 'axis', '') == 'Y', '{} axis attribute must be Y'.format(lat))\n\n        results.append(test_ctx.to_result())\n\n        test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for variable {}'.format(lat))\n        test_ctx.assert_true(getattr(lat_var, 'long_name', '') != '', 'long_name attribute should exist and not be empty')\n        self._check_min_max_range(lat_var, test_ctx)\n        if hasattr(lat_var, 'comment'):\n            test_ctx.assert_true(getattr(lat_var, 'comment', '') != '', 'comment attribute should not be empty if specified')\n        test_ctx.assert_true(getattr(lat_var, 'comment', '') != '', 'comment attribute should exist and not be empty')\n        test_ctx.assert_true(units == 'degrees_north', '{} should have units degrees_north'.format(lat))\n        results.append(test_ctx.to_result())\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the variable for longitude exists in the dataset.", "response": "def check_lon(self, dataset):\n        '''\n        float lon(timeSeries) ; //........................................ Depending on the precision used for the variable, the data type could be int or double instead of float.\n            lon:long_name = \"\" ; //...................................... RECOMMENDED\n            lon:standard_name = \"longitude\" ; //......................... REQUIRED    - This is fixed, do not change.\n            lon:units = \"degrees_east\" ; //.............................. REQUIRED    - CF recommends degrees_east, but at least use UDUNITS.\n            lon:axis = \"X\" ; //.......................................... REQUIRED    - Do not change.\n            lon:valid_min = 0.0f ; //.................................... RECOMMENDED - Replace this with correct value.\n            lon:valid_max = 0.0f ; //.................................... RECOMMENDED - Replace this with correct value.\n            lon:_FillValue = 0.0f;//..................................... REQUIRED  if there could be missing values in the data.\n            lon:ancillary_variables = \"\" ; //............................ RECOMMENDED - List other variables providing information about this variable.\n            lon:comment = \"\" ; //........................................ RECOMMENDED - Add useful, additional information here.\n        '''\n        results = []\n        lon = util.get_lon_variable(dataset)\n        if not lon:\n            return Result(BaseCheck.HIGH, False, 'longitude', ['a variable for longitude doesn\\'t exist'])\n        lon_var = dataset.variables[lon]\n        test_ctx = TestCtx(BaseCheck.HIGH, 'Required attributes for variable {}'.format(lon))\n        test_ctx.assert_true(getattr(lon_var, 'standard_name', '') == 'longitude', 'standard_name attribute must be longitude')\n        units = getattr(lon_var, 'units', '')\n        test_ctx.assert_true(units and units_convertible(units, 'degrees_east'), 'units are valid UDUNITS for longitude')\n        test_ctx.assert_true(getattr(lon_var, 'axis', '') == 'X', '{} axis attribute must be X'.format(lon))\n\n        results.append(test_ctx.to_result())\n\n        test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for variable {}'.format(lon))\n        test_ctx.assert_true(getattr(lon_var, 'long_name', '') != '', 'long_name attribute should exist and not be empty')\n        self._check_min_max_range(lon_var, test_ctx)\n\n        if hasattr(lon_var, 'comment'):\n            test_ctx.assert_true(getattr(lon_var, 'comment', '') != '', 'comment attribute should not be empty if specified')\n        test_ctx.assert_true(units == 'degrees_east', '{} should have units degrees_east'.format(lon))\n        results.append(test_ctx.to_result())\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_time(self, dataset):\n        '''\n        double time(time) ;//........................................ Depending on the precision used for the variable, the data type could be int or double instead of float.\n            time:long_name = \"\" ; //..................................... RECOMMENDED - Provide a descriptive, long name for this variable.\n            time:standard_name = \"time\" ; //............................. REQUIRED    - Do not change\n            time:units = \"seconds since 1970-01-01 00:00:00 0:00\" ; //... REQUIRED    - Use approved CF convention with approved UDUNITS.\n            time:calendar = \"julian\" ; //................................ REQUIRED    - IF the calendar is not default calendar, which is \"gregorian\".\n            time:axis = \"T\" ; //......................................... REQUIRED    - Do not change.\n            time:_FillValue = 0.0f;//.................................... REQUIRED  if there could be missing values in the data.\n            time:ancillary_variables = \"\" ; //........................... RECOMMENDED - List other variables providing information about this variable.\n            time:comment = \"\" ; //....................................... RECOMMENDED - Add useful, additional information here.\n        '''\n        results = []\n        time_var = util.get_time_variable(dataset)\n        if not time_var:\n            return Result(BaseCheck.HIGH, False, 'Coordinate variable time', ['Time coordinate variable was not found'])\n        required_ctx = TestCtx(BaseCheck.HIGH, 'Required attributes for variable time')\n        required_ctx.assert_true(getattr(dataset.variables[time_var], 'standard_name', '') == 'time', 'standard_name is \"time\"')\n        time_regex = r'(seconds|minutes|hours|days) since.*'\n        time_units = getattr(dataset.variables[time_var], 'units', '')\n        required_ctx.assert_true(re.match(time_regex, time_units) is not None, 'Valid units for time')\n        calendar = getattr(dataset.variables[time_var], 'calendar', '')\n        valid_calendars = [\n            'standard',\n            'gregorian',\n            'proleptic_gregorian',\n            'noleap',\n            '365_day',\n            '360_day',\n            'julian',\n            'all_leap',\n            '366_day'\n        ]\n\n        if calendar:\n            required_ctx.assert_true(calendar.lower() in valid_calendars, 'calendar attribute should be a valid calendar in ({})'.format(', '.join(valid_calendars)))\n\n        results.append(required_ctx.to_result())\n        recommended_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for variable time')\n        recommended_ctx.assert_true(getattr(dataset.variables[time_var], 'long_name', '') != '', 'long_name attribute should exist and not be empty')\n        if hasattr(dataset.variables[time_var], 'comment'):\n            recommended_ctx.assert_true(getattr(dataset.variables[time_var], 'comment', '') != '', 'comment attribute should not be empty if specified')\n        results.append(recommended_ctx.to_result())\n\n        return results", "response": "Checks the time variable for validity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_height(self, dataset):\n        '''\n        float z(time) ;//........................................ Depending on the precision used for the variable, the data type could be int or double instead of float. Also the variable \"z\" could be substituted with a more descriptive name like \"depth\", \"altitude\", \"pressure\", etc.\n                z:long_name = \"\" ; //........................................ RECOMMENDED - Provide a descriptive, long name for this variable.\n                z:standard_name = \"\" ; //.................................... REQUIRED    - Usually \"depth\" or \"altitude\" is used.\n                z:units = \"\" ; //............................................ REQUIRED    - Use UDUNITS.\n                z:axis = \"Z\" ; //............................................ REQUIRED    - Do not change.\n                z:positive = \"\" ; //......................................... REQUIRED    - Use \"up\" or \"down\".\n                z:valid_min = 0.0f ; //...................................... RECOMMENDED - Replace with correct value.\n                z:valid_max = 0.0f ; //...................................... RECOMMENDED - Replace with correct value.\n                z:_FillValue = 0.0f;//....................................... REQUIRED  if there could be missing values in the data.\n                z:ancillary_variables = \"\" ; //.............................. RECOMMENDED - List other variables providing information about this variable.\n                z:comment = \"\" ; //.......................................... RECOMMENDED - Add useful, additional information here.\n                '''\n        results = []\n\n        exists_ctx = TestCtx(BaseCheck.HIGH, 'Variable for height must exist')\n        var = util.get_z_variable(dataset)\n        exists_ctx.assert_true(var is not None, \"A variable for height must exist\")\n        if var is None:\n            return exists_ctx.to_result()\n\n        # Check Height Name\n        required_ctx = TestCtx(BaseCheck.HIGH, 'Required attributes for variable {}'.format(var))\n\n        # Check Standard Name\n        standard_name = getattr(dataset.variables[var], 'standard_name', '')\n        required_ctx.assert_true(\n            standard_name in ('depth', 'height', 'altitude'),\n            '{} is not a valid standard_name for height'.format(standard_name)\n        )\n\n        axis = getattr(dataset.variables[var], 'axis', '')\n        required_ctx.assert_true(\n            axis == 'Z',\n            '{} must have an axis of Z'.format(var)\n        )\n\n        # Check Units\n        valid_units = False\n        units = getattr(dataset.variables[var], 'units', '1')\n        try:\n            # If cf_units fails to read the units, then it's not a valid unit\n            Unit(units)\n            valid_units = True\n        except:\n            pass\n        required_ctx.assert_true(valid_units, '{} are not valid units for height'.format(units))\n\n        positive = getattr(dataset.variables[var], 'positive', '')\n        required_ctx.assert_true(positive in ('up', 'down'), 'height must have a positive attribute that is equal to \"up\" or \"down\"')\n        results.append(required_ctx.to_result())\n\n        # Check has these attributes\n        # We ommit checking ancillary_variables because that only applies if this variable HAS ancillary variables\n        recommended_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for coordinate variable {}'.format(var))\n        self._check_min_max_range(dataset.variables[var], recommended_ctx)\n\n        if hasattr(dataset.variables[var], 'comment'):\n            recommended_ctx.assert_true(getattr(dataset.variables[var], 'comment', '') != '', 'comment attribute should not be empty if specified')\n\n        results.append(recommended_ctx.to_result())\n        return results", "response": "Check the variable for height exists and has the correct values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the validity of a single flag in the specified dataset.", "response": "def check_qaqc(self, dataset):\n        '''\n        byte boolean_flag_variable(timeSeries,time); //............................. A boolean flag variable, in which each bit of the flag can be a 1 or 0.\n                boolean_flag_variable:standard_name= \"\" ; //................. RECOMMENDED - This attribute should include the standard name of the variable which this flag contributes plus the modifier: \"status_flag\" (for example, \"sea_water_temperature status_flag\"). See CF standard name modifiers.\n                boolean_flag_variable:long_name = \"\" ; //.................... RECOMMENDED - Provide a descriptive, long name for this variable.\n                boolean_flag_variable:flag_masks = ; //...................... REQUIRED    - Provide a comma-separated list describing the binary condition of the flags.\n                boolean_flag_variable:flag_meanings = \"\" ; //................ REQUIRED    - Provide a comma-separated list of flag values that map to the flag_masks.\n                boolean_flag_variable:references = \"\" ; //................... RECOMMENDED - Published or web-based references that describe the data or methods used to produce it.\n                boolean_flag_variable:comment = \"\" ; //...................... RECOMMENDED - Add useful, additional information here.\n        int enumerated_flag_variable(timeSeries,time);  //...................... An enumerated flag variable, in which numeric values refer to defined, exclusive conditions.\n                enumerated_flag_variable:standard_name= \"\" ; //.............. RECOMMENDED - This attribute should include the standard name of the variable which this flag contributes plus the modifier: \"status_flag\" (for example, \"sea_water_temperature status_flag\"). See CF standard name modifiers.\n                enumerated_flag_variable:long_name = \"\" ; //................. RECOMMENDED - Provide a descriptive, long name for this variable.\n                enumerated_flag_variable:flag_values = ; //.................. REQUIRED    - Provide a comma-separated list of flag values that map to the flag_meanings.\n                enumerated_flag_variable:flag_meanings = \"\" ; //............. REQUIRED    - Provide a space-separated list of meanings corresponding to each of the flag_values\n                enumerated_flag_variable:references = \"\" ; //................ RECOMMENDED - Published or web-based references that describe the data or methods used to produce it.\n                enumerated_flag_variable:comment = \"\" ; //................... RECOMMENDED - Add useful, additional information here.\n        '''\n        # Check the qaqc variables to ensure they are good\n        results = []\n\n        flag_variables = dataset.get_variables_by_attributes(flag_meanings=lambda x: x is not None)\n        for flag_variable in flag_variables:\n            required_ctx = TestCtx(BaseCheck.HIGH, 'Required attributes for flag variable {}'.format(flag_variable.name))\n            flag_values = getattr(flag_variable, 'flag_values', None)\n            flag_masks = getattr(flag_variable, 'flag_masks', None)\n            required_ctx.assert_true(flag_values is not None or flag_masks is not None, 'flag variable must define either flag_values or flag_masks')\n            results.append(required_ctx.to_result())\n\n            recommended_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for flag variable {}'.format(flag_variable.name))\n            standard_name = getattr(flag_variable, 'standard_name', '')\n            recommended_ctx.assert_true(standard_name.endswith(' status_flag'), 'The standard_name attribute should end with status_flag')\n\n            varattr = getattr(flag_variable, 'long_name', '')\n            recommended_ctx.assert_true(varattr != '', 'The {} attribute should exist and not be empty'.format('long_name'))\n\n            if hasattr(flag_variable, 'comment'):\n                recommended_ctx.assert_true(getattr(flag_variable, 'comment', '') != '', 'comment attribute should not be empty if specified')\n\n            results.append(recommended_ctx.to_result())\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck that the variable for instrument exists.", "response": "def check_instrument(self, dataset):\n        '''\n        int instrument_parameter_variable(timeSeries); // ... RECOMMENDED - an instrument variable storing information about a parameter of the instrument used in the measurement, the dimensions don't have to be specified if the same instrument is used for all the measurements.\n            instrument_parameter_variable:long_name = \"\" ; // RECOMMENDED - Provide a descriptive, long name for this variable.\n            instrument_parameter_variable:comment = \"\" ; //.. RECOMMENDED - Add useful, additional information here.\n        '''\n        # Check for the instrument variable\n        instruments = util.get_instrument_variables(dataset)\n        if not instruments:\n            return Result(BaseCheck.MEDIUM, False, 'Recommended variable for instrument should exist', ['No instrument variables found'])\n        results = []\n        for instrument in instruments:\n            test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for instrument variable {}'.format(instrument))\n            var = dataset.variables[instrument]\n            test_ctx.assert_true(getattr(var, 'long_name', '') != '', 'long_name attribute should exist and not be empty')\n\n            if hasattr(var, 'comment'):\n                test_ctx.assert_true(getattr(var, 'comment', '') != '', 'comment attribute should not be empty if specified')\n\n            results.append(test_ctx.to_result())\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the grid mapping variable exists and contains the required attributes.", "response": "def check_crs(self, dataset):\n        '''\n        int crs; //.......................................................... RECOMMENDED - A container variable storing information about the grid_mapping. All the attributes within a grid_mapping variable are described in http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.6/cf-conventions.html#appendix-grid-mappings. For all the measurements based on WSG84, the default coordinate system used for GPS measurements, the values shown here should be used.\n                crs:grid_mapping_name = \"latitude_longitude\"; //............. RECOMMENDED\n                crs:epsg_code = \"EPSG:4326\" ; //............................. RECOMMENDED - European Petroleum Survey Group code for the grid mapping name.\n                crs:semi_major_axis = 6378137.0 ; //......................... RECOMMENDED\n                crs:inverse_flattening = 298.257223563 ; //.................. RECOMMENDED\n        '''\n        grid_mapping = util.get_crs_variable(dataset)\n        if grid_mapping is None:\n            return Result(\n                BaseCheck.MEDIUM,\n                False,\n                'Recommended variable for grid mapping should exist',\n                ['A variable to describe the grid mapping should exist']\n            )\n        crs_variable = dataset.variables[grid_mapping]\n        test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for grid mapping variable {}'.format(crs_variable.name))\n        test_ctx.assert_true(crs_variable is not None, 'A container variable storing the grid mapping should exist for this dataset.')\n\n        epsg_code = getattr(crs_variable, 'epsg_code', '')\n        semi_major_axis = getattr(crs_variable, 'semi_major_axis', None)\n        inverse_flattening = getattr(crs_variable, 'inverse_flattening', None)\n\n        test_ctx.assert_true(epsg_code != '',\n                             'Attribute epsg_code should exist and not be empty: {}'.format(epsg_code))\n        test_ctx.assert_true(semi_major_axis is not None,\n                             'Attribute semi_major_axis should exist and not be empty: {}'.format(epsg_code))\n        test_ctx.assert_true(inverse_flattening is not None,\n                             'Attribute inverse_flattening should exist and not be empty: {}'.format(epsg_code))\n        return test_ctx.to_result()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_base_required_attributes(self, dataset):\n        '''\n        Check the global required and highly recommended attributes for 1.1 templates. These go an extra step besides\n        just checking that they exist.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n\n\n        :Conventions = \"CF-1.6\" ; //......................................... REQUIRED    - Always try to use latest value. (CF)\n        :Metadata_Conventions = \"Unidata Dataset Discovery v1.0\" ; //........ REQUIRED    - Do not change. (ACDD)\n        :featureType = \"timeSeries\" ; //..................................... REQUIRED - CF attribute for identifying the featureType.\n        :cdm_data_type = \"Station\" ; //...................................... REQUIRED (ACDD)\n        :nodc_template_version = \"NODC_NetCDF_TimeSeries_Orthogonal_Template_v1.1\" ; //....... REQUIRED (NODC)\n        :standard_name_vocabulary = \"NetCDF Climate and Forecast (CF) Metadata Convention Standard Name Table \"X\"\" ; //........ REQUIRED    - If using CF standard name attribute for variables. \"X\" denotes the table number  (ACDD)\n        '''\n        test_ctx = TestCtx(BaseCheck.HIGH, 'Required global attributes')\n\n        conventions = getattr(dataset, 'Conventions', '')\n        metadata_conventions = getattr(dataset, 'Metadata_Conventions', '')\n        feature_type = getattr(dataset, 'featureType', '')\n        cdm_data_type = getattr(dataset, 'cdm_data_type', '')\n        standard_name_vocab = getattr(dataset, 'standard_name_vocabulary', '')\n\n        accepted_conventions = 'CF-1.6'\n\n        test_ctx.assert_true(conventions == accepted_conventions,\n                             'Conventions attribute is missing or is not equal to CF-1.6: {}'.format(conventions))\n        test_ctx.assert_true(metadata_conventions == 'Unidata Dataset Discovery v1.0',\n                             \"Metadata_Conventions attribute is required to be 'Unidata Dataset Discovery v1.0': {}\".format(metadata_conventions))\n        test_ctx.assert_true(feature_type in ['point', 'timeSeries', 'trajectory', 'profile', 'timeSeriesProfile', 'trajectoryProfile'],\n                             'Feature type must be one of point, timeSeries, trajectory, profile, timeSeriesProfile, trajectoryProfile: {}'.format(feature_type))\n        test_ctx.assert_true(cdm_data_type.lower() in ['grid', 'image', 'point', 'radial', 'station', 'swath', 'trajectory'],\n                             'cdm_data_type must be one of Grid, Image, Point, Radial, Station, Swath, Trajectory: {}'.format(cdm_data_type))\n\n        regex = re.compile(r'[sS]tandard [nN]ame [tT]able')\n        test_ctx.assert_true(regex.search(standard_name_vocab),\n                             \"standard_name_vocabulary doesn't contain 'Standard Name Table': {}\".format(standard_name_vocab))\n\n        return test_ctx.to_result()", "response": "Check the global required and highly recommended attributes for 1. 1 templates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the global recommended attributes for 1. 1 templates.", "response": "def check_recommended_global_attributes(self, dataset):\n        '''\n        Check the global recommended attributes for 1.1 templates. These go an extra step besides\n        just checking that they exist.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n\n        Basic \"does it exist\" checks are done in BaseNCEICheck:check_recommended\n        :title = \"\" ; //..................................................... RECOMMENDED - Provide a useful title for the data in the file. (ACDD)\n        :summary = \"\" ; //................................................... RECOMMENDED - Provide a useful summary or abstract for the data in the file. (ACDD)\n        :source = \"\" ; //.................................................... RECOMMENDED - The input data sources regardless of the method of production method used. (CF)\n        :platform = \"platform_variable\" ; //................................. RECOMMENDED - Refers to a variable containing information about the platform. May also put this in individual variables. Use NODC or ICES platform table. (NODC)\n        :instrument = \"instrument_parameter_variable\" ; //................... RECOMMENDED - Refers to a variable containing information about the instrument. May also put this in individual variables. Use NODC or GCMD instrument table. (NODC)\n        :uuid = \"\" ; //...................................................... RECOMMENDED - Machine readable unique identifier for each file. A new uuid is created whenever the file is changed. (NODC)\n        :sea_name = \"\" ; //.................................................. RECOMMENDED - The names of the sea in which the data were collected. Use NODC sea names table. (NODC)\n        :id = \"\" ; //........................................................ RECOMMENDED - Should be a human readable unique identifier for data set. (ACDD)\n        :naming_authority = \"\" ; //.......................................... RECOMMENDED - Backward URL of institution (for example, gov.noaa.nodc). (ACDD)\n        :time_coverage_start = \"\" ; //....................................... RECOMMENDED - Use ISO8601 for date and time. (ACDD)\n        :time_coverage_end = \"\" ; //......................................... RECOMMENDED - Use ISO8601 for date and time.(ACDD)\n        :time_coverage_resolution = \"\" ; //.................................. RECOMMENDED - For example, \"point\" or \"minute averages\". (ACDD)\n        :geospatial_lat_min = 0.0f ; //...................................... RECOMMENDED - Replace with correct value. (ACDD)\n        :geospatial_lat_max = 0.0f ; //...................................... RECOMMENDED - Replace with correct value. (ACDD)\n        :geospatial_lat_units = \"degrees_north\" ; //......................... RECOMMENDED - Use UDUNITS compatible units. (ACDD)\n        :geospatial_lat_resolution= \"\" ; //.................................. RECOMMENDED - For example, \"point\" or \"10 degree grid\". (ACDD)\n        :geospatial_lon_min = 0.0f ; //...................................... RECOMMENDED - Replace with correct value. (ACDD)\n        :geospatial_lon_max = 0.0f ; //...................................... RECOMMENDED - Replace with correct value. (ACDD)\n        :geospatial_lon_units = \"degrees_east\"; //........................... RECOMMENDED - Use UDUNITS compatible units. (ACDD)\n        :geospatial_lon_resolution= \"\" ; //.................................. RECOMMENDED - For example, \"point\" or \"10 degree grid\". (ACDD)\n        :geospatial_vertical_min = 0.0f ; //................................. RECOMMENDED - Replace with correct value. (ACDD)\n        :geospatial_vertical_max = 0.0f ; //................................. RECOMMENDED - Replace with correct value. (ACDD)\n        :geospatial_vertical_units = \"\" ; //................................. RECOMMENDED - Use UDUNITS compatible units. (ACDD)\n        :geospatial_vertical_resolution = \"\" ; //............................ RECOMMENDED - For example, \"point\" or \"1 meter binned\". (ACDD)\n        :geospatial_vertical_positive = \"\" ; //.............................. RECOMMENDED - Use \"up\" or \"down\". (ACDD)\n        :institution = \"\" ; //............................................... RECOMMENDED - Institution of the person or group that collected the data.  An institution attribute can be used for each variable if variables come from more than one institution. (ACDD)\n        :creator_name = \"\" ; //.............................................. RECOMMENDED - Name of the person who collected the data. (ACDD)\n        :creator_url = \"\" ; //............................................... RECOMMENDED - URL for person who collected the data. (ACDD)\n        :creator_email = \"\" ; //............................................. RECOMMENDED - Email address for person who collected the data. (ACDD)\n        :project = \"\" ; //................................................... RECOMMENDED - Project the data was collected under. (ACDD)\n        :processing_level = \"\" ; //.......................................... RECOMMENDED - Provide a description of the processing or quality control level of the data. (ACDD)\n        :references = \"\" ; //................................................ RECOMMENDED - Published or web-based references that describe the data or methods used to produce it. (CF)\n        :keywords_vocabulary = \"\" ; //....................................... RECOMMENDED - Identifies the controlled keyword vocabulary used to specify the values within the attribute \"keywords\". e.g. NASA/GCMD Earth Science Keywords (ACDD)\n        :keywords = \"\" ; //.................................................. RECOMMENDED - A comma separated list of keywords coming from the keywords_vocabulary. (ACDD)\n        :acknowledgment = \"\" ; //............................................ RECOMMENDED - Text to use to properly acknowledge use of the data. (ACDD)\n        :comment = \"\" ; //................................................... RECOMMENDED - Provide useful additional information here. (ACDD and CF)\n        :contributor_name = \"\" ; //.......................................... RECOMMENDED - A comma separated list of contributors to this data set. (ACDD)\n        :contributor_role = \"\" ; //.......................................... RECOMMENDED - A comma separated list of their roles. (ACDD)\n        :date_created = \"\" ; //.............................................. RECOMMENDED - Creation date of the netCDF.  Use ISO8601 for date and time. (ACDD)\n        :date_modified = \"\" ; //............................................. RECOMMENDED - Modification date of the netCDF.  Use ISO8601 for date and time. (ACDD)\n        :publisher_name = \"\" ; //............................................ RECOMMENDED - Publisher of the data. (ACDD)\n        :publisher_email = \"\" ; //........................................... RECOMMENDED - Email address of the publisher of the data. (ACDD)\n        :publisher_url = \"\" ; //............................................. RECOMMENDED - A URL for the publisher of the data. (ACDD)\n        :history = \"\" ; //................................................... RECOMMENDED - Record changes made to the netCDF. (ACDD)\n        :license = \"\" ; //................................................... RECOMMENDED - Describe the restrictions to data access and distribution. (ACDD)\n        :metadata_link = \"\" ; //............................................. RECOMMENDED - This attribute provides a link to a complete metadata record for this data set or the collection that contains this data set. (ACDD)\n        '''\n\n        recommended_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended global attributes')\n\n        # Do any of the variables define platform ?\n        variable_defined_platform = any((hasattr(var, 'platform') for var in dataset.variables))\n        if not variable_defined_platform:\n            platform_name = getattr(dataset, 'platform', '')\n            recommended_ctx.assert_true(platform_name and platform_name in dataset.variables, 'platform should exist and point to a variable.')\n\n        sea_names = [sn.lower() for sn in util.get_sea_names()]\n        sea_name = getattr(dataset, 'sea_name', '')\n        sea_name = sea_name.replace(', ', ',')\n        sea_name = sea_name.split(',') if sea_name else []\n        for sea in sea_name:\n            recommended_ctx.assert_true(\n                sea.lower() in sea_names,\n                'sea_name attribute should exist and should be from the NODC sea names list: {} is not a valid sea name'.format(sea)\n            )\n\n        # Parse dates, check for ISO 8601\n        for attr in ['time_coverage_start', 'time_coverage_end', 'date_created', 'date_modified']:\n            attr_value = getattr(dataset, attr, '')\n            try:\n                parse_datetime(attr_value)\n                recommended_ctx.assert_true(True, '')  # Score it True!\n            except ISO8601Error:\n                recommended_ctx.assert_true(False, '{} should exist and be ISO-8601 format (example: PT1M30S), currently: {}'.format(attr, attr_value))\n\n        units = getattr(dataset, 'geospatial_lat_units', '').lower()\n        recommended_ctx.assert_true(units == 'degrees_north', 'geospatial_lat_units attribute should be degrees_north: {}'.format(units))\n\n        units = getattr(dataset, 'geospatial_lon_units', '').lower()\n        recommended_ctx.assert_true(units == 'degrees_east', 'geospatial_lon_units attribute should be degrees_east: {}'.format(units))\n\n        value = getattr(dataset, 'geospatial_vertical_positive', '')\n        recommended_ctx.assert_true(value.lower() in ['up', 'down'], 'geospatial_vertical_positive attribute should be up or down: {}'.format(value))\n\n        # I hate english.\n        ack_exists = any((getattr(dataset, attr, '') != '' for attr in ['acknowledgment', 'acknowledgement']))\n        recommended_ctx.assert_true(ack_exists, 'acknowledgement attribute should exist and not be empty')\n\n        contributor_name = getattr(dataset, 'contributor_name', '')\n        contributor_role = getattr(dataset, 'contributor_role', '')\n        names = contributor_role.split(',')\n        roles = contributor_role.split(',')\n        recommended_ctx.assert_true(contributor_name != '', 'contributor_name should exist and not be empty.')\n        recommended_ctx.assert_true(len(names) == len(roles), 'length of contributor names matches length of roles')\n        recommended_ctx.assert_true(contributor_role != '', 'contributor_role should exist and not be empty.')\n        recommended_ctx.assert_true(len(names) == len(roles), 'length of contributor names matches length of roles')\n\n        if hasattr(dataset, 'comment'):\n            recommended_ctx.assert_true(getattr(dataset, 'comment', '') != '', 'comment attribute should not be empty if specified')\n\n        return recommended_ctx.to_result()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_base_required_attributes(self, dataset):\n        '''\n        Check the global required and highly recommended attributes for 2.0 templates. These go an extra step besides\n        just checking that they exist.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n\n        :Conventions = \"CF-1.6, ACDD-1.3\" ; //............................... REQUIRED - Always try to use latest value. (CF)\n        :featureType = \"timeSeries\" ; //..................................... REQUIRED - CF attribute for identifying the featureType.\n        :cdm_data_type = \"Station\" ; //...................................... REQUIRED (ACDD)\n        :ncei_template_version = \"NCEI_NetCDF_TimeSeries_Orthogonal_Template_v1.1\" ; //....... REQUIRED (NCEI)\n        :title = \"\" ; //............................................... HIGHLY RECOMMENDED - Provide a useful title for the data in the file. (ACDD)\n        :summary = \"\" ; //............................................. HIGHLY RECOMMENDED - Provide a useful summary or abstract for the data in the file. (ACDD)\n        :keywords = \"\" ; //............................................ HIGHLY RECOMMENDED - A comma separated list of keywords coming from the keywords_vocabulary. (ACDD)\n        :Conventions = \"CF-1.6, ACDD-1.3\" ; //......................... HIGHLY RECOMMENDED    - A comma separated list of the conventions being followed. Always try to use latest version. (CF/ACDD)\n        '''\n        test_ctx = TestCtx(BaseCheck.HIGH, 'Required global attributes')\n\n        conventions = getattr(dataset, 'Conventions', '')\n        feature_type = getattr(dataset, 'featureType', '')\n\n        # Define conventions\n        accepted_conventions = ['CF-1.6', 'ACDD-1.3']\n        dataset_conventions = conventions.replace(' ', '').split(',')\n        for accepted_convention in accepted_conventions:\n            if accepted_convention not in dataset_conventions:\n                test_ctx.assert_true(False, 'Conventions attribute is missing or is not equal to \"CF-1.6, ACDD-1.3\": {}'.format(conventions))\n                break\n        else:\n            test_ctx.assert_true(True, '')\n\n        # Check feature types\n        test_ctx.assert_true(feature_type in ['point', 'timeSeries', 'trajectory', 'profile', 'timeSeriesProfile', 'trajectoryProfile'],\n                             'Feature type must be one of point, timeSeries, trajectory, profile, timeSeriesProfile, trajectoryProfile: {}'.format(feature_type))\n\n        return test_ctx.to_result()", "response": "Check the global required and highly recommended attributes for 2. 0 templates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_recommended_global_attributes(self, dataset):\n        '''\n        Check the global recommended attributes for 2.0 templates. These go an extra step besides\n        just checking that they exist.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n\n        :id = \"\" ; //.................................................. RECOMMENDED - Should be a human readable unique identifier for data set. (ACDD)\n        :naming_authority = \"\" ; //.................................... RECOMMENDED - Backward URL of institution (for example, gov.noaa.ncei). (ACDD)\n        :history = \"\" ; //............................................. RECOMMENDED - Provides an audit trail for modifications to the original data. (ACDD)\n        :source = \"\" ; //.............................................. RECOMMENDED - The method of production of the original data. (CF)\n        :processing_level = \"\" ; //.................................... RECOMMENDED - Provide a description of the processing or quality control level of the data. (ACDD)\n        :comment = \"\" ; //............................................. RECOMMENDED - Provide useful additional information here. (CF)\n        :acknowledgment = \"\" ; //...................................... RECOMMENDED - A place to acknowledge various types of support for the project that produced this data. (ACDD)\n        :license = \"\" ; //............................................. RECOMMENDED - Describe the restrictions to data access and distribution. (ACDD)\n        :standard_name_vocabulary = \"CF Standard Name Table vNN\" ; //.. RECOMMENDED   - If using CF standard name attribute for variables. Replace NN with the CF standard name table number  (CF)\n        :date_created = \"\" ; //........................................ RECOMMENDED - Creation date of this version of the data(netCDF).  Use ISO 8601:2004 for date and time. (ACDD)\n        :creator_name = \"\" ; //........................................ RECOMMENDED - The name of the person (or other creator type specified by the creator_type attribute) principally responsible for creating this data. (ACDD)\n        :creator_email = \"\" ; //....................................... RECOMMENDED - The email address of the person (or other creator type specified by the creator_type attribute) principally responsible for creating this data. (ACDD)\n        :creator_url = \"\" ; //......................................... RECOMMENDED - The URL of the person (or other creator type specified by the creator_type attribute) principally responsible for creating this data. (ACDD)\n        :institution = \"\" ; //......................................... RECOMMENDED -The name of the institution principally responsible for originating this data..  An institution attribute can be used for each variable if variables come from more than one institution. (CF/ACDD)\n        :project = \"\" ; //............................................. RECOMMENDED - The name of the project(s) principally responsible for originating this data. Multiple projects can be separated by commas. (ACDD)\n        :publisher_name = \"\" ; //...................................... RECOMMENDED - The name of the person (or other entity specified by the publisher_type attribute) responsible for publishing the data file or product to users, with its current metadata and format. (ACDD)\n        :publisher_email = \"\" ; //..................................... RECOMMENDED - The email address of the person (or other entity specified by the publisher_type attribute) responsible for publishing the data file or product to users, with its current metadata and format. (ACDD)\n        :publisher_url = \"\" ; //....................................... RECOMMENDED - The URL of the person (or other entity specified by the publisher_type attribute) responsible for publishing the data file or product to users, with its current metadata and format. (ACDD)\n        :geospatial_bounds = \"\" ; //................................... RECOMMENDED - Describes the data's 2D or 3D geospatial extent in OGC's Well-Known Text (WKT) Geometry format. (ACDD)\n        :geospatial_bounds_crs = \"\" ; //............................... RECOMMENDED - The coordinate reference system (CRS) of the point coordinates in the geospatial_bounds attribute. (ACDD)\n        :geospatial_bounds_vertical_crs = \"\" ; //...................... RECOMMENDED - The vertical coordinate reference system (CRS) for the Z axis of the point coordinates in the geospatial_bounds attribute. (ACDD)\n        :geospatial_lat_min = 0.0d ; //................................ RECOMMENDED - Describes a simple lower latitude limit. (ACDD)\n        :geospatial_lat_max = 0.0d ; //................................ RECOMMENDED - Describes a simple upper latitude limit. (ACDD)\n        :geospatial_lon_min = 0.0d ; //................................ RECOMMENDED - Describes a simple lower longitude limit. (ACDD)\n        :geospatial_lon_max = 0.0d ; //................................ RECOMMENDED - Describes a simple upper longitude limit. (ACDD)\n        :geospatial_vertical_min = 0.0d ; //........................... RECOMMENDED - Describes the numerically smaller vertical limit. (ACDD)\n        :geospatial_vertical_max = 0.0d ; //........................... RECOMMENDED - Describes the numerically larger vertical limit. (ACDD)\n        :geospatial_vertical_positive = \"\" ; //........................ RECOMMENDED - Use \"up\" or \"down\". (ACDD)\n        :time_coverage_start = \"\" ; //................................. RECOMMENDED - Describes the time of the first data point in the data set. Use ISO 8601:2004 for date and time. (ACDD)\n        :time_coverage_end = \"\" ; //................................... RECOMMENDED - Describes the time of the last data point in the data set. Use ISO 8601:2004 for date and time.(ACDD)\n        :time_coverage_duration = \"\" ; //.............................. RECOMMENDED - Describes the duration of the data set. Use ISO 8601:2004 for date and time. (ACDD)\n        :time_coverage_resolution = \"\" ; //............................ RECOMMENDED - Describes the targeted time period between each value in the data set. Use ISO 8601:2004 for date and time. (ACDD)\n        :uuid = \"\" ; //................................................ RECOMMENDED - Machine readable unique identifier for each file. A new uuid is created whenever the file is changed. (NCEI)\n        :sea_name = \"\" ; //............................................ RECOMMENDED - The names of the sea in which the data were collected. Use NCEI sea names table. (NCEI)\n        '''\n\n        recommended_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended global attributes')\n\n        sea_names = [sn.lower() for sn in util.get_sea_names()]\n        sea_name = getattr(dataset, 'sea_name', '')\n        sea_name = sea_name.replace(', ', ',')\n        sea_name = sea_name.split(',') if sea_name else []\n        for sea in sea_name:\n            recommended_ctx.assert_true(\n                sea.lower() in sea_names,\n                'sea_name attribute should exist and should be from the NODC sea names list: {} is not a valid sea name'.format(sea)\n            )\n\n        # Parse dates, check for ISO 8601\n        for attr in ['time_coverage_start', 'time_coverage_end', 'date_created', 'date_modified']:\n            attr_value = getattr(dataset, attr, '')\n            try:\n                parse_datetime(attr_value)\n                recommended_ctx.assert_true(True, '')  # Score it True!\n            except ISO8601Error:\n                recommended_ctx.assert_true(False, '{} should exist and be ISO-8601 format (example: PT1M30S), currently: {}'.format(attr, attr_value))\n\n        value = getattr(dataset, 'geospatial_vertical_positive', '')\n        recommended_ctx.assert_true(value.lower() in ['up', 'down'], 'geospatial_vertical_positive attribute should be up or down: {}'.format(value))\n\n        # I hate english.\n        ack_exists = any((getattr(dataset, attr, '') != '' for attr in ['acknowledgment', 'acknowledgement']))\n        recommended_ctx.assert_true(ack_exists, 'acknowledgement attribute should exist and not be empty')\n\n        standard_name_vocab = getattr(dataset, 'standard_name_vocabulary', '')\n        regex = re.compile(r'[sS]tandard [nN]ame [tT]able')\n        recommended_ctx.assert_true(regex.search(standard_name_vocab),\n                                    \"standard_name_vocabulary doesn't contain 'Standard Name Table': {}\".format(standard_name_vocab))\n\n        if hasattr(dataset, 'comment'):\n            recommended_ctx.assert_true(getattr(dataset, 'comment', '') != '', 'comment attribute should not be empty if specified')\n        return recommended_ctx.to_result()", "response": "Check the global recommended attributes for 2. 0 templates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking the global suggested attributes for 2. 0 templates.", "response": "def check_base_suggested_attributes(self, dataset):\n        '''\n        Check the global suggested attributes for 2.0 templates. These go an extra step besides\n        just checking that they exist.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n\n        :creator_type = \"\" ; //........................................ SUGGESTED - Specifies type of creator with one of the following: 'person', 'group', 'institution', or 'position'. (ACDD)\n        :creator_institution = \"\" ; //................................. SUGGESTED - The institution of the creator; should uniquely identify the creator's institution. (ACDD)\n        :publisher_type = \"\" ; //...................................... SUGGESTED - Specifies type of publisher with one of the following: 'person', 'group', 'institution', or 'position'. (ACDD)\n        :publisher_institution = \"\" ; //............................... SUGGESTED - The institution that presented the data file or equivalent product to users; should uniquely identify the institution. (ACDD)\n        :program = \"\" ; //............................................. SUGGESTED - The overarching program(s) of which the dataset is a part. (ACDD)\n        :contributor_name = \"\" ; //.................................... SUGGESTED - The name of any individuals, projects, or institutions that contributed to the creation of this data. (ACDD)\n        :contributor_role = \"\" ; //.................................... SUGGESTED - The role of any individuals, projects, or institutions that contributed to the creation of this data. (ACDD)\n        :geospatial_lat_units = \"degrees_north\" ; //..................  SUGGESTED - Units for the latitude axis described in \"geospatial_lat_min\" and \"geospatial_lat_max\" attributes. Use UDUNITS compatible units. (ACDD)\n        :geospatial_lon_units = \"degrees_east\"; //..................... SUGGESTED - Units for the longitude axis described in \"geospatial_lon_min\" and \"geospatial_lon_max\" attributes. Use UDUNITS compatible units. (ACDD)\n        :geospatial_vertical_units = \"\" ; //........................... SUGGESTED - Units for the vertical axis described in \"geospatial_vertical_min\" and \"geospatial_vertical_max\" attributes. The default is EPSG:4979. (ACDD)\n        :date_modified = \"\" ; //....................................... SUGGESTED - The date on which the data was last modified. Note that this applies just to the data, not the metadata. Use ISO 8601:2004 for date and time. (ACDD)\n        :date_issued = \"\" ; //......................................... SUGGESTED - The date on which this data (including all modifications) was formally issued (i.e., made available to a wider audience). Note that these apply just to the data, not the metadata. Use ISO 8601:2004 for date and time. (ACDD)\n        :date_metadata_modified = \"\" ; //.............................. SUGGESTED - The date on which the metadata was last modified. Use ISO 8601:2004 for date and time. (ACDD)\n        :product_version = \"\" ; //..................................... SUGGESTED - Version identifier of the data file or product as assigned by the data creator. (ACDD)\n        :keywords_vocabulary = \"\" ; //................................. SUGGESTED - Identifies the controlled keyword vocabulary used to specify the values within the attribute \"keywords\". Example: 'GCMD:GCMD Keywords' ACDD)\n        :platform = \"\" ; //............................................ SUGGESTED - Name of the platform(s) that supported the sensor data used to create this data set or product. Platforms can be of any type, including satellite, ship, station, aircraft or other. (ACDD)\n        :platform_vocabulary = \"\" ; //................................. SUGGESTED - Controlled vocabulary for the names used in the \"platform\" attribute . Example: \u2018NASA/GCMD Platform Keywords Version 8.1\u2019 (ACDD)\n        :instrument = \"\" ; //.......................................... SUGGESTED - Name of the contributing instrument(s) or sensor(s) used to create this data set or product. (ACDD)\n        :instrument_vocabulary = \"\" ; //............................... SUGGESTED - Controlled vocabulary for the names used in the \"instrument\" attribute. Example: \u2018NASA/GCMD Instrument Keywords Version 8.1\u2019 (ACDD)\n        :cdm_data_type = \"Point\" ; //.................................. SUGGESTED - The data type, as derived from Unidata's Common Data Model Scientific Data types and understood by THREDDS. (ACDD)\n        :metadata_link = \"\" ; //....................................... SUGGESTED - A URL that gives the location of more complete metadata. A persistent URL is recommended for this attribute. (ACDD)\n        :references = \"\" ; //.......................................... SUGGESTED - Published or web-based references that describe the data or methods used to produce it. Recommend URIs (such as a URL or DOI) for papers or other references. (CF)\n        '''\n        suggested_ctx = TestCtx(BaseCheck.LOW, 'Suggested global attributes')\n\n        # Do any of the variables define platform ?\n        platform_name = getattr(dataset, 'platform', '')\n        suggested_ctx.assert_true(platform_name != '', 'platform should exist and point to a term in :platform_vocabulary.')\n\n        cdm_data_type = getattr(dataset, 'cdm_data_type', '')\n        suggested_ctx.assert_true(cdm_data_type.lower() in ['grid', 'image', 'point', 'radial', 'station', 'swath', 'trajectory'],\n                     'cdm_data_type must be one of Grid, Image, Point, Radial, Station, Swath, Trajectory: {}'.format(cdm_data_type))\n\n        # Parse dates, check for ISO 8601\n        for attr in ['date_modified', 'date_issued', 'date_metadata_modified']:\n            attr_value = getattr(dataset, attr, '')\n            try:\n                parse_datetime(attr_value)\n                suggested_ctx.assert_true(True, '')  # Score it True!\n            except ISO8601Error:\n                suggested_ctx.assert_true(False, '{} should exist and be ISO-8601 format (example: PT1M30S), currently: {}'.format(attr, attr_value))\n\n        units = getattr(dataset, 'geospatial_lat_units', '').lower()\n        suggested_ctx.assert_true(units == 'degrees_north', 'geospatial_lat_units attribute should be degrees_north: {}'.format(units))\n\n        units = getattr(dataset, 'geospatial_lon_units', '').lower()\n        suggested_ctx.assert_true(units == 'degrees_east', 'geospatial_lon_units attribute should be degrees_east: {}'.format(units))\n\n        contributor_name = getattr(dataset, 'contributor_name', '')\n        contributor_role = getattr(dataset, 'contributor_role', '')\n        names = contributor_role.split(',')\n        roles = contributor_role.split(',')\n        suggested_ctx.assert_true(contributor_name != '', 'contributor_name should exist and not be empty.')\n        suggested_ctx.assert_true(len(names) == len(roles), 'length of contributor names matches length of roles')\n        suggested_ctx.assert_true(contributor_role != '', 'contributor_role should exist and not be empty.')\n        suggested_ctx.assert_true(len(names) == len(roles), 'length of contributor names matches length of roles')\n\n        return suggested_ctx.to_result()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the attributes of the geophysical variable for 2. 0 templates.", "response": "def check_geophysical(self, dataset):\n        '''\n        Check the geophysical variable attributes for 2.0 templates.\n        Attributes missing_value and coverage_content_type have been added in NCEI 2.0\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n\n        float geophysical_variable_1(time) ;//................................ This is an example of how each and every geophysical variable in the file should be represented. Replace the name of the variable(\"geophysical_variable_1\") with a suitable name. Replace \"float\" by data type which is appropriate for the variable.\n            geophysical_variable_1:long_name = \"\" ; //................... RECOMMENDED - Provide a descriptive, long name for this variable.\n            geophysical_variable_1:standard_name = \"\" ; //............... REQUIRED    - If using a CF standard name and a suitable name exists in the CF standard name table.\n            geophysical_variable_1:ncei_name = \"\" ; //................... RECOMMENDED - From the NCEI variables vocabulary, if standard_name does not exist.\n            geophysical_variable_1:units = \"\" ; //....................... REQUIRED    - Use UDUNITS compatible units.\n            geophysical_variable_1:scale_factor = 0.0f ; //.............. REQUIRED if the data uses a scale_factor other than 1.The data type should be the data type of the variable.\n            geophysical_variable_1:add_offset = 0.0f ; // ............... REQUIRED if the data uses an add_offset other than 0. The data type should be the data type of the variable.\n            geophysical_variable_1:_FillValue = 0.0f ; //................ REQUIRED  if there could be undefined values in the data.\n            geophysical_variable_1:missing_value = 0.0f ; //............. RECOMMENDED  if there could be missing values in the data. Not necessary if there is only one value which is the same as _FillValue.\n            geophysical_variable_1:valid_min = 0.0f ; //................. RECOMMENDED - Replace with correct value.\n            geophysical_variable_1:valid_max = 0.0f ; //................. RECOMMENDED - Replace with correct value.\n            geophysical_variable_1:coordinates = \"time lat lon z\" ; //... REQUIRED    - Include the auxiliary coordinate variables and optionally coordinate variables in the list. The order itself does not matter. Also, note that whenever any auxiliary coordinate variable contains a missing value, all other coordinate, auxiliary coordinate and data values corresponding to that element should also contain missing values.\n            geophysical_variable_1:coverage_content_type = \"\" ; //....... RECOMMENDED - An ISO 19115-1 code to indicate the source of the data (image, thematicClassification, physicalMeasurement, auxiliaryInformation, qualityInformation, referenceInformation, modelResult, or coordinate). (ACDD)\n            geophysical_variable_1:grid_mapping = \"crs\" ; //............. RECOMMENDED - It is highly recommended that the data provider put the data in a well known geographic coordinate system and provide the details of the coordinate system.\n            geophysical_variable_1:source = \"\" ; //...................... RECOMMENDED - The method of production of the original data\n            geophysical_variable_1:references = \"\" ; //.................. RECOMMENDED - Published or web-based references that describe the data or methods used to produce it.\n            geophysical_variable_1: cell_methods = \"\" ; // .............. RECOMMENDED - Use the coordinate variables to define the cell values (ex., \"time: point lon: point lat: point z: point\").\n            geophysical_variable_1:ancillary_variables = \"instrument_parameter_variable platform_variable boolean_flag_variable enumerated_flag_variable\" ; //......... RECOMMENDED - Identify the variable name(s) of the flag(s) and other ancillary variables relevant to this variable.  Use a space-separated list.\n            geophysical_variable_1:platform = \"platform_variable\" ; //... RECOMMENDED - Refers to name of variable containing information on the platform from which this variable was collected.\n            geophysical_variable_1:instrument = \"instrument_variable\";//..RECOMMENDED - Refers to name of variable containing information on the instrument from which this variable was collected.\n            geophysical_variable_1:comment = \"\" ; //..................... RECOMMENDED - Add useful, additional information here.\n        '''\n\n        results = []\n        for var in util.get_geophysical_variables(dataset):\n            ncvar = dataset.variables[var]\n\n            test_ctx = TestCtx(BaseCheck.HIGH, 'Required attributes for variable {}'.format(var))\n            test_ctx.assert_true(getattr(ncvar, 'standard_name', '') != '', 'standard_name attribute must exist and not be empty')\n            test_ctx.assert_true(getattr(ncvar, 'units', '') != '', 'units attribute must exist and not be empty')\n            coordinates = getattr(ncvar, 'coordinates', '')\n            test_ctx.assert_true(coordinates != '', 'coordinates must exist and not be empty')\n            results.append(test_ctx.to_result())\n\n            test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for variable {}'.format(var))\n            test_ctx.assert_true(getattr(ncvar, 'long_name', '') != '', 'long_name should exist and not be empty')\n            if not hasattr(ncvar, 'standard_name'):\n                test_ctx.assert_true(getattr(ncvar, 'ncei_name', '') != '', 'ncei_name should exist and not be empty')\n            self._check_min_max_range(ncvar, test_ctx)\n\n            coverage_content_type_options = ['image', 'thematicClassification', 'physicalMeasurement', 'auxiliaryInformation',\n                                             'qualityInformation', 'referenceInformation', 'modelResult', 'coordinate']\n            test_ctx.assert_true(getattr(ncvar, 'coverage_content_type', '') in coverage_content_type_options,\n                                 ('coverage_content_type should exist and be one of the following:'\n                                  'image, thematicClassification, physicalMeasurement, auxiliaryInformation, '\n                                  'qualityInformation, referenceInformation, modelResult, or coordinate'))\n\n            grid_mapping = getattr(ncvar, 'grid_mapping', '')\n            test_ctx.assert_true(grid_mapping != '', 'grid_mapping should exist and not be empty')\n            if grid_mapping:\n                test_ctx.assert_true(grid_mapping in dataset.variables, 'grid_mapping attribute is a variable')\n            test_ctx.assert_true(getattr(ncvar, 'source', '') != '', 'source should exist and not be empty')\n            test_ctx.assert_true(getattr(ncvar, 'references', '') != '', 'references should exist and not be empty')\n            test_ctx.assert_true(getattr(ncvar, 'cell_methods', '') != '', 'cell_methods should exist and not be empty')\n            ancillary_variables = getattr(ncvar, 'ancillary_variables', '')\n            if ancillary_variables:\n                ancillary_variables = ancillary_variables.split(' ')\n            all_variables = all([v in dataset.variables for v in ancillary_variables])\n            if ancillary_variables:\n                test_ctx.assert_true(all_variables, 'ancillary_variables point to variables')\n            platform = getattr(ncvar, 'platform', '')\n            if platform:\n                test_ctx.assert_true(platform in dataset.variables, 'platform attribute points to variable')\n            instrument = getattr(ncvar, 'instrument', '')\n            if instrument:\n                test_ctx.assert_true(instrument in dataset.variables, 'instrument attribute points to variable')\n\n            if hasattr(ncvar, 'comment'):\n                test_ctx.assert_true(getattr(dataset, 'comment', '') != '', 'comment attribute should not be empty if specified')\n            results.append(test_ctx.to_result())\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_platform(self, dataset):\n        '''\n        int platform_variable; //............................................ RECOMMENDED - a container variable storing information about the platform. If more than one, can expand each attribute into a variable. For example, platform_call_sign and platform_nodc_code. See instrument_parameter_variable for an example.\n                platform_variable:long_name = \"\" ; //........................ RECOMMENDED - Provide a descriptive, long name for this variable.\n                platform_variable:comment = \"\" ; //.......................... RECOMMENDED - Add useful, additional information here.\n                platform_variable:call_sign = \"\" ; //........................ RECOMMENDED - This attribute identifies the call sign of the platform.\n                platform_variable:ncei_code = \"\"; //......................... RECOMMENDED - This attribute identifies the NCEI code of the platform. Look at http://www.nodc.noaa.gov/cgi-bin/OAS/prd/platform to find if NCEI codes are available.\n                platform_variable:wmo_code = \"\";//........................... RECOMMENDED - This attribute identifies the wmo code of the platform. Information on getting WMO codes is available at http://www.wmo.int/pages/prog/amp/mmop/wmo-number-rules.html\n                platform_variable:imo_code  = \"\";//.......................... RECOMMENDED - This attribute identifies the International Maritime Organization (IMO) number assigned by Lloyd's register.\n        '''\n        # Check for the platform variable\n        platforms = util.get_platform_variables(dataset)\n        if not platforms:\n            return Result(BaseCheck.MEDIUM,\n                          False,\n                          'A container variable storing information about the platform exists',\n                          ['Create a variable to store the platform information'])\n\n        results = []\n        for platform in platforms:\n            test_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended attributes for platform variable {}'.format(platform))\n            pvar = dataset.variables[platform]\n            test_ctx.assert_true(getattr(pvar, 'long_name', '') != '', 'long_name attribute should exist and not be empty')\n            if hasattr(pvar, 'comment'):\n                test_ctx.assert_true(getattr(pvar, 'comment', '') != '', 'comment attribute should not be empty if specified')\n            # We only check to see if nodc_code, wmo_code and imo_code are empty. They are only recommended if they exist for the platform.\n            found_identifier = False\n            if hasattr(pvar, 'ncei_code'):\n                test_ctx.assert_true(getattr(pvar, 'ncei_code', '') != '', 'ncei_code should not be empty if specified')\n                found_identifier = True\n            if hasattr(pvar, 'wmo_code'):\n                test_ctx.assert_true(getattr(pvar, 'wmo_code', '') != '', 'wmo_code should not be empty if specified')\n                found_identifier = True\n            if hasattr(pvar, 'imo_code'):\n                test_ctx.assert_true(getattr(pvar, 'imo_code', '') != '', 'imo_code should not be empty if specified')\n                found_identifier = True\n            if hasattr(pvar, 'call_sign'):\n                test_ctx.assert_true(getattr(pvar, 'call_sign', '') != '', 'call_sign attribute should not be empty if specified')\n                found_identifier = True\n            test_ctx.assert_true(found_identifier, 'At least one attribute should be defined to identify the platform: ncei_code, wmo_code, imo_code, call_sign.')\n            results.append(test_ctx.to_result())\n\n        return results", "response": "Checks the platform variable for existence."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconfigures the core of sirbot", "response": "def _configure(self):\n        \"\"\"\n        Configure the core of sirbot\n\n        Merge the config with the default core config and configure logging.\n        The default logging level is `INFO`\n        \"\"\"\n        path = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), 'config.yml'\n        )\n\n        with open(path) as file:\n            defaultconfig = yaml.load(file)\n\n        self.config = merge_dict(self.config, defaultconfig)\n\n        if 'logging' in self.config:\n            logging.config.dictConfig(self.config['logging'])\n        else:\n            logging.getLogger('sirbot').setLevel('INFO')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _import_plugins(self) -> None:\n        logger.debug('Importing plugins')\n        self._pm = pluggy.PluginManager('sirbot')\n        self._pm.add_hookspecs(hookspecs)\n\n        for plugin in self.config['sirbot']['plugins']:\n            try:\n                p = importlib.import_module(plugin)\n            except (ModuleNotFoundError, ):\n                if os.getcwd() not in sys.path:\n                    sys.path.append(os.getcwd())\n                    p = importlib.import_module(plugin)\n                else:\n                    raise\n            self._pm.register(p)", "response": "Import and register plugins in the plugin manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _initialize_plugins(self):\n        logger.debug('Initializing plugins')\n        plugins = self._pm.hook.plugins(loop=self._loop)\n        if plugins:\n            for plugin in plugins:\n                name = plugin.__name__\n                registry_name = plugin.__registry__ or plugin.__name__\n                config = self.config.get(name, {})\n\n                priority = config.get('priority', 50)\n\n                if priority:\n                    self._plugins[name] = {\n                        'plugin': plugin,\n                        'config': config,\n                        'priority': priority,\n                        'factory': registry_name\n                    }\n\n                    self._start_priority[priority].append(name)\n        else:\n            logger.error('No plugins found')", "response": "Initialize the plugins and the start priority list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister the available factories and their associated factory", "response": "def _register_factory(self):\n        \"\"\"\n        Index the available factories\n\n        Query the plugins for an usable factory and register it\n        \"\"\"\n        for name, info in self._plugins.items():\n            if info['priority']:\n                factory = getattr(info['plugin'], 'factory', None)\n                if callable(factory):\n                    registry[info['factory']] = info['plugin'].factory\n        registry.freeze()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure the plugins Asynchronously configure the plugins. Pass them their configuration, the aiohttp session, the registry and the aiohttp router", "response": "async def _configure_plugins(self) -> None:\n        \"\"\"\n        Configure the plugins\n\n        Asynchronously configure the plugins. Pass them their configuration,\n        the aiohttp session, the registry and the aiohttp router\n        \"\"\"\n        logger.debug('Configuring plugins')\n        funcs = [\n            info['plugin'].configure(\n                config=info['config'],\n                session=self._session,\n                router=self.app.router\n            )\n            for info in self._plugins.values()\n        ]\n\n        if funcs:\n            await asyncio.gather(*funcs, loop=self._loop)\n        logger.debug('Plugins configured')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def _start_plugins(self) -> None:\n        logger.debug('Starting plugins')\n        for priority in sorted(self._start_priority, reverse=True):\n            logger.debug(\n                'Starting plugins %s',\n                ', '.join(self._start_priority[priority])\n            )\n\n            for name in self._start_priority[priority]:\n                plugin = self._plugins[name]\n                self._tasks[name] = self._loop.create_task(\n                    plugin['plugin'].start()\n                )\n\n            while not all(self._plugins[name]['plugin'].started\n                          for name in self._tasks):\n\n                for task in self._tasks.values():\n                    if task.done():\n                        task.result()\n                await asyncio.sleep(0.2, loop=self._loop)\n\n            else:\n                logger.debug('Plugins %s started',\n                             ', '.join(self._start_priority[priority]))", "response": "Start the plugins based on the priority and wait for them to be fully started."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the sirbot s internal cache with the current configuration.", "response": "async def update(self):\n        \"\"\"\n        Update sirbot\n\n        Trigger the update method of the plugins. This is needed if the plugins\n        need to perform update migration (i.e database)\n        \"\"\"\n        logger.info('Updating Sir Bot-a-lot')\n        for name, plugin in self._plugins.items():\n            plugin_update = getattr(plugin['plugin'], 'update', None)\n            if callable(plugin_update):\n                logger.info('Updating %s', name)\n                await plugin_update(self.config.get(name, {}), self._plugins)\n                logger.info('%s updated', name)\n        self._session.close()\n        logger.info('Sir Bot-a-lot updated')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart sirbot and starts the application", "response": "def run(self, host: str = '0.0.0.0', port: int = 8080):\n        \"\"\"\n        Start sirbot\n\n        Configure sirbot and start the aiohttp.web.Application\n\n        Args:\n            host (str): host\n            port (int): port\n        \"\"\"\n        self._loop.run_until_complete(self._configure_plugins())\n        web.run_app(self._app, host=host, port=port)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the settings object that will be sent to the frontend vizualization", "response": "def _create_settings(self):\n        \"\"\" \n        Creates the settings object that will be sent \n        to the frontend vizualization\n\n        \"\"\"\n\n        self.settings = {\n            \"columns\": [{\"Header\": s, \"accessor\": s} for s in self.settings],\n            \"port\": self.port,\n            \"docs\": construct_trie(self.docs)\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a server to handle queries to the index without creating the javascript table.", "response": "def run_server(self):\n        \"\"\" \n        Runs a server to handle queries to the index without creating the \n        javascript table.\n\n        \"\"\"\n        app = build_app()\n        run(app, host='localhost', port=self.port)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting the javascript table to a jupyter notebook cell", "response": "def print_ipython(self):\n        \"\"\" \n        Renders the javascript table to a jupyter/ipython notebook cell\n\n        Usage example:\n        \n        >>> t = Table(ind)\n        >>> t.print_ipython()\n        ... renders the table to notebook cell\n\n        \"\"\"\n        from IPython.display import display, HTML\n        self._listen()\n        try: shutil.rmtree('viz')\n        except: None\n\n        shutil.copytree(self.html_path, 'viz')\n        pth = \"viz/index.html\"\n        html = open(pth).read()\n        html = html.replace(\"__SERVER_DATA__\", '\"http://localhost:'+str(self.port)+'\"')\n        display(HTML(html))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncleans trailing whitespaces and replaces also multiple whitespaces with a single space.", "response": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the rank of this transition for a given request.", "response": "async def rank(self, request, origin: Optional[Text]) \\\n            -> Tuple[\n                float,\n                Optional[BaseTrigger],\n                Optional[type],\n                Optional[bool],\n            ]:\n        \"\"\"\n        Computes the rank of this transition for a given request.\n\n        It returns (in order):\n\n            - The score (from 0 to 1)\n            - The trigger instance (if it matched)\n            - The class of the destination state (if matched)\n        \"\"\"\n\n        if self.origin_name == origin:\n            score = 1.0\n        elif self.origin_name is None:\n            score = settings.JUMPING_TRIGGER_PENALTY\n        else:\n            return 0.0, None, None, None\n\n        trigger = self.factory(request)\n        rank = await run_or_return(trigger.rank())\n        score *= self.weight * (rank or 0.0)\n\n        return score, trigger, self.dest, self.do_not_register"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that the feature types of this dataset are consitent with a point dataset", "response": "def check_dimensions(self, dataset):\n        '''\n        Checks that the feature types of this dataset are consitent with a point dataset\n        '''\n        required_ctx = TestCtx(BaseCheck.HIGH, 'All geophysical variables are point feature types')\n        t = util.get_time_variable(dataset)\n\n        # Exit prematurely\n        if not t:\n            required_ctx.assert_true(False, 'A dimension representing time is required for point feature types')\n            return required_ctx.to_result()\n        t_dims = dataset.variables[t].dimensions\n        o = None or (t_dims and t_dims[0])\n\n        message = '{} must be a valid timeseries feature type. It must have dimensions of ({}), and all coordinates must have dimensions of ({})'\n        for variable in util.get_geophysical_variables(dataset):\n            is_valid = util.is_point(dataset, variable)\n            required_ctx.assert_true(\n                is_valid,\n                message.format(variable, o, o)\n            )\n        return required_ctx.to_result()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef settings(cls):\n\n        from bernard.platforms.management import get_platform_settings\n\n        for platform in get_platform_settings():\n            candidate = import_class(platform['class'])\n            if candidate == cls:\n                return platform.get('settings', {})", "response": "Find the settings for the current class inside the platforms\n        configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnotifies all listeners that a message was received.", "response": "async def _notify(self, message: BaseMessage, responder: Responder):\n        \"\"\"\n        Notify all callbacks that a message was received.\n        \"\"\"\n        for cb in self._listeners:\n            coro = cb(message, responder, self.fsm_creates_task)\n\n            if not self.fsm_creates_task:\n                self._register = await coro"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def async_init(self):\n        self.session = aiohttp.ClientSession()\n        asyncio.get_event_loop().create_task(self._deferred_init())", "response": "During async init we just need to create a HTTP session so we can keep\n        outgoing connexions to the platform alive."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef accept(self, stack: Stack):\n\n        for name, pattern in self.PATTERNS.items():\n            if stack.match_exp(pattern):\n                stack.annotation = name\n                return True\n        return False", "response": "Checks that the stack can be accepted according to the PATTERNS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, request: Request, stack: Stack) -> Coroutine:\n\n        if stack.annotation not in self.PATTERNS:\n            if not self.accept(stack):\n                raise UnacceptableStack('Cannot accept stack {}'.format(stack))\n\n        func = getattr(self, '_send_' + stack.annotation)\n        return func(request, stack)", "response": "Send a stack to the platform."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_unit_memory(number):\n    kb = 1024\n\n    number /= kb\n\n    if number < 100:\n        return '{} Kb'.format(round(number, 2))\n\n    number /= kb\n    if number < 300:\n        return '{} Mb'.format(round(number, 2))\n\n    number /= kb\n\n    return '{} Gb'.format(round(number, 2))", "response": "Creates a string representation of memory size given number."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_percentage(number, rounding=2):\n    number = float(number) * 100\n    number_as_int = int(number)\n    rounded = round(number, rounding)\n\n    return '{}%'.format(number_as_int if number_as_int == rounded else rounded)", "response": "Converts a number to a percentage string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_editor(self, editor):\n        if self._editor is not None:\n            try:\n                self._editor.offset_calculator.pic_infos_available.disconnect(\n                    self._update)\n            except (AttributeError, RuntimeError, ReferenceError):\n                # see https://github.com/OpenCobolIDE/OpenCobolIDE/issues/89\n                pass\n        self._editor = weakref.proxy(editor) if editor else editor\n        try:\n            self._editor.offset_calculator.pic_infos_available.connect(\n                self._update)\n        except AttributeError:\n            pass", "response": "Sets the associated editor for the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef patch_conf(settings_patch=None, settings_file=None):\n\n    if settings_patch is None:\n        settings_patch = {}\n\n    reload_config()\n    os.environ[ENVIRONMENT_VARIABLE] = settings_file if settings_file else ''\n\n    from bernard.conf import settings as l_settings\n    # noinspection PyProtectedMember\n    r_settings = l_settings._settings\n    r_settings.update(settings_patch)\n\n    if 'bernard.i18n' in modules:\n        from bernard.i18n import translate, intents\n        translate._regenerate_word_dict()\n        intents._refresh_intents_db()\n\n    yield", "response": "Patch the configuration of a bernard. conf file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addRegistration(self, key, registration):\n        if key in self._registrations:\n            raise KeyError(\"Key already registered\")\n\n        self._registrations[key] = registration\n        return self", "response": "Adds an IoC registration to a given key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef registerSingleton(self, key, factoryMethod, disposeMethod=None):\n        return self.addRegistration(key, SingletonRegistration(factoryMethod, disposeMethod))", "response": "Binds a singleton instance to a key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resolve(self, key):\n        registration = self._registrations.get(key)\n\n        if registration is None:\n            raise KeyError(\"Unknown key: '{0}'\".format(key))\n\n        return registration.resolve(self, key)", "response": "Resolves the requested key to an object instance raising a KeyError if the key is missing\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndispose all the registrations and the container.", "response": "def dispose(self):\n        \"\"\"\n        Disposes every performed registration; the container can then be used again\n        \"\"\"\n        for registration in self._registrations.values():\n            registration.dispose()\n\n        self._registrations = {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild user s workspace relative path.", "response": "def build_workspace_path(user_id, workflow_id=None):\n    \"\"\"Build user's workspace relative path.\n\n    :param user_id: Owner of the workspace.\n    :param workflow_id: Optional parameter, if provided gives the path to the\n        workflow workspace instead of just the path to the user workspace.\n    :return: String that represents the workspace relative path.\n        i.e. users/0000/workflows/0034\n    \"\"\"\n    workspace_path = os.path.join('users', str(user_id), 'workflows')\n    if workflow_id:\n        workspace_path = os.path.join(workspace_path, str(workflow_id))\n\n    return workspace_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_workflow_with_uuid_or_name(uuid_or_name, user_uuid):\n    from reana_db.models import Workflow\n    # Check existence\n    if not uuid_or_name:\n        raise ValueError('No Workflow was specified.')\n\n    # Check validity\n    try:\n        uuid_or_name.encode('ascii')\n    except UnicodeEncodeError:\n        # `workflow_name` contains something else than just ASCII.\n        raise ValueError('Workflow name {} is not valid.'.format(uuid_or_name))\n\n    # Check if UUIDv4\n    try:\n        # is_uuid = UUID(uuid_or_name, version=4)\n        is_uuid = UUID('{' + uuid_or_name + '}', version=4)\n    except (TypeError, ValueError):\n        is_uuid = None\n\n    if is_uuid:\n        # `uuid_or_name` is an UUIDv4.\n        # Search with it since it is expected to be unique.\n        return _get_workflow_by_uuid(uuid_or_name)\n\n    else:\n        # `uuid_or_name` is not and UUIDv4. Expect it is a name.\n\n        # Expect name might be in format 'reana.workflow.123' with arbitrary\n        # number of dot-delimited substring, where last substring specifies\n        # the run_number of the workflow this workflow name refers to.\n\n        # Possible candidates for names are e.g. :\n        # 'workflow_name' -> ValueError\n        # 'workflow.name' -> True, True\n        # 'workflow.name.123' -> True, True\n        # '123.' -> True, False\n        # '' -> ValueError\n        # '.123' -> False, True\n        # '..' -> False, False\n        # '123.12' -> True, True\n        # '123.12.' -> True, False\n\n        # Try to split the dot-separated string.\n        try:\n            workflow_name, run_number = uuid_or_name.rsplit('.', maxsplit=1)\n        except ValueError:\n            # Couldn't split. Probably not a dot-separated string.\n            #  -> Search with `uuid_or_name`\n            return _get_workflow_by_name(uuid_or_name, user_uuid)\n\n        # Check if `run_number` was specified\n        if not run_number:\n            # No `run_number` specified.\n            # -> Search by `workflow_name`\n            return _get_workflow_by_name(workflow_name, user_uuid)\n\n        # `run_number` was specified.\n        # Check `run_number` is valid.\n        if not run_number.isdigit():\n            # `uuid_or_name` was split, so it is a dot-separated string\n            # but it didn't contain a valid `run_number`.\n            # Assume that this dot-separated string is the name of\n            # the workflow and search with it.\n            return _get_workflow_by_name(uuid_or_name, user_uuid)\n\n        # `run_number` is valid.\n        # Search by `run_number` since it is a primary key.\n        workflow = Workflow.query.filter(\n            Workflow.name == workflow_name,\n            Workflow.run_number == run_number,\n            Workflow.owner_id == user_uuid).\\\n            one_or_none()\n        if not workflow:\n            raise ValueError(\n                'REANA_WORKON is set to {0}, but '\n                'that workflow does not exist. '\n                'Please set your REANA_WORKON environment '\n                'variable appropriately.'.\n                format(workflow_name, run_number))\n\n        return workflow", "response": "Get a workflow from database with UUID or name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a workflow by name.", "response": "def _get_workflow_by_name(workflow_name, user_uuid):\n    \"\"\"From Workflows named as `workflow_name` the latest run_number.\n\n    Only use when you are sure that workflow_name is not UUIDv4.\n\n    :rtype: reana-db.models.Workflow\n    \"\"\"\n    from reana_db.models import Workflow\n    workflow = Workflow.query.filter(\n        Workflow.name == workflow_name,\n        Workflow.owner_id == user_uuid). \\\n        order_by(Workflow.run_number.desc()).first()\n    if not workflow:\n        raise ValueError(\n            'REANA_WORKON is set to {0}, but '\n            'that workflow does not exist. '\n            'Please set your REANA_WORKON environment '\n            'variable appropriately.'.\n            format(workflow_name))\n    return workflow"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a workflow with the given UUID.", "response": "def _get_workflow_by_uuid(workflow_uuid):\n    \"\"\"Get Workflow with UUIDv4.\n\n    :param workflow_uuid: UUIDv4 of a Workflow.\n    :type workflow_uuid: String representing a valid UUIDv4.\n\n    :rtype: reana-db.models.Workflow\n    \"\"\"\n    from reana_db.models import Workflow\n    workflow = Workflow.query.filter(Workflow.id_ ==\n                                     workflow_uuid).first()\n    if not workflow:\n        raise ValueError(\n            'REANA_WORKON is set to {0}, but '\n            'that workflow does not exist. '\n            'Please set your REANA_WORKON environment '\n            'variable appropriately.'.\n            format(workflow_uuid))\n    return workflow"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting a list of ranges from a row.", "response": "def extract_ranges(row, ranges: ColRanges) -> List[Text]:\n    \"\"\"\n    Extracts a list of ranges from a row:\n\n    - If the range is an int, just get the data at this index\n    - If the range is a tuple of two ints, use them as indices in a slice\n    - If the range is an int then a None, start the slice at the int and go\n      up to the end of the row.\n    \"\"\"\n\n    out = []\n\n    for r in ranges:\n        if isinstance(r, int):\n            r = (r, r + 1)\n\n        if r[1] is None:\n            r = (r[0], len(row))\n\n        out.extend(row[r[0]:r[1]])\n\n    return [x for x in (y.strip() for y in out) if x]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def _watch(self):\n\n        file_name = os.path.basename(self._file_path)\n        logger.info(\n            'Watching %s \"%s\"',\n            self.THING,\n            self._file_path,\n        )\n\n        while self._running:\n            evt = await self._watcher.get_event()\n\n            if evt.name == file_name:\n                await self._load()\n                logger.info(\n                    'Reloading changed %s from \"%s\"',\n                    self.THING,\n                    self._file_path\n                )", "response": "Start the watching loop."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the event loop and load the data.", "response": "async def start(self, file_path, locale=None, kwargs=None):\n        \"\"\"\n        Setup the watching utilities, start the loop and load data a first\n        time.\n        \"\"\"\n\n        self._file_path = os.path.realpath(file_path)\n        self._locale = locale\n\n        if kwargs:\n            self._kwargs = kwargs\n\n        if settings.I18N_LIVE_RELOAD:\n            loop = asyncio.get_event_loop()\n\n            self._running = True\n            self._watcher = aionotify.Watcher()\n            self._watcher.watch(\n                path=os.path.dirname(self._file_path),\n                flags=aionotify.Flags.MOVED_TO | aionotify.Flags.MODIFY,\n            )\n            await self._watcher.setup(loop)\n            await self._load()\n\n            loop.create_task(self._watch())\n        else:\n            await self._load()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the internal state of the object.", "response": "def _update(self, data: TransDict, *args, **kwargs):\n        \"\"\"\n        Propagate updates to listeners\n\n        :param data: Data to propagate\n        \"\"\"\n\n        for l in self.listeners:\n            l(data, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def _load(self):\n\n        flags = self._kwargs.get('flags')\n\n        if not flags:\n            flags = {1: {}}\n\n        cols = {k: [] for k in flags.keys()}\n\n        with open(self._file_path, newline='', encoding='utf-8') as f:\n            reader = csv.reader(f)\n\n            for row in reader:\n                for i, col in cols.items():\n                    try:\n                        val = row[i].strip()\n                        assert val\n                    except (IndexError, AssertionError):\n                        pass\n                    else:\n                        col.append((row[0], val))\n\n        for i, col in cols.items():\n            self._update({self._locale: col}, flags[i])", "response": "Load data from an Excel - formatted CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def load(self, file_path, locale=None, flags=None):\n\n        await self.start(file_path, locale, {'flags': flags})", "response": "Load the data from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _load(self):\n\n        key = self._kwargs['key']\n        pos = self._kwargs['pos']\n        neg = self._kwargs['neg']\n\n        with open(self._file_path, newline='', encoding='utf-8') as f:\n            reader = csv.reader(f)\n            data = {}\n\n            for row in reader:\n                try:\n                    data[row[key]] = data.get(row[key], []) + [\n                        tuple(extract_ranges(row, [pos] + neg))\n                    ]\n                except IndexError:\n                    pass\n\n        self._update({self._locale: data})", "response": "Load data from an Excel - formatted CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def load(self,\n                   file_path,\n                   locale=None,\n                   key: int = 0,\n                   pos: int = 1,\n                   neg: Optional[ColRanges] = None):\n        \"\"\"\n        Start the loading/watching process\n        \"\"\"\n\n        if neg is None:\n            neg: ColRanges = [(2, None)]\n\n        await self.start(file_path, locale, kwargs={\n            'key': key,\n            'pos': pos,\n            'neg': neg,\n        })", "response": "Load the content of a specific entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_info(self):\n        \n        d = dir(self)\n        self.plugins = []\n        for key in d:\n            if key.startswith(\"info_\"):\n                self.plugins.append(key)\n\n        for key in self.plugins:\n            if self.echo:\n                Console.ok(\"> {0}\".format(key.replace(\"_\", \" \", 1)))\n            exec(\"self.%s()\" % key)", "response": "prints some info that the user may find useful"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_info(self, arg, arguments):\n        if arguments[\"--all\"]:\n            Console.ok(70 * \"-\")\n            Console.ok('DIR')\n            Console.ok(70 * \"-\")\n            for element in dir(self):\n                Console.ok(str(element))\n            Console.ok(70 * \"-\")\n        self.print_info()", "response": "Print some internal information about the current object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives parsed variant - loading arguments return a pandas DataFrame.", "response": "def load_from_args_as_dataframe(args):\n    '''\n    Given parsed variant-loading arguments, return a pandas DataFrame.\n\n    If no variant loading arguments are specified, return None.\n    '''\n    if not args.variants and not args.single_variant:\n        return None\n\n    if args.variant_source_name:\n        variant_source_names = util.expand(\n            args.variant_source_name,\n            'variant_source_name',\n            'variant source',\n            len(args.variants))\n    else:\n        variant_source_names = util.drop_prefix(args.variants)\n\n    variant_to_sources = collections.defaultdict(list)\n\n    dfs = []\n    for i in range(len(args.variants)):\n        name = variant_source_names[i]\n        prefix = (\n            'metadata:' if len(args.variants) == 1 else \"metadata:%s:\" % name)\n        df = load_as_dataframe(\n            args.variants[i],\n            name=name,\n            genome=args.genome,\n            max_variants=args.max_variants_per_source,\n            only_passing=not args.include_failing_variants,\n            metadata_column_prefix=prefix)\n\n        if df.shape[0] == 0:\n            logging.warn(\"No variants loaded from: %s\" % args.variants[i])\n        else:\n            for variant in df.variant:\n                variant_to_sources[variant].append(name)\n            dfs.append(df)\n\n    if args.single_variant:\n        variants = []\n        extra_args = {}\n        if args.genome:\n            extra_args = {\n                'ensembl': varcode.reference.infer_genome(args.genome)\n            }\n        for (locus_str, ref, alt) in args.single_variant:\n            locus = Locus.parse(locus_str)\n            variant = varcode.Variant(\n                    locus.contig,\n                    locus.inclusive_start,\n                    ref,\n                    alt,\n                    **extra_args)\n            variants.append(variant)\n            variant_to_sources[variant].append(\"commandline\")\n        dfs.append(variants_to_dataframe(variants))\n\n    df = dfs.pop(0)\n    for other_df in dfs:\n        df = pandas.merge(\n            df,\n            other_df,\n            how='outer',\n            on=[\"variant\"] + STANDARD_DATAFRAME_COLUMNS)\n\n    genomes = df[\"genome\"].unique()\n    if len(genomes) > 1:\n        raise ValueError(\n                \"Mixing references is not supported. \"\n                \"Reference genomes: %s\" % (\", \".join(genomes)))\n\n    df[\"sources\"] = [\" \".join(variant_to_sources[v]) for v in df.variant]\n\n    # Apply filters:\n    if args.ref:\n        df = df.ix[df.ref.isin(args.ref)]\n    if args.alt:\n        df = df.ix[df.alt.isin(args.alt)]\n    loci = loci_util.load_from_args(\n        util.remove_prefix_from_parsed_args(args, \"variant\"))\n    if loci is not None:\n        df = df.ix[[\n            loci.intersects(pileup_collection.to_locus(v))\n            for v in df.variant\n        ]]\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests data from the server.", "response": "def request(self, cmd, *args, **kwargs):\n        \"\"\"\n        Request data fromo the server.\n\n        :param cmd: repo handler command.\n\n        :returns: Result.\n        \"\"\"\n        params = {'action': cmd}\n        #TODO: serialize the kwargs?\n        params.update(kwargs)\n        return self.__request(self.url, params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __request(self, url, params):\n        log.debug('request: %s %s' %(url, str(params)))\n        try:\n            response = urlopen(url, urlencode(params)).read()\n            if params.get('action') != 'data':\n                log.debug('response: %s' % response)\n            if params.get('action', None) == 'data':\n                return response\n            else:\n                return json.loads(response)\n        except TypeError, e:\n            log.exception('request error')\n            raise ServerError(e)\n        except IOError, e:\n            log.error('request error: %s' % str(e))\n            raise ServerError(e)", "response": "Make an HTTP POST request to the server and return JSON data."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the position of the locus in the locus property.", "response": "def position(self):\n        '''\n        If this locus spans a single base, this property gives that position.\n        Otherwise, raises a ValueError.\n        '''\n        if self.end != self.start + 1:\n            raise ValueError(\"Not a single base: %s\" % str(self))\n        return self.start"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives coordinates in 0 - based interbase coordinates return a Locus instance.", "response": "def from_interbase_coordinates(contig, start, end=None):\n        '''\n        Given coordinates in 0-based interbase coordinates, return a Locus\n        instance.\n        '''\n        typechecks.require_string(contig)\n        typechecks.require_integer(start)\n        if end is None:\n            end = start + 1\n        typechecks.require_integer(end)\n        contig = pyensembl.locus.normalize_chromosome(contig)\n        return Locus(contig, start, end)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef variant_context(\n        reference_fasta,\n        contig,\n        inclusive_start,\n        inclusive_end,\n        alt,\n        context_length):  \n    \"\"\"\n    Retrieve the surronding reference region from a variant.\n\n    SNVs are canonicalized so the reference base is a pyrmidine (C/T). For\n    indels the reverse complement will still be taken if the first base of\n    the reference is not a pyrmidine, but since the reference will also be\n    reversed, that doesn't guarantee it will start with a pyrmidine.\n\n    Parameters\n    ----------\n    reference_fasta : FastaReference\n        reference sequence from pyfaidx package\n\n    contig : str\n        Chromosome of the variant\n\n    inclusive_start : int\n        start of the variant in 1-based inclusive coordinates\n\n    inclusive_end : int\n        end of the variant in 1-based inclusive coordinates\n\n    alt : string\n        alt sequence\n\n    context_length : int\n        number of bases on either side of the variant to return\n\n    Returns\n    ---------\n    A tuple of (5', mutation, 3') where\n        5' - bases immediately 5 prime to the mutation\n        \n        3' - bases immediately 3 prime to the mutation\n        \n        mutation - the ref sequence followed by a > character followed by the\n            the alt sequence\n    \"\"\"\n\n    # Move from 1-base coorindates to 0-base coordinates\n    start = int(inclusive_start) - 1\n    end = int(inclusive_end)\n\n    full_sequence = reference_fasta[contig]\n\n    left = str(full_sequence[start - context_length:start].seq).upper()\n    middle = str(full_sequence[start: end].seq).upper()\n    right = str(full_sequence[end: end + context_length].seq).upper()\n\n    # Complement and reverse the context if necessary so the ref base is a\n    # pyrmidine (C/T)\n    if middle[0] in ('A', 'G'):\n        context_5prime = pyfaidx.complement(right)[::-1]\n        context_3prime = pyfaidx.complement(left)[::-1]\n        context_mutation = \"%s>%s\" % (\n            pyfaidx.complement(middle)[::-1], pyfaidx.complement(alt)[::-1])\n    else:\n        context_5prime = left\n        context_3prime = right\n        context_mutation = \"%s>%s\" % (middle, alt)\n\n    return (context_5prime, context_mutation, context_3prime)", "response": "Retrieve the surronding reference region from a variant."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize(string: Text) -> Text:\n\n    string = string.lower()\n    string = unidecode(string)\n    string = RE_WHITESPACES.sub(' ', string).strip()\n\n    return string", "response": "Normalizes a string to encompass various things humans tend to get wrong"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_trigrams(i: Iterable[T]) \\\n        -> Iterable[Tuple[Optional[T], Optional[T], Optional[T]]]:\n    \"\"\"\n    Compute all trigrams of an iterable and yield them. You probably want\n    to do something like:\n\n    >>> t = set(make_trigrams('hi there'))\n    \"\"\"\n    q = deque([None, None, None])\n\n    def nxt():\n        q.append(x)\n        q.popleft()\n        return tuple(c if c is not None else ' ' for c in q)\n\n    for x in i:\n        yield nxt()\n\n    if q[-1] is not None:\n        x = None\n        yield nxt()", "response": "Compute all trigrams of an iterable and yield them."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef similarity(self, other: 'Trigram') -> float:\n        if not len(self._trigrams) or not len(other._trigrams):\n            return 0\n\n        count = float(len(self._trigrams & other._trigrams))\n        len1 = float(len(self._trigrams))\n        len2 = float(len(other._trigrams))\n\n        return count / (len1 + len2 - count)", "response": "Compute the similarity with the provided trigram."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _match(self, local: Tuple[Trigram, ...], other: Trigram) -> float:\n\n        pos = local[0] % other\n        neg = max((x % other for x in local[1:]), default=0)\n\n        if neg > pos:\n            return 0.0\n\n        return pos", "response": "Match a trigram with another trigram."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef similarity(self, other: Trigram) -> float:\n        return max((self._match(x, other) for x in self.trigrams), default=0)", "response": "Find the best similarity between this set and another set."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the best matching score and the associated label.", "response": "def similarity(self, other: Trigram) -> Tuple[float, L]:\n        \"\"\"\n        Returns the best matching score and the associated label.\n        \"\"\"\n\n        return max(\n            ((t % other, l) for t, l in self.trigrams),\n            key=lambda x: x[0],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _construct_full_hostname(self, hostname):\n        if hostname.startswith(('http://', 'https://', )):\n            return hostname\n        if '://' in hostname:\n            protocol, host = hostname.split('://', 1)\n            raise ValueError('Protocol %s is not supported.' % protocol)\n        return '://'.join([self.default_scheme, hostname, ])", "response": "Create a full hostname from the argument given."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the exception class suitable for the specified HTTP status code.", "response": "def _exception_for(self, code):\n        \"\"\"Return the exception class suitable for the specified HTTP\n        status code.\n\n        Raises:\n            UnknownError: The HTTP status code is not one of the knowns.\n        \"\"\"\n        if code in self.errors:\n            return self.errors[code]\n        elif 500 <= code < 599:\n            return exceptions.RemoteServerError\n        else:\n            return exceptions.UnknownError"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_content_size(self, path):\n        \"Return size of files/dirs contents excluding parent node.\"\n        node = self._get_node(path)\n        return self._get_content_size(node) - node.size", "response": "Return size of files / dirs contents excluding parent node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef postprocess(self):\n        try:\n            for name, item in self['addresses'][0].items():\n                try:\n                    if name == \"indexInList\": continue\n                    self['addresses'][0][name] = unicode(self['addresses'][0][name])\n                    self['address'][name] = unicode(self['address'][name])\n                except AttributeError:\n                    pass\n        except (KeyError, IndexError):\n            pass\n\n        super(MambuClient,self).postprocess()", "response": "Postprocessing.\n\n        Just in case some elements on the addresses was converted to\n        anything but string, it gets converted back to only string\n        (unicode). Things on addresses are not useful but by what they\n        say, not what they are.\n\n.. todo:: do the same thing to the 'address' field created on\n          preprocessing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the groups to which this client belongs. Returns the number of requests done to Mambu.", "response": "def setGroups(self, *args, **kwargs):\n        \"\"\"Adds the groups to which this client belongs.\n\n        The 'groupKeys' field of the client holds a list of the\n        encodedKeys of the groups to which this client belongs.\n\n        Returns the number of requests done to Mambu.\n        \"\"\"\n\n        requests = 0\n        groups = []\n        try:\n            for gk in self['groupKeys']:\n                try:\n                    g = self.mambugroupclass(entid=gk, *args, **kwargs)\n                except AttributeError as ae:\n                    from .mambugroup import MambuGroup\n                    self.mambugroupclass = MambuGroup\n                    g = self.mambugroupclass(entid=gk, *args, **kwargs)\n                requests += 1\n                groups.append(g)\n        except KeyError:\n            pass\n\n        self['groups'] = groups\n\n        return requests"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setBranch(self, *args, **kwargs):\n\n        try:\n            branch = self.mambubranchclass(entid=self['assignedBranchKey'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mambubranch import MambuBranch\n            self.mambubranchclass = MambuBranch\n            branch = self.mambubranchclass(entid=self['assignedBranchKey'], *args, **kwargs)\n        self['assignedBranchName'] = branch['name']\n        self['assignedBranch'] = branch\n\n        return 1", "response": "Adds the branch to which the client belongs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convertDict2Attrs(self, *args, **kwargs):\n        for n,c in enumerate(self.attrs):\n            # ok ok, I'm modifying elements of a list while iterating it. BAD PRACTICE!\n            try:\n                params = self.params\n            except AttributeError as aerr:\n                params = {}\n            kwargs.update(params)\n            try:\n                client = self.mambuclientclass(urlfunc=None, entid=None, *args, **kwargs)\n            except AttributeError as ae:\n                self.mambuclientclass = MambuClient\n                client = self.mambuclientclass(urlfunc=None, entid=None, *args, **kwargs)\n            client.init(c, *args, **kwargs)\n            self.attrs[n] = client", "response": "This function converts a dictionary of Mambu objects into a list of MambuClient objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef protected(self, *tests, **kwargs):\n        _role = kwargs.pop('role', None)\n        _roles = kwargs.pop('roles', None) or []\n        _csrf = kwargs.pop('csrf', None)\n        _url_sign_in = kwargs.pop('url_sign_in', None)\n        _request = kwargs.pop('request', None)\n\n        if _role:\n            _roles.append(_role)\n        _roles = [to_unicode(r) for r in _roles]\n\n        _tests = tests\n        _user_tests = kwargs\n\n        def decorator(f):\n            @functools.wraps(f)\n            def wrapper(*args, **kwargs):\n                logger = logging.getLogger(__name__)\n                request = _request or self.request or args and args[0]\n                url_sign_in = self._get_url_sign_in(request, _url_sign_in)\n\n                user = self.get_user()\n                if not user:\n                    return self._login_required(request, url_sign_in)\n\n                if hasattr(user, 'has_role') and _roles:\n                    if not user.has_role(*_roles):\n                        logger.debug(u'User `{0}`: has_role fail'.format(user.login))\n                        logger.debug(u'User roles: {0}'.format([r.name for r in user.roles]))\n                        return self.wsgi.raise_forbidden()\n\n                for test in _tests:\n                    test_pass = test(user, *args, **kwargs)\n                    if not test_pass:\n                        logger.debug(u'User `{0}`: test fail'.format(user.login))\n                        return self.wsgi.raise_forbidden()\n\n                for name, value in _user_tests.items():\n                    user_test = getattr(user, name)\n                    test_pass = user_test(value, *args, **kwargs)\n                    if not test_pass:\n                        logger.debug(u'User `{0}`: test fail'.format(user.login))\n                        return self.wsgi.raise_forbidden()\n\n                disable_csrf = _csrf == False  # noqa\n                if (not self.wsgi.is_idempotent(request) and not disable_csrf) or _csrf:\n                    if not self.csrf_token_is_valid(request):\n                        logger.debug(u'User `{0}`: invalid CSFR token'.format(user.login))\n                        return self.wsgi.raise_forbidden(\"CSFR token isn't valid\")\n\n                return f(*args, **kwargs)\n            return wrapper\n        return decorator", "response": "Decorator for limit the access to views."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace_flask_route(self, bp, *args, **kwargs):\n        protected = self.protected\n\n        def protected_route(rule, **options):\n            \"\"\"Like :meth:`Flask.route` but for a blueprint.  The endpoint for the\n            :func:`url_for` function is prefixed with the name of the blueprint.\n            \"\"\"\n            def decorator(f):\n                endpoint = options.pop(\"endpoint\", f.__name__)\n                protected_f = protected(*args, **kwargs)(f)\n                bp.add_url_rule(rule, endpoint, protected_f, **options)\n                return f\n            return decorator\n\n        bp.route = protected_route", "response": "Replace the Flask app. route or blueprint. route with a version\n        that first applies the protected decorator to the view so all views\n        are automatically protected."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a query string using given grammar", "response": "def parse_query(self, query):\n        \"\"\"Parse query string using given grammar\"\"\"\n        tree = pypeg2.parse(query, Main, whitespace=\"\")\n        return tree.accept(self.converter)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunpacks a compact - form serialized JWT.", "response": "def _unpack_token_compact(token):\n    \"\"\"\n    Unpack a compact-form serialized JWT.\n    Returns (header, payload, signature, signing_input) on success\n    Raises DecodeError on bad input\n    \"\"\"\n    if isinstance(token, (str, unicode)):\n        token = token.encode('utf-8')\n\n    try:\n        signing_input, crypto_segment = token.rsplit(b'.', 1)\n        header_segment, payload_segment = signing_input.split(b'.', 1)\n    except ValueError:\n        raise DecodeError('Not enough segments')\n\n    try:\n        header_data = base64url_decode(header_segment)\n    except (TypeError, binascii.Error):\n        raise DecodeError('Invalid header padding')\n\n    try:\n        header = json.loads(header_data.decode('utf-8'))\n    except ValueError as e:\n        raise DecodeError('Invalid header string: %s' % e)\n\n    if not isinstance(header, Mapping):\n        raise DecodeError('Invalid header string: must be a json object')\n\n    try:\n        payload_data = base64url_decode(payload_segment)\n    except (TypeError, binascii.Error):\n        raise DecodeError('Invalid payload padding')\n\n    try:\n        payload = json.loads(payload_data.decode('utf-8'))\n    except ValueError as e:\n        raise DecodeError('Invalid payload string: %s' % e)\n\n    try:\n        signature = base64url_decode(crypto_segment)\n    except (TypeError, binascii.Error):\n        raise DecodeError('Invalid crypto padding')\n\n    return (header, payload, signature, signing_input)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunpacking a JSON - serialized JWT into a list of headers payload signatures and signing_inputs.", "response": "def _unpack_token_json(token):\n    \"\"\"\n    Unpack a JSON-serialized JWT\n    Returns (headers, payload, signatures) on success\n    Raises DecodeError on bad input\n    \"\"\"\n    if not isinstance(token, dict):\n        raise DecodeError(\"Not a dict\")\n\n    if not token.has_key('payload'):\n        raise DecodeError(\"Missing 'payload' field\")\n\n    for k in ['header', 'signature']:\n        if not token.has_key(k):\n            raise DecodeError(\"Missing '{}' field\".format(k))\n\n        if not isinstance(token[k], list):\n            raise DecodeError(\"Field '{}' is not a string\".format(k))\n\n    headers = []\n    signatures = []\n    signing_inputs = []\n    payload = None\n\n    try:\n        headers = [base64url_decode(str(h)) for h in token['header']]\n    except (TypeError, binascii.Error):\n        raise DecodeError(\"Invalid header padding\")\n\n    try:\n        payload_data = base64url_decode(str(token['payload']))\n    except (TypeError, binascii.Error):\n        raise DecodeError(\"Invalid payload padding\")\n\n    try:\n        payload = json.loads(payload_data.decode('utf-8'))\n    except ValueError as e:\n        raise DecodeError('Invalid payload string: {}'.format(e))\n\n    try:\n        signatures = [base64url_decode(str(s)) for s in token['signature']]\n    except (TypeError, binascii.Error):\n        raise DecodeError(\"Invalid crypto padding\")\n\n    for header_b64 in token['header']:\n        signing_inputs.append( b'{}.{}'.format(header_b64, token['payload']) )\n\n    return (headers, payload, signatures, signing_inputs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunpacking a JSON - serialized JWT or a compact - serialized JWT returning a tuple of header payload signature signing_input", "response": "def unpack_token(token):\n    \"\"\"\n    Unpack a JSON-serialized JWT or a compact-serialized JWT\n    Returns (header, payload, signature, signing_input) on success\n    Raises DecodeError on bad input\n    \"\"\"\n    if isinstance(token, (unicode,str)):\n        return _decode_token_compact(token)\n\n    else:\n        return _decode_token_json(token)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecoding a compact - serialized JWT Returns a compact - serialized JWT", "response": "def _decode_token_compact(token):\n    \"\"\"\n    Decode a compact-serialized JWT\n    Returns {'header': ..., 'payload': ..., 'signature': ...}\n    \"\"\"\n    header, payload, raw_signature, signing_input = _unpack_token_compact(token)\n    token = { \n        \"header\": header,\n        \"payload\": payload,\n        \"signature\": base64url_encode(raw_signature)\n    }\n    return token"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _decode_token_json(token):\n    header, payload, raw_signatures, signing_inputs = _unpack_token_json(token)\n    token = {\n        'header': header,\n        'payload': payload,\n        'signature': [base64url_encode(rs) for rs in raw_signatures]\n    }\n    return token", "response": "Decode a JSON - serialized JWT\n    Returns a dictionary with header payload and signature."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_token(token):\n    if isinstance(token, (unicode,str)):\n        return _decode_token_compact(token)\n\n    else:\n        return _decode_token_json(token)", "response": "Decode a compact - encoded JWT into a dict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nverify a JSON - formatted JWT signed by multiple keys.", "response": "def _verify_multi(self, token, verifying_keys, num_required=None):\n        \"\"\"\n        Verify a JSON-formatted JWT signed by multiple keys is authentic.\n        Optionally set a threshold of required valid signatures with num_required.\n        Return True if valid\n        Return False if not\n\n        TODO: support multiple types of keys\n        \"\"\"\n        headers, payload, raw_signatures, signing_inputs = _unpack_token_json(token)\n        if num_required is None:\n            num_required = len(raw_signatures)\n\n        if num_required > len(verifying_keys):\n            # not possible\n            return False\n\n        if len(headers) != len(raw_signatures):\n            # invalid \n            raise DecodeError('Header/signature mismatch')\n\n        verifying_keys = [load_verifying_key(vk, self.crypto_backend) for vk in verifying_keys]\n\n        # sanity check: only support one type of key :(\n        for vk in verifying_keys:\n            if vk.curve.name != verifying_keys[0].curve.name:\n                raise DecodeError(\"TODO: only support using keys from one curve per JWT\")\n                \n        der_signatures = [raw_to_der_signature(rs, verifying_keys[0].curve) for rs in raw_signatures]\n\n        # verify until threshold is met\n        num_verified = 0\n        for (signing_input, der_sig) in zip(signing_inputs, der_signatures):\n            for vk in verifying_keys:\n                verifier = self._get_verifier(vk, der_sig)\n                verifier.update(signing_input)\n                try:\n                    verifier.verify()\n                    num_verified += 1\n                    verifying_keys.remove(vk)\n                    break\n                except InvalidSignature:\n                    pass\n\n            if num_verified >= num_required:\n                break\n\n        return (num_verified >= num_required)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verify(self, token, verifying_key_or_keys, num_required=None):\n        if not isinstance(verifying_key_or_keys, (list, str, unicode)):\n            raise ValueError(\"Invalid verifying key(s): expected list or string\")\n\n        if isinstance(verifying_key_or_keys, list):\n            return self._verify_multi(token, verifying_key_or_keys, num_required=num_required)\n\n        else:\n            return self._verify_single(token, str(verifying_key_or_keys))", "response": "Verify a compact - formated JWT or a JSON - formatted JWT signed by multiple keys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nactivating the script command", "response": "def activate_script(self):\n        \"\"\"activates the script command\"\"\"\n\n        # must be rethought\n        # ./scripts\n        # deploydir/./scripts\n        self._add_scope(\"script\")\n        self.scripts = {}\n        self.script_files = [\n            \"./scripts/script_*.txt\", \"~/.cloudmesh/scripts/script_*.txt\"]\n        self._load_scripts(self.script_files)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_script(self, args, arguments):\n        if args == \"load\":\n            self._load_scripts(self.script_files)\n            self._list_scripts()\n        elif args == \"list\" or args == \"\" or args is None:\n            self._list_scripts()\n        elif args in self.scripts:\n            filename = self.scripts[args]\n            self.run_script(filename)\n        elif arguments['load'] and arguments['REGEXP']:\n            new_files = arguments['REGEXP']\n            self.add_script_dir(new_files)\n            self._load_scripts(new_files)\n            self._list_scripts()\n        else:\n            Console.error(\"script execution not yet defined\")\n            print arguments\n            print args", "response": "This function is called by the script module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef safeMakeDirs(path, mode=0o777):\n        try:\n            os.makedirs(path, mode)\n\n            return True\n        except OSError:\n            return False", "response": "Makes the given directory path as well as intermediate directories. Returns True if successful False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef touch(path):\n        parentDirPath = os.path.dirname(path)\n\n        PathOperations.safeMakeDirs(parentDirPath)\n\n        with open(path, \"wb\"):\n            pass", "response": "Creates a file with the given path as a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting a tree and returns true if it was correctly deleted.", "response": "def safeRmTree(rootPath):\n        \"\"\"\n        Deletes a tree and returns true if it was correctly deleted\n        \"\"\"\n        shutil.rmtree(rootPath, True)\n\n        return not os.path.exists(rootPath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef linearWalk(rootPath, currentDirFilter=None):\n        for dirTuple in os.walk(rootPath):\n            (dirPath, dirNames, fileNames) = dirTuple\n\n            if currentDirFilter is not None and not currentDirFilter(dirPath, dirNames, fileNames):\n                continue\n\n            for fileName in fileNames:\n                yield LinearWalkItem(\n                    dirPath,\n                    fileName\n                )", "response": "Returns a list of LinearWalkItem s one for each file in the tree whose root is rootPath."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_live_reload(run):\n    from asyncio import get_event_loop\n    from ._live_reload import start_child\n\n    loop = get_event_loop()\n\n    if run:\n        loop.run_until_complete(start_child())\n    else:\n        get_event_loop().create_task(start_child())", "response": "Start the live reload task"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmp_name(first_node, second_node):\n    if len(first_node.children) == len(second_node.children):\n        for first_child, second_child in zip(first_node.children,\n                                             second_node.children):\n            for key in first_child.__dict__.keys():\n                if key.startswith('_'):\n                    continue\n                if first_child.__dict__[key] != second_child.__dict__[key]:\n                    return 1\n            ret_val = cmp_name(first_child, second_child)\n            if ret_val != 0:\n                return 1\n    else:\n        return 1\n    return 0", "response": "Compare two name recursively."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a line of a file into a node.", "response": "def parse_division(l, c, line, root_node, last_section_node):\n    \"\"\"\n    Extracts a division node from a line\n\n    :param l: The line number (starting from 0)\n\n    :param c: The column number\n\n    :param line: The line string (without indentation)\n\n    :param root_node: The document root node.\n\n    :return: tuple(last_div_node, last_section_node)\n    \"\"\"\n    name = line\n    name = name.replace(\".\", \"\")\n    # trim whitespaces/tabs between XXX and DIVISION\n    tokens = [t for t in name.split(' ') if t]\n    node = Name(Name.Type.Division, l, c, '%s %s' % (tokens[0], tokens[1]))\n    root_node.add_child(node)\n    last_div_node = node\n    # do not take previous sections into account\n    if last_section_node:\n        last_section_node.end_line = l\n    last_section_node = None\n    return last_div_node, last_section_node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_section(l, c, last_div_node, last_vars, line):\n    name = line\n    name = name.replace(\".\", \"\")\n    node = Name(Name.Type.Section, l, c, name)\n    last_div_node.add_child(node)\n    last_section_node = node\n    # do not take previous var into account\n    last_vars.clear()\n    return last_section_node", "response": "Extracts a section node from a line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a pic field line. Returns A VariableNode or None if the line is malformed.", "response": "def parse_pic_field(l, c, last_section_node, last_vars, line):\n    \"\"\"\n    Parse a pic field line. Return A VariableNode or None in case of malformed\n    code.\n\n    :param l: The line number (starting from 0)\n    :param c: The column number (starting from 0)\n    :param last_section_node: The last section node found\n    :param last_vars: The last vars dict\n    :param line: The line string (without indentation)\n    :return: The extracted variable node\n    \"\"\"\n    parent_node = None\n    raw_tokens = line.split(\" \")\n    tokens = []\n    for t in raw_tokens:\n        if not t.isspace() and t != \"\":\n            tokens.append(t)\n    try:\n        if tokens[0].upper() == \"FD\":\n            lvl = 1\n        else:\n            lvl = int(tokens[0], 16)\n        name = tokens[1]\n    except ValueError:\n        return None\n    except IndexError:\n        # line not complete\n        return None\n    name = name.replace(\".\", \"\")\n    if name in ALL_KEYWORDS or name in ['-', '/']:\n        return None\n    m = re.findall(r'pic.*\\.', line, re.IGNORECASE)\n    if m:\n        description = ' '.join([t for t in m[0].split(' ') if t])\n    else:\n        description = line\n    try:\n        index = description.lower().index('value')\n    except ValueError:\n        description = description.replace('.', '')\n    else:\n        description = description[index:].replace('value', '')[:80]\n    if lvl == int('78', 16):\n        lvl = 1\n    if lvl == 1:\n        parent_node = last_section_node\n        last_vars.clear()\n    else:\n        # find parent level\n        levels = sorted(last_vars.keys(), reverse=True)\n        for lv in levels:\n            if lv < lvl:\n                parent_node = last_vars[lv]\n                break\n    if not parent_node:\n        # malformed code\n        return None\n    # todo: enabled this with an option in pyqode 3.0\n    # if lvl == int('88', 16):\n    #     return None\n    if not name or name.upper().strip() == 'PIC':\n        name = 'FILLER'\n    node = Name(Name.Type.Variable, l, c, name, description)\n    parent_node.add_child(node)\n    last_vars[lvl] = node\n    # remove closed variables\n    levels = sorted(last_vars.keys(), reverse=True)\n    for l in levels:\n        if l > lvl:\n            last_vars.pop(l)\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_paragraph(l, c, last_div_node, last_section_node, line):\n    if not line.endswith('.'):\n        return None\n    name = line.replace(\".\", \"\")\n    if name.strip() == '':\n        return None\n    if name.upper() in ALL_KEYWORDS:\n        return None\n    parent_node = last_div_node\n    if last_section_node is not None:\n        parent_node = last_section_node\n    node = Name(Name.Type.Paragraph, l, c, name)\n    parent_node.add_child(node)\n    return node", "response": "Parses a line of text into a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a cobol code and returns a tuple of names and their associated procedures.", "response": "def defined_names(code, free_format=False):\n    \"\"\"\n    Parses a cobol document and build a name tree.\n\n    For convenience, it also returns the list of variables (PIC) and\n    procedures (paragraphs).\n\n    :param code: cobol code to parse. Default is None.\n    :param free_format: True if the source code must be considered as coded\n        in free format.\n\n    :return: A tuple made up of the name tree root node, the list of variables\n        and  the list of paragraphs.\n    :rtype: Name, list of Name, list of Name\n    \"\"\"\n    root_node = Name(Name.Type.Root, 0, 0, 'root')\n    variables = []\n    paragraphs = []\n    lines = code.splitlines()\n    last_div_node = None\n    last_section_node = None\n    last_vars = {}\n    last_par = None\n\n    for i, line in enumerate(lines):\n        if not free_format:\n            if len(line) >= 6:\n                line = 6 * \" \" + line[6:]\n        column = len(line) - len(line.lstrip())\n        if not line.isspace() and not line.strip().startswith(\"*\"):\n            line = line.strip()\n            # DIVISIONS\n            if regex.DIVISION.indexIn(line.upper()) != -1 and 'EXIT' not in line.upper():\n                # remember\n                if last_div_node is not None:\n                    last_div_node.end_line = i\n                last_div_node, last_section_node = parse_division(\n                    i, column, line, root_node, last_section_node)\n            # SECTIONS\n            elif regex.SECTION.indexIn(line.upper()) != -1 and 'EXIT' not in line.upper():\n                if last_section_node:\n                    last_section_node.end_line = i\n                if last_div_node is None:\n                    name = 'PROCEDURE DIVISION'\n                    for to_check in ['WORKING-STORAGE', 'LOCAL-STORAGE', 'LINKAGE', 'REPORT ', 'SCREEN']:\n                        if to_check in line.upper():\n                            name = 'DATA DIVISION'\n                    last_div_node = Name(Name.Type.Division, -1, -1, name, name)\n                    root_node.add_child(last_div_node)\n                last_section_node = parse_section(\n                    i, column, last_div_node, last_vars, line)\n            # VARIABLES\n            # PARAGRAPHS\n            elif (last_div_node is not None and\n                  \"PROCEDURE DIVISION\" in last_div_node.name.upper()):\n                tokens = line.upper().split(\" \")\n                if len(tokens) == 1 and not tokens[0] in ALL_KEYWORDS:\n                    p = parse_paragraph(\n                        i, column, last_div_node, last_section_node, line)\n                    if p:\n                        paragraphs.append(p)\n                        if last_par:\n                            last_par.end_line = i\n                        last_par = p\n            elif regex.VAR_PATTERN.indexIn(line.upper()) != -1 or line.upper().lstrip().startswith('FD'):\n                if last_div_node is None:\n                    last_div_node = Name(Name.Type.Division, -1, -1, 'DATA DIVISION', '')\n                    root_node.add_child(last_div_node)\n                if last_section_node is None:\n                    last_section_node = Name(Name.Type.Section, -1, -1, 'WORKING-STORAGE SECTION', '')\n                    last_div_node.add_child(last_section_node)\n                v = parse_pic_field(\n                    i, column, last_section_node, last_vars, line)\n                if v:\n                    variables.append(v)\n\n    # close last div\n    if last_par:\n        last_par.end_line = len(lines) - 1\n    if last_div_node:\n        last_div_node.end_line = len(lines)\n    if root_node and last_div_node:\n        root_node.end_line = last_div_node.end_line\n\n    return root_node, variables, paragraphs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind a possible child whose name matches the name parameter.", "response": "def find(self, name):\n        \"\"\"\n        Finds a possible child whose name match the name parameter.\n\n        :param name: name of the child node to look up\n        :type name: str\n\n        :return: DocumentNode or None\n        \"\"\"\n        for c in self.children:\n            if c.name == name:\n                return c\n            result = c.find(name)\n            if result:\n                return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_definition(self):\n        icon = {\n            Name.Type.Root: icons.ICON_MIMETYPE,\n            Name.Type.Division: icons.ICON_DIVISION,\n            Name.Type.Section: icons.ICON_SECTION,\n            Name.Type.Variable: icons.ICON_VAR,\n            Name.Type.Paragraph: icons.ICON_FUNC\n        }[self.node_type]\n        d = Definition(self.name, self.line, self.column, icon, self.description)\n        for ch in self.children:\n            d.add_child(ch.to_definition())\n        return d", "response": "Converts the name instance to a pyqode. core. share. Definition object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to database utility function.", "response": "def connectDb(engine   = dbeng,\n              user     = dbuser,\n              password = dbpwd,\n              host     = dbhost,\n              port     = dbport,\n              database = dbname,\n              params   = \"?charset=utf8&use_unicode=1\",\n              echoopt  = False):\n    \"\"\"Connect to database utility function.\n\n    Uses SQLAlchemy ORM library.\n\n    Useful when using schema modules in MambuPy\n    \"\"\"\n    return create_engine('%s://%s:%s@%s:%s/%s%s' % (engine, user, password, host, port, database, params), echo=echoopt)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting Branches URL. If idbranch is set, you'll get a response adequate for a MambuBranch object. If not set, you'll get a response adequate for a MambuBranches object. See mambubranch module and pydoc for further information. Currently implemented filter parameters: * fullDetails * limit * offset See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def getbranchesurl(idbranch, *args, **kwargs):\n    \"\"\"Request Branches URL.\n\n    If idbranch is set, you'll get a response adequate for a MambuBranch object.\n    If not set, you'll get a response adequate for a MambuBranches object.\n    See mambubranch module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * fullDetails\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n\n    branchidparam = \"\" if idbranch == \"\" else \"/\"+idbranch\n    url = getmambuurl(*args, **kwargs) + \"branches\" + branchidparam + (\"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getcentresurl(idcentre, *args, **kwargs):\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n\n    centreidparam = \"\" if idcentre == \"\" else \"/\"+idcentre\n    url = getmambuurl(*args, **kwargs) + \"centres\" + centreidparam + (\"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url", "response": "Request Centres URL.\n\n    If idcentre is set, you'll get a response adequate for a MambuCentre object.\n    If not set, you'll get a response adequate for a MambuCentres object.\n    See mambucentre module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * fullDetails\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getrepaymentsurl(idcred, *args, **kwargs):\n    url = getmambuurl(*args,**kwargs) + \"loans/\" + idcred + \"/repayments\"\n    return url", "response": "Request loan Repayments URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrequest Loans URL. If idcred is set, you'll get a response adequate for a MambuLoan object. If not set, you'll get a response adequate for a MambuLoans object. See mambuloan module and pydoc for further information. Currently implemented filter parameters: * fullDetails * accountState * branchId * centreId * creditOfficerUsername * limit * offset See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def getloansurl(idcred, *args, **kwargs):\n    \"\"\"Request Loans URL.\n\n    If idcred is set, you'll get a response adequate for a MambuLoan object.\n    If not set, you'll get a response adequate for a MambuLoans object.\n    See mambuloan module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * fullDetails\n    * accountState\n    * branchId\n    * centreId\n    * creditOfficerUsername\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"accountState=%s\" % kwargs[\"accountState\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"branchId=%s\" % kwargs[\"branchId\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"centreId=%s\" % kwargs[\"centreId\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"creditOfficerUsername=%s\" % kwargs[\"creditOfficerUsername\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n\n    idcredparam = \"\" if idcred == \"\" else \"/\"+idcred\n    url = getmambuurl(*args,**kwargs) + \"loans\" + idcredparam + (\"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequest Groups URL. If idgroup is set, you'll get a response adequate for a MambuGroup object. If not set, you'll get a response adequate for a MambuGroups object. See mambugroup module and pydoc for further information. Currently implemented filter parameters: * fullDetails * creditOfficerUsername * branchId * centreId * limit * offset See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def getgroupurl(idgroup, *args, **kwargs):\n    \"\"\"Request Groups URL.\n\n    If idgroup is set, you'll get a response adequate for a MambuGroup object.\n    If not set, you'll get a response adequate for a MambuGroups object.\n    See mambugroup module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * fullDetails\n    * creditOfficerUsername\n    * branchId\n    * centreId\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"creditOfficerUsername=%s\" % kwargs[\"creditOfficerUsername\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"branchId=%s\" % kwargs[\"branchId\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"centreId=%s\" % kwargs[\"centreId\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n    groupidparam = \"\" if idgroup == \"\" else \"/\"+idgroup\n    url = getmambuurl(*args,**kwargs) + \"groups\" + groupidparam + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest Group loans URL.", "response": "def getgrouploansurl(idgroup, *args, **kwargs):\n    \"\"\"Request Group loans URL.\n\n    How to use it? By default MambuLoan uses getloansurl as the urlfunc.\n    Override that behaviour by sending getgrouploansurl (this function)\n    as the urlfunc to the constructor of MambuLoans (note the final 's')\n    and voila! you get the Loans just for a certain group.\n\n    If idgroup is set, you'll get a response adequate for a\n    MambuLoans object.\n\n    If not set, you'll get a Jar Jar Binks object, or something quite\n    strange and useless as JarJar. A MambuError must likely since I\n    haven't needed it for anything but for loans of one and just\n    one group.\n\n    See mambugroup module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * accountState\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"accountState=%s\" % kwargs[\"accountState\"])\n        except Exception as ex:\n            pass\n    groupidparam = \"/\" + idgroup\n    url = getmambuurl(*args,**kwargs) + \"groups\" + groupidparam  + \"/loans\" + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrequests Group Custom Information URL.", "response": "def getgroupcustominformationurl(idgroup, customfield=\"\", *args, **kwargs):\n    \"\"\"Request Group Custom Information URL.\n\n    See mambugroup module and pydoc for further information.\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    groupidparam = \"/\" + idgroup\n    url = getmambuurl(*args, **kwargs) + \"groups\" + groupidparam + \"/custominformation\" + ( (\"/\"+customfield) if customfield else \"\" )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrequest loan Transactions URL.", "response": "def gettransactionsurl(idcred, *args, **kwargs):\n    \"\"\"Request loan Transactions URL.\n\n    If idcred is set, you'll get a response adequate for a\n    MambuTransactions object. There's a MambuTransaction object too, but\n    you'll get a list first and each element of it will be automatically\n    converted to a MambuTransaction object that you may use.\n\n    If not set, you'll get a Jar Jar Binks object, or something quite\n    strange and useless as JarJar. A MambuError must likely since I\n    haven't needed it for anything but for transactions of one and just\n    one loan account.\n\n    See mambutransaction module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n    url = getmambuurl(*args,**kwargs) + \"loans/\" + idcred + \"/transactions\" + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest Clients URL. If idclient is set, you'll get a response adequate for a MambuClient object. If not set, you'll get a response adequate for a MambuClients object. See mambuclient module and pydoc for further information. Currently implemented filter parameters: * fullDetails * firstName * lastName * idDocument * birthdate * state * limit * offset See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def getclienturl(idclient, *args, **kwargs):\n    \"\"\"Request Clients URL.\n\n    If idclient is set, you'll get a response adequate for a MambuClient object.\n    If not set, you'll get a response adequate for a MambuClients object.\n    See mambuclient module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * fullDetails\n    * firstName\n    * lastName\n    * idDocument\n    * birthdate\n    * state\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"firstName=%s\" % kwargs[\"firstName\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"lastName=%s\" % kwargs[\"lastName\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"idDocument=%s\" % kwargs[\"idDocument\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"birthdate=%s\" % kwargs[\"birthdate\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"state=%s\" % kwargs[\"state\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n    clientidparam = \"\" if idclient == \"\" else \"/\"+idclient\n    url = getmambuurl(*args,**kwargs) + \"clients\" + clientidparam + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrequesting Client loans URL.", "response": "def getclientloansurl(idclient, *args, **kwargs):\n    \"\"\"Request Client loans URL.\n\n    How to use it? By default MambuLoan uses getloansurl as the urlfunc.\n    Override that behaviour by sending getclientloansurl (this function)\n    as the urlfunc to the constructor of MambuLoans (note the final 's')\n    and voila! you get the Loans just for a certain client.\n\n    If idclient is set, you'll get a response adequate for a\n    MambuLoans object.\n\n    If not set, you'll get a Jar Jar Binks object, or something quite\n    strange and useless as JarJar. A MambuError must likely since I\n    haven't needed it for anything but for loans of one and just\n    one client.\n\n    See mambuloan module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * accountState\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"accountState=%s\" % kwargs[\"accountState\"])\n        except Exception as ex:\n            pass\n    clientidparam = \"/\" + idclient\n    url = getmambuurl(*args,**kwargs) + \"clients\" + clientidparam  + \"/loans\" + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getclientcustominformationurl(idclient, customfield=\"\", *args, **kwargs):\n    clientidparam = \"/\" + idclient\n    url = getmambuurl(*args, **kwargs) + \"clients\" + clientidparam + \"/custominformation\" + ( (\"/\"+customfield) if customfield else \"\" )\n    return url", "response": "Request Client Custom Information URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrequest Users URL. If iduser is set, you'll get a response adequate for a MambuUser object. If not set, you'll get a response adequate for a MambuUsers object. See mambuuser module and pydoc for further information. Currently implemented filter parameters: * fullDetails * branchId * limit * offset See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def getuserurl(iduser, *args, **kwargs):\n    \"\"\"Request Users URL.\n\n    If iduser is set, you'll get a response adequate for a MambuUser object.\n    If not set, you'll get a response adequate for a MambuUsers object.\n    See mambuuser module and pydoc for further information.\n\n    Currently implemented filter parameters:\n    * fullDetails\n    * branchId\n    * limit\n    * offset\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            if kwargs[\"fullDetails\"] == True:\n                getparams.append(\"fullDetails=true\")\n            else:\n                getparams.append(\"fullDetails=false\")\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"branchId=%s\" % kwargs[\"branchId\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n    useridparam = \"\" if iduser == \"\" else \"/\"+iduser\n    url = getmambuurl(*args,**kwargs) + \"users\" + useridparam + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrequests loan Products URL.", "response": "def getproductsurl(idproduct, *args, **kwargs):\n    \"\"\"Request loan Products URL.\n\n    If idproduct is set, you'll get a response adequate for a MambuProduct object.\n    If not set, you'll get a response adequate for a MambuProducts object.\n    See mambuproduct module and pydoc for further information.\n\n    No current implemented filter parameters.\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    productidparam = \"\" if idproduct == \"\" else \"/\"+idproduct\n    url = getmambuurl(*args,**kwargs) + \"loanproducts\" + productidparam\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests Tasks URL. dummyId is used because MambuStruct always requires an Id from an entity, but the Mambu API doesn't requires it for Tasks, because of that dummyId defaults to '', but in practice it is never used (if someone sends dummyId='someId' nothing happens). The fact of forcing to send an entid is a technical debt that should be payed. Currently implemented filter parameters: * username * clientId * groupId * status * limit * offset Mambu REST API defaults to open when status not provided. Here we are just making that explicit always defaulting status to 'OPEN' See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def gettasksurl(dummyId='', *args, **kwargs):\n    \"\"\"Request Tasks URL.\n\n    dummyId is used because MambuStruct always requires an Id from an\n    entity, but the Mambu API doesn't requires it for Tasks, because of\n    that dummyId defaults to '', but in practice it is never used (if\n    someone sends dummyId='someId' nothing happens). The fact of forcing\n    to send an entid is a technical debt that should be payed.\n\n    Currently implemented filter parameters:\n    * username\n    * clientId\n    * groupId\n    * status\n    * limit\n    * offset\n\n    Mambu REST API defaults to open when status not provided. Here we\n    are just making that explicit always defaulting status to 'OPEN'\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    getparams = []\n    if kwargs:\n        try:\n            getparams.append(\"username=%s\" % kwargs[\"username\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"clientid=%s\" % kwargs[\"clientId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"groupid=%s\" % kwargs[\"groupId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"status=%s\" % kwargs[\"status\"])\n        except Exception as ex:\n            getparams.append(\"status=OPEN\")\n\n        try:\n            getparams.append(\"offset=%s\" % kwargs[\"offset\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n\n    url = getmambuurl(*args,**kwargs) + \"tasks\" + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrequest Activities URL. dummyId is used because MambuStruct always requires an Id from an entity, but the Mambu API doesn't requires it for Activities, because of that dummyId defaults to '', but in practice it is never used (if someone sends dummyId='someId' nothing happens). The fact of forcing to send an entid is a technical debt that should be payed. Currently implemented filter parameters: * from * to * branchID * clientID * centreID * userID * loanAccountID * groupID * limit See Mambu official developer documentation for further details, and info on parameters that may be implemented here in the future.", "response": "def getactivitiesurl(dummyId='', *args, **kwargs):\n    \"\"\"Request Activities URL.\n\n    dummyId is used because MambuStruct always requires an Id from an\n    entity, but the Mambu API doesn't requires it for Activities,\n    because of that dummyId defaults to '', but in practice it is never\n    used (if someone sends dummyId='someId' nothing happens). The fact\n    of forcing to send an entid is a technical debt that should be\n    payed.\n\n    Currently implemented filter parameters:\n    * from\n    * to\n    * branchID\n    * clientID\n    * centreID\n    * userID\n    * loanAccountID\n    * groupID\n    * limit\n\n    See Mambu official developer documentation for further details, and\n    info on parameters that may be implemented here in the future.\n    \"\"\"\n    from datetime import datetime\n\n    getparams = []\n    if kwargs:\n        try:\n            getparams.append(\"from=%s\" % kwargs[\"fromDate\"])\n        except Exception as ex:\n            getparams.append(\"from=%s\" % '1900-01-01')\n\n        try:\n            getparams.append(\"to=%s\" % kwargs[\"toDate\"])\n        except Exception as ex:\n            hoy = datetime.now().strftime('%Y-%m-%d')\n            getparams.append(\"to=%s\" % hoy)\n\n        try:\n            getparams.append(\"branchID=%s\" % kwargs[\"branchId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"clientID=%s\" % kwargs[\"clientId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"centreID=%s\" % kwargs[\"centreId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"userID=%s\" % kwargs[\"userId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"loanAccountID=%s\" % kwargs[\"loanAccountId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"groupID=%s\" % kwargs[\"groupId\"])\n        except Exception as ex:\n            pass\n\n        try:\n            getparams.append(\"limit=%s\" % kwargs[\"limit\"])\n        except Exception as ex:\n            pass\n\n    url = getmambuurl(*args,**kwargs) + \"activities\" + ( \"\" if len(getparams) == 0 else \"?\" + \"&\".join(getparams) )\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting Roles URL. If idrole is set, you'll get a response adequate for a MambuRole object. If not set, you'll get a response adequate for a MambuRoles object too. See mamburoles module and pydoc for further information. See Mambu official developer documentation for further details.", "response": "def getrolesurl(idrole='', *args, **kwargs):\n    \"\"\"Request Roles URL.\n\n    If idrole is set, you'll get a response adequate for a MambuRole\n    object.  If not set, you'll get a response adequate for a MambuRoles\n    object too.  See mamburoles module and pydoc for further\n    information.\n\n    See Mambu official developer documentation for further details.\n    \"\"\"\n    url = getmambuurl(*args,**kwargs) + \"userroles\" + ((\"/\" + idrole) if idrole else \"\")\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strip_consecutive_repeated_char(s, ch):\n    sdest = \"\"\n    for i,c in enumerate(s):\n        if i != 0 and s[i] == ch and s[i] == s[i-1]:\n            continue\n        sdest += s[i]\n    return sdest", "response": "Strip characters in a string which are consecutively repeated."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges an IRI to an URI.", "response": "def iriToUri(iri):\n    \"\"\"Change an IRI (internationalized R) to an URI.\n\n    Used at MambuStruct.connect() method for any requests done to Mambu.\n\n    Perfect example of unicode getting in the way.\n\n    Illustrative (I hope) example: I have Mambu usernames with special\n    chars in them. When retrieving them and then trying to build a\n    MambuUser object with them, I get a BIG problem because of the\n    unicode chars there. Using this I solved the problem.\n    \"\"\"\n    def urlEncodeNonAscii(b):\n        \"\"\"Encode Non ASCII chars to URL-friendly chars.\n\n        Sometimes unicode gets in the way. A shame, I know. And perhaps the\n        biggest shame is not me correctly handling it.\n        \"\"\"\n        import re\n        return re.sub('[\\x80-\\xFF]', lambda c: '%%%02x' % ord(c.group(0)), b)\n\n    parts = urlparse.urlparse(iri)\n    if sys.version_info < (3, 0):\n        # python2\n        partes = []\n        for parti, part in enumerate(parts):\n            try:\n                if parti != 1:\n                    partes.append(urlEncodeNonAscii(part.encode('utf-8')))\n                else:\n                    partes.append(part.encode('idna'))\n            except UnicodeDecodeError as ue:\n                partes.append(urlEncodeNonAscii(part.decode('latin')))\n            except Exception as e:\n                raise e\n        return urlparse.urlunparse(partes)\n    else:\n        # python3\n        uri = [part.decode('utf8') for parti, part in enumerate(parts.encode('utf8'))]\n        return urlparse.urlunparse(uri)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode every value of a dict to UTF - 8.", "response": "def encoded_dict(in_dict):\n    \"\"\"Encode every value of a dict to UTF-8.\n\n    Useful for POSTing requests on the 'data' parameter of urlencode.\n    \"\"\"\n    out_dict = {}\n    for k, v in in_dict.items():\n        if isinstance(v, unicode):\n            if sys.version_info < (3, 0):\n                v = v.encode('utf8')\n        elif isinstance(v, str):\n            # Must be encoded in UTF-8\n            if sys.version_info < (3, 0):\n                v.decode('utf8')\n        out_dict[k] = v\n    return out_dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef backup_db(callback, bool_func, output_fname, *args, **kwargs):\n    from datetime import datetime\n\n    try:\n        verbose = kwargs['verbose']\n    except KeyError:\n        verbose = False\n    try:\n        retries = kwargs['retries']\n    except KeyError:\n        retries = -1\n    try:\n        force_download_latest = bool(kwargs['force_download_latest'])\n    except KeyError:\n        force_download_latest = False\n\n    if verbose:\n        log = open('/tmp/log_mambu_backup','a')\n        log.write(datetime.now().strftime('%Y-%m-%d %H:%M:%S') + \" - Mambu DB Backup\\n\")\n        log.flush()\n\n    user = kwargs.pop('user', apiuser)\n    pwd = kwargs.pop('pwd', apipwd)\n    data = {'callback' : callback}\n    try:\n        posturl = iriToUri(getmambuurl(*args, **kwargs) + \"database/backup\")\n        if verbose:\n            log.write(\"open url: \"+posturl+\"\\n\")\n            log.flush()\n        resp = requests.post(posturl, data=data, headers={'content-type': 'application/json'}, auth=(apiuser, apipwd))\n    except Exception as ex:\n        mess = \"Error requesting backup: %s\" % repr(ex)\n        if verbose:\n            log.write(mess + \"\\n\")\n            log.close()\n        raise MambuError(mess)\n\n    if resp.status_code != 200:\n        mess = \"Error posting request for backup: %s\" % resp.content\n        if verbose:\n            log.write(mess + \"\\n\")\n            log.close()\n        raise MambuCommError(mess)\n\n    data['latest'] = True\n    while retries and not bool_func():\n        if verbose:\n            log.write(\"waiting...\\n\")\n            log.flush()\n        sleep(10)\n        retries -= 1\n        if retries < 0: retries = -1\n    if not retries:\n        mess = \"Tired of waiting, giving up...\"\n        if verbose:\n            log.write(mess + \"\\n\")\n            log.flush()\n        if not force_download_latest:\n            if verbose:\n                log.close()\n            raise MambuError(mess)\n        else:\n            data['latest'] = False\n    sleep(30)\n\n    geturl = iriToUri(getmambuurl(*args, **kwargs) + \"database/backup/LATEST\")\n    if verbose:\n        log.write(\"open url: \"+geturl+\"\\n\")\n        log.flush()\n    resp = requests.get(geturl, auth=(apiuser, apipwd))\n\n    if resp.status_code != 200:\n        mess = \"Error getting database backup: %s\" % resp.content\n        if verbose:\n            log.write(mess + \"\\n\")\n            log.close()\n        raise MambuCommError(mess)\n\n    if verbose:\n        log.write(\"saving...\\n\")\n        log.flush()\n    with open(output_fname, \"w\") as fw:\n        fw.write(resp.content)\n\n    if verbose:\n        log.write(\"DONE!\\n\")\n        log.close()\n\n    return data", "response": "Backup Mambu Database via REST API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrap(self, sock):\n        try:\n            s = ssl.wrap_socket(sock, do_handshake_on_connect=True,\n                    server_side=True, certfile=self.certificate,\n                    keyfile=self.private_key, ssl_version=ssl.PROTOCOL_SSLv23)\n        except ssl.SSLError, e:\n            if e.errno == ssl.SSL_ERROR_EOF:\n                # This is almost certainly due to the cherrypy engine\n                # 'pinging' the socket to assert it's connectable;\n                # the 'ping' isn't SSL.\n                return None, {}\n            elif e.errno == ssl.SSL_ERROR_SSL:\n                if e.args[1].endswith('http request'):\n                    # The client is speaking HTTP to an HTTPS server.\n                    raise wsgiserver.NoSSLError\n            raise\n        return s, self.get_environ(s)", "response": "Wrap and return the given socket plus WSGI environ entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_environ(self, sock):\n        cipher = sock.cipher()\n        ssl_environ = {\n            \"wsgi.url_scheme\": \"https\",\n            \"HTTPS\": \"on\",\n            'SSL_PROTOCOL': cipher[1],\n            'SSL_CIPHER': cipher[0]\n##            SSL_VERSION_INTERFACE \tstring \tThe mod_ssl program version\n##            SSL_VERSION_LIBRARY \tstring \tThe OpenSSL program version\n            }\n        return ssl_environ", "response": "Create WSGI environ entries to be merged into each request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding memoization for methods on a specific instance. Results are cached for given parameter list. See also: http://en.wikipedia.org/wiki/Memoization N.B. The cache object gets added to the instance instead of the global scope. Therefore cached results are restricted to that instance. The cache dictionary gets a name containing the name of the decorated function to avoid clashes. Example: class MyClass(object): @memoize def foo(self, a, b): return self._do_calculation(a, b) HINT: - The decorator does not work with keyword arguments.", "response": "def memoize(func):\n    \"\"\"\n    Provides memoization for methods on a specific instance.\n    Results are cached for given parameter list.\n\n    See also: http://en.wikipedia.org/wiki/Memoization\n\n    N.B. The cache object gets added to the instance instead of the global scope.\n    Therefore cached results are restricted to that instance.\n    The cache dictionary gets a name containing the name of the decorated function to\n    avoid clashes.\n\n    Example:\n\n        class MyClass(object):\n            @memoize\n            def foo(self, a, b):\n                return self._do_calculation(a, b)\n\n    HINT: - The decorator does not work with keyword arguments.\n    \"\"\"\n\n    cache_name = '__CACHED_{}'.format(func.__name__)\n\n    def wrapper(self, *args):\n        cache = getattr(self, cache_name, None)\n        if cache is None:\n            cache = {}\n            setattr(self, cache_name, cache)\n        if args not in cache:\n            cache[args] = func(self, *args)\n        return cache[args]\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nidentifying pathways overrepresented in a constructed feature according to a user-specified criterion (see `gene_signature_definitions` in the parameters list below) for identifying the feature's gene signature. Donato et al.'s (2013) algorithm for pathway crosstalk correction (removes gene overlap between pathway definitions) is applied to the pathway definitions before overrepresentation analysis. Here, we refer to it as *overlap-correction*. Parameters ----------- feature_weight_vector : pandas.Series(float), shape = n A vector containing gene weights pathway_definitions : dict(str -> set(str)) A pathway (key) is defined by a set of genes (value). gene_signature_definition : functools.partial callable, returns (set(), set()) Accepts the `feature_weight_vector` as input. Provide a function to distinguish positive and/or negative gene signatures. Both a positive & a negative signature may be appropriate if the feature's gene weight distribution spans positive and negative values. If this is not the case, specify a single gene signature by returning one of the sides as an empty set. alpha : float (default=0.05) Significance level for pathway enrichment. correct_all_genes : bool (default=True) The overlap correction procedure is applied independently to both the gene signature (union of positive and negative signature when applicable) _and_ the genes outside of the signature (termed *remaining* genes). If not `correct_all_genes`, overlap correction is not applied to the set of remaining genes. metadata : bool (default=False) Gather information to store in a MongoDB-backed Flask web application. Users can interact with the PathCORE-T-produced network and analyze the genes underlying a pair of pathways linked in the network. Returns ----------- tup([pandas.DataFrame|None], dict()) tup[0] : pandas.DataFrame: dataframe of significant pathways | None if the gene signature does not contain any genes in the pathway definitions tup[1] : if `metadata`: {\"positive signature\": <set() positive gene signature>, \"negative signature\": <set() negative gene signature>, \"pathway definitions\": <dict(str -> set()) overlap-corrected definitions--only signature genes>} else: {}", "response": "def pathway_enrichment_with_overlap_correction(feature_weight_vector,\n                                               pathway_definitions,\n                                               gene_signature_definition,\n                                               alpha=0.05,\n                                               correct_all_genes=True,\n                                               metadata=False):\n    \"\"\"Identify pathways overrepresented in a constructed feature\n    according to a user-specified criterion (see `gene_signature_definitions`\n    in the parameters list below) for identifying the feature's gene\n    signature. Donato et al.'s (2013) algorithm for pathway crosstalk\n    correction (removes gene overlap between pathway definitions) is applied to\n    the pathway definitions before overrepresentation analysis.\n    Here, we refer to it as *overlap-correction*.\n\n    Parameters\n    -----------\n    feature_weight_vector : pandas.Series(float), shape = n\n      A vector containing gene weights\n    pathway_definitions : dict(str -> set(str))\n      A pathway (key) is defined by a set of genes (value).\n    gene_signature_definition : functools.partial callable,\n                                returns (set(), set())\n      Accepts the `feature_weight_vector` as input. Provide a function to\n      distinguish positive and/or negative gene signatures.\n      Both a positive & a negative signature may be appropriate if the\n      feature's gene weight distribution spans positive and negative values.\n      If this is not the case, specify a single gene signature by returning\n      one of the sides as an empty set.\n    alpha : float (default=0.05)\n      Significance level for pathway enrichment.\n    correct_all_genes : bool (default=True)\n      The overlap correction procedure is applied independently to both\n      the gene signature (union of positive and negative signature when\n      applicable) _and_ the genes outside of the signature (termed\n      *remaining* genes).\n      If not `correct_all_genes`, overlap correction is not applied to\n      the set of remaining genes.\n    metadata : bool (default=False)\n      Gather information to store in a MongoDB-backed Flask web application.\n      Users can interact with the PathCORE-T-produced network and analyze the\n      genes underlying a pair of pathways linked in the network.\n\n    Returns\n    -----------\n    tup([pandas.DataFrame|None], dict())\n    tup[0] : pandas.DataFrame: dataframe of significant pathways\n           | None if the gene signature does not contain any genes in the\n                  pathway definitions\n    tup[1] : if `metadata`:\n             {\"positive signature\": <set() positive gene signature>,\n              \"negative signature\": <set() negative gene signature>,\n              \"pathway definitions\": <dict(str -> set())\n                overlap-corrected definitions--only signature genes>}\n             else: {}\n    \"\"\"\n    genes_in_pathway_definitions = set.union(*pathway_definitions.values())\n    positive_gene_signature, negative_gene_signature = \\\n        gene_signature_definition(feature_weight_vector)\n    gene_signature = ((positive_gene_signature | negative_gene_signature) &\n                      genes_in_pathway_definitions)\n    if not gene_signature:\n        return (None, {})\n\n    additional_information = {}\n    n_genes = len(feature_weight_vector)\n\n    if metadata:\n        additional_information[\"positive_signature\"] = (\n          positive_gene_signature & gene_signature)\n        additional_information[\"negative_signature\"] = (\n          negative_gene_signature & gene_signature)\n    corrected_pathway_definitions = crosstalk_correction(\n        pathway_definitions,\n        gene_set=gene_signature,\n        all_genes=correct_all_genes)\n\n    if metadata:\n        collect_signature_pathway_definitions = {}\n        for pathway, (signature_defn, remaining_defn) in \\\n                corrected_pathway_definitions.items():\n            collect_signature_pathway_definitions[pathway] = signature_defn\n        additional_information[\"pathway_definitions\"] = \\\n            collect_signature_pathway_definitions\n\n    pathway_positive_series = single_side_pathway_enrichment(\n        corrected_pathway_definitions, positive_gene_signature, n_genes)\n    pathway_negative_series = single_side_pathway_enrichment(\n        corrected_pathway_definitions, negative_gene_signature, n_genes)\n\n    pvalue_information = pathway_positive_series.append(\n        pathway_negative_series)\n    side_information = _pathway_side_information(\n        pathway_positive_series, pathway_negative_series,\n        pvalue_information.index)\n    significant_pathways = _significant_pathways_dataframe(\n        pvalue_information, side_information, alpha)\n    return significant_pathways, additional_information"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the pandas. Series containing the side labels that correspond to each pathway based on the user - specified gene signature definition.", "response": "def _pathway_side_information(pathway_positive_series,\n                              pathway_negative_series,\n                              index):\n    \"\"\"Create the pandas.Series containing the side labels that correspond\n    to each pathway, based on the user-specified gene signature definition.\n    \"\"\"\n    positive_series_label = pd.Series([\"pos\"] * len(pathway_positive_series))\n    negative_series_label = pd.Series([\"neg\"] * len(pathway_negative_series))\n    side_information = positive_series_label.append(\n        negative_series_label)\n    side_information.index = index\n    side_information.name = \"side\"\n    return side_information"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _significant_pathways_dataframe(pvalue_information,\n                                    side_information,\n                                    alpha):\n    \"\"\"Create the significant pathways pandas.DataFrame.\n    Given the p-values corresponding to each pathway in a feature,\n    apply the FDR correction for multiple testing and remove those that\n    do not have a q-value of less than `alpha`.\n    \"\"\"\n    significant_pathways = pd.concat(\n        [pvalue_information, side_information], axis=1)\n    # fdr_bh: false discovery rate, Benjamini & Hochberg (1995, 2000)\n    below_alpha, qvalues, _, _ = multipletests(\n        significant_pathways[\"p-value\"], alpha=alpha, method=\"fdr_bh\")\n    below_alpha = pd.Series(\n        below_alpha, index=pvalue_information.index, name=\"pass\")\n    qvalues = pd.Series(\n        qvalues, index=pvalue_information.index, name=\"q-value\")\n    significant_pathways = pd.concat(\n        [significant_pathways, below_alpha, qvalues], axis=1)\n    significant_pathways = significant_pathways[significant_pathways[\"pass\"]]\n    significant_pathways.drop(\"pass\", axis=1, inplace=True)\n    significant_pathways.loc[:, \"pathway\"] = significant_pathways.index\n    return significant_pathways", "response": "Create the significant pathways pandas. DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef single_side_pathway_enrichment(pathway_definitions,\n                                   gene_signature,\n                                   n_genes):\n    \"\"\"Identify overrepresented pathways using the Fisher's exact test for\n    significance on a given pathway definition and gene signature.\n    (FDR correction for multiple testing is applied in\n    `_significant_pathways_dataframe`).\n\n    Parameters\n    -----------\n    pathway_definitions : dict(str -> set(str))\n      Pathway definitions, *post*-overlap-correction if this function\n      is called from `pathway_enrichment_with_overlap_correction`.\n      A pathway (key) is defined by a set of genes (value).\n    gene_signature : set(str)\n      The set of genes we consider to be enriched in a feature.\n    n_genes : int\n      The total number of genes for which we have assigned weights in the\n      features of an unsupervised model.\n\n    Returns\n    -----------\n    pandas.Series, for each pathway, the p-value from applying the Fisher's\n      exact test.\n    \"\"\"\n    if not gene_signature:\n        return pd.Series(name=\"p-value\")\n    pvalues_list = []\n    for pathway, definition in pathway_definitions.items():\n        if isinstance(definition, tuple):\n            definition = set.union(*definition)\n\n        both_definition_and_signature = len(definition & gene_signature)\n        in_definition_not_signature = (len(definition) -\n                                       both_definition_and_signature)\n        in_signature_not_definition = (len(gene_signature) -\n                                       both_definition_and_signature)\n        neither_definition_nor_signature = (n_genes -\n                                            both_definition_and_signature -\n                                            in_definition_not_signature -\n                                            in_signature_not_definition)\n        contingency_table = np.array(\n            [[both_definition_and_signature, in_signature_not_definition],\n             [in_definition_not_signature, neither_definition_nor_signature]])\n        try:\n            _, pvalue = stats.fisher_exact(\n                contingency_table, alternative=\"greater\")\n            pvalues_list.append(pvalue)\n        # FPE can occur when `neither_definition_nor_signature` is very\n        # large and `both_definition_and_signature` is very small (near zero)\n        except FloatingPointError:\n            pvalues_list.append(1.0)\n    pvalues_series = pd.Series(\n        pvalues_list, index=pathway_definitions.keys(), name=\"p-value\")\n    return pvalues_series", "response": "Identify overrepresented pathways using the Fisher s exact test for a given pathway definition and gene signature."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pathway_enrichment_no_overlap_correction(feature_weight_vector,\n                                             pathway_definitions,\n                                             gene_signature_definition,\n                                             alpha=0.05,\n                                             metadata=False):\n    \"\"\"Identify pathways overrepresented in a constructed feature\n    according to a user-specified criterion (see `gene_signature_definitions`\n    in the parameters list below) for identifying the feature's gene\n    signature. Overlap-correction is not applied to the pathway definitions.\n\n    Parameters\n    -----------\n    feature_weight_vector : pandas.Series(float), shape = n\n      A vector containing gene weights\n    pathway_definitions : dict(str -> set(str))\n      A pathway (key) is defined by a set of genes (value).\n    gene_signature_definition : functools.partial callable,\n                                returns (set(), set())\n      Accepts the `feature_weight_vector` as input. Provide a function to\n      distinguish positive and/or negative gene signatures.\n      Both a positive & negative signature may be appropriate if the feature's\n      gene weight distribution spans positive and negative values. If this\n      is not the case, a user can just specify a single gene signature by\n      returning one or the other as an empty set.\n    alpha : float (default=0.05)\n      Significance level for pathway enrichment.\n    metadata : bool (default=False)\n      Return information about the gene signature(s)\n\n    Returns\n    -----------\n    tup([pandas.DataFrame|None], dict())\n    tup[0] : pandas.DataFrame: dataframe of significant pathways\n           | None if the gene signature does not contain any genes in the\n                  pathway definitions\n    tup[1] : if `metadata`:\n             {\"positive signature\": <set() positive gene signature>,\n              \"negative signature\": <set() negative gene signature>,\n              \"pathway definitions\": <dict(str -> set()) the pathway genes\n               that are in the gene signature(s)>}\n             else: {}\n    \"\"\"\n    genes_in_pathway_definitions = set.union(*pathway_definitions.values())\n\n    positive_gene_signature, negative_gene_signature = \\\n        gene_signature_definition(feature_weight_vector)\n    gene_signature = ((positive_gene_signature | negative_gene_signature) &\n                      genes_in_pathway_definitions)\n\n    if not gene_signature:\n        return (None, {})\n\n    additional_information = {}\n    n_genes = len(feature_weight_vector)\n\n    if metadata:\n        additional_information[\"positive_signature\"] = positive_gene_signature\n        additional_information[\"negative_signature\"] = negative_gene_signature\n\n        collect_signature_pathway_definitions = {}\n        for pathway, definition in pathway_definitions.items():\n            signature_definition = gene_signature & definition\n            if signature_definition:\n                collect_signature_pathway_definitions[pathway] = (\n                    signature_definition)\n        additional_information[\"pathway_definitions\"] = (\n            collect_signature_pathway_definitions)\n\n    pathway_positive_series = single_side_pathway_enrichment(\n        pathway_definitions, positive_gene_signature, n_genes)\n    pathway_negative_series = single_side_pathway_enrichment(\n        pathway_definitions, negative_gene_signature, n_genes)\n    pvalue_information = pathway_positive_series.append(\n        pathway_negative_series)\n    side_information = _pathway_side_information(\n        pathway_positive_series, pathway_negative_series,\n        pvalue_information.index)\n    significant_pathways = _significant_pathways_dataframe(\n        pvalue_information, side_information, alpha)\n    return significant_pathways, additional_information", "response": "This function is used to determine if a pathway is overrepresented in a constructed feature pathway."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def flush(self, request: Request, stacks: List[Stack]):\n\n        ns = await self.expand_stacks(request, stacks)\n        ns = self.split_stacks(ns)\n        ns = self.clean_stacks(ns)\n\n        await self.next(request, [Stack(x) for x in ns])", "response": "Flushes the given list of stacks."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split_stacks(self, stacks: List[List[BaseLayer]]) \\\n            -> List[List[BaseLayer]]:\n        \"\"\"\n        First step of the stacks cleanup process. We consider that if inside\n        a stack there's a text layer showing up then it's the beginning of a\n        new stack and split upon that.\n        \"\"\"\n\n        ns: List[List[BaseLayer]] = []\n\n        for stack in stacks:\n            cur: List[BaseLayer] = []\n\n            for layer in stack:\n                if cur and isinstance(layer, lyr.RawText):\n                    ns.append(cur)\n                    cur = []\n\n                cur.append(layer)\n\n            if cur:\n                ns.append(cur)\n\n        return ns", "response": "This function splits the stacks into individual stacks."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclean up stacks to ensure that the stack is not sleep or sleep.", "response": "def clean_stacks(self, stacks: List[List[BaseLayer]]) \\\n            -> List[List[BaseLayer]]:\n        \"\"\"\n        Two cases: if a stack finishes by a sleep then let's keep it (it means\n        that there was nothing after the text). However if the stack finishes\n        with something else (like a quick reply) then we don't risk an\n        is preserved.\n        \"\"\"\n\n        ns: List[List[BaseLayer]] = []\n\n        for stack in stacks:\n            if isinstance(stack[-1], lyr.Sleep):\n                ns.extend([x] for x in stack)\n            else:\n                ns.append([x for x in stack if not isinstance(x, lyr.Sleep)])\n\n        if not ns:\n            return ns\n\n        last = ns[-1]\n        if len(last) == 1 and isinstance(last[0], lyr.Sleep):\n            return ns[:-1]\n        else:\n            return ns"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def expand(self, request: Request, layer: BaseLayer):\n\n        if isinstance(layer, lyr.RawText):\n            t = self.reading_time(layer.text)\n            yield layer\n            yield lyr.Sleep(t)\n\n        elif isinstance(layer, lyr.MultiText):\n            texts = await render(layer.text, request, True)\n\n            for text in texts:\n                t = self.reading_time(text)\n                yield lyr.RawText(text)\n                yield lyr.Sleep(t)\n\n        elif isinstance(layer, lyr.Text):\n            text = await render(layer.text, request)\n            t = self.reading_time(text)\n            yield lyr.RawText(text)\n            yield lyr.Sleep(t)\n\n        else:\n            yield layer", "response": "Expand a layer into a list of layers including the pauses."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the time that the user will need to read a bubble from the given text.", "response": "def reading_time(self, text: TextT):\n        \"\"\"\n        Computes the time in seconds that the user will need to read a bubble\n        containing the text passed as parameter.\n        \"\"\"\n\n        wc = re.findall(r'\\w+', text)\n        period = 60.0 / settings.USERS_READING_SPEED\n        return float(len(wc)) * period + settings.USERS_READING_BUBBLE_START"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def flush(self, request: Request, stacks: List[Stack]):\n\n        ns: List[Stack] = []\n\n        for stack in stacks:\n            ns.extend(self.typify(stack))\n\n        if len(ns) > 1 and ns[-1] == Stack([lyr.Typing()]):\n            ns[-1].get_layer(lyr.Typing).active = False\n\n        await self.next(request, ns)", "response": "Flushes the typing stack after each stack."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting typing right when the message is received.", "response": "async def pre_handle(self, request: Request, responder: 'Responder'):\n        \"\"\"\n        Start typing right when the message is received.\n        \"\"\"\n\n        responder.send([lyr.Typing()])\n        await responder.flush(request)\n        responder.clear()\n\n        await self.next(request, responder)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef typify(self, stack: Stack) -> List[Stack]:\n\n        if len(stack.layers) == 1 and isinstance(stack.layers[0], lyr.Typing):\n            return [stack]\n\n        return [stack, Stack([lyr.Typing()])]", "response": "Adds a typing stack after the given stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _get_full_user(self) -> Dict:\n\n        if 'language_code' in self._user:\n            return self._user\n\n        async with self._lock:\n            if self._full_user is None:\n                cm = await self._telegram.call(\n                    'getChatMember',\n                    user_id=self._user['id'],\n                    chat_id=self._chat['id'],\n                )\n                self._full_user = cm['result']['user']\n\n            return self._full_user", "response": "Get the full User object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get_friendly_name(self) -> Text:\n\n        if 'first_name' not in self._user:\n            user = await self._get_full_user()\n        else:\n            user = self._user\n\n        return user.get('first_name')", "response": "Get the first name of the user as friendly name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the chat object from the update.", "response": "def _get_chat(self) -> Dict:\n        \"\"\"\n        As Telegram changes where the chat object is located in the response,\n        this method tries to be smart about finding it in the right place.\n        \"\"\"\n\n        if 'callback_query' in self._update:\n            query = self._update['callback_query']\n            if 'message' in query:\n                return query['message']['chat']\n            else:\n                return {'id': query['chat_instance']}\n        elif 'inline_query' in self._update:\n            return patch_dict(\n                self._update['inline_query']['from'],\n                is_inline_query=True,\n            )\n        elif 'message' in self._update:\n            return self._update['message']['chat']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_user(self) -> Dict:\n\n        if 'callback_query' in self._update:\n            return self._update['callback_query']['from']\n        elif 'inline_query' in self._update:\n            return self._update['inline_query']['from']\n        elif 'message' in self._update:\n            return self._update['message']['from']", "response": "Get the user related to the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, stack: Layers):\n\n        if not isinstance(stack, Stack):\n            stack = Stack(stack)\n\n        if 'callback_query' in self._update and stack.has_layer(Update):\n            layer = stack.get_layer(Update)\n\n            try:\n                msg = self._update['callback_query']['message']\n            except KeyError:\n                layer.inline_message_id = \\\n                    self._update['callback_query']['inline_message_id']\n            else:\n                layer.chat_id = msg['chat']['id']\n                layer.message_id = msg['message_id']\n\n        if stack.has_layer(AnswerCallbackQuery):\n            self._acq = stack.get_layer(AnswerCallbackQuery)\n            stack = Stack([\n                l for l in stack.layers\n                if not isinstance(l, AnswerCallbackQuery)\n            ])\n\n        if stack.has_layer(Reply):\n            layer = stack.get_layer(Reply)\n\n            if 'message' in self._update:\n                layer.message = self._update['message']\n            elif 'callback_query' in self._update:\n                layer.message = self._update['callback_query']['message']\n\n        if 'inline_query' in self._update \\\n                and stack.has_layer(AnswerInlineQuery):\n            a = stack.get_layer(AnswerInlineQuery)\n            a.inline_query_id = self._update['inline_query']['id']\n\n        if stack.layers:\n            return super(TelegramResponder, self).send(stack)", "response": "Send a stack to the Telegram."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def flush(self, request: BernardRequest):\n\n        if self._acq and 'callback_query' in self._update:\n            try:\n                cbq_id = self._update['callback_query']['id']\n            except KeyError:\n                pass\n            else:\n                await self.platform.call(\n                    'answerCallbackQuery',\n                    **(await self._acq.serialize(cbq_id))\n                )\n\n        return await super(TelegramResponder, self).flush(request)", "response": "If there's a AnswerCallbackQuery scheduled for reply, place the call\n        before actually flushing the buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck that the configuration is correct.", "response": "async def self_check(cls):\n        \"\"\"\n        Check that the configuration is correct\n\n        - Presence of \"token\" in the settings\n        - Presence of \"BERNARD_BASE_URL\" in the global configuration\n        \"\"\"\n\n        # noinspection PyTypeChecker\n        async for check in super(Telegram, cls).self_check():\n            yield check\n\n        s = cls.settings()\n\n        try:\n            assert isinstance(s['token'], str)\n        except (KeyError, TypeError, AssertionError):\n            yield HealthCheckFail(\n                '00005',\n                'Missing \"token\" for Telegram platform. You can obtain one by'\n                'registering your bot in Telegram.',\n            )\n\n        if not hasattr(settings, 'BERNARD_BASE_URL'):\n            yield HealthCheckFail(\n                '00005',\n                '\"BERNARD_BASE_URL\" cannot be found in the configuration. The'\n                'Telegram platform needs it because it uses it to '\n                'automatically register its hook.'\n            )\n\n        if not hasattr(settings, 'WEBVIEW_SECRET_KEY'):\n            yield HealthCheckFail(\n                '00005',\n                '\"WEBVIEW_SECRET_KEY\" cannot be found in the configuration. '\n                'It is required in order to be able to create secure postback '\n                'URLs.'\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def receive_updates(self, request: Request):\n\n        body = await request.read()\n\n        try:\n            content = ujson.loads(body)\n        except ValueError:\n            return json_response({\n                'error': True,\n                'message': 'Cannot decode body',\n            }, status=400)\n\n        logger.debug('Received from Telegram: %s', content)\n\n        message = TelegramMessage(content, self)\n        responder = TelegramResponder(content, self)\n        await self._notify(message, responder)\n\n        return json_response({\n            'error': False,\n        })", "response": "Handle updates from Telegram"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a Telegram URL for this bot.", "response": "def make_url(self, method):\n        \"\"\"\n        Generate a Telegram URL for this bot.\n        \"\"\"\n\n        token = self.settings()['token']\n\n        return TELEGRAM_URL.format(\n            token=quote(token),\n            method=quote(method),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def call(self,\n                   method: Text,\n                   _ignore: Set[Text] = None,\n                   **params: Any):\n        \"\"\"\n        Call a telegram method\n\n        :param _ignore: List of reasons to ignore\n        :param method: Name of the method to call\n        :param params: Dictionary of the parameters to send\n\n        :return: Returns the API response\n        \"\"\"\n\n        logger.debug('Calling Telegram %s(%s)', method, params)\n\n        url = self.make_url(method)\n\n        headers = {\n            'content-type': 'application/json',\n        }\n\n        post = self.session.post(\n            url,\n            data=ujson.dumps(params),\n            headers=headers,\n        )\n\n        async with post as r:\n            out = await self._handle_telegram_response(r, _ignore)\n            logger.debug('Telegram replied: %s', out)\n            return out", "response": "Call a Telegram method and return the API response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _handle_telegram_response(self, response, ignore=None):\n\n        if ignore is None:\n            ignore = set()\n\n        ok = response.status == 200\n\n        try:\n            data = await response.json()\n\n            if not ok:\n                desc = data['description']\n\n                if desc in ignore:\n                    return\n\n                raise PlatformOperationError(\n                    'Telegram replied with an error: {}'\n                    .format(desc)\n                )\n        except (ValueError, TypeError, KeyError):\n            raise PlatformOperationError('An unknown Telegram error occurred')\n\n        return data", "response": "Parse a Telegram response from Telegram and return a DataONE object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the path to the hook URL", "response": "def make_hook_path(self):\n        \"\"\"\n        Compute the path to the hook URL\n        \"\"\"\n\n        token = self.settings()['token']\n        h = sha256()\n        h.update(token.encode())\n        key = str(h.hexdigest())\n        return f'/hooks/telegram/{key}'"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def _deferred_init(self):\n\n        hook_path = self.make_hook_path()\n        url = urljoin(settings.BERNARD_BASE_URL, hook_path)\n        await self.call('setWebhook', url=url)\n        logger.info('Setting Telegram webhook to \"%s\"', url)", "response": "Register the web hook onto which Telegram should send its messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends text to the user.", "response": "async def _send_text(self,\n                         request: Request,\n                         stack: Stack,\n                         parse_mode: Optional[Text] = None):\n        \"\"\"\n        Base function for sending text\n        \"\"\"\n\n        parts = []\n        chat_id = request.message.get_chat_id()\n\n        for layer in stack.layers:\n            if isinstance(layer, (lyr.Text, lyr.RawText, lyr.Markdown)):\n                text = await render(layer.text, request)\n                parts.append(text)\n\n        for part in parts[:-1]:\n            await self.call(\n                'sendMessage',\n                text=part,\n                chat_id=chat_id,\n            )\n\n        msg = {\n            'text': parts[-1],\n            'chat_id': chat_id,\n        }\n\n        if parse_mode is not None:\n            msg['parse_mode'] = parse_mode\n\n        await set_reply_markup(msg, request, stack)\n\n        if stack.has_layer(Reply):\n            reply = stack.get_layer(Reply)\n            if reply.message:\n                msg['reply_to_message_id'] = reply.message['message_id']\n\n        if stack.has_layer(Update):\n            update = stack.get_layer(Update)\n\n            if update.inline_message_id:\n                msg['inline_message_id'] = update.inline_message_id\n                del msg['chat_id']\n            else:\n                msg['message_id'] = update.message_id\n\n            await self.call(\n                'editMessageText',\n                {'Bad Request: message is not modified'},\n                **msg\n            )\n        else:\n            await self.call('sendMessage', **msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _send_plain_text(self, request: Request, stack: Stack):\n\n        await self._send_text(request, stack, None)", "response": "Sends plain text using _send_text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _send_markdown(self, request: Request, stack: Stack):\n\n        await self._send_text(request, stack, 'Markdown')", "response": "Sends Markdown using _send_text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a sleep to the stack.", "response": "async def _send_sleep(self, request: Request, stack: Stack):\n        \"\"\"\n        Sleep for the amount of time specified in the Sleep layer\n        \"\"\"\n\n        duration = stack.get_layer(lyr.Sleep).duration\n        await sleep(duration)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending typing stops when the message is received.", "response": "async def _send_typing(self, request: Request, stack: Stack):\n        \"\"\"\n        In telegram, the typing stops when the message is received. Thus, there\n        is no \"typing stops\" messages to send. The API is only called when\n        typing must start.\n        \"\"\"\n\n        t = stack.get_layer(lyr.Typing)\n\n        if t.active:\n            await self.call(\n                'sendChatAction',\n                chat_id=request.message.get_chat_id(),\n                action='typing',\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an application instance with processors & pipes setup.", "response": "def create_app(metadata, processors=None, pipes=None):\n    \"\"\"Return an application instance with processors & pipes setup.\"\"\"\n\n    instance = Application(metadata)\n\n    # In order to avoid code duplication, we use existing built-in import\n    # processor to import and register built-in processors on the application\n    # instance. This is, to be honest, the main purpose of this factory\n    # function, because otherwise one must create an Application instance\n    # directly.\n    import_processors.process(instance, [], imports=[\n        \"archive = holocron.processors.archive:process\",\n        \"commonmark = holocron.processors.commonmark:process\",\n        \"feed = holocron.processors.feed:process\",\n        \"frontmatter = holocron.processors.frontmatter:process\",\n        \"import-processors = holocron.processors.import_processors:process\",\n        \"jinja2 = holocron.processors.jinja2:process\",\n        \"markdown = holocron.processors.markdown:process\",\n        \"metadata = holocron.processors.metadata:process\",\n        \"pipe = holocron.processors.pipe:process\",\n        \"prettyuri = holocron.processors.prettyuri:process\",\n        \"restructuredtext = holocron.processors.restructuredtext:process\",\n        \"save = holocron.processors.save:process\",\n        \"sitemap = holocron.processors.sitemap:process\",\n        \"source = holocron.processors.source:process\",\n        \"todatetime = holocron.processors.todatetime:process\",\n        \"when = holocron.processors.when:process\",\n    ])\n\n    for name, processor in (processors or {}).items():\n        instance.add_processor(name, processor)\n\n    for name, pipeline in (pipes or {}).items():\n        instance.add_pipe(name, pipeline)\n\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the mappings between vertex indices and labels ( target vs. not", "response": "def write_index_labels(self, targets, output_path):\n        \"\"\"Write the mappings between vertex indices and labels(target vs. not) to a file.\n\n        :param list targets: List of known targets.\n        :param str output_path: Path to the output file.\n        \"\"\"\n        label_mappings = self.get_index_labels(targets)\n\n        with open(output_path, \"w\") as file:\n            for k, v in label_mappings.items():\n                print(k, v, sep='\\t', file=file)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the labels mapped to indices.", "response": "def get_index_labels(self, targets):\n        \"\"\"Get the labels(known target/not) mapped to indices.\n\n        :param targets: List of known targets\n        :return: Dictionary of index-label mappings\n        \"\"\"\n        target_ind = self.graph.vs.select(name_in=targets).indices\n        rest_ind = self.graph.vs.select(name_notin=targets).indices\n        label_mappings = {i: 1 for i in target_ind}\n        label_mappings.update({i: 0 for i in rest_ind})\n        return label_mappings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def page_view(self,\n                        url: str,\n                        title: str,\n                        user_id: str,\n                        user_lang: str='') -> None:\n        \"\"\"\n        Log a page view.\n\n        :param url: URL of the \"page\"\n        :param title: Title of the \"page\"\n        :param user_id: ID of the user seeing the page.\n        :param user_lang: Current language of the UI.\n        \"\"\"\n        ga_url = 'https://www.google-analytics.com/collect'\n\n        args = {\n            'v': '1',\n            'ds': 'web',\n            'de': 'UTF-8',\n            'tid': self.ga_id,\n            'cid': self.hash_user_id(user_id),\n\n            't': 'pageview',\n            'dh': self.ga_domain,\n            'dp': url,\n            'dt': title,\n        }\n\n        if user_lang:\n            args['ul'] = user_lang\n\n        logger.debug('GA settings = %s', urlencode(args))\n\n        async with self.session.post(ga_url, data=args) as r:\n            if r.status == 200:\n                logger.debug(f'Sent to GA {url} ({title}) for user {user_id}')\n            else:\n                logger.warning(f'Could not contact GA')", "response": "Log a page view."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, username=None, password=None, headers={}):\n        if all((username, password, )):\n            return BasicAuth(username, password, headers)\n        elif not any((username, password, )):\n            return AnonymousAuth(headers)\n        else:\n            if username is None:\n                data = (\"username\", username, )\n            else:\n                data = (\"Password\", password, )\n            msg = \"%s must have a value (instead of '%s')\" % (data[0], data[1])\n            raise ValueError(msg)", "response": "Returns the correct AuthInfo object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef populate_request_data(self, request_args):\n        request_args['auth'] = HTTPBasicAuth(\n            self._username, self._password)\n        return request_args", "response": "Add the authentication info to the supplied dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a workflow to be shown in the workflows list.", "response": "def register_workflow(self, name, workflow):\n        \"\"\"Register an workflow to be showed in the workflows list.\"\"\"\n        assert name not in self.workflows\n        self.workflows[name] = workflow"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init_app(self, app,\n                 entry_point_group='invenio_workflows.workflows',\n                 **kwargs):\n        \"\"\"Flask application initialization.\"\"\"\n        app.config.setdefault(\n            \"WORKFLOWS_OBJECT_CLASS\",\n            \"invenio_workflows.api.WorkflowObject\"\n        )\n        state = _WorkflowState(\n            app, entry_point_group=entry_point_group, **kwargs\n        )\n        app.extensions['invenio-workflows'] = state\n        return state", "response": "Initialize the application with the given entry_point_group and return the state of the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef static_file(filename, root,\n                mimetype=True,\n                download=False,\n                charset='UTF-8',\n                etag=None):\n    \"\"\" Open a file in a safe way and return an instance of :exc:`HTTPResponse`\n        that can be sent back to the client.\n\n        :param filename: Name or path of the file to send, relative to ``root``.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Provide the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset for files with a ``text/*`` mime-type.\n            (default: UTF-8)\n        :param etag: Provide a pre-computed ETag header. If set to ``False``,\n            ETag handling is disabled. (default: auto-generate ETag header)\n\n        While checking user input is always a good idea, this function provides\n        additional protection against malicious ``filename`` parameters from\n        breaking out of the ``root`` directory and leaking sensitive information\n        to an attacker.\n\n        Read-protected files or files outside of the ``root`` directory are\n        answered with ``403 Access Denied``. Missing files result in a\n        ``404 Not Found`` response. Conditional requests (``If-Modified-Since``,\n        ``If-None-Match``) are answered with ``304 Not Modified`` whenever\n        possible. ``HEAD`` and ``Range`` requests (used by download managers to\n        check or continue partial downloads) are also handled automatically.\n\n    \"\"\"\n\n    root = os.path.join(os.path.abspath(root), '')\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = dict()\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype is True:\n        if download and download is not True:\n            mimetype, encoding = mimetypes.guess_type(download)\n        else:\n            mimetype, encoding = mimetypes.guess_type(filename)\n        if encoding: headers['Content-Encoding'] = encoding\n\n    if mimetype:\n        if (mimetype[:5] == 'text/' or mimetype == 'application/javascript')\\\n        and charset and 'charset' not in mimetype:\n            mimetype += '; charset=%s' % charset\n        headers['Content-Type'] = mimetype\n\n    if download:\n        download = os.path.basename(filename if download is True else download)\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    headers['Last-Modified'] = email.utils.formatdate(stats.st_mtime,\n                                                      usegmt=True)\n    headers['Date'] = email.utils.formatdate(time.time(), usegmt=True)\n\n    getenv = request.environ.get\n\n    if etag is None:\n        etag = '%d:%d:%d:%d:%s' % (stats.st_dev, stats.st_ino, stats.st_mtime,\n                                   clen, filename)\n        etag = hashlib.sha1(tob(etag)).hexdigest()\n\n    if etag:\n        headers['ETag'] = etag\n        check = getenv('HTTP_IF_NONE_MATCH')\n        if check and check == etag:\n            return HTTPResponse(status=304, **headers)\n\n    ims = getenv('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n    if ims is not None and ims >= int(stats.st_mtime):\n        return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    range_header = getenv('HTTP_RANGE')\n    if range_header:\n        ranges = list(parse_range_header(range_header, clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end - 1, clen)\n        headers[\"Content-Length\"] = str(end - offset)\n        if body: body = _file_iter_range(body, offset, end - offset)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)", "response": "Open a file in a safe way and return a response object that can be sent back to the client."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_http_header(h):\n    values = []\n    if '\"' not in h:  # INFO: Fast path without regexp (~2x faster)\n        for value in h.split(','):\n            parts = value.split(';')\n            values.append((parts[0].strip(), {}))\n            for attr in parts[1:]:\n                name, value = attr.split('=', 1)\n                values[-1][1][name.strip()] = value.strip()\n    else:\n        lop, key, attrs = ',', None, {}\n        for quoted, plain, tok in _hsplit(h):\n            value = plain.strip() if plain else quoted.replace('\\\\\"', '\"')\n            if lop == ',':\n                attrs = {}\n                values.append((value, attrs))\n            elif lop == ';':\n                if tok == '=':\n                    key = value\n                else:\n                    attrs[value] = ''\n            elif lop == '=' and key:\n                attrs[key] = value\n                key = None\n            lop = tok\n    return values", "response": "Parses a typical multi - valued and parametrised HTTP header string and returns a list of values\n        and parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cookie_encode(data, key, digestmod=None):\n    depr(0, 13, \"cookie_encode() will be removed soon.\",\n                \"Do not use this API directly.\")\n    digestmod = digestmod or hashlib.sha256\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest())\n    return tob('!') + sig + tob('?') + msg", "response": "Encode and sign a pickle - able object. Return a byte string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nverify and decode an encoded string. Return an object or None.", "response": "def cookie_decode(data, key, digestmod=None):\n    \"\"\" Verify and decode an encoded string. Return an object or None.\"\"\"\n    depr(0, 13, \"cookie_decode() will be removed soon.\",\n                \"Do not use this API directly.\")\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        digestmod = digestmod or hashlib.sha256\n        hashed = hmac.new(tob(key), msg, digestmod=digestmod).digest()\n        if _lscmp(sig[1:], base64.b64encode(hashed)):\n            return pickle.loads(base64.b64decode(msg))\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a bottle application from a module and make sure that the import does not affect the current default application but returns a separate application object.", "response": "def load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN\n    NORUN, nr_old = True, NORUN\n    tmp = default_app.push()  # Create a new \"default application\"\n    try:\n        rv = load(target)  # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp)  # Remove the temporary added default application\n        NORUN = nr_old"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a string iterator that returns a single template string.", "response": "def template(*args, **kwargs):\n    \"\"\"\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    \"\"\"\n    tpl = args[0] if args else None\n    for dictarg in args[1:]:\n        kwargs.update(dictarg)\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    return TEMPLATES[tplid].render(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the original callback.", "response": "def get_undecorated_callback(self):\n        \"\"\" Return the callback. If the callback is a decorated function, try to\n            recover the original function. \"\"\"\n        func = self.callback\n        func = getattr(func, '__func__' if py3k else 'im_func', func)\n        closure_attr = '__closure__' if py3k else 'func_closure'\n        while hasattr(func, closure_attr) and getattr(func, closure_attr):\n            attributes = getattr(func, closure_attr)\n            func = attributes[0].cell_contents\n\n            # in case of decorators with multiple arguments\n            if not isinstance(func, FunctionType):\n                # pick first FunctionType instance from multiple arguments\n                func = filter(lambda x: isinstance(x, FunctionType),\n                              map(lambda x: x.cell_contents, attributes))\n                func = list(func)[0]  # py3 support\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_config(self, key, default=None):\n        depr(0, 13, \"Route.get_config() is deprectated.\",\n                    \"The Route.config property already includes values from the\"\n                    \" application config for missing keys. Access it directly.\")\n        return self.config.get(key, default)", "response": "Lookup a config field and return its value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mount(self, prefix, app, **options):\n\n        if not prefix.startswith('/'):\n            raise ValueError(\"Prefix must start with '/'\")\n\n        if isinstance(app, Bottle):\n            return self._mount_app(prefix, app, **options)\n        else:\n            return self._mount_wsgi(prefix, app, **options)", "response": "Mount an application to a specific\n            URL prefix."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef patch(self, path=None, method='PATCH', **options):\n        return self.route(path, method, **options)", "response": "Equals : meth. route with a PATCH method parameter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef error(self, code=500, callback=None):\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            self.error_handler[int(code)] = callback\n            return callback\n\n        return decorator(callback) if callback else decorator", "response": "Register an output handler for an HTTP error code."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256):\n        value = self.cookies.get(key)\n        if secret:\n            # See BaseResponse.set_cookie for details on signed cookies.\n            if value and value.startswith('!') and '?' in value:\n                sig, msg = map(tob, value[1:].split('?', 1))\n                hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()\n                if _lscmp(sig, base64.b64encode(hash)):\n                    dst = pickle.loads(base64.b64decode(msg))\n                    if dst and dst[0] == key:\n                        return dst[1]\n            return default\n        return value or default", "response": "Get the content of a cookie."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json(self):\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype in ('application/json', 'application/json-rpc'):\n            b = self._get_body_string()\n            if not b:\n                return None\n            try:\n                return json_loads(b)\n            except (ValueError, TypeError):\n                raise HTTPError(400, 'Invalid JSON')\n        return None", "response": "Returns the JSON object of the content of the request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef path_shift(self, shift=1):\n        script, path = path_shift(self.environ.get('SCRIPT_NAME', '/'), self.path, shift)\n        self['SCRIPT_NAME'], self['PATH_INFO'] = script, path", "response": "Shift path segments from the path to the script_name and\n            vice versa."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_header(self, name, value):\n        self._headers[_hkey(name)] = [_hval(value)]", "response": "Create a new response header with the given name and value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an additional response header.", "response": "def add_header(self, name, value):\n        \"\"\" Add an additional response header, not removing duplicates. \"\"\"\n        self._headers.setdefault(_hkey(name), []).append(_hval(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef headerlist(self):\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', _hval(c.OutputString())))\n        if py3k:\n            out = [(k, v.encode('utf8').decode('latin1')) for (k, v) in out]\n        return out", "response": "WSGI conform list of ( header value ) tuples."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_cookie(self, name, value, secret=None, digestmod=hashlib.sha256, **options):\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        # To add \"SameSite\" cookie support.\n        Morsel._reserved['same-site'] = 'SameSite'\n\n        if secret:\n            if not isinstance(value, basestring):\n                depr(0, 13, \"Pickling of arbitrary objects into cookies is \"\n                            \"deprecated.\", \"Only store strings in cookies. \"\n                            \"JSON strings are fine, too.\")\n            encoded = base64.b64encode(pickle.dumps([name, value], -1))\n            sig = base64.b64encode(hmac.new(tob(secret), encoded,\n                                            digestmod=digestmod).digest())\n            value = touni(tob('!') + sig + tob('?') + encoded)\n        elif not isinstance(value, basestring):\n            raise TypeError('Secret key required for non-string cookies.')\n\n        # Cookie size plus options must not exceed 4kb.\n        if len(name) + len(value) > 3800:\n            raise ValueError('Content does not fit into a cookie.')\n\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key == 'max_age':\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                if isinstance(value, (datedate, datetime)):\n                    value = value.timetuple()\n                elif isinstance(value, (int, float)):\n                    value = time.gmtime(value)\n                value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n            # check values for SameSite cookie, because it's not natively supported by http.cookies.\n            if key == 'same_site' and value.lower() not in ('lax', 'strict'):\n                raise CookieError(\"Invalid attribute %r\" % (key,))\n            if key in ('secure', 'httponly') and not value:\n                continue\n            self._cookies[name][key.replace('_', '-')] = value", "response": "Create a new cookie or replace an existing one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_module(self, path, squash=True):\n        config_obj = load(path)\n        obj = {key: getattr(config_obj, key) for key in dir(config_obj)\n               if key.isupper()}\n\n        if squash:\n            self.load_dict(obj)\n        else:\n            self.update(obj)\n        return self", "response": "Load values from a Python module."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_config(self, filename, **options):\n        options.setdefault('allow_no_value', True)\n        if py3k:\n            options.setdefault('interpolation',\n                               configparser.ExtendedInterpolation())\n        conf = configparser.ConfigParser(**options)\n        conf.read(filename)\n        for section in conf.sections():\n            for key in conf.options(section):\n                value = conf.get(section, key)\n                if section not in ['bottle', 'ROOT']:\n                    key = section + '.' + key\n                self[key.lower()] = value\n        return self", "response": "Load values from an. ini style config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the dictionary with the keys from a dictionary.", "response": "def update(self, *a, **ka):\n        \"\"\" If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n\n            >>> c = ConfigDict()\n            >>> c.update('some.namespace', key='value')\n        \"\"\"\n        prefix = ''\n        if a and isinstance(a[0], basestring):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix + key] = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _delete_virtual(self, key):\n        if key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        if key in self:\n            self._on_change(key, None)\n        dict.__delitem__(self, key)\n        self._virtual_keys.discard(key)\n        for overlay in self._iter_overlays():\n            overlay._delete_virtual(key)", "response": "Recursively delete virtual entry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef meta_set(self, key, metafield, value):\n        self._meta.setdefault(key, {})[metafield] = value", "response": "Set the meta field for a key to a new value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new overlay that acts like a chained map.", "response": "def _make_overlay(self):\n        \"\"\" (Unstable) Create a new overlay that acts like a chained map: Values\n            missing in the overlay are copied from the source map. Both maps\n            share the same meta entries.\n\n            Entries that were copied from the source are called 'virtual'. You\n            can not delete virtual keys, but overwrite them, which turns them\n            into non-virtual entries. Setting keys on an overlay never affects\n            its source, but may affect any number of child overlays.\n\n            Other than collections.ChainMap or most other implementations, this\n            approach does not resolve missing keys on demand, but instead\n            actively copies all values from the source to the overlay and keeps\n            track of virtual and non-virtual keys internally. This removes any\n            lookup-overhead. Read-access is as fast as a build-in dict for both\n            virtual and non-virtual keys.\n\n            Changes are propagated recursively and depth-first. A failing\n            on-change handler in an overlay stops the propagation of virtual\n            values and may result in an partly updated tree. Take extra care\n            here and make sure that on-change handlers never fail.\n\n            Used by Route.config\n        \"\"\"\n        # Cleanup dead references\n        self._overlays[:] = [ref for ref in self._overlays if ref() is not None]\n\n        overlay = ConfigDict()\n        overlay._meta = self._meta\n        overlay._source = self\n        self._overlays.append(weakref.ref(overlay))\n        for key in self:\n            overlay._set_virtual(key, self[key])\n        return overlay"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the name of the file on the client file system.", "response": "def filename(self):\n        \"\"\" Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        \"\"\"\n        fname = self.raw_filename\n        if not isinstance(fname, unicode):\n            fname = fname.decode('utf8', 'ignore')\n        fname = normalize('NFKD', fname)\n        fname = fname.encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize(text: TransText):\n\n    if isinstance(text, str):\n        return {\n            'type': 'string',\n            'value': text,\n        }\n    elif isinstance(text, StringToTranslate):\n        return {\n            'type': 'trans',\n            'key': text.key,\n            'count': text.count,\n            'params': text.params,\n        }\n    else:\n        raise ValueError('Cannot accept type \"{}\"'\n                         .format(text.__class__.__name__))", "response": "Takes as input either a string to translate either an actual string and transforms it into a JSON - serializable structure that can be reconstructed\n    using deserialize."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms back a serialized value of `serialize()`", "response": "def unserialize(wd: WordDictionary, text: Dict):\n    \"\"\"\n    Transforms back a serialized value of `serialize()`\n    \"\"\"\n\n    if not isinstance(text, Mapping):\n        raise ValueError('Text has not the right format')\n\n    try:\n        t = text['type']\n\n        if t == 'string':\n            return text['value']\n        elif t == 'trans':\n            if not isinstance(text['params'], Mapping):\n                raise ValueError('Params should be a dictionary')\n\n            for param in text['params']:\n                if not isinstance(param, str):\n                    raise ValueError('Params are not all text-keys')\n\n            return StringToTranslate(\n                wd=wd,\n                key=text['key'],\n                count=text['count'],\n                params=text['params'],\n            )\n        else:\n            raise ValueError('Unknown type \"{}\"'.format(t))\n    except KeyError:\n        raise ValueError('Not enough information to unserialize')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def render(\n        text: TransText,\n        request: Optional['Request'],\n        multi_line=False) -> Union[Text, List[Text]]:\n    \"\"\"\n    Render either a normal string either a string to translate into an actual\n    string for the specified request.\n    \"\"\"\n\n    if isinstance(text, str):\n        out = [text]\n    elif isinstance(text, StringToTranslate):\n        out = await text.render_list(request)\n    else:\n        raise TypeError('Provided text cannot be rendered')\n\n    if multi_line:\n        return out\n    else:\n        return ' '.join(out)", "response": "Render the given text into a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef score(self, flags: Flags) -> int:\n\n        score = 0\n\n        for k, v in flags.items():\n            if self.flags.get(k) == v:\n                score += 1\n\n        return score", "response": "Returns the score of the flags that can be matched."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of flags find all items that have a score greater than or equal to the given flags and put them in a list.", "response": "def best_for_flags(self, flags: Flags) -> List[TransItem]:\n        \"\"\"\n        Given `flags`, find all items of this sentence that have an equal\n        matching score and put them in a list.\n        \"\"\"\n\n        best_score: int = 0\n        best_list: List[TransItem] = []\n\n        for item in self.items:\n            score = item.score(flags)\n\n            if score == best_score:\n                best_list.append(item)\n            elif score > best_score:\n                best_list = [item]\n                best_score = score\n\n        return best_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(self, flags: Flags) -> Text:\n        return random.choice(self.best_for_flags(flags)).value", "response": "Renders a random tag from the list and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the items of the current set with the new sentence.", "response": "def update(self, new: 'Sentence', flags: Flags):\n        \"\"\"\n        Erase items with the specified flags and insert the new items from\n        the other sentence instead.\n        \"\"\"\n\n        items = [i for i in self.items if i.flags != flags]\n        items.extend(new.items)\n        self.items = items"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of random outcomes for each sentence of the list.", "response": "def render(self, flags: Flags) -> List[Text]:\n        \"\"\"\n        Returns a list of randomly chosen outcomes for each sentence of the\n        list.\n        \"\"\"\n        return [x.render(flags) for x in self.sentences]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending an item to the list.", "response": "def append(self, item: TransItem):\n        \"\"\"\n        Append an item to the list. If there is not enough sentences in the\n        list, then the list is extended as needed.\n\n        There is no control made to make sure that the key is consistent.\n        \"\"\"\n\n        if not (1 <= item.index <= settings.I18N_MAX_SENTENCES_PER_GROUP):\n            return\n\n        if len(self.sentences) < item.index:\n            for _ in range(len(self.sentences), item.index):\n                self.sentences.append(Sentence())\n\n        self.sentences[item.index - 1].append(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, group: 'SentenceGroup', flags: Flags) -> None:\n\n        to_append = []\n\n        for old, new in zip_longest(self.sentences, group.sentences):\n            if old is None:\n                old = Sentence()\n                to_append.append(old)\n\n            if new is None:\n                new = Sentence()\n\n            old.update(new, flags)\n\n        self.sentences.extend(to_append)", "response": "Updates the internal list of sentences related to the specified group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract(self):\n\n        out = {}\n\n        for key, group in self.data.items():\n            out[key] = group\n\n        return out", "response": "Extract only the valid sentence groups into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend an item to the internal dictionary.", "response": "def append(self, item: TransItem):\n        \"\"\"\n        Append an item to the internal dictionary.\n        \"\"\"\n\n        self.data[item.key].append(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_item(self, key, value, flags: Flags) -> Optional[TransItem]:\n\n        parts = key.split('+')\n        pure_key = parts[0]\n\n        try:\n            if len(parts) == 2:\n                index = int(parts[1])\n            elif len(parts) > 2:\n                return\n            else:\n                index = 1\n        except (ValueError, TypeError):\n            return\n\n        if index < 1:\n            return\n\n        return TransItem(\n            key=pure_key,\n            index=index,\n            value=value,\n            flags=flags,\n        )", "response": "Parses an item and returns the TransItem object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_lang(self,\n                    lang: Optional[Text],\n                    data: List[Tuple[Text, Text]],\n                    flags: Flags):\n        \"\"\"\n        Update translations for one specific lang\n        \"\"\"\n\n        sd = SortingDict()\n\n        for item in (self.parse_item(x[0], x[1], flags) for x in data):\n            if item:\n                sd.append(item)\n\n        if lang not in self.dict:\n            self.dict[lang] = {}\n\n        d = self.dict[lang]\n\n        for k, v in sd.extract().items():\n            if k not in d:\n                d[k] = SentenceGroup()\n\n            d[k].update(v, flags)", "response": "Update translations for one specific lang"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, data: TransDict, flags: Flags):\n\n        for lang, lang_data in data.items():\n            self.update_lang(lang, lang_data, flags)", "response": "Update all langs at once"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the appropriate translation for a specific key.", "response": "def get(self,\n            key: Text,\n            count: Optional[int]=None,\n            formatter: Formatter=None,\n            locale: Text=None,\n            params: Optional[Dict[Text, Any]]=None,\n            flags: Optional[Flags]=None) -> List[Text]:\n        \"\"\"\n        Get the appropriate translation given the specified parameters.\n\n        :param key: Translation key\n        :param count: Count for plurals\n        :param formatter: Optional string formatter to use\n        :param locale: Prefered locale to get the string from\n        :param params: Params to be substituted\n        :param flags: Flags to help choosing one version or the other\n        \"\"\"\n\n        if params is None:\n            params = {}\n\n        if count is not None:\n            raise TranslationError('Count parameter is not supported yet')\n\n        locale = self.choose_locale(locale)\n\n        try:\n            group: SentenceGroup = self.dict[locale][key]\n        except KeyError:\n            raise MissingTranslationError('Translation \"{}\" does not exist'\n                                          .format(key))\n\n        try:\n            trans = group.render(flags or {})\n            out = []\n\n            for line in trans:\n                if not formatter:\n                    out.append(line.format(**params))\n                else:\n                    out.append(formatter.format(line, **params))\n        except KeyError as e:\n            raise MissingParamError(\n                'Parameter \"{}\" missing to translate \"{}\"'\n                .format(e.args[0], key)\n            )\n        else:\n            return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _resolve_params(self,\n                              params: Dict[Text, Any],\n                              request: Optional['Request']):\n        \"\"\"\n        If any StringToTranslate was passed as parameter then it is rendered\n        at this moment.\n        \"\"\"\n\n        out = {}\n\n        for k, v in params.items():\n            if isinstance(v, StringToTranslate):\n                out[k] = await render(v, request)\n            else:\n                out[k] = v\n\n        return out", "response": "Resolves the parameters of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders the translation as a list if there is multiple strings for this single key.", "response": "async def render_list(self, request=None) -> List[Text]:\n        \"\"\"\n        Render the translation as a list if there is multiple strings for this\n        single key.\n\n        :param request: Bot request.\n        \"\"\"\n        from bernard.middleware import MiddlewareManager\n\n        if request:\n            tz = await request.user.get_timezone()\n            locale = await request.get_locale()\n            flags = await request.get_trans_flags()\n        else:\n            tz = None\n            locale = self.wd.list_locales()[0]\n            flags = {}\n\n        rp = MiddlewareManager.instance()\\\n            .get('resolve_trans_params', self._resolve_params)\n\n        resolved_params = await rp(self.params, request)\n\n        f = I18nFormatter(self.wd.choose_locale(locale), tz)\n        return self.wd.get(\n            self.key,\n            self.count,\n            f,\n            locale,\n            resolved_params,\n            flags,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_key(pysam_alignment_record):\n    '''\n    Given a `pysam.AlignedSegment` instance, return the attributes identifying\n    the *read* it comes from (not the alignment). There may be more than one\n    alignment for a read, e.g. chimeric and secondary alignments.\n    '''\n    return (\n        pysam_alignment_record.query_name,\n        pysam_alignment_record.is_duplicate,\n        pysam_alignment_record.is_read1,\n        pysam_alignment_record.is_read2,\n    )", "response": "Given a pysam. AlignedSegment instance return the attributes identifying\n    the read it comes from."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a message stack to the send list.", "response": "def send(self, stack: Layers):\n        \"\"\"\n        Add a message stack to the send list.\n        \"\"\"\n\n        if not isinstance(stack, Stack):\n            stack = Stack(stack)\n\n        if not self.platform.accept(stack):\n            raise UnacceptableStack('The platform does not allow \"{}\"'\n                                    .format(stack.describe()))\n\n        self._stacks.append(stack)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend all queued messages.", "response": "async def flush(self, request: 'Request'):\n        \"\"\"\n        Send all queued messages.\n\n        The first step is to convert all media in the stacked layers then the\n        second step is to send all messages as grouped in time as possible.\n        \"\"\"\n        from bernard.middleware import MiddlewareManager\n\n        for stack in self._stacks:\n            await stack.convert_media(self.platform)\n\n        func = MiddlewareManager.instance().get('flush', self._flush)\n        await func(request, self._stacks)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _flush(self, request: 'Request', stacks: List[Stack]):\n\n        for stack in stacks:\n            await self.platform.send(request, stack)", "response": "Perform the actual sending to the platform."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def make_transition_register(self, request: 'Request'):\n\n        register = {}\n\n        for stack in self._stacks:\n            register = await stack.patch_register(register, request)\n\n        return register", "response": "Create a transition register for the given request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef preloop(self):\n        lines = textwrap.dedent(self.banner).split(\"\\n\")\n        for line in lines:\n            Console._print(\"BLUE\", \"\", line)", "response": "adds the banner to the preloop"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getDebt(self):\n        debt = float(self['principalBalance']) + float(self['interestBalance'])\n        debt += float(self['feesBalance']) + float(self['penaltyBalance'])\n\n        return debt", "response": "Sums up all the balances of the account and returns them."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef preprocess(self):\n        super(MambuLoan,self).preprocess()\n\n        try:\n            self['notes'] = strip_tags(self['notes'])\n        except KeyError:\n            pass", "response": "Preprocessing.\n\n        Each active custom field is given a 'name' key that holds the field\n        name, and for each keyed name, the value of the custom field is\n        assigned.\n\n        Notes on the group get some html tags removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the repayments for this loan to a repayments field. Returns the number of requests done to Mambu.", "response": "def setRepayments(self, *args, **kwargs):\n        \"\"\"Adds the repayments for this loan to a 'repayments' field.\n\n        Repayments are MambuRepayment objects.\n\n        Repayments get sorted by due date.\n\n        Returns the number of requests done to Mambu.\n\n.. todo:: since pagination logic was added, is not always true that\n          just 1 request was done. It may be more! But since request\n          counter singleton holds true information about how many requests\n          were done to Mambu, in fact this return value may be obsolete\n        \"\"\"\n        def duedate(repayment):\n            \"\"\"Util function used for sorting repayments according to due Date\"\"\"\n            try:\n                return repayment['dueDate']\n            except KeyError as kerr:\n                return datetime.now()\n\n        try:\n            reps = self.mamburepaymentsclass(entid=self['id'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mamburepayment import MambuRepayments\n            self.mamburepaymentsclass = MambuRepayments\n            reps = self.mamburepaymentsclass(entid=self['id'], *args, **kwargs)\n\n        reps.attrs = sorted(reps.attrs, key=duedate)\n        self['repayments'] = reps\n\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the transactions for this loan to a transactions field. Returns the number of requests done to Mambu.", "response": "def setTransactions(self, *args, **kwargs):\n        \"\"\"Adds the transactions for this loan to a 'transactions' field.\n\n        Transactions are MambuTransaction objects.\n\n        Transactions get sorted by transaction id.\n\n        Returns the number of requests done to Mambu.\n\n.. todo:: since pagination logic was added, is not always true that\n          just 1 request was done. It may be more! But since request\n          counter singleton holds true information about how many requests\n          were done to Mambu, in fact this return value may be obsolete\n        \"\"\"\n        def transactionid(transaction):\n            \"\"\"Util function used for sorting transactions according to id\"\"\"\n            try:\n                return transaction['transactionId']\n            except KeyError as kerr:\n                return None\n\n        try:\n            trans = self.mambutransactionsclass(entid=self['id'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mambutransaction import MambuTransactions\n            self.mambutransactionsclass = MambuTransactions\n            trans = self.mambutransactionsclass(entid=self['id'], *args, **kwargs)\n\n        trans.attrs = sorted(trans.attrs, key=transactionid)\n        self['transactions'] = trans\n\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCentre(self, *args, **kwargs):\n\n        try:\n            centre = self.mambucentreclass(entid=self['assignedCentreKey'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mambucentre import MambuCentre\n            self.mambucentreclass = MambuCentre\n            centre = self.mambucentreclass(entid=self['assignedCentreKey'], *args, **kwargs)\n\n        self['assignedCentreName'] = centre['name']\n        self['assignedCentre'] = centre\n\n        return 1", "response": "Adds the centre for this loan to a assignedCentre field. Returns the number of requests done to Mambu."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the user for this loan to a user field. Returns the number of requests done to Mambu.", "response": "def setUser(self, *args, **kwargs):\n        \"\"\"Adds the user for this loan to a 'user' field.\n\n        User is a MambuUser object.\n\n        Returns the number of requests done to Mambu.\n        \"\"\"\n        try:\n            user = self.mambuuserclass(entid=self['assignedUserKey'], *args, **kwargs)\n        except KeyError as kerr:\n            err = MambuError(\"La cuenta %s no tiene asignado un usuario\" % self['id'])\n            err.noUser = True\n            raise err\n        except AttributeError as ae:\n            from .mambuuser import MambuUser\n            self.mambuuserclass = MambuUser\n            try:\n                user = self.mambuuserclass(entid=self['assignedUserKey'], *args, **kwargs)\n            except KeyError as kerr:\n                err = MambuError(\"La cuenta %s no tiene asignado un usuario\" % self['id'])\n                err.noUser = True\n                raise err\n\n        self['user'] = user\n\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setProduct(self, cache=False, *args, **kwargs):\n        if cache:\n            try:\n                prods = self.allmambuproductsclass(*args, **kwargs)\n            except AttributeError as ae:\n                from .mambuproduct import AllMambuProducts\n                self.allmambuproductsclass = AllMambuProducts\n                prods = self.allmambuproductsclass(*args, **kwargs)\n            for prod in prods:\n                if prod['encodedKey'] == self['productTypeKey']:\n                    self['product'] = prod\n            try:\n                # asked for cache, but cache was originally empty\n                prods.noinit\n            except AttributeError:\n                return 1\n            return 0\n        try:\n            product = self.mambuproductclass(entid=self['productTypeKey'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mambuproduct import MambuProduct\n            self.mambuproductclass = MambuProduct\n            product = self.mambuproductclass(entid=self['productTypeKey'], *args, **kwargs)\n\n        self['product'] = product\n\n        return 1", "response": "Adds the product for this loan to a product field."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the \"holder\" of the loan to a 'holder' field. Holder may be a MambuClient or a MambuGroup object, depending on the type of loan created at Mambu. getRoles argument tells this method to retrive the clients who have specific roles in the group, in case of a group holder. getClients argument tells this method to retrieve the client members of the group, in case of a group holder. See the definition of the 'clients' field added with this argument below. fullDetails argument works for Client Holder and for the client members of the group. But the Group is always retrieved with full details. When using getRoles argument also adds a 'roles' field to the holder, a dictionary with keys: * 'role' , the rolename * 'client', a MambuClient having that role on the group .. todo:: since the roles field is added to the holder, and it only applies to Groups, perhaps the getRoles functionality should be on MambuGroup code When using getClients argument, also adds a 'clients' field to the loan. By the way it works, when holder is a Group, it calls the setClients method, which adds a 'clients' field to the MambuGroup. The 'clients' field on the loan is a dictionary with the full name of each client receiving from this loan account as a key (see the 'name' field on MambuClient and MambuGroup). Each key holds another dictionary with the following keys: * 'client' holds a MambuClient. So even if a group is the holder of the account, you can access each individual client object here. * 'loan' holds a reference to this loan account (self) * 'amount' defaults to the total loan amount ('loanAmount' field) (see the pydoc for getClientDetails method) * 'montoPago' defaults to the total loan amount divided by the number of repayment installments of the loan account (the 'repaymentInstallments' field), that is, how much to pay for each repayment installment (see the pydoc for getClientDetails method) .. todo:: change the name to an english name * 'porcentaje' defaults to a 100%, the total loan amount divided by itself, that is, hoy much in percentage of the debt belongs to this client (see the pydoc for getClientDetails method) .. todo:: change the name to an english name This three fields are supposed to reflect individual numbers for each client, but Mambu does an awful job indicating this on group loan accounts. So you should indicate how much you assigned to each client in other ways. Using the notes of the loan account perhaps (with a predefined format you parse on the preprocessing of MambuLoan)? with custom fields? Your call that you may define making your own loan account class inheriting from MambuLoan class. See the pydoc for getClientDetails method below, it specifies the way to determine the amount for each client depending on your use of Mambu, and additionally any other fields you wish to add to the 'clients' field on the loan account. Returns the number of requests done to Mambu. .. todo:: what to do on Hybrid loan accounts?", "response": "def setHolder(self, getClients=False, getRoles=False, *args, **kwargs):\n        \"\"\"Adds the \"holder\" of the loan to a 'holder' field.\n\n        Holder may be a MambuClient or a MambuGroup object, depending on\n        the type of loan created at Mambu.\n\n        getRoles argument tells this method to retrive the clients who\n        have specific roles in the group, in case of a group holder.\n\n        getClients argument tells this method to retrieve the client\n        members of the group, in case of a group holder. See the\n        definition of the 'clients' field added with this argument\n        below.\n\n        fullDetails argument works for Client Holder and for the client\n        members of the group. But the Group is always retrieved with\n        full details.\n\n        When using getRoles argument also adds a 'roles' field to the\n        holder, a dictionary with keys:\n\n        * 'role' , the rolename\n\n        * 'client', a MambuClient having that role on the group\n\n.. todo:: since the roles field is added to the holder, and it only\n          applies to Groups, perhaps the getRoles functionality should be\n          on MambuGroup code\n\n        When using getClients argument, also adds a 'clients' field to\n        the loan. By the way it works, when holder is a Group, it calls\n        the setClients method, which adds a 'clients' field to the\n        MambuGroup.\n\n        The 'clients' field on the loan is a dictionary with the full\n        name of each client receiving from this loan account as a key\n        (see the 'name' field on MambuClient and MambuGroup). Each key\n        holds another dictionary with the following keys:\n\n        * 'client' holds a MambuClient. So even if a group is the holder\n          of the account, you can access each individual client object\n          here.\n\n        * 'loan' holds a reference to this loan account (self)\n\n        * 'amount' defaults to the total loan amount ('loanAmount'\n          field) (see the pydoc for getClientDetails method)\n\n        * 'montoPago' defaults to the total loan amount divided by the\n          number of repayment installments of the loan account (the\n          'repaymentInstallments' field), that is, how much to pay for\n          each repayment installment (see the pydoc for getClientDetails\n          method)\n\n.. todo:: change the name to an english name\n\n        * 'porcentaje' defaults to a 100%, the total loan amount divided\n          by itself, that is, hoy much in percentage of the debt belongs\n          to this client (see the pydoc for getClientDetails method)\n\n.. todo:: change the name to an english name\n\n        This three fields are supposed to reflect individual numbers for\n        each client, but Mambu does an awful job indicating this on\n        group loan accounts. So you should indicate how much you\n        assigned to each client in other ways. Using the notes of the\n        loan account perhaps (with a predefined format you parse on the\n        preprocessing of MambuLoan)? with custom fields? Your call that\n        you may define making your own loan account class inheriting\n        from MambuLoan class. See the pydoc for getClientDetails method\n        below, it specifies the way to determine the amount for each\n        client depending on your use of Mambu, and additionally any\n        other fields you wish to add to the 'clients' field on the loan\n        account.\n\n        Returns the number of requests done to Mambu.\n\n.. todo:: what to do on Hybrid loan accounts?\n        \"\"\"\n        requests = 0\n        if 'fullDetails' in kwargs:\n            fullDetails = kwargs['fullDetails']\n            kwargs.pop('fullDetails')\n        else:\n            fullDetails = True\n\n        if self['accountHolderType'] == \"GROUP\":\n\n            self['holderType'] = \"Grupo\"\n            try:\n                holder = self.mambugroupclass(entid=self['accountHolderKey'], fullDetails=True, *args, **kwargs)\n            except AttributeError as ae:\n                from .mambugroup import MambuGroup\n                self.mambugroupclass = MambuGroup\n                holder = self.mambugroupclass(entid=self['accountHolderKey'], fullDetails=True, *args, **kwargs)\n            self['holder'] = holder\n            requests += 1\n\n            if getRoles:\n                roles = []\n                # If holder is group, attach role client data to the group\n                for c in holder['groupRoles']:\n                    try:\n                        cli = self.mambuclientclass(entid=c['clientKey'], *args, **kwargs)\n                    except AttributeError as ae:\n                        from .mambuclient import MambuClient\n                        self.mambuclientclass = MambuClient\n                        cli = self.mambuclientclass(entid=c['clientKey'], *args, **kwargs)\n\n                    roles.append({'role'   : c['roleName'],\n                                  'client' : cli\n                                 })\n                    requests += 1\n                holder['roles'] = roles\n\n            if getClients:\n                requests += holder.setClients(fullDetails=fullDetails, *args, **kwargs)\n\n                loanclients = {}\n\n                loanclientsdata = self.getClientDetails(holder=holder, *args, **kwargs)\n\n                for data in loanclientsdata:\n                    loanclients[data['id']] = {'client'     : data['client'],\n                                               'name'       : data['name'],\n                                               'loan'       : self,\n                                               'amount'     : data['amount'],\n                                               'montoPago'  : data['amount'] / float(self['repaymentInstallments']),\n                                               'porcentaje' : data['amount'] / float(self['loanAmount']),\n                                              }\n                    # Any extra key,val pair on loannames is plainly assigned to the loanclients[cte] dict\n                    for k,v in [ (key,val) for (key,val) in data.items() if key not in['amount', 'name'] ]:\n                        loanclients[data['id']][k] = v\n\n                self['clients'] = loanclients\n\n\n        else: # \"CLIENT\"\n            self['holderType'] = \"Cliente\"\n            try:\n                holder = self.mambuclientclass(entid=self['accountHolderKey'], fullDetails=fullDetails, *args, **kwargs)\n            except AttributeError as ae:\n                from .mambuclient import MambuClient\n                self.mambuclientclass = MambuClient\n                holder = self.mambuclientclass(entid=self['accountHolderKey'], fullDetails=fullDetails, *args, **kwargs)\n\n            self['holder'] = holder\n            requests += 1\n\n            if getClients:\n                monto = float(self['loanAmount'])\n                self['clients'] = {holder['name']: {'client'     : holder,\n                                                          'loan'       : self,\n                                                          'amount'     : monto,\n                                                          'montoPago'  : monto / float(self['repaymentInstallments']),\n                                                          'porcentaje' : 1.0,\n                                                         }\n                                        }\n\n        return requests"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getClientDetails(self, *args, **kwargs):\n        loannames = []\n\n        holder = kwargs['holder']\n        for client in holder['clients']:\n            loannames.append({'id'     : client['id'],\n                              'name'   : client['name'],\n                              'client' : client,\n                              'amount' : self['loanAmount']\n                             })\n\n        return loannames", "response": "Gets the loan details for every client in the account."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_fields_for_keyword(self, keyword, mode='a'):\n        field = self.keyword_to_fields.get(keyword, keyword)\n        if isinstance(field, dict):\n            return field[mode]\n        elif isinstance(field, (list, tuple)):\n            return field\n        return [field]", "response": "Convert keyword to fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmerging dict b into a", "response": "def merge_dict(a, b, path=None):\n    \"\"\"\n    Merge dict b into a\n    \"\"\"\n    if not path:\n        path = []\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                merge_dict(a[key], b[key], path + [str(key)])\n            else:\n                continue\n        else:\n            a[key] = b[key]\n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the dict of model variables that are set via setVar.", "response": "def findVars(self):\n        \"\"\"\n        Returns the dict of model variables, as follows:\n\n        --each getProperty() and isProperty() getter method\n          is called, and a \"property\" key is added to the result\n\n        --variables set via setVar() are added to the result,\n          overwriting any value already provided by a getter\n\n        The variables can be cached, to avoid further processing,\n        by setting the related constructor parameter: in this case,\n        findVars() returns a copy of the cached vars dictionary.\n        \"\"\"\n        if self._cacheVars and (self._vars is not None):\n            return dict(self._vars)\n\n        result = {}\n\n        for itemName in map(str, dir(self)):\n            match = self._getterPattern.match(itemName)\n\n            if match is None:\n                continue\n\n            propertyName = match.group(1)\n            varName = propertyName[0].lower() + propertyName[1:]\n\n            varValue = getattr(self, itemName)()\n\n            result[varName] = varValue\n\n        result.update(self._explicitVars)\n\n        result[\"vars\"] = result\n\n        if self._cacheVars:\n            self._vars = dict(result)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the date using Babel s date format", "response": "def format_date(self, value, format_):\n        \"\"\"\n        Format the date using Babel\n        \"\"\"\n        date_ = make_date(value)\n        return dates.format_date(date_, format_, locale=self.lang)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat the datetime using Babel", "response": "def format_datetime(self, value, format_):\n        \"\"\"\n        Format the datetime using Babel\n        \"\"\"\n        date_ = make_datetime(value)\n        return dates.format_datetime(date_, format_, locale=self.lang)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the value according to the spec.", "response": "def format_field(self, value, spec):\n        \"\"\"\n        Provide the additional formatters for localization.\n        \"\"\"\n\n        if spec.startswith('date:'):\n            _, format_ = spec.split(':', 1)\n            return self.format_date(value, format_)\n        elif spec.startswith('datetime:'):\n            _, format_ = spec.split(':', 1)\n            return self.format_datetime(value, format_)\n        elif spec == 'number':\n            return self.format_number(value)\n        else:\n            return super(I18nFormatter, self).format_field(value, spec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _encode(cls, value):\n\n        value = json.dumps(value)\n        return cls._ENC_RE.sub(lambda x: '%%%2x' % ord(x.group(0)), value)", "response": "Encode the given value taking care of '%' and '/'."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode the given value reverting '%' - encoded groups.", "response": "def _decode(cls, value):\n        \"\"\"Decode the given value, reverting '%'-encoded groups.\"\"\"\n\n        value = cls._DEC_RE.sub(lambda x: '%c' % int(x.group(1), 16), value)\n        return json.loads(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode a string form of a bucket key into a BucketKey instance.", "response": "def decode(cls, key):\n        \"\"\"\n        Decode a bucket key into a BucketKey instance.\n\n        :param key: The string form of a bucket key.\n\n        :returns: A suitable instance of BucketKey corresponding to\n                  the passed-in key.\n        \"\"\"\n\n        # Determine bucket key version\n        prefix, sep, param_str = key.partition(':')\n        if sep != ':' or prefix not in cls._prefix_to_version:\n            raise ValueError(\"%r is not a bucket key\" % key)\n        version = cls._prefix_to_version[prefix]\n\n        # Take the parameters apart...\n        parts = param_str.split('/')\n        uuid = parts.pop(0)\n        params = {}\n        for part in parts:\n            name, sep, value = part.partition('=')\n\n            # Make sure it's well-formed\n            if sep != '=':\n                raise ValueError(\"Cannot interpret parameter expression %r\" %\n                                 part)\n\n            params[name] = cls._decode(value)\n\n        # Return a BucketKey\n        return cls(uuid, params, version=version)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef need_summary(self, now, max_updates, max_age):\n\n        # Handle the case where an old summarize record exists\n        if self.summarized is True and self.last_summarize_ts + max_age <= now:\n            return True\n\n        return self.summarized is False and self.updates >= max_updates", "response": "Returns True if a summarize record is needed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a key and a bucket dict generate an appropriate instance of Bucket.", "response": "def hydrate(cls, db, bucket, limit, key):\n        \"\"\"\n        Given a key and a bucket dict, as generated by dehydrate(),\n        generate an appropriate instance of Bucket.\n        \"\"\"\n\n        return cls(db, limit, key, **bucket)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dehydrate(self):\n\n        # Only concerned about very specific attributes\n        result = {}\n        for attr in self.attrs:\n            result[attr] = getattr(self, attr)\n\n        return result", "response": "Return a dict representing this bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines the delay until next request.", "response": "def delay(self, params, now=None):\n        \"\"\"Determine delay until next request.\"\"\"\n\n        if now is None:\n            now = time.time()\n\n        # Initialize last...\n        if not self.last:\n            self.last = now\n        elif now < self.last:\n            now = self.last\n\n        # How much has leaked out?\n        leaked = now - self.last\n\n        # Update the last message time\n        self.last = now\n\n        # Update the water level\n        self.level = max(self.level - leaked, 0)\n\n        # Are we too full?\n        difference = self.level + self.limit.cost - self.limit.unit_value\n        if difference >= self.eps:\n            self.next = now + difference\n            return difference\n\n        # OK, raise the water level and set next to an appropriate\n        # value\n        self.level += self.limit.cost\n        self.next = now\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef messages(self):\n\n        return int(math.floor(((self.limit.unit_value - self.level) /\n                               self.limit.unit_value) * self.limit.value))", "response": "Return remaining messages before limiting."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a dict as generated by dehydrate() generate an an appropriate instance of the required limit class.", "response": "def hydrate(cls, db, limit):\n        \"\"\"\n        Given a limit dict, as generated by dehydrate(), generate an\n        appropriate instance of Limit (or a subclass).  If the\n        required limit class cannot be found, returns None.\n        \"\"\"\n\n        # Extract the limit name from the keyword arguments\n        cls_name = limit.pop('limit_class')\n\n        # Is it in the registry yet?\n        if cls_name not in cls._registry:\n            utils.find_entrypoint(None, cls_name)\n\n        # Look it up in the registry\n        cls = cls._registry.get(cls_name)\n\n        # Instantiate the thing\n        return cls(db, **limit) if cls else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dict representing this limit.", "response": "def dehydrate(self):\n        \"\"\"Return a dict representing this limit.\"\"\"\n\n        # Only concerned about very specific attributes\n        result = dict(limit_class=self._limit_full_name)\n        for attr in self.attrs:\n            # Using getattr allows the properties to come into play\n            result[attr] = getattr(self, attr)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset up the route(s) corresponding to the limit. This controls which limits are checked against the request. :param mapper: The routes.Mapper object to add the route to.", "response": "def _route(self, mapper):\n        \"\"\"\n        Set up the route(s) corresponding to the limit.  This controls\n        which limits are checked against the request.\n\n        :param mapper: The routes.Mapper object to add the route to.\n        \"\"\"\n\n        # Build up the keyword arguments to feed to connect()\n        kwargs = dict(conditions=dict(function=self._filter))\n\n        # Restrict the verbs\n        if self.verbs:\n            kwargs['conditions']['method'] = self.verbs\n\n        # Add requirements, if provided\n        if self.requirements:\n            kwargs['requirements'] = self.requirements\n\n        # Hook to allow subclasses to override arguments to connect()\n        uri = self.route(self.uri, kwargs)\n\n        # Create the route\n        mapper.connect(None, uri, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, key):\n\n        # Turn the key into a BucketKey\n        if isinstance(key, basestring):\n            key = BucketKey.decode(key)\n\n        # Make sure the uuids match\n        if key.uuid != self.uuid:\n            raise ValueError(\"%s is not a bucket corresponding to this limit\" %\n                             key)\n\n        # If the key is a version 1 key, load it straight from the\n        # database\n        if key.version == 1:\n            raw = self.db.get(str(key))\n            if raw is None:\n                return self.bucket_class(self.db, self, str(key))\n            return self.bucket_class.hydrate(self.db, msgpack.loads(raw),\n                                             self, str(key))\n\n        # OK, use a BucketLoader\n        records = self.db.lrange(str(key), 0, -1)\n        loader = BucketLoader(self.bucket_class, self.db, self, str(key),\n                              records)\n\n        return loader.bucket", "response": "Given a bucket key load the corresponding bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a bucket key compute the parameters used to compute that key.", "response": "def decode(self, key):\n        \"\"\"\n        Given a bucket key, compute the parameters used to compute\n        that key.\n\n        Note: Deprecated.  Use BucketKey.decode() instead.\n\n        :param key: The bucket key.  Note that the UUID must match the\n                    UUID of this limit; a ValueError will be raised if\n                    this is not the case.\n        \"\"\"\n\n        # Parse the bucket key\n        key = BucketKey.decode(key)\n\n        # Make sure the uuids match\n        if key.uuid != self.uuid:\n            raise ValueError(\"%s is not a bucket corresponding to this limit\" %\n                             key)\n\n        return key.params"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if the limit applies to the request False otherwise.", "response": "def _filter(self, environ, params):\n        \"\"\"\n        Performs final filtering of the request to determine if this\n        limit applies.  Returns False if the limit does not apply or\n        if the call should not be limited, or True to apply the limit.\n        \"\"\"\n\n        # Search for required query arguments\n        if self.queries:\n            # No query string available\n            if 'QUERY_STRING' not in environ:\n                return False\n\n            # Extract the list of provided query arguments from the\n            # QUERY_STRING\n            available = set(qstr.partition('=')[0] for qstr in\n                            environ['QUERY_STRING'].split('&'))\n\n            # Check if we have the required query arguments\n            required = set(self.queries)\n            if not required.issubset(available):\n                return False\n\n        # Use only the parameters listed in use; we'll add the others\n        # back later\n        unused = {}\n        for key, value in params.items():\n            if key not in self.use:\n                unused[key] = value\n\n        # Do this in a separate step so we avoid changing a\n        # dictionary during traversal\n        for key in unused:\n            del params[key]\n\n        # First, we need to set up any additional params required to\n        # get the bucket.  If the DeferLimit exception is thrown, no\n        # further processing is performed.\n        try:\n            additional = self.filter(environ, params, unused) or {}\n        except DeferLimit:\n            return False\n\n        # Compute the bucket key\n        key = self.key(params)\n\n        # Update the parameters...\n        params.update(unused)\n        params.update(additional)\n\n        # Get the current time\n        now = time.time()\n\n        # Allow up to a minute to mutate the bucket record.  If no\n        # bucket exists currently, this is essentially a no-op, and\n        # the bucket won't expire anyway, once the update record is\n        # pushed.\n        self.db.expire(key, 60)\n\n        # Push an update record\n        update_uuid = str(uuid.uuid4())\n        update = {\n            'uuid': update_uuid,\n            'update': {\n                'params': params,\n                'time': now,\n            },\n        }\n        self.db.rpush(key, msgpack.dumps(update))\n\n        # Now suck in the bucket\n        records = self.db.lrange(key, 0, -1)\n        loader = BucketLoader(self.bucket_class, self.db, self, key, records)\n\n        # Determine if we should initialize the compactor algorithm on\n        # this bucket\n        if 'turnstile.conf' in environ:\n            config = environ['turnstile.conf']['compactor']\n            try:\n                max_updates = int(config['max_updates'])\n            except (KeyError, ValueError):\n                max_updates = None\n            try:\n                max_age = int(config['max_age'])\n            except (KeyError, ValueError):\n                max_age = 600\n            if max_updates and loader.need_summary(now, max_updates, max_age):\n                # Add a summary record; we want to do this before\n                # instructing the compactor to compact.  If we did the\n                # compactor instruction first, and a crash occurred\n                # before adding the summarize record, the lack of\n                # quiesence could cause two compactor threads to run\n                # on the same bucket, leading to a race condition that\n                # could corrupt the bucket.  With this ordering, if a\n                # crash occurs before the compactor instruction, the\n                # maximum aging applied to summarize records will\n                # cause this logic to eventually be retriggered, which\n                # should allow the compactor instruction to be issued.\n                summarize = dict(summarize=now, uuid=str(uuid.uuid4()))\n                self.db.rpush(key, msgpack.dumps(summarize))\n\n                # Instruct the compactor to compact this record\n                compactor_key = config.get('compactor_key', 'compactor')\n                self.db.zadd(compactor_key, int(math.ceil(now)), key)\n\n        # Set the expire on the bucket\n        self.db.expireat(key, loader.bucket.expire)\n\n        # If we found a delay, store the particulars in the\n        # environment; this will later be sorted and an error message\n        # corresponding to the longest delay returned.\n        if loader.delay is not None:\n            environ.setdefault('turnstile.delay', [])\n            environ['turnstile.delay'].append((loader.delay, self,\n                                               loader.bucket))\n\n        # Finally, if desired, add the bucket key to a desired\n        # database set\n        set_name = environ.get('turnstile.bucket_set')\n        if set_name:\n            self.db.zadd(set_name, loader.bucket.expire, key)\n\n        # Should we continue the route scan?\n        return not self.continue_scan"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format(self, status, headers, environ, bucket, delay):\n\n        # This is a default response entity, which can be overridden\n        # by limit subclasses.\n        entity = (\"This request was rate-limited.  \"\n                  \"Please retry your request after %s.\" %\n                  time.strftime(\"%Y-%m-%dT%H:%M:%SZ\",\n                                time.gmtime(bucket.next)))\n        headers['Content-Type'] = 'text/plain'\n\n        return status, entity", "response": "Formats a response entity."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nchange the unit for this limit to the specified value.", "response": "def unit(self, value):\n        \"\"\"\n        Change the unit for this limit to the specified unit.  The new\n        value may be specified as an integer, a string indicating the\n        number of seconds, or one of the recognized unit names.\n        \"\"\"\n\n        if isinstance(value, TimeUnit):\n            self._unit = value\n        else:\n            self._unit = TimeUnit(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchanging the unit for this limit to the specified value.", "response": "def unit_value(self, value):\n        \"\"\"\n        Change the unit for this limit to the specified unit.  The new\n        value may be specified as an integer, a string indicating the\n        number of seconds, or one of the recognized unit names.\n        \"\"\"\n\n        if isinstance(value, TimeUnit):\n            self._unit = value\n        else:\n            self._unit = TimeUnit(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove common prefix from a collection of strings", "response": "def drop_prefix(strings):\n    \"\"\"\n    Removes common prefix from a collection of strings\n    \"\"\"\n    strings_without_extensions = [\n        s.split(\".\", 2)[0] for s in strings\n    ]\n\n    if len(strings_without_extensions) == 1:\n        return [os.path.basename(strings_without_extensions[0])]\n    prefix_len = len(os.path.commonprefix(strings_without_extensions))\n    result = [string[prefix_len:] for string in strings_without_extensions]\n    if len(set(result)) != len(strings):\n        # If these operations resulted in a collision, just return the original\n        # strings.\n        return strings\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render(self, parsed):\n        self.renderer.root_node = parsed\n        with self.renderer as r:\n            return r.render(parsed)", "response": "Call self. renderer. render ( text )."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef formatwarning(message, category, filename, lineno, line=None):\n    return '{basename}:{lineno}: {category}: {message}\\n'.format(\n        basename=path.basename(filename), lineno=lineno,\n        category=category.__name__, message=message)", "response": "Override default Warning layout, from:\n\n        /PATH/TO/dutree.py:326: UserWarning:\n            [Errno 2] No such file or directory: '/0.d/05.d'\n          warnings.warn(str(e))\n\n    To:\n\n        dutree.py:330: UserWarning:\n            [Errno 2] No such file or directory: '/0.d/05.d'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn how many nodes this contains including self.", "response": "def count(self):\n        \"Return how many nodes this contains, including self.\"\n        if self._nodes is None:\n            return 1\n        return sum(i.count() for i in self._nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the total apparent size including children.", "response": "def app_size(self):\n        \"Return the total apparent size, including children.\"\n        if self._nodes is None:\n            return self._app_size\n        return sum(i.app_size() for i in self._nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_size(self):\n        \"Return the total used size, including children.\"\n        if self._nodes is None:\n            return self._use_size\n        return sum(i.use_size() for i in self._nodes)", "response": "Return the total used size including children."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prune_if_smaller_than(self, small_size, a_or_u):\n        \"Prune/merge all nodes that are smaller than small_size.\"\n        if self._prune_all_if_small(small_size, a_or_u):\n            return\n\n        for node in self._nodes:\n            node.prune_if_smaller_than(small_size, a_or_u)\n\n        self._prune_some_if_small(small_size, a_or_u)", "response": "Prune / merge all nodes that are smaller than small_size."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _prune_all_if_small(self, small_size, a_or_u):\n        \"Return True and delete children if small enough.\"\n        if self._nodes is None:\n            return True\n\n        total_size = (self.app_size() if a_or_u else self.use_size())\n        if total_size < small_size:\n            if a_or_u:\n                self._set_size(total_size, self.use_size())\n            else:\n                self._set_size(self.app_size(), total_size)\n            return True\n\n        return False", "response": "Return True and delete children if small enough."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _prune_some_if_small(self, small_size, a_or_u):\n        \"Merge some nodes in the directory, whilst keeping others.\"\n        # Assert that we're not messing things up.\n        prev_app_size = self.app_size()\n        prev_use_size = self.use_size()\n\n        keep_nodes = []\n        prune_app_size = 0\n        prune_use_size = 0\n        for node in self._nodes:\n            node_size = node.app_size() if a_or_u else node.use_size()\n            if node_size < small_size:\n                if a_or_u:\n                    prune_app_size += node_size\n                    prune_use_size += node.use_size()\n                else:\n                    prune_app_size += node.app_size()\n                    prune_use_size += node_size\n            else:\n                keep_nodes.append(node)\n\n        # Last \"leftover\" node? Merge with parent.\n        if len(keep_nodes) == 1 and keep_nodes[-1]._isdir is None:\n            prune_app_size += keep_nodes[-1]._app_size\n            prune_use_size += keep_nodes[-1]._use_size\n            keep_nodes = []\n\n        if prune_app_size:\n            if not keep_nodes:\n                # The only node to keep, no \"leftovers\" here. Move data\n                # to the parent.\n                keep_nodes = None\n                assert self._isdir and self._nodes is not None\n                self._set_size(prune_app_size, prune_use_size)\n            elif keep_nodes and keep_nodes[-1]._isdir is None:\n                # There was already a leftover node. Add the new leftovers.\n                keep_nodes[-1]._add_size(prune_app_size, prune_use_size)\n            else:\n                # Create a new leftover node.\n                keep_nodes.append(DuNode.new_leftovers(\n                    self._path, prune_app_size, prune_use_size))\n\n        # Update nodes and do the actual assertion.\n        self._nodes = keep_nodes\n        assert prev_app_size == self.app_size(), (\n            prev_app_size, self.app_size())\n        assert prev_use_size == self.use_size(), (\n            prev_use_size, self.use_size())", "response": "Merge some nodes in the directory whilst keeping others."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge_upwards_if_smaller_than(self, small_size, a_or_u):\n\n        # Assert that we're not messing things up.\n        prev_app_size = self.app_size()\n        prev_use_size = self.use_size()\n\n        small_nodes = self._find_small_nodes(small_size, (), a_or_u)\n        for node, parents in small_nodes:\n            # Check immediate grandparent for isdir=None and if it\n            # exists, move this there. The isdir=None node is always\n            # last.\n            if len(parents) >= 2:\n                tail = parents[-2]._nodes[-1]\n                if tail._isdir is None:\n                    assert tail._app_size is not None, tail\n                    tail._add_size(node.app_size(), node.use_size())\n                    parents[-1]._nodes.remove(node)\n                    assert len(parents[-1]._nodes)\n\n        # The actual assertion.\n        assert prev_app_size == self.app_size(), (\n            prev_app_size, self.app_size())\n        assert prev_use_size == self.use_size(), (\n            prev_use_size, self.use_size())", "response": "This is a private method that merges upwards the tree if the small_size is greater than the current one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the nodes as a list of lists.", "response": "def as_tree(self):\n        \"Return the nodes as a list of lists.\"\n        if self._nodes is None:\n            return [self]\n        ret = [self]\n        for node in self._nodes:\n            ret.append(node.as_tree())\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_leaves(self):\n        \"Return a sorted leaves: only nodes with fixed file size.\"\n        leaves = self._get_leaves()\n        leaves.sort(key=(lambda x: x._path))  # FF sorts \"mixed\" last\n        return leaves", "response": "Return a sorted leaves : only nodes with fixed file size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning path normalized for duscan usage : no trailing slash.", "response": "def _normpath(self, pathname):\n        \"Return path normalized for duscan usage: no trailing slash.\"\n        if pathname == '/':\n            pathname = ''\n        elif pathname.endswith('/'):\n            pathname = pathname[:-1]\n        assert not pathname.endswith('/'), pathname\n        return pathname"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_path(self):\n        \"Immediately check if we can access path. Otherwise bail.\"\n        if not path.isdir(self._path or '/'):\n            raise OSError('Path {!r} is not a directory'.format(self._path))", "response": "Immediately check if we can access path. Otherwise bail."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npresent a dmenu to the user.", "response": "def show(\n        items,\n        command='dmenu',\n        bottom=None,\n        fast=None,\n        case_insensitive=None,\n        lines=None,\n        monitor=None,\n        prompt=None,\n        font=None,\n        background=None,\n        foreground=None,\n        background_selected=None,\n        foreground_selected=None):\n    '''Present a dmenu to the user.\n\n    Args:\n        items (Iterable[str]): defines the menu items being presented to the user. items should not contain the newline character.\n        command (Optional[str]): defines the path to the dmenu executable. Defaults to 'dmenu'.\n        bottom (Optional[bool]): dmenu appears at the bottom of the screen.\n        fast (Optional[bool]): dmenu grabs the keyboard before reading stdin. This is faster, but will lock up X until stdin reaches end-of-file.\n        case_insensitive (Optional[bool]): dmenu matches menu items case insensitively.\n        lines (Optional[int]): dmenu lists items vertically, with the given number of lines.\n        monitor (Optional[int]): dmenu is displayed on the monitor number supplied. Monitor numbers are starting from 0.\n        prompt (Optional[str]): defines the prompt to be displayed to the left of the input field.\n        font (Optional[str]): defines the font or font set used. eg. \"fixed\" or \"Monospace-12:normal\" (an xft font)\n        background (Optional[str]): defines the normal background color. #RGB, #RRGGBB, and X color names are supported.\n        foreground (Optional[str]): defines the normal foreground color.\n        background_selected (Optional[str]): defines the selected background color.\n        foreground_selected (Optional[str]): defines the selected foreground color.\n\n    Raises:\n        DmenuCommandError\n        DmenuUsageError\n\n    Returns:\n        The user's selected menu item, their own typed item, or None if they hit escape.\n\n    Examples:\n\n        >>> import dmenu\n\n        >>> dmenu.show(['a', 'b', 'c'])\n        'a'  # user selected a\n\n        >>> dmenu.show(['a', 'b', 'c'], prompt='pick a letter')\n        'b'  # user selected b\n\n        >>> dmenu.show(['a', 'b', 'c'])\n        None  # user hit escape\n\n        >>> dmenu.show(['a', 'b', 'c'])\n        'd'  # user typed their own selection, d\n\n        >>> dmenu.show(['a', 'b', 'c'], command='not_a_valid_dmenu')\n        Traceback (most recent call last):\n          ...\n        dmenu.dmenu.DmenuCommandError: The provided dmenu command could not be used (['not_a_valid_dmenu']): [Errno 2] No such file or directory: 'not_a_valid_dmenu'\n\n        >>> dmenu.show(['a', 'b', 'c'], monitor=2)\n        Traceback (most recent call last):\n          ...\n        dmenu.dmenu.DmenuUsageError: This version of dmenu does not support your usage (['dmenu', '-m', '2']):\n        usage: dmenu [-b] [-f] [-i] [-l lines] [-p prompt] [-fn font]\n                     [-nb color] [-nf color] [-sb color] [-sf color] [-v]\n\n        Consider configuring show using partial application:\n\n        >>> import functools\n        >>> show = functools.partial(dmenu.show, bottom=True)\n        >>> show(['we', 'show', 'up', 'below'])\n        >>> show(['us', 'too'])\n    '''\n\n    # construct args\n\n    args = [command]\n\n    if bottom:\n        args.append('-b')\n\n    if fast:\n        args.append('-f')\n\n    if case_insensitive:\n        args.append('-i')\n\n    if lines is not None:\n        args.extend(('-l', str(lines)))\n\n    if monitor is not None:\n        args.extend(('-m', str(monitor)))\n\n    if prompt is not None:\n        args.extend(('-p', prompt))\n\n    if font is not None:\n        args.extend(('-fn', font))\n\n    if background is not None:\n        args.extend(('-nb', background))\n\n    if foreground is not None:\n        args.extend(('-nf', foreground))\n\n    if background_selected is not None:\n        args.extend(('-sb', background_selected))\n\n    if foreground_selected is not None:\n        args.extend(('-sf', foreground_selected))\n\n    try:\n        # start the dmenu process\n        proc = subprocess.Popen(\n            args,\n            universal_newlines=True,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE)\n    except OSError as err:\n        # something went wrong with starting the process\n        raise DmenuCommandError(args, err)\n\n    # write items over to dmenu\n    with proc.stdin:\n        for item in items:\n            proc.stdin.write(item)\n            proc.stdin.write('\\n')\n\n    if proc.wait() == 0:\n        # user made a selection\n        return proc.stdout.read().rstrip('\\n')\n\n    stderr = proc.stderr.read()\n\n    if stderr == '':\n        # user hit escape\n        return None\n\n    if re.match('usage', stderr, re.I):\n        # usage error\n        raise DmenuUsageError(args, stderr)\n\n    # other error from dmenu\n    raise DmenuCommandError(args, stderr)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_upregulated_genes_network(self) -> Graph:\n        logger.info(\"In get_upregulated_genes_network()\")\n\n        deg_graph = self.graph.copy()  # deep copy graph\n        not_diff_expr = self.graph.vs(up_regulated_eq=False)\n\n        # delete genes which are not differentially expressed or have no connections to others\n        deg_graph.delete_vertices(not_diff_expr.indices)\n        deg_graph.delete_vertices(deg_graph.vs.select(_degree_eq=0))\n\n        return deg_graph", "response": "Get the graph of up - regulated genes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_downregulated_genes_network(self) -> Graph:\n        logger.info(\"In get_downregulated_genes_network()\")\n\n        deg_graph = self.graph.copy()  # deep copy graph\n        not_diff_expr = self.graph.vs(down_regulated_eq=False)\n\n        # delete genes which are not differentially expressed or have no connections to others\n        deg_graph.delete_vertices(not_diff_expr.indices)\n        deg_graph.delete_vertices(deg_graph.vs.select(_degree_eq=0))\n\n        return deg_graph", "response": "Get the graph of down - regulated genes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating the parser for all sub - commands", "response": "def make_parser():\n    \"\"\"\n    Generate the parser for all sub-commands\n    \"\"\"\n\n    parser = argparse.ArgumentParser(description='BERNARD CLI utility')\n    sp = parser.add_subparsers(help='Sub-command')\n\n    parser_run = sp.add_parser('run', help='Run the BERNARD server')\n    parser_run.set_defaults(action='run')\n\n    parser_sheet = sp.add_parser('sheet', help='Import files from Google '\n                                               'Sheets')\n    parser_sheet.set_defaults(action='sheet')\n    parser_sheet.add_argument(\n        '--auth_host_name',\n        default='localhost',\n        help='Hostname when running a local web server.'\n    )\n    parser_sheet.add_argument(\n        '--noauth_local_webserver',\n        action='store_true',\n        default=False,\n        help='Do not run a local web server.'\n    )\n    parser_sheet.add_argument(\n        '--auth_host_port',\n        default=[8080, 8090],\n        type=int,\n        nargs='*',\n        help='Port web server should listen on.'\n    )\n    parser_sheet.add_argument(\n        '--logging_level',\n        default='ERROR',\n        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],\n        help='Set the logging level of detail.'\n    )\n\n    parser_sp = sp.add_parser('start_project', help='Starts a project')\n    parser_sp.set_defaults(action='start_project')\n    parser_sp.add_argument(\n        'project_name',\n        help='A snake-case name for your project'\n    )\n    parser_sp.add_argument(\n        'dir',\n        help='Directory to store the project'\n    )\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main():\n\n    parser = make_parser()\n    args = parser.parse_args()\n\n    if not hasattr(args, 'action'):\n        parser.print_help()\n        exit(1)\n\n    if args.action == 'sheet':\n        from bernard.misc.sheet_sync import main as main_sheet\n        main_sheet(args)\n    elif args.action == 'run':\n        from bernard.cli import main as main_run\n        main_run()\n    elif args.action == 'start_project':\n        from bernard.misc.start_project import main as main_sp\n        main_sp(args)", "response": "Run the appropriate main function according to the output of the parser."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_dotenv(dotenv_path, verbose=False):\n    if not os.path.exists(dotenv_path):\n        if verbose:\n            warnings.warn(f\"Not loading {dotenv_path}, it doesn't exist.\")\n        return None\n    for k, v in dotenv_values(dotenv_path).items():\n        os.environ.setdefault(k, v)\n    return True", "response": "Read a. env file and load into os. environ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_key(dotenv_path, key_to_get, verbose=False):\n    key_to_get = str(key_to_get)\n    if not os.path.exists(dotenv_path):\n        if verbose:\n            warnings.warn(f\"Can't read {dotenv_path}, it doesn't exist.\")\n        return None\n    dotenv_as_dict = dotenv_values(dotenv_path)\n    if key_to_get in dotenv_as_dict:\n        return dotenv_as_dict[key_to_get]\n    else:\n        if verbose:\n            warnings.warn(f\"key {key_to_get} not found in {dotenv_path}.\")\n        return None", "response": "Gets the value of a given key from the given. env file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding or updates a key to the given. env file.", "response": "def set_key(dotenv_path, key_to_set, value_to_set, quote_mode='always', verbose=False):\n    \"\"\"\n    Adds or Updates a key/value to the given .env\n\n    If the .env path given doesn't exist, fails instead of risking creating\n    an orphan .env somewhere in the file-system\n\n    :param dotenv_path: env path\n    :param key_to_set: key\n    :param value_to_set: value\n    :param quote_mode: quote value in .env file\n    :param verbose: verbosity flag, raise warning if path does not exist\n    :return: tuple (fail/win, key, value)\n    \"\"\"\n    key_to_set = str(key_to_set)\n    value_to_set = str(value_to_set).strip(\"'\").strip('\"')\n    if not os.path.exists(dotenv_path):\n        if verbose:\n            warnings.warn(f\"Can't write to {dotenv_path}, it doesn't exist.\")\n        return None, key_to_set, value_to_set\n\n    dotenv_as_dict = OrderedDict(parse_dotenv(dotenv_path))\n    dotenv_as_dict[key_to_set] = value_to_set\n    success = flatten_and_write(dotenv_path, dotenv_as_dict, quote_mode)\n\n    return success, key_to_set, value_to_set"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a given key from the given. env file and returns success and key.", "response": "def unset_key(dotenv_path, key_to_unset, quote_mode='always', verbose=False):\n    \"\"\"\n    Removes a given key from the given .env\n\n    If the .env path given doesn't exist, fails\n    If the given key doesn't exist in the .env, fails\n\n    :param dotenv_path: env path\n    :param key_to_unset: value\n    :param quote_mode: quote value in .env file\n    :param verbose: verbosity flag, raise warning if path does not exist\n    :return: tuple (fail/win, key)\n    \"\"\"\n    key_to_unset = str(key_to_unset)\n    if not os.path.exists(dotenv_path):\n        if verbose:\n            warnings.warn(f\"Can't delete from {dotenv_path}, it doesn't exist.\")\n        return None, key_to_unset\n    dotenv_as_dict = dotenv_values(dotenv_path)\n    if key_to_unset in dotenv_as_dict:\n        dotenv_as_dict.pop(key_to_unset, None)\n    else:\n        if verbose:\n            warnings.warn(f\"Key {key_to_unset} not removed from {dotenv_path}, key doesn't exist.\")\n        return None, key_to_unset\n\n    success = flatten_and_write(dotenv_path, dotenv_as_dict, quote_mode)\n    return success, key_to_unset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a dotenv file and return a dict of values", "response": "def dotenv_values(dotenv_path):\n    \"\"\"\n    :param dotenv_path: env file\n    :return: ordered dict\n    \"\"\"\n    values = OrderedDict(parse_dotenv(dotenv_path))\n    values = resolve_nested_variables(values)\n    return values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_dotenv(dotenv_path):\n    with open(dotenv_path) as f:\n        for line in f:\n            line = line.strip()\n            if not line or line.startswith('#') or '=' not in line:\n                continue\n            k, v = line.split('=', 1)\n\n            # Remove any leading and trailing spaces in key, value\n            k, v = k.strip(), v.strip()\n\n            if len(v) > 0:\n                quoted = v[0] == v[len(v) - 1] in ['\"', \"'\"]\n\n                if quoted:\n                    v = decode_escaped(v[1:-1])\n\n            yield k, v", "response": "Parses the dotenv file and returns a generator yielding the key and value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the quote format depending on the quote_mode.", "response": "def _get_format(value, quote_mode='always'):\n    \"\"\"\n    Returns the quote format depending on the quote_mode.\n    This determines if the key value will be quoted when written to\n    the env file.\n\n    :param value:\n    :param quote_mode:\n    :return: str\n    :raises: KeyError if the quote_mode is unknown\n    \"\"\"\n\n    formats = {'always': '{key}=\"{value}\"\\n', 'auto': '{key}={value}\\n'}\n\n    if quote_mode not in formats.keys():\n        return KeyError(f'quote_mode {quote_mode} is invalid')\n\n    _mode = quote_mode\n    if quote_mode == 'auto' and ' ' in value:\n        _mode = 'always'\n    return formats.get(_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a dict to a. env file", "response": "def flatten_and_write(dotenv_path, dotenv_as_dict, quote_mode='always'):\n    \"\"\"\n    Writes dotenv_as_dict to dotenv_path, flattening the values\n    :param dotenv_path: .env path\n    :param dotenv_as_dict: dict\n    :param quote_mode:\n    :return:\n    \"\"\"\n    with open(dotenv_path, 'w') as f:\n        for k, v in dotenv_as_dict.items():\n            str_format = _get_format(v, quote_mode)\n            f.write(str_format.format(key=k, value=v))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_dotenv(filename='.env', raise_error_if_not_found=False, usecwd=False):\n    if usecwd or '__file__' not in globals():\n        # should work without __file__, e.g. in REPL or IPython notebook\n        path = os.getcwd()\n    else:\n        # will work for .py files\n        frame_filename = sys._getframe().f_back.f_code.co_filename\n        path = os.path.dirname(os.path.abspath(frame_filename))\n\n    for dirname in _walk_to_root(path):\n        check_path = os.path.join(dirname, filename)\n        if os.path.exists(check_path):\n            return check_path\n\n    if raise_error_if_not_found:\n        raise IOError('File not found')\n\n    return ''", "response": "Search in increasingly higher folders for the given file and return the path to the file if found."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_version(self, args):\n        Console.ok(\"cmd3: {:}\".format(str(cmd3.__version__)))\n        Console.ok(\"cloudmesh_base: {:}\".format(str(cloudmesh_base.__version__)))\n\n        python_version, pip_version = get_python()\n\n        Console.ok(\"python: {:}\".format(str(python_version)))\n        Console.ok(\"pip: {:}\".format(str(pip_version)))\n\n\n        check_python()", "response": "Print out the version number of the current version of the cloudmesh base and the python version."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_exec(self, filename):\n        if not filename:\n            Console.error(\"the command requires a filename as parameter\")\n            return\n\n        if os.path.exists(filename):\n            with open(filename, \"r\") as f:\n                for line in f:\n                    Console.ok(\"> {:}\".format(str(line)))\n                    self.onecmd(line)\n        else:\n            Console.error('file \"{:}\" does not exist.'.format(filename))\n            sys.exit()", "response": "Execute the commands in the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reducer(*tokens):\n\n    def wrapper(func):\n        # Make sure that we have a list of reducer sequences\n        if not hasattr(func, 'reducers'):\n            func.reducers = []\n\n        # Add the token to the list of reducer sequences\n        func.reducers.append(list(tokens))\n\n        return func\n\n    return wrapper", "response": "Decorator for reduction methods."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_rule(rule: str, raise_error=False):\n\n    parser = Parser(raise_error)\n    return parser.parse(rule)", "response": "Parses a policy to a tree of Check objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _reduce(self):\n\n        for reduction, methname in self.reducers:\n            token_num = len(reduction)\n            if (len(self.tokens) >= token_num and\n                    self.tokens[-token_num:] == reduction):\n                # Get the reduction method\n                meth = getattr(self, methname)\n\n                # Reduce the token stream\n                results = meth(*self.values[-token_num:])\n\n                self.tokens[-token_num:] = [r[0] for r in results]\n                self.values[-token_num:] = [r[1] for r in results]\n\n                # Check for any more reductions\n                return self._reduce()", "response": "Perform a greedy reduction of the token stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a single base check rule into an appropriate Check object.", "response": "def _parse_check(self, rule):\n        \"\"\"Parse a single base check rule into an appropriate Check object.\"\"\"\n\n        # Handle the special constant-type checks\n        for check_cls in (checks.FalseCheck, checks.TrueCheck):\n            check = check_cls()\n            if rule == str(check):\n                return check\n\n        try:\n            kind, match = rule.split(':', 1)\n        except Exception:\n            if self.raise_error:\n                raise InvalidRuleException(rule)\n            else:\n                LOG.exception('Failed to understand rule %r', rule)\n                # If the rule is invalid, we'll fail closed\n                return checks.FalseCheck()\n\n        if kind in checks.registered_checks:\n            return checks.registered_checks[kind](kind, match)\n        elif None in checks.registered_checks:\n            return checks.registered_checks[None](kind, match)\n        elif self.raise_error:\n            raise InvalidRuleException(rule)\n        else:\n            LOG.error('No handler for matches of kind %r', kind)\n            # If the rule is invalid, we'll fail closed\n            return checks.FalseCheck()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_tokenize(self, rule):\n\n        for token in self._TOKENIZE_RE.split(rule):\n            # Skip empty tokens\n            if not token or token.isspace():\n                continue\n\n            # Handle leading parens on the token\n            clean = token.lstrip('(')\n            for i in range(len(token) - len(clean)):\n                yield '(', '('\n\n            # If it was only parentheses, continue\n            if not clean:\n                continue\n            else:\n                token = clean\n\n            # Handle trailing parens on the token\n            clean = token.rstrip(')')\n            trail = len(token) - len(clean)\n\n            # Yield the cleaned token\n            lowered = clean.lower()\n            if lowered in ('and', 'or', 'not'):\n                # Special tokens\n                yield lowered, clean\n            elif clean:\n                # Not a special token, but not composed solely of ')'\n                if len(token) >= 2 and ((token[0], token[-1]) in\n                                        [('\"', '\"'), (\"'\", \"'\")]):\n                    # It's a quoted string\n                    yield 'string', token[1:-1]\n                else:\n                    yield 'check', self._parse_check(clean)\n\n            # Yield the trailing parens\n            for i in range(trail):\n                yield ')', ')'", "response": "Yields the tokens in the rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, rule: str):\n\n        # Empty rule means always accept\n        if not rule:\n            return checks.TrueCheck()\n\n        for token, value in self._parse_tokenize(rule):\n            self._shift(token, value)\n\n        try:\n            return self.result\n        except ValueError:\n            LOG.exception('Failed to understand rule %r', rule)\n            # Fail closed\n            return checks.FalseCheck()", "response": "Parses a policy to tree.\n        Translate a policy written in the policy language into a tree of Check objects.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convertDict2Attrs(self, *args, **kwargs):\n        for n,r in enumerate(self.attrs):\n            # ok ok, I'm modifying elements of a list while iterating it. BAD PRACTICE!\n            try:\n                params = self.params\n            except AttributeError as aerr:\n                params = {}\n            kwargs.update(params)\n            try:\n                repayment = self.mamburepaymentclass(urlfunc=None, entid=None, *args, **kwargs)\n            except AttributeError as ae:\n                self.mamburepaymentclass = MambuRepayment\n                repayment = self.mamburepaymentclass(urlfunc=None, entid=None, *args, **kwargs)\n            repayment.init(r, *args, **kwargs)\n            self.attrs[n] = repayment", "response": "This method converts a dictionary of plain dictionaries into a list of Mambu Repayment objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_valid_keywords_grammar(keywords=None):\n    from invenio_query_parser.parser import KeywordQuery, KeywordRule, \\\n        NotKeywordValue, SimpleQuery, ValueQuery\n\n    if keywords:\n        KeywordRule.grammar = attr('value', re.compile(\n            r\"(\\d\\d\\d\\w{{0,3}}|{0})\\b\".format(\"|\".join(keywords), re.I)))\n\n        NotKeywordValue.grammar = attr('value', re.compile(\n            r'\\b(?!\\d\\d\\d\\w{{0,3}}|{0}:)\\S+\\b:'.format(\n                \":|\".join(keywords))))\n\n        SimpleQuery.grammar = attr(\n            'op', [NotKeywordValue, KeywordQuery, ValueQuery])\n    else:\n        KeywordRule.grammar = attr('value', re.compile(r\"[\\w\\d]+(\\.[\\w\\d]+)*\"))\n        SimpleQuery.grammar = attr('op', [KeywordQuery, ValueQuery])", "response": "Update parser grammar to add a list of allowed keywords."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender the given element to string.", "response": "def render(self, element):\n        \"\"\"Renders the given element to string.\n\n        :param element: a element to be rendered.\n        :returns: the output string or any values.\n        \"\"\"\n        # Store the root node to provide some context to render functions\n        if not self.root_node:\n            self.root_node = element\n        render_func = getattr(\n            self, self._cls_to_func_name(element.__class__), None)\n        if not render_func:\n            render_func = self.render_children\n        return render_func(element)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef preprocess(self):\n        super(MambuUser,self).preprocess()\n\n        try:\n            self['firstName'] = self['firstName'].strip()\n        except Exception as e:\n            self['firstName'] = \"\"\n        try:\n            self['lastName'] = self['lastName'].strip()\n        except Exception as ex:\n            self['lastName'] = \"\"\n\n        self['name'] = self['firstName'] + \" \" + self['lastName']", "response": "Preprocessing.\n\n        Removes repeated chars from firstName and lastName fields.\n\n        Adds a 'name' field joining all names in to one string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the groups assigned to this user to a groups field. Returns the number of requests done to Mambu.", "response": "def setGroups(self, *args, **kwargs):\n        \"\"\"Adds the groups assigned to this user to a 'groups' field.\n\n        Returns the number of requests done to Mambu.\n        \"\"\"\n        try:\n            groups = self.mambugroupsclass(creditOfficerUsername=self['username'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mambugroup import MambuGroups\n            self.mambugroupsclass = MambuGroups\n            groups = self.mambugroupsclass(creditOfficerUsername=self['username'], *args, **kwargs)\n        self['groups'] = groups\n\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the role assigned to this user to a role field. Returns the number of requests done to Mambu.", "response": "def setRoles(self, *args, **kwargs):\n        \"\"\"Adds the role assigned to this user to a 'role' field.\n\n        Depends on the 'role' field that comes with a fullDetails=True\n        build of the MambuUser.\n\n        Returns the number of requests done to Mambu.\n        \"\"\"\n        try:\n            role = self.mamburoleclass(entid=self['role']['encodedKey'], *args, **kwargs)\n        except KeyError:\n            return 0\n        except AttributeError as ae:\n            from .mamburoles import MambuRole\n            self.mamburoleclass = MambuRole\n            try:\n                role = self.mamburoleclass(entid=self['role']['encodedKey'], *args, **kwargs)\n            except KeyError:\n                return 0\n        self['role']['role'] = role\n\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, data, *args, **kwargs):\n        super(MambuUser, self).create(data)\n        self['user'][self.customFieldName] = self['customInformation']\n        self.init(attrs=self['user'])", "response": "Creates an user in MambuUser"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_attribute_adj_list(self, path):\n        att_mappings = self.get_attribute_mappings()\n\n        with open(path, mode=\"w\") as file:\n            for k, v in att_mappings.items():\n                print(\"{} {}\".format(k, \" \".join(str(e) for e in v)), file=file)", "response": "Write the bipartite attribute graph to a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_attribute_mappings(self):\n        att_ind_start = len(self.graph.vs)\n        att_mappings = defaultdict(list)\n        att_ind_end = self._add_differential_expression_attributes(att_ind_start, att_mappings)\n        if \"associated_diseases\" in self.graph.vs.attributes():\n            self._add_disease_association_attributes(att_ind_end, att_mappings)\n        return att_mappings", "response": "Get a dictionary of mappings between vertices and enumerated attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_differential_expression_attributes(self, att_ind_start, att_mappings):\n        up_regulated_ind = self.graph.vs.select(up_regulated_eq=True).indices\n        down_regulated_ind = self.graph.vs.select(down_regulated_eq=True).indices\n        rest_ind = self.graph.vs.select(diff_expressed_eq=False).indices\n\n        self._add_attribute_values(att_ind_start + 1, att_mappings, up_regulated_ind)\n        self._add_attribute_values(att_ind_start + 2, att_mappings, down_regulated_ind)\n        self._add_attribute_values(att_ind_start + 3, att_mappings, rest_ind)\n        return att_ind_start + 4", "response": "Add differential expression information to the attribute mapping dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_attribute_values(self, value, att_mappings, indices):\n        for i in indices:\n            att_mappings[i].append(value)", "response": "Add an attribute value to the given vertices."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd disease association information to the attribute mapping dictionary.", "response": "def _add_disease_association_attributes(self, att_ind_start, att_mappings):\n        \"\"\"Add disease association information to the attribute mapping dictionary.\n\n        :param int att_ind_start: Start index for enumerating the attributes.\n        :param dict att_mappings: Dictionary of mappings between vertices and enumerated attributes.\n        \"\"\"\n        disease_mappings = self.get_disease_mappings(att_ind_start)\n        for vertex in self.graph.vs:\n            assoc_diseases = vertex[\"associated_diseases\"]\n            if assoc_diseases is not None:\n                assoc_disease_ids = [disease_mappings[disease] for disease in assoc_diseases]\n                att_mappings[vertex.index].extend(assoc_disease_ids)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a dictionary of diseases and their numbers.", "response": "def get_disease_mappings(self, att_ind_start):\n        \"\"\"Get a dictionary of enumerations for diseases.\n\n        :param int att_ind_start: Starting index for enumeration.\n        :return: Dictionary of disease, number pairs.\n        \"\"\"\n        all_disease_ids = self.get_all_unique_diseases()\n        disease_enum = enumerate(all_disease_ids, start=att_ind_start)\n        disease_mappings = {}\n        for num, dis in disease_enum:\n            disease_mappings[dis] = num\n        return disease_mappings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all unique diseases that are known to the network.", "response": "def get_all_unique_diseases(self):\n        \"\"\"Get all unique diseases that are known to the network.\n\n        :return: All unique disease identifiers.\n        \"\"\"\n        all_disease_ids = self.graph.vs[\"associated_diseases\"]\n        # remove None values from list\n        all_disease_ids = [lst for lst in all_disease_ids if lst is not None]\n        # flatten list of lists, get unique elements\n        all_disease_ids = list(set([id for sublist in all_disease_ids for id in sublist]))\n        return all_disease_ids"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef page_view(url):\n\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(self: BaseState, *args, **kwargs):\n            user_id = self.request.user.id\n\n            try:\n                user_lang = await self.request.user.get_locale()\n            except NotImplementedError:\n                user_lang = ''\n\n            title = self.__class__.__name__\n\n            # noinspection PyTypeChecker\n            async for p in providers():\n                await p.page_view(url, title, user_id, user_lang)\n\n            return await func(self, *args, **kwargs)\n        return wrapper\n    return decorator", "response": "Decorator for state handler functions that logs a page view each time the handler gets called."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_cobol(lines):\n    output = []\n\n    intify = [\"level\", \"occurs\"]\n\n    # All in 1 line now, let's parse\n    for row in lines:\n        match = CobolPatterns.row_pattern.match(row.strip())\n\n        if not match:\n            _logger().warning(\"Found unmatched row %s\" % row.strip())\n            continue\n\n        match = match.groupdict()\n\n        for i in intify:\n            match[i] = int(match[i]) if match[i] is not None else None\n\n        if match['pic'] is not None:\n            match['pic_info'] = parse_pic_string(match['pic'])\n\n        output.append(match)\n    return output", "response": "Parses the COBOL line into a list of dictionaries containing the information of the item that was redefined."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean_names(lines, ensure_unique_names=False, strip_prefix=False,\n                make_database_safe=False):\n    \"\"\"\n    Clean the names.\n\n    Options to:\n     - strip prefixes on names\n     - enforce unique names\n     - make database safe names by converting - to _\n    \"\"\"\n    names = {}\n\n    for row in lines:\n        if strip_prefix:\n            row['name'] = row['name'][row['name'].find('-') + 1:]\n\n            if row['indexed_by'] is not None:\n                row['indexed_by'] = row['indexed_by'][row['indexed_by'].find(\n                    '-') + 1:]\n\n        if ensure_unique_names:\n            i = 1\n            while (row['name'] if i == 1 else\n                   row['name'] + \"-\" + str(i)) in names:\n                i += 1\n\n            names[row['name'] if i == 1 else row['name'] + \"-\" + str(i)] = 1\n\n            if i > 1:\n                row['name'] = row['name'] + \"-\" + str(i)\n\n        if make_database_safe:\n            row['name'] = row['name'].replace(\"-\", \"_\")\n    return lines", "response": "Clean the names.\n\n    Options to:\n     - strip prefixes on names\n     - enforce unique names\n     - make database safe names by converting - to _"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an application instance created from YAML.", "response": "def create_app_from_yml(path):\n    \"\"\"Return an application instance created from YAML.\"\"\"\n\n    try:\n        with open(path, \"rt\", encoding=\"UTF-8\") as f:\n            try:\n                # Substitute ALL occurrences of '%(here)s' with a path to a\n                # directory with '.holocron.yml'. Please note, we also want\n                # wrap the result into 'io.StringIO' in order to preserve\n                # original filename in 'yaml.safe_load()' errors.\n                interpolated = io.StringIO(f.read() % {\n                    \"here\": os.path.abspath(os.path.dirname(path))})\n                interpolated.name = f.name\n\n                conf = yaml.safe_load(interpolated)\n            except yaml.YAMLError as exc:\n                raise RuntimeError(\n                    \"Cannot parse a configuration file. Context: \" + str(exc))\n\n    except FileNotFoundError:\n        conf = {\"metadata\": None, \"pipes\": {}}\n\n    return core.create_app(conf[\"metadata\"], pipes=conf[\"pipes\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_logger(level):\n    class _Formatter(logging.Formatter):\n        def format(self, record):\n            record.levelname = record.levelname[:4]\n            return super(_Formatter, self).format(record)\n\n    # create stream handler with custom formatter\n    stream_handler = logging.StreamHandler()\n    stream_handler.setFormatter(_Formatter(\"[%(levelname)s] %(message)s\"))\n\n    # configure root logger\n    logger = logging.getLogger()\n    logger.addHandler(stream_handler)\n    logger.setLevel(level)\n\n    # capture warnings issued by 'warnings' module\n    logging.captureWarnings(True)", "response": "Configure a root logger to print records in pretty format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a command line interface and parses its arguments.", "response": "def parse_command_line(args):\n    \"\"\"\n    Builds a command line interface, and parses its arguments. Returns\n    an object with attributes, that are represent CLI arguments.\n\n    :param args: a list of command line arguments\n    :returns: a parsed object with cli options\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=(\n            \"Holocron is an easy and lightweight static blog generator, \"\n            \"based on markup text and Jinja2 templates.\"),\n        epilog=(\n            \"With no CONF, read .holocron.yml in the current working dir. \"\n            \"If no CONF found, the default settings will be used.\"))\n\n    parser.add_argument(\n        \"-c\", \"--conf\", dest=\"conf\", default=\".holocron.yml\",\n        help=\"set path to the settings file\")\n\n    parser.add_argument(\n        \"-q\", \"--quiet\", dest=\"verbosity\", action=\"store_const\",\n        const=logging.CRITICAL, help=\"show only critical errors\")\n\n    parser.add_argument(\n        \"-v\", \"--verbose\", dest=\"verbosity\", action=\"store_const\",\n        const=logging.INFO, help=\"show additional messages\")\n\n    parser.add_argument(\n        \"-d\", \"--debug\", dest=\"verbosity\", action=\"store_const\",\n        const=logging.DEBUG, help=\"show all messages\")\n\n    parser.add_argument(\n        \"--version\", action=\"version\",\n        version=pkg_resources.get_distribution(\"holocron\").version,\n        help=\"show the holocron version and exit\")\n\n    command_parser = parser.add_subparsers(\n        dest=\"command\", help=\"command to execute\")\n\n    run_parser = command_parser.add_parser(\"run\")\n    run_parser.add_argument(\"pipe\", help=\"a pipe to run\")\n\n    # parse cli and form arguments object\n    arguments = parser.parse_args(args)\n\n    # if no commands are specified display help\n    if arguments.command is None:\n        parser.print_help()\n        parser.exit(1)\n\n    return arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nyields the directory of the error file.", "response": "def _list_syntax_error():\n    \"\"\"\n    If we're going through a syntax error, add the directory of the error to\n    the watchlist.\n    \"\"\"\n\n    _, e, _ = sys.exc_info()\n    if isinstance(e, SyntaxError) and hasattr(e, 'filename'):\n        yield path.dirname(e.filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist all directories known to hold project code.", "response": "def list_dirs():\n    \"\"\"\n    List all directories known to hold project code.\n    \"\"\"\n\n    out = set()\n    out.update(_list_config_dirs())\n    out.update(_list_module_dirs())\n    out.update(_list_syntax_error())\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def start_child():\n\n    logger.info('Started to watch for code changes')\n\n    loop = asyncio.get_event_loop()\n    watcher = aionotify.Watcher()\n\n    flags = (\n        aionotify.Flags.MODIFY |\n        aionotify.Flags.DELETE |\n        aionotify.Flags.ATTRIB |\n        aionotify.Flags.MOVED_TO |\n        aionotify.Flags.MOVED_FROM |\n        aionotify.Flags.CREATE |\n        aionotify.Flags.DELETE_SELF |\n        aionotify.Flags.MOVE_SELF\n    )\n\n    watched_dirs = list_dirs()\n\n    for dir_name in watched_dirs:\n        watcher.watch(path=dir_name, flags=flags)\n\n    await watcher.setup(loop)\n\n    while True:\n        evt = await watcher.get_event()\n        file_path = path.join(evt.alias, evt.name)\n\n        if file_path in watched_dirs or file_path.endswith('.py'):\n            await asyncio.sleep(settings.CODE_RELOAD_DEBOUNCE)\n            break\n\n    watcher.close()\n    exit_for_reload()", "response": "Start the child process that will watch for changes in modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_parent():\n\n    while True:\n        args = [sys.executable] + sys.argv\n        new_environ = environ.copy()\n        new_environ[\"_IN_CHILD\"] = 'yes'\n        ret = subprocess.call(args, env=new_environ)\n\n        if ret != settings.CODE_RELOAD_EXIT:\n            return ret", "response": "Start the parent that will simply run the child forever until stopped."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_full_path(request):\n    path = request.path\n    if request.query_string:\n        path += '?' + to_native(request.query_string)\n    return path", "response": "Return the current relative path including the query string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to read a value named key from the GET parameters.", "response": "def get_from_params(request, key):\n    \"\"\"Try to read a value named ``key`` from the GET parameters.\n    \"\"\"\n    data = getattr(request, 'json', None) or request.values\n    value = data.get(key)\n    return to_native(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_from_headers(request, key):\n    value = request.headers.get(key)\n    return to_native(value)", "response": "Try to read a value named key from the request headers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_response(body, mimetype='text/html'):\n    from werkzeug.wrappers import Response\n    if isinstance(body, Response):\n        body.mimetype = mimetype\n        return body\n    return Response(body, mimetype=mimetype)", "response": "Build an HTPP response with the given body and mimetype."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def async_init(self):\n\n        self.pool = await aioredis.create_pool(\n            (self.host, self.port),\n            db=self.db_id,\n            minsize=self.min_pool_size,\n            maxsize=self.max_pool_size,\n            loop=asyncio.get_event_loop(),\n        )", "response": "Handle here the asynchronous part of the init."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize(d):\n    ret = {}\n    for k,v in d.items():\n        if not k.startswith('_'):\n            ret[k] = str(d[k])\n    #ret['__class__'] = obj.__class__.__name__\n    return ret", "response": "Serializes a dictionary of params to a dictionary of params skipping private attrs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing Git user config file.", "response": "def user_config(**kwargs):\n    \"\"\"\n    Initialize Git user config file.\n\n    :param kwargs: key/value pairs are stored in the git user config file.\n    \"\"\"\n    for kw in kwargs:\n        git('config --global user.%s \"%s\"' %(kw, kwargs.get(kw))).wait()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_header(self, token_type=None, signing_algorithm=None):\n        if not token_type:\n            token_type = self.token_type\n\n        if not signing_algorithm:\n            signing_algorithm = self.signing_algorithm\n\n        header = {'typ': token_type, 'alg': signing_algorithm}\n        return header", "response": "Make a JWT header"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_signature(self, header_b64, payload_b64, signing_key):\n        token_segments = [header_b64, payload_b64]\n        signing_input = b'.'.join(token_segments)\n\n        signer = self._get_signer(signing_key)\n        signer.update(signing_input)\n        signature = signer.finalize()\n\n        raw_signature = der_to_raw_signature(signature, signing_key.curve)\n        return base64url_encode(raw_signature)", "response": "Sign a serialized header and payload and return the urlsafe - base64 - encoded signature."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sign_single(self, payload, signing_key):\n        if not isinstance(payload, Mapping):\n            raise TypeError('Expecting a mapping object, as only '\n                            'JSON objects can be used as payloads.')\n\n        token_segments = []\n\n        signing_key = load_signing_key(signing_key, self.crypto_backend)\n\n        header = self._make_header()\n        header_b64 = base64url_encode(json_encode(header))\n        payload_b64 = base64url_encode(json_encode(payload))\n        signature_b64 = self._make_signature(header_b64, payload_b64, signing_key)\n\n        token_segments = [header_b64, payload_b64, signature_b64]\n\n        # combine the header, payload, and signature into a token and return it\n        token = b'.'.join(token_segments)\n        return token", "response": "Make a single - signature JWT."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _sign_multi(self, payload, signing_keys):\n        if not isinstance(payload, Mapping):\n            raise TypeError('Expecting a mapping object, as only '\n                            'JSON objects can be used as payloads.')\n\n        if not isinstance(signing_keys, list):\n            raise TypeError(\"Expecting a list of keys\")\n\n        headers = []\n        signatures = []\n        payload_b64 = base64url_encode(json_encode(payload))\n\n        for sk in signing_keys:\n            signing_key = load_signing_key(sk, self.crypto_backend)\n\n            header = self._make_header()\n            header_b64 = base64url_encode(json_encode(header))\n            signature_b64 = self._make_signature(header_b64, payload_b64, signing_key)\n\n            headers.append(header_b64)\n            signatures.append(signature_b64)\n\n        jwt = {\n            \"header\": headers,\n            \"payload\": payload_b64,\n            \"signature\": signatures\n        }\n\n        return jwt", "response": "Make a JSON - structured JWT with multiple signatures."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a compact - form serialized JWT with one or more keys.", "response": "def sign(self, payload, signing_key_or_keys):\n        \"\"\"\n        Create a JWT with one or more keys.\n        Returns a compact-form serialized JWT if there is only one key to sign with\n        Returns a JSON-structured serialized JWT if there are multiple keys to sign with\n        \"\"\"\n        if isinstance(signing_key_or_keys, list):\n            return self._sign_multi(payload, signing_key_or_keys)\n\n        else:\n            return self._sign_single(payload, signing_key_or_keys)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_reqs(req_path='./requirements/requirements.txt'):\n    install_requires = []\n    with codecs.open(req_path, 'r') as handle:\n        # remove comments and empty lines\n        lines = (line.strip() for line in handle\n                 if line.strip() and not line.startswith('#'))\n\n        for line in lines:\n            # check for nested requirements files\n            if line.startswith('-r'):\n                # recursively call this function\n                install_requires += parse_reqs(req_path=line[3:])\n            else:\n                # add the line as a new requirement\n                install_requires.append(line)\n\n    return install_requires", "response": "Recursively parse requirements from nested pip files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_readme():\n    # Get the long description from the relevant file\n    readme_file = str(Path(__file__).parent / 'README.rst')\n    with codecs.open(readme_file, encoding='utf-8') as handle:\n        long_description = handle.read()\n\n    return long_description", "response": "Parse the contents of the README file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the context for a specific request and state", "response": "def _make_context(self, request: 'Request'=None, state: Text=None):\n        \"\"\"\n        Build the context for a specific request/state\n        \"\"\"\n\n        if request:\n            self.client.user_context({\n                'id': request.user.id,\n            })\n            self.client.extra_context({\n                'message': repr(request.stack),\n                'register': make_rw(request.register),\n            })\n            self.client.tags_context({\n                'conversation_id': request.conversation.id,\n                'from_state': request.register.get(request.register.STATE),\n                'state': state,\n                'platform': request.platform,\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef report(self, request: 'Request'=None, state: Text=None):\n        self._make_context(request, state)\n        self.client.captureException()\n        self._clear_context()", "response": "Report current exception to Sentry."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the name and creates variations", "response": "def vary_name(name: Text):\n    \"\"\"\n    Validates the name and creates variations\n    \"\"\"\n\n    snake = re.match(r'^[a-z][a-z0-9]*(?:_[a-z0-9]+)*$', name)\n\n    if not snake:\n        fail('The project name is not a valid snake-case Python variable name')\n\n    camel = [x[0].upper() + x[1:] for x in name.split('_')]\n\n    return {\n        'project_name_snake': name,\n        'project_name_camel': ''.join(camel),\n        'project_name_readable': ' '.join(camel),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_random_key() -> Text:\n\n    r = SystemRandom()\n    allowed = \\\n        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_+/[]'\n\n    return ''.join([r.choice(allowed) for _ in range(0, 50)])", "response": "Generates a secure random string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the target path for a directory.", "response": "def make_dir_path(project_dir, root, project_name):\n    \"\"\"\n    Generates the target path for a directory\n    \"\"\"\n\n    root = root.replace('__project_name_snake__', project_name)\n    real_dir = path.realpath(project_dir)\n    return path.join(real_dir, root)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the target path for a file in a node.", "response": "def make_file_path(project_dir, project_name, root, name):\n    \"\"\"\n    Generates the target path for a file\n    \"\"\"\n\n    return path.join(make_dir_path(project_dir, root, project_name), name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_vars(project_name, project_dir):\n\n    out = vary_name(project_name)\n    out['random_key'] = make_random_key()\n    out['settings_file'] = make_file_path(\n        project_dir,\n        project_name,\n        path.join('src', project_name),\n        'settings.py',\n    )\n\n    return out", "response": "Generates the variables to replace in files\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_files():\n\n    files_root = path.join(path.dirname(__file__), 'files')\n\n    for root, dirs, files in walk(files_root):\n        rel_root = path.relpath(root, files_root)\n\n        for file_name in files:\n            try:\n                f = open(path.join(root, file_name), 'r', encoding='utf-8')\n                with f:\n                    yield rel_root, file_name, f.read(), True\n            except UnicodeError:\n                f = open(path.join(root, file_name), 'rb')\n                with f:\n                    yield rel_root, file_name, f.read(), False", "response": "Read all the template s files\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_target(target_path):\n\n    if not path.exists(target_path):\n        return\n\n    with scandir(target_path) as d:\n        for entry in d:\n            if not entry.name.startswith('.'):\n                fail(f'Target directory \"{target_path}\" is not empty')", "response": "Checks that the target path is not empty."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace variables inside the content.", "response": "def replace_content(content, project_vars):\n    \"\"\"\n    Replaces variables inside the content.\n    \"\"\"\n\n    for k, v in project_vars.items():\n        content = content.replace(f'__{k}__', v)\n\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_files(project_vars, project_dir, files):\n\n    for root, name, content, is_unicode in files:\n        project_name = project_vars['project_name_snake']\n\n        if is_unicode:\n            content = replace_content(content, project_vars)\n\n        file_path = make_file_path(project_dir, project_name, root, name)\n        makedirs(make_dir_path(project_dir, root, project_name), exist_ok=True)\n\n        if is_unicode:\n            with open(file_path, 'w') as f:\n                f.write(content)\n\n            if content.startswith('#!'):\n                chmod(file_path, 0o755)\n        else:\n            with open(file_path, 'wb') as f:\n                f.write(content)", "response": "Copy files from the template into the target location."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self):\n        for m in self.params['MEMBERS']:\n            m['ONLINE'] = 0\n            m.setdefault('STATUS', 'INVITED')\n\n        self.client = xmpp.Client(self.jid.getDomain(), debug=[])\n        conn = self.client.connect(server=self.params['SERVER'])\n        if not conn:\n            raise Exception(\"could not connect to server\")\n\n        auth = self.client.auth(self.jid.getNode(), self.params['PASSWORD'])\n        if not auth:\n            raise Exception(\"could not authenticate as chat server\")\n\n        #self.client.RegisterDisconnectHandler(self.on_disconnect)\n        self.client.RegisterHandler('message', self.on_message)\n        self.client.RegisterHandler('presence',self.on_presence)\n        self.client.sendInitPresence(requestRoster=0)\n\n        roster =  self.client.getRoster()\n        for m in self.params['MEMBERS']:\n            self.invite_user(m, roster=roster)", "response": "Connect to the chatroom s server sets up handlers invites members as needed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a chatroom member by JID", "response": "def get_member(self, jid, default=None):\n        \"\"\"Get a chatroom member by JID\"\"\"\n        member = filter(lambda m: m['JID'] == jid, self.params['MEMBERS'])\n        if len(member) == 1:\n            return member[0]\n        elif len(member) == 0:\n            return default\n        else:\n            raise Exception('Multple members have the same JID of [%s]' % (jid,))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a user is a member of the chatroom", "response": "def is_member(self, m):\n        \"\"\"Check if a user is a member of the chatroom\"\"\"\n        if not m:\n            return False\n        elif isinstance(m, basestring):\n            jid = m\n        else:\n            jid = m['JID']\n\n        is_member = len(filter(lambda m: m['JID'] == jid and m.get('STATUS') in ('ACTIVE', 'INVITED'), self.params['MEMBERS'])) > 0\n\n        return is_member"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninvite a new member to the chatroom", "response": "def invite_user(self, new_member, inviter=None, roster=None):\n        \"\"\"Invites a new member to the chatroom\"\"\"\n        roster = roster or self.client.getRoster()\n        jid = new_member['JID']\n\n        logger.info('roster %s %s' % (jid, roster.getSubscription(jid)))\n        if jid in roster.keys() and roster.getSubscription(jid) in ['both', 'to']:\n            new_member['STATUS'] = 'ACTIVE'\n            if inviter:\n                self.send_message('%s is already a member' % (jid,), inviter)\n        else:\n            new_member['STATUS'] = 'INVITED'\n            self.broadcast('inviting %s to the room' % (jid,))\n\n            #Add nickname according to http://xmpp.org/extensions/xep-0172.html\n            subscribe_presence = xmpp.dispatcher.Presence(to=jid, typ='subscribe')\n            if 'NICK' in self.params:\n                subscribe_presence.addChild(name='nick', namespace=xmpp.protocol.NS_NICK, payload=self.params['NICK'])\n            self.client.send(subscribe_presence)\n\n        if not self.is_member(new_member):\n            new_member.setdefault('NICK', jid.split('@')[0])\n            self.params['MEMBERS'].append(new_member)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef kick_user(self, jid):\n        for member in filter(lambda m: m['JID'] == jid, self.params['MEMBERS']):\n            member['STATUS'] = 'KICKED'\n            self.send_message('You have been kicked from %s' % (self.name,), member)\n\n            self.client.sendPresence(jid=member['JID'], typ='unsubscribed')\n            self.client.sendPresence(jid=member['JID'], typ='unsubscribe')\n            self.broadcast('kicking %s from the room' % (jid,))", "response": "Kicks a member from the chatroom."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a message to a single member.", "response": "def send_message(self, body, to, quiet=False, html_body=None):\n        \"\"\"Send a message to a single member\"\"\"\n        if to.get('MUTED'):\n            to['QUEUED_MESSAGES'].append(body)\n        else:\n            if not quiet:\n                logger.info('message on %s to %s: %s' % (self.name, to['JID'], body))\n\n            message = xmpp.protocol.Message(to=to['JID'], body=body, typ='chat')\n            if html_body:\n                html = xmpp.Node('html', {'xmlns': 'http://jabber.org/protocol/xhtml-im'})\n                html.addChild(node=xmpp.simplexml.XML2Node(\"<body xmlns='http://www.w3.org/1999/xhtml'>\" + html_body.encode('utf-8') + \"</body>\"))\n                message.addChild(node=html)\n\n            self.client.send(message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbroadcast a message to users in the chatroom", "response": "def broadcast(self, body, html_body=None, exclude=()):\n        \"\"\"Broadcast a message to users in the chatroom\"\"\"\n        logger.info('broadcast on %s: %s' % (self.name, body,))\n        for member in filter(lambda m: m.get('STATUS') == 'ACTIVE' and m not in exclude, self.params['MEMBERS']):\n            logger.debug(member['JID'])\n            self.send_message(body, member, html_body=html_body, quiet=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninvite members to the chatroom on a user s behalf", "response": "def do_invite(self, sender, body, args):\n        \"\"\"Invite members to the chatroom on a user's behalf\"\"\"\n        for invitee in args:\n            new_member = { 'JID': invitee }\n            self.invite_user(new_member, inviter=sender)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_kick(self, sender, body, args):\n        if sender.get('ADMIN') != True: return\n        for user in args:\n            self.kick_user(user)", "response": "Kick a member from the chatroom. Must be Admin to kick users"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_mute(self, sender, body, args):\n        if sender.get('MUTED'):\n            self.send_message('you are already muted', sender)\n        else:\n            self.broadcast('%s has muted this chatroom' % (sender['NICK'],))\n            sender['QUEUED_MESSAGES'] = []\n            sender['MUTED'] = True", "response": "Temporarily mutes a chatroom for a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_message(self, con, event):\n        msg_type = event.getType()\n        nick = event.getFrom().getResource()\n        from_jid = event.getFrom().getStripped()\n        body = event.getBody()\n\n        if msg_type == 'chat' and body is None:\n            return\n\n        logger.debug('msg_type[%s] from[%s] nick[%s] body[%s]' % (msg_type, from_jid, nick, body,))\n\n        sender = filter(lambda m: m['JID'] == from_jid, self.params['MEMBERS'])\n\n        should_process = msg_type in ['message', 'chat', None] and body is not None and len(sender) == 1\n        if not should_process: return\n        sender = sender[0]\n\n        try:\n            for p in self.command_patterns:\n                reg, cmd = p\n                m = reg.match(body)\n                if m:\n                    logger.info('pattern matched for bot command \\'%s\\'' % (cmd,))\n                    function = getattr(self, str(cmd), None)\n                    if function:\n                        return function(sender, body, m)\n\n            words = body.split(' ')\n            cmd, args = words[0], words[1:]\n            if cmd and cmd[0] == '/':\n                cmd = cmd[1:]\n                command_handler = getattr(self, 'do_'+cmd, None)\n                if command_handler:\n                    return command_handler(sender, body, args)\n\n            broadcast_body = '[%s] %s' % (sender['NICK'], body,)\n            return self.broadcast(broadcast_body, exclude=(sender,))\n        except:\n            logger.exception('Error handling message [%s] from [%s]' % (body, sender['JID']))", "response": "Handles a message from the bot"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pluralize_dj(value, arg='s'):\n    if ',' not in arg:\n        arg = ',' + arg\n    bits = arg.split(',')\n    if len(bits) > 2:\n        return ''\n    singular_suffix, plural_suffix = bits[:2]\n\n    try:\n        if int(value) != 1:\n            return plural_suffix\n    except ValueError:  # Invalid string that's not a number.\n        pass\n    except TypeError:  # Value isn't a string or a number; maybe it's a list?\n        try:\n            if len(value) != 1:\n                return plural_suffix\n        except TypeError:  # len() of unsized object.\n            pass\n    return singular_suffix", "response": "Returns a plural version of the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef activate(self):\n        d = dir(self)\n        self.plugins = []\n        for key in d:\n            if key.startswith(\"shell_activate_\"):\n                if self.echo:\n                    Console.ok(\"Shell Activate: {0}\".format(key))\n                self.plugins.append(key)\n        for key in d:\n            if key.startswith(\"activate_\"):\n                if self.echo:\n                    Console.ok(\"Activate: {0}\".format(key))\n                self.plugins.append(key)\n\n        for key in self.plugins:\n            if self.echo:\n                Console.ok(\"> {0}\".format(key.replace(\"_\", \" \", 1)))\n            exec (\"self.%s()\" % key)", "response": "method to activate all activation methods in the shell and its plugins."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist available commands with help or detailed help with help cmd", "response": "def do_help(self, arg):\n        \"\"\"List available commands with \"help\" or detailed help with \"help cmd\".\"\"\"\n\n        if arg:\n            # XXX check arg syntax\n            try:\n                func = getattr(self, 'help_' + arg)\n            except AttributeError:\n                try:\n                    doc = getattr(self, 'do_' + arg).__doc__\n                    if doc:\n                        self.stdout.write(\"%s\\n\" % str(doc))\n                        return\n                except AttributeError:\n                    pass\n                self.stdout.write(\"%s\\n\" % str(self.nohelp % (arg,)))\n                return\n            func()\n        else:\n            names = self.get_names()\n            cmds_doc = []\n            cmds_undoc = []\n            help_page = {}\n            for name in names:\n                if name[:5] == 'help_':\n                    help_page[name[5:]] = 1\n            names.sort()\n            # There can be duplicates if routines overridden\n            prevname = ''\n            for name in names:\n                if name[:3] == 'do_':\n                    if name == prevname:\n                        continue\n                    prevname = name\n                    cmd = name[3:]\n                    if cmd in help_page:\n                        cmds_doc.append(cmd)\n                        del help_page[cmd]\n                    elif getattr(self, name).__doc__:\n                        cmds_doc.append(cmd)\n                    else:\n                        cmds_undoc.append(cmd)\n\n            self.stdout.write(\"%s\\n\" % str(self.doc_leader))\n            self.print_topics(self.doc_header, cmds_doc, 15, 80)\n            self.print_topics(self.misc_header, list(help_page.keys()), 15, 80)\n            self.print_topics(self.undoc_header, cmds_undoc, 15, 80)\n\n            for topic in self.command_topics:\n                topic_cmds = self.command_topics[topic]\n                self.print_topics(string.capwords(topic + \" commands\"), topic_cmds, 15, 80)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fetch_channels(self):\n        json = requests.get(self._channels_url).json()\n        self._channels = {c['channel']['code']: c['channel']['name']\n                          for c in json['channels']}", "response": "Retrieve Ziggo channel information."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds out whether the media box is turned on or off.", "response": "def update_state(self):\n        \"\"\"Find out whether the media box is turned on/off.\"\"\"\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(self._timeout)\n        try:\n            if sock.connect_ex((self._ip, self._port['state'])) == 0:\n                self.state = True\n            else:\n                self.state = False\n            sock.close()\n        except socket.error:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_keys(self, keys):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(self._timeout)\n            sock.connect((self._ip, self._port['cmd']))\n            # mandatory dance\n            version_info = sock.recv(15)\n            sock.send(version_info)\n            sock.recv(2)\n            sock.send(bytes.fromhex('01'))\n            sock.recv(4)\n            sock.recv(24)\n            # send our command now!\n            for key in keys:\n                if key in self._keys:\n                    sock.send(bytes.fromhex(\"04 01 00 00 00 00 \" +\n                                            self._keys[key]))\n                    sock.send(bytes.fromhex(\"04 00 00 00 00 00 \" +\n                                            self._keys[key]))\n            sock.close()\n        except socket.error:\n            raise", "response": "Send keys to the device."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_echoicefield(echoices, *args, klass_name=None, **kwargs):\n    assert issubclass(echoices, EChoice)\n    value_type = echoices.__getvaluetype__()\n    if value_type is str:\n        cls_ = models.CharField\n    elif value_type is int:\n        cls_ = models.IntegerField\n    elif value_type is float:\n        cls_ = models.FloatField\n    elif value_type is bool:\n        cls_ = models.BooleanField\n    else:\n        raise NotImplementedError(\"Please open an issue if you wish your value type to be supported: \"\n                                  \"https://github.com/mbourqui/django-echoices/issues/new\")\n    if klass_name and StrictVersion(django_version()) < StrictVersion('1.9.0'):\n        warnings.warn(\"Django < 1.9 throws an 'ImportError' if the class name is not defined in the module. \"\n                      \"The provided klass_name will be replaced by {}\".format(EChoiceField.__name__), RuntimeWarning)\n    klass_name = EChoiceField.__name__ if StrictVersion(django_version()) < StrictVersion('1.9.0') else \\\n        klass_name if klass_name else \"{}Field\".format(echoices.__name__)\n    d = dict(cls_.__dict__)\n    d.update(dict(EChoiceField.__dict__))\n    return type(klass_name, (cls_,), d)(echoices, *args, **kwargs)", "response": "Returns a new derived field that is a subclass of the specified EChoice class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating value and throws ValidationError.", "response": "def validate(self, value, model_instance):\n        \"\"\"\n        Validates value and throws ValidationError. Subclasses should override\n        this to provide validation logic.\n        \"\"\"\n        return super(self.__class__, self).validate(value.value, model_instance)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_signing_key(signing_key, crypto_backend=default_backend()):\n    if isinstance(signing_key, EllipticCurvePrivateKey):\n        return signing_key\n\n    elif isinstance(signing_key, (str, unicode)):\n        invalid_strings = [b'-----BEGIN PUBLIC KEY-----']\n        invalid_string_matches = [\n            string_value in signing_key\n            for string_value in invalid_strings\n        ]\n        if any(invalid_string_matches):\n            raise ValueError(\n                'Signing key must be a private key, not a public key.')\n\n        if is_hex(signing_key):\n            try:\n                private_key_pem = ECPrivateKey(signing_key).to_pem()\n            except:\n                pass\n            else:\n                try:\n                    return load_pem_private_key(\n                        private_key_pem, password=None, backend=crypto_backend)\n                except:\n                    raise InvalidPrivateKeyError()\n\n            try:\n                return load_der_private_key(\n                    signing_key, password=None, backend=crypto_backend)\n            except Exception as e:\n                traceback.print_exc()\n                raise InvalidPrivateKeyError()\n        else:\n            try:\n                return load_pem_private_key(\n                    signing_key, password=None, backend=crypto_backend)\n            except:\n                raise InvalidPrivateKeyError()\n    else:\n        raise ValueError('Signing key must be in string or unicode format.')", "response": "Load a private key from the cryptography library."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a verifying key from the cryptography library.", "response": "def load_verifying_key(verifying_key, crypto_backend=default_backend()):\n    \"\"\" Optional: crypto backend object from the \"cryptography\" python library\n    \"\"\"\n    if isinstance(verifying_key, EllipticCurvePublicKey):\n        return verifying_key\n\n    elif isinstance(verifying_key, (str, unicode)):\n        if is_hex(verifying_key):\n            try:\n                public_key_pem = ECPublicKey(verifying_key).to_pem()\n            except:\n                pass\n            else:\n                try:\n                    return load_pem_public_key(\n                        public_key_pem, backend=crypto_backend)\n                except Exception as e:\n                    traceback.print_exc()\n                    raise InvalidPublicKeyError()\n\n            try:\n                return load_der_public_key(\n                    verifying_key, backend=crypto_backend)\n            except:\n                raise InvalidPublicKeyError()\n        else:\n            try:\n                return load_pem_public_key(\n                    verifying_key, backend=crypto_backend)\n            except Exception as e:\n                raise InvalidPublicKeyError()\n    else:\n        raise ValueError('Verifying key must be in string or unicode format.')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_dummy(instance,\n               relations        = {},\n               datetime_default = dt.strptime('1901-01-01','%Y-%m-%d'),\n               varchar_default  = \"\",\n               integer_default  = 0,\n               numeric_default  = 0.0,\n               *args, **kwargs\n              ):\n    \"\"\"Make an instance to look like an empty dummy.\n\n    Every field of the table is set with zeroes/empty strings.\n    Date fields are set to 01/01/1901.\n\n    * relations is a dictionary to set properties for relationships\n      on the instance.\n\n    The keys of the relations dictionary are the name of the fields to\n    be set at the instance.\n\n    The values of the relations dictionary must be 2 dimension tuples:\n\n    - first element will be the element to be related.\n\n    - second element will be the name of the backref set on the previous\n      first element of the tuple, as a list containing the instance.\n\n    If you wish that no backref to be set you may use any invalid value\n    for a property name, anything other than a string, for example a\n    number. Preferably, use None.\n\n    * datetime_default is the datetime object to use for init datetime\n      fields. Defaults to 01-01-1901\n\n    * varchar_default is the string object to use for init varchar\n      fields. Defaults to \"\"\n\n    * integer_default is the int object to use for init integer\n      fields. Defaults to 0\n\n    * numeric_default is the float object to use for init numeric\n      fields. Defaults to 0.0\n\n    * kwargs may have the name of a certain field you wish to initialize\n      with a value other than the given by the init_data dicionary. If you\n      give an unexistent name on the columns of the table, they are safely\n      ignored.\n\n    .. todo:: further field types may be set at the init_data dictionary.\n\"\"\"\n\n    # init_data knows how to put an init value depending on data type\n    init_data = {\n        'DATETIME'        : datetime_default,\n        'VARCHAR'         : varchar_default,\n        'INTEGER'         : integer_default,\n        'NUMERIC(50, 10)' : numeric_default,\n        'TEXT'            : varchar_default,\n        }\n\n    # the type of the instance is the SQLAlchemy Table\n    table = type(instance)\n\n    for col in table.__table__.columns:\n        # declarative base tables have a columns property useful for reflection\n        try:\n            setattr(instance, col.name, kwargs[col.name])\n        except KeyError:\n            setattr(instance, col.name, init_data[str(col.type)])\n\n    for k,v in relations.iteritems():\n        # set the relationship property with the first element of the tuple\n        setattr(instance, k, v[0])\n        # try:\n        #     # set the relationship backref on the first element of the tuple\n        #     # with a property named according to the second element of the\n        #     # tuple, pointing to a list with the instance itself (assumes a\n        #     # one-to-many relationship)\n        #     # in case you don't want a backref, just send a None as v[1]\n        #     try:\n        #         getattr(v[0], v[1]).append(instance)\n        #     except:\n        #         setattr(v[0], v[1], [ instance ])\n        # except:\n        #     pass\n\n    return instance", "response": "Make an empty dummy object for the given instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets up the network.", "response": "def set_up_network(\n            self,\n            genes: List[Gene],\n            gene_filter: bool = False,\n            disease_associations: Optional[Dict] = None\n    ) -> None:\n        \"\"\"Set up the network.\n\n         Filter genes out if requested and add attributes to the vertices.\n\n        :param genes: A list of Gene objects.\n        :param gene_filter: Removes all genes that are not in list <genes> if True.\n        :param disease_associations: Diseases associated with genes.\n        \"\"\"\n        if gene_filter:\n            self.filter_genes([gene.entrez_id for gene in genes])\n        self._add_vertex_attributes(genes, disease_associations)\n        self.print_summary(\"Graph of all genes\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering out the genes that are not in list relevant_entrez.", "response": "def filter_genes(self, relevant_entrez: list) -> None:\n        \"\"\"Filter out the genes that are not in list relevant_entrez.\n\n        :param list relevant_entrez: Entrez IDs of genes which are to be kept.\n        \"\"\"\n        logger.info(\"In filter_genes()\")\n        irrelevant_genes = self.graph.vs.select(name_notin=relevant_entrez)\n        self.graph.delete_vertices(irrelevant_genes)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd attributes to vertices.", "response": "def _add_vertex_attributes(self, genes: List[Gene],\n                               disease_associations: Optional[dict] = None) -> None:\n        \"\"\"Add attributes to vertices.\n\n        :param genes: A list of genes containing attribute information.\n        \"\"\"\n        self._set_default_vertex_attributes()\n        self._add_vertex_attributes_by_genes(genes)\n\n        # compute up-regulated and down-regulated genes\n        up_regulated = self.get_upregulated_genes()\n        down_regulated = self.get_downregulated_genes()\n\n        # set the attributes for up-regulated and down-regulated genes\n        self.graph.vs(up_regulated.indices)[\"diff_expressed\"] = True\n        self.graph.vs(up_regulated.indices)[\"up_regulated\"] = True\n        self.graph.vs(down_regulated.indices)[\"diff_expressed\"] = True\n        self.graph.vs(down_regulated.indices)[\"down_regulated\"] = True\n\n        # add disease associations\n        self._add_disease_associations(disease_associations)\n\n        logger.info(\"Number of all differentially expressed genes is: {}\".\n                    format(len(up_regulated) + len(down_regulated)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nassigns default values on attributes to all vertices.", "response": "def _set_default_vertex_attributes(self) -> None:\n        \"\"\"Assign default values on attributes to all vertices.\"\"\"\n        self.graph.vs[\"l2fc\"] = 0\n        self.graph.vs[\"padj\"] = 0.5\n        self.graph.vs[\"symbol\"] = self.graph.vs[\"name\"]\n        self.graph.vs[\"diff_expressed\"] = False\n        self.graph.vs[\"up_regulated\"] = False\n        self.graph.vs[\"down_regulated\"] = False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_vertex_attributes_by_genes(self, genes: List[Gene]) -> None:\n        for gene in genes:\n            try:\n                vertex = self.graph.vs.find(name=str(gene.entrez_id)).index\n                self.graph.vs[vertex]['l2fc'] = gene.log2_fold_change\n                self.graph.vs[vertex]['symbol'] = gene.symbol\n                self.graph.vs[vertex]['padj'] = gene.padj\n            except ValueError:\n                pass", "response": "Assign values to attributes on vertices."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the disease - gene associations to the network.", "response": "def _add_disease_associations(self, disease_associations: dict) -> None:\n        \"\"\"Add disease association annotation to the network.\n\n        :param disease_associations: Dictionary of disease-gene associations.\n        \"\"\"\n        if disease_associations is not None:\n            for target_id, disease_id_list in disease_associations.items():\n                if target_id in self.graph.vs[\"name\"]:\n                    self.graph.vs.find(name=target_id)[\"associated_diseases\"] = disease_id_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget genes that are up - regulated.", "response": "def get_upregulated_genes(self) -> VertexSeq:\n        \"\"\"Get genes that are up-regulated.\n\n        :return: Up-regulated genes.\n        \"\"\"\n        up_regulated = self.graph.vs.select(self._is_upregulated_gene)\n        logger.info(f\"No. of up-regulated genes after laying on network: {len(up_regulated)}\")\n        return up_regulated"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_downregulated_genes(self) -> VertexSeq:\n        down_regulated = self.graph.vs.select(self._is_downregulated_gene)\n        logger.info(f\"No. of down-regulated genes after laying on network: {len(down_regulated)}\")\n        return down_regulated", "response": "Get genes that are down - regulated."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints the summary of a graph.", "response": "def print_summary(self, heading: str) -> None:\n        \"\"\"Print the summary of a graph.\n\n        :param str heading: Title of the graph.\n        \"\"\"\n        logger.info(heading)\n        logger.info(\"Number of nodes: {}\".format(len(self.graph.vs)))\n        logger.info(\"Number of edges: {}\".format(len(self.graph.es)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_differentially_expressed_genes(self, diff_type: str) -> VertexSeq:\n        if diff_type == \"up\":\n            diff_expr = self.graph.vs.select(up_regulated_eq=True)\n        elif diff_type == \"down\":\n            diff_expr = self.graph.vs.select(down_regulated_eq=True)\n        else:\n            diff_expr = self.graph.vs.select(diff_expressed_eq=True)\n        return diff_expr", "response": "Get the differentially expressed genes based on diff_type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the network as an adjacency list to a file.", "response": "def write_adj_list(self, path: str) -> None:\n        \"\"\"Write the network as an adjacency list to a file.\n\n        :param path: File path to write the adjacency list.\n        \"\"\"\n        adj_list = self.get_adjlist()\n\n        with open(path, mode=\"w\") as file:\n            for i, line in enumerate(adj_list):\n                print(i, *line, file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_attribute_from_indices(self, indices: list, attribute_name: str):\n        return list(np.array(self.graph.vs[attribute_name])[indices])", "response": "Get the attribute values for the requested indices."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning error numbers for all errors in errnames on this platform.", "response": "def plat_specific_errors(*errnames):\n    \"\"\"Return error numbers for all errors in errnames on this platform.\n    \n    The 'errno' module contains different global constants depending on\n    the specific platform (OS). This function will return the list of\n    numeric values for a given list of potential names.\n    \"\"\"\n    errno_names = dir(errno)\n    nums = [getattr(errno, k) for k in errnames if k in errno_names]\n    # de-dupe the list\n    return dict.fromkeys(nums).keys()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_headers(rfile, hdict=None):\n    if hdict is None:\n        hdict = {}\n    \n    while True:\n        line = rfile.readline()\n        if not line:\n            # No more data--illegal end of headers\n            raise ValueError(\"Illegal end of headers.\")\n        \n        if line == CRLF:\n            # Normal end of headers\n            break\n        if not line.endswith(CRLF):\n            raise ValueError(\"HTTP requires CRLF terminators\")\n        \n        if line[0] in ' \\t':\n            # It's a continuation line.\n            v = line.strip()\n        else:\n            try:\n                k, v = line.split(\":\", 1)\n            except ValueError:\n                raise ValueError(\"Illegal header line.\")\n            # TODO: what about TE and WWW-Authenticate?\n            k = k.strip().title()\n            v = v.strip()\n            hname = k\n        \n        if k in comma_separated_headers:\n            existing = hdict.get(hname)\n            if existing:\n                v = \", \".join((existing, v))\n        hdict[hname] = v\n    \n    return hdict", "response": "Read headers from the given stream into the given header dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nliking print_exc but return a string. Backport for Python 2. 3.", "response": "def format_exc(limit=None):\n    \"\"\"Like print_exc() but return a string. Backport for Python 2.3.\"\"\"\n    try:\n        etype, value, tb = sys.exc_info()\n        return ''.join(traceback.format_exception(etype, value, tb, limit))\n    finally:\n        etype = value = tb = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the next HTTP request start - line and message - headers.", "response": "def parse_request(self):\n        \"\"\"Parse the next HTTP request start-line and message-headers.\"\"\"\n        self.rfile = SizeCheckWrapper(self.conn.rfile,\n                                      self.server.max_request_header_size)\n        try:\n            self.read_request_line()\n        except MaxSizeExceeded:\n            self.simple_response(\"414 Request-URI Too Long\",\n                \"The Request-URI sent with the request exceeds the maximum \"\n                \"allowed bytes.\")\n            return\n        \n        try:\n            success = self.read_request_headers()\n        except MaxSizeExceeded:\n            self.simple_response(\"413 Request Entity Too Large\",\n                \"The headers sent with the request exceed the maximum \"\n                \"allowed bytes.\")\n            return\n        else:\n            if not success:\n                return\n        \n        self.ready = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the HTTP headers into the internal inheaders. Return success.", "response": "def read_request_headers(self):\n        \"\"\"Read self.rfile into self.inheaders. Return success.\"\"\"\n        \n        # then all the http headers\n        try:\n            read_headers(self.rfile, self.inheaders)\n        except ValueError, ex:\n            self.simple_response(\"400 Bad Request\", ex.args[0])\n            return False\n        \n        mrbs = self.server.max_request_body_size\n        if mrbs and int(self.inheaders.get(\"Content-Length\", 0)) > mrbs:\n            self.simple_response(\"413 Request Entity Too Large\",\n                \"The entity sent with the request exceeds the maximum \"\n                \"allowed bytes.\")\n            return False\n        \n        # Persistent connection support\n        if self.response_protocol == \"HTTP/1.1\":\n            # Both server and client are HTTP/1.1\n            if self.inheaders.get(\"Connection\", \"\") == \"close\":\n                self.close_connection = True\n        else:\n            # Either the server or client (or both) are HTTP/1.0\n            if self.inheaders.get(\"Connection\", \"\") != \"Keep-Alive\":\n                self.close_connection = True\n        \n        # Transfer-Encoding support\n        te = None\n        if self.response_protocol == \"HTTP/1.1\":\n            te = self.inheaders.get(\"Transfer-Encoding\")\n            if te:\n                te = [x.strip().lower() for x in te.split(\",\") if x.strip()]\n        \n        self.chunked_read = False\n        \n        if te:\n            for enc in te:\n                if enc == \"chunked\":\n                    self.chunked_read = True\n                else:\n                    # Note that, even if we see \"chunked\", we must reject\n                    # if there is an extension we don't recognize.\n                    self.simple_response(\"501 Unimplemented\")\n                    self.close_connection = True\n                    return False\n        \n        # From PEP 333:\n        # \"Servers and gateways that implement HTTP 1.1 must provide\n        # transparent support for HTTP 1.1's \"expect/continue\" mechanism.\n        # This may be done in any of several ways:\n        #   1. Respond to requests containing an Expect: 100-continue request\n        #      with an immediate \"100 Continue\" response, and proceed normally.\n        #   2. Proceed with the request normally, but provide the application\n        #      with a wsgi.input stream that will send the \"100 Continue\"\n        #      response if/when the application first attempts to read from\n        #      the input stream. The read request must then remain blocked\n        #      until the client responds.\n        #   3. Wait until the client decides that the server does not support\n        #      expect/continue, and sends the request body on its own.\n        #      (This is suboptimal, and is not recommended.)\n        #\n        # We used to do 3, but are now doing 1. Maybe we'll do 2 someday,\n        # but it seems like it would be a big slowdown for such a rare case.\n        if self.inheaders.get(\"Expect\", \"\") == \"100-continue\":\n            # Don't use simple_response here, because it emits headers\n            # we don't want. See http://www.cherrypy.org/ticket/951\n            msg = self.server.protocol + \" 100 Continue\\r\\n\\r\\n\"\n            try:\n                self.conn.wfile.sendall(msg)\n            except socket.error, x:\n                if x.args[0] not in socket_errors_to_ignore:\n                    raise\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_request_uri(self, uri):\n        if uri == \"*\":\n            return None, None, uri\n        \n        i = uri.find('://')\n        if i > 0 and '?' not in uri[:i]:\n            # An absoluteURI.\n            # If there's a scheme (and it must be http or https), then:\n            # http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\n            scheme, remainder = uri[:i].lower(), uri[i + 3:]\n            authority, path = remainder.split(\"/\", 1)\n            return scheme, authority, path\n        \n        if uri.startswith('/'):\n            # An abs_path.\n            return None, None, uri\n        else:\n            # An authority.\n            return None, uri, None", "response": "Parse a Request - URI into scheme authority path and paramaters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls the gateway and write its iterable output.", "response": "def respond(self):\n        \"\"\"Call the gateway and write its iterable output.\"\"\"\n        mrbs = self.server.max_request_body_size\n        if self.chunked_read:\n            self.rfile = ChunkedRFile(self.conn.rfile, mrbs)\n        else:\n            cl = int(self.inheaders.get(\"Content-Length\", 0))\n            if mrbs and mrbs < cl:\n                if not self.sent_headers:\n                    self.simple_response(\"413 Request Entity Too Large\",\n                        \"The entity sent with the request exceeds the maximum \"\n                        \"allowed bytes.\")\n                return\n            self.rfile = KnownLengthRFile(self.conn.rfile, cl)\n        \n        self.server.gateway(self).respond()\n        \n        if (self.ready and not self.sent_headers):\n            self.sent_headers = True\n            self.send_headers()\n        if self.chunked_write:\n            self.conn.wfile.sendall(\"0\\r\\n\\r\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef simple_response(self, status, msg=\"\"):\n        status = str(status)\n        buf = [self.server.protocol + \" \" +\n               status + CRLF,\n               \"Content-Length: %s\\r\\n\" % len(msg),\n               \"Content-Type: text/plain\\r\\n\"]\n        \n        if status[:3] in (\"413\", \"414\"):\n            # Request Entity Too Large / Request-URI Too Long\n            self.close_connection = True\n            if self.response_protocol == 'HTTP/1.1':\n                # This will not be true for 414, since read_request_line\n                # usually raises 414 before reading the whole line, and we\n                # therefore cannot know the proper response_protocol.\n                buf.append(\"Connection: close\\r\\n\")\n            else:\n                # HTTP/1.0 had no 413/414 status nor Connection header.\n                # Emit 400 instead and trust the message body is enough.\n                status = \"400 Bad Request\"\n        \n        buf.append(CRLF)\n        if msg:\n            if isinstance(msg, unicode):\n                msg = msg.encode(\"ISO-8859-1\")\n            buf.append(msg)\n        \n        try:\n            self.conn.wfile.sendall(\"\".join(buf))\n        except socket.error, x:\n            if x.args[0] not in socket_errors_to_ignore:\n                raise", "response": "Write a simple response back to the client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite unbuffered data to the client.", "response": "def write(self, chunk):\n        \"\"\"Write unbuffered data to the client.\"\"\"\n        if self.chunked_write and chunk:\n            buf = [hex(len(chunk))[2:], CRLF, chunk, CRLF]\n            self.conn.wfile.sendall(\"\".join(buf))\n        else:\n            self.conn.wfile.sendall(chunk)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_headers(self):\n        hkeys = [key.lower() for key, value in self.outheaders]\n        status = int(self.status[:3])\n        \n        if status == 413:\n            # Request Entity Too Large. Close conn to avoid garbage.\n            self.close_connection = True\n        elif \"content-length\" not in hkeys:\n            # \"All 1xx (informational), 204 (no content),\n            # and 304 (not modified) responses MUST NOT\n            # include a message-body.\" So no point chunking.\n            if status < 200 or status in (204, 205, 304):\n                pass\n            else:\n                if (self.response_protocol == 'HTTP/1.1'\n                    and self.method != 'HEAD'):\n                    # Use the chunked transfer-coding\n                    self.chunked_write = True\n                    self.outheaders.append((\"Transfer-Encoding\", \"chunked\"))\n                else:\n                    # Closing the conn is the only way to determine len.\n                    self.close_connection = True\n        \n        if \"connection\" not in hkeys:\n            if self.response_protocol == 'HTTP/1.1':\n                # Both server and client are HTTP/1.1 or better\n                if self.close_connection:\n                    self.outheaders.append((\"Connection\", \"close\"))\n            else:\n                # Server and/or client are HTTP/1.0\n                if not self.close_connection:\n                    self.outheaders.append((\"Connection\", \"Keep-Alive\"))\n        \n        if (not self.close_connection) and (not self.chunked_read):\n            # Read any remaining request body data on the socket.\n            # \"If an origin server receives a request that does not include an\n            # Expect request-header field with the \"100-continue\" expectation,\n            # the request includes a request body, and the server responds\n            # with a final status code before reading the entire request body\n            # from the transport connection, then the server SHOULD NOT close\n            # the transport connection until it has read the entire request,\n            # or until the client closes the connection. Otherwise, the client\n            # might not reliably receive the response message. However, this\n            # requirement is not be construed as preventing a server from\n            # defending itself against denial-of-service attacks, or from\n            # badly broken client implementations.\"\n            remaining = getattr(self.rfile, 'remaining', 0)\n            if remaining > 0:\n                self.rfile.read(remaining)\n        \n        if \"date\" not in hkeys:\n            self.outheaders.append((\"Date\", rfc822.formatdate()))\n        \n        if \"server\" not in hkeys:\n            self.outheaders.append((\"Server\", self.server.server_name))\n        \n        buf = [self.server.protocol + \" \" + self.status + CRLF]\n        for k, v in self.outheaders:\n            buf.append(k + \": \" + v + CRLF)\n        buf.append(CRLF)\n        self.conn.wfile.sendall(\"\".join(buf))", "response": "Assert process and send the HTTP response message - headers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef communicate(self):\n        request_seen = False\n        try:\n            while True:\n                # (re)set req to None so that if something goes wrong in\n                # the RequestHandlerClass constructor, the error doesn't\n                # get written to the previous request.\n                req = None\n                req = self.RequestHandlerClass(self.server, self)\n                \n                # This order of operations should guarantee correct pipelining.\n                req.parse_request()\n                if not req.ready:\n                    # Something went wrong in the parsing (and the server has\n                    # probably already made a simple_response). Return and\n                    # let the conn close.\n                    return\n                \n                request_seen = True\n                req.respond()\n                if req.close_connection:\n                    return\n        except socket.error, e:\n            errnum = e.args[0]\n            # sadly SSL sockets return a different (longer) time out string\n            if errnum == 'timed out' or errnum == 'The read operation timed out':\n                # Don't error if we're between requests; only error\n                # if 1) no request has been started at all, or 2) we're\n                # in the middle of a request.\n                # See http://www.cherrypy.org/ticket/853\n                if (not request_seen) or (req and req.started_request):\n                    # Don't bother writing the 408 if the response\n                    # has already started being written.\n                    if req and not req.sent_headers:\n                        try:\n                            req.simple_response(\"408 Request Timeout\")\n                        except FatalSSLAlert:\n                            # Close the connection.\n                            return\n            elif errnum not in socket_errors_to_ignore:\n                if req and not req.sent_headers:\n                    try:\n                        req.simple_response(\"500 Internal Server Error\",\n                                            format_exc())\n                    except FatalSSLAlert:\n                        # Close the connection.\n                        return\n            return\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except FatalSSLAlert:\n            # Close the connection.\n            return\n        except NoSSLError:\n            if req and not req.sent_headers:\n                # Unwrap our wfile\n                self.wfile = CP_fileobject(self.socket._sock, \"wb\", self.wbufsize)\n                req.simple_response(\"400 Bad Request\",\n                    \"The client sent a plain HTTP request, but \"\n                    \"this server only speaks HTTPS on this port.\")\n                self.linger = True\n        except Exception:\n            if req and not req.sent_headers:\n                try:\n                    req.simple_response(\"500 Internal Server Error\", format_exc())\n                except FatalSSLAlert:\n                    # Close the connection.\n                    return", "response": "Read each request and respond appropriately."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        self.rfile.close()\n        \n        if not self.linger:\n            # Python's socket module does NOT call close on the kernel socket\n            # when you call socket.close(). We do so manually here because we\n            # want this server to send a FIN TCP segment immediately. Note this\n            # must be called *before* calling socket.close(), because the latter\n            # drops its reference to the kernel socket.\n            if hasattr(self.socket, '_sock'):\n                self.socket._sock.close()\n            self.socket.close()\n        else:\n            # On the other hand, sometimes we want to hang around for a bit\n            # to make sure the client has a chance to read our entire\n            # response. Skipping the close() calls here delays the FIN\n            # packet until the socket object is garbage-collected later.\n            # Someday, perhaps, we'll do the full lingering_close that\n            # Apache does, but not today.\n            pass", "response": "Close the socket underlying this connection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart the pool of threads.", "response": "def start(self):\n        \"\"\"Start the pool of threads.\"\"\"\n        for i in range(self.min):\n            self._threads.append(WorkerThread(self.server))\n        for worker in self._threads:\n            worker.setName(\"CP Server \" + worker.getName())\n            worker.start()\n        for worker in self._threads:\n            while not worker.ready:\n                time.sleep(.1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngrows the pool of worker threads.", "response": "def grow(self, amount):\n        \"\"\"Spawn new worker threads (not above self.max).\"\"\"\n        for i in range(amount):\n            if self.max > 0 and len(self._threads) >= self.max:\n                break\n            worker = WorkerThread(self.server)\n            worker.setName(\"CP Server \" + worker.getName())\n            self._threads.append(worker)\n            worker.start()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shrink(self, amount):\n        # Grow/shrink the pool if necessary.\n        # Remove any dead threads from our list\n        for t in self._threads:\n            if not t.isAlive():\n                self._threads.remove(t)\n                amount -= 1\n        \n        if amount > 0:\n            for i in range(min(amount, len(self._threads) - self.min)):\n                # Put a number of shutdown requests on the queue equal\n                # to 'amount'. Once each of those is processed by a worker,\n                # that worker will terminate and be culled from our list\n                # in self.put.\n                self._queue.put(_SHUTDOWNREQUEST)", "response": "Kills off worker threads and shrinks the pool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the server forever.", "response": "def start(self):\n        \"\"\"Run the server forever.\"\"\"\n        # We don't have to trap KeyboardInterrupt or SystemExit here,\n        # because cherrpy.server already does so, calling self.stop() for us.\n        # If you're using this server with another framework, you should\n        # trap those exceptions in whatever code block calls start().\n        self._interrupt = None\n        \n        if self.software is None:\n            self.software = \"%s Server\" % self.version\n        \n        # SSL backward compatibility\n        if (self.ssl_adapter is None and\n            getattr(self, 'ssl_certificate', None) and\n            getattr(self, 'ssl_private_key', None)):\n            warnings.warn(\n                    \"SSL attributes are deprecated in CherryPy 3.2, and will \"\n                    \"be removed in CherryPy 3.3. Use an ssl_adapter attribute \"\n                    \"instead.\",\n                    DeprecationWarning\n                )\n            try:\n                from cherrypy.wsgiserver.ssl_pyopenssl import pyOpenSSLAdapter\n            except ImportError:\n                pass\n            else:\n                self.ssl_adapter = pyOpenSSLAdapter(\n                    self.ssl_certificate, self.ssl_private_key,\n                    getattr(self, 'ssl_certificate_chain', None))\n        \n        # Select the appropriate socket\n        if isinstance(self.bind_addr, basestring):\n            # AF_UNIX socket\n            \n            # So we can reuse the socket...\n            try: os.unlink(self.bind_addr)\n            except: pass\n            \n            # So everyone can access the socket...\n            try: os.chmod(self.bind_addr, 0777)\n            except: pass\n            \n            info = [(socket.AF_UNIX, socket.SOCK_STREAM, 0, \"\", self.bind_addr)]\n        else:\n            # AF_INET or AF_INET6 socket\n            # Get the correct address family for our host (allows IPv6 addresses)\n            host, port = self.bind_addr\n            try:\n                info = socket.getaddrinfo(host, port, socket.AF_UNSPEC,\n                                          socket.SOCK_STREAM, 0, socket.AI_PASSIVE)\n            except socket.gaierror:\n                if ':' in self.bind_addr[0]:\n                    info = [(socket.AF_INET6, socket.SOCK_STREAM,\n                             0, \"\", self.bind_addr + (0, 0))]\n                else:\n                    info = [(socket.AF_INET, socket.SOCK_STREAM,\n                             0, \"\", self.bind_addr)]\n        \n        self.socket = None\n        msg = \"No socket could be created\"\n        for res in info:\n            af, socktype, proto, canonname, sa = res\n            try:\n                self.bind(af, socktype, proto)\n            except socket.error:\n                if self.socket:\n                    self.socket.close()\n                self.socket = None\n                continue\n            break\n        if not self.socket:\n            raise socket.error(msg)\n        \n        # Timeout so KeyboardInterrupt can be caught on Win32\n        self.socket.settimeout(1)\n        self.socket.listen(self.request_queue_size)\n        \n        # Create worker threads\n        self.requests.start()\n        \n        self.ready = True\n        while self.ready:\n            self.tick()\n            if self.interrupt:\n                while self.interrupt is True:\n                    # Wait for self.stop() to complete. See _set_interrupt.\n                    time.sleep(0.1)\n                if self.interrupt:\n                    raise self.interrupt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bind(self, family, type, proto=0):\n        self.socket = socket.socket(family, type, proto)\n        prevent_socket_inheritance(self.socket)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if self.nodelay and not isinstance(self.bind_addr, str):\n            self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n        \n        if self.ssl_adapter is not None:\n            self.socket = self.ssl_adapter.bind(self.socket)\n        \n        # If listening on the IPV6 any address ('::' = IN6ADDR_ANY),\n        # activate dual-stack. See http://www.cherrypy.org/ticket/871.\n        if (family == socket.AF_INET6\n            and self.bind_addr[0] in ('::', '::0', '::0.0.0.0')):\n            try:\n                self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)\n            except (AttributeError, socket.error):\n                # Apparently, the socket option is not available in\n                # this machine's TCP stack\n                pass\n        \n        self.socket.bind(self.bind_addr)", "response": "Create or recreate the actual socket object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccept a new connection and put it on the Queue.", "response": "def tick(self):\n        \"\"\"Accept a new connection and put it on the Queue.\"\"\"\n        try:\n            s, addr = self.socket.accept()\n            if not self.ready:\n                return\n            \n            prevent_socket_inheritance(s)\n            if hasattr(s, 'settimeout'):\n                s.settimeout(self.timeout)\n            \n            makefile = CP_fileobject\n            ssl_env = {}\n            # if ssl cert and key are set, we try to be a secure HTTP server\n            if self.ssl_adapter is not None:\n                try:\n                    s, ssl_env = self.ssl_adapter.wrap(s)\n                except NoSSLError:\n                    msg = (\"The client sent a plain HTTP request, but \"\n                           \"this server only speaks HTTPS on this port.\")\n                    buf = [\"%s 400 Bad Request\\r\\n\" % self.protocol,\n                           \"Content-Length: %s\\r\\n\" % len(msg),\n                           \"Content-Type: text/plain\\r\\n\\r\\n\",\n                           msg]\n                    \n                    wfile = CP_fileobject(s, \"wb\", DEFAULT_BUFFER_SIZE)\n                    try:\n                        wfile.sendall(\"\".join(buf))\n                    except socket.error, x:\n                        if x.args[0] not in socket_errors_to_ignore:\n                            raise\n                    return\n                if not s:\n                    return\n                makefile = self.ssl_adapter.makefile\n                # Re-apply our timeout since we may have a new socket object\n                if hasattr(s, 'settimeout'):\n                    s.settimeout(self.timeout)\n            \n            conn = self.ConnectionClass(self, s, makefile)\n            \n            if not isinstance(self.bind_addr, basestring):\n                # optional values\n                # Until we do DNS lookups, omit REMOTE_HOST\n                if addr is None: # sometimes this can happen\n                    # figure out if AF_INET or AF_INET6.\n                    if len(s.getsockname()) == 2:\n                        # AF_INET\n                        addr = ('0.0.0.0', 0)\n                    else:\n                        # AF_INET6\n                        addr = ('::', 0)\n                conn.remote_addr = addr[0]\n                conn.remote_port = addr[1]\n            \n            conn.ssl_env = ssl_env\n            \n            self.requests.put(conn)\n        except socket.timeout:\n            # The only reason for the timeout in start() is so we can\n            # notice keyboard interrupts on Win32, which don't interrupt\n            # accept() by default\n            return\n        except socket.error, x:\n            if x.args[0] in socket_error_eintr:\n                # I *think* this is right. EINTR should occur when a signal\n                # is received during the accept() call; all docs say retry\n                # the call, and I *think* I'm reading it right that Python\n                # will then go ahead and poll for and handle the signal\n                # elsewhere. See http://www.cherrypy.org/ticket/707.\n                return\n            if x.args[0] in socket_errors_nonblocking:\n                # Just try again. See http://www.cherrypy.org/ticket/479.\n                return\n            if x.args[0] in socket_errors_to_ignore:\n                # Our socket was closed.\n                # See http://www.cherrypy.org/ticket/686.\n                return\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop(self):\n        self.ready = False\n        \n        sock = getattr(self, \"socket\", None)\n        if sock:\n            if not isinstance(self.bind_addr, basestring):\n                # Touch our own socket to make accept() return immediately.\n                try:\n                    host, port = sock.getsockname()[:2]\n                except socket.error, x:\n                    if x.args[0] not in socket_errors_to_ignore:\n                        # Changed to use error code and not message\n                        # See http://www.cherrypy.org/ticket/860.\n                        raise\n                else:\n                    # Note that we're explicitly NOT using AI_PASSIVE,\n                    # here, because we want an actual IP to touch.\n                    # localhost won't work if we've bound to a public IP,\n                    # but it will if we bound to '0.0.0.0' (INADDR_ANY).\n                    for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC,\n                                                  socket.SOCK_STREAM):\n                        af, socktype, proto, canonname, sa = res\n                        s = None\n                        try:\n                            s = socket.socket(af, socktype, proto)\n                            # See http://groups.google.com/group/cherrypy-users/\n                            #        browse_frm/thread/bbfe5eb39c904fe0\n                            s.settimeout(1.0)\n                            s.connect((host, port))\n                            s.close()\n                        except socket.error:\n                            if s:\n                                s.close()\n            if hasattr(sock, \"close\"):\n                sock.close()\n            self.socket = None\n        \n        self.requests.stop(self.shutdown_timeout)", "response": "Gracefully shutdown a server that is serving forever."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, chunk):\n        if not self.started_response:\n            raise AssertionError(\"WSGI write called before start_response.\")\n        \n        if not self.req.sent_headers:\n            self.req.sent_headers = True\n            self.req.send_headers()\n        \n        self.req.write(chunk)", "response": "This method writes unbuffered data to the client."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_environ(self):\n        req = self.req\n        env = {\n            # set a non-standard environ entry so the WSGI app can know what\n            # the *real* server protocol is (and what features to support).\n            # See http://www.faqs.org/rfcs/rfc2145.html.\n            'ACTUAL_SERVER_PROTOCOL': req.server.protocol,\n            'PATH_INFO': req.path,\n            'QUERY_STRING': req.qs,\n            'REMOTE_ADDR': req.conn.remote_addr or '',\n            'REMOTE_PORT': str(req.conn.remote_port or ''),\n            'REQUEST_METHOD': req.method,\n            'REQUEST_URI': req.uri,\n            'SCRIPT_NAME': '',\n            'SERVER_NAME': req.server.server_name,\n            # Bah. \"SERVER_PROTOCOL\" is actually the REQUEST protocol.\n            'SERVER_PROTOCOL': req.request_protocol,\n            'SERVER_SOFTWARE': req.server.software,\n            'wsgi.errors': sys.stderr,\n            'wsgi.input': req.rfile,\n            'wsgi.multiprocess': False,\n            'wsgi.multithread': True,\n            'wsgi.run_once': False,\n            'wsgi.url_scheme': req.scheme,\n            'wsgi.version': (1, 0),\n            }\n        \n        if isinstance(req.server.bind_addr, basestring):\n            # AF_UNIX. This isn't really allowed by WSGI, which doesn't\n            # address unix domain sockets. But it's better than nothing.\n            env[\"SERVER_PORT\"] = \"\"\n        else:\n            env[\"SERVER_PORT\"] = str(req.server.bind_addr[1])\n        \n        # Request headers\n        for k, v in req.inheaders.iteritems():\n            env[\"HTTP_\" + k.upper().replace(\"-\", \"_\")] = v\n        \n        # CONTENT_TYPE/CONTENT_LENGTH\n        ct = env.pop(\"HTTP_CONTENT_TYPE\", None)\n        if ct is not None:\n            env[\"CONTENT_TYPE\"] = ct\n        cl = env.pop(\"HTTP_CONTENT_LENGTH\", None)\n        if cl is not None:\n            env[\"CONTENT_LENGTH\"] = cl\n        \n        if req.conn.ssl_env:\n            env.update(req.conn.ssl_env)\n        \n        return env", "response": "Return a new environ dict with the current WSGI version."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new environ dict targeting the given wsgi. version", "response": "def get_environ(self):\n        \"\"\"Return a new environ dict targeting the given wsgi.version\"\"\"\n        req = self.req\n        env_10 = WSGIGateway_10.get_environ(self)\n        env = dict([(k.decode('ISO-8859-1'), v) for k, v in env_10.iteritems()])\n        env[u'wsgi.version'] = ('u', 0)\n        \n        # Request-URI\n        env.setdefault(u'wsgi.url_encoding', u'utf-8')\n        try:\n            for key in [u\"PATH_INFO\", u\"SCRIPT_NAME\", u\"QUERY_STRING\"]:\n                env[key] = env_10[str(key)].decode(env[u'wsgi.url_encoding'])\n        except UnicodeDecodeError:\n            # Fall back to latin 1 so apps can transcode if needed.\n            env[u'wsgi.url_encoding'] = u'ISO-8859-1'\n            for key in [u\"PATH_INFO\", u\"SCRIPT_NAME\", u\"QUERY_STRING\"]:\n                env[key] = env_10[str(key)].decode(env[u'wsgi.url_encoding'])\n        \n        for k, v in sorted(env.items()):\n            if isinstance(v, str) and k not in ('REQUEST_URI', 'wsgi.input'):\n                env[k] = v.decode('ISO-8859-1')\n        \n        return env"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tuple of the fields that should be considered for our notion of object equality.", "response": "def fields(self):\n        '''\n        Fields that should be considered for our notion of object equality.\n        '''\n        return (\n            self.locus, self.offset_start, self.offset_end, self.alignment_key)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bases(self):\n        '''\n        The sequenced bases in the alignment that align to this locus in the\n        genome, as a string.\n\n        Empty string in the case of a deletion. String of length > 1 if there\n        is an insertion here.\n        '''\n        sequence = self.alignment.query_sequence\n        assert self.offset_end <= len(sequence), \\\n            \"End offset=%d > sequence length=%d. CIGAR=%s. SEQUENCE=%s\" % (\n                self.offset_end,\n                len(sequence),\n                self.alignment.cigarstring,\n                sequence)\n        return sequence[self.offset_start:self.offset_end]", "response": "Returns the sequenced bases in the alignment that align to this locus in the genome as a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef min_base_quality(self):\n        '''\n        The minimum of the base qualities. In the case of a deletion, in which\n        case there are no bases in this PileupElement, the minimum is taken\n        over the sequenced bases immediately before and after the deletion.\n        '''\n        try:\n            return min(self.base_qualities)\n        except ValueError:\n            # We are mid-deletion. We return the minimum of the adjacent bases.\n            assert self.offset_start == self.offset_end\n            adjacent_qualities = [\n                self.alignment.query_qualities[offset]\n                for offset in [self.offset_start - 1, self.offset_start]\n                if 0 <= offset < len(self.alignment.query_qualities)\n            ]\n            return min(adjacent_qualities)", "response": "Returns the minimum base quality of the PileupElement."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a listening socket on the designated Taxonomy host and port.", "response": "def _create_server(host, port):\n    \"\"\"\n    Helper function.  Creates a listening socket on the designated\n    host and port.  Modeled on the socket.create_connection()\n    function.\n    \"\"\"\n\n    exc = socket.error(\"getaddrinfo returns an empty list\")\n    for res in socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            # Create the listening socket\n            sock = socket.socket(af, socktype, proto)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            sock.bind(sa)\n            sock.listen(1024)\n            return sock\n\n        except socket.error as exc:\n            # Clean up after ourselves\n            if sock is not None:\n                sock.close()\n\n    # Couldn't create a listening socket\n    raise exc"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncloses the connection and the underlying socket.", "response": "def close(self):\n        \"\"\"\n        Close the connection.\n\n        :param purge: If True (the default), the receive buffer will\n                      be purged.\n        \"\"\"\n\n        # Close the underlying socket\n        if self._sock:\n            with utils.ignore_except():\n                self._sock.close()\n            self._sock = None\n\n        # Purge the message buffers\n        self._recvbuf = []\n        self._recvbuf_partial = ''"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(self, cmd, *payload):\n\n        # If it's closed, raise an error up front\n        if not self._sock:\n            raise ConnectionClosed(\"Connection closed\")\n\n        # Construct the outgoing message\n        msg = json.dumps(dict(cmd=cmd, payload=payload)) + '\\n'\n\n        # Send it\n        try:\n            self._sock.sendall(msg)\n        except socket.error:\n            # We'll need to re-raise\n            e_type, e_value, e_tb = sys.exc_info()\n\n            # Make sure the socket is closed\n            self.close()\n\n            # Re-raise\n            raise e_type, e_value, e_tb", "response": "Send a command message to the other end."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _recvbuf_pop(self):\n\n        # Pop a message off the recv buffer and return (or raise) it\n        msg = self._recvbuf.pop(0)\n        if isinstance(msg, Exception):\n            raise msg\n        return msg['cmd'], msg['payload']", "response": "Internal helper to pop a message off the receive buffer and return it."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreceives a message from the other end.", "response": "def recv(self):\n        \"\"\"\n        Receive a message from the other end.  Returns a tuple of the\n        command (a string) and payload (a list).\n        \"\"\"\n\n        # See if we have a message to process...\n        if self._recvbuf:\n            return self._recvbuf_pop()\n\n        # If it's closed, don't try to read more data\n        if not self._sock:\n            raise ConnectionClosed(\"Connection closed\")\n\n        # OK, get some data from the socket\n        while True:\n            try:\n                data = self._sock.recv(4096)\n            except socket.error:\n                # We'll need to re-raise\n                e_type, e_value, e_tb = sys.exc_info()\n\n                # Make sure the socket is closed\n                self.close()\n\n                # Re-raise\n                raise e_type, e_value, e_tb\n\n            # Did the connection get closed?\n            if not data:\n                # There can never be anything in the buffer here\n                self.close()\n                raise ConnectionClosed(\"Connection closed\")\n\n            # Begin parsing the read-in data\n            partial = self._recvbuf_partial + data\n            self._recvbuf_partial = ''\n            while partial:\n                msg, sep, partial = partial.partition('\\n')\n\n                # If we have no sep, then it's not a complete message,\n                # and the remainder is in msg\n                if not sep:\n                    self._recvbuf_partial = msg\n                    break\n\n                # Parse the message\n                try:\n                    self._recvbuf.append(json.loads(msg))\n                except ValueError as exc:\n                    # Error parsing the message; save the exception,\n                    # which we will re-raise\n                    self._recvbuf.append(exc)\n\n            # Make sure we have a message to return\n            if self._recvbuf:\n                return self._recvbuf_pop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ping(self):\n\n        # Make sure we're connected\n        if not self.conn:\n            self.connect()\n\n        # Send the ping and wait for the response\n        self.conn.send('PING', time.time())\n        cmd, payload = self.conn.recv()\n        recv_ts = time.time()\n\n        # Make sure the response was a PONG\n        if cmd != 'PONG':\n            raise Exception(\"Invalid response from server\")\n\n        # Return the RTT\n        return recv_ts - payload[0]", "response": "Ping the server and return the time interval in seconds required for the server to respond to the PING message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects to the server and return the SimpleRPC object.", "response": "def connect(self):\n        \"\"\"\n        Connect to the server.  This method causes the SimpleRPC\n        object to switch to client mode.  Note some methods, such as\n        the ping() method, implicitly call this method.\n        \"\"\"\n\n        # Make sure we're in client mode\n        if self.mode and self.mode != 'client':\n            raise ValueError(\"%s is not in client mode\" %\n                             self.__class__.__name__)\n        self.mode = 'client'\n\n        # If we're connected, nothing to do\n        if self.conn:\n            return\n\n        # OK, attempt the connection\n        fd = socket.create_connection((self.host, self.port))\n\n        # Initialize the connection object\n        self.conn = self.connection_class(fd)\n\n        # Authenticate\n        try:\n            self.conn.send('AUTH', self.authkey)\n            cmd, payload = self.conn.recv()\n            if cmd != 'OK':\n                LOG.error(\"Failed to authenticate to %s port %s: %s\" %\n                          (self.host, self.port, payload[0]))\n                self.close()\n        except Exception:\n            exc_type, exc_value, exc_tb = sys.exc_info()\n\n            # Log the error\n            if exc_type == ValueError:\n                LOG.error(\"Received bogus response from server: %s\" %\n                          str(exc_value))\n            elif exc_type == ConnectionClosed:\n                LOG.error(\"%s while authenticating to server\" %\n                          str(exc_value))\n            else:\n                LOG.exception(\"Failed to authenticate to server\")\n\n            # Close the connection\n            self.close()\n\n            # Re-raise the exception\n            raise exc_type, exc_value, exc_tb"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listen(self):\n\n        # Make sure we're in server mode\n        if self.mode and self.mode != 'server':\n            raise ValueError(\"%s is not in server mode\" %\n                             self.__class__.__name__)\n        self.mode = 'server'\n\n        # Obtain a listening socket\n        serv = _create_server(self.host, self.port)\n\n        # If we have too many errors, we want to bail out\n        err_thresh = 0\n        while True:\n            # Accept a connection\n            try:\n                sock, addr = serv.accept()\n            except Exception as exc:\n                err_thresh += 1\n                if err_thresh >= self.max_err_thresh:\n                    LOG.exception(\"Too many errors accepting \"\n                                  \"connections: %s\" % str(exc))\n                    break\n                continue  # Pragma: nocover\n\n            # Decrement error count on successful connections\n            err_thresh = max(err_thresh - 1, 0)\n\n            # Log the connection attempt\n            LOG.info(\"Accepted connection from %s port %s\" %\n                     (addr[0], addr[1]))\n\n            # And handle the connection\n            eventlet.spawn_n(self.serve, self.connection_class(sock), addr)\n\n        # Close the listening socket\n        with utils.ignore_except():\n            serv.close()", "response": "Listen for clients.  This method causes the SimpleRPC object\n        to switch to server mode.  One thread will be created for each\n        client."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_remote_method(self, funcname):\n\n        func = getattr(self, funcname)\n        if not callable(func) or not getattr(func, '_remote', False):\n            raise AttributeError(\"%r object has no attribute %r\" %\n                                 (self.__class__.__name__, funcname))\n\n        return func", "response": "Look up the named remote method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a single client.", "response": "def serve(self, conn, addr, auth=False):\n        \"\"\"\n        Handle a single client.\n\n        :param conn: The Connection instance.\n        :param addr: The address of the client, for logging purposes.\n        :param auth: A boolean specifying whether the connection\n                     should be considered authenticated or not.\n                     Provided for debugging.\n        \"\"\"\n\n        try:\n            # Handle data from the client\n            while True:\n                # Get the command\n                try:\n                    cmd, payload = conn.recv()\n                except ValueError as exc:\n                    # Tell the client about the error\n                    conn.send('ERR', \"Failed to parse command: %s\" % str(exc))\n\n                    # If they haven't successfully authenticated yet,\n                    # disconnect them\n                    if not auth:\n                        return\n                    continue  # Pragma: nocover\n\n                # Log the command and payload, for debugging purposes\n                LOG.debug(\"Received command %r from %s port %s; payload: %r\" %\n                          (cmd, addr[0], addr[1], payload))\n\n                # Handle authentication\n                if cmd == 'AUTH':\n                    if auth:\n                        conn.send('ERR', \"Already authenticated\")\n                    elif payload[0] != self.authkey:\n                        # Don't give them a second chance\n                        conn.send('ERR', \"Invalid authentication key\")\n                        return\n                    else:\n                        # Authentication successful\n                        conn.send('OK')\n                        auth = True\n\n                # Handle unauthenticated connections\n                elif not auth:\n                    # No second chances\n                    conn.send('ERR', \"Not authenticated\")\n                    return\n\n                # Handle aliveness test\n                elif cmd == 'PING':\n                    conn.send('PONG', *payload)\n\n                # Handle a function call command\n                elif cmd == 'CALL':\n                    try:\n                        # Get the call parameters\n                        try:\n                            funcname, args, kwargs = payload\n                        except ValueError as exc:\n                            conn.send('ERR', \"Invalid payload for 'CALL' \"\n                                      \"command: %s\" % str(exc))\n                            continue\n\n                        # Look up the function\n                        func = self._get_remote_method(funcname)\n\n                        # Call the function\n                        result = func(*args, **kwargs)\n                    except Exception as exc:\n                        exc_name = '%s:%s' % (exc.__class__.__module__,\n                                              exc.__class__.__name__)\n                        conn.send('EXC', exc_name, str(exc))\n                    else:\n                        # Return the result\n                        conn.send('RES', result)\n\n                # Handle all other commands by returning an ERR\n                else:\n                    conn.send('ERR', \"Unrecognized command %r\" % cmd)\n\n        except ConnectionClosed:\n            # Ignore the connection closed error\n            pass\n        except Exception as exc:\n            # Log other exceptions\n            LOG.exception(\"Error serving client at %s port %s: %s\" %\n                          (addr[0], addr[1], str(exc)))\n\n        finally:\n            LOG.info(\"Closing connection from %s port %s\" %\n                     (addr[0], addr[1]))\n\n            # Make sure the socket gets closed\n            conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_limits(self, limit_sum=None):\n\n        with self.limit_lock:\n            # Grab the checksum and limit list\n            try:\n                return self.limit_rpc.get_limits(limit_sum)\n            except control.NoChangeException:\n                # Expected possibility\n                raise\n            except Exception:\n                # Something happened; maybe the server isn't running.\n                # Pretend that there's no change...\n                raise control.NoChangeException()", "response": "Gets the current limit data if it is different from the data\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_limits(self):\n\n        # Set one up if we don't already have it\n        if not self.remote_limits:\n            self.remote_limits = RemoteLimitData(self.remote)\n        return self.remote_limits", "response": "Retrieve the LimitData object that can be used for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef db(self):\n\n        # Initialize the database handle; we're running in a separate\n        # process, so we need to get_database() ourself\n        if not self._db:\n            self._db = self.config.get_database()\n\n        return self._db", "response": "Returns a handle for the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits up to a certain number of seconds for the process to end.", "response": "def waitUpTo(self, timeoutSeconds, pollInterval=DEFAULT_POLL_INTERVAL):\n    '''\n        Popen.waitUpTo - Wait up to a certain number of seconds for the process to end.\n\n            @param timeoutSeconds <float> - Number of seconds to wait\n\n            @param pollInterval <float> (default .05) - Number of seconds in between each poll\n\n            @return - Returncode of application, or None if did not terminate.\n    '''\n    i = 0\n    numWaits = timeoutSeconds / float(pollInterval)\n\n    ret = self.poll()\n    if ret is None:\n        while i < numWaits:\n            time.sleep(pollInterval)\n            ret = self.poll()\n            if ret is not None:\n                break\n            i += 1\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef waitOrTerminate(self, timeoutSeconds, pollInterval=DEFAULT_POLL_INTERVAL, terminateToKillSeconds=SUBPROCESS2_DEFAULT_TERMINATE_TO_KILL_SECONDS):\n    '''\n        waitOrTerminate - Wait up to a certain number of seconds for the process to end.\n\n            If the process is running after the timeout has been exceeded, a SIGTERM will be sent. \n            Optionally, an additional SIGKILL can be sent after some configurable interval. See #terminateToKillSeconds doc below\n\n            @param timeoutSeconds <float> - Number of seconds to wait\n\n            @param pollInterval <float> (default .05)- Number of seconds between each poll\n\n            @param terminateToKillSeconds <float/None> (default 1.5) - If application does not end before #timeoutSeconds , terminate() will be called.\n\n                * If this is set to None, an additional #pollInterval sleep will occur after calling .terminate, to allow the application to cleanup. returnCode will be return of app if finished, or None if did not complete.\n                * If this is set to 0, no terminate signal will be sent, but directly to kill. Because the application cannot trap this, returnCode will be None.\n                * If this is set to > 0, that number of seconds maximum will be given between .terminate and .kill. If the application does not terminate before KILL, returnCode will be None.\n\n            Windows Note -- On windows SIGTERM and SIGKILL are the same thing.\n\n            @return dict { 'returnCode' : <int or None> , 'actionTaken' : <int mask of SUBPROCESS2_PROCESS_*> }\n                Returns a dict representing results: \n                    \"returnCode\" matches return of application, or None per #terminateToKillSeconds doc above.\n                    \"actionTaken\" is a mask of the SUBPROCESS2_PROCESS_* variables. If app completed normally, it will be SUBPROCESS2_PROCESS_COMPLETED, otherwise some mask of SUBPROCESS2_PROCESS_TERMINATED and/or SUBPROCESS2_PROCESS_KILLED\n    '''\n    returnCode = self.waitUpTo(timeoutSeconds, pollInterval)\n    actionTaken = SUBPROCESS2_PROCESS_COMPLETED\n\n\n    if returnCode is None:\n        if terminateToKillSeconds is None:\n            self.terminate()\n            actionTaken |= SUBPROCESS2_PROCESS_TERMINATED\n\n            time.sleep(pollInterval) # Give a chance to cleanup\n            returnCode = self.poll()\n\n        elif terminateToKillSeconds == 0:\n            self.kill()\n            actionTaken |= SUBPROCESS2_PROCESS_KILLED\n\n            time.sleep(.01)  # Give a chance to happen\n            self.poll() # Don't defunct\n\n            returnCode = None\n        else:\n            self.terminate()\n            actionTaken |= SUBPROCESS2_PROCESS_TERMINATED\n\n            returnCode = self.waitUpTo(terminateToKillSeconds, pollInterval)\n            if returnCode is None:\n                actionTaken |= SUBPROCESS2_PROCESS_KILLED\n                self.kill()\n                time.sleep(.01)\n                self.poll() # Don't defunct\n\n    return {\n        'returnCode' : returnCode,\n        'actionTaken' : actionTaken\n    }", "response": "Wait up to a certain number of seconds for the application to finish."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef runInBackground(self, pollInterval=.1, encoding=False):\n    '''\n        runInBackground - Create a background thread which will manage this process, automatically read from streams, and perform any cleanups\n\n          The object returned is a \"BackgroundTaskInfo\" object, and represents the state of the process. It is updated automatically as the program runs,\n            and if stdout or stderr are streams, they are automatically read from and populated into this object.\n\n         @see BackgroundTaskInfo for more info or http://pythonhosted.org/python-subprocess2/subprocess2.BackgroundTask.html\n\n        @param pollInterval - Amount of idle time between polling\n        @param encoding - Default False. If provided, data will be decoded using the value of this field as the codec name (e.x. \"utf-8\"). Otherwise, data will be stored as bytes.\n    '''\n        \n    from .BackgroundTask import BackgroundTaskThread\n\n    taskInfo = BackgroundTaskInfo(encoding)\n    thread = BackgroundTaskThread(self, taskInfo, pollInterval, encoding)\n\n    thread.start()\n    #thread.run()  # Uncomment to use pdb debug (will not run in background)\n    return taskInfo", "response": "This method runs the process in background."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_plugins(self, args, arguments):\n        # pprint(arguments)\n\n        quiet = arguments[\"-q\"]\n\n        if arguments[\"activate\"]:\n\n            Console.error(\"this method is not yet supported.\")\n            self.activate()\n\n        elif arguments[\"list\"]:\n\n            if arguments[\"--output\"] == \"yaml\":\n                plugins_object = setup_management(quiet=quiet)\n                print(plugins_object.config.yaml())\n            elif arguments[\"--output\"] == \"json\":\n                plugins_object = setup_management(quiet=quiet)\n                print(plugins_object.config)\n            elif arguments[\"--output\"] == \"list\":\n                plugins_object = setup_management(quiet=quiet)\n                print(plugins_object.config[\"cmd3\"][\"modules\"])\n            if arguments[\"--output\"] is None:\n                plugins_object = setup_management(quiet=quiet)\n                print(plugins_object)\n\n        elif arguments[\"add\"]:\n\n            plugins_object = setup_management()\n            plugins_object.add(arguments[\"COMMAND\"],\n                               dryrun=arguments[\"--dryrun\"])\n\n\n        elif arguments[\"delete\"]:\n\n            plugins_object = setup_management()\n            plugins_object.delete(arguments[\"COMMAND\"],\n                               dryrun=arguments[\"--dryrun\"])\n\n        else:\n            Console.error(\"unknown option.\")", "response": "This command is used to add and delete plugins for a given command."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef preprocess(self):\n        super(MambuGroup,self).preprocess()\n\n        try:\n            for k,v in self['theGroup'].items():\n                self[k] = v\n            del(self.attrs['theGroup'])\n        except Exception as e:\n            pass\n\n        try:\n            self['notes'] = self['notes'].replace(\"<div>\", \"\").replace(\"</div>\", \"\")\n        except Exception as e:\n            self['notes'] = \"\"\n\n        try:\n            self['name'] = self['groupName']\n        except KeyError:\n            pass", "response": "This method is used to preprocess the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the clients for this group to a list of clients.", "response": "def setClients(self, *args, **kwargs):\n        \"\"\"Adds the clients for this group to a 'clients' field.\n\n        The 'groupMembers' field of the group holds the encodedKeys of\n        the member clients of the group. Since Mambu REST API accepts\n        both ids or encodedKeys to retrieve entities, we use that here.\n\n        You may wish to get the full details of each client by passing a\n        fullDetails=True argument here.\n\n        Returns the number of requests done to Mambu.\n        \"\"\"\n\n        requests = 0\n        if 'fullDetails' in kwargs:\n            fullDetails = kwargs['fullDetails']\n            kwargs.pop('fullDetails')\n        else:\n            fullDetails = True\n\n        clients = []\n\n\n        for m in self['groupMembers']:\n            try:\n                client = self.mambuclientclass(entid=m['clientKey'], fullDetails=fullDetails, *args, **kwargs)\n            except AttributeError as ae:\n                from .mambuclient import MambuClient\n                self.mambuclientclass = MambuClient\n                client = self.mambuclientclass(entid=m['clientKey'], fullDetails=fullDetails, *args, **kwargs)\n            requests += 1\n            clients.append(client)\n\n        self['clients'] = clients\n\n        return requests"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setActivities(self, *args, **kwargs):\n        def activityDate(activity):\n            \"\"\"Util function used for sorting activities according to timestamp\"\"\"\n            try:\n                return activity['activity']['timestamp']\n            except KeyError as kerr:\n                return None\n        try:\n            activities = self.mambuactivitiesclass(groupId=self['encodedKey'], *args, **kwargs)\n        except AttributeError as ae:\n            from .mambuactivity import MambuActivities\n            self.mambuactivitiesclass = MambuActivities\n            activities = self.mambuactivitiesclass(groupId=self['encodedKey'], *args, **kwargs)\n\n        activities.attrs = sorted(activities.attrs, key=activityDate)\n        self['activities'] = activities\n\n        return 1", "response": "Adds the activities for this group to a activities field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convertDict2Attrs(self, *args, **kwargs):\n        for n,c in enumerate(self.attrs):\n            # ok ok, I'm modifying elements of a list while iterating it. BAD PRACTICE!\n            try:\n                params = self.params\n            except AttributeError as aerr:\n                params = {}\n            kwargs.update(params)\n            try:\n                group = self.mambugroupclass(urlfunc=None, entid=None, *args, **kwargs)\n            except AttributeError as ae:\n                self.mambugroupclass = MambuGroup\n                group = self.mambugroupclass(urlfunc=None, entid=None, *args, **kwargs)\n            group.init(c, *args, **kwargs)\n            self.attrs[n] = group", "response": "This function converts a dictionary of plain dictionaries into a list of Mambu Group objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_sensitivity(self, sensitivity=DEFAULT_SENSITIVITY):\n        if sensitivity < 31:\n            self._mtreg = 31\n        elif sensitivity > 254:\n            self._mtreg = 254\n        else:\n            self._mtreg = sensitivity\n        self._power_on()\n        self._set_mode(0x40 | (self._mtreg >> 5))\n        self._set_mode(0x60 | (self._mtreg & 0x1f))\n        self._power_down()", "response": "Set the sensitivity value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns current measurement result in lx.", "response": "def _get_result(self) -> float:\n        \"\"\"Return current measurement result in lx.\"\"\"\n        try:\n            data = self._bus.read_word_data(self._i2c_add, self._mode)\n            self._ok = True\n        except OSError as exc:\n            self.log_error(\"Bad reading in bus: %s\", exc)\n            self._ok = False\n            return -1\n\n        count = data >> 8 | (data & 0xff) << 8\n        mode2coeff = 2 if self._high_res else 1\n        ratio = 1 / (1.2 * (self._mtreg / 69.0) * mode2coeff)\n        return ratio * count"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _wait_for_result(self):\n        basetime = 0.018 if self._low_res else 0.128\n        sleep(basetime * (self._mtreg / 69.0) + self._delay)", "response": "Wait for the sensor to be ready for measurement."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the measured light level in lux.", "response": "def update(self):\n        \"\"\"Update the measured light level in lux.\"\"\"\n        if not self._continuous_sampling \\\n                or self._light_level < 0 \\\n                or self._operation_mode != self._mode:\n            self._reset()\n            self._set_mode(self._operation_mode)\n            self._wait_for_result()\n        self._light_level = self._get_result()\n        if not self._continuous_sampling:\n            self._power_down()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_uhmac(user, secret):\n    secret = to_bytes(secret)\n    key = '|'.join([\n        hashlib.sha1(secret).hexdigest(),\n        str(user.id),\n        get_hash_extract(user.password),\n    ])\n    key = key.encode('utf8', 'ignore')\n    mac = hmac.new(key, msg=None, digestmod=hashlib.sha512)\n    mac = mac.hexdigest()[:50]\n    uhmac = '{0}${1}'.format(user.id, mac)\n    return uhmac", "response": "Make an unique identifier for the user and secret."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_token(user, secret, timestamp=None):\n    timestamp = int(timestamp or time())\n    secret = to_bytes(secret)\n    key = '|'.join([\n        hashlib.sha1(secret).hexdigest(),\n        str(user.id),\n        get_hash_extract(user.password),\n        str(getattr(user, 'last_sign_in', 0)),\n        str(timestamp),\n    ])\n    key = key.encode('utf8', 'ignore')\n    mac = hmac.new(key, msg=None, digestmod=hashlib.sha512)\n    mac = mac.hexdigest()[:50]\n    token = '{0}${1}${2}'.format(user.id, to36(timestamp), mac)\n    return token", "response": "Generate a timestamped one - time - use token that can be used to identify a user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the real user object.", "response": "def __get_user(self):\n        \"\"\"Return the real user object.\n        \"\"\"\n        storage = object.__getattribute__(self, '_LazyUser__storage')\n        user = getattr(self.__auth, 'get_user')()\n        setattr(storage, self.__user_name, user)\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _expand_filename(self, line):\n        # expand .\n        newline = line\n        path = os.getcwd()\n        if newline.startswith(\".\"):\n            newline = newline.replace(\".\", path, 1)\n        # expand ~\n        newline = os.path.expanduser(newline)\n        return newline", "response": "expands the filename if there is a. as leading path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nopen the given file in a browser window.", "response": "def do_open(self, args, arguments):\n        \"\"\"\n        ::\n\n            Usage:\n                    open FILENAME\n\n            ARGUMENTS:\n                FILENAME  the file to open in the cwd if . is\n                          specified. If file in in cwd\n                          you must specify it with ./FILENAME\n\n            Opens the given URL in a browser window.\n        \"\"\"\n        filename = arguments['FILENAME']\n        filename = self._expand_filename(filename)\n        Console.ok(\"open {0}\".format(filename))\n\n        if not (filename.startswith(\"file:\") or filename.startswith(\"http:\")):\n            try:\n                with open(filename):\n                    pass\n                filename += \"file://\"\n            except:\n                Console.error(\"unsupported browser format in file {0}\".format(filename))\n                return\n\n        try:\n            webbrowser.open(\"%s\" % filename)\n        except:\n            Console.error(\"can not open browser with file {0}\".format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmodifying the customField field for the given object with something related to the value of the given field.", "response": "def setCustomField(mambuentity, customfield=\"\", *args, **kwargs):\n    \"\"\"Modifies the customField field for the given object with\n    something related to the value of the given field.\n\n    If the dataType == \"USER_LINK\" then instead of using the value\n    of the CF, it will be a MambuUser object.\n\n    Same if dataType == \"CLIENT_LINK\", but with a MambuClient.\n\n    Default case: just uses the same value the CF already had.\n\n    Returns the number of requests done to Mambu.\n    \"\"\"\n    from . import mambuuser\n    from . import mambuclient\n    try:\n        customFieldValue = mambuentity[customfield]\n        # find the dataType customfield by name or id\n        datatype = [ l['customField']['dataType'] for l in mambuentity[mambuentity.customFieldName] if (l['name'] == customfield or l['id'] == customfield) ][0]\n    except IndexError as ierr:\n    # if no customfield found with the given name, assume it is a\n    # grouped custom field, name must have an index suffix that must\n    # be removed\n        try:\n            # find the dataType customfield by name or id\n            datatype = [ l['customField']['dataType'] for l in mambuentity[mambuentity.customFieldName] if (l['name'] == customfield.split('_')[0] or l['id'] == customfield.split('_')[0]) ][0]\n        except IndexError:\n            err = MambuError(\"Object %s has no custom field '%s'\" % (mambuentity['id'], customfield))\n            raise err\n    except AttributeError:\n        err = MambuError(\"Object does not have a custom field to set\")\n        raise err\n\n    if datatype == \"USER_LINK\":\n        mambuentity[customfield] = mambuuser.MambuUser(entid=customFieldValue, *args, **kwargs)\n    elif datatype == \"CLIENT_LINK\":\n        mambuentity[customfield] = mambuclient.MambuClient(entid=customFieldValue, *args, **kwargs)\n    else:\n        mambuentity[customfield] = customFieldValue\n        return 0\n\n    return 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serializeFields(data):\n        if isinstance(data, MambuStruct):\n            return data.serializeStruct()\n        try:\n            it = iter(data)\n        except TypeError as terr:\n            return unicode(data)\n        if type(it) == type(iter([])):\n            l = []\n            for e in it:\n                l.append(MambuStruct.serializeFields(e))\n            return l\n        elif type(it) == type(iter({})):\n            d = {}\n            for k in it:\n                d[k] = MambuStruct.serializeFields(data[k])\n            return d\n        # elif ... tuples? sets?\n        return unicode(data)", "response": "Turns every attribute of the Mambu object in to a string representation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_key(self, key):\n        try:\n            if type(self.attrs) == dict:\n                return key in self.attrs\n            else:\n                raise AttributeError    # if attrs is not a dict\n        except AttributeError:          # if attrs doesnt exist\n            raise NotImplementedError", "response": "Check if a key exists in the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a key from the attribute dictionary.", "response": "def get(self, key, default=None):\n        \"\"\"Dict-like behaviour\"\"\"\n        if type(self.attrs) == dict:\n            return self.attrs.get(key, default)\n        else:\n            raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndefaulting initialization from a dictionary responded by Mambu.", "response": "def init(self, attrs={}, *args, **kwargs):\n        \"\"\"Default initialization from a dictionary responded by Mambu\n\n        in to the elements of the Mambu object.\n\n        It assings the response to attrs attribute and converts each of\n        its elements from a string to an adequate python object: number,\n        datetime, etc.\n\n        Basically it stores the response on the attrs attribute, then\n        runs some customizable preprocess method, then runs\n        convertDict2Attrs method to convert the string elements to an\n        adequate python object, then a customizable postprocess method.\n\n        It also executes each method on the 'methods' attribute given on\n        instantiation time, and sets new customizable 'properties' to\n        the object.\n\n        Why not on __init__? two reasons:\n\n        * __init__ optionally connects to Mambu, if you don't connect to\n          Mambu, the Mambu object will be configured but it won't have\n          any Mambu info on it. Only when connected, the Mambu object\n          will be initialized, here.\n\n          Useful to POST several times the same Mambu object. You make a\n          POST request over and over again by calling it's connect()\n          method every time you wish. This init method will configure the\n          response in to the attrs attribute each time.\n\n          You may also wish to update the info on a previously initialized\n          Mambu object and refresh it with what Mambu now has. Instead of\n          building a new object, you just connect() again and it will be\n          refreshed.\n\n        * Iterable Mambu objects (lists) do not initialize here, the\n          iterable Mambu object __init__ goes through each of its elements\n          and then initializes with this code one by one. Please look at\n          some Mambu iterable object code and pydoc for more details.\n\"\"\"\n        self.attrs = attrs\n        self.preprocess()\n        self.convertDict2Attrs(*args, **kwargs)\n        self.postprocess()\n        try:\n            for meth in kwargs['methods']:\n                try:\n                    getattr(self,meth)()\n                except Exception:\n                    pass\n        except Exception:\n            pass\n        try:\n            for propname,propval in kwargs['properties'].items():\n                setattr(self,propname,propval)\n        except Exception:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect(self, *args, **kwargs):\n        from copy import deepcopy\n        if args:\n            self.__args = deepcopy(args)\n        if kwargs:\n            for k,v in kwargs.items():\n                self.__kwargs[k] = deepcopy(v)\n\n        jsresp = {}\n\n        if not self.__urlfunc:\n            return\n\n        # Pagination window, Mambu restricts at most 500 elements in response\n        offset = self.__offset\n        window = True\n        jsresp = {}\n        while window:\n            if not self.__limit or self.__limit > OUT_OF_BOUNDS_PAGINATION_LIMIT_VALUE:\n                limit = OUT_OF_BOUNDS_PAGINATION_LIMIT_VALUE\n            else:\n                limit = self.__limit\n\n            # Retry mechanism, for awful connections\n            retries = 0\n            while retries < MambuStruct.RETRIES:\n                try:\n                    # Basic authentication\n                    user = self.__kwargs.get('user', apiuser)\n                    pwd = self.__kwargs.get('pwd', apipwd)\n                    if self.__data:\n                        headers = {'content-type': 'application/json'}\n                        data = json.dumps(encoded_dict(self.__data))\n                        url = iriToUri(self.__urlfunc(self.entid, limit=limit, offset=offset, *self.__args, **self.__kwargs))\n                    # PATCH\n                        if self.__method==\"PATCH\":\n                            resp = requests.patch(url, data=data, headers=headers, auth=(user, pwd))\n                    # POST\n                        else:\n                            resp = requests.post(url, data=data, headers=headers, auth=(user, pwd))\n                    # GET\n                    else:\n                        url = iriToUri(self.__urlfunc(self.entid, limit=limit, offset=offset, *self.__args, **self.__kwargs))\n                        resp = requests.get(url, auth=(user, pwd))\n                    # Always count a new request when done!\n                    self.rc.add(datetime.now())\n                    try:\n                        jsonresp = json.loads(resp.content)\n                        # Returns list: extend list for offset\n                        if type(jsonresp) == list:\n                            try:\n                                jsresp.extend(jsonresp)\n                            except AttributeError:\n                                # First window, forget that jsresp was a dict, turn it in to a list\n                                jsresp=jsonresp\n                            if len(jsonresp) < limit:\n                                window = False\n                        # Returns dict: in theory Mambu REST API doesn't takes limit/offset in to account\n                        else:\n                            jsresp = jsonresp\n                            window = False\n                    except ValueError as ex:\n                        # json.loads invalid data argument\n                        raise ex\n                    except Exception as ex:\n                        # any other json error\n                        raise MambuError(\"JSON Error: %s\" % repr(ex))\n                    # if we reach here, we're done and safe\n                    break\n                except MambuError as merr:\n                    raise merr\n                except requests.exceptions.RequestException:\n                    retries += 1\n                except Exception as ex:\n                    raise ex\n            else:\n                raise MambuCommError(\"ERROR I can't communicate with Mambu\")\n\n            # next window, moving offset...\n            offset = offset + limit\n            if self.__limit:\n                self.__limit -= limit\n                if self.__limit <= 0:\n                    window = False\n                    self.__limit = self.__inilimit\n\n        try:\n            if u'returnCode' in jsresp and u'returnStatus' in jsresp and jsresp[u'returnCode'] != 0:\n                raise MambuError(jsresp[u'returnStatus'])\n        except AttributeError:\n            pass\n\n        if self.__method != \"PATCH\":\n            self.init(attrs=jsresp, *self.__args, **self.__kwargs)", "response": "Connect to Mambu, make the request to the REST API.\n\n        If there's no urlfunc to use, nothing is done here.\n\n        When done, initializes the attrs attribute of the Mambu object\n        by calling the init method. Please refer to that code and pydoc\n        for further information.\n\n        Uses urllib module to connect. Since all Mambu REST API\n        responses are json, uses json module to translate the response\n        to a valid python object (dictionary or list).\n\n        When Mambu returns a response with returnCode and returnStatus\n        fields, it means something went wrong with the request, and a\n        MambuError is thrown detailing the error given by Mambu itself.\n\n        If you need to make a POST request, send a data argument to the\n        new Mambu object.\n\n        Provides to prevent errors due to using special chars on the\n        request URL. See mambuutil.iriToUri() method pydoc for further\n        info.\n\n        Provides to prevent errors due to using special chars on the\n        parameters of a POST request. See mambuutil.encoded_dict()\n        method pydoc for further info.\n\n        For every request done, the request counter Singleton is\n        increased.\n\n        Includes retry logic, to provide for a max number of connection\n        failures with Mambu. If maximum retries are reached,\n        MambuCommError is thrown.\n\n        Includes pagination code. Mambu supports a max of 500 elements\n        per response. Such an ugly detail is wrapped here so further\n        pagination logic is not needed above here. You need a million\n        elements? you got them by making several 500 elements requests\n        later joined together in a sigle list. Just send a limit=0\n        (default) and that's it.\n\n.. todo:: improve raised exception messages. Sometimes\n          MambuCommErrors are thrown due to reasons not always\n          clear when catched down the road, but that perhaps may\n          be noticed in here and aren't fully reported to the\n          user. Specially serious on retries-MambuCommError\n          situations (the except Exception that increases the\n          retries counter is not saving the exception message,\n          just retrying).\n\n.. todo:: what about using decorators for the retry and for the\n          window logic?\n          (https://www.oreilly.com/ideas/5-reasons-you-need-to-learn-to-write-python-decorators\n          # Reusing impossible-to-reuse code)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndefault info massage to appropiate format/style. This processing is called on preprocess and postprocess, AKA before and after conversion of fields to appropiate format/style. Perfect example: custom fields on certain objects is a mess (IMHO) when retrieved from Mambu, so some easiness is implemented here to access them. See some of this objects modules and pydocs for further info. Tasks done here: - Each custom field is given a 'name' key that holds the field name, and for each keyed name, the value of the custom field is assigned. Each pair of custom field name/value is entered as a new property on the main dictionary, allowing an easy access to them, not nested inside a pretty dark 'customInformation/Values' list. - Every item on the attrs dictionary gets stripped from trailing spaces (useful when users make typos). PLEASE REMEMBER! whenever you call postprocess on inherited classes you should call this method too, or else you lose the effect of the tasks done here.", "response": "def _process_fields(self):\n        \"\"\"Default info massage to appropiate format/style.\n\n        This processing is called on preprocess and postprocess, AKA\n        before and after conversion of fields to appropiate\n        format/style.\n\n        Perfect example: custom fields on certain objects is a mess\n        (IMHO) when retrieved from Mambu, so some easiness is\n        implemented here to access them. See some of this objects\n        modules and pydocs for further info.\n\n        Tasks done here:\n\n        - Each custom field is given a 'name' key that holds the field\n          name, and for each keyed name, the value of the custom field is\n          assigned. Each pair of custom field name/value is entered as a\n          new property on the main dictionary, allowing an easy access to\n          them, not nested inside a pretty dark 'customInformation/Values'\n          list.\n\n        - Every item on the attrs dictionary gets stripped from trailing\n          spaces (useful when users make typos).\n\n        PLEASE REMEMBER! whenever you call postprocess on inherited\n        classes you should call this method too, or else you lose the\n        effect of the tasks done here.\n        \"\"\"\n        try:\n            try:\n                if self.has_key(self.customFieldName):\n                    self[self.customFieldName] = [ c for c in self[self.customFieldName] if c['customField']['state']!=\"DEACTIVATED\" ]\n                    for custom in self[self.customFieldName]:\n                        field_name = custom['customField']['name']\n                        field_id = custom['customField']['id']\n                        if custom['customFieldSetGroupIndex'] != -1:\n                            field_name += '_'+str(custom['customFieldSetGroupIndex'])\n                            field_id += '_'+str(custom['customFieldSetGroupIndex'])\n                        custom['name'] = field_name\n                        custom['id'] = field_id\n                        try:\n                            self[field_name] = custom['value']\n                            self[field_id] = custom['value']\n                        except KeyError:\n                            self[field_name] = custom['linkedEntityKeyValue']\n                            self[field_id] = custom['linkedEntityKeyValue']\n                            custom['value']  = custom['linkedEntityKeyValue']\n            # in case you don't have any customFieldName, don't do anything here\n            except (AttributeError, TypeError):\n                pass\n\n            for k,v in self.items():\n                try:\n                    self[k] = v.strip()\n                except Exception:\n                    pass\n        except NotImplementedError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convertDict2Attrs(self, *args, **kwargs):\n        constantFields = ['id', 'groupName', 'name', 'homePhone', 'mobilePhone1', 'phoneNumber', 'postcode', 'emailAddress']\n        def convierte(data):\n            \"\"\"Recursively convert the fields on the data given to a python object.\"\"\"\n            # Iterators, lists and dictionaries\n            # Here comes the recursive calls!\n            try:\n                it = iter(data)\n                if type(it) == type(iter({})):\n                    d = {}\n                    for k in it:\n                        if k in constantFields:\n                            d[k] = data[k]\n                        else:\n                            d[k] = convierte(data[k])\n                    data = d\n                if type(it) == type(iter([])):\n                    l = []\n                    for e in it:\n                        l.append(convierte(e))\n                    data = l\n            except TypeError as terr:\n                pass\n            except Exception as ex:\n                raise ex\n\n            # Python built-in types: ints, floats, or even datetimes. If it\n            # cannot convert it to a built-in type, leave it as string, or\n            # as-is. There may be nested Mambu objects here!\n            # This are the recursion base cases!\n            try:\n                d = int(data)\n                if str(d) != data: # if string has trailing 0's, leave it as string, to not lose them\n                    return data\n                return d\n            except (TypeError, ValueError) as tverr:\n                try:\n                    return float(data)\n                except (TypeError, ValueError) as tverr:\n                    try:\n                        return self.util_dateFormat(data)\n                    except (TypeError, ValueError) as tverr:\n                        return data\n\n            return data\n\n        self.attrs = convierte(self.attrs)", "response": "Convert the attributes of the attribute object to a proper python object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef util_dateFormat(self, field, formato=None):\n        if not formato:\n            try:\n                formato = self.__formatoFecha\n            except AttributeError:\n                formato = \"%Y-%m-%dT%H:%M:%S+0000\"\n        return datetime.strptime(datetime.strptime(field, \"%Y-%m-%dT%H:%M:%S+0000\").strftime(formato), formato)", "response": "Converts a datetime field to a datetime using some specified format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an entity in Mambu object in the specified object", "response": "def create(self, data, *args, **kwargs):\n        \"\"\"Creates an entity in Mambu\n\n        This method must be implemented in child classes\n\n        Args:\n            data (dictionary): dictionary with data to send, this dictionary\n                               is specific for each Mambu entity\n        \"\"\"\n        # if module of the function is diferent from the module of the object\n        # that means create is not implemented in child class\n        if self.create.__func__.__module__ != self.__module__:\n            raise Exception(\"Child method not implemented\")\n\n        self._MambuStruct__method  = \"POST\"\n        self._MambuStruct__data    = data\n        self.connect(*args, **kwargs)\n        self._MambuStruct__method  = \"GET\"\n        self._MambuStruct__data    = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns bcp FORMAT command to create a format file that will assist in creating the bulk data file", "response": "def make(self, cmd_args, db_args):\n        '''\n        Runs bcp FORMAT command to create a format file that will assist in creating the bulk data file\n        '''\n        with NamedTemporaryFile(delete=True) as f:\n            format_file = f.name + '.bcp-format'\n        format_args = cmd_args + ['format', NULL_FILE, '-c', '-f', format_file, '-t,'] + db_args\n        _run_cmd(format_args)\n        self.load(format_file)\n        return format_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads a non - XML bcp FORMAT file and parses it into fields list used for creating bulk data file", "response": "def load(self, filename=None):\n        '''\n        Reads a non-XML bcp FORMAT file and parses it into fields list used for creating bulk data file\n        '''\n        fields = []\n        with open(filename, 'r') as f:\n            format_data = f.read().strip()\n\n        lines = format_data.split('\\n')\n        self._sql_version = lines.pop(0)\n        self._num_fields = int(lines.pop(0))\n\n        for line in lines:\n            # Get rid of mulitple spaces\n            line = re.sub(' +', ' ', line.strip())\n            row_format = BCPFormatRow(line.split(' '))\n            fields.append(row_format)\n\n        self.fields = fields\n        self.filename = filename"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the content of a resource.", "response": "def retrieve_content(self):\n        \"\"\"Retrieve the content of a resource.\"\"\"\n        path = self._construct_path_to_source_content()\n        res = self._http.get(path)\n        self._populated_fields['content'] = res['content']\n        return res['content']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse separate URL for updating the source file.", "response": "def _update(self, **kwargs):\n        \"\"\"Use separate URL for updating the source file.\"\"\"\n        if 'content' in kwargs:\n            content = kwargs.pop('content')\n            path = self._construct_path_to_source_content()\n            self._http.put(path, json.dumps({'content': content}))\n        super(Resource, self)._update(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all():\n    dir()\n    cmd3()\n    banner(\"CLEAN PREVIOUS CLOUDMESH INSTALLS\")\n    r = int(local(\"pip freeze |fgrep cloudmesh | wc -l\", capture=True))\n    while r > 0:\n        local('echo \"y\\n\" | pip uninstall cloudmesh')\n        r = int(local(\"pip freeze |fgrep cloudmesh | wc -l\", capture=True))", "response": "clean the dis and uninstall cloudmesh"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cronitor(self):\n        url = f'https://cronitor.link/{self.opts.cronitor}/{{}}'\n\n        try:\n            run_url = url.format('run')\n            self.logger.debug(f'Pinging {run_url}')\n            requests.get(run_url, timeout=self.opts.timeout)\n\n        except requests.exceptions.RequestException as e:\n            self.logger.exception(e)\n\n        # Cronitor may be having an outage, but we still want to run our stuff\n        output, exit_status = self.run()\n\n        endpoint = 'complete' if exit_status == 0 else 'fail'\n        try:\n            ping_url = url.format(endpoint)\n            self.logger.debug('Pinging {}'.format(ping_url))\n            requests.get(ping_url, timeout=self.opts.timeout)\n\n        except requests.exceptions.RequestException as e:\n            self.logger.exception(e)\n\n        return output, exit_status", "response": "Wrap run with requests to cronitor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_config(self, custom_config):\n        self.config = configparser.ConfigParser()\n\n        if custom_config:\n            self.config.read(custom_config)\n            return f'Loading config from file {custom_config}.'\n\n        home = os.path.expanduser('~{}'.format(getpass.getuser()))\n        home_conf_file = os.path.join(home, '.cronyrc')\n        system_conf_file = '/etc/crony.conf'\n\n        conf_precedence = (home_conf_file, system_conf_file)\n        for conf_file in conf_precedence:\n            if os.path.exists(conf_file):\n                self.config.read(conf_file)\n                return f'Loading config from file {conf_file}.'\n\n        self.config['crony'] = {}\n        return 'No config file found.'", "response": "Attempt to load config from file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlogging given CompletedProcess and return exit status code.", "response": "def log(self, output, exit_status):\n        \"\"\"Log given CompletedProcess and return exit status code.\"\"\"\n        if exit_status != 0:\n            self.logger.error(f'Error running command! Exit status: {exit_status}, {output}')\n\n        return exit_status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        self.logger.debug(f'Running command: {self.cmd}')\n\n        def execute(cmd):\n            output = \"\"\n            popen = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                                     universal_newlines=True, shell=True)\n            for stdout_line in iter(popen.stdout.readline, \"\"):\n                stdout_line = stdout_line.strip('\\n')\n                output += stdout_line\n                yield stdout_line\n            popen.stdout.close()\n            return_code = popen.wait()\n            if return_code:\n                raise subprocess.CalledProcessError(return_code, cmd, output)\n\n        try:\n            for out in execute(self.cmd):\n                self.logger.info(out)\n            return \"\", 0\n        except subprocess.CalledProcessError as e:\n            return e.output, e.returncode", "response": "Run command and report errors to Sentry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_dir(self):\n        cd = self.opts.cd or self.config['crony'].get('directory')\n        if cd:\n            self.logger.debug(f'Adding cd to {cd}')\n            self.cmd = f'cd {cd} && {self.cmd}'", "response": "Change directory for script if necessary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_logging(self):\n        date_format = '%Y-%m-%dT%H:%M:%S'\n        log_format = '%(asctime)s %(levelname)s: %(message)s'\n\n        if self.opts.verbose:\n            lvl = logging.DEBUG\n        else:\n            lvl = logging.INFO\n            # Requests is a bit chatty\n            logging.getLogger('requests').setLevel('WARNING')\n\n        self.logger.setLevel(lvl)\n\n        stdout = logging.StreamHandler(sys.stdout)\n        stdout.setLevel(lvl)\n        formatter = logging.Formatter(log_format, date_format)\n        stdout.setFormatter(formatter)\n        self.logger.addHandler(stdout)\n\n        # Decided not to use stderr\n        # stderr = logging.StreamHandler(sys.stderr)\n        # stderr.setLevel(logging.ERROR)  # Error and above go to both stdout & stderr\n        # formatter = logging.Formatter(log_format, date_format)\n        # stderr.setFormatter(formatter)\n        # self.logger.addHandler(stderr)\n\n        log = self.opts.log or self.config['crony'].get('log_file')\n        if log:\n            logfile = logging.FileHandler(log)\n            logfile.setLevel(lvl)\n            formatter = logging.Formatter(log_format, date_format)\n            logfile.setFormatter(formatter)\n            self.logger.addHandler(logfile)\n\n        if self.sentry_client:\n            sentry = SentryHandler(self.sentry_client)\n            sentry.setLevel(logging.ERROR)\n            self.logger.addHandler(sentry)\n\n        self.logger.debug('Logging setup complete.')", "response": "Setup python logging handler."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_path(self):\n        path = self.opts.path or self.config['crony'].get('path')\n        if path:\n            self.logger.debug(f'Adding {path} to PATH environment variable')\n            self.cmd = f'export PATH={path}:$PATH && {self.cmd}'", "response": "Setup PATH env var if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_venv(self):\n        venv = self.opts.venv\n        if not venv:\n            venv = os.environ.get('CRONY_VENV')\n            if not venv and self.config['crony']:\n                venv = self.config['crony'].get('venv')\n        if venv:\n            if not venv.endswith('activate'):\n                add_path = os.path.join('bin', 'activate')\n                self.logger.debug(f'Venv directory given, adding {add_path}')\n                venv = os.path.join(venv, add_path)\n            self.logger.debug(f'Adding sourcing virtualenv {venv}')\n            self.cmd = f'. {venv} && {self.cmd}'", "response": "Setup virtualenv if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_repos(path):\n    p = str(path)\n    ret = []\n    if not os.path.exists(p):\n        return ret\n    for d in os.listdir(p):\n        pd = os.path.join(p, d)\n        if os.path.exists(pd) and is_repo(pd):\n            ret.append(Local(pd))\n    return ret", "response": "Returns list of found branches."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns parent repo or input path if none found.", "response": "def get_repo_parent(path):\n    \"\"\"\n    Returns parent repo or input path if none found.\n\n    :return: grit.Local or path\n    \"\"\"\n    # path is a repository\n    if is_repo(path):\n        return Local(path)\n\n    # path is inside a repository\n    elif not os.path.isdir(path):\n        _rel = ''\n        while path and path != '/':\n            if is_repo(path):\n                return Local(path)\n            else:\n                _rel = os.path.join(os.path.basename(path), _rel)\n                path = os.path.dirname(path)\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning Remote origin as Proxy instance", "response": "def _get_parent(self):\n        \"\"\":return: Remote origin as Proxy instance\"\"\"\n        _dir = os.path.dirname(self.path)\n        if is_repo(_dir):\n            return Local(_dir)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setVersion(self, version):\n        try:\n            sha = self.versions(version).commit.sha\n            self.git.reset(\"--hard\", sha)\n        except Exception, e:\n            raise RepoError(e)", "response": "Checkout a version of the repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of the commits reachable from head.", "response": "def _commits(self, head='HEAD'):\n        \"\"\"Returns a list of the commits reachable from head.\n\n        :return: List of commit objects. the first of which will be the commit\n        of head, then following theat will be the parents.\n\n        :raise: RepoError if any no commits are referenced, including if the\n        head parameter isn't the sha of a commit.\n        \"\"\"\n        pending_commits = [head]\n        history = []\n        while pending_commits != []:\n            head = pending_commits.pop(0)\n            try:\n                commit = self[head]\n            except KeyError:\n                raise KeyError(head)\n            if type(commit) != Commit:\n                raise TypeError(commit)\n            if commit in history:\n                continue\n            i = 0\n            for known_commit in history:\n                if known_commit.commit_time > commit.commit_time:\n                    break\n                i += 1\n            history.insert(i, commit)\n            pending_commits += commit.parents\n        return history"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef versions(self, version=None):\n        try:\n            versions = [Version(self, c) for c in self._commits()]\n        except Exception, e:\n            log.debug('No versions exist')\n            return []\n        if version is not None and versions:\n            try:\n                versions = versions[version]\n            except IndexError:\n                raise VersionError('Version %s does not exist' % version)\n        return versions", "response": "Return a list of Version objects matching the given params."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef new(self, path, desc=None, bare=True):\n        if os.path.exists(path):\n            raise RepoError('Path already exists: %s' % path)\n        try:\n            os.mkdir(path)\n            if bare:\n                Repo.init_bare(path)\n            else:\n                Repo.init(path)\n            repo = Local(path)\n            if desc:\n                repo.setDescription(desc)\n            version = repo.addVersion()\n            version.save('Repo Initialization')\n            return repo\n        except Exception, e:\n            traceback.print_exc()\n            raise RepoError('Error creating repo')", "response": "Create a new bare repo. Local instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef branch(self, name, desc=None):\n        return Local.new(path=os.path.join(self.path, name), desc=desc, bare=True)", "response": "Create a branch of this repo at name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new Item class object", "response": "def addItem(self, item, message=None):\n        \"\"\"add a new Item class object\"\"\"\n        if message is None:\n            message = 'Adding item %s' % item.path\n        try:\n            v = Version.new(repo=self)\n            v.addItem(item)\n            v.save(message)\n        except VersionError, e:\n            raise RepoError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef items(self, path=None, version=None):\n        if version is None:\n            version = -1\n        items = {}\n        for item in self.versions(version).items():\n            items[item.path] = item\n        parent = self.parent\n\n        # get latest committed items from parents\n        while parent:\n            for item in parent.items(path=path):\n                if item.path not in items.keys():\n                    items[item.path] = item\n            parent = parent.parent\n\n        # filter items matching path regex\n        if path is not None:\n            path += '$'\n            regex = re.compile(path)\n            return [item for path, item in items.items() if regex.match(path)]\n        else:\n            return items.values()", "response": "Returns a list of items."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def set_reply_markup(msg: Dict, request: 'Request', stack: 'Stack') \\\n        -> None:\n    \"\"\"\n    Add the \"reply markup\" to a message from the layers\n\n    :param msg: Message dictionary\n    :param request: Current request being replied\n    :param stack: Stack to analyze\n    \"\"\"\n\n    from bernard.platforms.telegram.layers import InlineKeyboard, \\\n        ReplyKeyboard, \\\n        ReplyKeyboardRemove\n\n    try:\n        keyboard = stack.get_layer(InlineKeyboard)\n    except KeyError:\n        pass\n    else:\n        msg['reply_markup'] = await keyboard.serialize(request)\n    try:\n        keyboard = stack.get_layer(ReplyKeyboard)\n    except KeyError:\n        pass\n    else:\n        msg['reply_markup'] = await keyboard.serialize(request)\n    try:\n        remove = stack.get_layer(ReplyKeyboardRemove)\n    except KeyError:\n        pass\n    else:\n        msg['reply_markup'] = remove.serialize()", "response": "Add the reply markup to a message from the layers that are currently being processed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef split_locale(locale: Text) -> Tuple[Text, Optional[Text]]:\n\n    items = re.split(r'[_\\-]', locale.lower(), 1)\n\n    try:\n        return items[0], items[1]\n    except IndexError:\n        return items[0], None", "response": "Decomposes the locale into a normalized tuple."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompare two locales to find the level of compatibility", "response": "def compare_locales(a, b):\n    \"\"\"\n    Compares two locales to find the level of compatibility\n\n    :param a: First locale\n    :param b: Second locale\n    :return: 2 full match, 1 lang match, 0 no match\n    \"\"\"\n\n    if a is None or b is None:\n        if a == b:\n            return 2\n        else:\n            return 0\n\n    a = split_locale(a)\n    b = split_locale(b)\n\n    if a == b:\n        return 2\n    elif a[0] == b[0]:\n        return 1\n    else:\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of available locales.", "response": "def list_locales(self) -> List[Optional[Text]]:\n        \"\"\"\n        Returns the list of available locales. The first locale is the default\n        locale to be used. If no locales are known, then `None` will be the\n        first item.\n        \"\"\"\n\n        locales = list(self.dict.keys())\n\n        if not locales:\n            locales.append(None)\n\n        return locales"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the best matching locale in what is available.", "response": "def choose_locale(self, locale: Text) -> Text:\n        \"\"\"\n        Returns the best matching locale in what is available.\n\n        :param locale: Locale to match\n        :return: Locale to use\n        \"\"\"\n\n        if locale not in self._choice_cache:\n            locales = self.list_locales()\n\n            best_choice = locales[0]\n            best_level = 0\n\n            for candidate in locales:\n                cmp = compare_locales(locale, candidate)\n\n                if cmp > best_level:\n                    best_choice = candidate\n                    best_level = cmp\n\n            self._choice_cache[locale] = best_choice\n\n        return self._choice_cache[locale]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, new_data: Dict[Text, Dict[Text, Text]]):\n\n        for locale, data in new_data.items():\n            if locale not in self.dict:\n                self.dict[locale] = {}\n\n            self.dict[locale].update(data)", "response": "Receive an update from a loader."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsigning the URL if needed", "response": "async def _make_url(self, url: Text, request: 'Request') -> Text:\n        \"\"\"\n        Signs the URL if needed\n        \"\"\"\n\n        if self.sign_webview:\n            return await request.sign_url(url)\n\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if this object is sharable.", "response": "def is_sharable(self):\n        \"\"\"\n        Make sure that nothing inside blocks sharing.\n        \"\"\"\n        if self.buttons:\n            return (all(b.is_sharable() for b in self.buttons) and\n                    self.default_action and\n                    self.default_action.is_sharable())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_bounds_variables(self, dataset):\n        '''\n        Checks the grid boundary variables.\n\n        :param netCDF4.Dataset dataset: An open netCDF dataset\n        '''\n        recommended_ctx = TestCtx(BaseCheck.MEDIUM, 'Recommended variables to describe grid boundaries')\n\n        bounds_map = {\n            'lat_bounds': {\n                'units': 'degrees_north',\n                'comment': 'latitude values at the north and south bounds of each pixel.'\n            },\n            'lon_bounds': {\n                'units': 'degrees_east',\n                'comment': 'longitude values at the west and east bounds of each pixel.'\n            },\n            'z_bounds': {\n                'comment': 'z bounds for each z value',\n            },\n            'time_bounds': {\n                'comment': 'time bounds for each time value'\n            }\n        }\n\n        bounds_variables = [v.bounds for v in dataset.get_variables_by_attributes(bounds=lambda x: x is not None)]\n\n        for variable in bounds_variables:\n            ncvar = dataset.variables.get(variable, {})\n            recommended_ctx.assert_true(ncvar != {}, 'a variable {} should exist as indicated by a bounds attribute'.format(variable))\n            if ncvar == {}:\n                continue\n\n            units = getattr(ncvar, 'units', '')\n            if variable in bounds_map and 'units' in bounds_map[variable]:\n                recommended_ctx.assert_true(\n                    units == bounds_map[variable]['units'],\n                    'variable {} should have units {}'.format(variable, bounds_map[variable]['units'])\n                )\n            else:\n                recommended_ctx.assert_true(\n                    units != '',\n                    'variable {} should have a units attribute that is not empty'.format(variable)\n                )\n\n            comment = getattr(ncvar, 'comment', '')\n            recommended_ctx.assert_true(\n                comment != '',\n                'variable {} should have a comment and not be empty'\n            )\n\n        return recommended_ctx.to_result()", "response": "Checks the grid boundaries variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef geocode(self, string, bounds=None, region=None,\n                language=None, sensor=False):\n        '''Geocode an address.\n        Pls refer to the Google Maps Web API for the details of the parameters\n        '''\n        if isinstance(string, unicode):\n            string = string.encode('utf-8')\n\n        params = {\n            'address': self.format_string % string,\n            'sensor': str(sensor).lower()\n        }\n\n        \n        if bounds:\n            params['bounds'] = bounds\n            \n        if region:\n            params['region'] = region\n            \n        if language:\n            params['language'] = language\n            \n\n        if not self.premier:\n            url = self.get_url(params)\n        else:\n            url = self.get_signed_url(params)\n\n        return self.GetService_url(url)", "response": "Geocode an address.\n        Pls refer to the Google Maps Web API for the details of the parameters"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reverse(self, point, language=None, sensor=False):\n        '''Reverse geocode a point.\n        Pls refer to the Google Maps Web API for the details of the parameters\n        '''\n        params = {\n            'latlng': point,\n            'sensor': str(sensor).lower()\n        }\n        \n        if language:\n            params['language'] = language\n\n        if not self.premier:\n            url = self.get_url(params)\n        else:\n            url = self.get_signed_url(params)\n\n        return self.GetService_url(url)", "response": "Reverse geocode a point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Directions Service and return the response.", "response": "def GetDirections(self, origin, destination, sensor = False, mode = None, waypoints = None, alternatives  = None, avoid = None, language  = None, units = None,\n                        region = None, departure_time  = None, arrival_time = None):\n        '''Get Directions Service\n        Pls refer to the Google Maps Web API for the details of the remained parameters\n        '''\n        \n        params = {\n            'origin': origin,\n            'destination': destination,\n            'sensor': str(sensor).lower()\n        }\n\n        \n        if mode:\n            params['mode'] = mode\n            \n        if waypoints:\n            params['waypoints'] = waypoints\n            \n        if alternatives:\n            params['alternatives'] = alternatives\n            \n        if avoid:\n            params['avoid'] = avoid\n            \n        if language:\n            params['language'] = language\n            \n        if units:\n            params['units'] = units\n            \n        if region:\n            params['region'] = region\n            \n        if departure_time:\n            params['departure_time'] = departure_time\n            \n        if arrival_time:\n            params['arrival_time'] = arrival_time\n        \n        \n        if not self.premier:\n            url = self.get_url(params)\n        else:\n            url = self.get_signed_url(params)\n\n        return self.GetService_url(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a table of knobs with default values for all knobs in the database.", "response": "def get_knob_defaults_as_table(cls):\n        \"\"\"\n        Renders knobs in table\n        :return:\n        \"\"\"\n\n        knob_list = [\n            {\n                'Knob': name,\n                'Description': cls.get_registered_knob(name).description,\n                'Default': cls.get_registered_knob(name).default\n            } for name in sorted(cls._register.keys())\n        ]\n        return tabulate.tabulate(knob_list, headers='keys', tablefmt='fancy_grid')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_knobs_current_as_table(cls):\n\n        knob_list = [\n            {\n                'Knob': name,\n                'Description': cls.get_registered_knob(name).description,\n                'Value': cls.get_registered_knob(name)(),\n            } for name in sorted(cls._register.keys())\n        ]\n        return tabulate.tabulate(knob_list, headers='keys', tablefmt='fancy_grid')", "response": "Returns a table of current knobs in table format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_knob_defaults(cls):\n\n        return '\\n'.join(\n            [\n                '# {description}\\n# {knob}={default}\\n'.format(\n                    description=cls.get_registered_knob(name).description,\n                    knob=name,\n                    default=cls.get_registered_knob(name).default\n                ) for name in sorted(cls._register.keys())\n            ]\n        )", "response": "Returns a string with default values for all knob."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the value of the key from the environment variable if set to list AttributeNames", "response": "def get(self):\n        \"\"\"\n        convert json env variable if set to list\n        \"\"\"\n\n        self._cast = type([])\n        source_value = os.getenv(self.env_name)\n\n        # set the environment if it is not set\n        if source_value is None:\n            os.environ[self.env_name] = json.dumps(self.default)\n            return self.default\n\n        try:\n            val = json.loads(source_value)\n        except JSONDecodeError as e:\n            click.secho(str(e), err=True, color='red')\n            sys.exit(1)\n        except ValueError as e:\n            click.secho(e.message, err=True, color='red')\n            sys.exit(1)\n\n        if self.validator:\n            val = self.validator(val)\n\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a PPI file into a undirected graph of proteins and interactions.", "response": "def parse_ppi_graph(path: str, min_edge_weight: float = 0.0) -> Graph:\n    \"\"\"Build an undirected graph of gene interactions from edgelist file.\n\n    :param str path: The path to the edgelist file\n    :param float min_edge_weight: Cutoff to keep/remove the edges, default is 0, but could also be 0.63.\n    :return Graph: Protein-protein interaction graph\n    \"\"\"\n    logger.info(\"In parse_ppi_graph()\")\n    graph = igraph.read(os.path.expanduser(path), format=\"ncol\", directed=False, names=True)\n    graph.delete_edges(graph.es.select(weight_lt=min_edge_weight))\n    graph.delete_vertices(graph.vs.select(_degree=0))\n    logger.info(f\"Loaded PPI network.\\n\"\n                f\"Number of proteins: {len(graph.vs)}\\n\"\n                f\"Number of interactions: {len(graph.es)}\\n\")\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads an excel file on differential expression values as Gene objects.", "response": "def parse_excel(file_path: str,\n                entrez_id_header,\n                log_fold_change_header,\n                adjusted_p_value_header,\n                entrez_delimiter,\n                base_mean_header=None) -> List[Gene]:\n    \"\"\"Read an excel file on differential expression values as Gene objects.\n\n    :param str file_path: The path to the differential expression file to be parsed.\n    :param config.Params params: An object that includes paths, cutoffs and other information.\n    :return list: A list of Gene objects.\n    \"\"\"\n    logger.info(\"In parse_excel()\")\n\n    df = pd.read_excel(file_path)\n\n    return handle_dataframe(\n        df,\n        entrez_id_name=entrez_id_header,\n        log2_fold_change_name=log_fold_change_header,\n        adjusted_p_value_name=adjusted_p_value_header,\n        entrez_delimiter=entrez_delimiter,\n        base_mean=base_mean_header,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_csv(file_path: str,\n              entrez_id_header,\n              log_fold_change_header,\n              adjusted_p_value_header,\n              entrez_delimiter,\n              base_mean_header=None,\n              sep=\",\") -> List[Gene]:\n    \"\"\"Read a csv file on differential expression values as Gene objects.\n\n    :param str file_path: The path to the differential expression file to be parsed.\n    :param config.Params params: An object that includes paths, cutoffs and other information.\n    :return list: A list of Gene objects.\n    \"\"\"\n    logger.info(\"In parse_csv()\")\n\n    df = pd.read_csv(file_path, sep=sep)\n\n    return handle_dataframe(\n        df,\n        entrez_id_name=entrez_id_header,\n        log2_fold_change_name=log_fold_change_header,\n        adjusted_p_value_name=adjusted_p_value_header,\n        entrez_delimiter=entrez_delimiter,\n        base_mean=base_mean_header,\n    )", "response": "Read a csv file on differential expression values as Gene objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_dataframe(\n        df: pd.DataFrame,\n        entrez_id_name,\n        log2_fold_change_name,\n        adjusted_p_value_name,\n        entrez_delimiter,\n        base_mean=None,\n) -> List[Gene]:\n    \"\"\"Convert data frame on differential expression values as Gene objects.\n\n    :param df: Data frame with columns showing values on differential\n    expression.\n    :param cfp: An object that includes paths, cutoffs and other information.\n    :return list: A list of Gene objects.\n    \"\"\"\n    logger.info(\"In _handle_df()\")\n\n    if base_mean is not None and base_mean in df.columns:\n        df = df[pd.notnull(df[base_mean])]\n\n    df = df[pd.notnull(df[entrez_id_name])]\n    df = df[pd.notnull(df[log2_fold_change_name])]\n    df = df[pd.notnull(df[adjusted_p_value_name])]\n\n    # try:\n    #     import bio2bel_hgnc\n    # except ImportError:\n    #     logger.debug('skipping mapping')\n    # else:\n    #     manager = bio2bel_hgnc.Manager()\n    #     # TODO @cthoyt\n\n    return [\n        Gene(\n            entrez_id=entrez_id,\n            log2_fold_change=data[log2_fold_change_name],\n            padj=data[adjusted_p_value_name]\n        )\n        for _, data in df.iterrows()\n        for entrez_id in str(data[entrez_id_name]).split(entrez_delimiter)\n    ]", "response": "Convert a pandas DataFrame to a list of Gene objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_gene_list(path: str, graph: Graph, anno_type: str = \"name\") -> list:\n    # read the file\n    genes = pd.read_csv(path, header=None)[0].tolist()\n    genes = [str(int(gene)) for gene in genes]\n\n    # get those genes which are in the network\n    ind = []\n    if anno_type == \"name\":\n        ind = graph.vs.select(name_in=genes).indices\n    elif anno_type == \"symbol\":\n        ind = graph.vs.select(symbol_in=genes).indices\n    else:\n        raise Exception(\"The type can either be name or symbol, {} is not \"\n                        \"supported\".format(anno_type))\n    genes = graph.vs[ind][anno_type]\n\n    return genes", "response": "Parse a list of genes and return them if they are in the network."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_disease_ids(path: str):\n    if os.path.isdir(path) or not os.path.exists(path):\n        logger.info(\"Couldn't find the disease identifiers file. Returning empty list.\")\n        return []\n\n    df = pd.read_csv(path, names=[\"ID\"])\n    return set(df[\"ID\"].tolist())", "response": "Parse the disease identifiers file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_disease_associations(path: str, excluded_disease_ids: set):\n    if os.path.isdir(path) or not os.path.exists(path):\n        logger.info(\"Couldn't find the disease associations file. Returning empty list.\")\n        return {}\n\n    disease_associations = defaultdict(list)\n    with open(path) as input_file:\n        for line in input_file:\n            target_id, disease_id = line.strip().split(\" \")\n            if disease_id not in excluded_disease_ids:\n                disease_associations[target_id].append(disease_id)\n    return disease_associations", "response": "Parse the disease - drug target associations file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart a server for the specified chatrooms.", "response": "def run_server(chatrooms, use_default_logging=True):\n    \"\"\"Sets up and serves specified chatrooms. Main entrypoint to Hermes.\n\n    :param chatrooms: Dictionary of chatrooms to serve.\n    :param use_default_logging: (optional) Boolean. Set to True if Hermes should setup its default logging configuration.\n    \"\"\"\n    if use_default_logging:\n        configure_logging()\n\n    logger.info('Starting Hermes chatroom server...')\n\n    bots = []\n    for name, params in chatrooms.items():\n\n        bot_class = params.get('CLASS', 'hermes.Chatroom')\n        if type(bot_class) == type:\n            pass\n        else:\n            bot_class_path = bot_class.split('.')\n            if len(bot_class_path) == 1:\n                module, classname = '__main__', bot_class_path[-1]\n            else:\n                module, classname = '.'.join(bot_class_path[:-1]), bot_class_path[-1]\n            _ = __import__(module, globals(), locals(), [classname])\n            bot_class = getattr(_, classname)\n        bot = bot_class(name, params)\n        bots.append(bot)\n\n    while True:\n        try:\n            logger.info(\"Connecting to servers...\")\n            sockets = _get_sockets(bots)\n            if len(sockets.keys()) == 0:\n                logger.info('No chatrooms defined. Exiting.')\n                return\n\n            _listen(sockets)\n        except socket.error, ex:\n            if ex.errno == 9:\n                logger.exception('broken socket detected')\n            else:\n                logger.exception('Unknown socket error %d' % (ex.errno,))\n        except Exception:\n            logger.exception('Unexpected exception')\n            time.sleep(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects and gathers sockets for all bots", "response": "def _get_sockets(bots):\n    \"\"\"Connects and gathers sockets for all chatrooms\"\"\"\n    sockets = {}\n    #sockets[sys.stdin] = 'stdio'\n    for bot in bots:\n        bot.connect()\n        sockets[bot.client.Connection._sock] = bot\n    return sockets"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlistens for incoming events and dispatches them to appropriate chatroom", "response": "def _listen(sockets):\n    \"\"\"Main server loop. Listens for incoming events and dispatches them to appropriate chatroom\"\"\"\n    while True:\n        (i , o, e) = select.select(sockets.keys(),[],[],1)\n        for socket in i:\n            if isinstance(sockets[socket], Chatroom):\n                data_len = sockets[socket].client.Process(1)\n                if data_len is None or data_len == 0:\n                    raise Exception('Disconnected from server')\n            #elif sockets[socket] == 'stdio':\n            #    msg = sys.stdin.readline().rstrip('\\r\\n')\n            #    logger.info('stdin: [%s]' % (msg,))\n            else:\n                raise Exception(\"Unknown socket type: %s\" % repr(sockets[socket]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post(self, path, data, filename=None):\n        return self._send('POST', path, data, filename)", "response": "Make a POST request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a PUT request.", "response": "def put(self, path, data, filename=None):\n        \"\"\"Make a PUT request.\n\n        If a `filename` is not specified, then the data must already be\n        JSON-encoded. We specify the Content-Type accordingly.\n\n        Else, we make a multipart/form-encoded request. In this case, the data\n        variable must be a dict-like object. The file must already be\n        suitably (usually UTF-8) encoded.\n\n        Args:\n            `path`: The path to the resource.\n            `data`: The data to send. The data must already be JSON-encoded.\n            `filename`: The filename of the file to send.\n        Returns:\n            The content of the response.\n        Raises:\n            An exception depending on the HTTP status code of the response.\n        \"\"\"\n        return self._send('PUT', path, data, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _make_request(self, method, path, data=None, **kwargs):\n        _logger.debug(\"Method for request is %s\" % method)\n        url = self._construct_full_url(path)\n        _logger.debug(\"URL for request is %s\" % url)\n        self._auth_info.populate_request_data(kwargs)\n        _logger.debug(\"The arguments are %s\" % kwargs)\n\n        # Add custom headers for the request\n        if self._auth_info._headers:\n            kwargs.setdefault('headers', {}).update(self._auth_info._headers)\n\n        res = requests.request(method, url, data=data, **kwargs)\n\n        if res.ok:\n            _logger.debug(\"Request was successful.\")\n            return res.content.decode('utf-8')\n\n        if hasattr(res, 'content'):\n            _logger.debug(\"Response was %s:%s\", res.status_code, res.content)\n            raise self._exception_for(res.status_code)(\n                res.content, http_code=res.status_code\n            )\n        else:\n            msg = \"No response from URL: %s\" % res.request.url\n            _logger.error(msg)\n            raise NoResponseError(msg)", "response": "Makes a request to the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending data to a remote server either with a POST or PUT request.", "response": "def _send(self, method, path, data, filename):\n        \"\"\"Send data to a remote server, either with a POST or a PUT request.\n\n        Args:\n            `method`: The method (POST or PUT) to use.\n            `path`: The path to the resource.\n            `data`: The data to send.\n            `filename`: The filename of the file to send (if any).\n        Returns:\n            The content of the response.\n        Raises:\n            An exception depending on the HTTP status code of the response.\n        \"\"\"\n        if filename is None:\n            return self._send_json(method, path, data)\n        else:\n            return self._send_file(method, path, data, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _send_json(self, method, path, data):\n        headers = {'Content-type': 'application/json'}\n        return self._make_request(method, path, data=data, headers=headers)", "response": "Make a JSON request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a file to the resource.", "response": "def _send_file(self, method, path, data, filename):\n        \"\"\"Make a multipart/form-encoded request.\n\n        Args:\n            `method`: The method of the request (POST or PUT).\n            `path`: The path to the resource.\n            `data`: The JSON-encoded data.\n            `filename`: The filename of the file to send.\n        Returns:\n            The content of the response.\n        Raises:\n            An exception depending on the HTTP status code of the response.\n        \"\"\"\n        with open(filename, 'r') as f:\n            return self._make_request(method, path, data=data, files=[f, ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_platform_settings():\n\n    s = settings.PLATFORMS\n\n    if hasattr(settings, 'FACEBOOK') and settings.FACEBOOK:\n        s.append({\n            'class': 'bernard.platforms.facebook.platform.Facebook',\n            'settings': settings.FACEBOOK,\n        })\n\n    return s", "response": "Returns the content of settings. PLATFORMS with a twist."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def init(self):\n        self.fsm = FSM()\n\n        checks = []\n\n        # noinspection PyTypeChecker\n        async for check in self.run_checks():\n            checks.append(check)\n            logger.error('HEALTH CHECK FAIL #%s: %s', check.code, check.reason)\n\n        if checks:\n            exit(1)\n\n        await self.fsm.async_init()\n\n        self.platforms = {}", "response": "Initializes the FSM and the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning checks on itself and the FSM and the MiddlewareManager.", "response": "async def run_checks(self):\n        \"\"\"\n        Run checks on itself and on the FSM\n        \"\"\"\n\n        async for check in self.fsm.health_check():\n            yield check\n\n        async for check in self.self_check():\n            yield check\n\n        for check in MiddlewareManager.health_check():\n            yield check"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def self_check(self):\n\n        platforms = set()\n\n        for platform in get_platform_settings():\n            try:\n                name = platform['class']\n                cls: Type[Platform] = import_class(name)\n            except KeyError:\n                yield HealthCheckFail(\n                    '00004',\n                    'Missing platform `class` name in configuration.'\n                )\n            except (AttributeError, ImportError, ValueError):\n                yield HealthCheckFail(\n                    '00003',\n                    f'Platform \"{name}\" cannot be imported.'\n                )\n            else:\n                if cls in platforms:\n                    yield HealthCheckFail(\n                        '00002',\n                        f'Platform \"{name}\" is imported more than once.'\n                    )\n                platforms.add(cls)\n\n                # noinspection PyTypeChecker\n                async for check in cls.self_check():\n                    yield check", "response": "Checks that the platforms configuration is all right."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _index_classes(self) -> Dict[Text, Type[Platform]]:\n\n        out = {}\n\n        for p in get_platform_settings():\n            cls: Type[Platform] = import_class(p['class'])\n\n            if 'name' in p:\n                out[p['name']] = cls\n            else:\n                out[cls.NAME] = cls\n\n        return out", "response": "Build a name index for all platform classes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the Facebook platform. Nothing fancy.", "response": "async def build_platform(self, cls: Type[Platform], custom_id):\n        \"\"\"\n        Build the Facebook platform. Nothing fancy.\n        \"\"\"\n\n        from bernard.server.http import router\n\n        p = cls()\n\n        if custom_id:\n            p._id = custom_id\n\n        await p.async_init()\n        p.on_message(self.fsm.handle_message)\n        p.hook_up(router)\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the class for a given platform name.", "response": "def get_class(self, platform) -> Type[Platform]:\n        \"\"\"\n        For a given platform name, gets the matching class\n        \"\"\"\n\n        if platform in self._classes:\n            return self._classes[platform]\n\n        raise PlatformDoesNotExist('Platform \"{}\" is not in configuration'\n                                   .format(platform))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a valid instance of the specified platform.", "response": "async def get_platform(self, name: Text):\n        \"\"\"\n        Get a valid instance of the specified platform. Do not cache this\n        object, it might change with configuration changes.\n        \"\"\"\n\n        if not self._is_init:\n            await self.init()\n\n        if name not in self.platforms:\n            self.platforms[name] = \\\n                await self.build_platform(self.get_class(name), name)\n\n        return self.platforms[name]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def get_all_platforms(self) -> AsyncIterator[Platform]:\n\n        for name in self._classes.keys():\n            yield await self.get_platform(name)", "response": "Returns an async iterator over all platforms."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives an authentication token and payload create a message for that platform.", "response": "async def message_from_token(self, token: Text, payload: Any) \\\n            -> Tuple[Optional[BaseMessage], Optional[Platform]]:\n        \"\"\"\n        Given an authentication token, find the right platform that can\n        recognize this token and create a message for this platform.\n\n        The payload will be inserted into a Postback layer.\n        \"\"\"\n\n        async for platform in self.get_all_platforms():\n            m = await platform.message_from_token(token, payload)\n\n            if m:\n                return m, platform\n\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_args(parser, positional=False):\n    group = parser.add_argument_group(\"read loading\")\n    group.add_argument(\"reads\" if positional else \"--reads\",\n        nargs=\"+\", default=[],\n        help=\"Paths to bam files. Any number of paths may be specified.\")\n\n    group.add_argument(\n        \"--read-source-name\",\n        nargs=\"+\",\n        help=\"Names for each read source. The number of names specified \"\n        \"must match the number of bam files. If not specified, filenames are \"\n        \"used for names.\")\n\n    # Add filters\n    group = parser.add_argument_group(\n        \"read filtering\",\n        \"A number of read filters are available. See the pysam \"\n        \"documentation (http://pysam.readthedocs.org/en/latest/api.html) \"\n        \"for details on what these fields mean. When multiple filter \"\n        \"options are specified, reads must match *all* filters.\")\n\n    for (name, (kind, message, function)) in READ_FILTERS.items():\n        extra = {}\n        if kind is bool:\n            extra[\"action\"] = \"store_true\"\n            extra[\"default\"] = None\n        elif kind is int:\n            extra[\"type\"] = int\n            extra[\"metavar\"] = \"N\"\n        elif kind is str:\n            extra[\"metavar\"] = \"STRING\"\n        group.add_argument(\"--\" + name.replace(\"_\", \"-\"),\n            help=message,\n            **extra)", "response": "Adds command line arguments for specifying read sources."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive parsed commandline arguments returns a list of ReadSource objects", "response": "def load_from_args(args):\n    \"\"\"\n    Given parsed commandline arguments, returns a list of ReadSource objects\n    \"\"\"\n    if not args.reads:\n        return None\n\n    if args.read_source_name:\n        read_source_names = util.expand(\n            args.read_source_name,\n            'read_source_name',\n            'read source',\n            len(args.reads))\n    else:\n        read_source_names = util.drop_prefix(args.reads)\n\n    filters = []\n    for (name, info) in READ_FILTERS.items():\n        value = getattr(args, name)\n        if value is not None:\n            filters.append(functools.partial(info[-1], value))\n\n    return [\n        load_bam(filename, name, filters)\n        for (filename, name)\n        in zip(args.reads, read_source_names)\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef version_greater(minimum, version):\n\n    # Chop up the version strings\n    minimum = [int(i) for i in minimum.split('.')]\n    version = [int(i) for i in version.split('.')]\n\n    # Compare the versions element by element\n    for mini, vers in zip(minimum, version):\n        if vers < mini:\n            # If it's less than, we definitely don't match\n            return False\n        elif vers > mini:\n            # If it's greater than, we definitely match\n            return True\n\n        # OK, the elements are equal; loop around and check out the\n        # next element\n\n    # All elements are equal\n    return True", "response": "Compare two version strings and return True if the minimum is greater than the version."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compact_bucket(db, buck_key, limit):\n\n    # Suck in the bucket records and generate our bucket\n    records = db.lrange(str(buck_key), 0, -1)\n    loader = limits.BucketLoader(limit.bucket_class, db, limit,\n                                 str(buck_key), records, stop_summarize=True)\n\n    # We now have the bucket loaded in; generate a 'bucket' record\n    buck_record = msgpack.dumps(dict(bucket=loader.bucket.dehydrate(),\n                                     uuid=str(uuid.uuid4())))\n\n    # Now we need to insert it into the record list\n    result = db.linsert(str(buck_key), 'after', loader.last_summarize_rec,\n                        buck_record)\n\n    # Were we successful?\n    if result < 0:\n        # Insert failed; we'll try again when max_age is hit\n        LOG.warning(\"Bucket compaction on %s failed; will retry\" % buck_key)\n        return\n\n    # OK, we have confirmed that the compacted bucket record has been\n    # inserted correctly; now all we need to do is trim off the\n    # outdated update records\n    db.ltrim(str(buck_key), loader.last_summarize_idx + 1, -1)", "response": "This function performs the compaction operation on the bucket containing the given key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compactor(conf):\n\n    # Get the database handle\n    db = conf.get_database('compactor')\n\n    # Get the limits container\n    limit_map = LimitContainer(conf, db)\n\n    # Get the compactor configuration\n    config = conf['compactor']\n\n    # Make sure compaction is enabled\n    if get_int(config, 'max_updates', 0) <= 0:\n        # We'll just warn about it, since they could be running\n        # the compactor with a different configuration file\n        LOG.warning(\"Compaction is not enabled.  Enable it by \"\n                    \"setting a positive integer value for \"\n                    \"'compactor.max_updates' in the configuration.\")\n\n    # Select the bucket key getter\n    key_getter = GetBucketKey.factory(config, db)\n\n    LOG.info(\"Compactor initialized\")\n\n    # Now enter our loop\n    while True:\n        # Get a bucket key to compact\n        try:\n            buck_key = limits.BucketKey.decode(key_getter())\n        except ValueError as exc:\n            # Warn about invalid bucket keys\n            LOG.warning(\"Error interpreting bucket key: %s\" % exc)\n            continue\n\n        # Ignore version 1 keys--they can't be compacted\n        if buck_key.version < 2:\n            continue\n\n        # Get the corresponding limit class\n        try:\n            limit = limit_map[buck_key.uuid]\n        except KeyError:\n            # Warn about missing limits\n            LOG.warning(\"Unable to compact bucket for limit %s\" %\n                        buck_key.uuid)\n            continue\n\n        LOG.debug(\"Compacting bucket %s\" % buck_key)\n\n        # OK, we now have the limit (which we really only need for\n        # the bucket class); let's compact the bucket\n        try:\n            compact_bucket(db, buck_key, limit)\n        except Exception:\n            LOG.exception(\"Failed to compact bucket %s\" % buck_key)\n        else:\n            LOG.debug(\"Finished compacting bucket %s\" % buck_key)", "response": "This function is called by the daemon to compact the set of bucket keys that need to be compacted."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef factory(cls, config, db):\n\n        # Make sure that the client supports register_script()\n        if not hasattr(db, 'register_script'):\n            LOG.debug(\"Redis client does not support register_script()\")\n            return GetBucketKeyByLock(config, db)\n\n        # OK, the client supports register_script(); what about the\n        # server?\n        info = db.info()\n        if version_greater('2.6', info['redis_version']):\n            LOG.debug(\"Redis server supports register_script()\")\n            return GetBucketKeyByScript(config, db)\n\n        # OK, use our fallback...\n        LOG.debug(\"Redis server does not support register_script()\")\n        return GetBucketKeyByLock(config, db)", "response": "This method is used to create an instance of GetBucketKey based on a configuration and database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a bucket key to compact. If none are available returns None.", "response": "def get(self, now):\n        \"\"\"\n        Get a bucket key to compact.  If none are available, returns\n        None.  This uses a configured lock to ensure that the bucket\n        key is popped off the sorted set in an atomic fashion.\n\n        :param now: The current time, as a float.  Used to ensure the\n                    bucket key has been aged sufficiently to be\n                    quiescent.\n\n        :returns: A bucket key ready for compaction, or None if no\n                  bucket keys are available or none have aged\n                  sufficiently.\n        \"\"\"\n\n        with self.lock:\n            items = self.db.zrangebyscore(self.key, 0, now - self.min_age,\n                                          start=0, num=1)\n            # Did we get any items?\n            if not items:\n                return None\n\n            # Drop the item we got\n            item = items[0]\n            self.db.zrem(item)\n\n            return item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, now):\n\n        items = self.script(keys=[self.key], args=[now - self.min_age])\n        return items[0] if items else None", "response": "Get a bucket key to compact. If none are available returns\n        None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef recheck_limits(self):\n\n        limit_data = self.control_daemon.get_limits()\n\n        try:\n            # Get the new checksum and list of limits\n            new_sum, new_limits = limit_data.get_limits(self.limit_sum)\n\n            # Convert the limits list into a list of objects\n            lims = database.limits_hydrate(self.db, new_limits)\n\n            # Save the new data\n            self.limits = lims\n            self.limit_map = dict((lim.uuid, lim) for lim in lims)\n            self.limit_sum = new_sum\n        except control.NoChangeException:\n            # No changes to process; just keep going...\n            return\n        except Exception:\n            # Log an error\n            LOG.exception(\"Could not load limits\")\n\n            # Get our error set and publish channel\n            control_args = self.conf['control']\n            error_key = control_args.get('errors_key', 'errors')\n            error_channel = control_args.get('errors_channel', 'errors')\n\n            # Get an informative message\n            msg = \"Failed to load limits: \" + traceback.format_exc()\n\n            # Store the message into the error set.  We use a set\n            # here because it's likely that more than one node\n            # will generate the same message if there is an error,\n            # and this avoids an explosion in the size of the set.\n            with utils.ignore_except():\n                self.db.sadd(error_key, msg)\n\n            # Publish the message to a channel\n            with utils.ignore_except():\n                self.db.publish(error_channel, msg)", "response": "Re - check the current limits and save the new limits."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(text, elements, fallback):\n    # this is a raw list of elements that may contain overlaps.\n    tokens = []\n    for etype in elements:\n        for match in etype.find(text):\n            tokens.append(Token(etype, match, text, fallback))\n    tokens.sort()\n    tokens = _resolve_overlap(tokens)\n    return make_elements(tokens, text, fallback=fallback)", "response": "Parse given text and produce a list of inline elements."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_elements(tokens, text, start=0, end=None, fallback=None):\n    result = []\n    end = end or len(text)\n    prev_end = start\n    for token in tokens:\n        if prev_end < token.start:\n            result.append(fallback(text[prev_end:token.start]))\n        result.append(token.as_element())\n        prev_end = token.end\n    if prev_end < end:\n        result.append(fallback(text[prev_end:end]))\n    return result", "response": "Make elements from a list of parsed tokens."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_links_or_emphs(text, root_node):\n    delimiters_re = re.compile(r'(?:!?\\[|\\*+|_+)')\n    i = 0\n    delimiters = []\n    escape = False\n    matches = []\n    code_pattern = re.compile(r'(?<!`)(`+)(?!`)([\\s\\S]+?)(?<!`)\\1(?!`)')\n\n    while i < len(text):\n        if escape:\n            escape = False\n            i += 1\n        elif text[i] == '\\\\':\n            escape = True\n            i += 1\n        elif code_pattern.match(text, i):\n            i = code_pattern.match(text, i).end()\n        elif text[i] == ']':\n            node = look_for_image_or_link(text, delimiters, i, root_node, matches)\n            if node:\n                i = node.end()\n                matches.append(node)\n            else:\n                i += 1\n        else:\n            m = delimiters_re.match(text, i)\n            if m:\n                delimiters.append(Delimiter(m, text))\n                i = m.end()\n            else:\n                i += 1\n    process_emphasis(text, delimiters, None, matches)\n    return matches", "response": "Fink links or images or emphasis from text."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts just the domain name from an URL and adds it to a list", "response": "def extract_domain(var_name, output):\n    \"\"\"\n    Extracts just the domain name from an URL and adds it to a list\n    \"\"\"\n\n    var = getenv(var_name)\n\n    if var:\n        p = urlparse(var)\n        output.append(p.hostname)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef numchannels(samples:np.ndarray) -> int:\n    if len(samples.shape) == 1:\n        return 1\n    else:\n        return samples.shape[1]", "response": "Returns the number of channels present in samples"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a function which returns an anonymized version of the application that will be used to filter the application based on the given configuration.", "response": "def turnstile_filter(global_conf, **local_conf):\n    \"\"\"\n    Factory function for turnstile.\n\n    Returns a function which, when passed the application, returns an\n    instance of the TurnstileMiddleware.\n    \"\"\"\n\n    # Select the appropriate middleware class to return\n    klass = TurnstileMiddleware\n    if 'turnstile' in local_conf:\n        klass = utils.find_entrypoint('turnstile.middleware',\n                                      local_conf['turnstile'], required=True)\n\n    def wrapper(app):\n        return klass(app, local_conf)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef recheck_limits(self):\n\n        limit_data = self.control_daemon.get_limits()\n\n        try:\n            # Get the new checksum and list of limits\n            new_sum, new_limits = limit_data.get_limits(self.limit_sum)\n\n            # Convert the limits list into a list of objects\n            lims = database.limits_hydrate(self.db, new_limits)\n\n            # Build a new mapper\n            mapper = routes.Mapper(register=False)\n            for lim in lims:\n                lim._route(mapper)\n\n            # Save the new data\n            self.limits = lims\n            self.limit_sum = new_sum\n            self.mapper = mapper\n        except control.NoChangeException:\n            # No changes to process; just keep going...\n            return\n        except Exception:\n            # Log an error\n            LOG.exception(\"Could not load limits\")\n\n            # Get our error set and publish channel\n            control_args = self.conf['control']\n            error_key = control_args.get('errors_key', 'errors')\n            error_channel = control_args.get('errors_channel', 'errors')\n\n            # Get an informative message\n            msg = \"Failed to load limits: \" + traceback.format_exc()\n\n            # Store the message into the error set.  We use a set\n            # here because it's likely that more than one node\n            # will generate the same message if there is an error,\n            # and this avoids an explosion in the size of the set.\n            with utils.ignore_except():\n                self.db.sadd(error_key, msg)\n\n            # Publish the message to a channel\n            with utils.ignore_except():\n                self.db.publish(error_channel, msg)", "response": "Re - check the current limits and return the new cache level."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_delay(self, delay, limit, bucket, environ, start_response):\n\n        # Set up the default status\n        status = self.conf.status\n\n        # Set up the retry-after header...\n        headers = HeadersDict([('Retry-After', \"%d\" % math.ceil(delay))])\n\n        # Let format fiddle with the headers\n        status, entity = limit.format(status, headers, environ, bucket,\n                                      delay)\n\n        # Return the response\n        start_response(status, headers.items())\n        return entity", "response": "Formats the over - limit response for the request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef db(self):\n\n        # Initialize the database handle\n        if not self._db:\n            self._db = self.conf.get_database()\n\n        return self._db", "response": "Returns a handle for the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the first available entry point with the given name in the given group.", "response": "def find_entrypoint(group, name, compat=True, required=False):\n    \"\"\"\n    Finds the first available entrypoint with the given name in the\n    given group.\n\n    :param group: The entrypoint group the name can be found in.  If\n                  None, the name is not presumed to be an entrypoint.\n    :param name: The name of the entrypoint.\n    :param compat: If True, and if the name parameter contains a ':',\n                   the name will be interpreted as a module name and\n                   an object name, separated by a colon.  This is\n                   provided for compatibility.\n    :param required: If True, and no corresponding entrypoint can be\n                     found, an ImportError will be raised.  If False\n                     (the default), None will be returned instead.\n\n    :returns: The entrypoint object, or None if one could not be\n              loaded.\n    \"\"\"\n\n    if group is None or (compat and ':' in name):\n        try:\n            return pkg_resources.EntryPoint.parse(\"x=\" + name).load(False)\n        except (ImportError, pkg_resources.UnknownExtra) as exc:\n            pass\n    else:\n        for ep in pkg_resources.iter_entry_points(group, name):\n            try:\n                # Load and return the object\n                return ep.load()\n            except (ImportError, pkg_resources.UnknownExtra):\n                # Couldn't load it; try the next one\n                continue\n\n    # Raise an ImportError if requested\n    if required:\n        raise ImportError(\"Cannot import %r entrypoint %r\" % (group, name))\n\n    # Couldn't find one...\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transfer(self, transfer_payload=None, *, from_user, to_user):\n\n        if self.persist_id is None:\n            raise EntityNotYetPersistedError(('Entities cannot be transferred '\n                                              'until they have been '\n                                              'persisted'))\n\n        return self.plugin.transfer(self.persist_id, transfer_payload,\n                                    from_user=from_user, to_user=to_user)", "response": "Transfer this entity to another owner on the backing\n            persistence layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntransfer this Right to another owner on the backing persistence layer.", "response": "def transfer(self, rights_assignment_data=None, *, from_user, to_user,\n                 rights_assignment_format='jsonld'):\n        \"\"\"Transfer this Right to another owner on the backing\n        persistence layer.\n\n        Args:\n            rights_assignment_data (dict): Model data for the resulting\n                :class:`~.RightsAssignment`\n            from_user (any, keyword): A user based on the model specified\n                by the persistence layer\n            to_user (any, keyword): A user based on the model specified\n                by the persistence layer\n            rights_assignment_format (str, keyword, optional): Data\n                format of the created entity; must be one of:\n\n                    - 'jsonld' (default)\n                    - 'json'\n                    - 'ipld'\n\n        Returns:\n            :class:`~.RightsAssignment`: The RightsAssignment entity\n            created from this transfer\n\n        Raises:\n            See :meth:`~.TransferrableEntity.transfer`\n        \"\"\"\n\n        rights_assignment = RightsAssignment.from_data(\n            rights_assignment_data or {},\n            plugin=self.plugin)\n        transfer_payload = rights_assignment._to_format(\n            data_format=rights_assignment_format)\n        transfer_id = super().transfer(transfer_payload, from_user=from_user,\n                                       to_user=to_user)\n\n        rights_assignment.persist_id = transfer_id\n        return rights_assignment"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the underlying repo object", "response": "def _set_repo(self, url):\n        \"\"\"sets the underlying repo object\"\"\"\n        if url.startswith('http'):\n            try:\n                self.repo = Proxy(url)\n            except ProxyError, e:\n                log.exception('Error setting repo: %s' % url)\n                raise GritError(e)\n        else:\n            try:\n                self.repo = Local(url)\n            except NotGitRepository:\n                raise GritError('Invalid url: %s' % url)\n            except Exception, e:\n                log.exception('Error setting repo: %s' % url)\n                raise GritError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef new(self, url, clone_from=None, bare=True):\n        #note to self: look into using templates (--template)\n        if clone_from:\n            self.clone(path=url, bare=bare)\n        else:\n            if url.startswith('http'):\n                proxy = Proxy(url)\n                proxy.new(path=url, bare=bare)\n            else:\n                local = Local.new(path=url, bare=bare)\n        return Repo(url)", "response": "Creates a new Repo instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclones the repository to path.", "response": "def clone(self, path=None, bare=False):\n        \"\"\"\n        Clone the repository to path (requires git).\n\n        :param path: Destination filesystem path.\n        :param bare: Make this a bare repo.\n\n        :returns: grit.Repo instance.\n\n        For example:\n\n            >>> r = Repo(\"http://localhost/projects/a/b/c\")\n            >>> c = r.clone('/tmp')\n            >>> c\n            <grit.Repo \"/tmp/c\">\n\n        \"\"\"\n        #note to self: see --reference, --shared options\n        if path is None:\n            path = os.path.basename(url)\n        try:\n            self.git.clone(self.url, path, '--bare'*bare, '--depth=0')\n            return Repo(path)\n        except Exception, e:\n            raise GritError(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck Emails in List Wether they are Correct or not", "response": "def CheckEmails(self, checkTypo=False, fillWrong=True):\n        '''Checks Emails in List Wether they are Correct or not'''\n        self.wrong_emails = []\n        for email in self.emails:\n            if self.CheckEmail(email, checkTypo) is False:\n                self.wrong_emails.append(email)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CheckEmail(self, email, checkTypo=False):\n        '''Checks a Single email if it is correct'''\n        contents = email.split('@')\n        if len(contents) == 2:\n            if contents[1] in self.valid:\n                return True\n        return False", "response": "Checks a Single email if it is correct"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncorrect Emails in wrong_emails", "response": "def CorrectWrongEmails(self, askInput=True):\n        '''Corrects Emails in wrong_emails'''\n        for email in self.wrong_emails:\n            corrected_email = self.CorrectEmail(email)\n            self.emails[self.emails.index(email)] = corrected_email\n\n        self.wrong_emails = []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef CorrectEmail(self, email):\n        '''Returns a Corrected email USER INPUT REQUIRED'''\n        print(\"Wrong Email : \"+email)\n        contents = email.split('@')\n        if len(contents) == 2:\n            domain_data = contents[1].split('.')\n\n            for vemail in self.valid:\n                alters = perms(vemail.split('.', 1)[0])\n                if domain_data[0] in alters and qyn.query_yes_no(\"Did you mean : \" + contents[0] + '@' + vemail) is True:\n                        return contents[0] + '@' + vemail\n\n            corrected = input('Enter Corrected Email : ')\n            while self.CheckEmail(corrected) is False:\n                corrected = input('PLEASE Enter \"Corrected\" Email : ')\n            return corrected\n        else:\n            print('Looks like you missed/overused `@`')\n            if len(contents) == 1:\n                for vemail in self.valid:\n                    if email[len(email) - len(vemail):] == vemail and qyn.query_yes_no(\"Did you mean : \" + email[:len(email) - len(vemail)] + '@' + vemail) is True:\n                        return email[:len(email) - len(vemail)] + '@' + vemail\n\n            corrected = input('Enter Corrected Email : ')\n            while self.CheckEmail(corrected) is False:\n                corrected = input('PLEASE Enter \"Corrected\" Email : ')\n            return corrected", "response": "Returns a Corrected email USER INPUT REQUIRED"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an element to the parser.", "response": "def add_element(self, element, override=False):\n        \"\"\"Add an element to the parser.\n\n        :param element: the element class.\n        :param override: whether to replace the default element based on.\n\n        .. note:: If one needs to call it inside ``__init__()``, please call it after\n             ``super().__init__()`` is called.\n        \"\"\"\n        if issubclass(element, inline.InlineElement):\n            dest = self.inline_elements\n        elif issubclass(element, block.BlockElement):\n            dest = self.block_elements\n        else:\n            raise TypeError(\n                'The element should be a subclass of either `BlockElement` or '\n                '`InlineElement`.'\n            )\n        if not override:\n            dest[element.__name__] = element\n        else:\n            for cls in element.__bases__:\n                if cls in dest.values():\n                    dest[cls.__name__] = element\n                    break\n            else:\n                dest[element.__name__] = element"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndoing the actual parsing and returns an AST or parsed element.", "response": "def parse(self, source_or_text):\n        \"\"\"Do the actual parsing and returns an AST or parsed element.\n\n        :param source_or_text: the text or source object.\n            Based on the type, it will do following:\n            - text: returns the parsed Document element.\n            - source: parse the source and returns the parsed children as a list.\n        \"\"\"\n        if isinstance(source_or_text, string_types):\n            block.parser = self\n            inline.parser = self\n            return self.block_elements['Document'](source_or_text)\n        element_list = self._build_block_element_list()\n        ast = []\n        while not source_or_text.exhausted:\n            for ele_type in element_list:\n                if ele_type.match(source_or_text):\n                    result = ele_type.parse(source_or_text)\n                    if not hasattr(result, 'priority'):\n                        result = ele_type(result)\n                    ast.append(result)\n                    break\n            else:\n                # Quit the current parsing and go back to the last level.\n                break\n        return ast"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_inline(self, text):\n        element_list = self._build_inline_element_list()\n        return inline_parser.parse(\n            text, element_list, fallback=self.inline_elements['RawText']\n        )", "response": "Parses the given text into inline elements."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a list of block elements ordered from highest priority to lowest.", "response": "def _build_block_element_list(self):\n        \"\"\"Return a list of block elements, ordered from highest priority to lowest.\n        \"\"\"\n        return sorted(\n            [e for e in self.block_elements.values() if not e.virtual],\n            key=lambda e: e.priority,\n            reverse=True\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassemble basic WSGI-compatible application providing functionality of git-http-backend. content_path (Defaults to '.' = \"current\" directory) The path to the folder that will be the root of served files. Accepts relative paths. uri_marker (Defaults to '') Acts as a \"virtual folder\" separator between decorative URI portion and the actual (relative to content_path) path that will be appended to content_path and used for pulling an actual file. the URI does not have to start with contents of uri_marker. It can be preceeded by any number of \"virtual\" folders. For --uri_marker 'my' all of these will take you to the same repo: http://localhost/my/HEAD http://localhost/admysf/mylar/zxmy/my/HEAD This WSGI hanlder will cut and rebase the URI when it's time to read from file system. Default of '' means that no cutting marker is used, and whole URI after FQDN is used to find file relative to content_path. returns WSGI application instance.", "response": "def make_app(*args, **kw):\n    '''\n    Assembles basic WSGI-compatible application providing functionality of git-http-backend.\n\n    content_path (Defaults to '.' = \"current\" directory)\n        The path to the folder that will be the root of served files. Accepts relative paths.\n\n    uri_marker (Defaults to '')\n        Acts as a \"virtual folder\" separator between decorative URI portion and\n        the actual (relative to content_path) path that will be appended to\n        content_path and used for pulling an actual file.\n\n        the URI does not have to start with contents of uri_marker. It can\n        be preceeded by any number of \"virtual\" folders. For --uri_marker 'my'\n        all of these will take you to the same repo:\n            http://localhost/my/HEAD\n            http://localhost/admysf/mylar/zxmy/my/HEAD\n        This WSGI hanlder will cut and rebase the URI when it's time to read from file system.\n\n        Default of '' means that no cutting marker is used, and whole URI after FQDN is\n        used to find file relative to content_path.\n\n    returns WSGI application instance.\n    '''\n\n    default_options = [\n        ['content_path','.'],\n        ['uri_marker','']\n    ]\n    args = list(args)\n    options = dict(default_options)\n    options.update(kw)\n    while default_options and args:\n        _d = default_options.pop(0)\n        _a = args.pop(0)\n        options[_d[0]] = _a\n    options['content_path'] = os.path.abspath(options['content_path'].decode('utf8'))\n    options['uri_marker'] = options['uri_marker'].decode('utf8')\n\n    selector = WSGIHandlerSelector()\n    git_inforefs_handler = GitHTTPBackendInfoRefs(**options)\n    git_rpc_handler = GitHTTPBackendSmartHTTP(**options)\n    static_handler = StaticServer(**options)\n    file_handler = FileServer(**options)\n    json_handler = JSONServer(**options)\n    ui_handler = UIServer(**options)\n\n    if options['uri_marker']:\n        marker_regex = r'(?P<decorative_path>.*?)(?:/'+ options['uri_marker'] + ')'\n    else:\n        marker_regex = ''\n\n    selector.add(\n        marker_regex + r'(?P<working_path>.*?)/info/refs\\?.*?service=(?P<git_command>git-[^&]+).*$',\n        GET = git_inforefs_handler,\n        HEAD = git_inforefs_handler\n        )\n    selector.add(\n        marker_regex + r'(?P<working_path>.*)/(?P<git_command>git-[^/]+)$',\n        POST = git_rpc_handler\n        )\n    selector.add(\n        marker_regex + r'/static/(?P<working_path>.*)$',\n        GET = static_handler,\n        HEAD = static_handler)\n    selector.add(\n        marker_regex + r'(?P<working_path>.*)/file$',\n        GET = file_handler,\n        HEAD = file_handler)\n    selector.add(\n        marker_regex + r'(?P<working_path>.*)$',\n        GET = ui_handler,\n        POST = json_handler,\n        HEAD = ui_handler)\n\n    return selector"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an aware or naive datetime. datetime depending on settings. USE_TZ.", "response": "def now(tzinfo=True):\n    \"\"\"\n    Return an aware or naive datetime.datetime, depending on settings.USE_TZ.\n    \"\"\"\n    if dj_now:\n        return dj_now()\n\n    if tzinfo:\n        # timeit shows that datetime.now(tz=utc) is 24% slower\n        return datetime.utcnow().replace(tzinfo=utc)\n    return datetime.now()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning item as dict. __getitem__ but using keys with dots.", "response": "def dottable_getitem(data, dottable_key, default=None):\n    \"\"\"Return item as ``dict.__getitem__` but using keys with dots.\n\n    It does not address indexes in iterables.\n    \"\"\"\n    def getitem(value, *keys):\n        if not keys:\n            return default\n        elif len(keys) == 1:\n            key = keys[0]\n            if isinstance(value, MutableMapping):\n                return value.get(key, default)\n            elif isinstance(value, Sequence) and \\\n                    not isinstance(value, six.string_types):\n                return [getitem(v, key) for v in value]\n            return default\n        return getitem(getitem(value, keys[0]), *keys[1:])\n    return getitem(data, *dottable_key.split('.'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_unit(data, p, m='a'):\n    if data is None:\n        return p is None\n\n    # compile search value only once for non exact search\n    if m != 'e' and isinstance(p, six.string_types):\n        p = re.compile(p)\n\n    if isinstance(data, Sequence) and not isinstance(data, six.string_types):\n        return any([match_unit(field, p, m=m)\n                    for field in data])\n    elif isinstance(data, MutableMapping):\n        return any([match_unit(field, p, m=m)\n                    for field in data.values()])\n\n    # Inclusive range query\n    if isinstance(p, tuple):\n        left, right = p\n        return (left <= data) and (data <= right)\n\n    if m == 'e':\n        return six.text_type(data) == p\n    return p.search(six.text_type(data)) is not None", "response": "Match data to basic match unit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_ppi_network(\n        ppi_graph_path: str,\n        dge_list: List[Gene],\n        max_adj_p: float,\n        max_log2_fold_change: float,\n        min_log2_fold_change: float,\n        ppi_edge_min_confidence: Optional[float] = None,\n        current_disease_ids_path: Optional[str] = None,\n        disease_associations_path: Optional[str] = None,\n) -> Network:\n    \"\"\"Generate the protein-protein interaction network.\n\n    :return Network: Protein-protein interaction network with information on differential expression.\n    \"\"\"\n    # Compilation of a protein-protein interaction (PPI) graph (HIPPIE)\n    protein_interactions = parsers.parse_ppi_graph(ppi_graph_path, ppi_edge_min_confidence)\n    protein_interactions = protein_interactions.simplify()\n\n    if disease_associations_path is not None and current_disease_ids_path is not None:\n        current_disease_ids = parsers.parse_disease_ids(current_disease_ids_path)\n        disease_associations = parsers.parse_disease_associations(disease_associations_path,\n                                                                  current_disease_ids)\n    else:\n        disease_associations = None\n\n    # Build an undirected weighted graph with the remaining interactions based on Entrez gene IDs\n    network = Network(\n        protein_interactions,\n        max_adj_p=max_adj_p,\n        max_l2fc=max_log2_fold_change,\n        min_l2fc=min_log2_fold_change,\n    )\n    network.set_up_network(dge_list, disease_associations=disease_associations)\n\n    return network", "response": "Generate a protein - protein interaction network with information on differential expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_dge(\n        dge_path: str,\n        entrez_id_header: str,\n        log2_fold_change_header: str,\n        adj_p_header: str,\n        entrez_delimiter: str,\n        base_mean_header: Optional[str] = None\n) -> List[Gene]:\n    \"\"\"Parse a differential expression file.\n\n    :param dge_path: Path to the file.\n    :param entrez_id_header: Header for the Entrez identifier column\n    :param log2_fold_change_header: Header for the log2 fold change column\n    :param adj_p_header: Header for the adjusted p-value column\n    :param entrez_delimiter: Delimiter between Entrez ids.\n    :param base_mean_header: Header for the base mean column.\n    :return: A list of genes.\n    \"\"\"\n    if dge_path.endswith('.xlsx'):\n        return parsers.parse_excel(\n            dge_path,\n            entrez_id_header=entrez_id_header,\n            log_fold_change_header=log2_fold_change_header,\n            adjusted_p_value_header=adj_p_header,\n            entrez_delimiter=entrez_delimiter,\n            base_mean_header=base_mean_header,\n        )\n\n    if dge_path.endswith('.csv'):\n        return parsers.parse_csv(\n            dge_path,\n            entrez_id_header=entrez_id_header,\n            log_fold_change_header=log2_fold_change_header,\n            adjusted_p_value_header=adj_p_header,\n            entrez_delimiter=entrez_delimiter,\n            base_mean_header=base_mean_header,\n        )\n\n    if dge_path.endswith('.tsv'):\n        return parsers.parse_csv(\n            dge_path,\n            entrez_id_header=entrez_id_header,\n            log_fold_change_header=log2_fold_change_header,\n            adjusted_p_value_header=adj_p_header,\n            entrez_delimiter=entrez_delimiter,\n            base_mean_header=base_mean_header,\n            sep=\"\\t\"\n        )\n\n    raise ValueError(f'Unsupported extension: {dge_path}')", "response": "Parses a differential expression file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the configuration from a plain Python file.", "response": "def _load(self, file_path: Text) -> None:\n        \"\"\"\n        Load the configuration from a plain Python file. This file is executed\n        on its own.\n\n        Only keys matching the CONFIG_ATTR will be loaded. Basically, it's\n        CONFIG_KEYS_LIKE_THIS.\n\n        :param file_path: Path to the file to load\n        \"\"\"\n\n        # noinspection PyUnresolvedReferences\n        module_ = types.ModuleType('settings')\n        module_.__file__ = file_path\n\n        try:\n            with open(file_path, encoding='utf-8') as f:\n                exec(compile(f.read(), file_path, 'exec'), module_.__dict__)\n        except IOError as e:\n            e.strerror = 'Unable to load configuration file ({})'\\\n                .format(e.strerror)\n            raise\n\n        for key in dir(module_):\n            if CONFIG_ATTR.match(key):\n                self[key] = getattr(module_, key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the actual settings object or creates it if missing.", "response": "def _settings(self) -> Settings:\n        \"\"\"\n        Return the actual settings object, or create it if missing.\n        \"\"\"\n        if self.__dict__['__settings'] is None:\n            self.__dict__['__settings'] = Settings()\n            for file_path in self._get_files():\n                if file_path:\n                    # noinspection PyProtectedMember\n                    self.__dict__['__settings']._load(file_path)\n        return self.__dict__['__settings']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart the lock. Here we use a SETNX-based algorithm. It's quite shitty, change it.", "response": "async def _start(self, key: Text) -> None:\n        \"\"\"\n        Start the lock.\n\n        Here we use a SETNX-based algorithm. It's quite shitty, change it.\n        \"\"\"\n        for _ in range(0, 1000):\n            with await self.pool as r:\n                just_set = await r.set(\n                    self.lock_key(key),\n                    '',\n                    expire=settings.REGISTER_LOCK_TIME,\n                    exist=r.SET_IF_NOT_EXIST,\n                )\n\n                if just_set:\n                    break\n\n            await asyncio.sleep(settings.REDIS_POLL_INTERVAL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _get(self, key: Text) -> Dict[Text, Any]:\n\n        try:\n            with await self.pool as r:\n                return ujson.loads(await r.get(self.register_key(key)))\n        except (ValueError, TypeError):\n            return {}", "response": "Get the value for the key. It is automatically deserialized from JSON\n        and returns an empty dictionary by default."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace the register with a new value.", "response": "async def _replace(self, key: Text, data: Dict[Text, Any]) -> None:\n        \"\"\"\n        Replace the register with a new value.\n        \"\"\"\n\n        with await self.pool as r:\n            await r.set(self.register_key(key), ujson.dumps(data))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getFileName(self, suffix=None, extension=\"jar\"):\n\n        assert (self._artifactId is not None)\n        assert (self._version is not None)\n\n        return \"{0}-{1}{2}{3}\".format(\n            self._artifactId,\n            self._version.getRawString(),\n            \"-\" + suffix.lstrip(\"-\") if suffix is not None else \"\",\n            \".\" + extension.lstrip(\".\") if extension is not None else \"\"\n        )", "response": "Returns the basename of the artifact s file using Maven s conventions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getPath(self, suffix=None, extension=\"jar\", separator=os.sep):\n\n        assert (self._groupId is not None)\n\n        resultComponents = [\n            self._groupId.replace(\".\", separator)\n        ]\n\n        if self._artifactId is not None:\n            resultComponents.append(self._artifactId)\n\n            version = self._version\n            if version is not None:\n                resultComponents.append(version.getRawString())\n                resultComponents.append(self.getFileName(suffix, extension))\n\n        return separator.join(resultComponents)", "response": "Returns the full path of the current artifact in a Maven repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the absolute path of the artifact.", "response": "def getArtifactPath(self, artifact, suffix=None, extension=\"jar\"):\n        \"\"\"\n        Joins the root path of the repository with the relative path returned\n        by the artifact's getPath() method\n        \"\"\"\n        return os.path.join(self._rootPath, artifact.getPath(suffix, extension, os.sep))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_state_changed(self, state):\n        if state:\n            self.editor.painted.connect(self._paint_margins)\n            self.editor.key_pressed.connect(self._on_key_pressed)\n            self.editor.repaint()\n        else:\n            self.editor.painted.disconnect(self._paint_margins)\n            self.editor.key_pressed.disconnect(self._on_key_pressed)\n            self.editor.repaint()", "response": "Connects and disconnects to the painted event of the editor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npaint the right margin after editor paint event.", "response": "def _paint_margins(self, event):\n        \"\"\" Paints the right margin after editor paint event. \"\"\"\n        font = QtGui.QFont(self.editor.font_name, self.editor.font_size +\n                           self.editor.zoom_level)\n        metrics = QtGui.QFontMetricsF(font)\n        painter = QtGui.QPainter(self.editor.viewport())\n        for pos, pen in zip(self._positions, self._pens):\n            if pos < 0:\n                # margin not visible\n                continue\n            offset = self.editor.contentOffset().x() + \\\n                self.editor.document().documentMargin()\n            x_pos = round(metrics.width(' ') * pos) + offset\n            painter.setPen(pen)\n            painter.drawLine(x_pos, 0, x_pos, 2 ** 16)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef allele_support_df(loci, sources):\n    return pandas.DataFrame(\n        allele_support_rows(loci, sources),\n        columns=EXPECTED_COLUMNS)", "response": "Returns a DataFrame of all the allele counts for all given loci in the read sources"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef variant_support(variants, allele_support_df, ignore_missing=False):\n    '''\n    Collect the read evidence support for the given variants.\n\n    Parameters\n    ----------\n\n    variants : iterable of varcode.Variant\n\n    allele_support_df : dataframe\n        Allele support dataframe, as output by the varlens-allele-support tool.\n        It should have columns: source, contig, interbase_start, interbase_end,\n        allele. The remaining columns are interpreted as read counts of various\n        subsets of reads (e.g. all reads, non-duplicate reads, etc.)\n\n    ignore_missing : boolean\n        If True, then varaints with no allele counts will be interpreted as\n        having 0 depth. If False, then an exception will be raised if any\n        variants have no allele counts.\n\n    Returns\n    ----------\n\n    A pandas.Panel4D frame with these axes:\n\n    labels (axis=0) : the type of read being counted, i.e. the read count\n        fields in allele_support_df.\n\n    items (axis=1)  : the type of measurement (num_alt, num_ref, num_other,\n        total_depth, alt_fraction, any_alt_fraction)\n\n    major axis (axis=2) : the variants\n\n    minor axis (axis=3) : the sources\n    '''\n    missing = [\n        c for c in EXPECTED_COLUMNS if c not in allele_support_df.columns\n    ]\n    if missing:\n        raise ValueError(\"Missing columns: %s\" % \" \".join(missing))\n\n    # Ensure our start and end fields are ints.\n    allele_support_df[[\"interbase_start\", \"interbase_end\"]] = (\n        allele_support_df[[\"interbase_start\", \"interbase_end\"]].astype(int))\n\n    sources = sorted(allele_support_df[\"source\"].unique())\n\n    allele_support_dict = collections.defaultdict(dict)\n    for (i, row) in allele_support_df.iterrows():\n        key = (\n            row['source'],\n            row.contig,\n            row.interbase_start,\n            row.interbase_end)\n        allele_support_dict[key][row.allele] = row[\"count\"]\n\n    # We want an exception on bad lookups, so convert to a regular dict.\n    allele_support_dict = dict(allele_support_dict)\n\n    dataframe_dicts = collections.defaultdict(\n        lambda: collections.defaultdict(list))\n\n    for variant in variants:\n        for source in sources:\n            key = (source, variant.contig, variant.start - 1, variant.end)\n            try:\n                alleles = allele_support_dict[key]\n            except KeyError:\n                message = (\n                    \"No allele counts in source %s for variant %s\" % (\n                        source, str(variant)))\n                if ignore_missing:\n                    logging.warning(message)\n                    alleles = {}\n                else:\n                    raise ValueError(message)\n\n            alt = alleles.get(variant.alt, 0)\n            ref = alleles.get(variant.ref, 0)\n            total = sum(alleles.values())\n\n            other = total - alt - ref\n\n            dataframe_dicts[\"num_alt\"][source].append(alt)\n            dataframe_dicts[\"num_ref\"][source].append(ref)\n            dataframe_dicts[\"num_other\"][source].append(other)\n            dataframe_dicts[\"total_depth\"][source].append(total)\n            dataframe_dicts[\"alt_fraction\"][source].append(\n                float(alt) / max(1, total))\n            dataframe_dicts[\"any_alt_fraction\"][source].append(\n                float(alt + other) / max(1, total))\n\n    dataframes = dict(\n        (label, pandas.DataFrame(value, index=variants))\n        for (label, value) in dataframe_dicts.items())\n\n    return pandas.Panel(dataframes)", "response": "Returns a DataFrame containing the read evidence support for the given variants."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_timer(self, args, arguments):\n        # print arguments\n        # print \"args\", args\n        args = args.lower()\n\n        if args in (\"on\", \"off\"):\n            self.with_timers = (args == \"on\")\n            Console.ok (\"Timers are now: {0}\".format(args))\n        if args == 'list':\n            self.list_timers()\n        else:\n            self.do_timer.__doc__", "response": "Command for timer command"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a soundfile as a numpy array.", "response": "def sndread(path:str) -> Tuple[np.ndarray, int]:\n    \"\"\"\n    Read a soundfile as a numpy array. This is a float array defined \n    between -1 and 1, independently of the format of the soundfile\n    \n    Returns (data:ndarray, sr:int)\n    \"\"\"\n    backend = _getBackend(path)\n    logger.debug(f\"sndread: using backend {backend.name}\")\n    return backend.read(path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a file in chunks.", "response": "def sndread_chunked(path:str, frames:int=_CHUNKSIZE) -> Iterator[np.ndarray]:\n    \"\"\"\n    Returns a generator yielding numpy arrays (float64)\n    of at most `frames` frames\n    \"\"\"\n    backend = _getBackend(path, key=lambda backend: backend.can_read_chunked)\n    if backend:\n        logger.debug(f\"sndread_chunked: using backend {backend.name}\")\n        return backend.read_chunked(path, frames)\n    else:\n        raise SndfileError(\"chunked reading is not supported by the available backends\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget info about a soundfile", "response": "def sndinfo(path:str) -> SndInfo:\n    \"\"\"\n    Get info about a soundfile\n\n    path (str): the path to a soundfile\n\n    RETURNS --> an instance of SndInfo: samplerate, nframes, channels, encoding, fileformat\n    \"\"\"\n    backend = _getBackend(path)\n    logger.debug(f\"sndinfo: using backend {backend.name}\")\n    return backend.getinfo(path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting samples to a file using the specified samplerate.", "response": "def sndwrite(samples:np.ndarray, sr:int, outfile:str, encoding:str='auto') -> None:\n    \"\"\"\n    samples  --> Array-like. the actual samples, shape=(nframes, channels)\n    sr       --> Sampling-rate\n    outfile  --> The name of the outfile. the extension will determine\n                 the file-format.\n                 The formats supported depend on the available backends\n                 Without additional backends, only uncompressed formats\n                 are supported (wav, aif)\n    encoding --> one of:\n                 - 'auto' or None: the encoding is determined from the format\n                                   given by the extension of outfile, and\n                                   from the data\n                 - 'pcm16'\n                 - 'pcm24'\n                 - 'pcm32'\n                 - 'flt32'\n\n                 NB: not all file formats support all encodings.\n                     Throws a SndfileError if the format does not support\n                     the given encoding\n\n          If set to 'auto', an encoding will be selected based on the\n          file-format and on the data. The bitdepth of the data is\n          measured, and if the file-format supports it, it will be used.\n          For bitdepths of 8, 16 and 24 bits, a PCM encoding will be used.\n          For a bitdepth of 32 bits, a FLOAT encoding will be used,\n          or the next lower supported encoding\n    \"\"\"\n    if encoding in ('auto', None):\n        encoding = _guessEncoding(samples, outfile)\n    # normalize in the case where there would be clipping\n    clipping = ((samples > 1).any() or (samples < -1).any())\n    if encoding.startswith('pcm') and clipping:\n        maxvalue = max(samples.max(), abs(samples.min()))\n        samples = samples / maxvalue\n    backend = _getWriteBackend(outfile, encoding)\n    if not backend:\n        raise SndfileError(\"No backend found to support the given format\")\n    logger.debug(f\"sndwrite: using backend {backend.name}\")\n    return backend.write(samples, sr, outfile, encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a SndWriter that writes samples to a file in chunks.", "response": "def sndwrite_chunked(sr: int, outfile: str, encoding: str) -> _SndWriter:\n    \"\"\"\n    Returns a SndWriter. Call its .write(samples) method \n    to write\n\n    samples  --> Array-like. the actual samples, shape=(nframes, channels)\n    sr       --> Sampling-rate\n    outfile  --> The name of the outfile. the extension will determine\n                 the file-format.\n                 The formats supported depend on the available backends\n                 Without additional backends, only uncompressed formats\n                 are supported (wav, aif)\n    encoding --> one of:\n                 - 'pcm16'\n                 - 'pcm24'\n                 - 'pcm32'\n                 - 'flt32'\n    \"\"\"\n    backends = [backend for backend in _getBackends() if backend.can_write_chunked]\n    if not backends:\n        raise SndfileError(\"No backend found to support the given format\")\n    print(backends)\n    backend = min(backends, key=lambda backend:backend.priority)\n    logger.debug(f\"sndwrite_chunked: using backend {backend.name}\")\n    return backend.writer(sr, outfile, encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef asmono(samples:np.ndarray, channel:Union[int, str]=0) -> np.ndarray:\n    if numchannels(samples) == 1:\n        # it could be [1,2,3,4,...], or [[1], [2], [3], [4], ...]\n        if isinstance(samples[0], float):\n            return samples\n        elif isinstance(samples[0], np.dnarray):\n            return np.reshape(samples, (len(samples),))\n        else:\n            raise TypeError(\"Samples should be numeric, found: %s\"\n                            % str(type(samples[0])))\n    if isinstance(channel, int):\n        return samples[:, channel]\n    elif channel == 'mix':\n        return _mix(samples, scale_by_numchannels=True)\n    else:\n        raise ValueError(\"channel has to be an integer indicating a channel,\"\n                         \" or 'mix' to mix down all channels\")", "response": "Convert samples to mono if they are not mono already."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a view into a channel of samples.", "response": "def getchannel(samples: np.ndarray, ch:int) -> np.ndarray:\n    \"\"\"\n    Returns a view into a channel of samples.\n\n    samples    : a numpy array representing the audio data\n    ch         : the channel to extract (channels begin with 0)\n    \"\"\"\n    N = numchannels(samples)\n    if ch > (N - 1):\n        raise ValueError(\"channel %d out of range\" % ch)\n    if N == 1:\n        return samples\n    return samples[:, ch]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bitdepth(data:np.ndarray, snap:bool=True) -> int:\n    data = asmono(data)\n    maxitems = min(4096, data.shape[0])\n    maxbits = max(x.as_integer_ratio()[1]\n                  for x in data[:maxitems]).bit_length()\n    if snap:\n        if maxbits <= 8:\n            maxbits = 8\n        elif maxbits <= 16:\n            maxbits = 16\n        elif maxbits <= 24:\n            maxbits = 24\n        elif maxbits <= 32:\n            maxbits = 32\n        else:\n            maxbits = 64\n    return maxbits", "response": "Returns the number of bits actually used to represent the data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sndwrite_like(samples:np.ndarray, likefile:str, outfile:str) -> None:\n    info = sndinfo(likefile)\n    sndwrite(samples, info.samplerate, outfile, encoding=info.encoding)", "response": "Write samples to outfile with samplerate and encoding taken from likefile"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the data from a wav file.", "response": "def _wavReadData(fid, \n                 size:int, \n                 channels:int, \n                 encoding:str, \n                 bigendian:bool) -> np.ndarray:\n    \"\"\"\n    adapted from scipy.io.wavfile._read_data_chunk\n\n    assume we are at the data (after having read the size)\n    \"\"\"\n    bits = int(encoding[3:])\n    if bits == 8:\n        data = np.fromfile(fid, dtype=np.ubyte, count=size)\n        if channels > 1:\n            data = data.reshape(-1, channels)\n    else:\n        bytes = bits // 8\n        if encoding in ('pcm16', 'pcm32', 'pcm64'):\n            if bigendian:\n                dtype = '>i%d' % bytes\n            else:\n                dtype = '<i%d' % bytes\n            data = np.fromfile(fid, dtype=dtype, count=size // bytes)\n            if channels > 1:\n                data = data.reshape(-1, channels)\n        elif encoding[:3] == 'flt':\n            print(\"flt32!\")\n            if bits == 32:\n                if bigendian:\n                    dtype = '>f4'\n                else:\n                    dtype = '<f4'\n            else:\n                raise NotImplementedError\n            data = np.fromfile(fid, dtype=dtype, count=size // bytes)\n            if channels > 1:\n                data = data.reshape(-1, channels)\n        elif encoding == 'pcm24':\n            # this conversion approach is really bad for long files\n            # TODO: do the same but in chunks\n            data = _numpy24to32bit(np.fromfile(fid, dtype=np.ubyte, count=size), \n                                   bigendian=False)\n            if channels > 1:\n                data = data.reshape(-1, channels)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _wavGetInfo(f:Union[IO, str]) -> Tuple[SndInfo, Dict[str, Any]]:\n    if isinstance(f, (str, bytes)):\n        f = open(f, 'rb')\n        needsclosing = True\n    else:\n        needsclosing = False\n    fsize, bigendian = _wavReadRiff(f)\n    fmt = \">i\" if bigendian else \"<i\"\n    while (f.tell() < fsize):\n        chunk_id = f.read(4)\n        if chunk_id == b'fmt ':\n            chunksize, sampfmt, chans, sr, byterate, align, bits = _wavReadFmt(f, bigendian)\n        elif chunk_id == b'data':\n            datasize = _struct.unpack(fmt, f.read(4))[0]\n            nframes = int(datasize / (chans * (bits / 8)))\n            break\n        else:\n            _warnings.warn(\"chunk not understood: %s\" % chunk_id)\n            data = f.read(4)\n            size = _struct.unpack(fmt, data)[0]\n            f.seek(size, 1)\n    encoding = _encoding(sampfmt, bits)\n    if needsclosing:\n        f.close()\n    info = SndInfo(sr, nframes, chans, encoding, \"wav\")\n    return info, {'fsize': fsize, 'bigendian': bigendian, 'datasize': datasize}", "response": "Read the info of a wav file. taken mostly from scipy. io. wavfile\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _numpy24to32bit(data:np.ndarray, bigendian:bool=False) -> np.ndarray:\n    target = np.zeros((data.shape[0] * 4 / 3,), dtype=np.ubyte)\n    if not bigendian:\n        target[3::4] = data[2::3]\n        target[2::4] = data[1::3]\n        target[1::4] = data[0::3]\n    else:\n        target[1::4] = data[2::3]\n        target[2::4] = data[1::3]\n        target[3::4] = data[0::3]\n    del data\n    targetraw = target.tostring()\n    del target\n    data = np.fromstring(targetraw, dtype=np.int32)\n    return data", "response": "Convert numpy array to 32 - bit integer array."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getBackend(path=None, key=None):\n    ext = _os.path.splitext(path)[1].lower() if path else None\n    backends = _getBackends()\n    if key:\n        backends = [b for b in backends if key(b)]\n    if ext:\n        backends = [b for b in backends if ext in b.filetypes]\n    if backends:\n        return min(backends, key=lambda backend: backend.priority)\n    return None", "response": "Get a backend for a specific task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating connection to server", "response": "def connect(self):\n        \"Create connection to server\"\n        family, stype, proto, cname, sockaddr = self.best_connection_params(\n            self.host, self.port)\n        self.sock = socket.socket(family, stype)\n        self.sock.settimeout(self.timeout)\n        self.sock.connect(sockaddr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends rcon command to server", "response": "def send(self, command):\n        \"Send rcon command to server\"\n        if self.secure_rcon == self.RCON_NOSECURE:\n            self.sock.send(rcon_nosecure_packet(self.password, command))\n        elif self.secure_rcon == self.RCON_SECURE_TIME:\n            self.sock.send(rcon_secure_time_packet(self.password, command))\n        elif self.secure_rcon == self.RCON_SECURE_CHALLENGE:\n            challenge = self.getchallenge()\n            self.sock.send(rcon_secure_challenge_packet(self.password,\n                                                        challenge, command))\n        else:\n            raise ValueError(\"Bad value of secure_rcon\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting a command on the server and return the response.", "response": "def execute(self, command, timeout=1):\n        \"\"\"Execute rcon command on server and fetch result\n        Args:\n            command --- executed command\n            timeout --- read timeout\n\n        Returns: bytes response\n        \"\"\"\n        self.send(command)\n        return self.read_untill(timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(html_string, wrapper=Parser, *args, **kwargs):\n    return Parser(lxml.html.fromstring(html_string), *args, **kwargs)", "response": "Parse html with wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a string to an integer.", "response": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_unicode(obj, encoding='utf-8'):\n    if isinstance(obj, string_types) or isinstance(obj, binary_type):\n        if not isinstance(obj, text_type):\n            obj = text_type(obj, encoding)\n    return obj", "response": "Convert string to unicode string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstrips accents from a string", "response": "def strip_accents(s, pass_symbols=(u'\u0439', u'\u0419', u'\\n')):\n    \"\"\" Strip accents from a string \"\"\"\n    result = []\n    for char in s:\n        # Pass these symbols without processing\n        if char in pass_symbols:\n            result.append(char)\n            continue\n        for c in unicodedata.normalize('NFD', char):\n            if unicodedata.category(c) == 'Mn':\n                continue\n            result.append(c)\n    return ''.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstrips ugly unicode symbols from a string", "response": "def strip_symbols(s, pass_symbols=(u'\u0439', u'\u0419', u'\\n')):\n    \"\"\" Strip ugly unicode symbols from a string \"\"\"\n    result = []\n    for char in s:\n        # Pass these symbols without processing\n        if char in pass_symbols:\n            result.append(char)\n            continue\n        for c in unicodedata.normalize('NFKC', char):\n            if unicodedata.category(c) == 'Zs':\n                result.append(u' ')\n                continue\n            if unicodedata.category(c) not in ['So', 'Mn', 'Lo', 'Cn', 'Co', 'Cf', 'Cc']:\n                result.append(c)\n    return u\"\".join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstrip excess spaces from a string", "response": "def strip_spaces(s):\n    \"\"\" Strip excess spaces from a string \"\"\"\n    return u\" \".join([c for c in s.split(u' ') if c])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strip_linebreaks(s):\n    return u\"\\n\".join([c for c in s.split(u'\\n') if c])", "response": "Strip excess line breaks from a string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, selector, index=0, default=None):\n        elements = self(selector)\n        if elements:\n            try:\n                return elements[index]\n            except (IndexError):\n                pass\n        return default", "response": "Get first element from CSSSelector"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef html(self, unicode=False):\n        html = lxml.html.tostring(self.element, encoding=self.encoding)\n        if unicode:\n            html = html.decode(self.encoding)\n        return html", "response": "Return HTML of element"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self, func, *args, **kwargs):\n        result = []\n        for element in self.xpath('child::node()'):\n            if isinstance(element, Parser):\n                children = element.parse(func, *args, **kwargs)\n                element_result = func(element, children, *args, **kwargs)\n                if element_result:\n                    result.append(element_result)\n            else:\n                result.append(element)\n        return u\"\".join(result)", "response": "Parse element with given function"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps result in Parser instance", "response": "def _wrap_result(self, func):\n        \"\"\" Wrap result in Parser instance \"\"\"\n        def wrapper(*args):\n            result = func(*args)\n            if hasattr(result, '__iter__') and not isinstance(result, etree._Element):\n                return [self._wrap_element(element) for element in result]\n            else:\n                return self._wrap_element(result)\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap single element in Parser instance", "response": "def _wrap_element(self, result):\n        \"\"\" Wrap single element in Parser instance \"\"\"\n        if isinstance(result, lxml.html.HtmlElement):\n            return Parser(result)\n        else:\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing inline elements of this element.", "response": "def parse_inline(self):\n        \"\"\"Inline parsing is postponed so that all link references\n        are seen before that.\n        \"\"\"\n        if self.inline_children:\n            self.children = parser.parse_inline(self.children)\n        elif isinstance(getattr(self, 'children', None), list):\n            for child in self.children:\n                if isinstance(child, BlockElement):\n                    child.parse_inline()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef work_model_factory(*, validator=validators.is_work_model, **kwargs):\n    kwargs['ld_type'] = 'AbstractWork'\n    return _model_factory(validator=validator, **kwargs)", "response": "Generates a Work model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a manifestation model.", "response": "def manifestation_model_factory(*, validator=validators.is_manifestation_model,\n                                ld_type='CreativeWork', **kwargs):\n    \"\"\"Generate a Manifestation model.\n\n    Expects ``data``, ``validator``, ``model_cls``, ``ld_type``, and\n    ``ld_context`` as keyword arguments.\n    \"\"\"\n    return _model_factory(validator=validator, ld_type=ld_type, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a Right model.", "response": "def right_model_factory(*, validator=validators.is_right_model,\n                        ld_type='Right', **kwargs):\n    \"\"\"Generate a Right model.\n\n    Expects ``data``, ``validator``, ``model_cls``, ``ld_type``, and\n    ``ld_context`` as keyword arguments.\n    \"\"\"\n    return _model_factory(validator=validator, ld_type=ld_type, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a Copyright model.", "response": "def copyright_model_factory(*, validator=validators.is_copyright_model,\n                            **kwargs):\n    \"\"\"Generate a Copyright model.\n\n    Expects ``data``, ``validator``, ``model_cls``, and ``ld_context``\n    as keyword arguments.\n\n    Raises:\n        :exc:`ModelError`: If a non-'Copyright' ``ld_type`` keyword\n            argument is given.\n    \"\"\"\n    kwargs['ld_type'] = 'Copyright'\n    return _model_factory(validator=validator, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RetryableExecutionPolicy(attempts=3, activate_hook=None):\n    assert attempts > 0\n\n    def retry_policy(environ, router):\n        # make the original request\n        request_ctx = router.request_context(environ)\n        request = request_ctx.begin()\n\n        if activate_hook:\n            retry_attempts = activate_hook(request)\n            if retry_attempts is None:\n                retry_attempts = attempts\n            else:\n                assert retry_attempts > 0\n        else:\n            retry_attempts = attempts\n\n        # if we are supporting multiple attempts then we must make\n        # make the body seekable in order to re-use it across multiple\n        # attempts. make_body_seekable will copy wsgi.input if\n        # necessary, otherwise it will rewind the copy to position zero\n        if retry_attempts != 1:\n            request.make_body_seekable()\n\n        for number in range(retry_attempts):\n            # track the attempt info in the environ\n            # try to set it as soon as possible so that it's available\n            # in the request factory and elsewhere if people want it\n            # note: set all of these values here as they are cleared after\n            # each attempt\n            environ['retry.attempt'] = number\n            environ['retry.attempts'] = retry_attempts\n\n            # if we are not on the first attempt then we should start\n            # with a new request object and throw away any changes to\n            # the old object, however we do this carefully to try and\n            # avoid extra copies of the body\n            if number > 0:\n                # try to make sure this code stays in sync with pyramid's\n                # router which normally creates requests\n                request_ctx = router.request_context(environ)\n                request = request_ctx.begin()\n\n            try:\n                response = router.invoke_request(request)\n\n                # check for a squashed exception and handle it\n                # this would happen if an exception view was invoked and\n                # rendered an error response\n                exc = getattr(request, 'exception', None)\n                if exc is not None:\n                    # if this is a retryable exception then continue to the\n                    # next attempt, discarding the current response\n                    if is_error_retryable(request, exc):\n                        request.registry.notify(BeforeRetry(request))\n                        continue\n\n                return response\n\n            except Exception as exc:\n                # if this was the last attempt or the exception is not\n                # retryable then make a last ditch effort to render an\n                # error response before sending the exception up the stack\n                if not is_error_retryable(request, exc):\n                    return request.invoke_exception_view(reraise=True)\n\n                else:\n                    request.registry.notify(BeforeRetry(request))\n\n            # cleanup any changes we made to the request\n            finally:\n                request_ctx.end()\n\n                del environ['retry.attempt']\n                del environ['retry.attempts']\n\n    return retry_policy", "response": "Returns a new execution policy that catches any failed or failed request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mark_error_retryable(error):\n    if isinstance(error, Exception):\n        alsoProvides(error, IRetryableError)\n    elif inspect.isclass(error) and issubclass(error, Exception):\n        classImplements(error, IRetryableError)\n    else:\n        raise ValueError(\n            'only exception objects or types may be marked retryable')", "response": "Mark an exception instance or type as retryable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the exception is recognized as retryable error.", "response": "def is_error_retryable(request, exc):\n    \"\"\"\n    Return ``True`` if the exception is recognized as :term:`retryable error`.\n\n    This will return ``False`` if the request is on its last attempt.\n    This will return ``False`` if ``pyramid_retry`` is inactive for the\n    request.\n\n    \"\"\"\n    if is_last_attempt(request):\n        return False\n\n    return (\n        isinstance(exc, RetryableException)\n        or IRetryableError.providedBy(exc)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_last_attempt(request):\n    environ = request.environ\n    attempt = environ.get('retry.attempt')\n    attempts = environ.get('retry.attempts')\n    if attempt is None or attempts is None:\n        return True\n\n    return attempt + 1 == attempts", "response": "Returns True if the request is on its last attempt."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef includeme(config):\n    settings = config.get_settings()\n\n    config.add_view_predicate('last_retry_attempt', LastAttemptPredicate)\n    config.add_view_predicate('retryable_error', RetryableErrorPredicate)\n\n    def register():\n        attempts = int(settings.get('retry.attempts') or 3)\n        settings['retry.attempts'] = attempts\n\n        activate_hook = settings.get('retry.activate_hook')\n        activate_hook = config.maybe_dotted(activate_hook)\n\n        policy = RetryableExecutionPolicy(\n            attempts,\n            activate_hook=activate_hook,\n        )\n        config.set_execution_policy(policy)\n\n    # defer registration to allow time to modify settings\n    config.action(None, register, order=PHASE1_CONFIG)", "response": "Include pyramid_retry in Pyramid application."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lowpass_cheby2_coeffs(freq, sr, maxorder=12):\n    # type: (float, int, int) -> Tuple[np.ndarray, np.ndarray, float]\n    \"\"\"\n    freq    : The frequency above which signals are attenuated\n              with 95 dB\n    sr      : Sampling rate in Hz.\n    maxorder: Maximal order of the designed cheby2 filter\n\n    Returns --> (b coeffs, a coeffs, freq_passband)\n    \"\"\"\n    \n    nyquist = sr * 0.5\n    # rp - maximum ripple of passband, rs - attenuation of stopband\n    rp, rs, order = 1, 96, 1e99\n    ws = freq / nyquist  # stop band frequency\n    wp = ws              # pass band frequency\n    # raise for some bad scenarios\n    if ws > 1:\n        ws = 1.0\n        msg = \"Selected corner frequency is above Nyquist. \" + \\\n              \"Setting Nyquist as high corner.\"\n        warnings.warn(msg)\n    while True:\n        if order <= maxorder:\n            break\n        wp = wp * 0.99\n        order, wn = signal.cheb2ord(wp, ws, rp, rs, analog=0)\n    b, a = signal.cheby2(order, rs, wn, btype='low', analog=0, output='ba')\n    return b, a, wp*nyquist", "response": "low - passcheby2 filter for a given frequency sr"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_butter_coeffs(filtertype, freq, samplerate, order=5):\n    # type: (str, Union[float, Tuple[float, float]], int, int) -> Tuple[np.ndarray, np.ndarray]\n    \"\"\"\n    calculates the coefficients for a digital butterworth filter\n\n    filtertype: 'low', 'high', 'band'\n    freq      : cutoff freq.\n                in the case of 'band': (low, high)\n\n    Returns --> (b, a)\n    \"\"\"\n    assert filtertype in ('low', 'high', 'band')\n    nyq = 0.5 * samplerate\n    if isinstance(freq, tuple):\n        assert filtertype == 'band'\n        low, high = freq\n        low  /= nyq\n        high /= nyq\n        b, a = signal.butter(order, [low, high], btype='band')\n    else:\n        freq = freq / nyq\n        b, a = signal.butter(order, freq, btype=filtertype)\n    return b, a", "response": "This function calculates the coefficients for a digital butterworth filter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_butter(samples, samplerate, filtertype, freq, order=5):\n    # type: (np.ndarray, int, str, float, int) -> np.ndarray\n    \"\"\"\n    Filters the samples with a digital butterworth filter\n\n    samples   : mono samples\n    filtertype: 'low', 'band', 'high'\n    freq      : for low or high, the cutoff freq\n                for band, (low, high)\n    samplerate: the sampling-rate\n    order     : the order of the butterworth filter\n\n    Returns --> the filtered samples\n\n    NB: calls filter_butter_coeffs to calculate the coefficients\n    \"\"\"\n    assert filtertype in ('low', 'high', 'band')\n    b, a = filter_butter_coeffs(filtertype, freq, samplerate, order=order)\n    return apply_multichannel(samples, lambda data:signal.lfilter(b, a, data))", "response": "Filter the samples with a digital butterworth filter"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots the freq. response of the digital butterw. filter", "response": "def filter_butter_plot_freqresponse(b, a, samplerate, numpoints=2000):\n    # type: (Seq[float], Seq[float], int, int) -> None\n    \"\"\"\n    Plot the freq. response of the digital butterw. filter \n    defined by the coeffs. (b, a) at `samplerate`\n\n    Returns --> nothing\n\n    See also: filter_butter_coeffs\n    \"\"\"\n    import matplotlib.pyplot as plt\n    plt.figure(1)\n    plt.clf()\n    w, h = signal.freqz(b, a, worN=numpoints)\n    plt.semilogx((samplerate*0.5/np.pi) * w, np.abs(h))\n    plt.xlabel('Freq (Hz)')\n    plt.ylabel('Gain')\n    plt.grid(True)\n    plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_blocking(obj):\n    if isinstance(obj, tuple):\n        try:\n            a, b = obj\n        except:\n            raise TypeError(\"Not a Blocking object\")\n    else:\n        a, b = obj, None\n    return extract_attr(a, keys=[\"Index\"]), b", "response": "Extract index and watch from a blocking object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef consistency_middleware(ctx, get_response):\n    async def middleware(request):\n        params = request.setdefault(\"params\", {})\n        consistency = request.pop(\"consistency\", None)\n        a, b = set_consistency(consistency, ctx.consistency, params)\n        params[\"consistent\"] = a\n        params[\"stale\"] = b\n        return await get_response(request)\n    return middleware", "response": "A middleware that sets the consistency of the current context."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef token_middleware(ctx, get_response):\n    async def middleware(request):\n        params = request.setdefault('params', {})\n        if params.get(\"token\") is None:\n            params['token'] = ctx.token\n        return await get_response(request)\n    return middleware", "response": "Reinject token and consistency into requests.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addEntry(self, key='', value=''):\r\n        img = resources.find('img/close.png')\r\n        new_item = XTreeWidgetItem()\r\n        new_item.setText(1, nativestring(key))\r\n        new_item.setText(2, nativestring(value))\r\n        new_item.setIcon(0, QtGui.QIcon(img))\r\n        new_item.setFixedHeight(22)\r\n        self.insertTopLevelItem(self.topLevelItemCount() - 1, new_item)\r\n        \r\n        return new_item", "response": "Adds a new entry item for this widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of the key value pairing for the items in this widget.", "response": "def dictionary(self):\r\n        \"\"\"\r\n        Returns a dictionary of the key/value pairing for the items in\r\n        this widget.\r\n        \r\n        :return     {<str> key: <str> value, ..}\r\n        \"\"\"\r\n        output = {}\r\n        for i in range(self.topLevelItemCount() - 1):\r\n            item = self.topLevelItem(i)\r\n            output[nativestring(item.text(1))] = nativestring(item.text(2))\r\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handleClick(self, item, column):\r\n        if item.text(0) == 'add another item':\r\n            new_item = self.addEntry()\r\n            self.setCurrentItem(new_item, 1)\r\n            self.editItem(new_item, 1)\r\n        \r\n        elif column == 0:\r\n            self.takeTopLevelItem(self.indexOfTopLevelItem(item))", "response": "Handles the click event on an item."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the dictionary of the key value pairing for the items in this widget.", "response": "def setDictionary(self, props):\r\n        \"\"\"\r\n        Sets a dictionary of the key/value pairing for the items in\r\n        this widget.\r\n        \r\n        :param      props | {<str> key: <str> value, ..}\r\n        \"\"\"\r\n        if not self._initialized:\r\n            self.setColumns(['', 'Property', 'Value'])\r\n            self.setColumnWidth(0, 22)\r\n            \r\n        self._initialized = True\r\n        \r\n        self.clear()\r\n        \r\n        palette = self.palette()\r\n        item = XTreeWidgetItem(self, ['add another item'])\r\n        item.setForeground(0, palette.color(palette.Disabled, palette.Text))\r\n        item.setTextAlignment(0, QtCore.Qt.AlignCenter)\r\n        item.setFlags(QtCore.Qt.ItemFlags(0))\r\n        item.setFixedHeight(22)\r\n        item.setFirstColumnSpanned(True)\r\n        \r\n        for key, text in props.items():\r\n            self.addEntry(key, text)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paint( self, painter, option, widget ):\n        super(XGanttDepItem, self).paint(painter, option, widget)\r\n        \n        # redraw the poly to force-fill it\n        if ( self._polygon ):\r\n            painter.setRenderHint(painter.Antialiasing)\n            painter.setBrush(self.pen().color())\n            painter.drawPolygon(self._polygon)", "response": "Override paint method to handle custom drawing of the path using the items defined in the constructor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrebuild the dependency path for this item.", "response": "def rebuild( self ):\r\n        \"\"\"\r\n        Rebuilds the dependency path for this item.\r\n        \"\"\"\r\n        scene      = self.scene()\r\n        if ( not scene ):\r\n            return\r\n        \r\n        sourcePos  = self.sourceItem().viewItem().pos()\r\n        sourceRect = self.sourceItem().viewItem().rect()\r\n        \r\n        targetPos  = self.targetItem().viewItem().pos()\r\n        targetRect = self.targetItem().viewItem().rect()\r\n        \r\n        cellWidth  = scene.ganttWidget().cellWidth()\r\n        \r\n        startX = sourcePos.x() + sourceRect.width() - (cellWidth / 2.0)\r\n        startY = sourcePos.y() + (sourceRect.height() / 2.0)\r\n        \r\n        endX   = targetPos.x() - 2\r\n        endY   = targetPos.y() + (targetRect.height() / 2.0)\r\n        \r\n        path = QPainterPath()\r\n        path.moveTo(startX, startY)\r\n        path.lineTo(startX, endY)\r\n        path.lineTo(endX, endY)\r\n        \r\n        a = QPointF(endX - 10, endY - 3)\n        b = QPointF(endX, endY)\n        c = QPointF(endX - 10, endY + 3)\r\n        \r\n        self._polygon = QPolygonF([a, b, c, a])\r\n        \r\n        path.addPolygon(self._polygon)\r\n        \r\n        self.setPath(path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_proof(proof, target_hash, merkle_root, hash_f=sha256):\n\n    if not proof:\n        # no siblings, single item tree, so the hash should also be the root\n        return target_hash == merkle_root\n\n    target_hash = get_buffer(target_hash)\n    merkle_root = get_buffer(merkle_root)\n\n    proof_hash = target_hash\n    for x in proof:\n        if 'left' in x:\n            # then the sibling is a left node\n            proof_hash = get_buffer(hash_f(get_buffer(x['left']) + proof_hash))\n        elif 'right' in x:\n            # then the sibling is a right node\n            proof_hash = get_buffer(hash_f(proof_hash + get_buffer(x['right'])))\n        else:\n            # no left or right designation exists, proof is invalid\n            return False\n\n    return hexlify(proof_hash) == hexlify(merkle_root)", "response": "Validate a single item tree proof."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the block to a file with the id", "response": "def _writeBlock(block, blockID):\n    '''writes the block to a file with the id'''\n    with open(\"blockIDs.txt\", \"a\") as fp:\n        fp.write(\"blockID: \" + str(blockID) + \"\\n\")\n        sentences = \"\"\n        for sentence in block:\n            sentences += sentence+\",\"\n        fp.write(\"block sentences: \"+sentences[:-1]+\"\\n\")\n        fp.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _writeSentenceInBlock(sentence, blockID, sentenceID):\n    '''writes the sentence in a block to a file with the id'''\n    with open(\"sentenceIDs.txt\", \"a\") as fp:\n        fp.write(\"sentenceID: \"+str(blockID)+\"_\"+str(sentenceID)+\"\\n\")\n        fp.write(\"sentence string: \"+sentence+\"\\n\")\n        fp.write(\"\\n\")", "response": "writes the sentence in a block to a file with the id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the word from a sentence in a block to a file with the id", "response": "def _writeWordFromSentenceInBlock(word, blockID, sentenceID, wordID):\n    '''writes the word from a sentence in a block to a file with the id'''\n    with open(\"wordIDs.txt\", \"a\") as fp:\n        fp.write(\"wordID: \" + str(blockID) + \"_\" +\n                 str(sentenceID) + \"_\" + str(wordID) + \"\\n\")\n        fp.write(\"wordString: \" + word + \"\\n\")\n        fp.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a background file to disk.", "response": "def _writeBk(target=\"sentenceContainsTarget(+SID,+WID).\", treeDepth=\"3\",\n             nodeSize=\"3\", numOfClauses=\"8\"):\n    \"\"\"\n    Writes a background file to disk.\n\n    :param target: Target predicate with modes.\n    :type target: str.\n    :param treeDepth: Depth of the tree.\n    :type treeDepth: str.\n    :param nodeSize: Maximum size of each node in the tree.\n    :type nodeSize: str.\n    :param numOfClauses: Number of clauses in total.\n    :type numOfClauses: str.\n    \"\"\"\n\n    with open('bk.txt', 'w') as bk:\n\n        bk.write(\"useStdLogicVariables: true\\n\")\n\n        bk.write(\"setParam: treeDepth=\" + str(treeDepth) + '.\\n')\n        bk.write(\"setParam: nodeSize=\" + str(nodeSize) + '.\\n')\n        bk.write(\"setParam: numOfClauses=\" + str(numOfClauses) + '.\\n')\n\n        bk.write(\"mode: nextSentenceInBlock(+BID,+SID,-SID).\\n\")\n        bk.write(\"mode: nextSentenceInBlock(+BID,-SID,+SID).\\n\")\n        bk.write(\"mode: earlySentenceInBlock(+BID,-SID).\\n\")\n        bk.write(\"mode: midWaySentenceInBlock(+BID,-SID).\\n\")\n        bk.write(\"mode: lateSentenceInBlock(+BID,-SID).\\n\")\n        bk.write(\"mode: sentenceInBlock(-SID,+BID).\\n\")\n        bk.write(\"mode: wordString(+WID,#WSTR).\\n\")\n        bk.write(\"mode: partOfSpeechTag(+WID,#WPOS).\\n\")\n        bk.write(\"mode: nextWordInSentence(+SID,+WID,-WID).\\n\")\n        bk.write(\"mode: earlyWordInSentence(+SID,-WID).\\n\")\n        bk.write(\"mode: midWayWordInSentence(+SID,-WID).\\n\")\n        bk.write(\"mode: lateWordInSentence(+SID,-WID).\\n\")\n        bk.write(\"mode: wordInSentence(-WID,+SID).\\n\")\n\n        bk.write(\"mode: \" + target + \"\\n\")\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking unique identifiers for components of the block and write to files. :param blocks: Blocks of sentences (likely the output of ``textprocessing.getBlocks``). :type blocks: list :param target: Target to write to the background file (another option might be ``blockContainsTarget(+BID,+SID).``). :type target: str. :param treeDepth: Depth of the tree. :type treeDepth: str. :param nodeSize: Maximum size of each node in the tree. :type nodeSize: str. :param numOfClauses: Number of clauses in total. :type numOfClauses: str. .. note:: This is a function that writes *facts*, presently there is no way to distinguish between these and positive/negatives examples. Example: .. code-block:: python from rnlp.textprocessing import getSentences from rnlp.textprocessing import getBlocks from rnlp.parse import makeIdentifiers example = \"Hello there. How are you? I am fine.\" sentences = getSentences(example) # ['Hello there', 'How are you', 'I am fine'] blocks = getBlocks(sentences, 2) # with 1: [['Hello there'], ['How are you'], ['I am fine']] # with 2: [['Hello there', 'How are you'], ['I am fine']] # with 3: [['Hello there', 'How are you', 'I am fine']] makeIdentifiers(blocks) # 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00<00:00, 18.49it/s]", "response": "def makeIdentifiers(blocks, target=\"sentenceContainsTarget(+SID,+WID).\",\n                    treeDepth=\"3\", nodeSize=\"3\", numOfClauses=\"8\"):\n    \"\"\"\n    Make unique identifiers for components of the block and write to files.\n\n    :param blocks: Blocks of sentences (likely the output of\n                   ``textprocessing.getBlocks``).\n    :type blocks: list\n    :param target: Target to write to the background file (another option might\n                   be ``blockContainsTarget(+BID,+SID).``).\n    :type target: str.\n    :param treeDepth: Depth of the tree.\n    :type treeDepth: str.\n    :param nodeSize: Maximum size of each node in the tree.\n    :type nodeSize: str.\n    :param numOfClauses: Number of clauses in total.\n    :type numOfClauses: str.\n\n    .. note:: This is a function that writes *facts*, presently there is no\n      way to distinguish between these and positive/negatives examples.\n\n    Example:\n\n    .. code-block:: python\n\n                    from rnlp.textprocessing import getSentences\n                    from rnlp.textprocessing import getBlocks\n                    from rnlp.parse import makeIdentifiers\n\n                    example = \"Hello there. How are you? I am fine.\"\n\n                    sentences = getSentences(example)\n                    # ['Hello there', 'How are you', 'I am fine']\n\n                    blocks = getBlocks(sentences, 2)\n                    # with 1: [['Hello there'], ['How are you'], ['I am fine']]\n                    # with 2: [['Hello there', 'How are you'], ['I am fine']]\n                    # with 3: [['Hello there', 'How are you', 'I am fine']]\n\n                    makeIdentifiers(blocks)\n                    # 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00<00:00, 18.49it/s]\n    \"\"\"\n\n    blockID, sentenceID, wordID = 1, 0, 0\n\n    print(\"Creating background file...\")\n\n    _writeBk(target=target, treeDepth=treeDepth,\n             nodeSize=nodeSize, numOfClauses=numOfClauses)\n\n    print(\"Creating identifiers from the blocks...\")\n\n    nBlocks = len(blocks)\n    for block in tqdm(blocks):\n\n        _writeBlock(block, blockID)\n\n        sentenceID = 1\n        nSentences = len(block)\n        beginning = nSentences/float(3)\n        ending = (2*nSentences)/float(3)\n\n        for sentence in block:\n\n            if sentenceID < nSentences:\n                # mode: nextSentenceInBlock(blockID, sentenceID, sentenceID).\n                ps = \"nextSentenceInBlock(\" + str(blockID) + \",\" + \\\n                     str(blockID) + \"_\" + str(sentenceID) + \",\" + \\\n                     str(blockID) + \"_\" + str(sentenceID+1) + \").\"\n                _writeFact(ps)\n\n            if sentenceID < beginning:\n                # mode: earlySentenceInBlock(blockID, sentenceID).\n                ps = \"earlySentenceInBlock(\" + str(blockID) + \",\" + \\\n                     str(blockID) + \"_\" + str(sentenceID) + \").\"\n                _writeFact(ps)\n            elif sentenceID > ending:\n                # mode: lateSentenceInBlock(blockID, sentenceID).\n                ps = \"lateSentenceInBlock(\" + str(blockID) + \",\" + \\\n                     str(blockID) + \"_\" + str(sentenceID) + \").\"\n                _writeFact(ps)\n            else:\n                # mode: midWaySentenceInBlock(blockID, sentenceID).\n                ps = \"earlySentenceInBlock(\" + str(blockID) + \",\" + \\\n                     str(blockID) + \"_\" + str(sentenceID) + \").\"\n                _writeFact(ps)\n\n            # mode: sentenceInBlock(sentenceID, blockID).\n            ps = \"sentenceInBlock(\" + str(blockID) + \"_\" + str(sentenceID) + \\\n                 \",\" + str(blockID) + \").\"\n            _writeFact(ps)\n            _writeSentenceInBlock(sentence, blockID, sentenceID)\n\n            wordID = 1\n            tokens = nltk.word_tokenize(sentence)\n            nWords = len(tokens)\n            wBeginning = nWords/float(3)\n            wEnding = (2*nWords)/float(3)\n\n            for word in tokens:\n\n                \"\"\"\n                if word == \"He\":\n                    pos = open(\"pos.txt\",\"a\")\n                    word = str(blockID)+\"_\"+str(sentenceID)+\"_\"+str(wordID)\n                    sentence = str(blockID)+\"_\"+str(sentenceID)\n                    pos.write(\"sentenceContainsTarget(\"+sentence+\",\"+word+\").\\n\")\n                    pos.close()\n                else:\n                    neg = open(\"neg.txt\",\"a\")\n                    word = str(blockID)+\"_\"+str(sentenceID)+\"_\"+str(wordID)\n                    sentence = str(blockID)+\"_\"+str(sentenceID)\n                    neg.write(\"sentenceContainsTarget(\"+sentence+\",\"+word+\").\\n\")\n                    neg.close()\n                \"\"\"\n\n                # mode: wordString(wordID, #str).\n                ps = \"wordString(\" + str(blockID) + \"_\" + str(sentenceID) + \\\n                     \"_\" + str(wordID) + \",\" + \"'\" + str(word) + \"').\"\n                _writeFact(ps)\n\n                # mode: partOfSpeechTag(wordID, #POS).\n                POS = nltk.pos_tag([word])[0][1]\n                ps = \"partOfSpeech(\" + str(blockID) + \"_\" + str(sentenceID) + \\\n                     \"_\" + str(wordID) + \",\" + '\"' + str(POS) + '\").'\n                _writeFact(ps)\n\n                # mode: nextWordInSentence(sentenceID, wordID, wordID).\n                if wordID < nWords:\n                    ps = \"nextWordInSentence(\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \",\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \"_\" + str(wordID) + \",\" + \\\n                         str(blockID) + \"_\" + str(sentenceID) + \"_\" + \\\n                         str(wordID+1) + \").\"\n                    _writeFact(ps)\n\n                if wordID < wBeginning:\n                    # mode: earlyWordInSentence(sentenceID, wordID).\n                    ps = \"earlyWordInSentence(\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \",\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \"_\" + str(wordID) + \").\"\n                    _writeFact(ps)\n                elif wordID > wEnding:\n                    # mode: lateWordInSentence(sentenceID< wordID).\n                    ps = \"lateWordInSentence(\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \",\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \"_\" + str(wordID) + \").\"\n                    _writeFact(ps)\n                else:\n                    # mode: midWayWordInSentence(sentenceID, wordID).\n                    ps = \"midWayWordInSentence(\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \",\" + str(blockID) + \"_\" + \\\n                         str(sentenceID) + \"_\" + str(wordID) + \").\"\n                    _writeFact(ps)\n\n                # mode: wordInSentence(wordID, sentenceID).\n                ps = \"wordInSentence(\" + str(blockID) + \"_\" + \\\n                     str(sentenceID) + \"_\" + str(wordID) + \",\" + \\\n                     str(blockID) + \"_\" + str(sentenceID) + \").\"\n                _writeFact(ps)\n                _writeWordFromSentenceInBlock(word, blockID,\n                                              sentenceID, wordID)\n                wordID += 1\n            sentenceID += 1\n        blockID += 1"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef traverse_depth_first_pre_order(self, callback):\n        n = len(self.suftab)\n        root = [0, 0, n - 1, \"\"]  # <l, i, j, char>\n\n        def _traverse_top_down(interval):  # TODO: Rewrite with stack? As in bottom-up\n            callback(interval)\n            i, j = interval[1], interval[2]\n            if i != j:\n                children = self._get_child_intervals(i, j)\n                children.sort(key=lambda child: child[3])\n                for child in children:\n                    _traverse_top_down(child)\n\n        _traverse_top_down(root)", "response": "Visits the internal nodes of the enhanced suffix array in depth - first pre - order."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef traverse_depth_first_post_order(self, callback):\n        # a. Reimplement without python lists?..\n        # b. Interface will require it to have not internal nodes only?..\n        #    (but actually this implementation gives a ~2x gain of performance)\n        last_interval = None\n        n = len(self.suftab)\n        stack = [[0, 0, None, []]]  # <l, i, j, children>\n        for i in xrange(1, n):\n            lb = i - 1\n            while self.lcptab[i] < stack[-1][0]:\n                stack[-1][2] = i - 1\n                last_interval = stack.pop()\n                callback(last_interval)\n                lb = last_interval[1]\n                if self.lcptab[i] <= stack[-1][0]:\n                    stack[-1][3].append(last_interval)\n                    last_interval = None\n            if self.lcptab[i] > stack[-1][0]:\n                if last_interval:\n                    stack.append([self.lcptab[i], lb, None, [last_interval]])\n                    last_interval = None\n                else:\n                    stack.append([self.lcptab[i], lb, None, []])\n        stack[-1][2] = n - 1\n        callback(stack[-1])", "response": "Visit the internal nodes of the enhanced suffix array in depth - first post - order."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the suffix array of a string in O ( n ).", "response": "def _compute_suftab(self, string):\n        \"\"\"Computes the suffix array of a string in O(n).\n\n        The code is based on that from the pysuffix library (https://code.google.com/p/pysuffix/).\n\n        K\u00e4rkk\u00e4inen & Sanders (2003).\n        \"\"\"\n        n = len(string)\n        string += (unichr(1) * 3)\n        suftab = np.zeros(n, dtype=np.int)\n        alpha = sorted(set(string))\n        self._kark_sort(string, suftab, n, alpha)\n        return suftab"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the LCP array in O ( n ) based on the input string and its suffix array.", "response": "def _compute_lcptab(self, string, suftab):\n        \"\"\"Computes the LCP array in O(n) based on the input string & its suffix array.\n\n        Kasai et al. (2001).\n        \"\"\"\n        n = len(suftab)\n        rank = [0] * n\n        for i in xrange(n):\n            rank[suftab[i]] = i\n        lcptab = np.zeros(n, dtype=np.int)\n        h = 0\n        for i in xrange(n):\n            if rank[i] >= 1:\n                j = suftab[rank[i] - 1]\n                while string[i + h] == string[j + h]:\n                    h += 1\n                lcptab[rank[i]] = h\n                if h > 0:\n                    h -= 1\n        return lcptab"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _compute_childtab(self, lcptab):\n        last_index = -1\n        stack = [0]\n        n = len(lcptab)\n        childtab_up = np.zeros(n, dtype=np.int)  # Zeros / -1 ?\n        childtab_down = np.zeros(n, dtype=np.int)\n        for i in xrange(n):\n            while lcptab[i] < lcptab[stack[-1]]:\n                last_index = stack.pop()\n                if lcptab[i] <= lcptab[stack[-1]] and lcptab[stack[-1]] != lcptab[last_index]:\n                    childtab_down[stack[-1]] = last_index\n            if last_index != -1:\n                childtab_up[i] = last_index\n                last_index = -1\n            stack.append(i)\n        return childtab_up, childtab_down", "response": "Computes the child up and down arrays in O ( n ) based on the LCP table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the child next l index array in O ( n ) based on the LCP table.", "response": "def _compute_childtab_next_l_index(self, lcptab):\n        \"\"\"Computes the child 'next l index' array in O(n) based on the LCP table.\n\n        Abouelhoda et al. (2004).\n        \"\"\"\n        stack = [0]\n        n = len(lcptab)\n        childtab_next_l_index = np.zeros(n, dtype=np.int)  # Zeros / -1 ?\n        for i in xrange(n):\n            while lcptab[i] < lcptab[stack[-1]]:\n                stack.pop()\n            if lcptab[i] == lcptab[stack[-1]]:\n                last_index = stack.pop()\n                childtab_next_l_index[last_index] = i\n            stack.append(i)\n        return childtab_next_l_index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compute_anntab(self, suftab, lcptab):\n        n = len(suftab)\n        anntab = np.zeros(n, dtype=np.int)  # Zeros / -1 ?\n\n        def process_node(node):\n            # NOTE(msdubov): Assumes that child l-[i..j] lcp intervals come in the ascending\n            #                order (by i). This allows to handle the leafs properly.\n            i = node[1]\n            for child_node in node[3]:\n                if i < child_node[1]:\n                    anntab[self._interval_index(node)] += child_node[1] - i\n                anntab[self._interval_index(node)] += anntab[self._interval_index(child_node)]\n                i = child_node[2] + 1\n            if i <= node[2]:\n                anntab[self._interval_index(node)] += node[2] - i + 1\n\n        self.traverse_depth_first_post_order(process_node)\n        # NOTE(msdubov): Removing the \"degenerate\" 1st-level leafs\n        #                with the auxiliary symbol in the arc.\n        anntab[0] -= len(self.strings_collection)\n\n        return anntab", "response": "Computes the annotations array in O ( n ) by traversing the suffix array and computing the annotation array in O ( n ) by traversing the suffix array and computing the annotation array in O ( n ) by computing the annotations array in O ( n ) by traversing the suffix array."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new packet as a reply to this one.", "response": "def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return Packet(id=self.id, secret=self.secret,\n                      authenticator=self.authenticator, dict=self.dict,\n                      **attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nturning a key into a string if possible", "response": "def _DecodeKey(self, key):\n        \"\"\"Turn a key into a string if possible\"\"\"\n\n        if self.dict.attrindex.HasBackward(key):\n            return self.dict.attrindex.GetBackward(key)\n        return key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef AddAttribute(self, key, value):\n        if isinstance(value, list):\n            values = value\n        else:\n            values = [value]\n        (key, values) = self._EncodeKeyValues(key, values)\n        self.setdefault(key, []).extend(values)", "response": "Add an attribute to the packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef CreateAuthenticator():\n\n        data = []\n        for i in range(16):\n            data.append(random_generator.randrange(0, 256))\n        if six.PY3:\n            return bytes(data)\n        else:\n            return ''.join(chr(b) for b in data)", "response": "Create a packet authenticator which can be used to authenticate replies from the RADIUS server and in the password hiding algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ReplyPacket(self):\n        assert(self.authenticator)\n        assert(self.secret is not None)\n\n        attr = self._PktEncodeAttributes()\n        header = struct.pack('!BBH', self.code, self.id, (20 + len(attr)))\n\n        authenticator = md5_constructor(header[0:4] + self.authenticator\n                              + attr + self.secret).digest()\n        return header + authenticator + attr", "response": "Create a ready - to - transmit authentication reply packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndecodes a packet into a dictionary.", "response": "def DecodePacket(self, packet):\n        \"\"\"Initialize the object from raw packet data.  Decode a packet as\n        received from the network and decode it.\n\n        :param packet: raw packet\n        :type packet:  string\"\"\"\n\n        try:\n            (self.code, self.id, length, self.authenticator) = \\\n                    struct.unpack('!BBH16s', packet[0:20])\n        except struct.error:\n            raise PacketError('Packet header is corrupt')\n        if len(packet) != length:\n            raise PacketError('Packet has invalid length')\n        if length > 8192:\n            raise PacketError('Packet length is too long (%d)' % length)\n\n        self.clear()\n\n        packet = packet[20:]\n        while packet:\n            try:\n                (key, attrlen) = struct.unpack('!BB', packet[0:2])\n            except struct.error:\n                raise PacketError('Attribute header is corrupt')\n\n            if attrlen < 2:\n                raise PacketError(\n                        'Attribute length is too small (%d)' % attrlen)\n\n            value = packet[2:attrlen]\n            if key == 26:\n                # 26 is the Vendor-Specific attribute\n                (vendor, subattrs) = self._PktDecodeVendorAttribute(value)\n                if vendor is None:\n                    self.setdefault(key, []).append(value)\n                else:\n                    for (k, v) in subattrs:\n                        self.setdefault((vendor, k), []).append(v)\n            else:\n                self.setdefault(key, []).append(value)\n\n            packet = packet[attrlen:]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a ready - to - transmit authentication request packet.", "response": "def RequestPacket(self):\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        attr = self._PktEncodeAttributes()\n\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack('!BBH16s', self.code, self.id,\n            (20 + len(attr)), self.authenticator)\n\n        return header + attr"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef PwDecrypt(self, password):\n        buf = password\n        pw = six.b('')\n\n        last = self.authenticator\n        while buf:\n            hash = md5_constructor(self.secret + last).digest()\n            if six.PY3:\n                for i in range(16):\n                    pw += bytes((hash[i] ^ buf[i],))\n            else:\n                for i in range(16):\n                    pw += chr(ord(hash[i]) ^ ord(buf[i]))\n\n            (last, buf) = (buf[:16], buf[16:])\n\n        while pw.endswith(six.b('\\x00')):\n            pw = pw[:-1]\n\n        return pw.decode('utf-8')", "response": "This function decrypts a RADIUS password."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef PwCrypt(self, password):\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if isinstance(password, six.text_type):\n            password = password.encode('utf-8')\n\n        buf = password\n        if len(password) % 16 != 0:\n            buf += six.b('\\x00') * (16 - (len(password) % 16))\n\n        hash = md5_constructor(self.secret + self.authenticator).digest()\n        result = six.b('')\n\n        last = self.authenticator\n        while buf:\n            hash = md5_constructor(self.secret + last).digest()\n            if six.PY3:\n                for i in range(16):\n                    result += bytes((hash[i] ^ buf[i],))\n            else:\n                for i in range(16):\n                    result += chr(ord(hash[i]) ^ ord(buf[i]))\n\n            last = result[-16:]\n            buf = buf[16:]\n\n        return result", "response": "Obfuscate a password using an MD5 hash of the authenticator and RADIUS - specific secret."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new packet as a reply to this one.", "response": "def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AcctPacket(AccountingResponse, self.id,\n            self.secret, self.authenticator, dict=self.dict,\n            **attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RequestPacket(self):\n\n        attr = self._PktEncodeAttributes()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack('!BBH', self.code, self.id, (20 + len(attr)))\n        self.authenticator = md5_constructor(header[0:4] + 16 * six.b('\\x00') + attr\n            + self.secret).digest()\n        return header + self.authenticator + attr", "response": "Create a ready - to - transmit authentication request packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CreateReply(self, **attributes):\n        return CoAPacket(CoAACK, self.id,\n            self.secret, self.authenticator, dict=self.dict,\n            **attributes)", "response": "Create a new reply to this one."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef VerifyCoARequest(self):\n        assert(self.raw_packet)\n        hash = md5_constructor(self.raw_packet[0:4] + 16 * six.b('\\x00') +\n                self.raw_packet[20:] + self.secret).digest()\n        return hash == self.authenticator", "response": "Verify the request authenticator."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear(self):\n        # preserve the collapse button\n        super(XToolBar, self).clear()\n        \n        # clears out the toolbar\n        if self.isCollapsable():\n            self._collapseButton = QToolButton(self)\n            self._collapseButton.setAutoRaise(True)\n            self._collapseButton.setSizePolicy(QSizePolicy.Expanding,\n                                               QSizePolicy.Expanding)\n            \n            self.addWidget(self._collapseButton)\n            self.refreshButton()\n            \n            # create connection\n            self._collapseButton.clicked.connect(self.toggleCollapsed)\n        \n        elif self._collapseButton:\n            self._collapseButton.setParent(None)\n            self._collapseButton.deleteLater()\n            self._collapseButton = None", "response": "Clears out the toolbar from the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrefreshing the button for this toolbar.", "response": "def refreshButton(self):\n        \"\"\"\n        Refreshes the button for this toolbar.\n        \"\"\"\n        collapsed   = self.isCollapsed()\n        btn         = self._collapseButton\n        \n        if not btn:\n            return\n        \n        btn.setMaximumSize(MAX_SIZE, MAX_SIZE)\n        \n        # set up a vertical scrollbar\n        if self.orientation() == Qt.Vertical:\n            btn.setMaximumHeight(12)\n        else:\n            btn.setMaximumWidth(12)\n            \n        icon = ''\n        \n        # collapse/expand a vertical toolbar\n        if self.orientation() == Qt.Vertical:\n            if collapsed:\n                self.setFixedWidth(self._collapsedSize)\n                btn.setMaximumHeight(MAX_SIZE)\n                btn.setArrowType(Qt.RightArrow)\n            else:\n                self.setMaximumWidth(MAX_SIZE)\n                self._precollapseSize = None\n                btn.setMaximumHeight(12)\n                btn.setArrowType(Qt.LeftArrow)\n                \n        else:\n            if collapsed:\n                self.setFixedHeight(self._collapsedSize)\n                btn.setMaximumWidth(MAX_SIZE)\n                btn.setArrowType(Qt.DownArrow)\n            else:\n                self.setMaximumHeight(1000)\n                self._precollapseSize = None\n                btn.setMaximumWidth(12)\n                btn.setArrowType(Qt.UpArrow)\n        \n        for index in range(1, self.layout().count()):\n            item = self.layout().itemAt(index)\n            if not item.widget():\n                continue\n                \n            if collapsed:\n                item.widget().setMaximumSize(0, 0)\n            else:\n                item.widget().setMaximumSize(MAX_SIZE, MAX_SIZE)\n        \n        if not self.isCollapsable():\n            btn.hide()\n        else:\n            btn.show()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setCollapsed(self, state):\n        if state == self._collapsed:\n            return False\n        \n        self._collapsed = state\n        self.refreshButton()\n        \n        if not self.signalsBlocked():\n            self.collapseToggled.emit(state)\n        \n        return True", "response": "Sets whether or not this toolbar is in a collapsed state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCollapsable(self, state):\n        if self._collapsable == state:\n            return\n        \n        self._collapsable = state\n        self.clear()", "response": "Sets whether or not this toolbar is collapsable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the orientation for this toolbar to the inputed value.", "response": "def setOrientation( self, orientation ):\n        \"\"\"\n        Sets the orientation for this toolbar to the inputed value, and \\\n        updates the contents margins and collapse button based on the vaule.\n        \n        :param      orientation | <Qt.Orientation>\n        \"\"\"\n        super(XToolBar, self).setOrientation(orientation)\n        self.refreshButton()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setShadowed(self, state):\n        self._shadowed = state\n        if state:\n            self._colored = False\n        \n        for child in self.findChildren(XToolButton):\n            child.setShadowed(state)", "response": "Sets whether or not this toolbar is shadowed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculateDatasets(self, scene, axes, datasets):\r\n        items = self.calculateDatasetItems(scene, datasets)\r\n        if not items:\r\n            scene.clear()\r\n            return\r\n        \r\n        rect = self.buildData('axis_rect')\r\n        half_size = self.maximumBarSize() / 2.0\r\n        \r\n        for dataset, item in items.items():\r\n            path = QPainterPath()\r\n            subpaths = []\r\n            \r\n            for value in dataset.values():\r\n                pos = self.pointAt(axes, value)\r\n                \r\n                radius = min(rect.bottom() - pos.y(), 8)\r\n                \r\n                subpath = QPainterPath()\r\n                \r\n                # create a vertical bar graph\r\n                if self.orientation() == Qt.Vertical:\r\n                    subpath.moveTo(pos.x() - half_size, rect.bottom())\r\n                    subpath.lineTo(pos.x() - half_size, pos.y() + radius)\r\n                    subpath.quadTo(pos.x() - half_size, pos.y(),\r\n                                   pos.x() - half_size + radius, pos.y())\r\n                    subpath.lineTo(pos.x() + half_size - radius, pos.y())\r\n                    subpath.quadTo(pos.x() + half_size, pos.y(),\r\n                                   pos.x() + half_size, pos.y() + radius)\r\n                    subpath.lineTo(pos.x() + half_size, rect.bottom())\r\n                    subpath.lineTo(pos.x() - half_size, rect.bottom())\r\n                \r\n                # create a horizontal bar graph\r\n                else:\r\n                    subpath.moveTo(rect.left(), pos.y() - half_size)\r\n                    subpath.lineTo(pos.x(),     pos.y() - half_size)\r\n                    subpath.lineTo(pos.x(),     pos.y() + half_size)\r\n                    subpath.lineTo(rect.left(), pos.y() + half_size)\r\n                    subpath.lineTo(rect.left(), pos.y() - half_size)\r\n                \r\n                path.addPath(subpath)\r\n                subpaths.append(subpath)\r\n            \r\n            item.setPath(path)\r\n            item.setBuildData('subpaths', subpaths)", "response": "Calculates the datasets for the given scene and axes and datasets."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw the item as a bar graph.", "response": "def drawItem(self, item, painter, option):\r\n        \"\"\"\r\n        Draws the inputed item as a bar graph.\r\n        \r\n        :param      item    | <XChartDatasetItem>\r\n                    painter | <QPainter>\r\n                    option  | <QStyleOptionGraphicsItem>\r\n        \"\"\"\r\n        dataset = item.dataset()\r\n        \r\n        painter.save()\r\n        painter.setRenderHint(painter.Antialiasing)\r\n        \r\n        pen = QPen(dataset.color())\r\n        pen.setWidth(0.75)\r\n        painter.setPen(pen)\r\n        \r\n        for path in item.buildData('subpaths', []):\r\n            gradient = QLinearGradient()\r\n            \r\n            clr = QColor(dataset.color())\r\n            clr.setAlpha(220)\r\n            \r\n            gradient.setColorAt(0.0,  clr.lighter(180))\r\n            gradient.setColorAt(0.1,  clr.lighter(160))\r\n            gradient.setColorAt(0.25, clr.lighter(140))\r\n            gradient.setColorAt(1.0,  clr.lighter(125))\r\n            \r\n            if self.orientation() == Qt.Vertical:\r\n                gradient.setStart(0, path.boundingRect().bottom())\r\n                gradient.setFinalStop(0, path.boundingRect().top())\r\n            else:\r\n                gradient.setStart(path.boundingRect().left(), 0)\r\n                gradient.setFinalStop(path.boundingRect().right(), 0)\r\n            \r\n            painter.setBrush(gradient)\r\n            painter.drawPath(path)\r\n        \r\n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match(self, url):\n        return list({\n            message for message in self.active() if\n            message.is_global or message.match(url)\n        })", "response": "Return a list of all active Messages which match the given URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mousePressEvent(self, event):\r\n        ddata = self.dataset().dragData()\r\n        if ddata:\r\n            self.startDrag(ddata)\r\n        \r\n        super(XChartDatasetItem, self).mousePressEvent(event)", "response": "Creates the drag event for this item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef paint(self, painter, option, widget):\r\n        scene = self.scene()\r\n        if not scene:\r\n            return\r\n        \r\n        scene.chart().renderer().drawItem(self, painter, option)", "response": "Draws this item with the inputed painter."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the dataset associated with this item.", "response": "def setDataset(self, dataset):\r\n        \"\"\"\r\n        Sets the dataset instance associated with this item.\r\n        \r\n        :param      dataset | <XChartDataset>\r\n        \"\"\"\r\n        self._dataset = dataset\r\n        \r\n        # setup the tooltip\r\n        tip = []\r\n        tip.append('<b>%s</b>' % dataset.name())\r\n        for value in dataset.values():\r\n            value_text = []\r\n            for key, val in sorted(value.items()):\r\n                if val == dataset.name():\r\n                    continue\r\n                \r\n                axis = self.axis(key)\r\n                if axis and axis.labelFormat():\r\n                    val = axis.labelFormat().format(val)\r\n                value_text.append('%s: %s' % (key, val))\r\n            \r\n            tip.append('<p>%s</p>' % ', '.join(value_text))\r\n        self.setToolTip(''.join(tip))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef startDrag(self, dragData):\r\n        # create the mime data\r\n        mimeData = QMimeData()\r\n        for key, value in dragData.items():\r\n            mimeData.setData('application/x-%s' % key, wrapVariant(value))\r\n        \r\n        # create the drag instance\r\n        drag = QDrag(self.scene().chart())\r\n        drag.setMimeData(mimeData)\r\n        drag.exec_()", "response": "Starts a new drag with the inputed data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a boolean value that indicates whether the stat_statement module is installed.", "response": "def pg_stat_statement(self):\n        \"\"\"\n        Some queries require the pg_stat_statement module to be installed.\n        http://www.postgresql.org/docs/current/static/pgstatstatements.html\n\n        :returns: boolean\n        \"\"\"\n\n        if self._pg_stat_statement is None:\n            results = self.execute(sql.PG_STAT_STATEMENT)\n            is_available = results[0].available\n\n            if is_available:\n                self._pg_stat_statement = True\n            else:\n                self._pg_stat_statement = False\n\n        return self._pg_stat_statement"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if postgres version is greater than 9. 2. 0 and False otherwise.", "response": "def is_pg_at_least_nine_two(self):\n        \"\"\"\n        Some queries have different syntax depending what version of postgres\n        we are querying against.\n\n        :returns: boolean\n        \"\"\"\n\n        if self._is_pg_at_least_nine_two is None:\n            results = self.version()\n            regex = re.compile(\"PostgreSQL (\\d+\\.\\d+\\.\\d+) on\")\n            matches = regex.match(results[0].version)\n            version = matches.groups()[0]\n\n            if version > '9.2.0':\n                self._is_pg_at_least_nine_two = True\n            else:\n                self._is_pg_at_least_nine_two = False\n\n        return self._is_pg_at_least_nine_two"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting the given sql statement and return the result as a list of the result sets.", "response": "def execute(self, statement):\n        \"\"\"\n        Execute the given sql statement.\n\n        :param statement: sql statement to run\n        :returns: list\n        \"\"\"\n\n        # Make the sql statement easier to read in case some of the queries we\n        # run end up in the output\n        sql = statement.replace('\\n', '')\n        sql = ' '.join(sql.split())\n        self.cursor.execute(sql)\n\n        return self.cursor.fetchall()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calls(self, truncate=False):\n\n        if self.pg_stat_statement():\n            if truncate:\n                select = \"\"\"\n                    SELECT CASE\n                        WHEN length(query) < 40\n                        THEN query\n                        ELSE substr(query, 0, 38) || '..'\n                    END AS qry,\n                \"\"\"\n            else:\n                select = 'SELECT query,'\n\n            return self.execute(sql.CALLS.format(select=select))\n        else:\n            return [self.get_missing_pg_stat_statement_error()]", "response": "Show 10 most frequently called queries."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay queries holding locks other queries are waiting to be released.", "response": "def blocking(self):\n        \"\"\"\n        Display queries holding locks other queries are waiting to be\n        released.\n\n        Record(\n            pid=40821,\n            source='',\n            running_for=datetime.timedelta(0, 0, 2857),\n            waiting=False,\n            query='SELECT pg_sleep(10);'\n        )\n\n        :returns: list of Records\n        \"\"\"\n\n        return self.execute(\n            sql.BLOCKING.format(\n                query_column=self.query_column,\n                pid_column=self.pid_column\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef long_running_queries(self):\n\n        if self.is_pg_at_least_nine_two():\n            idle = \"AND state <> 'idle'\"\n        else:\n            idle = \"AND current_query <> '<IDLE>'\"\n\n        return self.execute(\n            sql.LONG_RUNNING_QUERIES.format(\n                pid_column=self.pid_column,\n                query_column=self.query_column,\n                idle=idle\n            )\n        )", "response": "Show all long running queries."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndisplays queries with active locks.", "response": "def locks(self):\n        \"\"\"\n        Display queries with active locks.\n\n        Record(\n            procpid=31776,\n            relname=None,\n            transactionid=None,\n            granted=True,\n            query_snippet='select * from hello;',\n            age=datetime.timedelta(0, 0, 288174),\n        )\n\n        :returns: list of Records\n        \"\"\"\n\n        return self.execute(\n            sql.LOCKS.format(\n                pid_column=self.pid_column,\n                query_column=self.query_column\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying the database for active queries with execution time.", "response": "def ps(self):\n        \"\"\"\n        View active queries with execution time.\n\n        Record(\n            pid=28023,\n            source='pgbench',\n            running_for=datetime.timedelta(0, 0, 288174),\n            waiting=0,\n            query='UPDATE pgbench_accounts SET abalance = abalance + 423;'\n        )\n\n        :returns: list of Records\n        \"\"\"\n\n        if self.is_pg_at_least_nine_two():\n            idle = \"AND state <> 'idle'\"\n        else:\n            idle = \"AND current_query <> '<IDLE>'\"\n\n        return self.execute(\n            sql.PS.format(\n                pid_column=self.pid_column,\n                query_column=self.query_column,\n                idle=idle\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npublishing the given list of metrics to a file in JSON format.", "response": "def publish(self, metrics, config):\n        \"\"\"Publishes metrics to a file in JSON format.\n\n        This method is called by the Snap deamon during the collection phase\n        of the execution of a Snap workflow.\n\n        In this example we are writing the metrics to a file in json format.\n        We obtain the path to the file through the config (`ConfigMap`) arg.\n\n        Args:\n            metrics (obj:`list` of :obj:`snap_plugin.v1.Metric`):\n                List of metrics to be collected.\n\n        Returns:\n            :obj:`list` of :obj:`snap_plugin.v1.Metric`:\n                List of collected metrics.\n        \"\"\"\n        if len(metrics) > 0:\n            with open(config[\"file\"], 'a') as outfile:\n                for metric in metrics:\n                    outfile.write(\n                        json_format.MessageToJson(\n                            metric._pb, including_default_value_fields=True))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a duplicate of this profile and returns it.", "response": "def duplicate(self):\r\n        \"\"\"\r\n        Create a duplicate of this profile and returns it.\r\n        \r\n        :return     <XViewProfile>\r\n        \"\"\"\r\n        out = XViewProfile()\r\n        \r\n        out._icon = self._icon\r\n        out._name = self._name\r\n        out._version = self._version\r\n        out._description = self._description\r\n        out._customData  = copy.deepcopy(self._customData)\r\n        out._xmlElement  = copy.deepcopy(self._xmlElement)\r\n        \r\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef restore(self, viewWidget):\n        if self._xmlElement is None:\n            return False\n        \n        # disable all the information\n        viewWidget.blockSignals(True)\n        viewWidget.setUpdatesEnabled(False)\n        viewWidget.setCursor(Qt.WaitCursor)\n        \r\n        viewWidget.reset(force=True)\r\n        \r\n        # make sure all the cleanup happens (short of GUI updates)\r\n        QApplication.sendPostedEvents()\r\n        \n        # restore the widget data\r\n        try:\r\n            xml_elem = self._xmlElement[0]\r\n        except IndexError:\r\n            viewWidget.unsetCursor()\r\n            viewWidget.blockSignals(False)\r\n            viewWidget.setUpdatesEnabled(True)\r\n            return False\r\n        \n        widget = self.restoreWidget(viewWidget,\n                                    viewWidget,\n                                    xml_elem)\n                                    \n        viewWidget.setWidget(widget)\n        viewWidget.setLocked(self._xmlElement.get('locked') == 'True')\n        \n        # enable the infromation\n        viewWidget.unsetCursor()\n        viewWidget.blockSignals(False)\n        viewWidget.setUpdatesEnabled(True)\n        return True", "response": "Restores the profile to the inputed view widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the widget with the inputed parent based on the given xml type.", "response": "def restoreWidget(self, viewWidget, parent, xwidget):\n        \"\"\"\n        Creates the widget with the inputed parent based on the given xml type.\n        \n        :param      viewWidget  | <XViewWidget>\n                    parent      | <QWidget>\n                    xwidget     | <xml.etree.Element>\n        \n        :return     <QWidget>\n        \"\"\"\n        # create a new splitter\n        if xwidget.tag == 'split':\n            widget = XSplitter(parent)\n            \n            if ( xwidget.get('orient') == 'horizontal' ):\n                widget.setOrientation( Qt.Horizontal )\n            else:\n                widget.setOrientation( Qt.Vertical )\n            \n            # restore the children\n            for xchild in xwidget:\n                widget.addWidget( self.restoreWidget( viewWidget,\n                                                      widget,\n                                                      xchild ) )\n                                                     \n            widget.restoreState(QByteArray.fromBase64(xwidget.get('state')))\n            \n            return widget\n        \n        # create a new panel\n        elif xwidget.tag == 'panel':\n            widget = XViewPanel(parent, viewWidget.isLocked())\r\n            hide = xwidget.get('hideTabs', 'True') == 'True'\r\n            widget.setHideTabsWhenLocked(hide)\n            widget.blockSignals(True)\n            \n            # restore the children\n            for xchild in xwidget:\n                child = self.restoreWidget( viewWidget,\n                                            widget,\n                                            xchild )\n                \n                if ( not child ):\n                    err = 'Missing View Type: %s' % xchild.get('type')\n                    logger.warning(err)\n                    continue\n                \n                widget.addTab(child, child.windowTitle())\n            \n            widget.setCurrentIndex(int(xwidget.get('current', 0)))\n            widget.blockSignals(False)\n            widget.markCurrentChanged()\r\n            \r\n            view = widget.currentWidget()\r\n            if isinstance(view, XView):\r\n                view.initialize(force=True)\n            \n            return widget\n        \n        # create a new view\n        else:\n            viewType = viewWidget.findViewType(xwidget.get('type'))\n            if not viewType:\n                return None\n            \n            widget = viewType.createInstance(parent, viewWidget)\n            widget.setObjectName(xwidget.get('name'))\n            widget.restoreXml(xwidget)\n            widget.setViewingGroup(int(xwidget.get('group', 0)))\r\n            \n            title = xwidget.get('title')\n            if title:\n                widget.setWindowTitle(title)\n            \r\n            # set the current view for this instance\r\n            if xwidget.get('current', 'False') == 'True':\r\n                widget.setCurrent()\r\n            \n            return widget"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave the xml data to the inputed filename.", "response": "def save(self, filename):\n        \"\"\"\n        Saves the xml data to the inputed filename.\n        \n        :param      filename | <str>\n        \"\"\"\n        projex.text.xmlindent(self.xmlElement())\n        \n        try:\n            f = open(filename, 'w')\n        except IOError:\n            logger.exception('Could not save file: %s' % filename)\n            return False\n            \n        f.write(self.toString())\n        f.close()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef toXml(self, xparent=None):\r\n        if xparent is not None:\r\n            xprofile = ElementTree.SubElement(xparent, 'profile')\r\n        else:\r\n            xprofile = ElementTree.Element('profile')\r\n        \r\n        xprofile.set('version', '2')\r\n        xprofile.set('name', self.name())\r\n        xprofile.set('profile_version', '{0:0.1f}'.format(self.version()))\r\n        \r\n        icon = self.icon()\r\n        if not icon.isNull():\r\n            data = projexui.storePixmap(self.icon().pixmap(48, 48))\r\n            xico = ElementTree.SubElement(xprofile, 'icon')\r\n            xico.text = data\r\n        \r\n        xdata = ElementTree.SubElement(xprofile, 'data')\r\n        self._customData.toXml(xdata)\r\n        \r\n        xdesc = ElementTree.SubElement(xprofile, 'desc')\r\n        xdesc.text = self.description()\r\n        \r\n        if self._xmlElement is not None:\r\n            xlayout = copy.deepcopy(self._xmlElement)\r\n            xlayout.tag = 'layout'\r\n            xprofile.append(xlayout)\r\n        \r\n        return xprofile", "response": "Converts the data for this profile into an XML blob."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the string representation of the current object.", "response": "def toString(self):\n        \"\"\"\n        Converts the data about this view widget into a string value.\n        \n        :return     <str>\n        \"\"\"\r\n        xprofile = self.toXml()\r\n        projex.text.xmlindent(xprofile)\n        return ElementTree.tostring(xprofile)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef recordWidget(xparent, widget):\n        # record a splitter\n        if isinstance(widget, XSplitter):\n            xwidget = ElementTree.SubElement(xparent, 'split')\n            if ( widget.orientation() == Qt.Horizontal ):\n                xwidget.set('orient', 'horizontal')\n            else:\n                xwidget.set('orient', 'vertical')\n            \n            xwidget.set('state', nativestring(widget.saveState().toBase64()))\n            \n            # record sub-widgets\n            for i in range(widget.count()):\n                XViewProfile.recordWidget(xwidget, widget.widget(i))\n        \n        # record a view panel\n        elif isinstance(widget, XViewPanel):\n            xwidget = ElementTree.SubElement(xparent, 'panel')\n            xwidget.set('current', nativestring(widget.currentIndex()))\r\n            xwidget.set('hideTabs', nativestring(widget.hideTabsWhenLocked()))\n            for i in range(widget.count()):\n                XViewProfile.recordWidget(xwidget, widget.widget(i))\n        \n        # record a view\n        elif widget is not None:\n            xwidget = ElementTree.SubElement(xparent, 'view')\n            xwidget.set('name',  nativestring(widget.objectName()))\n            xwidget.set('title', nativestring(widget.windowTitle()))\n            xwidget.set('type',  nativestring(widget.viewTypeName()))\n            xwidget.set('group', nativestring(widget.viewingGroup()))\r\n            \r\n            # store that this was the current widget\r\n            if widget.isCurrent():\r\n                xwidget.set('current', 'True')\n            \n            widget.saveXml(xwidget)", "response": "Records the inputed widget to the parent profile."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrecord the state for the inputed view widget into data.", "response": "def record(viewWidget):\n        \"\"\"\n        Records the state for the inputed view widget into data.\n        \n        :param      viewWidget | <XViewWidget>\n        \"\"\"\n        profile = XViewProfile()\n        \n        xprofile = ElementTree.Element('profile')\n        xprofile.set('locked', nativestring(viewWidget.isLocked()))\n        XViewProfile.recordWidget(xprofile, viewWidget.widget())\n        profile.setXmlElement(xprofile)\n        \n        return profile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new instance of the appropriate class based on the information in the XML file.", "response": "def fromXml( xprofile ):\r\n        \"\"\"\r\n        Restores the profile information from XML.\r\n        \r\n        :param      xprofile | <xml.etree.ElementTree.Element>\r\n        \r\n        :return     <XViewProfile>\r\n        \"\"\"\r\n        # determine the proper version\r\n        if xprofile.tag != 'profile':\r\n            return XViewProfile()\r\n        \r\n        version = int(xprofile.get('version', '1'))\r\n        \r\n        # load the legacy information - just layout data\r\n        if version == 1:\r\n            prof = XViewProfile()\r\n            prof.setXmlElement(xprofile)\r\n            return prof\r\n        \r\n        # load latest information\r\n        prof = XViewProfile()\r\n        prof.setName(xprofile.get('name', ''))\r\n        prof.setVersion(float(xprofile.get('profile_version', '1.0')))\r\n        \r\n        ico = xprofile.get('icon')\r\n        if ico is not None:\r\n            prof.setIcon(os.path.expandvars(ico))\r\n        else:\r\n            ico = xprofile.find('icon')\r\n            if ico is not None:\r\n                prof.setIcon(projexui.generatePixmap(ico.text))\r\n        \r\n        # restore data\r\n        xdata = xprofile.find('data')\r\n        if ( xdata is not None ):\r\n            prof._customData = DataSet.fromXml(xdata)\r\n        \r\n        # load description\r\n        xdesc = xprofile.find('desc')\r\n        if ( xdesc is not None ):\r\n            prof.setDescription(xdesc.text)\r\n        \r\n        # load layout\r\n        xlayout = xprofile.find('layout')\r\n        if ( xlayout is not None ):\r\n            prof.setXmlElement(xlayout)\r\n        \r\n        return prof"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fromString(strdata):\n        if strdata:\r\n            try:\n                xprofile = ElementTree.fromstring(nativestring(strdata))\r\n            except ExpatError, err:\r\n                logger.exception(str(err))\r\n                return XViewProfile()\r\n            \r\n            return XViewProfile.fromXml(xprofile)\r\n        \r\n        logger.warning('Blank profile data provided.')\r\n        return XViewProfile()", "response": "Generates profile data from the inputed string data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load( filename ):\n        try:\n            f = open(filename, 'r')\n            \n        except IOError:\n            logger.exception('Could not load the file: %s' % filename)\n            return False\n        \n        strdata = f.read()\n        f.close()\n        \n        return XViewProfile.fromString(strdata)", "response": "Loads the profile from the inputed filename."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean_name(self):\n        \"Avoid name clashes between static and dynamic attributes.\"\n        name = self.cleaned_data['name']\n        reserved_names = self._meta.model._meta.get_all_field_names()\n        if name not in reserved_names:\n            return name\n        raise ValidationError(_('Attribute name must not clash with reserved names'\n                                ' (\"%s\")') % '\", \"'.join(reserved_names))", "response": "Avoid name clashes between static and dynamic attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves this form s cleaned_data into model instance self. instance and related EAV attributes. Returns the new instance.", "response": "def save(self, commit=True):\n        \"\"\"\n        Saves this ``form``'s cleaned_data into model instance ``self.instance``\n        and related EAV attributes.\n\n        Returns ``instance``.\n        \"\"\"\n\n        if self.errors:\n            raise ValueError(\"The %s could not be saved because the data didn't\"\n                             \" validate.\" % self.instance._meta.object_name)\n\n        # create entity instance, don't save yet\n        instance = super(BaseDynamicEntityForm, self).save(commit=False)\n\n        # assign attributes\n        for name in instance.get_schema_names():\n            value = self.cleaned_data.get(name)\n            setattr(instance, name, value)\n\n        # save entity and its attributes\n        if commit:\n            instance.save()\n\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the current record based on the active index from the model.", "response": "def currentRecord(self):\r\n        \"\"\"\r\n        Returns the current record based on the active index from the model.\r\n        \r\n        :return     <orb.Table> || None\r\n        \"\"\"\r\n        completion = nativestring(self._pywidget.text())\r\n        options    = map(str, self.model().stringList())\r\n        \r\n        try:\r\n            index = options.index(completion)\r\n        except ValueError:\r\n            return None\r\n        \r\n        return self._records[index]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eventFilter(self, object, event):\r\n        result = super(XOrbSearchCompleter, self).eventFilter(object, event)\r\n        \r\n        # update the search results\r\n        if event.type() == event.KeyPress:\r\n            # ignore return keys\r\n            if event.key() in (Qt.Key_Return,\r\n                               Qt.Key_Enter):\r\n                return False\r\n            \r\n            # ignore navigation keys\r\n            if event.key() in (Qt.Key_Up,\r\n                               Qt.Key_Down,\r\n                               Qt.Key_Left,\r\n                               Qt.Key_Right,\r\n                               Qt.Key_Shift,\r\n                               Qt.Key_Control,\r\n                               Qt.Key_Alt):\r\n                return result\r\n            \r\n            text = self._pywidget.text()\r\n            if text != self._lastSearch:\r\n                # clear the current completion\r\n                self.model().setStringList([])\r\n                \r\n                # mark for reset\r\n                self._refreshTimer.start()\r\n        \r\n        return result", "response": "Sets the completion prefor this instance triggering a search query query\r\n            for the search query. Returns True if the event was handled otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refresh(self):\r\n        table   = self.tableType()\r\n        search  = nativestring(self._pywidget.text())\r\n        if search == self._lastSearch:\r\n            return\r\n        \r\n        self._lastSearch = search\r\n        if not search:\r\n            return\r\n        \r\n        if search in self._cache:\r\n            records = self._cache[search]\r\n        else:\r\n            records = table.select(where = self.baseQuery(),\r\n                                   order = self.order())\r\n            records = list(records.search(search, limit=self.limit()))\r\n            self._cache[search] = records\r\n        \r\n        self._records = records\r\n        self.model().setStringList(map(str, self._records))\r\n        self.complete()", "response": "Refreshes the contents of the completer based on the current text."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef xviewSlot(*typs, **opts):\n    default = opts.get('default')\n    policy  = opts.get('policy')\n    \n    if typs:\n        typ_count = len(typs)\n    else:\n        typ_count = 0\n    \n    def decorated(func):\n        @wraps(func)\n        def wrapped(*args, **kwds):\n            if ( args and isinstance(args[0], XView) ):\n                validated = args[0].validateSignal(policy)\n            else:\n                validated = True\n            \n            if ( validated ):\n                new_args = args[:typ_count+1]\n                return func(*new_args, **kwds)\n            return default\n        return wrapped\n    return decorated", "response": "A decorator that returns a new slot for the XView system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nblocking the given signal.", "response": "def blockSignal(self, signal, state):\n        \"\"\"\n        Blocks the particular signal.\n        \n        :param      signal | <str>\n                    state  | <bool>\n        \"\"\"\n        signal = nativestring(signal)\n        if state:\n            self._blockedSignals.setdefault(signal, 0)\n            self._blockedSignals[signal] += 1\n        else:\n            val = self._blockedSignals.get(signal, 0)\n            val -= 1\n            if val > 0:\n                self._blockedSignals[signal] = val\n            elif val == 0:\n                self._blockedSignals.pop(signal)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a connection for this instance for the given signal and slot.", "response": "def connect(self, signal, slot):\n        \"\"\"\n        Creates a connection for this instance for the given signal.\n        \n        :param      signal | <str>\n                    slot   | <callable>\n        \"\"\"\n        super(XViewDispatch, self).connect(self, SIGNAL(signal), slot)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nemits a signal through the dispatcher.", "response": "def emit(self, signal, *args):\n        \"\"\"\n        Emits a signal through the dispatcher.\n        \n        :param      signal | <str>\n                    *args  | additional arguments\n        \"\"\"\n        if not (self.signalsBlocked() or self.signalBlocked(signal)):\n            super(XViewDispatch, self).emit(SIGNAL(signal), *args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef closeEvent(self, event):\n        if not self.canClose():\n            event.ignore()\n            return\n\n        elif not self.isViewSingleton():\n            self.setAttribute(Qt.WA_DeleteOnClose)\n\n        else:\n            self.setParent(self.window())  # attach the hidden singleton instance to the window vs. anything in the view\n\n        super(XView, self).closeEvent(event)", "response": "Override this method to set the attribute to delete on close if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nemitting the given signal via the XView dispatch instance with the given arguments.", "response": "def dispatchEmit(self, signal, *args):\n        \"\"\"\n        Emits the given signal via the XView dispatch instance with the\n        given arguments.\n        \n        :param      signal | <str>\n                    args   | <tuple>\n        \"\"\"\n        XView.setGlobal('emitGroup', self.viewingGroup())\n        XView.dispatch().emit(signal, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nduplicates this current view for another. Subclass this method to provide any additional duplication options. :param parent | <QWidget> :return <XView> | instance of this class", "response": "def duplicate(self, parent):\n        \"\"\"\n        Duplicates this current view for another.  Subclass this method to \n        provide any additional duplication options.\n        \n        :param      parent | <QWidget>\n        \n        :return     <XView> | instance of this class\n        \"\"\"\n        # only return a single singleton instance\n        if self.isViewSingleton():\n            return self\n            \n        output = type(self).createInstance(parent, self.viewWidget())\n        \n        # save/restore the current settings\n        xdata = ElementTree.Element('data')\n        self.saveXml(xdata)\n        new_name = output.objectName()\n        output.setObjectName(self.objectName())\n        output.restoreXml(xdata)\n        output.setObjectName(new_name)\n        \n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\noverride hideEvent to set the visible state for this view.", "response": "def hideEvent(self, event):\n        \"\"\"\n        Sets the visible state for this widget.  If it is the first time this\n        widget will be visible, the initialized signal will be emitted.\n        \n        :param      state | <bool>\n        \"\"\"\n        super(XView, self).hideEvent(event)\n        \n        # record the visible state for this widget to be separate of Qt's\n        # system to know if this view WILL be visible or not once the \n        # system is done processing.  This will affect how signals are\n        # validated as part of the visible slot delegation\n        self._visibleState = False\n        \n        if not self.signalsBlocked():\n            self.visibleStateChanged.emit(False)\n            QTimer.singleShot(0, self.hidden)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initialize(self, force=False):\n        if force or (self.isVisible() and \\\n                     not self.isInitialized() and \\\n                     not self.signalsBlocked()):\n            \n            self._initialized = True\n            self.initialized.emit()", "response": "Initializes the view if it is visible or being loaded."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the current state of the current source.", "response": "def setCurrent(self, state=True):\n        \"\"\"\n        Marks this view as the current source based on the inputed flag.  \\\n        This method will return True if the currency changes.\n        \n        :return     <bool> | changed\n        \"\"\"\n        if self._current == state:\n            return False\n        \n        widget = self.viewWidget()\n        if widget:\n            for other in widget.findChildren(type(self)):\n                if other.isCurrent():\n                    other._current = False\n                    if not other.signalsBlocked():\n                        other.currentStateChanged.emit(state)\n                        other.deactivated.emit()\n        \n        self._current = state\n        \n        if not self.signalsBlocked():\n            self.currentStateChanged.emit(state)\n            if state:\n                self.activated.emit()\n            else:\n                self.deactivated.emit()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the maximum height value to the inputed height.", "response": "def setFixedHeight(self, height):\n        \"\"\"\n        Sets the maximum height value to the inputed height and emits the \\\n        sizeConstraintChanged signal.\n        \n        :param      height | <int>\n        \"\"\"\n        super(XView, self).setFixedHeight(height)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the maximum width value to the inputed width.", "response": "def setFixedWidth(self, width):\n        \"\"\"\n        Sets the maximum width value to the inputed width and emits the \\\n        sizeConstraintChanged signal.\n        \n        :param      width | <int>\n        \"\"\"\n        super(XView, self).setFixedWidth(width)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the maximum height of the item.", "response": "def setMaximumHeight(self, height):\n        \"\"\"\n        Sets the maximum height value to the inputed height and emits the \\\n        sizeConstraintChanged signal.\n        \n        :param      height | <int>\n        \"\"\"\n        super(XView, self).setMaximumHeight(height)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the maximum size value to the inputed size.", "response": "def setMaximumSize(self, *args):\n        \"\"\"\n        Sets the maximum size value to the inputed size and emits the \\\n        sizeConstraintChanged signal.\n        \n        :param      *args | <tuple>\n        \"\"\"\n        super(XView, self).setMaximumSize(*args)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the maximum width value for the inputed width.", "response": "def setMaximumWidth(self, width):\n        \"\"\"\n        Sets the maximum width value to the inputed width and emits the \\\n        sizeConstraintChanged signal.\n        \n        :param      width | <int>\n        \"\"\"\n        super(XView, self).setMaximumWidth(width)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setMinimumHeight(self, height):\n        super(XView, self).setMinimumHeight(height)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()", "response": "Sets the minimum height value for the current item."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setMinimumSize(self, *args):\n        super(XView, self).setMinimumSize(*args)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()", "response": "Sets the minimum size value to the inputed size."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the minimum width value for the current item.", "response": "def setMinimumWidth(self, width):\n        \"\"\"\n        Sets the minimum width value to the inputed width and emits the \\\n        sizeConstraintChanged signal.\n        \n        :param      width | <int>\n        \"\"\"\n        super(XView, self).setMinimumWidth(width)\n        \n        if ( not self.signalsBlocked() ):\n            self.sizeConstraintChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the window title for this view and emits the windowTitleChanged signal if the signals are not blocked.", "response": "def setWindowTitle(self, title):\n        \"\"\"\n        Sets the window title for this view, and emits the windowTitleChanged \\\n        signal if the signals are not blocked.  Setting this title will update \\\n        the tab title for the view within the widget.\n        \n        :param      title | <str>\n        \"\"\"\n        super(XView, self).setWindowTitle(title)\n        if ( not self.signalsBlocked() ):\n            self.windowTitleChanged.emit(title)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef showActiveState(self, state):\n        return\n        \n        palette = self.window().palette()\n        clr = palette.color(palette.Window)\n        avg = (clr.red() + clr.green() + clr.blue()) / 3\n        \n        if avg < 180 and state:\n            clr = clr.lighter(105)\n        elif not state:\n            clr = clr.darker(105)\n        \n        palette.setColor(palette.Window, clr)\n        self.setPalette(palette)", "response": "Show the active state of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef showEvent(self, event):\n        super(XView, self).showEvent(event)\n        \n        # record the visible state for this widget to be separate of Qt's\n        # system to know if this view WILL be visible or not once the \n        # system is done processing.  This will affect how signals are\n        # validated as part of the visible slot delegation\n        self._visibleState = True\n        \n        if not self.isInitialized():\n            self.initialize()\n        \n        # after the initial time the view is loaded, the visibleStateChanged\n        # signal will be emitted\n        elif not self.signalsBlocked():\n            self.visibleStateChanged.emit(True)\n            QTimer.singleShot(0, self.shown)", "response": "Sets the visible state for this view."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validateSignal(self, policy=None):\n        # validate whether or not to process a signal\n        if policy is None:\n            policy = self.signalPolicy()\n        \n        group_check   = XView.getGlobal('emitGroup') == self.viewingGroup()\n        current_check = self.isCurrent()\n        \n        # always delegate signals if they are not set to block,\n        # or if the method is called directly (not from a signal)\n        if not self.sender() or policy & XView.SignalPolicy.NeverBlock:\n            return True\n        \n        # block delegation of the signal if the view is not initialized\n        elif policy & XView.SignalPolicy.BlockIfNotInitialized and \\\n             not self.isInitialized():\n            return False\n        \n        # block delegation if the view is not visible\n        elif policy & XView.SignalPolicy.BlockIfNotVisible and \\\n            not self._visibleState:\n            return False\n        \n        # block delegation if the view is not part of a group\n        elif self.viewingGroup() and \\\n             policy & XView.SignalPolicy.BlockIfNotInGroup:\n            return group_check\n        \n        # look for only currency releated connections\n        elif policy & XView.SignalPolicy.BlockIfNotCurrent:\n            return current_check\n        \n        else:\n            return True", "response": "Validates that the view is part of the group that is emitting the signal and that the signal is not already in the group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef currentView(cls, parent=None):\n        if parent is None:\n            parent = projexui.topWindow()\n        \n        for inst in parent.findChildren(cls):\n            if inst.isCurrent():\n                return inst\n        return None", "response": "Returns the current view for the given class within a viewWidget."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroySingleton(cls):\n        singleton_key = '_{0}__singleton'.format(cls.__name__)\n        singleton = getattr(cls, singleton_key, None)\n        \n        if singleton is not None:\n            setattr(cls, singleton_key, None)\n\n            singleton.close()\n            singleton.deleteLater()", "response": "Destroys the singleton instance of this class if one exists."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef instances(cls, parent=None):\n        if parent is None:\n            parent = projexui.topWindow()\n        return parent.findChildren(cls)", "response": "Returns all the instances that exist for a given parent."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new dialog with the given parent and viewwidget.", "response": "def popup(cls, parent=None, viewWidget=None):\n        \"\"\"\n        Pops up this view as a new dialog.  If the forceDialog flag is set to \\\n        False, then it will try to activate the first instance of the view \\\n        within an existing viewwidget context before creating a new dialog.\n        \n        :param      parent      | <QWidget> || None\n                    viewWidget  | <projexui.widgets.xviewwidget.XViewWidget> || None\n        \"\"\"\n        if cls.isViewSingleton():\n            inst = cls.createInstance(parent, viewWidget)\n            inst.setWindowFlags(Qt.Dialog)\n        else:\n            inst = cls.popupInstance(parent, viewWidget)\n        \n        inst.showNormal()\n        inst.setFocus()\n        inst.raise_()\n        inst.activateWindow()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the instance of the global view dispatching system.", "response": "def dispatch(location='Central'):\n        \"\"\"\n        Returns the instance of the global view dispatching system.  All views \\\n        will route their signals through the central hub so no single view \\\n        necessarily depends on another.\n        \n        :return     <XViewDispatch>\n        \"\"\"\n        dispatch = XView._dispatch.get(nativestring(location))\n        if not dispatch:\n            dispatch = XViewDispatch(QApplication.instance())\n            XView._dispatch[nativestring(location)] = dispatch\n        \n        return dispatch"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the view that is registered to the inputed location for the given name.", "response": "def registeredView(viewName, location='Central'):\n        \"\"\"\n        Returns the view that is registered to the inputed location for the \\\n        given name.\n        \n        :param      viewName | <str>\n                    location | <str>\n        \n        :return     <subclass of XView> || None\n        \"\"\"\n        loc = nativestring(location)\n        view = XView._registry.get(loc, {}).get(viewName, None)\n        if not view:\n            for view in XView._registry.get(nativestring(location), {}).values():\n                if view.__name__ == viewName:\n                    return view\n        return view"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef registeredViews(location='Central'):\n        return [view for view in XView._registry.get(nativestring(location), {}).values() if not view.isViewAbstract()]", "response": "Returns all the views that have benefit from a particular location."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef registerView(viewType, location='Central'):\n        # update the dispatch signals\n        sigs = getattr(viewType, '__xview_signals__', [])\n        XView.dispatch(location).registerSignals(sigs)\n        \n        location = nativestring(location)\n        XView._registry.setdefault(location, {})\n        XView._registry[location][viewType.viewName()] = viewType\n        XView.dispatch(location).emit('registeredView(QVariant)', viewType)", "response": "Registers the given view type to the given location."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unregisterView(viewType, location='Central'):\n        XView._registry.get(location, {}).pop(viewType.viewName(), None)\n        XView.dispatch(location).emit('unregisteredView(QVariant)', viewType)", "response": "Unregisters the given view type from the inputed location."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef adjustSize(self):\n        # adjust the close button\n        align = self.closeAlignment()\n        if align & QtCore.Qt.AlignTop:\n            y = 6\n        else:\n            y = self.height() - 38\n\n        if align & QtCore.Qt.AlignLeft:\n            x = 6\n        else:\n            x = self.width() - 38\n\n        self._closeButton.move(x, y)\n\n        # adjust the central widget\n        widget = self.centralWidget()\n        if widget is not None:\n            center = self.rect().center()\n            widget.move(center.x() - widget.width() / 2, center.y() - widget.height() / 2)", "response": "Adjusts the size of this widget as the parent resizes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrejects the modal window when an escape press is detected.", "response": "def keyPressEvent(self, event):\n        \"\"\"\n        Exits the modal window on an escape press.\n\n        :param      event | <QtCore.QKeyPressEvent>\n        \"\"\"\n        if event.key() == QtCore.Qt.Key_Escape:\n            self.reject()\n\n        super(XOverlayWidget, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef eventFilter(self, object, event):\n        if object == self.parent() and event.type() == QtCore.QEvent.Resize:\n            self.resize(event.size())\n        elif event.type() == QtCore.QEvent.Close:\n            self.setResult(0)\n        return False", "response": "Resizes this overlay as the widget resizes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resizeEvent(self, event):\n        super(XOverlayWidget, self).resizeEvent(event)\n        self.adjustSize()", "response": "Handles a resize event for this overlay centering the central widget if one is found."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the central widget for this overlay to the inputed widget.", "response": "def setCentralWidget(self, widget):\n        \"\"\"\n        Sets the central widget for this overlay to the inputed widget.\n\n        :param      widget | <QtGui.QWidget>\n        \"\"\"\n        self._centralWidget = widget\n\n        if widget is not None:\n            widget.setParent(self)\n\n            widget.installEventFilter(self)\n\n            # create the drop shadow effect\n            effect = QtGui.QGraphicsDropShadowEffect(self)\n            effect.setColor(QtGui.QColor('black'))\n            effect.setBlurRadius(80)\n            effect.setOffset(0, 0)\n            widget.setGraphicsEffect(effect)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setClosable(self, state):\n        self._closable = state\n        if state:\n            self._closeButton.show()\n        else:\n            self._closeButton.hide()", "response": "Sets whether or not the user should be able to close this overlay widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setVisible(self, state):\n        super(XOverlayWidget, self).setVisible(state)\n\n        if not state:\n            self.setResult(0)", "response": "Sets the visibility of this widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing the event for this overlay.", "response": "def showEvent(self, event):\n        \"\"\"\n        Ensures this widget is the top-most widget for its parent.\n\n        :param      event | <QtCore.QEvent>\n        \"\"\"\n        super(XOverlayWidget, self).showEvent(event)\n\n        # raise to the top\n        self.raise_()\n        self._closeButton.setVisible(self.isClosable())\n\n        widget = self.centralWidget()\n        if widget:\n            center = self.rect().center()\n            start_x = end_x = center.x() - widget.width() / 2\n            start_y = -widget.height()\n            end_y = center.y() - widget.height() / 2\n\n            start = QtCore.QPoint(start_x, start_y)\n            end = QtCore.QPoint(end_x,  end_y)\n\n            # create the movement animation\n            anim = QtCore.QPropertyAnimation(self)\n            anim.setPropertyName('pos')\n            anim.setTargetObject(widget)\n            anim.setStartValue(start)\n            anim.setEndValue(end)\n            anim.setDuration(500)\n            anim.setEasingCurve(QtCore.QEasingCurve.InOutQuad)\n            anim.finished.connect(anim.deleteLater)\n            anim.start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef modal(widget, parent=None, align=QtCore.Qt.AlignTop | QtCore.Qt.AlignRight, blurred=True):\n        if parent is None:\n            parent = QtGui.QApplication.instance().activeWindow()\n\n        overlay = XOverlayWidget(parent)\n        overlay.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n        overlay.setCentralWidget(widget)\n        overlay.setCloseAlignment(align)\n        overlay.show()\n        return overlay", "response": "Creates a modal dialog for the user with the inputed widget."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef defineMultiline(self, style, openPattern, closePattern):\r\n        self._multiline.append((style, openPattern, closePattern))", "response": "Defines a pattern that can span multiple styles."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhighlight the given text according to this highlighters syntax.", "response": "def highlightBlock(self, text):\r\n        \"\"\"\r\n        Highlights the given text format based on this highlighters syntax\r\n        rules.\r\n        \r\n        :param      text | <str>\r\n        \"\"\"\r\n        text = nativestring(text)\r\n        for pattern, format in self.patterns():\r\n            for result in re.finditer(pattern, text):\r\n                grps = result.groups()\r\n                if grps:\r\n                    for i in range(len(grps)):\r\n                        start, end = result.span(i+1)\r\n                        self.setFormat(start, end - start, format)\r\n                else:\r\n                    self.setFormat(result.start(),\r\n                                   result.end() - result.start(),\r\n                                   format)\r\n        \r\n        self.setCurrentBlockState(0)\r\n        if self.previousBlockState() == 1:\r\n            return\r\n        \r\n        for form, open, close in self._multiline:\r\n            open = QtCore.QRegExp(open)\r\n            close = QtCore.QRegExp(close)\r\n            \r\n            start = open.indexIn(text)\r\n            processed = False\r\n            \r\n            while start >= 0:\r\n                processed = True\r\n                end = close.indexIn(text, start)\r\n\r\n                if end == -1:\r\n                    self.setCurrentBlockState(1)\r\n                    length = len(text) - start\r\n                else:\r\n                    length = end - start + close.matchedLength()\r\n\r\n                self.setFormat(start, length, form)\r\n                start = open.indexIn(text, start + length)\r\n            \r\n            if processed:\r\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef patterns(self):\r\n        patterns = []\r\n        \r\n        # add keyword patterns\r\n        form = self.styleFormat(XCodeHighlighter.Style.Keyword)\r\n        for kwd in self.keywords():\r\n            patterns.append((r'\\b{0}\\b'.format(kwd), form))\r\n        \r\n        # add additional patterns\r\n        for style, pattern in self._patterns:\r\n            form = self.styleFormat(style)\r\n            if not form:\r\n                continue\r\n            \r\n            patterns.append((pattern, form))\r\n        \r\n        return patterns", "response": "Returns a list of highlighting rules for this highlighter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef acceptCompletion( self ):\r\n        tree = self._completerTree\r\n        if not tree:\r\n            return False\r\n            \r\n        tree.hide()\r\n        \r\n        item = tree.currentItem()\r\n        if not item:\r\n            return False\r\n        \r\n        # clear the previously typed code for the block\r\n        cursor  = self.textCursor()\r\n        text    = cursor.block().text()\r\n        col     = cursor.columnNumber()\r\n        end     = col\r\n        \r\n        while col:\r\n            col -= 1\r\n            if text[col] in ('.', ' '):\r\n                col += 1\r\n                break\r\n        \r\n        # insert the current text\r\n        cursor.setPosition(cursor.position() - (end-col), cursor.KeepAnchor)\r\n        cursor.removeSelectedText()\r\n        self.insertPlainText(item.text(0))\r\n        return True", "response": "Accepts the current completion and inserts the code into the edit. Returns True if the completion was accepted False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\napply the current line of code as an interactive python command. Returns True if the current line of code is an interactive python command False otherwise.", "response": "def applyCommand(self):\r\n        \"\"\"\r\n        Applies the current line of code as an interactive python command.\r\n        \"\"\"\r\n        # generate the command information\r\n        cursor      = self.textCursor()\r\n        cursor.movePosition(cursor.EndOfLine)\r\n        \r\n        line        = projex.text.nativestring(cursor.block().text())\r\n        at_end      = cursor.atEnd()\r\n        modifiers   = QApplication.instance().keyboardModifiers()\r\n        mod_mode    = at_end or modifiers == Qt.ShiftModifier\r\n        \r\n        # test the line for information\r\n        if mod_mode and line.endswith(':'):\r\n            cursor.movePosition(cursor.EndOfLine)\r\n            \r\n            line = re.sub('^>>> ', '', line)\r\n            line = re.sub('^\\.\\.\\. ', '', line)\r\n            count = len(line) - len(line.lstrip()) + 4\r\n            \r\n            self.insertPlainText('\\n... ' + count * ' ')\r\n            return False\r\n        \r\n        elif mod_mode and line.startswith('...') and \\\r\n            (line.strip() != '...' or not at_end):\r\n            cursor.movePosition(cursor.EndOfLine)\r\n            line = re.sub('^\\.\\.\\. ', '', line)\r\n            count = len(line) - len(line.lstrip())\r\n            self.insertPlainText('\\n... ' + count * ' ')\r\n            return False\r\n        \r\n        # if we're not at the end of the console, then add it to the end\r\n        elif line.startswith('>>>') or line.startswith('...'):\r\n            # move to the top of the command structure\r\n            line = projex.text.nativestring(cursor.block().text())\r\n            while line.startswith('...'):\r\n                cursor.movePosition(cursor.PreviousBlock)\r\n                line = projex.text.nativestring(cursor.block().text())\r\n            \r\n            # calculate the command\r\n            cursor.movePosition(cursor.EndOfLine)\r\n            line = projex.text.nativestring(cursor.block().text())\r\n            ended = False\r\n            lines = []\r\n            \r\n            while True:\r\n                # add the new block\r\n                lines.append(line)\r\n                \r\n                if cursor.atEnd():\r\n                    ended = True\r\n                    break\r\n                \r\n                # move to the next line\r\n                cursor.movePosition(cursor.NextBlock)\r\n                cursor.movePosition(cursor.EndOfLine)\r\n                \r\n                line = projex.text.nativestring(cursor.block().text())\r\n                \r\n                # check for a new command or the end of the command\r\n                if not line.startswith('...'):\r\n                    break\r\n            \r\n            command = '\\n'.join(lines)\r\n            \r\n            # if we did not end up at the end of the command block, then\r\n            # copy it for modification\r\n            if not (ended and command):\r\n                self.waitForInput()\r\n                self.insertPlainText(command.replace('>>> ', ''))\r\n                cursor.movePosition(cursor.End)\r\n                return False\r\n        \r\n        else:\r\n            self.waitForInput()\r\n            return False\r\n        \r\n        self.executeCommand(command)\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the completion tree for this instance.", "response": "def completerTree( self ):\r\n        \"\"\"\r\n        Returns the completion tree for this instance.\r\n        \r\n        :return     <QTreeWidget>\r\n        \"\"\"\r\n        if not self._completerTree:\r\n            self._completerTree = QTreeWidget(self)\r\n            self._completerTree.setWindowFlags(Qt.Popup)\r\n            self._completerTree.setAlternatingRowColors( True )\r\n            self._completerTree.installEventFilter(self)\r\n            self._completerTree.itemClicked.connect( self.acceptCompletion )\r\n            self._completerTree.setRootIsDecorated(False)\r\n            self._completerTree.header().hide()\r\n            \r\n        return self._completerTree"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef eventFilter(self, obj, event):\r\n        if not obj == self._completerTree:\r\n            return False\r\n        \r\n        if event.type() != event.KeyPress:\r\n            return False\r\n            \r\n        if event.key() == Qt.Key_Escape:\r\n            QToolTip.hideText()\r\n            self.cancelCompletion()\r\n            return False\r\n        \r\n        elif event.key() in (Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab):\r\n            self.acceptCompletion()\r\n            return False\r\n        \r\n        elif event.key() in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown):\r\n            return False\r\n        \r\n        else:\r\n            self.keyPressEvent(event)\r\n            \r\n            # update the completer\r\n            cursor   = self.textCursor()\r\n            text     = projex.text.nativestring(cursor.block().text())\r\n            text     = text[:cursor.columnNumber()].split(' ')[-1]\r\n            text     = text.split('.')[-1]\r\n            \r\n            self._completerTree.blockSignals(True)\r\n            self._completerTree.setUpdatesEnabled(False)\r\n            \r\n            self._completerTree.setCurrentItem(None)\r\n            \r\n            for i in range(self._completerTree.topLevelItemCount()):\r\n                item = self._completerTree.topLevelItem(i)\r\n                if projex.text.nativestring(item.text(0)).startswith(text):\r\n                    self._completerTree.setCurrentItem(item)\r\n                    break\r\n            \r\n            self._completerTree.blockSignals(False)\r\n            self._completerTree.setUpdatesEnabled(True)\r\n            \r\n            return True", "response": "Filter the completion tree for a given event."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef executeCommand(self, command):\r\n        if not command.strip():\r\n            return self.waitForInput()\r\n        \r\n        # store the current block\r\n        self._history.append(command)\r\n        self._currentHistoryIndex = len(self._history)\r\n        \r\n        lines = []\r\n        for line in command.split('\\n'):\r\n            line = re.sub('^>>> ', '', line)\r\n            line = re.sub('^\\.\\.\\. ', '', line)\r\n            lines.append(line)\r\n        \r\n        command = '\\n'.join(lines)\r\n        \r\n        # ensure we are at the end\r\n        self.moveCursor(QTextCursor.End)\r\n        self.scrollToEnd()\r\n        self.insertPlainText('\\n')\r\n        cmdresult = None\r\n        \r\n        try:\r\n            cmdresult = eval(command, self.scope(), self.scope())\r\n        \r\n        except SyntaxError:\r\n            exec(command) in self.scope(), self.scope()\r\n        \r\n        else:\r\n            if cmdresult is not None:\r\n                # check to see if the command we executed actually caused\r\n                # the destruction of this object -- if it did, then\r\n                # the commands below will error\r\n                if self.isDestroyed():\r\n                    return\r\n                \r\n                try:\r\n                    result = projex.text.nativestring(repr(cmdresult))\r\n                except:\r\n                    result = '<<< error formatting result to utf-8 >>>'\r\n                \r\n                self.information(result)\r\n        \r\n        finally:\r\n            self.waitForInput()", "response": "Executes the inputed command in the global scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gotoHome(self):\r\n        mode = QTextCursor.MoveAnchor\r\n        \r\n        # select the home\r\n        if QApplication.instance().keyboardModifiers() == Qt.ShiftModifier:\r\n            mode = QTextCursor.KeepAnchor\r\n        \r\n        cursor = self.textCursor()\r\n        block  = projex.text.nativestring(cursor.block().text())\r\n        \r\n        cursor.movePosition( QTextCursor.StartOfBlock, mode )\r\n        if block.startswith('>>> '):\r\n            cursor.movePosition(QTextCursor.Right, mode, 4)\r\n        elif block.startswith('... '):\r\n            match = re.match('...\\s*', block)\r\n            cursor.movePosition(QTextCursor.Right, mode, match.end())\r\n        \r\n        self.setTextCursor(cursor)", "response": "Navigates to the home position for the edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insertFromMimeData(self, source):\r\n        lines = projex.text.nativestring(source.text()).splitlines()\r\n        for i in range(1, len(lines)):\r\n            if not lines[i].startswith('... '):\r\n                lines[i] = '... ' + lines[i]\r\n        \r\n        if len(lines) > 1:\r\n            lines.append('... ')\r\n        \r\n        self.insertPlainText('\\n'.join(lines))", "response": "Inserts the information from the inputed source."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insertNextCommand(self):\r\n        self._currentHistoryIndex += 1\r\n        if 0 <= self._currentHistoryIndex < len(self._history):\r\n            cmd = self._history[self._currentHistoryIndex]\r\n        else:\r\n            cmd = '>>> '\r\n            self._currentHistoryIndex = -1\r\n        \r\n        self.replaceCommand(cmd)", "response": "Inserts the next command into the line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insertPreviousCommand(self):\r\n        self._currentHistoryIndex -= 1\r\n        if 0 <= self._currentHistoryIndex < len(self._history):\r\n            cmd = self._history[self._currentHistoryIndex]\r\n        else:\r\n            cmd = '>>> '\r\n            self._currentHistoryIndex = len(self._history)\r\n        \r\n        self.replaceCommand(cmd)", "response": "Inserts the previous command into the line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef keyPressEvent(self, event):\r\n        # enter || return keys will apply the command\r\n        if event.key() in (Qt.Key_Return, Qt.Key_Enter):\r\n            self.applyCommand()\r\n            event.accept()\r\n        \r\n        # home key will move the cursor to the home position\r\n        elif event.key() == Qt.Key_Home:\r\n            self.gotoHome()\r\n            event.accept()\r\n        \r\n        elif event.key() in (Qt.Key_Backspace, Qt.Key_Delete):\r\n            super(XConsoleEdit, self).keyPressEvent(event)\r\n            \r\n            # update the completer\r\n            cursor   = self.textCursor()\r\n            text     = projex.text.nativestring(cursor.block().text())\r\n            text     = text[:cursor.columnNumber()].split(' ')[-1]\r\n            \r\n            if not '.' in text:\r\n                self.cancelCompletion()\r\n            \r\n        # period key will trigger a completion popup\r\n        elif event.key() == Qt.Key_Period or \\\r\n             (Qt.Key_A <= event.key() <= Qt.Key_Z):\r\n            super(XConsoleEdit, self).keyPressEvent(event)\r\n            self.startCompletion(force=event.key() == Qt.Key_Period)\r\n        \r\n        # space, tab, backspace and delete will cancel the completion\r\n        elif event.key() == Qt.Key_Space:\r\n            self.cancelCompletion()\r\n            super(XConsoleEdit, self).keyPressEvent(event)\r\n        \r\n        # left parenthesis will start method help\r\n        elif event.key() == Qt.Key_ParenLeft:\r\n            self.cancelCompletion()\r\n            self.showMethodToolTip()\r\n            super(XConsoleEdit, self).keyPressEvent(event)\r\n        \r\n        # Ctrl+Up will load previous commands\r\n        elif event.key() == Qt.Key_Up:\r\n            if self.commandLineInteraction() or \\\r\n               event.modifiers() & Qt.ControlModifier:\r\n                self.insertPreviousCommand()\r\n                event.accept()\r\n            else:\r\n                super(XConsoleEdit, self).keyPressEvent(event)\r\n        \r\n        # Ctrl+Down will load future commands\r\n        elif event.key() == Qt.Key_Down:\r\n            if self.commandLineInteraction() or \\\r\n               event.modifiers() & Qt.ControlModifier:\r\n                self.insertNextCommand()\r\n                event.accept()\r\n            else:\r\n                super(XConsoleEdit, self).keyPressEvent(event)\r\n        \r\n        # otherwise, handle the event like normal\r\n        else:\r\n            super(XConsoleEdit, self).keyPressEvent(event)", "response": "Override this method to modify the current state of the keyboard."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the python object that the text is representing.", "response": "def objectAtCursor(self):\r\n        \"\"\"\r\n        Returns the python object that the text is representing.\r\n        \r\n        :return     <object> || None\r\n        \"\"\"\r\n        \r\n        # determine the text block\r\n        cursor   = self.textCursor()\r\n        text     = projex.text.nativestring(cursor.block().text())\r\n        position = cursor.positionInBlock() - 1\r\n        \r\n        if not text:\r\n            return (None, '')\r\n        \r\n        symbol   = ''\r\n        for match in re.finditer('[\\w\\.]+', text):\r\n            if match.start() <= position <= match.end():\r\n                symbol = match.group()\r\n                break\r\n        \r\n        if not symbol:\r\n            return (None, '')\r\n        \r\n        parts = symbol.split('.')\r\n        if len(parts) == 1:\r\n            return (self.scope(), parts[0])\r\n        \r\n        part = parts[0]\r\n        obj = self.scope().get(part)\r\n        for part in parts[1:-1]:\r\n            try:\r\n                obj = getattr(obj, part)\r\n            except AttributeError:\r\n                return (None, '')\r\n        \r\n        return (obj, parts[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing the message that the user has clicked on the object at the cursor.", "response": "def showMethodToolTip(self):\r\n        \"\"\"\r\n        Pops up a tooltip message with the help for the object under the \\\r\n        cursor.\r\n        \r\n        :return     <bool> success\r\n        \"\"\"\r\n        self.cancelCompletion()\r\n        \r\n        obj, _ = self.objectAtCursor()\r\n        if not obj:\r\n            return False\r\n        \r\n        docs = inspect.getdoc(obj)\r\n        if not docs:\r\n            return False\r\n        \r\n        # determine the cursor position\r\n        rect   = self.cursorRect()\r\n        cursor = self.textCursor()\r\n        point  = QPoint(rect.left(), rect.top() + 18)\r\n        \r\n        QToolTip.showText(self.mapToGlobal(point), docs, self)\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts a new completion popup for the current object.", "response": "def startCompletion(self, force=False):\r\n        \"\"\"\r\n        Starts a new completion popup for the current object.\r\n        \r\n        :return     <bool> success\r\n        \"\"\"\r\n        # add the top level items\r\n        tree = self.completerTree()\r\n        if not force and tree.isVisible():\r\n            return\r\n        \r\n        tree.clear()\r\n        \r\n        # make sure we have a valid object\r\n        obj, remain = self.objectAtCursor()\r\n        \r\n        if obj is None:\r\n            tree.hide()\r\n            return\r\n        \r\n        # determine the cursor position\r\n        rect   = self.cursorRect()\r\n        cursor = self.textCursor()\r\n        point  = QPoint(rect.left(), rect.top() + 18)\r\n        \r\n        # compare the ids since some things might overload the __eq__\r\n        # comparator\r\n        if id(obj) == id(self._scope):\r\n            o_keys = obj.keys()\r\n        elif obj is not None:\r\n            o_keys = dir(obj)\r\n        \r\n        keys = [key for key in sorted(o_keys) if not key.startswith('_')]\r\n        if id(obj) == id(self._scope):\r\n            if not remain:\r\n                return False\r\n            else:\r\n                keys = filter(lambda x: x.startswith(remain[0]), keys)\r\n        \r\n        if not keys:\r\n            return False\r\n        \r\n        for key in keys:\r\n            tree.addTopLevelItem(QTreeWidgetItem([key]))\r\n        \r\n        tree.move(self.mapToGlobal(point))\r\n        tree.show()\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwaits for input and returns True if it is ready to be inserted into the console.", "response": "def waitForInput(self):\r\n        \"\"\"\r\n        Inserts a new input command into the console editor.\r\n        \"\"\"\r\n        self._waitingForInput = False\r\n        \r\n        try:\r\n            if self.isDestroyed() or self.isReadOnly():\r\n                return\r\n        except RuntimeError:\r\n            return\r\n        \r\n        self.moveCursor(QTextCursor.End)\r\n        if self.textCursor().block().text() == '>>> ':\r\n            return\r\n        \r\n        # if there is already text on the line, then start a new line\r\n        newln = '>>> '\r\n        if projex.text.nativestring(self.textCursor().block().text()):\r\n            newln = '\\n' + newln\r\n        \r\n        # insert the text\r\n        self.setCurrentMode('standard')\r\n        self.insertPlainText(newln)\r\n        self.scrollToEnd()\r\n        \r\n        self._blankCache = ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_package():\n    setup(\n        name='python-form',\n        version='0.2.2',\n        description='A package for communicating with FORM',\n        long_description=readme(),\n        author='Takahiro Ueda',\n        author_email='tueda@nikhef.nl',\n        url='https://github.com/tueda/python-form',\n        license='MIT',\n        classifiers=[\n            'Development Status :: 4 - Beta',\n            'Intended Audience :: Science/Research',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: Unix',\n            'Programming Language :: Python',\n            'Programming Language :: Python :: 2',\n            'Programming Language :: Python :: 2.6',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.2',\n            'Programming Language :: Python :: 3.3',\n            'Programming Language :: Python :: 3.4',\n            'Programming Language :: Python :: 3.5',\n            'Programming Language :: Python :: 3.6',\n            'Topic :: Scientific/Engineering :: Mathematics',\n            'Topic :: Scientific/Engineering :: Physics',\n        ],\n        keywords='binding, form, computer algebra',\n        packages=find_packages(),\n        package_data={'form': ['init.frm']},\n        setup_requires=['nose'],\n    )", "response": "Entry point. Setups the entry point for communicating with FORM."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accept( self ):\n        for i in range(self.uiConfigSTACK.count()):\n            widget = self.uiConfigSTACK.widget(i)\n            if ( not widget ):\n                continue\n            \n            if ( not widget.save() ):\n                self.uiConfigSTACK.setCurrentWidget(widget)\n                return False\n        \n        # close all the widgets in the stack\n        for i in range(self.uiConfigSTACK.count()):\n            widget = self.uiConfigSTACK.widget(i)\n            if ( not widget ):\n                continue\n            \n            widget.close()\n        \n        if ( self == XConfigDialog._instance ):\n            XConfigDialog._instance = None\n            \n        super(XConfigDialog, self).accept()", "response": "Saves all the current widgets and closes down."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmanaging the close event for the current dialog.", "response": "def closeEvent( self, event ):\n        \"\"\"\n        Manages the close event for the current dialog.\n        \n        :param      event | <QCloseEvent>\n        \"\"\"\n        if ( XConfigDialog._instance == self ):\n            XConfigDialog._instance = None\n        \n        super(XConfigDialog, self).closeEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing up the instance variable and then calls the reject method.", "response": "def reject( self ):\n        \"\"\"\n        Overloads the reject method to clear up the instance variable.\n        \"\"\"\n        if ( self == XConfigDialog._instance ):\n            XConfigDialog._instance = None\n        \n        super(XConfigDialog, self).reject()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the current plugin item to the inputed plugin.", "response": "def setCurrentPlugin( self, plugin ):\n        \"\"\"\n        Sets the current plugin item to the inputed plugin.\n        \n        :param      plugin | <XConfigPlugin> || None\n        \"\"\"\n        if ( not plugin ):\n            self.uiPluginTREE.setCurrentItem(None)\n            return\n            \n        for i in range(self.uiPluginTREE.topLevelItemCount()):\n            item = self.uiPluginTREE.topLevelItem(i)\n            for c in range(item.childCount()):\n                pitem = item.child(c)\n                \n                if ( pitem.plugin() == plugin ):\n                    self.uiPluginTREE.setCurrentItem(pitem)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setPlugins( self, plugins ):\n        plugins = sorted(plugins, key = lambda x: x.title())\n        \n        breakdown = {}\n        for plugin in plugins:\n            breakdown.setdefault(plugin.configGroup(), [])\n            breakdown[plugin.configGroup()].append(plugin)\n        \n        for grp in sorted(breakdown.keys()):\n            gitem = XTreeWidgetItem([grp])\r\n            gitem.initGroupStyle()\r\n            gitem.setFixedHeight(22)\n            \n            for plugin in breakdown[grp]:\n                item = PluginItem(plugin)\n                gitem.addChild(item)\n            \n            self.uiPluginTREE.addTopLevelItem(gitem)\n            gitem.setExpanded(True)", "response": "Sets the plugins for the inputed dialog."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef showConfig( self ):\n        item = self.uiPluginTREE.currentItem()\n        if not isinstance(item, PluginItem):\n            return\n        \n        plugin = item.plugin()\n        widget = self.findChild(QWidget, plugin.uniqueName())\n        \n        if ( not widget ):\n            widget = plugin.createWidget(self)\n            widget.setObjectName(plugin.uniqueName())\n            self.uiConfigSTACK.addWidget(widget)\n            \n        self.uiConfigSTACK.setCurrentWidget(widget)", "response": "Show the config widget for the currently selected plugin."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprompt the user to edit the config settings for the inputed config.", "response": "def edit( plugins, parent = None, default = None, modal = True ):\n        \"\"\"\n        Prompts the user to edit the config settings for the inputed config \\\n        plugins.\n        \n        :param      plugins | [<XConfigPlugin>, ..]\n                    parent  | <QWidget>\n                    default | <XConfigPlugin> || None\n        \n        :return     <bool> success\n        \"\"\"\n        if ( XConfigDialog._instance ):\n            XConfigDialog._instance.show()\n            XConfigDialog._instance.activateWindow()\n            return True\n        \n        dlg = XConfigDialog( parent )\n        dlg.setPlugins(plugins)\n        dlg.setCurrentPlugin(default)\n        \n        if ( not modal ):\n            XConfigDialog._instance = dlg\n            dlg.setAttribute(Qt.WA_DeleteOnClose)\n            dlg.show()\n            return True\n            \n        if ( dlg.exec_() ):\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resizeEvent(self, event):\r\n        super(XTabBar, self).resizeEvent(event)\r\n        self.resized.emit()", "response": "Updates the position of the additional buttons when this widget resizes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef adjustButtons( self ):\n        tabbar = self.tabBar()\n        tabbar.adjustSize()\n        \r\n        w = self.width() - self._optionsButton.width() - 2\r\n        self._optionsButton.move(w, 0)\r\n        \r\n        if self.count():\r\n            need_update = self._addButton.property('alone') != False\r\n            if need_update:\r\n                self._addButton.setProperty('alone', False)\r\n                \r\n            \r\n            self._addButton.move(tabbar.width(), 1)\r\n            self._addButton.setFixedHeight(tabbar.height())\r\n        else:\r\n            need_update = self._addButton.property('alone') != True\r\n            if need_update:\r\n                self._addButton.setProperty('alone', True)\r\n            \r\n            self._addButton.move(tabbar.width() + 2, 1)\r\n        \r\n        self._addButton.stackUnder(self.currentWidget())\r\n        \r\n        # force refresh on the stylesheet (Qt limitation for updates)\r\n        if need_update:\r\n            app = QApplication.instance()\r\n            app.setStyleSheet(app.styleSheet())", "response": "Updates the position of the buttons based on the current geometry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef emitAddRequested(self, point=None):\n        if self.signalsBlocked():\n            return\n        \n        if not point:\n            btn = self._addButton\r\n            point = btn.mapToGlobal(QPoint(btn.width(), 0))\n        \n        self.addRequested.emit(point)", "response": "Emits the addRequested signal for the specified point."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nemit the options requested signal.", "response": "def emitOptionsRequested(self, point=None):\n        \"\"\"\n        Emitted when the option menu button is clicked provided the signals \\\n        are not being blocked for this widget.\n        \n        :param      point | <QPoint>\n        \"\"\"\n        if self.signalsBlocked():\n            return\n        \n        if not point:\r\n            btn = self._optionsButton\n            point = btn.mapToGlobal(QPoint(0, btn.height()))\r\n        \n        self.optionsRequested.emit(point)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resizeEvent(self, event):\r\n        super(XTabWidget, self).resizeEvent(event)\r\n        self.adjustButtons()", "response": "Updates the position of the additional buttons when this widget resizes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting whether or not the add button is visible.", "response": "def setShowAddButton(self, state):\n        \"\"\"\n        Sets whether or not the add button is visible.\n        \n        :param      state | <bool>\n        \"\"\"\r\n        self._showAddButton = state\n        self._addButton.setVisible(state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset whether or not the option button is visible.", "response": "def setShowOptionsButton(self, state):\n        \"\"\"\n        Sets whether or not the option button is visible.\n        \n        :param          state   | <bool>\n        \"\"\"\r\n        self._showOptionsButton = state\n        self._optionsButton.setVisible(state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nemits a new log record.", "response": "def emit(self, record):\r\n        \"\"\" \r\n        Throws an error based on the information that the logger reported,\r\n        given the logging level.\r\n        \r\n        :param      record | <logging.LogRecord>\r\n        \"\"\"\r\n        # if we've already processed this record, ignore it\r\n        if record in self._recordQueue:\r\n            return\r\n        \r\n        name = record.name\r\n        lvl = self.loggerLevel(name)\r\n        \r\n        # don't process this log\r\n        if lvl > record.levelno:\r\n            return\r\n        \r\n        self._recordQueue.insert(0, record)\r\n        self._recordQueue = self._recordQueue[:10]\r\n        \r\n        # emit the change\r\n        super(XLogRecordHandler, self).emit(record)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the level for the given logger.", "response": "def loggerLevel(self, logger):\r\n        \"\"\"\r\n        Returns the level for the inputed logger.\r\n        \r\n        :param      logger | <str>\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        try:\r\n            return self._loggerLevels[logger]\r\n        except KeyError:\r\n            items = sorted(self._loggerLevels.items())\r\n            for key, lvl in items:\r\n                if logger.startswith(key):\r\n                    return lvl\r\n            return logging.NOTSET"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setLoggerLevel(self, logger, level):\r\n        if logger == 'root':\r\n            _log = logging.getLogger()\r\n        else:\r\n            _log = logging.getLogger(logger)\r\n        \r\n        _log.setLevel(level)\r\n        \r\n        if level == logging.NOTSET:\r\n            self._loggerLevels.pop(logger, None)\r\n        else:\r\n            self._loggerLevels[logger] = level", "response": "Sets the level to log the inputed logger at."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef publish(self, message, routing_key=None):\n        if routing_key is None:\n            routing_key = self.routing_key\n        return self.client.publish_to_exchange(self.name, message=message, routing_key=routing_key)", "response": "Publish a message to the exchange"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef publish(self, message):\n        return self.client.publish_to_queue(self.name, message=message)", "response": "Publish a message to the queue"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a custom button to the button box.", "response": "def addButton(self, button, role=QDialogButtonBox.ActionRole):\r\n        \"\"\"\r\n        Adds a custom button to the button box for this popup widget.\r\n        \r\n        :param      button | <QAbstractButton> || <str>\r\n        \r\n        :return     <button> || None (based on if a button or string was given)\r\n        \"\"\"\r\n        return self._buttonBox.addButton(button, role)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadjust the contents of this popup widget based on the current anchor and mode.", "response": "def adjustContentsMargins( self ):\r\n        \"\"\"\r\n        Adjusts the contents for this widget based on the anchor and \\\r\n        mode.\r\n        \"\"\"\r\n        anchor = self.anchor()\r\n        mode   = self.currentMode()\r\n        \r\n        # margins for a dialog\r\n        if ( mode == XPopupWidget.Mode.Dialog ):\r\n            self.setContentsMargins(0, 0, 0, 0)\r\n        \r\n        # margins for a top anchor point\r\n        elif ( anchor & (XPopupWidget.Anchor.TopLeft |\r\n                         XPopupWidget.Anchor.TopCenter |\r\n                         XPopupWidget.Anchor.TopRight) ):\r\n            self.setContentsMargins(0, self.popupPadding() + 5, 0, 0)\r\n        \r\n        # margins for a bottom anchor point\r\n        elif ( anchor & (XPopupWidget.Anchor.BottomLeft |\r\n                         XPopupWidget.Anchor.BottomCenter |\r\n                         XPopupWidget.Anchor.BottomRight) ):\r\n            self.setContentsMargins(0, 0, 0, self.popupPadding())\r\n        \r\n        # margins for a left anchor point\r\n        elif ( anchor & (XPopupWidget.Anchor.LeftTop |\r\n                         XPopupWidget.Anchor.LeftCenter |\r\n                         XPopupWidget.Anchor.LeftBottom) ):\r\n            self.setContentsMargins(self.popupPadding(), 0, 0, 0)\r\n        \r\n        # margins for a right anchor point\r\n        else:\r\n            self.setContentsMargins(0, 0, self.popupPadding(), 0)\r\n        \r\n        self.adjustMask()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the alpha mask for this popup widget.", "response": "def adjustMask(self):\r\n        \"\"\"\r\n        Updates the alpha mask for this popup widget.\r\n        \"\"\"\r\n        if self.currentMode() == XPopupWidget.Mode.Dialog:\r\n            self.clearMask()\r\n            return\r\n        \r\n        path = self.borderPath()\r\n        bitmap = QBitmap(self.width(), self.height())\r\n        bitmap.fill(QColor('white'))\r\n        \r\n        with XPainter(bitmap) as painter:\r\n            painter.setRenderHint(XPainter.Antialiasing)\r\n            pen = QPen(QColor('black'))\r\n            pen.setWidthF(0.75)\r\n            painter.setPen(pen)\r\n            painter.setBrush(QColor('black'))\r\n            painter.drawPath(path)\r\n        \r\n        self.setMask(bitmap)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadjusting the size of this popup to best fit the new widget size.", "response": "def adjustSize(self):\r\n        \"\"\"\r\n        Adjusts the size of this popup to best fit the new widget size.\r\n        \"\"\"\r\n        widget = self.centralWidget()\r\n        if widget is None:\r\n            super(XPopupWidget, self).adjustSize()\r\n            return\r\n        \r\n        widget.adjustSize()\r\n        hint = widget.minimumSizeHint()\r\n        size = widget.minimumSize()\r\n        \r\n        width  = max(size.width(),  hint.width())\r\n        height = max(size.height(), hint.height())\r\n        \r\n        width += 20\r\n        height += 20\r\n        \r\n        if self._buttonBoxVisible:\r\n            height += self.buttonBox().height() + 10\r\n            \r\n        if self._titleBarVisible:\r\n            height += max(self._dialogButton.height(),\r\n                          self._closeButton.height()) + 10\r\n        \r\n        curr_w = self.width()\r\n        curr_h = self.height()\r\n        \r\n        # determine if we need to move based on our anchor\r\n        anchor = self.anchor()\r\n        if anchor & (self.Anchor.LeftBottom | self.Anchor.RightBottom | \\\r\n                       self.Anchor.BottomLeft | self.Anchor.BottomCenter | \\\r\n                       self.Anchor.BottomRight):\r\n            delta_y = height - curr_h\r\n        \r\n        elif anchor & (self.Anchor.LeftCenter | self.Anchor.RightCenter):\r\n            delta_y = (height - curr_h) / 2\r\n        \r\n        else:\r\n            delta_y = 0\r\n        \r\n        if anchor & (self.Anchor.RightTop | self.Anchor.RightCenter | \\\r\n                       self.Anchor.RightTop | self.Anchor.TopRight):\r\n            delta_x = width - curr_w\r\n        \r\n        elif anchor & (self.Anchor.TopCenter | self.Anchor.BottomCenter):\r\n            delta_x = (width - curr_w) / 2\r\n        \r\n        else:\r\n            delta_x = 0\r\n        \r\n        self.setMinimumSize(width, height)\r\n        self.resize(width, height)\r\n        \r\n        pos = self.pos()\r\n        pos.setX(pos.x() - delta_x)\r\n        pos.setY(pos.y() - delta_y)\r\n        \r\n        self.move(pos)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nemits the accepted signal and closes the popup.", "response": "def accept(self):\r\n        \"\"\"\r\n        Emits the accepted signal and closes the popup.\r\n        \"\"\"\r\n        self._result = 1\r\n        \r\n        if not self.signalsBlocked():\r\n            self.accepted.emit()\r\n        \r\n        if self.autoCloseOnAccept():\r\n            self.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the path that will be drawn for this widget.", "response": "def borderPath(self):\r\n        \"\"\"\r\n        Returns the border path that will be drawn for this widget.\r\n        \r\n        :return     <QPainterPath>\r\n        \"\"\"\r\n        \r\n        path = QPainterPath()\r\n        \r\n        x = 1\r\n        y = 1\r\n        w = self.width() - 2\r\n        h = self.height() - 2\r\n        pad = self.popupPadding()\r\n        anchor = self.anchor()\r\n        \r\n        # create a path for a top-center based popup\r\n        if anchor == XPopupWidget.Anchor.TopCenter:\r\n            path.moveTo(x, y + pad)\r\n            path.lineTo(x + ((w/2) - pad), y + pad)\r\n            path.lineTo(x + (w/2), y)\r\n            path.lineTo(x + ((w/2) + pad), y + pad)\r\n            path.lineTo(x + w, y + pad)\r\n            path.lineTo(x + w, y + h)\r\n            path.lineTo(x, y + h)\r\n            path.lineTo(x, y + pad)\r\n        \r\n        # create a path for a top-left based popup\r\n        elif anchor == XPopupWidget.Anchor.TopLeft:\r\n            path.moveTo(x, y + pad)\r\n            path.lineTo(x + pad, y)\r\n            path.lineTo(x + 2 * pad, y + pad)\r\n            path.lineTo(x + w, y + pad)\r\n            path.lineTo(x + w, y + h)\r\n            path.lineTo(x, y + h)\r\n            path.lineTo(x, y + pad)\r\n        \r\n        # create a path for a top-right based popup\r\n        elif anchor == XPopupWidget.Anchor.TopRight:\r\n            path.moveTo(x, y + pad)\r\n            path.lineTo(x + w - 2 * pad, y + pad)\r\n            path.lineTo(x + w - pad, y)\r\n            path.lineTo(x + w, y + pad)\r\n            path.lineTo(x + w, y + h)\r\n            path.lineTo(x, y + h)\r\n            path.lineTo(x, y + pad)\r\n        \r\n        # create a path for a bottom-left based popup\r\n        elif anchor == XPopupWidget.Anchor.BottomLeft:\r\n            path.moveTo(x, y)\r\n            path.lineTo(x + w, y)\r\n            path.lineTo(x + w, y + h - pad)\r\n            path.lineTo(x + 2 * pad, y + h - pad)\r\n            path.lineTo(x + pad, y + h)\r\n            path.lineTo(x, y + h - pad)\r\n            path.lineTo(x, y)\r\n        \r\n        # create a path for a south based popup\r\n        elif anchor == XPopupWidget.Anchor.BottomCenter:\r\n            path.moveTo(x, y)\r\n            path.lineTo(x + w, y)\r\n            path.lineTo(x + w, y + h - pad)\r\n            path.lineTo(x + ((w/2) + pad), y + h - pad)\r\n            path.lineTo(x + (w/2), y + h)\r\n            path.lineTo(x + ((w/2) - pad), y + h - pad)\r\n            path.lineTo(x, y + h - pad)\r\n            path.lineTo(x, y)\r\n        \r\n        # create a path for a bottom-right based popup\r\n        elif anchor == XPopupWidget.Anchor.BottomRight:\r\n            path.moveTo(x, y)\r\n            path.lineTo(x + w, y)\r\n            path.lineTo(x + w, y + h - pad)\r\n            path.lineTo(x + w - pad, y + h)\r\n            path.lineTo(x + w - 2 * pad, y + h - pad)\r\n            path.lineTo(x, y + h - pad)\r\n            path.lineTo(x, y)\r\n        \r\n        # create a path for a right-top based popup\r\n        elif anchor == XPopupWidget.Anchor.RightTop:\r\n            path.moveTo(x, y)\r\n            path.lineTo(x + w - pad, y)\r\n            path.lineTo(x + w, y + pad)\r\n            path.lineTo(x + w - pad, y + 2 * pad)\r\n            path.lineTo(x + w - pad, y + h)\r\n            path.lineTo(x, y + h)\r\n            path.lineTo(x, y)\r\n        \r\n        # create a path for a right-center based popup\r\n        elif anchor == XPopupWidget.Anchor.RightCenter:\r\n            path.moveTo(x, y)\r\n            path.lineTo(x + w - pad, y)\r\n            path.lineTo(x + w - pad, y + ((h/2) - pad))\r\n            path.lineTo(x + w, y + (h/2))\r\n            path.lineTo(x + w - pad, y + ((h/2) + pad))\r\n            path.lineTo(x + w - pad, y + h)\r\n            path.lineTo(x, y + h)\r\n            path.lineTo(x, y)\r\n        \r\n        # create a path for a right-bottom based popup\r\n        elif anchor == XPopupWidget.Anchor.RightBottom:\r\n            path.moveTo(x, y)\r\n            path.lineTo(x + w - pad, y)\r\n            path.lineTo(x + w - pad, y + h - 2 * pad)\r\n            path.lineTo(x + w, y + h - pad)\r\n            path.lineTo(x + w - pad, y + h)\r\n            path.lineTo(x, y + h)\r\n            path.lineTo(x, y)\r\n        \r\n        # create a path for a left-top based popup\r\n        elif anchor == XPopupWidget.Anchor.LeftTop:\r\n            path.moveTo(x + pad, y)\r\n            path.lineTo(x + w, y)\r\n            path.lineTo(x + w, y + h)\r\n            path.lineTo(x + pad, y + h)\r\n            path.lineTo(x + pad, y + 2 * pad)\r\n            path.lineTo(x, y + pad)\r\n            path.lineTo(x + pad, y)\r\n        \r\n        # create a path for an left-center based popup\r\n        elif anchor == XPopupWidget.Anchor.LeftCenter:\r\n            path.moveTo(x + pad, y)\r\n            path.lineTo(x + w, y)\r\n            path.lineTo(x + w, y + h)\r\n            path.lineTo(x + pad, y + h)\r\n            path.lineTo(x + pad, y + ((h/2) + pad))\r\n            path.lineTo(x, y + (h/2))\r\n            path.lineTo(x + pad, y + ((h/2) - pad))\r\n            path.lineTo(x + pad, y)\r\n        \r\n        # create a path for a left-bottom based popup\r\n        elif anchor == XPopupWidget.Anchor.LeftBottom:\r\n            path.moveTo(x + pad, y)\r\n            path.lineTo(x + w, y)\r\n            path.lineTo(x + w, y + h)\r\n            path.lineTo(x + pad, y + h)\r\n            path.lineTo(x, y + h - pad)\r\n            path.lineTo(x + pad, y + h - 2 * pad)\r\n            path.lineTo(x + pad, y)\r\n        \r\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\r\n        widget = self.centralWidget()\r\n        if widget and not widget.close():\r\n            return\r\n            \r\n        super(XPopupWidget, self).close()", "response": "Closes the popup widget and central widget."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef direction( self ):\r\n        anchor = self.anchor()\r\n        if ( anchor & (XPopupWidget.Anchor.TopLeft |\r\n                       XPopupWidget.Anchor.TopCenter |\r\n                       XPopupWidget.Anchor.TopRight) ):\r\n            return XPopupWidget.Direction.North\r\n        \r\n        elif ( anchor & (XPopupWidget.Anchor.BottomLeft |\r\n                         XPopupWidget.Anchor.BottomCenter |\r\n                         XPopupWidget.Anchor.BottomRight) ):\r\n            return XPopupWidget.Direction.South\r\n        \r\n        elif ( anchor & (XPopupWidget.Anchor.LeftTop |\r\n                         XPopupWidget.Anchor.LeftCenter |\r\n                         XPopupWidget.Anchor.LeftBottom) ):\r\n            return XPopupWidget.Direction.East\r\n        \r\n        else:\r\n            return XPopupWidget.Direction.West", "response": "Returns the current direction parameter for this widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eventFilter(self, object, event):\r\n        if not self.isVisible():\r\n            return False\r\n        \r\n        links = self.positionLinkedTo()\r\n        is_dialog = self.currentMode() == self.Mode.Dialog\r\n        if object not in links:\r\n            return False\r\n        \r\n        if event.type() == event.Close:\r\n            self.close()\r\n            return False\r\n        \r\n        if event.type() == event.Hide and not is_dialog:\r\n            self.hide()\r\n            return False\r\n        \r\n        if event.type() == event.Move and not is_dialog:\r\n            deltaPos = event.pos() - event.oldPos()\r\n            self.move(self.pos() + deltaPos)\r\n            return False\r\n        \r\n        if self.currentMode() != self.Mode.ToolTip:\r\n            return False\r\n        \r\n        if event.type() == event.Leave:\r\n            pos = object.mapFromGlobal(QCursor.pos())\r\n            if (not object.rect().contains(pos)):\r\n                self.close()\r\n                event.accept()\r\n                return True\r\n        \r\n        if event.type() in (event.MouseButtonPress, event.MouseButtonDblClick):\r\n            self.close()\r\n            event.accept()\r\n            return True\r\n        \r\n        return False", "response": "Returns True if the object is in the position of the object in the window False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle the button click for this widget.", "response": "def handleButtonClick(self, button):\r\n        \"\"\"\r\n        Handles the button click for this widget.  If the Reset button was\r\n        clicked, then the resetRequested signal will be emitted.  All buttons\r\n        will emit the buttonClicked signal.\r\n        \r\n        :param      button | <QAbstractButton>\r\n        \"\"\"\r\n        if ( self.signalsBlocked() ):\r\n            return\r\n        \r\n        if ( button == self._buttonBox.button(QDialogButtonBox.Reset) ):\r\n            self.resetRequested.emit()\r\n        \r\n        self.buttonClicked.emit(button)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the key press event.", "response": "def keyPressEvent( self, event ):\r\n        \"\"\"\r\n        Looks for the Esc key to close the popup.\r\n        \r\n        :param      event | <QKeyEvent>\r\n        \"\"\"\r\n        if ( event.key() == Qt.Key_Escape ):\r\n            self.reject()\r\n            event.accept()\r\n            return\r\n        \r\n        elif ( event.key() in (Qt.Key_Return, Qt.Key_Enter) ):\r\n            if self._autoDefault:\r\n                self.accept()\r\n                event.accept()\r\n            return\r\n        \r\n        super(XPopupWidget, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mapAnchorFrom(self, widget, point):\r\n        screen_geom = QtGui.QDesktopWidget(self).screenGeometry()\r\n\r\n        # calculate the end rect for each position\r\n        Anchor = self.Anchor\r\n        w = self.width()\r\n        h = self.height()\r\n\r\n        possible_rects = {\r\n            # top anchors\r\n            Anchor.TopLeft: QtCore.QRect(point.x(), point.y(), w, h),\r\n            Anchor.TopCenter: QtCore.QRect(point.x() - w / 2, point.y(), w, h),\r\n            Anchor.TopRight: QtCore.QRect(point.x() - w, point.y(), w, h),\r\n\r\n            # left anchors\r\n            Anchor.LeftTop: QtCore.QRect(point.x(), point.y(), w, h),\r\n            Anchor.LeftCenter: QtCore.QRect(point.x(), point.y() - h / 2, w, h),\r\n            Anchor.LeftBottom: QtCore.QRect(point.x(), point.y() - h, w, h),\r\n\r\n            # bottom anchors\r\n            Anchor.BottomLeft: QtCore.QRect(point.x(), point.y() - h, w, h),\r\n            Anchor.BottomCenter: QtCore.QRect(point.x() - w / 2, point.y() - h, w, h),\r\n            Anchor.BottomRight: QtCore.QRect(point.x() - w, point.y() - h, w, h),\r\n\r\n            # right anchors\r\n            Anchor.RightTop: QtCore.QRect(point.x() - self.width(), point.y(), w, h),\r\n            Anchor.RightCenter: QtCore.QRect(point.x() - self.width(), point.y() - h / 2, w, h),\r\n            Anchor.RightBottom: QtCore.QRect(point.x() - self.width(), point.y() - h, w ,h)\r\n        }\r\n\r\n        for anchor in (Anchor.TopCenter,\r\n                       Anchor.BottomCenter,\r\n                       Anchor.LeftCenter,\r\n                       Anchor.RightCenter,\r\n                       Anchor.TopLeft,\r\n                       Anchor.LeftTop,\r\n                       Anchor.BottomLeft,\r\n                       Anchor.LeftBottom,\r\n                       Anchor.TopRight,\r\n                       Anchor.RightTop,\r\n                       Anchor.BottomRight,\r\n                       Anchor.RightBottom):\r\n\r\n            if not self.isPossibleAnchor(anchor):\r\n                continue\r\n\r\n            rect = possible_rects[anchor]\r\n            if screen_geom.contains(rect):\r\n                return anchor\r\n\r\n        return self.anchor()", "response": "Returns the anchor point that best fits within the given widget from the inputed global position."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef popup(self, pos=None):\r\n        if self._first and self.centralWidget() is not None:\r\n            self.adjustSize()\r\n            self._first = False\r\n        \r\n        if not self.signalsBlocked():\r\n            self.aboutToShow.emit()\r\n        \r\n        if not pos:\r\n            pos = QCursor.pos()\r\n        \r\n        if self.currentMode() == XPopupWidget.Mode.Dialog and \\\r\n             self.isVisible():\r\n            return False\r\n        \r\n        elif self.currentMode() == XPopupWidget.Mode.Dialog:\r\n            self.setPopupMode()\r\n        \r\n        # auto-calculate the point\r\n        if self.autoCalculateAnchor():\r\n            self.setAnchor(self.mapAnchorFrom(self.parent(), pos))\r\n        \r\n        pad = self.popupPadding()\r\n        \r\n        # determine where to move based on the anchor\r\n        anchor = self.anchor()\r\n        \r\n        # MODIFY X POSITION\r\n        # align x-left\r\n        if ( anchor & (XPopupWidget.Anchor.TopLeft |\r\n                       XPopupWidget.Anchor.BottomLeft) ):\r\n            pos.setX(pos.x() - pad)\r\n        \r\n        # align x-center\r\n        elif ( anchor & (XPopupWidget.Anchor.TopCenter |\r\n                         XPopupWidget.Anchor.BottomCenter) ):\r\n            pos.setX(pos.x() - self.width() / 2)\r\n        \r\n        # align x-right\r\n        elif ( anchor & (XPopupWidget.Anchor.TopRight |\r\n                         XPopupWidget.Anchor.BottomRight) ):\r\n            pos.setX(pos.x() - self.width() + pad)\r\n        \r\n        # align x-padded\r\n        elif ( anchor & (XPopupWidget.Anchor.RightTop |\r\n                         XPopupWidget.Anchor.RightCenter |\r\n                         XPopupWidget.Anchor.RightBottom) ):\r\n            pos.setX(pos.x() - self.width())\r\n        \r\n        # MODIFY Y POSITION\r\n        # align y-top\r\n        if ( anchor & (XPopupWidget.Anchor.LeftTop |\r\n                       XPopupWidget.Anchor.RightTop) ):\r\n            pos.setY(pos.y() - pad)\r\n        \r\n        # align y-center\r\n        elif ( anchor & (XPopupWidget.Anchor.LeftCenter |\r\n                         XPopupWidget.Anchor.RightCenter) ):\r\n            pos.setY(pos.y() - self.height() / 2)\r\n        \r\n        # align y-bottom\r\n        elif ( anchor & (XPopupWidget.Anchor.LeftBottom |\r\n                         XPopupWidget.Anchor.RightBottom) ):\r\n            pos.setY(pos.y() - self.height() + pad)\r\n        \r\n        # align y-padded\r\n        elif ( anchor & (XPopupWidget.Anchor.BottomLeft |\r\n                         XPopupWidget.Anchor.BottomCenter |\r\n                         XPopupWidget.Anchor.BottomRight) ):\r\n            pos.setY(pos.y() - self.height())\r\n        \r\n        self.adjustMask()\r\n        self.move(pos)\r\n        self.update()\r\n        self.setUpdatesEnabled(True)\r\n        \r\n        if self.isAnimated():\r\n            anim = QPropertyAnimation(self, 'windowOpacity')\r\n            anim.setParent(self)\r\n            anim.setStartValue(0.0)\r\n            anim.setEndValue(self.windowOpacity())\r\n            anim.setDuration(500)\r\n            anim.finished.connect(anim.deleteLater)\r\n            self.setWindowOpacity(0.0)\r\n        else:\r\n            anim = None\r\n            \r\n        \r\n        self.show()\r\n        \r\n        if self.currentMode() != XPopupWidget.Mode.ToolTip:\r\n            self.activateWindow()\r\n            \r\n            widget = self.centralWidget()\r\n            if widget:\r\n                self.centralWidget().setFocus()\r\n            \r\n        \r\n        if anim:\r\n            anim.start()\r\n        \r\n        if not self.signalsBlocked():\r\n            self.shown.emit()\r\n        \r\n        return True", "response": "Returns true if the user has clicked the popup at the inputed position."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\noverride this method to handle the painting pointers for the popup mode and the popup widget.", "response": "def paintEvent(self, event):\r\n        \"\"\"\r\n        Overloads the paint event to handle painting pointers for the popup \\\r\n        mode.\r\n        \r\n        :param      event | <QPaintEvent>\r\n        \"\"\"\r\n        # use the base technique for the dialog mode\r\n        if self.currentMode() == XPopupWidget.Mode.Dialog:\r\n            super(XPopupWidget, self).paintEvent(event)\r\n            return\r\n        \r\n        # setup the coloring options\r\n        palette = self.palette()\r\n        \r\n        with XPainter(self) as painter:\r\n            pen = QPen(palette.color(palette.Window).darker(130))\r\n            pen.setWidthF(1.75)\r\n            painter.setPen(pen)\r\n            painter.setRenderHint(painter.Antialiasing)\r\n            painter.setBrush(palette.color(palette.Window))\r\n            painter.drawPath(self.borderPath())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nemit the rejected signal and closes the popup.", "response": "def reject(self):\r\n        \"\"\"\r\n        Emits the accepted signal and closes the popup.\r\n        \"\"\"\r\n        self._result = 0\r\n        if not self.signalsBlocked():\r\n            self.rejected.emit()\r\n        \r\n        if self.autoCloseOnReject():\r\n            self.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resizeEvent(self, event):\r\n        self.setUpdatesEnabled(False)\r\n        super(XPopupWidget, self).resizeEvent(event)\r\n        \r\n        self.adjustMask()\r\n        self.setUpdatesEnabled(True)\r\n        \r\n        x = self.width() - self._sizeGrip.width()\r\n        y = self.height() - self._sizeGrip.height()\r\n        \r\n        self._leftSizeGrip.move(0, y)\r\n        self._sizeGrip.move(x, y)", "response": "Resizes this widget and updates the mask."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset whether or not the popup widget should animate its opacity when it is shown.", "response": "def setAnimated(self, state):\r\n        \"\"\"\r\n        Sets whether or not the popup widget should animate its opacity\r\n        when it is shown.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._animated = state\r\n        self.setAttribute(Qt.WA_TranslucentBackground, state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setAutoDefault(self, state):\r\n        self._autoDefault = state\r\n        for button in self.buttonBox().buttons():\r\n            button.setAutoDefault(state)\r\n            button.setDefault(state)", "response": "Sets whether or not the buttons should respond to defaulting options\r\n        when the user is interacting with it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setCentralWidget( self, widget ):\r\n        self._scrollArea.takeWidget()\r\n        self._scrollArea.setWidget(widget)\r\n        \r\n        self.adjustSize()", "response": "Sets the central widget that will be used by this popup."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the current mode for this dialog.", "response": "def setCurrentMode( self, mode ):\r\n        \"\"\"\r\n        Sets the current mode for this dialog to the inputed mode.\r\n        \r\n        :param      mode | <XPopupWidget.Mode>\r\n        \"\"\"\r\n        if ( self._currentMode == mode ):\r\n            return\r\n        \r\n        self._currentMode = mode\r\n        self.updateModeSettings()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the direction for this popup widget.", "response": "def setDirection( self, direction ):\r\n        \"\"\"\r\n        Sets the direction for this widget to the inputed direction.\r\n        \r\n        :param      direction | <XPopupWidget.Direction>\r\n        \"\"\"\r\n        if ( direction == XPopupWidget.Direction.North ):\r\n            self.setAnchor(XPopupWidget.Anchor.TopCenter)\r\n        \r\n        elif ( direction == XPopupWidget.Direction.South ):\r\n            self.setAnchor(XPopupWidget.Anchor.BottomCenter)\r\n        \r\n        elif ( direction == XPopupWidget.Direction.East ):\r\n            self.setAnchor(XPopupWidget.Anchor.LeftCenter)\r\n        \r\n        else:\r\n            self.setAnchor(XPopupWidget.Anchor.RightCenter)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the palette for this popup widget and the scroll area.", "response": "def setPalette(self, palette):\r\n        \"\"\"\r\n        Sets the palette for this widget and the scroll area.\r\n        \r\n        :param      palette | <QPalette>\r\n        \"\"\"\r\n        super(XPopupWidget, self).setPalette(palette)\r\n        self._scrollArea.setPalette(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the widgets that this popup will be linked to for positional changes.", "response": "def setPositionLinkedTo(self, widgets):\r\n        \"\"\"\r\n        Sets the widget that this popup will be linked to for positional\r\n        changes.\r\n        \r\n        :param      widgets | <QWidget> || [<QWidget>, ..]\r\n        \"\"\"\r\n        if type(widgets) in (list, set, tuple):\r\n            new_widgets = list(widgets)\r\n        else:\r\n            new_widgets = []\r\n            widget = widgets\r\n            while widget:\r\n                widget.installEventFilter(self)\r\n                new_widgets.append(widget)\r\n                widget = widget.parent()\r\n        \r\n        self._positionLinkedTo = new_widgets"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef timerEvent( self, event ):\r\n        if self.currentMode() == XPopupWidget.Mode.ToolTip:\r\n            self.killTimer(event.timerId())\r\n            event.accept()\r\n            self.close()\r\n        else:\r\n            super(XPopupWidget, self).timerEvent(event)", "response": "Called when the timer finishes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisplay a popup widget as a tooltip bubble.", "response": "def showToolTip( text,\r\n                     point      = None,\r\n                     anchor     = None,\r\n                     parent     = None,\r\n                     background = None,\r\n                     foreground = None,\r\n                     key        = None,\r\n                     seconds    = 5 ):\r\n        \"\"\"\r\n        Displays a popup widget as a tooltip bubble.\r\n        \r\n        :param      text        | <str>\r\n                    point       | <QPoint> || None\r\n                    anchor      | <XPopupWidget.Mode.Anchor> || None\r\n                    parent      | <QWidget> || None\r\n                    background  | <QColor> || None\r\n                    foreground  | <QColor> || None\r\n                    key         | <str> || None\r\n                    seconds     | <int>\r\n        \"\"\"\r\n        if point is None:\r\n            point = QCursor.pos()\r\n            \r\n        if parent is None:\r\n            parent = QApplication.activeWindow()\r\n        \r\n        if anchor is None and parent is None:\r\n            anchor = XPopupWidget.Anchor.TopCenter\r\n        \r\n        # create a new tooltip widget\r\n        widget = XPopupWidget(parent)\r\n        widget.setToolTipMode()\r\n        widget.setResizable(False)\r\n        \r\n        # create the tooltip label\r\n        label = QLabel(text, widget)\r\n        label.setOpenExternalLinks(True)\r\n        label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)\r\n        label.setMargin(3)\r\n        label.setIndent(3)\r\n        label.adjustSize()\r\n    \r\n        widget.setCentralWidget(label)\r\n        \r\n        # update the tip\r\n        label.adjustSize()\r\n        widget.adjustSize()\r\n        \r\n        palette = widget.palette()\r\n        if not background:\r\n            background = palette.color(palette.ToolTipBase)\r\n        if not foreground:\r\n            foreground = palette.color(palette.ToolTipText)\r\n        \r\n        palette.setColor(palette.Window,     QColor(background))\r\n        palette.setColor(palette.WindowText, QColor(foreground))\r\n        widget.setPalette(palette)\r\n        widget.centralWidget().setPalette(palette)\r\n        \r\n        if anchor is None:\r\n            widget.setAutoCalculateAnchor(True)\r\n        else:\r\n            widget.setAnchor(anchor)\r\n        \r\n        widget.setAutoCloseOnFocusOut(True)\r\n        widget.setAttribute(Qt.WA_DeleteOnClose)\r\n        widget.popup(point)\r\n        widget.startTimer(1000 * seconds)\r\n        \r\n        return widget"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the full path from the given index.", "response": "def pathFromIndex( self, index ):\r\n        \"\"\"\r\n        Returns the joined path from the given model index.  This will\r\n        join together the full path with periods.\r\n        \r\n        :param      index | <QModelIndex>\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        item = self._model.itemFromIndex(index)\r\n        out  = []\r\n        \r\n        while ( item ):\r\n            out.append(nativestring(item.text()))\r\n            item = item.parent()\r\n        \r\n        return '.'.join(reversed(out))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nemit a message based on the information that the logger reported.", "response": "def emit( self, record ):\n        \"\"\" \n        Throws an error based on the information that the logger reported,\n        given the logging level.\n        \n        :param      record | <logging.LogRecord>\n        \"\"\"\n        msg   = self._formatter.format(record)\n        align = self._splash.textAlignment()\n        fg    = self._splash.textColor()\n        \n        self._splash.showMessage(msg, align, fg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gotoNext( self ):\r\n        next_page = self.currentPage() + 1\r\n        if ( next_page > self.pageCount() ):\r\n            return\r\n        \r\n        self.setCurrentPage(next_page)", "response": "Goes to the next page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pageSizePicked( self, pageSize ):\r\n        try:\r\n            pageSize = int(self._pageSizeCombo.currentText())\r\n        except ValueError:\r\n            pageSize = 0\r\n        \r\n        self.setPageSize(pageSize)\r\n        self.pageSizeChanged.emit(pageSize)", "response": "Updates when the user picks a page size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefreshing the labels to display the proper title and count information.", "response": "def refreshLabels( self ):\r\n        \"\"\"\r\n        Refreshes the labels to display the proper title and count information.\r\n        \"\"\"\r\n        itemCount = self.itemCount()\r\n        title = self.itemsTitle()\r\n        \r\n        if ( not itemCount ):\r\n            self._itemsLabel.setText(' %s per page' % title)\r\n        else:\r\n            msg = ' %s per page, %i %s total' % (title, itemCount, title)\r\n            self._itemsLabel.setText(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the current page for this widget.", "response": "def setCurrentPage( self, pageno ):\r\n        \"\"\"\r\n        Sets the current page for this widget to the inputed page.\r\n        \r\n        :param      pageno | <int>\r\n        \"\"\"\r\n        if ( pageno == self._currentPage ):\r\n            return\r\n        \r\n        if ( pageno <= 0 ):\r\n            pageno = 1\r\n        \r\n        self._currentPage = pageno\r\n        \r\n        self._prevButton.setEnabled(pageno > 1)\r\n        self._nextButton.setEnabled(pageno < self.pageCount())\r\n        \r\n        self._pagesSpinner.blockSignals(True)\r\n        self._pagesSpinner.setValue(pageno)\r\n        self._pagesSpinner.blockSignals(False)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.currentPageChanged.emit(pageno)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setPageCount( self, pageCount ):\r\n        if ( pageCount == self._pageCount ):\r\n            return\r\n        \r\n        pageCount = max(1, pageCount)\r\n        \r\n        self._pageCount = pageCount\r\n        self._pagesSpinner.setMaximum(pageCount)\r\n        self._pagesLabel.setText('of %i for ' % pageCount)\r\n        \r\n        if ( pageCount and self.currentPage() <= 0 ):\r\n            self.setCurrentPage(1)\r\n        \r\n        elif ( pageCount < self.currentPage() ):\r\n            self.setCurrentPage(pageCount)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.pageCountChanged.emit(pageCount)\r\n        \r\n        self._prevButton.setEnabled(self.currentPage() > 1)\r\n        self._nextButton.setEnabled(self.currentPage() < pageCount)", "response": "Sets the number of pages that this widget holds."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setPageSize( self, pageSize ):\r\n        if self._pageSize == pageSize:\r\n            return\r\n        \r\n        self._pageSize = pageSize\r\n        \r\n        # update the display size\r\n        ssize = nativestring(pageSize)\r\n        if ( ssize == '0' ):\r\n            ssize = ''\r\n        \r\n        self._pageSizeCombo.blockSignals(True)\r\n        index = self._pageSizeCombo.findText(ssize)\r\n        self._pageSizeCombo.setCurrentIndex(index)\r\n        self._pageSizeCombo.blockSignals(False)", "response": "Updates the page size of the items that should be displayed in a page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the options that will be displayed for this default size.", "response": "def setPageSizeOptions( self, options ):\r\n        \"\"\"\r\n        Sets the options that will be displayed for this default size.\r\n        \r\n        :param      options | [<str>,. ..]\r\n        \"\"\"\r\n        self._pageSizeCombo.blockSignals(True)\r\n        self._pageSizeCombo.addItems(options)\r\n        \r\n        ssize = nativestring(self.pageSize())\r\n        if ( ssize == '0' ):\r\n            ssize = ''\r\n        \r\n        index = self._pageSizeCombo.findText()\r\n        self._pageSizeCombo.setCurrentIndex(index)\r\n        self._pageSizeCombo.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsplits the text into a collection of strings ; returns a list of lists of lists each containing the strings in the collection.", "response": "def text_to_strings_collection(text, words=3):\n    \"\"\"\n    Splits the text to a collection of strings;\n    a GAST for such a split collection usually produces\n    better results in keyword matching that a GAST\n    for the whole text. The word parameters determines\n    how many words each string in the collection shall\n    consist of (3 by default)\n    \n    return: Unicode\n    \"\"\"\n    \n    text = prepare_text(text)\n    strings_collection = tokenize(text)\n    strings_collection = filter(lambda s: len(s) > 2 and not s.isdigit(), strings_collection)\n        \n    i = 0\n    strings_collection_grouped = []\n    while i < len(strings_collection):\n        group = ''\n        for j in xrange(words):\n            if i + j < len(strings_collection):\n                group += strings_collection[i+j]\n        strings_collection_grouped.append(group)\n        i += words\n\n    # Having an empty strings collection would lead to a runtime errors in the applications.\n    if not strings_collection_grouped:\n        strings_collection_grouped = [\" \"]\n        \n    return strings_collection_grouped"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_modules_from_package(package):\n    path = [os.path.dirname(__file__), '..'] + package.split('.')\n    path = os.path.join(*path)\n    for root, dirs, files in os.walk(path):\n        for filename in files:\n            if filename.startswith('__') or not filename.endswith('.py'):\n                continue\n            new_package = \".\".join(root.split(os.sep)).split(\"....\")[1]\n            module_name = '%s.%s' % (new_package, filename[:-3])\n            if module_name not in sys.modules:\n                __import__(module_name)", "response": "Import modules from package and append into sys. modules\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef request(self, request_method, api_method, *args, **kwargs):\n        url = self._build_url(api_method)\n        resp = requests.request(request_method, url, *args, **kwargs)\n\n        try:\n            rv = resp.json()\n        except ValueError:\n            raise RequestFailedError(resp, 'not a json body')\n\n        if not resp.ok:\n            raise RequestFailedError(resp, rv.get('error'))\n\n        return rv", "response": "Perform a request to BearyChat s OpenAPI endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef updateCurrentValue(self, value):\n        xsnap = None\n        ysnap = None\n        \n        if value != self.endValue():\n            xsnap = self.targetObject().isXSnappedToGrid()\n            ysnap = self.targetObject().isYSnappedToGrid()\n            \n            self.targetObject().setXSnapToGrid(False)\n            self.targetObject().setYSnapToGrid(False)\n        \n        super(XNodeAnimation, self).updateCurrentValue(value)\n        \n        if value != self.endValue():\n            self.targetObject().setXSnapToGrid(xsnap)\n            self.targetObject().setYSnapToGrid(ysnap)", "response": "Disables snapping during the current value update to ensure a smooth\n            transition for node animations."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadjusting the font used for the title based on the current with and \\ display name.", "response": "def adjustTitleFont(self):\n        \"\"\"\n        Adjusts the font used for the title based on the current with and \\\n        display name.\n        \"\"\"\n        left, top, right, bottom = self.contentsMargins()\n        r = self.roundingRadius()\n        \n        # include text padding\n        left += 5 + r / 2\n        top += 5 + r / 2\n        right += 5 + r / 2\n        bottom += 5 + r / 2\n        \n        r = self.rect()\n        rect_l = r.left() + left\n        rect_r = r.right() - right\n        rect_t = r.top() + top\n        rect_b = r.bottom() - bottom\n        \n        # ensure we have a valid rect\n        rect = QRect(rect_l, rect_t, rect_r - rect_l, rect_b - rect_t)\n        if rect.width() < 10:\n            return\n        \n        font = XFont(QApplication.font())\n        font.adaptSize(self.displayName(), rect, wordWrap=self.wordWrap())\n        \n        self._titleFont = font"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef adjustSize( self ):\n        cell      = self.scene().cellWidth() * 2\n        minheight = cell\n        minwidth  = 2 * cell\n        \n        # fit to the grid size\n        metrics = QFontMetrics(QApplication.font())\n        width   = metrics.width(self.displayName()) + 20\n        width   = ((width/cell) * cell) + (cell % width)\n        \n        height  = self.rect().height()\n        \n        # adjust for the icon\n        icon = self.icon()\n        if icon and not icon.isNull():\n            width += self.iconSize().width() + 2\n            height = max(height, self.iconSize().height() + 2)\n        \n        w = max(width, minwidth)\n        h = max(height, minheight)\n        \n        max_w = self.maximumWidth()\n        max_h = self.maximumHeight()\n        \n        if max_w is not None:\n            w = min(w, max_w)\n        if max_h is not None:\n            h = min(h, max_h)\n        \n        self.setMinimumWidth(w)\n        self.setMinimumHeight(h)\n        \n        self.rebuild()", "response": "Adjusts the size of this node to support the length of its contents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining the bounding rectangle for this node.", "response": "def boundingRect( self ):\n        \"\"\"\n        Determines the bounding rectangle for this node.\n        \n        :return     <QRectF>\n        \"\"\"\n        rect = super(XNode, self).boundingRect()\n        \n        pad = self.highlightPadding()\n        x = rect.x() - pad / 2.0\n        y = rect.y() - pad / 2.0\n        w = rect.width() + pad\n        h = rect.height() + pad\n        \n        return QRectF( x, y, w, h )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the main brush for this node.", "response": "def brush( self ):\n        \"\"\"\n        Return the main brush for this node.\n        \n        :return     <QBrush>\n        \"\"\"\n        # create the background brush\n        grad = QLinearGradient()\n        rect = self.rect()\n        \n        grad.setStart(QPointF(0, rect.y()))\n        grad.setFinalStop(QPointF(0, rect.bottom()))\n        \n        grad.setColorAt(0, self.baseColor())\n        grad.setColorAt(1, self.alternateColor())\n            \n        return QBrush(grad)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncenters this node on the inputed point.", "response": "def centerOn(self, point):\n        \"\"\"\n        Centers this node on the inputed point.\n        \n        :param      point | <QPointF>\n        \"\"\"\n        rect = self.rect()\n        x = point.x() - rect.width() / 2.0\n        y = point.y() - rect.height() / 2.0\n        \n        self.setPos(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clearConnections( self, cls ):\n        count = 0\n        for connection in self.connections(cls):\n            connection.remove()\n            count += 1\n        return count", "response": "Clears all the connections for this node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connections( self, cls = None ):\n        scene = self.scene()\n        if ( not scene ):\n            return []\n        \n        if ( not cls ):\n            cls = XNodeConnection\n        \n        output = []\n        for item in scene.items():\n            if ( not isinstance(item, cls) ):\n                continue\n            \n            if ( item.inputNode() == self or item.outputNode() == self ):\n                output.append(item)\n        \n        return output", "response": "Returns a list of all connections that match the inputed\nalid class for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects the inputed dropzone to the given slot at the given rect.", "response": "def connectDropzone( self, \n                         rect, \n                         slot, \n                         color = None,\n                         style = None,\n                         name  = '',\n                         toolTip = '' ):\n        \"\"\"\n        Connects the inputed dropzone to the given slot at the defined rect.\n        \n        :param      rect    | <QRectF>\n                    slot    | <method> || <function>\n        \n        :return     <XNodeHotspot>\n        \"\"\"\n        if not color:\n            color = self.hotspotColor()\n        if not style:\n            style = self.hotspotStyle()\n        \n        hotspot = XNodeHotspot(rect, \n                               slot, \n                               name,\n                               toolTip)\n        \n        hotspot.setColor(color)\n        hotspot.setStyle(style)\n        self._dropzones.append(hotspot)\n        return hotspot"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connectHotspot( self, \n                        rect, \n                        slot, \n                        color = None, \n                        style = None, \n                        name = '',\n                        toolTip = '' ):\n        \"\"\"\n        Defines a new hotspot rect for the given hotspot type.\n        \n        :param      rect        | <QRectF>\n                    slot        | <method> || <function>\n                    color       | <QColor> || None\n                    style       | <XNode.HotspotStyle> || None\n                    toolTip     | <str>\n        \n        :return     <XNodeHotspot>\n        \"\"\"\n        if not color:\n            color = self.hotspotColor()\n        if not style:\n            style = self.hotspotStyle()\n        \n        hotspot = XNodeHotspot(rect, \n                               slot, \n                               name,\n                               toolTip)\n        \n        hotspot.setColor(color)\n        hotspot.setStyle(style)\n        \n        self._hotspots.append(hotspot)\n        return hotspot", "response": "Connect a new hotspot to a given slot."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a connection between this node and the inputed node.", "response": "def connectTo( self, node, cls = None ):\n        \"\"\"\n        Creates a connection between this node and the inputed node.\n        \n        :param      node | <XNode>\n                    cls  | <subclass of XNodeConnection> || None\n        \n        :return     <XNodeConnection>\n        \"\"\"\n        if ( not node ):\n            return\n        \n        con = self.scene().addConnection(cls)\n        con.setOutputNode(self)\n        con.setInputNode(node)\n        \n        return con"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef customData( self, key, default = None ):\n        return self._customData.get(nativestring(key), default)", "response": "Returns the custom data for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove all connections from the inputed node.", "response": "def disconnectFrom( self, node, cls = None ):\n        \"\"\"\n        Disconnects from the inputed node.  If there is a class provided, then\n        only a particular type of connection will be removed\n        \n        :param      node | <XNode>\n                    cls  | <subclass of XNodeConnection> || None\n        \n        :return     <int> | number of connections removed\n        \"\"\"\n        count = 0\n        for connection in self.connections(cls):\n            if ( connection.inputNode() == node or \\\n                 connection.outputNode() == node ):\n                connection.remove()\n        return count"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disabledAlternateColor(self):\n        palette = self.palette()\n        return palette.color(palette.Disabled, palette.NodeAlternateBackground)", "response": "Returns the alternate color for this node when it is disabled."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disabledBorderColor( self ):\n        palette = self.palette()\n        return palette.color(palette.Disabled, palette.NodeBorder)", "response": "Returns the disabled border color for this node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disabledBrush( self ):\n        # create the background brush\n        grad = QLinearGradient()\n        rect = self.rect()\n        \n        grad.setStart(QPointF(0, rect.y()))\n        grad.setFinalStop(QPointF(0, rect.bottom()))\n        \n        grad.setColorAt(0, self.disabledColor())\n        grad.setColorAt(1, self.disabledAlternateColor())\n            \n        return QBrush(grad)", "response": "Return the main brush for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the color this node should render when its disabled.", "response": "def disabledColor(self):\n        \"\"\"\n        Returns the color this node should render when its disabled.\n        \n        :return     <QColor>\n        \"\"\"\n        palette = self.palette()\n        return palette.color(palette.Disabled, palette.NodeBackground)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef disabledPenColor(self):\n        palette = self.palette()\n        return palette.color(palette.Disabled, palette.NodeForeground)", "response": "Returns the disabled pen color for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef displayName( self ):\n        if ( not self._displayName ):\n            return projex.text.pretty(self.objectName())\n        return self._displayName", "response": "Returns the user friendly name for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef draw(self, painter, option, rect):\n        painter.save()\n        \n        # draw the node\n        rect = self.rect()\n        \n        left, top, right, bottom = self.contentsMargins()\n        \n        x = rect.x() + left\n        y = rect.y() + top\n        w = rect.width() - (left + right)\n        h = rect.height() - (top + bottom)\n        r = self.roundingRadius()\n        \n        l_pinch, t_pinch, r_pinch, b_pinch = self.pinch()\n        \n        painter.setRenderHint(painter.Antialiasing)\n        painter.setRenderHint(painter.TextAntialiasing)\n        \n        # draw the border\n        painter.save()\n        if self.isEnabled():\n            pen = QPen(self.borderColor())\n        else:\n            pen = QPen(self.disabledBorderColor())\n        \n        pen.setWidthF(0.8)\n        painter.setRenderHint(painter.Antialiasing)\n        painter.setPen(pen)\n        \n        self.drawStyle(painter, x, y, w, h, r)\n        painter.restore()\n        \n        if self.style() == XNode.NodeStyle.Pixmap:\n            painter.restore()\n            return\n        \n        # draw the icon\n        icon = self.icon()\n        if icon and not icon.isNull():\n            pixmap = icon.pixmap(self.iconSize())\n            offset = (h - self.iconSize().height()) / 2\n            painter.drawPixmap(x + 4, offset, pixmap)\n            x += self.iconSize().width() + 4\n            w -= self.iconSize().width() + 4\n        \n        # draw the font\n        x += 6\n        w -= 12\n        metrics = QFontMetrics(self.titleFont())\n        if not self.wordWrap():\n            e_text  = metrics.elidedText(nativestring(self.displayName()), \n                                         Qt.ElideRight,\n                                         w)\n        else:\n            e_text = self.displayName()\n        \n        # draw the text\n        painter.setFont(self.titleFont())\n        painter.drawText(x, \n                         y, \n                         w, \n                         h, \n                         Qt.AlignCenter | Qt.TextWordWrap, \n                         e_text)\n        \n        painter.restore()", "response": "Draws the node for the graphics scene."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef drawHotspots(self, painter):\n        # draw hotspots\n        for hotspot in (self._hotspots + self._dropzones):\n            hstyle = hotspot.style()\n            if hstyle == XNode.HotspotStyle.Invisible:\n                continue\n            \n            hotspot.render(painter, self)", "response": "Draws all the hotspots for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing the style for the given coordinates for this node.", "response": "def drawStyle(self, painter, x, y, width, height, radius):\n        \"\"\"\n        Draws the style for the given coordinates for this node.\n        \n        :param      x      | <int>\n                    y      | <int>\n                    width  | <int>\n                    height | <int>\n                    radius | <int>\n        \"\"\"\n        if self.style() == XNode.NodeStyle.Rectangle:\n            # no pinch, draw regular\n            if sum(self.pinch()) == 0:\n                painter.drawRoundedRect(x, y, width, height, radius, radius)\n            \n            # create a path to draw\n            else:\n                tl, tr, bl, br = self.pinch()\n                path = QPainterPath()\n                path.moveTo(x + tl, y)\n                path.lineTo(x + width - tr, y)\n                path.lineTo(x + width, y + tr)\n                path.lineTo(x + width, y + height - br)\n                path.lineTo(x + width - br, y + height)\n                path.lineTo(x + bl, y + height)\n                path.lineTo(x, y + height - bl)\n                path.lineTo(x, y + tl)\n                path.lineTo(x + tl, y)\n                painter.drawPath(path)\n        \n        # draw the ellipse style\n        elif self.style() == XNode.NodeStyle.Ellipse:\n            painter.drawEllipse(x, y, width, height)\n        \n        # draw a pixmap style\n        elif self.style() == XNode.NodeStyle.Pixmap:\n            pmap = self.pixmap().scaled(width,\n                                        height,\n                                        Qt.KeepAspectRatio,\n                                        Qt.SmoothTransformation)\n            painter.drawPixmap(x, y, pmap)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dropzoneAt(self, point):\n        for dropzone in self._dropzones:\n            rect = dropzone.rect()\n            if ( rect.contains(point) ):\n                return dropzone\n        return None", "response": "Returns the dropzone at the inputed point."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emitGeometryChanged( self, point = None ):\n        # check the signals blocked\n        if ( self.signalsBlocked() ):\n            return False\n        \n        # grab the point\n        if ( point == None ):\n            point = self.pos()\n        \n        # emit the signal\n        self.dispatch.geometryChanged.emit(point)\n        return True", "response": "Emits the geometryChanged signal provided the dispatcher s signals are not currently blocked."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef emitRemoved( self ):\n        # check the signals blocked\n        if ( self.signalsBlocked() ):\n            return False\n        \n        # emit the signal\n        self.dispatch.removed.emit()\n        return True", "response": "Emits the removed signal"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the dropzone with the given name or None if no dropzone exists.", "response": "def findDropzone( self, name ):\n        \"\"\"\n        Finds the dropzone based on the inputed name.\n        \n        :param      name | <str>\n        \n        :return     <XNodeHotspot> || None\n        \"\"\"\n        for dropzone in self._dropzones:\n            if ( dropzone.name() == name ):\n                return dropzone\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the XNodeHotspot object for the given name.", "response": "def findHotspot( self, name ):\n        \"\"\"\n        Finds the hotspot based on the inputed name.\n        \n        :param      name | <str>\n        \n        :return     <XNodeHotspot> || None\n        \"\"\"\n        for hotspot in self._hotspots:\n            if ( hotspot.name() == name ):\n                return hotspot\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hotspotAt(self, point):\n        for hotspot in self._hotspots:\n            rect = hotspot.rect()\n            if rect.contains(point):\n                return hotspot\n        return None", "response": "Returns the XNodeHotspot at the inputed point."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hoverEnterEvent( self, event ):\n        # process the parent event\n        super(XNode, self).hoverEnterEvent(event)\n        \n        # hover over a hotspot\n        hotspot = self.hotspotAt(event.pos())\n        if not hotspot:\n            hotspot = self.dropzoneAt(event.pos())\n        \n        old_spot = self._hoverSpot\n        \n        if hotspot and hotspot != old_spot:\n            # update the new hotspot\n            self._hoverSpot = hotspot\n            \n            if old_spot:\n                old_spot.hoverLeaveEvent(event)\n            \n            if hotspot.hoverEnterEvent(event):\n                self.update()\n        \n        elif old_spot and not hotspot:\n            self._hoverSpot = None\n            \n            if old_spot.hoverLeaveEvent(event):\n                self.update()", "response": "Prompts the tool tip for this node based on the inputed event."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hoverMoveEvent(self, event):\n        # process the parent event\n        super(XNode, self).hoverMoveEvent(event)\n        \n        self._hovered = True\n        \n        # hover over a hotspot\n        hotspot = self.hotspotAt(event.pos())\n        if not hotspot:\n            hotspot = self.dropzoneAt(event.pos())\n        \n        old_spot = self._hoverSpot\n        \n        if hotspot and hotspot != old_spot:\n            # update the new hotspot\n            self._hoverSpot = hotspot\n            \n            if old_spot:\n                old_spot.hoverLeaveEvent(event)\n            \n            if hotspot.hoverEnterEvent(event):\n                self.update()\n        \n        elif old_spot and not hotspot:\n            self._hoverSpot = None\n            \n            if old_spot.hoverLeaveEvent(event):\n                self.update()\n\n        if hotspot and hotspot.toolTip():\n            super(XNode, self).setToolTip(hotspot.toolTip())\n        else:\n            super(XNode, self).setToolTip(self._toolTip)", "response": "Prompts the tool tip for this node based on the inputed event."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hoverLeaveEvent(self, event):\n        if self._hoverSpot:\n            if self._hoverSpot.hoverLeaveEvent(event):\n                self.update()\n        \n        self._hoverSpot = None\n        self._hovered = False\n        \n        super(XNode, self).setToolTip(self._toolTip)\n        super(XNode, self).hoverLeaveEvent(event)", "response": "Handles the hoverLeave event. Updates the node s tooltip and the hovered state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inputConnections(self, cls=None):\n        scene = self.scene()\n        if not scene:\n            return []\n        \n        if not cls:\n            cls = XNodeConnection\n        \n        output = []\n        for item in scene.items():\n            if not isinstance(item, cls):\n                continue\n            \n            if item.inputNode() == self:\n                output.append(item)\n        \n        return output", "response": "Returns a list of input connections from the scene that match the \n        inputed class for this node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isEnabled( self ):\n        if ( self._disableWithLayer and self._layer ):\n            lenabled = self._layer.isEnabled()\n        else:\n            lenabled = True\n            \n        return self._enabled and lenabled", "response": "Returns whether or not this node is enabled."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn if both the x and y directions are locked or if the node is enabled and the layer is not the current layer.", "response": "def isLocked( self ):\n        \"\"\"\n        Returns if both the x and y directions are locked, or if the scene \\\n        is in view mode.\n        \n        :return     <bool>\n        \"\"\"\n        # return if the layer is not the current layer\n        if self._layer and not self._layer.isCurrent():\n             return True\n        \n        # return whether or not the node is enabld or locked\n        return not self._enabled or (self._xLocked and self._yLocked)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isSnappedToGrid( self ):\n        shift = QtCore.QCoreApplication.keyboardModifiers() == QtCore.Qt.ShiftModifier\n        return (self._xSnapToGrid and self._ySnapToGrid) or shift", "response": "Returns if both the x and y directions are snapping to the grid."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns whether or not this item is visible.", "response": "def isVisible( self ):\n        \"\"\"\n        Returns whether or not this item is visible.\n        \n        :return     <bool>\n        \"\"\"\n        layer = self.layer()\n        if layer and not layer.isVisible():\n            return False\n        \n        return self._visible"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noverload the base QGraphicsItem itemChange method to handle snapping and locking of an object.", "response": "def itemChange(self, change, value):\n        \"\"\"\n        Overloads the base QGraphicsItem itemChange method to \\\n        handle snapping and locking of an object as the user \\\n        moves it around in the scene.\n        \n        :param      change      <int>\n        :param      value       <variant>\n        \n        :return     <variant>\n        \"\"\"\n        value = unwrapVariant(value)\n        \n        if change == self.ItemSelectedChange:\n            eff = self.graphicsEffect()\n            eff.setColor(self.highlightColor() if value else QColor(0, 0, 0 ,0))\n        \n        # only operate when it is a visible, geometric change\n        if not (self.isVisible() and change == self.ItemPositionChange):\n            return super(XNode, self).itemChange(change, value)\n            \n        scene = self.scene()\n        # only operate when we have a scene\n        if not scene:\n            return super(XNode, self).itemChange(change, value)\n            \n        point = unwrapVariant(value)\n        \n        # update the x position\n        if self.isXLocked():\n            point.setX( self.pos().x() )\n        elif self.isXSnappedToGrid():\n            offset_x = self.rect().width() / 2.0\n            center_x = point.x() + offset_x\n            center_x -= center_x % scene.cellWidth()\n            \n            point.setX(center_x - offset_x)\n            \n        # update the y position\n        if self.isYLocked():\n            point.setY( self.pos().y() )\n        elif self.isYSnappedToGrid():\n            offset_y = self.rect().height() / 2.0\n            center_y = point.y() + offset_y\n            center_y -= center_y % scene.cellHeight()\n            \n            point.setY(center_y - offset_y)\n            \n        # create the return value\n        new_value = wrapVariant(point)\n        \n        # call the base method to operate on the new point\n        result = super(XNode, self).itemChange(change, new_value)\n        \n        # emit the geometry changed signal\n        self.emitGeometryChanged(point)\n        \n        # return the result\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mousePressEvent( self, event ):\n        event.setAccepted(False)\n        self._hotspotPressed = False\n        # ignore events when the scene is in view mode\n        scene = self.scene()\n        if self.isLocked() or (scene and scene.inViewMode()):\n            event.ignore()\n            self._ignoreMouseEvents = True\n            return\n        \n        self._ignoreMouseEvents = False\n        \n        # block the selection signals\n        if scene:\n            scene.blockSelectionSignals(True)\n            \n            # clear the selection\n            if ( not (self.isSelected() or \n                      event.modifiers() == Qt.ControlModifier) ):\n                for item in scene.selectedItems():\n                    if ( item != self ):\n                        item.setSelected(False)\n        \n        # determine if we need to start any connections\n        hotspot = self.hotspotAt(event.pos())\n        if hotspot and hotspot.isEnabled():\n            hotspot.slot()(event)\n        \n            # check if the event is accepted\n            if ( event.isAccepted() ):\n                self._hotspotPressed = True\n                return\n        \n        # try to start the connection\n        event.accept()\n        self._pressTime = datetime.datetime.now()\n        super(XNode, self).mousePressEvent(event)", "response": "Handles the mouse press event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverloading the mouse move event to ignore the event when the scene is in view mode.", "response": "def mouseMoveEvent( self, event ):\n        \"\"\"\n        Overloads the mouse move event to ignore the event when \\\n        the scene is in view mode.\n        \n        :param      event   <QMouseMoveEvent>\n        \"\"\"\n        event.setAccepted(False)\n        if self._hotspotPressed:\n            event.accept()\n            return\n        \n        # ignore events when the scene is in view mode\n        scene = self.scene()\n        if ( self.isLocked() or self._ignoreMouseEvents or \\\n             (scene and (scene.inViewMode() or scene.isConnecting()))):\n            event.ignore()\n            self._ignoreMouseEvents = True\n            return\n        \n        # call the base method\n        event.accept()\n        super(XNode, self).mouseMoveEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mouseReleaseEvent( self, event ):\n        event.setAccepted(False)\n        if self._hotspotPressed:\n            event.accept()\n            self._hotspotPressed = False\n            return\n        \n        # ignore events when the scene is in view mode\n        scene = self.scene()\n        if ( self.isLocked() or self._ignoreMouseEvents or \\\n             (scene and (scene.inViewMode() or scene.isConnecting()))):\n            event.ignore()\n            self._ignoreMouseEvents = False\n            return\n        \n        super(XNode, self).mouseReleaseEvent(event)\n        \n        # emit the geometry changed signal\n        self.emitGeometryChanged()\n        \n        # unblock the selection signals\n        if ( scene ):\n            scene.blockSelectionSignals(False)\n            \n            delta = datetime.datetime.now() - self._pressTime\n            if not scene.signalsBlocked() and delta.seconds < 1:\n                scene.nodeClicked.emit(self)", "response": "Override mouseReleaseEvent to ignore the event when the scene is in view mode and release the selection block signal."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef opacity( self ):\n        if self.isIsolateHidden():\n            return 0.1\n        \n        opacity = super(XNode, self).opacity()\n        layer = self.layer()\n        if layer:\n            return layer.opacity() * opacity\n        \n        return opacity", "response": "Returns the opacity value for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of output connections from the scene that match the inputed class for this node.", "response": "def outputConnections(self, cls=None):\n        \"\"\"\n        Returns a list of output connections from the scene that match the \n        inputed class for this node.\n        \n        :param      cls | <subclass of XNodeConnection> || None\n        \n        :return     [<XNodeConnection>, ..]\n        \"\"\"\n        scene = self.scene()\n        if not scene:\n            return []\n        \n        if not cls:\n            cls = XNodeConnection\n        \n        output = []\n        for item in scene.items():\n            if not isinstance(item, cls):\n                continue\n            \n            if item.outputNode() == self:\n                output.append(item)\n        \n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\noverloading the default paint event to update the node when necessary and call the draw method for the node.", "response": "def paint(self, painter, option, widget):\n        \"\"\"\n        Overloads the default QGraphicsItem paint event to update the \\\n        node when necessary and call the draw method for the node.\n        \n        :param      painter     <QPainter>\n        :param      option      <QStyleOptionGraphicsItem>\n        :param      widget      <QWidget>\n        \"\"\"\n        # rebuild when dirty\n        if self.isDirty():\n            self.rebuild()\n        \n        painter.save()\n        painter.setOpacity( self.opacity() )\n        \n        if self.drawHotspotsUnderneath():\n            self.drawHotspots(painter)\n        \n        if self.isEnabled():\n            painter.setPen(self.penColor())\n            painter.setBrush(self.brush())\n        else:\n            painter.setPen(self.disabledPenColor())\n            painter.setBrush(self.disabledBrush())\n        \n        # draw the item\n        self.draw(painter, option, widget)\n        \n        if not self.drawHotspotsUnderneath():\n            self.drawHotspots(painter)\n        \n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the position at the inputed location.", "response": "def positionAt( self, location, fixedX = None, fixedY = None ):\n        \"\"\"\n        Calculates the position at the inputed location.\n        \n        :param      location        <XConnectionLocation>\n        :param      fixedX          <float> || None\n        :param      fixedY          <float> || None\n            \n        :return     <QPointF>\n        \"\"\"\n        # figure the position information\n        rect    = self.sceneRect()\n        \n        if rect.height() < self.minimumHeight():\n            rect.setHeight(self.minimumHeight())\n        \n        if rect.width() < self.minimumWidth():\n            rect.setWidth(self.minimumWidth())\n        \n        cx      = rect.center().x()\n        cy      = rect.center().y()\n        x       = cx\n        y       = cy\n            \n        if ( location == XConnectionLocation.Left ):\n            x = rect.left()\n        \n        # define a right-based x\n        elif ( location & XConnectionLocation.Right ):\n            x = rect.right()\n        \n        # define a top-based y\n        elif ( location & XConnectionLocation.Top ):\n            y = rect.top()\n        \n        # define a bottom-based y\n        elif location & XConnectionLocation.Bottom:\n            y = rect.bottom()\n        \n        # use the fixed locations if provided\n        if fixedX != None:\n            x = rect.x() + fixedX\n        if fixedY != None:\n            y = rect.y() + fixedY\n        \n        return QPointF(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrebuild the geometry and data for a node.", "response": "def rebuild(self, scene=None):\n        \"\"\"\n        This method is where you will rebuild the geometry and \\\n        data for a node.\n        \n        :param      scene       <QGraphicsScene> || None\n        \n        :return     <bool> success\n        \"\"\"\n        rect = QRectF(0, 0, self.minimumWidth(), self.minimumHeight())\n        self.setRect(rect)\n        self._dirty = False\n        self.adjustTitleFont()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the scene position for this node by resolving any inhertiance position data.", "response": "def scenePos( self ):\n        \"\"\"\n        Returns the scene position for this node by resolving any \\\n        inhertiance position data since QGraphicsItem's return \\\n        relative-space positions.\n        \n        :return     <QPointF>\n        \"\"\"\n        pos     = self.pos()\n        pitem   = self.parentItem()\n        \n        while (pitem):\n            pos     = pitem.pos() + pos\n            pitem   = pitem.parentItem()\n        \n        return pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the scene geometry for this node by resolving any inheritance position data since QGraphicsItem s return - value is not a QRectF", "response": "def sceneRect( self ):\n        \"\"\"\n        Returns the scene geometry for this node by resolving any \\\n        inheritance position data since QGraphicsItem's return \\\n        relative-space positions.\n        \n        :return     <QRectF>\n        \"\"\"\n        pos     = self.scenePos()\n        rect    = self.rect()\n        return QRectF(pos.x(), pos.y(), rect.width(), rect.height())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setAlternateColor(self, color):\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.NodeAlternateBackground, color)\n        self.setDirty()", "response": "Sets the alternate color for this node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setBaseColor(self, color):\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.NodeBackground, color)\n        self._palette.setColor(self._palette.NodeAlternateBackground,\n                               color.darker(105))\n        self._palette.setColor(self._palette.NodeBorder,\n                               color.darker(125))\n        \n        self.setDirty()", "response": "Sets the primary color for this node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the border color for this node to the inputed color.", "response": "def setBorderColor(self, color):\n        \"\"\"\n        Sets the border color for this node to the inputed color.\n        \n        :param      color | <QColor>\n        \"\"\"\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.NodeBorder, color)\n        self.setDirty()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setContentsMargins(self, left, top, right, bottom):\n        self._margins   = (left, top, right, bottom)\n        self.adjustTitleFont()", "response": "Sets the margins for this node to the inputed values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the alternate color used when drawing this node as disabled.", "response": "def setDisabledAlternateColor(self, color):\n        \"\"\"\n        Sets the alternate color used when drawing this node as disabled.\n        \n        :param      color | <QColor>\n        \"\"\"\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.Disabled,\n                               self._palette.NodeAlternateBackground,\n                               color)\n        self.setDirty()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the disabled border color for this node.", "response": "def setDisabledBorderColor( self ):\n        \"\"\"\n        Returns the base color for this node.\n        \n        :return     <QColor>\n        \"\"\"\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.Disabled,\n                               self._palette.NodeBorder,\n                               color)\n        self.setDirty()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setDisabledColor(self, color):\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.Disabled,\n                               self._palette.NodeBackground,\n                               color)\n        self._palette.setColor(self._palette.Disabled,\n                               self._palette.NodeAlternateBackground,\n                               color.darker(105))\n        self.setDirty()", "response": "Sets the disabled color used when drawing this node as disabled."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setDisabledPenColor(self, color):\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.Disabled,\n                               self._palette.NodeForeground,\n                               color)\n        self.setDirty()", "response": "Sets the pen color to be used when drawing this node as disabled."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setHighlightColor(self, color):\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.NodeHighlight, color)\n        self.setDirty()", "response": "Sets the color to be used when highlighting a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the hotspot color for this node.", "response": "def setHotspotColor(self, color):\n        \"\"\"\n        Sets the hotspot color for this node to the inputed color.\n        \n        :param      color | <QColor>\n        \"\"\"\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.NodeHotspot, color)\n        self.setDirty()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setIcon(self, icon):\n        if icon:\n            self._icon = QIcon(icon)\n        else:\n            self._icon = None", "response": "Sets the icon for this item to the inputed icon."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset whether or not this item is hidden due to isolation.", "response": "def setIsolateHidden(self, state):\n        \"\"\"\n        Sets whether or not this item is hidden due to isolation.\n        \n        :param      state | <bool>\n        \"\"\"\n        self._isolatedHidden = state\n        \n        super(XNode, self).setVisible(self.isVisible())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the locked state of the node.", "response": "def setLocked( self, state = True ):\n        \"\"\"\n        Locks the node in both the x and y directions.\n        \n        :param      state   <bool>\n        \"\"\"\n        self._xLocked = state\n        self._yLocked = state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setObjectName( self, name ):\n        scene = self.scene()\n        if scene:\n            name = scene.uniqueNodeName(name)\n        \n        self._objectName = name\n        self.adjustTitleFont()\n        self.update()", "response": "Sets the unique object name for this node"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the palette for this node to the inputed palette.", "response": "def setPalette(self, palette):\n        \"\"\"\n        Sets the palette for this node to the inputed palette.  If None is\n        provided, then the scene's palette will be used for this node.\n        \n        :param      palette | <XNodePalette> || None\n        \"\"\"\n        self._palette = XNodePalette(palette) if palette is not None else None\n        self.setDirty()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setPenColor(self, color):\n        color = QColor(color)\n        if self._palette is None:\n            self._palette = XNodePalette(self._scenePalette)\n        \n        self._palette.setColor(self._palette.NodeForeground, color)\n        self.setDirty()", "response": "Sets the pen color for this node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setPinch(self,\n                 topLeft=None,\n                 topRight=None,\n                 bottomLeft=None,\n                 bottomRight=None):\n        \"\"\"\n        Sets the pinch amounts for this node.  This\n        will pinch in the borders based on the inputed information generating\n        a variety of edged shapes.  If the keyword is not specified, then it\n        will use the already existing pinch value for that section.\n        \n        :param      left   | <int> || None\n                    top    | <int> || None\n                    right  | <int> || None\n                    bottom | <int> || None\n        \"\"\"\n        pinch = list(self._pinch)\n        if topLeft is not None:\n            pinch[0] = topLeft\n        if topRight is not None:\n            pinch[1] = topRight\n        if bottomLeft is not None:\n            pinch[2] = bottomLeft\n        if bottomRight is not None:\n            pinch[3] = bottomRight\n        \n        self._pinch = tuple(pinch)", "response": "Sets the amount of pinch in the section of this node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the pixmap associated with this node.", "response": "def setPixmap(self, pixmap):\n        \"\"\"\n        Sets the pixmap associated with this node.\n        \n        :param     pixmap | <str> || <QtGui.QPixmap> || None\n        \"\"\"\n        if pixmap is not None:\n            self._style = XNode.NodeStyle.Pixmap\n            self._pixmap = QPixmap(pixmap)\n        else:\n            self._style = XNode.NodeStyle.Rectangle\n            self._pixmap = pixmap\n        \n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setRect( self, rect ):\n        mwidth  = self.minimumWidth()\n        mheight = self.minimumHeight()\n        \n        if ( rect.width() < mwidth ):\n            rect.setWidth(mwidth)\n        if ( rect.height() < mheight ):\n            rect.setHeight(mheight)\n        \n        return super(XNode, self).setRect(rect)", "response": "Sets the rect for this node ensuring that the width and height meet the minimum requirements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the snap to grid property for both the x and y directions", "response": "def setSnapToGrid( self, state = True ):\n        \"\"\"\n        Sets the snap to grid property for both the x and y directions \\\n        based on the inputed value.\n        \n        :param      state   <bool>\n        \"\"\"\n        self._xSnapToGrid = state\n        self._ySnapToGrid = state"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setVisible( self, state ):\n        self._visible = state\n        \n        super(XNode, self).setVisible(self.isVisible())\n        \n        self.dispatch.visibilityChanged.emit(state)\n        self.setDirty()", "response": "Sets whether or not this node is visible in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the internal state of the item based on the given layer data.", "response": "def syncLayerData(self, layerData=None):\n        \"\"\"\n        Syncs the layer information for this item from the given layer data.\n        \n        :param      layerData | <dict> || None\n        \"\"\"\n        if not self._layer:\n            return\n            \n        if not layerData:\n            layerData = self._layer.layerData()\n        \n        self.setVisible(layerData.get('visible', True))\n        \n        if layerData.get('current'):\n            # set the default parameters\n            flags  = self.ItemIsMovable \n            flags |= self.ItemIsSelectable \n            flags |= self.ItemIsFocusable\n            \n            # need this flag for Qt 4.6+\n            try:\n                flags |= self.ItemSendsGeometryChanges\n            except AttributeError:\n                pass\n            \n            self.setFlags(flags)\n            self.setAcceptHoverEvents(True)\n            self.setZValue(100)\n            \n        else:\n            # set the default parameters\n            self.setFlags(self.ItemIsFocusable)\n            self.setAcceptHoverEvents(True)\n            self.setZValue(layerData.get('zValue', 0))\n        \n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef triggerDropzoneAt( self, point, connection ):\n        dropzone = self.dropzoneAt(point)\n        if dropzone:\n            dropzone.slot()(connection)", "response": "Triggers the connected dropzone slot at the inputed point."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nliking dict. iteritems but returns an iterator.", "response": "def iteritems(self, multi=False):\n        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n        for key, values in dict.iteritems(self):\n            if multi:\n                for value in values:\n                    yield key, value\n            else:\n                yield key, values[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iterlists(self):\n        for key, values in dict.iteritems(self):\n            yield key, list(values)", "response": "Like dict. iterlists but returns an iterator."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the contents as regular dict.", "response": "def to_dict(self, flat=True):\n        \"\"\"Return the contents as regular dict.  If `flat` is `True` the\n        returned dict will only have the first item present, if `flat` is\n        `False` all values will be returned as lists.\n\n        :param flat: If set to `False` the dict returned will have lists\n                     with all the values in it.  Otherwise it will only\n                     contain the first value for each key.\n        :return: a :class:`dict`\n        \"\"\"\n        if flat:\n            return dict(self.iteritems())\n        return dict(self.lists())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating method extends rather than replaces existing key lists.", "response": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npops the first item for a list on the dict.", "response": "def pop(self, key, default=_missing):\n        \"\"\"Pop the first item for a list on the dict.  Afterwards the\n        key is removed from the dict, so additional values are discarded:\n\n        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n        >>> d.pop(\"foo\")\n        1\n        >>> \"foo\" in d\n        False\n\n        :param key: the key to pop.\n        :param default: if provided the value to return if the key was\n                        not in the dictionary.\n        \"\"\"\n        try:\n            return dict.pop(self, key)[0]\n        except KeyError, e:\n            if default is not _missing:\n                return default\n            raise BadRequestKeyError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npops an item from the dict.", "response": "def popitem(self):\n        \"\"\"Pop an item from the dict.\"\"\"\n        try:\n            item = dict.popitem(self)\n            return (item[0], item[1][0])\n        except KeyError, e:\n            raise BadRequestKeyError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef popitemlist(self):\n        try:\n            return dict.popitem(self)\n        except KeyError, e:\n            raise BadRequestKeyError(str(e))", "response": "Pop a ( key list ) tuple from the dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hoverEnterEvent(self, event):\r\n        self._hovered = True\r\n        if self.toolTip():\r\n            QToolTip.showText(QCursor.pos(), self.toolTip())\r\n            return True\r\n        \r\n        return self.style() == XNodeHotspot.Style.Icon", "response": "Processes when this hotspot is entered.\r\n        \r\n        :param      event | <QHoverEvent>\r\n        \r\n        :return     <bool> | processed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hoverLeaveEvent(self, event):\r\n        self._hovered = False\r\n        if self.toolTip():\r\n            QToolTip.hideText()\r\n        \r\n        return self.style() == XNodeHotspot.Style.Icon", "response": "Handles the hoverLeave event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self, painter, node=None):\r\n        policy = self.visibilityPolicy()\r\n        \r\n        if policy == XNodeHotspot.VisibilityPolicy.Never:\r\n            return\r\n        elif policy == XNodeHotspot.VisibilityPolicy.Hover and \\\r\n            not self._hovered:\r\n            return\r\n        elif policy == XNodeHotspot.VisibilityPolicy.NodeHover and \\\r\n            not (node and node.isHovered()):\r\n            return\r\n        \r\n        # initialize the look\r\n        painter.setPen(self.borderColor())\r\n        painter.setBrush(self.color())\r\n        \r\n        # draw a circle\r\n        if self.style() == XNodeHotspot.Style.Circle:\r\n            painter.drawEllipse(self.rect())\r\n        \r\n        # draw a square\r\n        elif self.style() == XNodeHotspot.Style.Square:\r\n            painter.drawRect(self.rect())\r\n        \r\n        # draw an icon\r\n        elif self.style() == XNodeHotspot.Style.Icon:\r\n            rect = self.rect()\r\n            x = int(rect.x())\r\n            y = int(rect.y())\r\n            w = int(rect.size().width())\r\n            h = int(rect.size().height())\r\n            \r\n            icon = self.icon()\r\n            hicon = self.hoverIcon()\r\n            \r\n            if not self.isEnabled():\r\n                pixmap = icon.pixmap(w, h, QIcon.Disabled)\r\n            elif not self._hovered:\r\n                pixmap = icon.pixmap(w, h)\r\n            elif hicon:\r\n                pixmap = hicon.pixmap(w, h)\r\n            else:\r\n                pixmap = icon.pixmap(w, h, QIcon.Selected)\r\n            \r\n            painter.drawPixmap(x, y, pixmap)", "response": "Renders the node based on its style information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setHoverIcon(self, icon):\r\n        icon = QIcon(icon)\r\n        if not icon.isNull():\r\n            self._hoverIcon = QIcon(icon)\r\n        else:\r\n            self._hoverIcon = None", "response": "Sets the icon that will be used when this hotspot is hovered."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setIcon(self, icon):\r\n        icon = QIcon(icon)\r\n        if icon.isNull():\r\n            self._icon = None\r\n            self._style = XNodeHotspot.Style.Invisible\r\n        else:\r\n            self._icon = icon\r\n            self._style = XNodeHotspot.Style.Icon", "response": "Sets the icon for this hotspot."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the given record to the system.", "response": "def addRecord(self, record):\r\n        \"\"\"\r\n        Adds the given record to the system.\r\n        \r\n        :param      record | <str>\r\n        \"\"\"\r\n        label_mapper    = self.labelMapper()\r\n        icon_mapper     = self.iconMapper()\r\n        \r\n        self.addItem(label_mapper(record))\r\n        self.setItemData(self.count() - 1, wrapVariant(record), Qt.UserRole)\r\n        \r\n        # load icon\r\n        if icon_mapper:\r\n            self.setItemIcon(self.count() - 1, icon_mapper(record))\r\n        \r\n        if self.showTreePopup():\r\n            XOrbRecordItem(self.treePopupWidget(), record)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addRecords(self, records):\r\n        label_mapper    = self.labelMapper()\r\n        icon_mapper     = self.iconMapper()\r\n        \r\n        # create the items to display\r\n        tree = None\r\n        if self.showTreePopup():\r\n            tree = self.treePopupWidget()\r\n            tree.blockSignals(True)\r\n            tree.setUpdatesEnabled(False)\r\n        \r\n        # add the items to the list\r\n        start = self.count()\r\n        self.addItems(map(label_mapper, records))\r\n        \r\n        # update the item information\r\n        for i, record in enumerate(records):\r\n            index = start + i\r\n            \r\n            self.setItemData(index, wrapVariant(record), Qt.UserRole)\r\n            \r\n            if icon_mapper:\r\n                self.setItemIcon(index, icon_mapper(record))\r\n            \r\n            if tree:\r\n                XOrbRecordItem(tree, record)\r\n        \r\n        if tree:\r\n            tree.blockSignals(False)\r\n            tree.setUpdatesEnabled(True)", "response": "Adds the given record to the system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addRecordsFromThread(self, records):\r\n        label_mapper    = self.labelMapper()\r\n        icon_mapper     = self.iconMapper()\r\n        \r\n        tree = None\r\n        if self.showTreePopup():\r\n            tree = self.treePopupWidget()\r\n        \r\n        # add the items to the list\r\n        start = self.count()\r\n        \r\n        # update the item information\r\n        blocked = self.signalsBlocked()\r\n        self.blockSignals(True)\r\n        for i, record in enumerate(records):\r\n            index = start + i\r\n            self.addItem(label_mapper(record))\r\n            self.setItemData(index, wrapVariant(record), Qt.UserRole)\r\n            \r\n            if icon_mapper:\r\n                self.setItemIcon(index, icon_mapper(record))\r\n            \r\n            if record == self._currentRecord:\r\n                self.setCurrentIndex(self.count() - 1)\r\n            \r\n            if tree:\r\n                XOrbRecordItem(tree, record)\r\n        self.blockSignals(blocked)", "response": "Adds the given records to the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef acceptRecord(self, item):\r\n        record = item.record()\r\n        self.treePopupWidget().close()\r\n        self.setCurrentRecord(record)", "response": "Sets the current record for the given item. Closes the tree popup and sets the current record."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassigns the current record from the inputed text.", "response": "def assignCurrentRecord(self, text):\r\n        \"\"\"\r\n        Assigns the current record from the inputed text.\r\n        \r\n        :param      text | <str>\r\n        \"\"\"\r\n        if self.showTreePopup():\r\n            item = self._treePopupWidget.currentItem()\r\n            if item:\r\n                self._currentRecord = item.record()\r\n            else:\r\n                self._currentRecord = None\r\n            return\r\n        \r\n        # look up the record for the given text\r\n        if text:\r\n            index = self.findText(text)\r\n        elif self.isRequired():\r\n            index = 0\r\n        else:\r\n            index = -1\r\n        \r\n        # determine new record to look for\r\n        record = self.recordAt(index)\r\n        if record == self._currentRecord:\r\n            return\r\n        \r\n        # set the current index and record for any changes\r\n        self._currentRecord = record\r\n        self.setCurrentIndex(index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the record that is currently in the combo box.", "response": "def currentRecord( self ):\r\n        \"\"\"\r\n        Returns the record found at the current index for this combo box.\r\n        \r\n        :rerturn        <orb.Table> || None\r\n        \"\"\"\r\n        if self._currentRecord is None and self.isRequired():\r\n            self._currentRecord = self.recordAt(self.currentIndex())\r\n        return self._currentRecord"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the new tree entry ID for the given event.", "response": "def dragEnterEvent(self, event):\r\n        \"\"\"\r\n        Listens for query's being dragged and dropped onto this tree.\r\n        \r\n        :param      event | <QDragEnterEvent>\r\n        \"\"\"\r\n        data = event.mimeData()\r\n        if data.hasFormat('application/x-orb-table') and \\\r\n           data.hasFormat('application/x-orb-query'):\r\n            tableName = self.tableTypeName()\r\n            if nstr(data.data('application/x-orb-table')) == tableName:\r\n                event.acceptProposedAction()\r\n                return\r\n        elif data.hasFormat('application/x-orb-records'):\r\n            event.acceptProposedAction()\r\n            return\r\n        \r\n        super(XOrbRecordBox, self).dragEnterEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noverride this method to handle the drop event.", "response": "def dropEvent(self, event):\r\n        \"\"\"\r\n        Listens for query's being dragged and dropped onto this tree.\r\n        \r\n        :param      event | <QDropEvent>\r\n        \"\"\"\r\n        # overload the current filtering options\r\n        data = event.mimeData()\r\n        if data.hasFormat('application/x-orb-table') and \\\r\n           data.hasFormat('application/x-orb-query'):\r\n            tableName = self.tableTypeName()\r\n            if nstr(data.data('application/x-orb-table')) == tableName:\r\n                data = nstr(data.data('application/x-orb-query'))\r\n                query = Q.fromXmlString(data)\r\n                self.setQuery(query)\r\n                return\r\n        \r\n        elif self.tableType() and data.hasFormat('application/x-orb-records'):\r\n            from projexui.widgets.xorbtreewidget import XOrbTreeWidget\r\n            records = XOrbTreeWidget.dataRestoreRecords(data)\r\n            \r\n            for record in records:\r\n                if isinstance(record, self.tableType()):\r\n                    self.setCurrentRecord(record)\r\n                    return\r\n        \r\n        super(XOrbRecordBox, self).dropEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nemit the current record changed signal for this combobox.", "response": "def emitCurrentRecordChanged(self):\r\n        \"\"\"\r\n        Emits the current record changed signal for this combobox, provided \\\r\n        the signals aren't blocked.\r\n        \"\"\"\r\n        record = unwrapVariant(self.itemData(self.currentIndex(), Qt.UserRole))\r\n        if not Table.recordcheck(record):\r\n            record = None\r\n        \r\n        self._currentRecord = record\r\n        if not self.signalsBlocked():\r\n            self._changedRecord = record\r\n            self.currentRecordChanged.emit(record)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nemitting the current record edited signal for this combobox.", "response": "def emitCurrentRecordEdited(self):\r\n        \"\"\"\r\n        Emits the current record edited signal for this combobox, provided the\r\n        signals aren't blocked and the record has changed since the last time.\r\n        \"\"\"\r\n        if self._changedRecord == -1:\r\n            return\r\n        \r\n        if self.signalsBlocked():\r\n            return\r\n        \r\n        record = self._changedRecord\r\n        self._changedRecord = -1\r\n        self.currentRecordEdited.emit(record)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfilter the event for the popup tree widget.", "response": "def eventFilter(self, object, event):\r\n        \"\"\"\r\n        Filters events for the popup tree widget.\r\n        \r\n        :param      object | <QObject>\r\n                    event  | <QEvent>\r\n        \r\n        :retuen     <bool> | consumed\r\n        \"\"\"\r\n        edit = self.lineEdit()\r\n        \r\n        if not (object and object == self._treePopupWidget):\r\n            return super(XOrbRecordBox, self).eventFilter(object, event)\r\n        \r\n        elif event.type() == event.Show:\r\n            object.resizeToContents()\r\n            object.horizontalScrollBar().setValue(0)\r\n        \r\n        elif edit and event.type() == event.KeyPress:\r\n            # accept lookup\r\n            if event.key() in (Qt.Key_Enter,\r\n                               Qt.Key_Return,\r\n                               Qt.Key_Tab,\r\n                               Qt.Key_Backtab):\r\n                \r\n                item = object.currentItem()\r\n                text = edit.text()\r\n                \r\n                if not text:\r\n                    record = None\r\n                    item = None\r\n                \r\n                elif isinstance(item, XOrbRecordItem):\r\n                    record = item.record()\r\n                \r\n                if record and item.isSelected() and not item.isHidden():\r\n                    self.hidePopup()\r\n                    self.setCurrentRecord(record)\r\n                    event.accept()\r\n                    return True\r\n                \r\n                else:\r\n                    self.setCurrentRecord(None)\r\n                    self.hidePopup()\r\n                    edit.setText(text)\r\n                    edit.keyPressEvent(event)\r\n                    event.accept()\r\n                    return True\r\n                \r\n            # cancel lookup\r\n            elif event.key() == Qt.Key_Escape:\r\n                text = edit.text()\r\n                self.setCurrentRecord(None)\r\n                edit.setText(text)\r\n                self.hidePopup()\r\n                event.accept()\r\n                return True\r\n            \r\n            # update the search info\r\n            else:\r\n                edit.keyPressEvent(event)\r\n        \r\n        elif edit and event.type() == event.KeyRelease:\r\n            edit.keyReleaseEvent(event)\r\n        \r\n        elif edit and event.type() == event.MouseButtonPress:\r\n            local_pos = object.mapFromGlobal(event.globalPos())\r\n            in_widget = object.rect().contains(local_pos)\r\n            \r\n            if not in_widget:\r\n                text = edit.text()\r\n                self.setCurrentRecord(None)\r\n                edit.setText(text)\r\n                self.hidePopup()\r\n                event.accept()\r\n                return True\r\n            \r\n        return super(XOrbRecordBox, self).eventFilter(object, event)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef focusInEvent(self, event):\r\n        self._changedRecord = -1\r\n        super(XOrbRecordBox, self).focusInEvent(event)", "response": "Called by the event handler when the record is changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hidePopup(self):\r\n        if self._treePopupWidget and self.showTreePopup():\r\n            self._treePopupWidget.close()\r\n        \r\n        super(XOrbRecordBox, self).hidePopup()", "response": "Overloads the hidePopup method to handle when the user hides the popup widget."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef markLoadingStarted(self):\r\n        if self.isThreadEnabled():\r\n            XLoaderWidget.start(self)\r\n        \r\n        if self.showTreePopup():\r\n            tree = self.treePopupWidget()\r\n            tree.setCursor(Qt.WaitCursor)\r\n            tree.clear()\r\n            tree.setUpdatesEnabled(False)\r\n            tree.blockSignals(True)\r\n            \r\n            self._baseHints = (self.hint(), tree.hint())\r\n            tree.setHint('Loading records...')\r\n            self.setHint('Loading records...')\r\n        else:\r\n            self._baseHints = (self.hint(), '')\r\n            self.setHint('Loading records...')\r\n        \r\n        self.setCursor(Qt.WaitCursor)\r\n        self.blockSignals(True)\r\n        self.setUpdatesEnabled(False)\r\n        \r\n        # prepare to load\r\n        self.clear()\r\n        use_dummy = not self.isRequired() or self.isCheckable()\r\n        if use_dummy:\r\n            self.addItem('')\r\n        \r\n        self.loadingStarted.emit()", "response": "Marks this widget as loading records."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmarking this widget as finished loading records.", "response": "def markLoadingFinished(self):\r\n        \"\"\"\r\n        Marks this widget as finished loading records.\r\n        \"\"\"\r\n        XLoaderWidget.stop(self, force=True)\r\n        \r\n        hint, tree_hint = self._baseHints\r\n        self.setHint(hint)\r\n        \r\n        # set the tree widget\r\n        if self.showTreePopup():\r\n            tree = self.treePopupWidget()\r\n            tree.setHint(tree_hint)\r\n            tree.unsetCursor()\r\n            tree.setUpdatesEnabled(True)\r\n            tree.blockSignals(False)\r\n        \r\n        self.unsetCursor()\r\n        self.blockSignals(False)\r\n        self.setUpdatesEnabled(True)\r\n        self.loadingFinished.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef records( self ):\r\n        records = []\r\n        for i in range(self.count()):\r\n            record = self.recordAt(i)\r\n            if record:\r\n                records.append(record)\r\n        return records", "response": "Returns the list of records linked with this combo box."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrefreshes the current user interface with the latest settings.", "response": "def refresh(self, records):\r\n        \"\"\"\r\n        Refreshs the current user interface to match the latest settings.\r\n        \"\"\"\n        self._loaded = True\r\n        \r\n        if self.isLoading():\r\n            return\r\n        \r\n        # load the information\r\n        if RecordSet.typecheck(records):\r\n            table = records.table()\r\n            self.setTableType(table)\r\n            \r\n            if self.order():\r\n                records.setOrder(self.order())\r\n            \r\n            # load specific data for this record box\r\n            if self.specifiedColumnsOnly():\r\n                records.setColumns(map(lambda x: x.name(),\r\n                                       self.specifiedColumns()))\r\n            \r\n            # load the records asynchronously\r\n            if self.isThreadEnabled() and table:\r\n                try:\r\n                    thread_enabled = table.getDatabase().isThreadEnabled()\r\n                except AttributeError:\r\n                    thread_enabled = False\r\n                \r\n                if thread_enabled:\r\n                    # ensure we have a worker thread running\r\n                    self.worker()\r\n                    \r\n                    # assign ordering based on tree table\r\n                    if self.showTreePopup():\r\n                        tree = self.treePopupWidget()\r\n                        if tree.isSortingEnabled():\r\n                            col = tree.sortColumn()\r\n                            colname = tree.headerItem().text(col)\r\n                            column = table.schema().column(colname)\r\n                            \r\n                            if column:\r\n                                if tree.sortOrder() == Qt.AscendingOrder:\r\n                                    sort_order = 'asc'\r\n                                else:\r\n                                    sort_order = 'desc'\r\n                                \r\n                                records.setOrder([(column.name(), sort_order)])\r\n                    \r\n                    self.loadRequested.emit(records)\r\n                    return\r\n        \r\n        # load the records synchronously\r\n        self.loadingStarted.emit()\r\n        curr_record = self.currentRecord()\r\n        self.blockSignals(True)\r\n        self.setUpdatesEnabled(False)\r\n        self.clear()\r\n        use_dummy = not self.isRequired() or self.isCheckable()\r\n        if use_dummy:\r\n            self.addItem('')\r\n        self.addRecords(records)\r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)\r\n        self.setCurrentRecord(curr_record)\r\n        self.loadingFinished.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setBatchSize(self, size):\r\n        self._batchSize = size\r\n        try:\r\n            self._worker.setBatchSize(size)\r\n        except AttributeError:\r\n            pass", "response": "Sets the batch size of records to look up for this record box."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setCheckedRecords( self, records ):\n        QApplication.sendPostedEvents(self, -1)\n        indexes = []\n        \r\n        for i in range(self.count()):\r\n            record = self.recordAt(i)\r\n            if record is not None and record in records:\r\n                indexes.append(i)\r\n        \n        self.setCheckedIndexes(indexes)", "response": "Sets the checked records to the list of inputed records."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setCurrentRecord(self, record, autoAdd=False):\r\n        if record is not None and not Table.recordcheck(record):\r\n            return False\r\n        \r\n        # don't reassign the current record\r\n        # clear the record\r\n        if record is None:\r\n            self._currentRecord = None\r\n            blocked = self.signalsBlocked()\r\n            self.blockSignals(True)\r\n            self.setCurrentIndex(-1)\r\n            self.blockSignals(blocked)\r\n            \r\n            if not blocked:\r\n                self.currentRecordChanged.emit(None)\r\n            \r\n            return True\r\n        \r\n        elif record == self.currentRecord():\r\n            return False\r\n        \r\n        self._currentRecord = record\r\n        found = False\r\n        \r\n        blocked = self.signalsBlocked()\r\n        self.blockSignals(True)\r\n        for i in range(self.count()):\r\n            stored = unwrapVariant(self.itemData(i, Qt.UserRole))\r\n            if stored == record:\r\n                self.setCurrentIndex(i)\r\n                found = True\r\n                break\r\n        \r\n        if not found and autoAdd:\r\n            self.addRecord(record)\r\n            self.setCurrentIndex(self.count() - 1)\r\n        \r\n        self.blockSignals(blocked)\r\n        \r\n        if not blocked:\r\n            self.currentRecordChanged.emit(record)\r\n        return False", "response": "Sets the index for this combobox to the inputed record instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setQuery(self, query, autoRefresh=True):\r\n        self._query = query\r\n        \r\n        tableType = self.tableType()\r\n        if not tableType:\r\n            return False\r\n        \r\n        if autoRefresh:\r\n            self.refresh(tableType.select(where = query))\r\n        \r\n        return True", "response": "Sets the query for this record box for generating records."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the table type for this record box to the inputed table type.", "response": "def setTableType( self, tableType ):\r\n        \"\"\"\r\n        Sets the table type for this record box to the inputed table type.\r\n        \r\n        :param      tableType | <orb.Table>\r\n        \"\"\"\r\n        self._tableType     = tableType\r\n        \r\n        if tableType:\r\n            self._tableTypeName = tableType.schema().name()\r\n        else:\r\n            self._tableTypeName = ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the visibility of this record box.", "response": "def setVisible(self, state):\r\n        \"\"\"\r\n        Sets the visibility for this record box.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        super(XOrbRecordBox, self).setVisible(state)\r\n        \r\n        if state and not self._loaded:\r\n            if self.autoInitialize():\r\n                table = self.tableType()\r\n                if not table:\r\n                    return\r\n                \r\n                self.setRecords(table.select(where=self.query()))\r\n            else:\r\n                self.initialized.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\noverload the showPopup method from QComboBox to display an ORB tree widget when necessary.", "response": "def showPopup(self):\r\n        \"\"\"\r\n        Overloads the popup method from QComboBox to display an ORB tree widget\r\n        when necessary.\r\n        \r\n        :sa     setShowTreePopup\r\n        \"\"\"\r\n        if not self.showTreePopup():\r\n            return super(XOrbRecordBox, self).showPopup()\r\n        \r\n        tree = self.treePopupWidget()\r\n        \r\n        if tree and not tree.isVisible():\r\n            tree.move(self.mapToGlobal(QPoint(0, self.height())))\r\n            tree.resize(self.width(), 250)\r\n            tree.resizeToContents()\r\n            tree.filterItems('')\r\n            tree.setFilteredColumns(range(tree.columnCount()))\r\n            tree.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef specifiedColumns(self):\r\n        columns = []\r\n        table = self.tableType()\r\n        tree = self.treePopupWidget()\r\n        schema = table.schema()\r\n        \r\n        if self._specifiedColumns is not None:\r\n            colnames = self._specifiedColumns\r\n        else:\r\n            colnames = tree.columns()\r\n        \r\n        for colname in colnames:\r\n            if isinstance(colname, Column):\r\n                columns.append(colname)\r\n            else:\r\n                col = schema.column(colname)\r\n                if col and not col.isProxy():\r\n                    columns.append(col)\r\n        \r\n        return columns", "response": "Returns the list of columns that are specified based on the column\r\n            view for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the table type for this instance.", "response": "def tableType( self ):\r\n        \"\"\"\r\n        Returns the table type for this instance.\r\n        \r\n        :return     <subclass of orb.Table> || None\r\n        \"\"\"\r\n        if not self._tableType:\r\n            if self._tableTypeName:\r\n                self._tableType = Orb.instance().model(nstr(self._tableTypeName))\r\n            \r\n        return self._tableType"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef treePopupWidget(self):\r\n        edit = self.lineEdit()\r\n        if not self._treePopupWidget:\r\n            # create the treewidget\r\n            tree = XTreeWidget(self)\r\n            tree.setWindowFlags(Qt.Popup)\r\n            tree.setFocusPolicy(Qt.StrongFocus)\r\n            tree.installEventFilter(self)\r\n            tree.setAlternatingRowColors(True)\r\n            tree.setShowGridColumns(False)\r\n            tree.setRootIsDecorated(False)\r\n            tree.setVerticalScrollMode(tree.ScrollPerPixel)\r\n            \r\n            # create connections\r\n            tree.itemClicked.connect(self.acceptRecord)\r\n            \r\n            if edit:\r\n                edit.textEdited.connect(tree.filterItems)\r\n                edit.textEdited.connect(self.showPopup)\r\n            \r\n            self._treePopupWidget = tree\r\n        \r\n        return self._treePopupWidget", "response": "Returns the most appropriate tree widget for this record box when it is supposed to be an ORB tree widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a worker object for loading records for this record box.", "response": "def worker(self):\r\n        \"\"\"\r\n        Returns the worker object for loading records for this record box.\r\n        \r\n        :return     <XOrbLookupWorker>\r\n        \"\"\"\r\n        if self._worker is None:\r\n            self._worker = XOrbLookupWorker(self.isThreadEnabled())\r\n            self._worker.setBatchSize(self._batchSize)\r\n            self._worker.setBatched(not self.isThreadEnabled())\r\n            \r\n            # connect the worker\r\n            self.loadRequested.connect(self._worker.loadRecords)\r\n            self._worker.loadingStarted.connect(self.markLoadingStarted)\r\n            self._worker.loadingFinished.connect(self.markLoadingFinished)\r\n            self._worker.loadedRecords.connect(self.addRecordsFromThread)\r\n        \r\n        return self._worker"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generatePlugins(widgetPath = None, buildPath = None):\r\n    if widgetPath is None:\r\n        widgetPath = WIDGET_PATH\r\n        \r\n    if buildPath is None:\r\n        buildPath = BUILD_PATH\r\n    \r\n    for basepath in widgetPath.split(os.path.pathsep):\r\n        if not basepath:\r\n            continue\r\n            \r\n        # load packaged widgets\r\n        for filepath in glob.glob(os.path.join(basepath, '*/__init__.py')):\r\n            generatePlugins(os.path.dirname(filepath), buildPath)\r\n        \r\n        # load module widgets\r\n        for filepath in glob.glob(os.path.join(basepath, '*.py')):\r\n            generatePlugin(filepath, buildPath)", "response": "Generates all the plugin files for the system and imports them."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a particular ui plugin for the given source file and creates it if it does not exist.", "response": "def generatePlugin(sourcePath, buildPath = None):\r\n    \"\"\"\r\n    Generates a particular ui plugin for ths system and imports it.\r\n    \r\n    :param      widgetPath  | <str>\r\n                buildPath   | <str> || None\r\n    \"\"\"\r\n    if ( buildPath is None ):\r\n        buildPath = BUILD_PATH\r\n        \r\n    pkg_name = projex.packageFromPath(sourcePath)\r\n    module = os.path.basename(sourcePath).split('.')[0]\r\n    if module != '__init__':\r\n        pkg_name += '.' + module\r\n    \r\n    try:\r\n        __import__(pkg_name)\r\n    except ImportError, e:\r\n        logging.exception(e)\r\n        return\r\n    \r\n    module = sys.modules.get(pkg_name)\r\n    if not module:\r\n        return\r\n        \r\n    if not hasattr(module, '__designer_plugins__'):\r\n        logger.info('%s has no __designer_plugins__ defined.' % pkg_name)\r\n        return\r\n    \r\n    if not os.path.exists(buildPath):\r\n        os.mkdir(buildPath)\r\n    \r\n    for plug in module.__designer_plugins__:\r\n        output_path = os.path.join(buildPath, \r\n                                   '%splugin.py' % plug.__name__.lower())\r\n        \r\n        # generate the options\r\n        options = {}\r\n        options['module'] = pkg_name\r\n        options['class']  = plug.__name__\r\n        \r\n        # save the plugin\r\n        f = open(output_path, 'w')\r\n        f.write(PLUGIN_DEF % options)\r\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the key press event.", "response": "def keyPressEvent(self, event):\r\n        \"\"\"\r\n        Handles the key press event.  When the user hits F5, the current\r\n        code edit will be executed within the console's scope.\r\n        \r\n        :param      event | <QtCore.QKeyEvent>\r\n        \"\"\"\r\n        if event.key() == QtCore.Qt.Key_F5 or \\\r\n           (event.key() == QtCore.Qt.Key_E and \\\r\n            event.modifiers() == QtCore.Qt.ControlModifier):\r\n            code = str(self._edit.toPlainText())\r\n            scope = self.viewWidget().codeScope()\r\n            \r\n            exec code in scope, scope\r\n        else:\r\n            super(XScriptView, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrestore the view s content from XML.", "response": "def restoreXml(self, xml):\r\n        \"\"\"\r\n        Restores the view's content from XML.\r\n        \r\n        :param      xml | <str>\r\n        \"\"\"\r\n        xscript = xml.find('script')\r\n        if xscript is not None and xscript.text is not None:\r\n            self._edit.setPlainText(unescape(xscript.text))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave this view s content to XML.", "response": "def saveXml(self, xml):\r\n        \"\"\"\r\n        Saves this view's content to XML.\r\n        \r\n        :param      xml | <str>\r\n        \"\"\"\r\n        xscript = ElementTree.SubElement(xml, 'script')\r\n        xscript.text = escape(self._edit.toPlainText())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _updateFrame(self):\r\n        for col, mov in self._movies.items():\r\n            self.setIcon(col, QtGui.QIcon(mov.currentPixmap()))", "response": "Updates the frame with the current movie icon."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadjusts the height of this item based on the columna and its text.", "response": "def adjustHeight(self, column):\r\n        \"\"\"\r\n        Adjusts the height for this item based on the columna and its text.\r\n        \r\n        :param      column | <int>\r\n        \"\"\"\r\n        tree = self.treeWidget()\r\n        if not tree:\r\n            return\r\n        \r\n        w = tree.width()\r\n        if tree.verticalScrollBar().isVisible():\r\n            w -= tree.verticalScrollBar().width()\r\n        \r\n        doc = QtGui.QTextDocument()\r\n        doc.setTextWidth(w)\r\n        doc.setHtml(self.text(0))\r\n        height = doc.documentLayout().documentSize().height()\r\n        self.setFixedHeight(height+2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroy(self):\r\n        try:\r\n            tree = self.treeWidget()\r\n            tree.destroyed.disconnect(self.destroy)\r\n        except StandardError:\r\n            pass\r\n        \r\n        for movie in set(self._movies.values()):\r\n            try:\r\n                movie.frameChanged.disconnect(self._updateFrame)\r\n            except StandardError:\r\n                pass", "response": "Destroys this item by disconnecting any signals that may exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef children(self, recursive=False):\r\n        for i in xrange(self.childCount()):\r\n            child = self.child(i)\r\n            yield child\r\n            \r\n            if recursive:\r\n                for subchild in child.children(recursive=True):\r\n                    yield subchild", "response": "Returns the list of child nodes for this item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the drag information associated with this tree widget item for the given format.", "response": "def dragData(self, format=None, default=None):\r\n        \"\"\"\r\n        Returns the drag information that is associated with this tree\r\n        widget item for the given format.\r\n        \r\n        :param      format | <str>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        if format is None:\r\n            return self._dragData\r\n        return self._dragData.get(nativestring(format), default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ensureVisible(self):\r\n        parent = self.parent()\r\n        while parent:\r\n            parent.setExpanded(True)\r\n            parent = parent.parent()", "response": "Ensures that this item is visible to the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initGroupStyle(self, useIcons=True, columnCount=None):\r\n        flags      = self.flags()\r\n        if flags & QtCore.Qt.ItemIsSelectable:\r\n            flags ^= QtCore.Qt.ItemIsSelectable\r\n            self.setFlags(flags)\r\n        \r\n        if useIcons:\r\n            ico        = QtGui.QIcon(resources.find('img/treeview/triangle_right.png'))\r\n            expand_ico = QtGui.QIcon(resources.find('img/treeview/triangle_down.png'))\r\n            \r\n            self.setIcon(0, ico)\r\n            self.setExpandedIcon(0, expand_ico)\r\n        \r\n        palette = QtGui.QApplication.palette()\r\n        \r\n        line_clr = palette.color(palette.Mid)\r\n        base_clr = palette.color(palette.Button)\r\n        text_clr = palette.color(palette.ButtonText)\r\n        \r\n        gradient = QtGui.QLinearGradient()\r\n        \r\n        gradient.setColorAt(0.00, line_clr)\r\n        gradient.setColorAt(0.03, line_clr)\r\n        gradient.setColorAt(0.04, base_clr.lighter(105))\r\n        gradient.setColorAt(0.25, base_clr)\r\n        gradient.setColorAt(0.96, base_clr.darker(105))\r\n        gradient.setColorAt(0.97, line_clr)\r\n        gradient.setColorAt(1.00, line_clr)\r\n        \r\n        h = self._fixedHeight\r\n        if not h:\r\n            h = self.sizeHint(0).height()\r\n        if not h:\r\n            h = 18\r\n        \r\n        gradient.setStart(0.0, 0.0)\r\n        gradient.setFinalStop(0.0, h)\r\n        \r\n        brush = QtGui.QBrush(gradient)\r\n        \r\n        tree = self.treeWidget()\r\n        columnCount = columnCount or (tree.columnCount() if tree else self.columnCount())\r\n\r\n        for i in range(columnCount):\r\n            self.setForeground(i, text_clr)\r\n            self.setBackground(i, brush)", "response": "Initializes the group style of this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the check state of the given column based on the given bool state.", "response": "def setChecked(self, column, state):\r\n        \"\"\"\r\n        Sets the check state of the inputed column based on the given bool\r\n        state.  This is a convenience method on top of the setCheckState\r\n        method.\r\n        \r\n        :param      column | <int>\r\n                    state  | <bool>\r\n        \"\"\"\r\n        self.setCheckState(column, QtCore.Qt.Checked if state else QtCore.Qt.Unchecked)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the drag information that is associated with this tree widget item for the given format.", "response": "def setDragData(self, format, value):\r\n        \"\"\"\r\n        Sets the drag information that is associated with this tree\r\n        widget item for the given format.\r\n        \r\n        :param      format | <str>\r\n                    value  | <variant>\r\n        \"\"\"\r\n        if value is None:\r\n            self._dragData.pop(nativestring(format), None)\r\n        else:\r\n            self._dragData[nativestring(format)] = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setExpanded(self, state):\r\n        if (state and self.testFlag(self.ItemIsExpandable)) or \\\r\n           (not state and self.testFlag(self.ItemIsCollapsible)):\r\n            super(XTreeWidgetItem, self).setExpanded(state)", "response": "Sets whether or not this item is in an expanded state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the expanded icon for the item in the given column.", "response": "def setExpandedIcon( self, column, icon ):\r\n        \"\"\"\r\n        Sets the icon to be used when the item is expanded.\r\n        \r\n        :param      column | <int>\r\n                    icon   | <QtGui.QIcon> || None\r\n        \"\"\"\r\n        self._expandedIcon[column] = QtGui.QIcon(icon)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the flag associated with this item.", "response": "def setFlag(self, flag, state=True):\r\n        \"\"\"\r\n        Sets whether or not the inputed flag is associated with this item.\r\n        \r\n        :param      flag  | <QtCore.Qt.ItemFlags>\r\n                    state | <bool>\r\n        \"\"\"\r\n        if state:\r\n            self.setFlags(self.flags() | flag)\r\n        else:\r\n            self.setFlags(self.flags() & ~flag)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a label with the given HTML for this item and column. This method requires the item to be a part of the tree. :param column | <int> html | <unicode> :return <bool> | success", "response": "def setHtml(self, column, html):\r\n        \"\"\"\r\n        Creates a label with the given HTML for this item and column.  This\r\n        method requires the item to be a part of the tree.\r\n        \r\n        :param      column | <int>\r\n                    html   | <unicode>\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        tree = self.treeWidget()\r\n        if not tree:\r\n            return False\r\n        \r\n        lbl = tree.itemWidget(self, column)\r\n        if not html and lbl:\r\n            lbl.deleteLater()\r\n            return True\r\n        \r\n        elif not lbl:\r\n            lbl = QtGui.QLabel(tree)\r\n            lbl.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)\r\n            lbl.setOpenExternalLinks(True)\r\n            tree.setItemWidget(self, column, lbl)\r\n        \r\n        lbl.setText(html)\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the hover background for the given column.", "response": "def setHoverBackground( self, column, brush ):\r\n        \"\"\"\r\n        Returns the brush to use when coloring when the user hovers over\r\n        the item for the given column.\r\n        \r\n        :param      column | <int>\r\n                    brush  | <QtGui.QBrush)\r\n        \"\"\"\r\n        self._hoverBackground[column] = QtGui.QBrush(brush)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the hover icon for the given column.", "response": "def setHoverIcon( self, column, icon ):\r\n        \"\"\"\r\n        Returns the icon to use when coloring when the user hovers over\r\n        the item for the given column.\r\n        \r\n        :param      column | <int>\r\n                    icon   | <QtGui.QIcon)\r\n        \"\"\"\r\n        self._hoverIcon[column] = QtGui.QIcon(icon)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setHoverForeground( self, column, brush ):\r\n        self._hoverForeground[column] = QtGui.QBrush(brush)", "response": "Sets the color to use when coloring when the user hovers over the given column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the icon overlay for this item at the inputed column to the given icon.", "response": "def setIconOverlay(self, column, icon):\r\n        \"\"\"\r\n        Sets the icon overlay for this item at the inputed column to the\r\n        given icon.\r\n        \r\n        :param      column | <int>\r\n                    icon   | <str> || <QtGui.QIcon>\r\n        \"\"\"\r\n        self._iconOverlays[column] = QtGui.QIcon(icon)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the movie that will play for the given column.", "response": "def setMovie(self, column, movie):\r\n        \"\"\"\r\n        Sets the movie that will play for the given column.\r\n        \r\n        :param      column | <int>\r\n                    movie  | <QtGui.QMovie> || None\r\n        \"\"\"\r\n        curr = self._movies.get(column)\r\n        if curr == movie:\r\n            return True\r\n        else:\r\n            try:\r\n                curr.frameChanged.disconnect(self._updateFrame)\r\n            except StandardError:\r\n                pass\r\n        \r\n        if movie is not None:\r\n            self.requireCleanup()\r\n\r\n            self._movies[column] = movie\r\n            self.setIcon(column, QtGui.QIcon(movie.currentPixmap()))\r\n            \r\n            try:\r\n                movie.frameChanged.connect(self._updateFrame,\r\n                                           QtCore.Qt.UniqueConnection)\r\n            except StandardError:\r\n                pass\r\n        else:\r\n            self._movies.pop(column, None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setSizeHint(self, column, hint):\r\n        self._fixedHeight = max(hint.height(), self._fixedHeight)\r\n        super(XTreeWidgetItem, self).setSizeHint(column, hint)", "response": "Sets the size hint for this item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the sorting information for the inputed column to the given data.", "response": "def setSortData( self, column, data ):\r\n        \"\"\"\r\n        Sets the sorting information for the inputed column to the given data.\r\n        \r\n        :param      column | <int>\r\n                    data   | <variant>\r\n        \"\"\"\r\n        self.setData(column, self.SortRole, wrapVariant(data))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the size hint for this column.", "response": "def sizeHint(self, column):\r\n        \"\"\"\r\n        Returns the size hint for this column.  This will return the width\r\n        for the given column, with the maximum height assigned with this item.\r\n        \r\n        :return     <QtCore.QSize>\r\n        \"\"\"\r\n        hint = super(XTreeWidgetItem, self).sizeHint(column)\r\n        hint.setHeight(max(hint.height(), self.fixedHeight()))\r\n        return hint"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sortData( self, column ):\r\n        value = unwrapVariant(self.data(column, self.SortRole))\r\n        if value is None:\r\n            return None\r\n        return unwrapVariant(self.data(column, QtCore.Qt.EditRole))", "response": "Returns the data to be used when sorting the items in the given column."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef takeFromTree(self):\r\n        tree = self.treeWidget()\r\n        parent = self.parent()\r\n        \r\n        if parent:\r\n            parent.takeChild(parent.indexOfChild(self))\r\n        else:\r\n            tree.takeTopLevelItem(tree.indexOfTopLevelItem(self))", "response": "Takes this item from the tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the default database for this Proxy object.", "response": "def database(self, database_name):\n        \"\"\"\n        Set the default database for this Proxy object.\n        :param database_name: A string naming the database\n        \"\"\"\n        if database_name and MongoDB.valid_mongodb_name(database_name):\n            self._database = self.client[database_name]\n        else:\n            raise ShellError(f\"'{database_name}' is not a valid database name\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the pymongo find command against the default database and collection and paginate the output to the screen.", "response": "def find(self, *args, **kwargs):\n        \"\"\"\n        Run the pymongo find command against the default database and collection\n        and paginate the output to the screen.\n        \"\"\"\n        # print(f\"database.collection: '{self.database.name}.{self.collection.name}'\")\n        self.print_cursor(self.collection.find(*args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns the pymongo find_one command against the default database and collection and print the result.", "response": "def find_one(self, *args, **kwargs):\n        \"\"\"\n        Run the pymongo find_one command against the default database and collection\n        and paginate the output to the screen.\n        \"\"\"\n        # print(f\"database.collection: '{self.database.name}.{self.collection.name}'\")\n        self.print_doc(self.collection.find_one(*args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert_one(self, *args, **kwargs):\n        # print(f\"database.collection: '{self.database.name}.{self.collection.name}'\")\n        result = self.collection.insert_one(*args, **kwargs)\n        return result.inserted_id", "response": "Run the pymongo insert_one command against the default database and collection and return the inserted ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the pymongo insert_many command against the default database and collection and return the list of inserted IDs.", "response": "def insert_many(self, *args, **kwargs):\n        \"\"\"\n        Run the pymongo insert_many command against the default database and collection\n        and return the list of inserted IDs.\n        \"\"\"\n        # print(f\"database.collection: '{self.database.name}.{self.collection.name}'\")\n        result = self.collection.insert_many(*args, **kwargs)\n        return result.inserted_ids"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the pymongo delete_one command against the default database and collection and return the deleted IDs.", "response": "def delete_one(self, *args, **kwargs):\n        \"\"\"\n        Run the pymongo delete_one command against the default database and collection\n        and return the deleted IDs.\n        \"\"\"\n        result = self.collection.delete_one(*args, **kwargs)\n        return result.raw_result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the pymongo delete_many command against the default database and collection and return the deleted IDs.", "response": "def delete_many(self, *args, **kwargs):\n        \"\"\"\n        Run the pymongo delete_many command against the default database and collection\n        and return the deleted IDs.\n        \"\"\"\n        result = self.collection.delete_many(*args, **kwargs)\n        return result.raw_result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncounting the number of documents in a collection accurately", "response": "def count_documents(self, filter={},  *args, **kwargs):\n        \"\"\"\n        Count all the documents in a collection accurately\n        \"\"\"\n        result = self.collection.count_documents(filter, *args, **kwargs)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning collection stats for collection.", "response": "def collstats(self, scale=1024, verbose=False):\n        \"\"\"\n        Run collection stats for collection.\n        see https://docs.mongodb.com/manual/reference/command/collStats/\n\n        :param scale: Scale at which to report sizes\n        :param verbose: used for extended report on legacy MMAPV1 storage engine\n        :return: JSON doc with stats\n        \"\"\"\n        self.print_doc(self.database.command(\n                            {\"collStats\": self._collection_name,\n                             \"scale\": scale,\n                             \"verbose\": verbose}))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_collections(self, db_names=None):\n        if db_names:\n            db_list = db_names\n        else:\n            db_list = self.client.list_database_names()\n\n        for db_name in db_list:\n            db = self.client.get_database(db_name)\n            for col_name in db.list_collection_names():\n                size = db[col_name].g\n                yield f\"{db_name}.{col_name}\"", "response": "Internal function to return all the collections for every database."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noutputs lines to a terminal. It uses `shutil.get_terminal_size` to determine the height of the terminal. It expects an iterator that returns a line at a time and those lines should be terminated by a valid newline sequence. Behaviour is controlled by a number of external class properties. `paginate` : Is on by default and triggers pagination. Without `paginate` all output is written straight to the screen. `output_file` : By assigning a name to this property we can ensure that all output is sent to the corresponding file. Prompts are not output. `pretty_print` : If this is set (default is on) then all output is pretty printed with `pprint`. If it is off then the output is just written to the screen. `overlap` : The number of lines to overlap between one page and the next. :param lines: :return: paginated output", "response": "def pager(self, lines):\n        \"\"\"\n        Outputs lines to a terminal. It uses\n        `shutil.get_terminal_size` to determine the height of the terminal.\n        It expects an iterator that returns a line at a time and those lines\n        should be terminated by a valid newline sequence.\n\n        Behaviour is controlled by a number of external class properties.\n\n        `paginate` : Is on by default and triggers pagination. Without `paginate`\n        all output is written straight to the screen.\n\n        `output_file` : By assigning a name to this property we can ensure that\n        all output is sent to the corresponding file. Prompts are not output.\n\n        `pretty_print` : If this is set (default is on) then all output is\n        pretty printed with `pprint`. If it is off then the output is just\n        written to the screen.\n\n        `overlap` : The number of lines to overlap between one page and the\n        next.\n\n        :param lines:\n        :return: paginated output\n        \"\"\"\n        try:\n\n            line_count = 0\n\n            if self._output_filename:\n                print(f\"Output is also going to '{self.output_file}'\")\n                self._output_file = open(self._output_filename, \"a+\")\n\n            terminal_columns, terminal_lines = shutil.get_terminal_size(fallback=(80, 24))\n            lines_left = terminal_lines\n            for i, l in enumerate(lines, 1):\n\n                line_residue = 0\n                if self.line_numbers:\n                    output_line = f\"{i:<4} {l}\"\n                else:\n                    output_line = l\n\n                line_overflow = int(len(output_line) / terminal_columns)\n                if line_overflow:\n                    line_residue = len(output_line) % terminal_columns\n\n                if line_overflow >= 1:\n                    lines_left = lines_left - line_overflow\n                else:\n                    lines_left = lines_left - 1\n\n                if line_residue > 1:\n                    lines_left = lines_left - 1\n\n                # line_count = line_count + 1\n\n                print(output_line)\n\n                if self._output_file:\n                    self._output_file.write(f\"{l}\\n\")\n                    self._output_file.flush()\n\n                #print(lines_left)\n                if (lines_left - self.overlap - 1) <= 0:  # -1 to leave room for prompt\n\n                    if self.paginate:\n                        print(\"Hit Return to continue (q or quit to exit)\", end=\"\")\n\n                        user_input = input()\n                        if user_input.lower().strip() in [\"q\", \"quit\", \"exit\"]:\n                            break\n\n                        terminal_columns, terminal_lines = shutil.get_terminal_size(fallback=(80, 24))\n                        lines_left = terminal_lines\n            # end for\n\n            if self._output_file:\n                self._output_file.close()\n        except KeyboardInterrupt:\n            print(\"ctrl-C...\")\n            if self._output_file:\n                self._output_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef doc_to_lines(self, doc, format_func=None):\n        if format_func:\n            for l in format_func(doc).splitlines():\n                yield l\n        elif self.pretty_print:\n            for l in pprint.pformat(doc).splitlines():\n                yield l\n        else:\n            for l in str(doc).splitlines():\n                yield l", "response": "Generator that converts a doc to a sequence of lines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a cursor that returns a list of docs and returns a list of lines that are returned by the format_func function.", "response": "def cursor_to_lines(self, cursor, format_func=None):\n        \"\"\"\n        Take a cursor that returns a list of docs and returns a\n        generator yield each line of each doc a line at a time.\n        :param cursor: A mongod cursor yielding docs (dictonaries)\n        :param format_func: A customisable format function\n        :return: a generator yielding a line at a time\n        \"\"\"\n        for doc in cursor:\n            yield from self.doc_to_lines(doc, format_func)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setEditorData( self, editor, index ):\r\n        item        = self.parent().itemFromIndex(index)\r\n        value       = item.value()\r\n        tree        = self.parent()\r\n        querywidget = tree.parent()\r\n        factory     = querywidget.factory()\r\n        \r\n        factory.setEditorData(editor, value)", "response": "Set the data for the editor of this delegate to the inputed information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the data for the given index from the given editor s value.", "response": "def setModelData( self, editor, model, index ):\r\n        \"\"\"\r\n        Sets the data for the given index from the editor's value.\r\n        \r\n        :param      editor | <QWidget>\r\n                    model  | <QAbstractItemModel>\r\n                    index  | <QModelIndex>\r\n        \"\"\"\r\n        tree        = self.parent()\r\n        querywidget = tree.parent()\r\n        factory     = querywidget.factory()\r\n        item        = tree.itemFromIndex(index)\r\n        \r\n        value = factory.editorData(editor)\r\n        item.setValue(value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef columnType( self ):\r\n        schema = self.treeWidget().parent().schema()\r\n        if ( not schema ):\r\n            return 0\r\n        column = schema.column(self.text(0))\r\n        if ( column ):\r\n            return column.columnType()\r\n        return ColumnType.String", "response": "Returns the column type for this item based on the current column."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the operator type for this item based on the current column name.", "response": "def operatorType( self ):\r\n        \"\"\"\r\n        Returns the operator type for this item based on the current column.\r\n        \r\n        :return     <Q.Op>\r\n        \"\"\"\r\n        return Q.Op[projex.text.joinWords(projex.text.capitalizeWords(self.text(1)))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the query for this item by joining together its children and building its data.", "response": "def query( self ):\r\n        \"\"\"\r\n        Returns the query for this item by joining together its children, \r\n        or building its data.\r\n        \r\n        :return     <Query> || <QueryCompound>\r\n        \"\"\"\r\n        # create the query compound\r\n        if ( self.childCount() ):\r\n            q = Q()\r\n            operator = 'and'\r\n            for i in range(self.childCount()):\r\n                item = self.child(i)\r\n                if ( isinstance(item, XQueryItem) ):\r\n                    if ( operator == 'and' ):\r\n                        q &= item.query()\r\n                    else:\r\n                        q |= item.query()\r\n                else:\r\n                    operator = nativestring(item.text(0))\r\n            return q\r\n        \r\n        # create the query for this individual item\r\n        else:\r\n            q = Q(self.columnName())\r\n            q.setOperatorType(self.operatorType())\r\n            q.setValue(self.value())\r\n            return q"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setOperatorType( self, operatorType ):\r\n        op_name = Q.Op[operatorType]\r\n        op_name = projex.text.joinWords(op_name, ' ').lower()\r\n        self.setText(1, op_name)", "response": "Sets the operator type value to the inputed type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value for this item to the inputed value.", "response": "def setValue( self, value ):\r\n        \"\"\"\r\n        Sets the value for this item to the inputed value.\r\n        \r\n        :param      value | <variant>\r\n        \"\"\"\r\n        self._value = value\r\n        \r\n        # map a list of choices to the system\r\n        if ( isinstance(value, list) ):\r\n            self.setText(2, '[%s]' % ','.join(map(str, value)))\r\n        else:\r\n            self.setText(2, nativestring(value))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef summary( self ):\r\n        child_text = []\r\n        \r\n        for c in range(self.childCount()):\r\n            child = self.child(c)\r\n            text = [child.text(0), child.text(1), child.text(2), child.text(3)]\r\n            text = map(str, text)\r\n            \r\n            while ( '' in text ):\r\n                text.remove('')\r\n            \r\n            child_text.append( ' '.join(text) )\r\n        \r\n        return ' '.join(child_text)", "response": "Returns a text string representing the current query and its children."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addQuery( self ):\r\n        insert_item = self.uiQueryTREE.currentItem()\r\n        if ( insert_item and not insert_item.isSelected() ):\r\n            insert_item = None\r\n        \r\n        # create the query\r\n        if ( self.uiQueryTXT.text() ):\r\n            query = Q.fromString(nativestring(self.uiQueryTXT.text()))\r\n            self.uiQueryTXT.setText('')\r\n        else:\r\n            query = Q()\r\n        \r\n        # determine where to create the item at\r\n        tree = self.uiQueryTREE\r\n        \r\n        if ( not insert_item ):\r\n            # determine if we are already joining queries together\r\n            count = tree.topLevelItemCount()\r\n            \r\n            # create the first item\r\n            if ( not count ):\r\n                XQueryItem(tree, query)\r\n            else:\r\n                if ( 1 < count ):\r\n                    join = tree.topLevelItem(count - 2).text(0)\r\n                else:\r\n                    join = 'and'\r\n                \r\n                # create the join item & query item\r\n                XJoinItem(tree, join)\r\n                XQueryItem(tree, query)\r\n        \r\n        # add a query into a group\r\n        elif ( insert_item.childCount() ):\r\n            count = insert_item.childCount()\r\n            join = insert_item.child(count - 2).text(0)\r\n            \r\n            # add the query to the group\r\n            XJoinItem(insert_item, join)\r\n            XQueryItem(tree, query)\r\n        \r\n        # add a query underneath another item\r\n        else:\r\n            parent_item = insert_item.parent()\r\n            \r\n            # add into the tree\r\n            if ( not parent_item ):\r\n                count = tree.topLevelItemCount()\r\n                index = tree.indexOfTopLevelItem(insert_item)\r\n                \r\n                # add to the end\r\n                if ( index == count - 1 ):\r\n                    if ( 1 < count ):\r\n                        join = tree.topLevelItem(count - 2).text(0)\r\n                    else:\r\n                        join = 'and'\r\n                    \r\n                    XJoinItem(tree, join)\r\n                    XQueryItem(tree, query)\r\n                \r\n                # insert in the middle\r\n                else:\r\n                    join_item = tree.topLevelItem(index + 1)\r\n                    join = join_item.text(0)\r\n                    XJoinItem(tree, join, preceeding = join_item)\r\n                    XQueryItem(tree, query, preceeding = join_item)\r\n            else:\r\n                count = parent_item.childCount()\r\n                index = parent_item.indexOfChild(insert_item)\r\n                \r\n                # add to the end\r\n                if ( index == count - 1 ):\r\n                    if ( 1 < count ):\r\n                        join = parent_item.child(count - 2).text(0)\r\n                    else:\r\n                        join = 'and'\r\n                    \r\n                    XJoinItem(parent_item, join)\r\n                    XQueryItem(parent_item, query)\r\n                \r\n                # insert in the middle\r\n                else:\r\n                    join_item = parent_item.child(index + 1)\r\n                    join = join_item.text(0)\r\n                    XJoinItem(parent_item, join, preceeding = join_item)\r\n                    XQueryItem(parent_item, join, preceeding = join_item)", "response": "Sets the query for this widget from the quick query text builder."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eventFilter( self, object, event ):\r\n        if ( event.type() == event.KeyPress ):\r\n            if ( event.key() in (Qt.Key_Return, Qt.Key_Enter) ):\r\n                self.addQuery()\r\n                return True\r\n        \r\n        return False", "response": "Returns True if the object is in the list of events that are in the list of related objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngroup the selected items together into a sub query", "response": "def groupQuery( self ):\r\n        \"\"\"\r\n        Groups the selected items together into a sub query\r\n        \"\"\"\r\n        items = self.uiQueryTREE.selectedItems()\r\n        if ( not len(items) > 2 ):\r\n            return\r\n        \r\n        if ( isinstance(items[-1], XJoinItem) ):\r\n            items = items[:-1]\r\n        \r\n        tree   = self.uiQueryTREE\r\n        parent = items[0].parent()\r\n        if ( not parent ):\r\n            parent = tree\r\n        \r\n        preceeding = items[-1]\r\n        \r\n        tree.blockSignals(True)\r\n        tree.setUpdatesEnabled(False)\r\n        \r\n        grp_item = XQueryItem(parent, Q(), preceeding = preceeding)\r\n        for item in items:\r\n            parent = item.parent()\r\n            if ( not parent ):\r\n                tree.takeTopLevelItem(tree.indexOfTopLevelItem(item))\r\n            else:\r\n                parent.takeChild(parent.indexOfChild(item))\r\n            grp_item.addChild(item)\r\n        grp_item.update()\r\n        \r\n        tree.blockSignals(False)\r\n        tree.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the query this widget is representing from the tree widget.", "response": "def query( self ):\r\n        \"\"\"\r\n        Returns the query this widget is representing from the tree widget.\r\n        \r\n        :return     <Query> || <QueryCompound> || None\r\n        \"\"\"\r\n        # build a query if not searching all\r\n        q        = Q()\r\n        operator = 'and'\r\n        \r\n        for i in range(self.uiQueryTREE.topLevelItemCount()):\r\n            item = self.uiQueryTREE.topLevelItem(i)\r\n            \r\n            if ( isinstance(item, XQueryItem) ):\r\n                if ( operator == 'and' ):\r\n                    q &= item.query()\r\n                else:\r\n                    q |= item.query()\r\n            else:\r\n                operator = nativestring(item.text(0))\r\n        return q"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the currently selected query from the tree.", "response": "def removeQuery( self ):\r\n        \"\"\"\r\n        Removes the currently selected query.\r\n        \"\"\"\r\n        items = self.uiQueryTREE.selectedItems()\r\n        tree  = self.uiQueryTREE\r\n        for item in items:\r\n            parent = item.parent()\r\n            if ( parent ):\r\n                parent.takeChild(parent.indexOfChild(item))\r\n            else:\r\n                tree.takeTopLevelItem(tree.indexOfTopLevelItem(item))\r\n        \r\n        self.setQuery(self.query())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setQuery( self, query ):\r\n        tree = self.uiQueryTREE\r\n        tree.blockSignals(True)\r\n        tree.setUpdatesEnabled(False)\r\n        \r\n        tree.clear()\r\n        \r\n        # assign a top level query item\r\n        if ( Q.typecheck(query) and not query.isNull() ):\r\n            XQueryItem(tree, query)\r\n        \r\n        # assign a top level query group\r\n        elif ( QueryCompound.typecheck(query) and not query.isNull() ):\r\n            op_name = QueryCompound.Op[query.operatorType()].lower()\r\n            \r\n            for i, sub_query in enumerate(query.queries()):\r\n                if ( i ):\r\n                    XJoinItem(tree, op_name)\r\n                \r\n                XQueryItem(tree, sub_query)\r\n            \r\n        tree.resizeToContents()\r\n        tree.setUpdatesEnabled(True)\r\n        tree.blockSignals(False)", "response": "Assigns the query for this widget loading the query builder tree with\r\n        the pertinent information information."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef currentPlugin( self ):\n        col    = self.uiWizardTABLE.currentColumn()\r\n        row    = self.uiWizardTABLE.currentRow()\r\n        item   = self.uiWizardTABLE.currentItem()\r\n        widget = self.uiWizardTABLE.cellWidget(row, col)\r\n        \n        if ( not (widget and item and item.isSelected()) ):\n            return None\r\n            \n        return widget.plugin()", "response": "Returns the currently selected plugin."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the plugins used for this dialog.", "response": "def plugins( self, typ = None, group = None ):\n        \"\"\"\n        Returns the plugins used for this dialog.\n        \r\n        :param      typ      | <str> || None\r\n                    group    | <str> || None\r\n        \n        :return     [<XWizardPlugin>, ..]\n        \"\"\"\n        if ( typ is None ):\r\n            output = []\r\n            for wlang in self._plugins.values():\r\n                for wgrp in wlang.values():\r\n                    output += wgrp\r\n            return output\r\n            \r\n        elif ( group is None ):\r\n            output = []\r\n            for wgrp in self._plugins.get(nativestring(typ), {}).values():\r\n                output += wgrp\r\n            return output\r\n        \r\n        else:\r\n            return self._plugins.get(nativestring(typ), {}).get(nativestring(group), [])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runWizard( self ):\r\n        plugin = self.currentPlugin()\r\n        if ( plugin and plugin.runWizard(self) ):\r\n            self.accept()", "response": "Runs the current wizard."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCurrentPlugin( self, plugin ):\n        item = self.uiWizardTABLE.currentItem()\r\n        if ( not item ):\r\n            return None\r\n        \r\n        return item.plugin()", "response": "Sets the current plugin item to the inputed plugin."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setPlugins( self, plugins ):\n        langs = {}\r\n        icons = {}\r\n        \r\n        for plugin in plugins:\r\n            wlang = plugin.wizardType()\r\n            wgrp  = plugin.wizardGroup()\r\n            \r\n            langs.setdefault(wlang, {})\r\n            langs[wlang].setdefault(wgrp, [])\r\n            \r\n            langs[wlang][wgrp].append( plugin )\r\n            \r\n            icons.setdefault(wgrp, plugin.groupIcon(wgrp))\r\n        \r\n        self._plugins = langs\r\n        \r\n        self.blockSignals(True)\r\n        self.setUpdatesEnabled(False)\r\n        self.uiPluginTREE.clear()\r\n        \r\n        folder = QIcon(projexui.resources.find('img/folder_32.png'))\r\n        for wlang in sorted(langs.keys()):\r\n            langitem = XTreeWidgetItem(self.uiPluginTREE, [wlang])\r\n            langitem.setFixedHeight(28)\r\n            langitem.initGroupStyle()\r\n            langitem.setExpanded(True)\r\n            \r\n            for wgrp in sorted(langs[wlang].keys()):\r\n                grpitem = XTreeWidgetItem(langitem, [wgrp])\r\n                grpitem.setIcon(0, QIcon(icons[wgrp]))\r\n                grpitem.setFixedHeight(26)\r\n\r\n        self.blockSignals(False)\r\n        self.setUpdatesEnabled(True)", "response": "Sets the plugins for the inputed dialog."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setVisible( self, state ):\n        super(XWizardBrowserDialog, self).setVisible(state)\n        \n        if ( state ):\n            mwidth = self.uiPluginTREE.minimumWidth()\n            self.uiMainSPLT.setSizes([mwidth,\n                                      self.uiMainSPLT.width() - mwidth])", "response": "Overloads the setVisible method for the XWizardBrowserDialog to resize the contents of the splitter properly."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef showDescription( self ):\r\n        plugin = self.currentPlugin()\r\n        if ( not plugin ):\r\n            self.uiDescriptionTXT.setText('')\r\n        else:\r\n            self.uiDescriptionTXT.setText(plugin.description())", "response": "Shows the description for the current interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef showWizards( self ):\n        self.uiWizardTABLE.clear()\r\n        \r\n        item = self.uiPluginTREE.currentItem()\r\n        if ( not (item and item.parent()) ):\r\n            plugins = []\r\n        else:\r\n            wlang   = nativestring(item.parent().text(0))\r\n            wgrp    = nativestring(item.text(0))\r\n            plugins = self.plugins(wlang, wgrp)\r\n        \r\n        if ( not plugins ):\r\n            self.uiWizardTABLE.setEnabled(False)\r\n            self.uiDescriptionTXT.setEnabled(False)\r\n            return\r\n        \r\n        self.uiWizardTABLE.setEnabled(True)\r\n        self.uiDescriptionTXT.setEnabled(True)\r\n        \r\n        # determine the number of columns\r\n        colcount = len(plugins) / 2\r\n        if ( len(plugins) % 2 ):\r\n            colcount += 1\r\n        \r\n        self.uiWizardTABLE.setRowCount(2)\r\n        self.uiWizardTABLE.setColumnCount( colcount )\r\n        \r\n        header = self.uiWizardTABLE.verticalHeader()\r\n        header.setResizeMode(0, header.Stretch)\r\n        header.setResizeMode(1, header.Stretch)\r\n        header.setMinimumSectionSize(64)\r\n        header.hide()\r\n        \r\n        header = self.uiWizardTABLE.horizontalHeader()\r\n        header.setMinimumSectionSize(64)\r\n        header.hide()\r\n        \r\n        col = -1\r\n        row = 1\r\n        for plugin in plugins:\r\n            if ( row ):\r\n                col += 1\r\n            \r\n            row     = int(not row)\r\n            widget  = PluginWidget(self, plugin)\r\n            \r\n            self.uiWizardTABLE.setItem(row, col, QTableWidgetItem())\r\n            self.uiWizardTABLE.setCellWidget(row, col, widget)", "response": "Show the wizards widget for the currently selected plugin."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprompt the user to browse the wizards based on the inputed plugins and returns True if the user is able to browse the wizards based on the inputed plugins.", "response": "def browse( plugins, parent = None, default = None ):\n        \"\"\"\n        Prompts the user to browse the wizards based on the inputed plugins \\\r\n        allowing them to launch any particular wizard of choice.\n        \n        :param      plugins | [<XWizardPlugin>, ..]\n                    parent  | <QWidget>\n                    default | <XWizardPlugin> || None\n        \n        :return     <bool> success\n        \"\"\"\n        dlg = XWizardBrowserDialog( parent )\n        dlg.setPlugins(plugins)\n        dlg.setCurrentPlugin(default)\n        if ( dlg.exec_() ):\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the color for the given name at the given color group.", "response": "def color( self, name, colorGroup = None ):\n        \"\"\"\n        Returns the color for the given name at the inputed group.  If no \\\n        group is specified, the first group in the list is used.\n        \n        :param      name        | <str>\n                    colorGroup  | <str> || None\n            \n        :return     <QColor>\n        \"\"\"\n        if ( not colorGroup and self._colorGroups ):\n            colorGroup = self._colorGroups[0]\n        \n        if ( not colorGroup ):\n            return QColor()\n        \n        return self._colors.get(str(name), {}).get(str(colorGroup), QColor())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the colors for the inputed color name.", "response": "def colors( self, name ):\n        \"\"\"\n        Returns all the colors in order for the inputed color name.\n        \n        :return     [<QColor>, ..]\n        \"\"\"\n        output = []\n        colors = self._colors.get(name, {})\n        for colorType in self._colorGroups:\n            output.append(colors.get(colorType, QColor()))\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setColor( self, name, color, colorGroup = None ):\n        self._colors.setdefault(str(name), {})\n        cmap = self._colors.get(str(name))\n        \n        if ( not colorGroup ):\n            for colorGroup in self._colorGroups:\n                cmap[colorGroup] = color\n        else:\n            cmap[colorGroup] = color", "response": "Sets the color for the inputed name in the given color group."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the string representation of the color set.", "response": "def toString( self ):\n        \"\"\"\n        Saves the color set information out to string format.  The data is \\\n        returned as xml data.\n        \n        :return     <str>\n        \"\"\"\n        # convert the element tree information\n        from xml.etree import ElementTree\n        \n        xelem = ElementTree.Element('colorset')\n        xelem.set('name', self.name())\n        xelem.set('colorGroups', ','.join(self.colorGroups()))\n        \n        for colorName, colors in self._colors.items():\n            xcolor = ElementTree.SubElement(xelem, 'color')\n            xcolor.set('name', colorName)\n            \n            for colorGroup, color in colors.items():\n                xcolorval = ElementTree.SubElement(xcolor, 'value')\n                xcolorval.set('group', colorGroup)\n                xcolorval.set('red',    str(color.red()))\n                xcolorval.set('green',  str(color.green()))\n                xcolorval.set('blue',   str(color.blue()))\n                xcolorval.set('alpha',  str(color.alpha()))\n        \n        # save the text\n        return ElementTree.tostring(xelem)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrestores a color set instance from the inputed string data.", "response": "def fromString( cls, strdata ):\n        \"\"\"\n        Restores a color set instance from the inputed string data.\n        \n        :param      strdata | <str>\n        \"\"\"\n        if ( not strdata ):\n            return None\n            \n        from xml.etree import ElementTree\n        \n        xelem = ElementTree.fromstring(str(strdata))\n        output = cls(xelem.get('name'), xelem.get('colorGroups').split(','))\n        \n        for xcolor in xelem:\n            colorName = xcolor.get('name')\n            \n            for xcolorval in xcolor:\n                color = QColor( int(xcolorval.get('red')),\n                                int(xcolorval.get('green')),\n                                int(xcolorval.get('blue')),\n                                int(xcolorval.get('alpha')) )\n                \n                output.setColor(colorName, color, xcolorval.get('group'))\n        \n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering this class as a valid datatype for saving and loading via .", "response": "def registerToDataTypes( cls ):\n        \"\"\"\n        Registers this class as a valid datatype for saving and loading via\n        the datatype system.\n        \"\"\"\n        from projexui.xdatatype import registerDataType\n        registerDataType(cls.__name__,\n            lambda pyvalue:  pyvalue.toString(),\n            lambda qvariant: cls.fromString(unwrapVariant(qvariant)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the current color data to a QPalette.", "response": "def palette( self ):\n        \"\"\"\n        Converts the current color data to a QPalette.\n        \n        :return     <QPalette>\n        \"\"\"\n        palette = QPalette()\n        \n        for colorGroup, qColorGroup in self.GroupMapping.items():\n            for colorRole, qColorRole in self.RoleMapping.items():\n                color = self.color(colorRole, colorGroup)\n                \n                palette.setColor( qColorGroup,\n                                  qColorRole,\n                                  color )\n        return palette"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enterEvent(self, event):\n        super(XViewPanelItem, self).enterEvent(event)\n\n        # store the hover state and mark for a repaint\n        self._hovered = True\n        self.update()", "response": "Updates the hovered state and updates the panel item s size."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef leaveEvent(self, event):\n        super(XViewPanelItem, self).leaveEvent(event)\n\n        # store the hover state and mark for a repaint\n        self._hovered = False\n        self.update()", "response": "Overwrites the leave event to store the hovered state and updates the treeview."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef paintEvent(self, event):\n        painter = QtGui.QPainter()\n        painter.begin(self)\n        try:\n            x = 0\n            y = 2\n            w = self.width() - 1\n            h = self.height() - 3\n            palette = self.palette()\n            clr = palette.color(palette.WindowText)\n            clr.setAlpha(100)\n            painter.setPen(QtGui.QPen(clr))\n\n            if not self.isActive() and not self._hovered:\n                painter.setBrush(palette.color(palette.Button))\n            else:\n                painter.setBrush(palette.color(palette.Window))\n\n            painter.fillRect(x, y, w, h, painter.brush())\n            painter.drawLine(x, y, w, y)\n            painter.drawLine(w, y, w, h + 2)\n\n            if self.parent().indexOf(self) == 0:\n                painter.drawLine(x, y, x, h + 2)\n\n\n            # draw the drag buttons\n            if not self._locked:\n                center = self._dragLabel.geometry().center()\n                x = 6\n                y = center.y()\n                width = 3\n\n                painter.setBrush(palette.color(palette.Window).lighter(120))\n\n                painter.drawRect(x - width / 2, (y - width - 2) - width / 2, width, width)\n                painter.drawRect(x - width / 2, y - width / 2, width, width)\n                painter.drawRect(x - width / 2, (y + width + 2) - width / 2, width, width)\n\n        finally:\n            painter.end()", "response": "Runs the paint event for this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the mouse event for dragging or activating this tab.", "response": "def mousePressEvent(self, event):\n        \"\"\"\n        Creates the mouse event for dragging or activating this tab.\n\n        :param      event | <QtCore.QMousePressEvent>\n        \"\"\"\n        self._moveItemStarted = False\n        rect = QtCore.QRect(0, 0, 12, self.height())\n\n        # drag the tab off\n        if not self._locked and rect.contains(event.pos()):\n            tabbar = self.parent()\n            panel = tabbar.parent()\n\n            index = tabbar.indexOf(self)\n            view = panel.widget(index)\n            pixmap = QtGui.QPixmap.grabWidget(view)\n\n            drag = QtGui.QDrag(panel)\n            data = QtCore.QMimeData()\n            data.setData('x-application/xview/tabbed_view', QtCore.QByteArray(str(index)))\n            drag.setMimeData(data)\n            drag.setPixmap(pixmap)\n\n            if not drag.exec_():\n                cursor = QtGui.QCursor.pos()\n                geom = self.window().geometry()\n                if not geom.contains(cursor):\n                    view.popout()\n\n        # allow moving indexes around\n        elif not self._locked and self.isActive():\n            self._moveItemStarted = self.parent().count() > 1\n\n        else:\n            self.activate()\n\n        super(XViewPanelItem, self).mousePressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setFixedHeight(self, height):\n        super(XViewPanelItem, self).setFixedHeight(height)\n\n        self._dragLabel.setFixedHeight(height)\n        self._titleLabel.setFixedHeight(height)\n        self._searchButton.setFixedHeight(height)\n        self._closeButton.setFixedHeight(height)", "response": "Sets the fixed height for this item to the inputed height amount."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addTab(self, tab):\n        if not isinstance(tab, XViewPanelItem):\n            tab = XViewPanelItem(tab, self)\n            tab.setFixedHeight(self.height())\n\n        index = len(self.items())\n        self.layout().insertWidget(index, tab)\n\n        self.setCurrentIndex(index)\n        return tab", "response": "Adds a new tab to this panel bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear(self):\n        self.blockSignals(True)\n        items = list(self.items())\n        for item in items:\n            item.close()\n        self.blockSignals(False)\n\n        self._currentIndex = -1\n        self.currentIndexChanged.emit(self._currentIndex)", "response": "Clears out all the items from this tab bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests a close for the inputed tab item.", "response": "def closeTab(self, item):\n        \"\"\"\n        Requests a close for the inputed tab item.\n\n        :param      item | <XViewPanelItem>\n        \"\"\"\n        index = self.indexOf(item)\n        if index != -1:\n            self.tabCloseRequested.emit(index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insertTab(self, index, tab):\n        if not isinstance(tab, XViewPanelItem):\n            tab = XViewPanelItem(tab, self)\n            tab.setFixedHeight(self.height())\n\n        # remove it from the layout first\n        self.layout().insertWidget(index, tab)\n        self.setCurrentIndex(index)\n        return tab", "response": "Adds a new tab to this panel bar."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef items(self):\n        output = []\n        for i in xrange(self.layout().count()):\n            item = self.layout().itemAt(i)\n            try:\n                widget = item.widget()\n            except AttributeError:\n                break\n\n            if isinstance(widget, XViewPanelItem):\n                output.append(widget)\n            else:\n                break\n        return output", "response": "Returns a list of all the items associated with this panel."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef moveTab(self, fromIndex, toIndex):\n        try:\n            item = self.layout().itemAt(fromIndex)\n            self.layout().insertItem(toIndex, item.widget())\n        except StandardError:\n            pass", "response": "Moves the tab from the inputed index to the given index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the paint event for this item.", "response": "def paintEvent(self, event):\n        \"\"\"\n        Runs the paint event for this item.\n        \"\"\"\n        painter = QtGui.QPainter()\n        painter.begin(self)\n        try:\n            h = self.height() - 1\n            palette = self.palette()\n            clr = palette.color(palette.WindowText)\n            clr.setAlpha(100)\n            painter.setPen(QtGui.QPen(clr))\n            painter.fillRect(0, 0, self.width() - 1, self.height() - 1, palette.color(palette.Button))\n            painter.drawLine(3, h, self.width() - 5, h)\n\n            try:\n                geom = self.currentItem().geometry()\n                painter.setPen(QtGui.QPen(palette.color(palette.Window)))\n                painter.drawLine(geom.left(), h, geom.right(), h)\n            except AttributeError:\n                painter\n\n        finally:\n            painter.end()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the tab at the inputed index.", "response": "def removeTab(self, index):\n        \"\"\"\n        Removes the tab at the inputed index.\n\n        :param      index | <int>\n        \"\"\"\n        curr_index = self.currentIndex()\n        items = list(self.items())\n\n        item = items[index]\n        item.close()\n        if index <= curr_index:\n            self._currentIndex -= 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nemits the add requested signal.", "response": "def requestAddMenu(self):\n        \"\"\"\n        Emits the add requested signal.\n        \"\"\"\n        point = QtCore.QPoint(self._addButton.width(), 0)\n        point = self._addButton.mapToGlobal(point)\n        self.addRequested.emit(point)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nemits the options request signal.", "response": "def requestOptionsMenu(self):\n        \"\"\"\n        Emits the options request signal.\n        \"\"\"\n        point = QtCore.QPoint(0, self._optionsButton.height())\n        point = self._optionsButton.mapToGlobal(point)\n        self.optionsRequested.emit(point)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the current item to the item at the inputed index.", "response": "def setCurrentIndex(self, index):\n        \"\"\"\n        Sets the current item to the item at the inputed index.\n\n        :param      index | <int>\n        \"\"\"\n        if self._currentIndex == index:\n            return\n\n        self._currentIndex = index\n        self.currentIndexChanged.emit(index)\n\n        for i, item in enumerate(self.items()):\n            item.setMenuEnabled(i == index)\n        self.repaint()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the fixed height for this bar to the inputed height.", "response": "def setFixedHeight(self, height):\n        \"\"\"\n        Sets the fixed height for this bar to the inputed height.\n\n        :param      height | <int>\n        \"\"\"\n        super(XViewPanelBar, self).setFixedHeight(height)\n\n        # update the layout\n        if self.layout():\n            for i in xrange(self.layout().count()):\n                try:\n                    self.layout().itemAt(i).widget().setFixedHeight(height)\n                except StandardError:\n                    continue"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the text for the tab at the inputed index.", "response": "def setTabText(self, index, text):\n        \"\"\"\n        Returns the text for the tab at the inputed index.\n\n        :param      index | <int>\n\n        :return     <str>\n        \"\"\"\n        try:\n            self.items()[index].setText(text)\n        except IndexError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addTab(self, view, title):\n        if not isinstance(view, XView):\n            return False\n\n        tab = self._tabBar.addTab(title)\n        self.addWidget(view)\n        tab.titleChanged.connect(view.setWindowTitle)\n        \n        # create connections\n        try:\n            view.windowTitleChanged.connect(self.refreshTitles,\n                                            QtCore.Qt.UniqueConnection)\n            view.sizeConstraintChanged.connect(self.adjustSizeConstraint,\n                                            QtCore.Qt.UniqueConnection)\n            view.poppedOut.connect(self.disconnectView,\n                                   QtCore.Qt.UniqueConnection)\n        except RuntimeError:\n            pass\n        \n        self.setCurrentIndex(self.count() - 1)\n        \n        return True", "response": "Adds a new tab to the panel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addView(self, viewType):\n        if not viewType:\n            return None\n        \n        view = viewType.createInstance(self, self.viewWidget())\n        self.addTab(view, view.windowTitle())\n        return view", "response": "Adds a new view of the inputed view type to the current tab."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadjusts the min and max size based on the current tab.", "response": "def adjustSizeConstraint(self):\n        \"\"\"\n        Adjusts the min/max size based on the current tab.\n        \"\"\"\n        widget = self.currentWidget()\n        if not widget:\n            return\n            \n        offw = 4\n        offh = 4\n        \n        #if self.tabBar().isVisible():\n        #    offh += 20 # tab bar height\n        \n        minw = min(widget.minimumWidth() + offw,   MAX_INT)\n        minh = min(widget.minimumHeight() + offh,  MAX_INT)\n        maxw = min(widget.maximumWidth() + offw,   MAX_INT)\n        maxh = min(widget.maximumHeight() + offh,  MAX_INT)\n        \n        self.setMinimumSize(minw, minh)\n        self.setMaximumSize(maxw, maxh)\n        self.setSizePolicy(widget.sizePolicy())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclosing the inputed view.", "response": "def closeView(self, view=None):\n        \"\"\"\n        Closes the inputed view.\n        \n        :param      view | <int> || <XView> || None\n        \"\"\"\n        if type(view) == int:\n            view = self.widget(view)\n        elif view == None:\n            view = self.currentView()\n        \n        index = self.indexOf(view)\n        if index == -1:\n            return False\n        \n        # close the view\n        count = self.count()\n        if count == 1:\n            self.closePanel()\n        else:\n            view.close()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef closePanel(self):\n        # make sure we can close all the widgets in the view first\n        for i in range(self.count()):\n            if not self.widget(i).canClose():\n                return False\n\n        container = self.parentWidget()\n        viewWidget = self.viewWidget()\n\n        # close all the child views\n        for i in xrange(self.count() - 1, -1, -1):\n            self.widget(i).close()\n\n        self.tabBar().clear()\n\n        if isinstance(container, XSplitter):\n            parent_container = container.parentWidget()\n            \n            if container.count() == 2:\n                if isinstance(parent_container, XSplitter):\n                    sizes = parent_container.sizes()\n                    widget = container.widget(int(not container.indexOf(self)))\n                    index = parent_container.indexOf(container)\n                    parent_container.insertWidget(index, widget)\n                    \n                    container.setParent(None)\n                    container.close()\n                    container.deleteLater()\n                    \n                    parent_container.setSizes(sizes)\n                \n                elif parent_container.parentWidget() == viewWidget:\n                    widget = container.widget(int(not container.indexOf(self)))\n                    widget.setParent(viewWidget)\n                    \n                    if projexui.QT_WRAPPER == 'PySide':\n                        _ = viewWidget.takeWidget()\n                    else:\n                        old_widget = viewWidget.widget()\n                        old_widget.setParent(None)\n                        old_widget.close()\n                        old_widget.deleteLater()\n                        QtGui.QApplication.instance().processEvents()\n                    \n                    viewWidget.setWidget(widget)\n            else:\n                container.setParent(None)\n                container.close()\n                container.deleteLater()\n        else:\n            self.setFocus()\n\n        self._hintLabel.setText(self.hint())\n        self._hintLabel.show()\n\n        return True", "response": "Closes a full view panel."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the current tab of the specified type exists and if not adds it. If it does not exist returns None.", "response": "def ensureVisible(self, viewType):\n        \"\"\"\n        Find and switch to the first tab of the specified view type. If the\n        type does not exist, add it.\n\n        :param     viewType | <subclass of XView>\n\n        :return    <XView> || None\n        \"\"\"\n        # make sure we're not trying to switch to the same type\n        view = self.currentView()\n        if type(view) == viewType:\n            return view\n\n        self.blockSignals(True)\n        self.setUpdatesEnabled(False)\n\n        for i in xrange(self.count()):\n            widget = self.widget(i)\n            if type(widget) == viewType:\n                self.setCurrentIndex(i)\n                view = widget\n                break\n        else:\n            view = self.addView(viewType)\n\n        self.blockSignals(False)\n        self.setUpdatesEnabled(True)\n\n        return view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insertTab(self, index, widget, title):\n        self.insertWidget(index, widget)\n        tab = self.tabBar().insertTab(index, title)\n        tab.titleChanged.connect(widget.setWindowTitle)", "response": "Inserts a new tab for this widget and sets the window title."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef markCurrentChanged(self):\n        view = self.currentView()\n        if view:\n            view.setCurrent()\n            self.setFocus()\n            view.setFocus()\n            self._hintLabel.hide()\n        else:\n            self._hintLabel.show()\n            self._hintLabel.setText(self.hint())\n\n        if not self.count():\n            self.tabBar().clear()\n\n        self.adjustSizeConstraint()", "response": "Mark that the current widget has changed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the paint event for this item.", "response": "def paintEvent(self, event):\n        \"\"\"\n        Runs the paint event for this item.\n        \"\"\"\n        painter = QtGui.QPainter()\n        painter.begin(self)\n        try:\n            palette = self.palette()\n            clr = palette.color(palette.WindowText)\n            clr.setAlpha(100)\n            painter.setPen(clr)\n            painter.setBrush(palette.color(palette.Window))\n\n            if self._tabBar.isVisible():\n                painter.fillRect(0, 0, self.width() - 1, self.height() - 1, palette.color(palette.Button))\n                x = y = 3\n                w = self.width() - 7\n                h = self.height() - 7\n            else:\n                x = y = 0\n                w = self.width() - 1\n                h = self.height() - 1\n\n            painter.drawRect(x, y, w, h)\n\n        finally:\n            painter.end()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refreshTitles(self):\n        for index in range(self.count()):\n            widget = self.widget(index)\n            self.setTabText(index, widget.windowTitle())", "response": "Refreshes the titles for each view within this tab panel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removeTab(self, index):\n        view = self.widget(index)\n        if isinstance(view, XView):\n            try:\n                view.windowTitleChanged.disconnect(self.refreshTitles)\n                view.sizeConstraintChanged.disconnect(self.adjustSizeConstraint)\n            except:\n                pass\n        \n        return super(XViewPanel, self).removeTab(index)", "response": "Removes the view at the inputed index and disconnects it from the \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necmascript \\ necm"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCurrentIndex(self, index):\n        super(XViewPanel, self).setCurrentIndex(index)\n        self.tabBar().setCurrentIndex(index)", "response": "Sets the current index on the tab bar and keep the two insync."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setLocked(self, state, force=False):\n        if not force and state == self._locked:\n            return\n        \n        self._locked = state\n        tabbar = self.tabBar()\n        tabbar.setLocked(state)\n        if self.hideTabsWhenLocked():\n            tabbar.setVisible(self.count() > 1 or not state)\n        else:\n            tabbar.setVisible(True)\n\n        if tabbar.isVisible():\n            self.setContentsMargins(6, tabbar.height(), 6, 6)\n        else:\n            self.setContentsMargins(1, 1, 1, 1)\n\n        self.adjustSizeConstraint()", "response": "Sets the locked state for this panel."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nswaps the current tab view for the inputed action s type.", "response": "def switchCurrentView(self, viewType):\n        \"\"\"\n        Swaps the current tab view for the inputed action's type.\n\n        :param      action | <QAction>\n\n        :return     <XView> || None\n        \"\"\"\n        if not self.count():\n            return self.addView(viewType)\n\n        # make sure we're not trying to switch to the same type\n        view = self.currentView()\n        if type(view) == viewType:\n            return view\n\n        # create a new view and close the old one\n        self.blockSignals(True)\n        self.setUpdatesEnabled(False)\n\n        # create the new view\n        index = self.indexOf(view)\n        if not view.close():\n            return None\n        #else:\n        #    self.tabBar().removeTab(index)\n\n        index = self.currentIndex()\n        new_view = viewType.createInstance(self.viewWidget(), self.viewWidget())\n\n        # add the new view\n        self.insertTab(index, new_view, new_view.windowTitle())\n\n        self.blockSignals(False)\n        self.setUpdatesEnabled(True)\n        self.setCurrentIndex(index)\n\n        return new_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snagViewFromPanel(self, panel, index=None):\n        if index == None:\n            index = panel.currentIndex()\n            \n        view = panel.widget(index)\n        if not view:\n            return\n        \n        count = panel.count()\n        self.addTab(view, view.windowTitle())\n        \n        # when the panel gets moved and there are no more widgets within the \n        # panel, we'll close it out - but we cannot close it directly or we \n        # run into a segmentation fault here.  Better to provide a timer and\n        # close it in a second.  It depends on which thread triggers this call\n        # that sometimes causes it to error out. - EKH 01/25/12\n        if count == 1:\n            QtCore.QTimer.singleShot(0, panel.closePanel)", "response": "Removes the view from the inputed panel and adds it to this panel."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwaits for a single transform to exist based on does_exist.", "response": "def await_transform_exists(cli, transform_path, does_exist=DEFAULT_TRANSFORM_EXISTS, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    \"\"\"\n    Waits for a single transform to exist based on does_exist.\n    :param cli:\n    :param transform_path:\n    :param does_exist: Whether or not to await for exist state (True | False)\n    :param timeout_seconds: How long until this returns with failure\n    :return: bool\n    \"\"\"\n    message_payload = {\n        \"transform_paths\": [transform_path],\n        \"do_exist\": does_exist,\n        \"match_mode\": \"All\",\n        \"timeout\": timeout_seconds\n    }\n    msg = message.Message(\"await.unity.transform.exists\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return bool(response['payload']['success'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef await_any_transforms_exist(cli, transform_paths, does_exist=DEFAULT_TRANSFORM_EXISTS, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    message_payload = {\n        \"transform_paths\": transform_paths,\n        \"do_exist\": does_exist,\n        \"match_mode\": \"Any\",\n        \"timeout\": timeout_seconds\n    }\n    msg = message.Message(\"await.unity.transform.exists\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return bool(response['payload']['success'])", "response": "Waits for a transform to exist based on does_exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch_transform_screen_position(cli, transform_path):\n\n    message_payload = {\n        \"transform_path\": transform_path\n    }\n    msg = message.Message(\"fetch.unity.transform.screenPosition\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return [\n            response['payload']['x'],\n            response['payload']['y']\n    ]", "response": "Requests screen position of a transform at path."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nqueries Unity to see if a renderer at transform_path is visible.", "response": "def query_renderer_visible(cli, transform_path):\n    \"\"\"\n    Requests status on whether a renderer at transform_path is visible.\n    :param cli:\n    :param transform_path:\n    :return: bool\n    \"\"\"\n\n    message_payload = {\n        \"transform_path\": transform_path\n    }\n    msg = message.Message(\"query.unity.renderer.visible\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return bool(response['payload']['result'])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef await_renderer_visible(cli, transform_path, is_visible=DEFAULT_RENDERER_VISIBLE, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    message_payload = {\n        \"transform_path\": transform_path,\n        \"is_visible\": is_visible,\n        \"timeout\": timeout_seconds\n    }\n    msg = message.Message(\"await.unity.renderer.visible\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return bool(response['payload']['success'])", "response": "Waits for a transform renderer to become visible based on is_visible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquery Unity to see if a scene is loaded or not.", "response": "def query_scene_loaded(cli, scene_name):\n    \"\"\"\n    Requests status on whether a scene is loaded or not.\n    :param cli:\n    :param scene_name:\n    :return: bool\n    \"\"\"\n\n    message_payload = {\n        \"scene_name\": scene_name\n    }\n    msg = message.Message(\"query.unity.scene.loaded\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return bool(response['payload']['result'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwaiting for a scene to be loaded based on is_loaded.", "response": "def await_scene_loaded(cli, scene_name, is_loaded=DEFAULT_SCENE_LOADED, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    \"\"\"\n    Waits for a scene to be loaded based on is_loaded.\n    :param cli:\n    :param scene_name:\n    :param is_loaded: Whether or not to await for loaded state (True | False)\n    :param timeout_seconds: How long until this returns with failure\n    :return: bool\n    \"\"\"\n    message_payload = {\n        \"scene_name\": scene_name,\n        \"is_loaded\": is_loaded,\n        \"timeout\": timeout_seconds\n    }\n    msg = message.Message(\"await.unity.scene.loaded\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)\n    return bool(response['payload']['success'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assign_component_value(cli, transform_path, component_type, name, value):\n\n    message_payload = {\n        \"transform_path\": transform_path,\n        \"component_type\": component_type,\n        \"name\": name,\n        \"value\": value\n    }\n    msg = message.Message(\"assign.unity.component.value\", message_payload)\n    cli.send_message(msg)\n\n    response = cli.read_message()\n    verify_response(response)", "response": "Assign a value to a component in a NCBI Unity Component"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _read(self, path, *,\n                    raw=None,\n                    recurse=None,\n                    dc=None,\n                    separator=None,\n                    keys=None,\n                    watch=None,\n                    consistency=None):\n        \"\"\"Returns the specified key\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        \"\"\"\n        response = await self._api.get(\n            \"/v1/kv\", path,\n            params={\n                \"raw\": raw,\n                \"dc\": dc,\n                \"recurse\": recurse,\n                \"separator\": separator,\n                \"keys\": keys\n            },\n            watch=watch,\n            consistency=consistency)\n        return response", "response": "Read the specified key in the specified datacenter."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of the keys under the given prefix", "response": "async def keys(self, prefix, *,\n                   dc=None, separator=None, watch=None, consistency=None):\n        \"\"\"Returns a list of the keys under the given prefix\n\n        Parameters:\n            prefix (str): Prefix to fetch\n            separator (str): List only up to a given separator\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            CollectionMeta: where value is list of keys\n\n        For example, listing ``/web/`` with a ``/`` separator may return::\n\n            [\n              \"/web/bar\",\n              \"/web/foo\",\n              \"/web/subdir/\"\n            ]\n\n        \"\"\"\n        response = await self._read(prefix,\n                                    dc=dc,\n                                    separator=separator,\n                                    keys=True,\n                                    watch=watch,\n                                    consistency=consistency)\n        return consul(response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the specified key in the KV store.", "response": "async def get(self, key, *, dc=None, watch=None, consistency=None):\n        \"\"\"Returns the specified key\n\n        Parameters:\n            key (str): Key to fetch\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            ObjectMeta: where value is the queried kv value\n\n        Object will look like::\n\n            {\n                \"CreateIndex\": 100,\n                \"ModifyIndex\": 200,\n                \"LockIndex\": 200,\n                \"Key\": \"zip\",\n                \"Flags\": 0,\n                \"Value\": b\"my data\",\n                \"Session\": \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\"\n            }\n\n        **CreateIndex** is the internal index value that represents when\n        the entry was created.\n\n        **ModifyIndex** is the last index that modified this key.\n        This index corresponds to the X-Consul-Index header value that is\n        returned in responses, and it can be used to establish blocking\n        queries. You can even perform blocking queries against entire\n        subtrees of the KV store.\n\n        **LockIndex** is the number of times this key has successfully been\n        acquired in a lock. If the lock is held, the Session key provides\n        the session that owns the lock.\n\n        **Key** is simply the full path of the entry.\n\n        **Flags** is an opaque unsigned integer that can be attached to each\n        entry. Clients can choose to use this however makes sense for their\n        application.\n\n        **Value** is a :class:`~aioconsul.typing.Payload` object,\n        it depends on **Flags**.\n        \"\"\"\n        response = await self._read(key,\n                                    dc=dc,\n                                    watch=watch,\n                                    consistency=consistency)\n        result = response.body[0]\n        result[\"Value\"] = decode_value(result[\"Value\"], result[\"Flags\"])\n        return consul(result, meta=extract_meta(response.headers))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def raw(self, key, *, dc=None, watch=None, consistency=None):\n        response = await self._read(key,\n                                    dc=dc,\n                                    raw=True,\n                                    watch=watch,\n                                    consistency=consistency)\n        return consul(response)", "response": "Returns the raw value of a key in the specified datacenter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_tree(self, prefix, *,\n                       dc=None, separator=None, watch=None, consistency=None):\n        \"\"\"Gets all keys with a prefix of Key during the transaction.\n\n        Parameters:\n            prefix (str): Prefix to fetch\n            separator (str): List only up to a given separator\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            CollectionMeta: where value is a list of values\n\n        This does not fail the transaction if the Key doesn't exist. Not\n        all keys may be present in the results if ACLs do not permit them\n        to be read.\n        \"\"\"\n        response = await self._read(prefix,\n                                    dc=dc,\n                                    recurse=True,\n                                    separator=separator,\n                                    watch=watch,\n                                    consistency=consistency)\n        result = response.body\n        for data in result:\n            data[\"Value\"] = decode_value(data[\"Value\"], data[\"Flags\"])\n        return consul(result, meta=extract_meta(response.headers))", "response": "Get all keys with a given prefix of Key during the transaction."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the key to the given value.", "response": "async def set(self, key, value, *, flags=None):\n        \"\"\"Sets the key to the given value.\n\n        Parameters:\n            key (str): Key to set\n            value (Payload): Value to set, It will be encoded by flags\n            flags (int): Flags to set with value\n        Returns:\n            bool: ``True`` on success\n        \"\"\"\n        value = encode_value(value, flags)\n        response = await self._write(key, value, flags=flags)\n        return response.body is True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the key to the given value with check - and - set semantics.", "response": "async def cas(self, key, value, *, flags=None, index):\n        \"\"\"Sets the key to the given value with check-and-set semantics.\n\n        Parameters:\n            key (str): Key to set\n            value (Payload): Value to set, It will be encoded by flags\n            index (ObjectIndex): Index ID\n            flags (int): Flags to set with value\n        Response:\n            bool: ``True`` on success\n\n        The Key will only be set if its current modify index matches\n        the supplied Index\n\n        If the index is 0, Consul will only put the key if it does not already\n        exist. If the index is non-zero, the key is only set if the index\n        matches the ModifyIndex of that key.\n        \"\"\"\n        value = encode_value(value, flags)\n        index = extract_attr(index, keys=[\"ModifyIndex\", \"Index\"])\n        response = await self._write(key, value, flags=flags, cas=index)\n        return response.body is True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def lock(self, key, value, *, flags=None, session):\n        value = encode_value(value, flags)\n        session_id = extract_attr(session, keys=[\"ID\"])\n        response = await self._write(key, value,\n                                     flags=flags,\n                                     acquire=session_id)\n        return response.body is True", "response": "Locks the Key with the given Session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def unlock(self, key, value, *, flags=None, session):\n        value = encode_value(value, flags)\n        session_id = extract_attr(session, keys=[\"ID\"])\n        response = await self._write(key, value,\n                                     flags=flags,\n                                     release=session_id)\n        return response.body is True", "response": "Unlocks the Key with the given Session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _write(self, path, data, *,\n                     flags=None, cas=None, acquire=None, release=None):\n        \"\"\"Sets the key to the given value.\n\n        Returns:\n            bool: ``True`` on success\n        \"\"\"\n        if not isinstance(data, bytes):\n            raise ValueError(\"value must be bytes\")\n        path = \"/v1/kv/%s\" % path\n        response = await self._api.put(\n            path,\n            params={\n                \"flags\": flags,\n                \"cas\": cas,\n                \"acquire\": acquire,\n                \"release\": release\n            },\n            data=data,\n            headers={\"Content-Type\": \"application/octet-stream\"})\n        return response", "response": "Write the key to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def delete(self, key):\n        response = await self._discard(key)\n        return response.body is True", "response": "Deletes the Key\n            from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete all keys with a given prefix of Key.", "response": "async def delete_tree(self, prefix, *, separator=None):\n        \"\"\"Deletes all keys with a prefix of Key.\n\n        Parameters:\n            key (str): Key to delete\n            separator (str): Delete only up to a given separator\n        Response:\n            bool: ``True`` on success\n        \"\"\"\n        response = await self._discard(prefix,\n                                       recurse=True,\n                                       separator=separator)\n        return response.body is True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def delete_cas(self, key, *, index):\n        index = extract_attr(index, keys=[\"ModifyIndex\", \"Index\"])\n        response = await self._discard(key, cas=index)\n        return response.body is True", "response": "Deletes the Key with check - and - set semantics."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, key, value, *, flags=None):\n        self.append({\n            \"Verb\": \"set\",\n            \"Key\": key,\n            \"Value\": encode_value(value, flags, base64=True).decode(\"utf-8\"),\n            \"Flags\": flags\n        })\n        return self", "response": "Sets the Key to the given Value\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the Key to the given Value with check - and - set semantics.", "response": "def cas(self, key, value, *, flags=None, index):\n        \"\"\"Sets the Key to the given Value with check-and-set semantics\n\n        Parameters:\n            key (str): Key to set\n            value (Payload): Value to set, It will be encoded by flags\n            index (ObjectIndex): Index ID\n            flags (int): Flags to set with value\n\n        The Key will only be set if its current modify index matches the\n        supplied Index\n        \"\"\"\n        self.append({\n            \"Verb\": \"cas\",\n            \"Key\": key,\n            \"Value\": encode_value(value, flags, base64=True).decode(\"utf-8\"),\n            \"Flags\": flags,\n            \"Index\": extract_attr(index, keys=[\"ModifyIndex\", \"Index\"])\n        })\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lock(self, key, value, *, flags=None, session):\n        self.append({\n            \"Verb\": \"lock\",\n            \"Key\": key,\n            \"Value\": encode_value(value, flags, base64=True).decode(\"utf-8\"),\n            \"Flags\": flags,\n            \"Session\": extract_attr(session, keys=[\"ID\"])\n        })\n        return self", "response": "Locks the Key with the given Session\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfails the transaction if the Key does not have a modify index equal to the index.", "response": "def check_index(self, key, *, index):\n        \"\"\"Fails the transaction if Key does not have a modify index equal to\n        Index\n\n        Parameters:\n            key (str): Key to check\n            index (ObjectIndex): Index ID\n        \"\"\"\n        self.append({\n            \"Verb\": \"check-index\",\n            \"Key\": key,\n            \"Index\": extract_attr(index, keys=[\"ModifyIndex\", \"Index\"])\n        })\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_session(self, key, *, session=None):\n        self.append({\n            \"Verb\": \"check-session\",\n            \"Key\": key,\n            \"Session\": extract_attr(session, keys=[\"ID\"])\n        })\n        return self", "response": "Fails the transaction if Key is not currently locked by Session\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes the Key with check - and - set semantics.", "response": "def delete_cas(self, key, *, index):\n        \"\"\"Deletes the Key with check-and-set semantics.\n\n        Parameters:\n            key (str): Key to delete\n            index (ObjectIndex): Index ID\n\n        The Key will only be deleted if its current modify index matches\n        the supplied Index\n        \"\"\"\n        self.append({\n            \"Verb\": \"delete-cas\",\n            \"Key\": key,\n            \"Index\": extract_attr(index, keys=[\"ModifyIndex\", \"Index\"])\n        })\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes stored operations on the local datacenter.", "response": "async def execute(self, dc=None, token=None):\n        \"\"\"Execute stored operations\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            token (ObjectID): Token ID\n        Returns:\n            Collection: Results of operations.\n        Raises:\n            TransactionError: Transaction failed\n        \"\"\"\n        token_id = extract_attr(token, keys=[\"ID\"])\n        try:\n            response = await self._api.put(\n                \"/v1/txn\",\n                data=self.operations,\n                params={\n                    \"dc\": dc,\n                    \"token\": token_id\n                })\n        except ConflictError as error:\n            errors = {elt[\"OpIndex\"]: elt for elt in error.value[\"Errors\"]}\n            operations = [op[\"KV\"] for op in self.operations]\n            meta = error.meta\n            raise TransactionError(errors, operations, meta) from error\n        except Exception as error:\n            raise error\n        else:\n            self.operations[:] = []\n\n        results = []\n        for _ in response.body[\"Results\"]:\n            data = _[\"KV\"]\n            if data[\"Value\"] is not None:\n                data[\"Value\"] = decode_value(data[\"Value\"], data[\"Flags\"])\n            results.append(data)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open(self, args=None, keep_log=False):\n        # type: (Optional[Union[str, Sequence[str]]], Union[bool, int]) -> None\n        \"\"\"Open a connection to FORM.\n\n        Open a connection to a new FORM process. The opened connection should\n        be closed by :meth:`close`, which can be guaranteed by use of the\n        \"with\" statement:\n\n        >>> import form\n        >>> with form.open() as formlink:\n        ...     pass  # use formlink ...\n\n        If this method is called for a link object that has an established\n        connection to a FORM process, then the existing connection will be\n        closed and a new connection will be created.\n\n        The optional argument ``args`` is for the FORM command, a string or\n        a sequence of strings. For example '/path/to/form' or ['tform', '-w4'].\n        By default, the value of the environment variable ``$FORM`` is used if\n        set, otherwise 'form' will be used.\n\n        The other argument ``keep_log`` indicates whether the log from FORM is\n        kept and used as detailed information when an error occurs.\n        If the value is >= 2, it specifies the maximum number of lines for\n        the scrollback. The default value is False.\n\n        Note\n        ----\n        In the current implementation, ``keep_log=True`` may cause a dead lock\n        when the listing of the input is enabled and very long input is sent to\n        FORM.\n        \"\"\"\n        if args is None:\n            if 'FORM' in os.environ:\n                args = os.environ['FORM']\n            else:\n                args = 'form'\n        if isinstance(args, string_types):\n            args = shlex.split(args)  # Split the arguments.\n        elif isinstance(args, (list, tuple)):\n            args = list(args)  # As a modifiable mutable object.\n        else:\n            raise TypeError(\"invalid args = {0}\".format(args))\n\n        self.close()\n\n        fd_childin, fd_parentout = os.pipe()\n        fd_parentin, fd_childout = os.pipe()\n        fd_loggingin, fd_loggingout = os.pipe()\n\n        pid = os.fork()\n        if pid:\n            # parent process\n            os.close(fd_childin)\n            os.close(fd_childout)\n            os.close(fd_loggingout)\n\n            parentin = os.fdopen(fd_parentin, 'r')\n            parentout = os.fdopen(fd_parentout, 'w')\n            loggingin = os.fdopen(fd_loggingin, 'r')\n\n            # FORM sends 'pid\\n'.\n            s = parentin.readline()\n            if not s:\n                os.waitpid(pid, 0)\n                parentin.close()\n                parentout.close()\n                loggingin.close()\n                raise IOError('failed to read the first line from FORM')\n            s = s.rstrip()\n            formpid = int(s)\n            # The parent must send 'pid,ppid\\n'.\n            s = s + ',{0}\\n'.format(os.getpid())\n            parentout.write(s)\n            parentout.flush()\n            # FORM sends 'OK' (in init.frm).\n            s = parentin.read(2)\n            if s != 'OK':\n                os.waitpid(pid, 0)\n                parentin.close()\n                parentout.close()\n                loggingin.close()\n                raise IOError('failed to establish the connection to FORM')\n            # Change the prompt.\n            parentout.write('#prompt {0}\\n'.format(self._PROMPT.strip()))\n            # Read the first line of the FORM output.\n            head = loggingin.readline().rstrip()\n\n            set_nonblock(fd_parentin)\n            set_nonblock(fd_loggingin)\n\n            self._closed = False\n            self._head = head\n            if keep_log:\n                if keep_log >= 2:\n                    log = collections.deque(maxlen=keep_log)  # type: Any\n                    self._log = log  # hack typeshed for Python 2\n                    assert self._log is not None\n                    self._log.append(head)\n                else:\n                    self._log = []\n                    self._log.append(head)\n            else:\n                self._log = None\n                # Turn off the listing of the input.\n                parentout.write('#-\\n')\n            self._childpid = pid\n            self._formpid = formpid\n            self._parentin = PushbackReader(parentin)\n            self._parentout = parentout\n            self._loggingin = PushbackReader(loggingin)\n        else:\n            # child process\n\n            # NOTE: Coverage fails to collect data from child processes when\n            #       the os.fork+os._exit pattern is used.\n            #       https://bitbucket.org/ned/coveragepy/issues/310\n\n            os.close(fd_parentout)\n            os.close(fd_parentin)\n            os.close(fd_loggingin)\n            os.dup2(fd_loggingout, sys.__stdout__.fileno())\n\n            args.append('-M')\n            args.append('-pipe')\n            args.append('{0},{1}'.format(fd_childin, fd_childout))\n            args.append(FormLink._INIT_FRM)\n\n            # In Python 3.2, subprocess.Popen() on UNIX changed the default\n            # value for close_fds from False to True, in order to stop leaking\n            # file descriptors. File descriptors to be kept open should be\n            # specified by pass_fds.\n            if sys.version_info[0:2] < (3, 2):\n                subprocess.call(args, shell=False)\n            else:\n                subprocess.call(args, shell=False,\n                                pass_fds=(fd_childin,\n                                          fd_childout,\n                                          fd_loggingout))\n\n            os.close(fd_childin)\n            os.close(fd_childout)\n            os.close(fd_loggingout)\n            os._exit(0)", "response": "Open a connection to the FORM process and return a new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a script to FORM.", "response": "def write(self, script):\n        # type: (str) -> None\n        \"\"\"Send a script to FORM.\n\n        Write the given script to the communication channel to FORM. It could\n        be buffered and so FORM may not execute the sent script until\n        :meth:`flush` or :meth:`read` is called.\n        \"\"\"\n        if self._closed:\n            raise IOError('tried to write to closed connection')\n        script = script.strip()\n        if script:\n            assert self._parentout is not None\n            self._parentout.write(script)\n            self._parentout.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nflushing the channel to FORM.", "response": "def flush(self):\n        # type: () -> None\n        \"\"\"Flush the channel to FORM.\n\n        Flush the communication channel to FORM. Because :meth:`write` is\n        buffered and :meth:`read` is a blocking operation, this method is used\n        for asynchronous execution of FORM scripts.\n        \"\"\"\n        if self._closed:\n            raise IOError('tried to flush closed connection')\n        assert self._parentout is not None\n        self._parentout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, *names):  # type: ignore  # noqa: F811\n        # type: (Any) -> Any\n        r\"\"\"Read results from FORM.\n\n        Wait for a response of FORM to obtain the results specified by\n        the given names and return a corresponding string or (nested) list of\n        strings. Objects to be read from FORM are expressions, $-variables and\n        preprocessor variables.\n\n        ========== =============================\n          name       meaning\n        ========== =============================\n          \"F\"        expression F\n          \"$x\"       $-variable $x\n          \"$x[]\"     factorized $-variable $x\n          \"\\`A'\"     preprocessor variable A\n        ========== =============================\n\n        Note that the communication for the reading is performed within the\n        preprocessor of FORM (i.e., at compile-time), so one may need to write\n        \".sort\" to get the correct result.\n\n        If non-string objects are passed, they are considered as sequences, and\n        the return value becomes a list corresponding to the arguments. If\n        a sequence is passed as the argument to this method, it is guaranteed\n        that the return value is always a list:\n\n        >>> import form\n        >>> f = form.open()\n        >>> f.write('''\n        ...     S a1,...,a3;\n        ...     L F1 = a1;\n        ...     L F2 = a2;\n        ...     L F3 = a3;\n        ...     .sort\n        ... ''')\n\n        >>> f.read(['F1'])\n        ['a1']\n        >>> f.read(['F1', 'F2'])\n        ['a1', 'a2']\n        >>> f.read(['F1', 'F2', 'F3'])\n        ['a1', 'a2', 'a3']\n\n        A more complicated example, which returns a nested list, is\n\n        >>> f.read('F1', ['F2', 'F3'])\n        ['a1', ['a2', 'a3']]\n\n        >>> f.close()\n        \"\"\"\n        if self._closed:\n            raise IOError('tried to read from closed connection')\n\n        if len(names) == 1 and not isinstance(names[0], string_types):\n            names = tuple(names[0])\n            if len(names) == 1:\n                return [self.read(*names)]  # Guarantee to return a list.\n            else:\n                return self.read(*names)\n\n        if any(not isinstance(x, string_types) for x in names):\n            return [self.read(x) for x in names]\n\n        assert self._parentin is not None\n        assert self._parentout is not None\n        assert self._loggingin is not None\n\n        for e in names:\n            if len(e) >= 2 and e[0] == '`' and e[-1] == \"'\":\n                self._parentout.write(\n                    '#toexternal \"{0}{1}\"\\n'.format(e, self._END_MARK))\n            elif len(e) >= 3 and e[0] == '$' and e[-2:] == '[]':\n                # Special syntax \"$x[]\" for factorized $-variables.\n                # NOTE: (1) isfactorized($x) is zero when $x is 0 or $x has\n                #           only one factor even after FactArg is performed.\n                #       (2) `$x[0]' is accessible even if FactArg has not been\n                #           performed. Use `$x[0]' rather than\n                #           `isfactorized($x)`.\n                #       (3) `$x[1]' is not accessible (segfault) with versions\n                #           before Sep  3 2015, if $x has only one factor and\n                #           `$x[0]' gives 1.\n                self._parentout.write((\n                    \"#if `${0}[0]'\\n\"\n                    \"#toexternal \\\"(%$)\\\",${0}[1]\\n\"\n                    \"#do i=2,`${0}[0]'\\n\"\n                    \"#toexternal \\\"*(%$)\\\",${0}[`i']\\n\"\n                    \"#enddo\\n\"\n                    \"#else\\n\"\n                    \"#if termsin(${0})\\n\"\n                    \"#toexternal \\\"%$\\\",${0}\\n\"\n                    \"#else\\n\"\n                    \"#toexternal \\\"(0)\\\"\\n\"\n                    \"#endif\\n\"\n                    \"#endif\\n\"\n                    \"#toexternal \\\"{1}\\\"\\n\"\n                ).format(e[1:-2], self._END_MARK))\n            elif len(e) >= 1 and e[0] == '$':\n                self._parentout.write(\n                    '#toexternal \"%${1}\",{0}\\n'.format(e, self._END_MARK))\n            else:\n                self._parentout.write(\n                    '#toexternal \"%E{1}\",{0}\\n'.format(e, self._END_MARK))\n        self._parentout.write('#redefine FORMLINKLOOPVAR \"0\"')\n        self._parentout.write(self._PROMPT)\n        self._parentout.flush()\n\n        result = []\n        out = self._parentin.read0()\n        out_start = 0  # start position for searching _END_MARK.\n        for _e in names:\n            while True:\n                i = out.find(self._END_MARK, out_start)\n                if i >= 0:\n                    result.append(out[:i])\n                    out = out[i + self._END_MARK_LEN:]\n                    out_start = 0\n                    break\n                out_start = max(len(out) - self._END_MARK_LEN, 0)\n\n                r, _, _ = select.select((self._parentin, self._loggingin),\n                                        (), ())\n                if self._loggingin in r:\n                    s = self._loggingin.read()\n                    if s:\n                        i = s.rfind('\\n')\n                        if i >= 0:\n                            msgs = s[:i].split('\\n')\n                            if self._log is not None:\n                                self._log.extend(msgs)\n                            for msg in msgs:\n                                if (msg.find('-->') >= 0 or\n                                        msg.find('==>') >= 0):\n                                    if self._log:\n                                        msg += '\\n'\n                                        msg += '\\n'.join(self._log)\n                                    self.close()\n                                    raise FormError(msg)\n                        self._loggingin.unread(s[i + 1:])\n                if self._parentin in r:\n                    out += (self._parentin.read()\n                            .replace('\\n', '')\n                            .replace('\\\\', '')\n                            .replace(' ', ''))\n\n        self._parentin.unread(out)\n\n        if len(names) == 0:\n            return None\n        elif len(names) == 1:\n            return result[0]\n        else:\n            return result", "response": "Read the names of the objects in names and return a corresponding string or nested list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the build / revision date as an integer yyyymmdd.", "response": "def _dateversion(self):\n        # type: () -> int\n        \"\"\"Return the build/revision date as an integer \"yyyymmdd\".\"\"\"\n        import re\n        if self._head:\n            ma = re.search(r'(?<=\\()(.*)(?=\\))', self._head)\n            if ma:\n                s = re.split(r'[, ]+', ma.group(0))\n                if len(s) >= 3:\n                    # month\n                    month_names = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')\n                    if s[0] in month_names:\n                        m = month_names.index(s[0]) + 1\n                        # date\n                        if s[1].isdigit():\n                            d = int(s[1])\n                            if 1 <= d <= 31:\n                                # year\n                                if s[2].isdigit():\n                                    y = int(s[2])\n                                    if y >= 1:\n                                        # Return an integer as \"yyyymmdd\".\n                                        return y * 10000 + m * 100 + d\n            raise ValueError('failed to parse \"{0}\"'.format(self._head))\n        raise ValueError('no first line')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompiles the delete sql statement", "response": "def compile(self):\n        \"\"\"Compiles the delete sql statement\"\"\"\n        sql = ''\n        sql += 'DELETE FROM ' + self.dialect.quote_table(self._table)\n        if self._where:\n            sql += ' WHERE ' + self.compile_condition(self._where)\n        if self._order_by:\n            sql += ' ' + self.compile_order_by(self._order_by)\n\n        if self._limit:\n            sql += ' LIMIT ' + self._limit\n        return sql"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear and reset the state of the table and parameters", "response": "def clear(self):\n        \"\"\"Clear and reset to orignal state\"\"\"\n        WhereQuery.clear(self)\n        self._table = None\n        self._parameters = []\n        self._sql = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef challenge_hash(peer_challenge, authenticator_challenge, username):\n    sha_hash = hashlib.sha1()\n    sha_hash.update(peer_challenge)\n    sha_hash.update(authenticator_challenge)\n    sha_hash.update(username)\n    return sha_hash.digest()[:8]", "response": "Return the challenge hash for a given peer challenge and authenticator challenge and username."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef challenge_response(challenge, password_hash):\n    zpassword_hash = password_hash.ljust(21, '\\0')\n\n    response = \"\"\n    des_obj = des.DES(zpassword_hash[0:7])\n    response += des_obj.encrypt(challenge)\n\n    des_obj = des.DES(zpassword_hash[7:14])\n    response += des_obj.encrypt(challenge)\n\n    des_obj = des.DES(zpassword_hash[14:21])\n    response += des_obj.encrypt(challenge)\n    return response", "response": "Return the challenge response for the given challenge and password hash."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_authenticator_response(password, nt_response, peer_challenge, authenticator_challenge, user_name, received_response):\n    my_resppnse = generate_authenticator_response(password, nt_response, peer_challenge, authenticator_challenge, user_name)\n\n    return my_resppnse == received_response", "response": "Check if authenticator response is correct."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setName( self, name ):\n        self._name = projex.text.nativestring(name)\n        self.setText(0, ' '.join(projex.text.words(self._name)))", "response": "Sets the name for this color item to the inputed name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef editColor( self, item, index ):\n        if ( not index ):\n            return\n            \n        newcolor = QColorDialog.getColor(item.colorAt(index-1), self)\n        \n        if ( not newcolor.isValid() ):\n            return\n            \n        endIndex = index + 1\n        if ( self.propogateRight() ):\n            endIndex = self.columnCount()\n        \n        for i in range(index, endIndex):\n            item.setColorAt(i-1, newcolor)", "response": "Prompts the user to choose a new color for the inputed item and column."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the current colors as a saved color set.", "response": "def savedColorSet( self ):\n        \"\"\"\n        Returns the current colors as a saved color set.\n        \n        :return     <XColorSet> || None\n        \"\"\"\n        colorSet = self._colorSet\n        if ( not colorSet ):\n            return None\n        \n        labels = colorSet.colorGroups()\n        for i in range( self.topLevelItemCount() ):\n            item = self.topLevelItem(i)\n            colorName = item.name()\n            for i, color in enumerate(item.colors()):\n                colorSet.setColor(colorName, color, labels[i])\n        \n        return colorSet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setColorSet( self, colorSet ):\n        self.blockSignals(True)\n        self.setUpdatesEnabled(False)\n        \n        self.clear()\n        \n        self._colorSet = colorSet\n        \n        if ( colorSet ):\n            labels = colorSet.colorGroups()\n            self.setHeaderLabels( [colorSet.name()] + labels )\n            self.setColumnCount( 1 + len(labels) )\n            \n            for colorName in colorSet.colorNames():\n                item = XColorTreeWidgetItem(colorName, \n                                            colorSet.colors(colorName))\n                                            \n                self.addTopLevelItem(item)\n            \n        self.setUpdatesEnabled(True)\n        self.blockSignals(False)", "response": "Sets the color set for this tree item."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the number of columns used for this tree widget updating the \\ column resizing modes to stretch the first column.", "response": "def setColumnCount( self, count ):\n        \"\"\"\n        Sets the number of columns used for this tree widget, updating the \\\n        column resizing modes to stretch the first column.\n        \n        :param      count | <int>\n        \"\"\"\n        super(XColorTreeWidget, self).setColumnCount(count)\n        \n        header = self.header()\n        header.setResizeMode(0, header.Stretch)\n        for i in range(1, count):\n            header.setResizeMode(i, header.Fixed)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setQuickColor( self, color ):\n        colorset = XPaletteColorSet()\n        colorset.setPalette(QPalette(color))\n        self.setColorSet(colorset)", "response": "Sets the quick color for the given palette."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\noverloading the base QGraphicsItem itemChange method to block user ability to move along the y - axis.", "response": "def itemChange( self, change, value ):\n        \"\"\"\n        Overloads the base QGraphicsItem itemChange method to block user ability\r\n        to move along the y-axis.\n        \n        :param      change      <int>\n        :param      value       <variant>\n        \n        :return     <variant>\n        \"\"\"\n        # only operate when it is a visible, geometric change\n        if not (self.isVisible() and change == self.ItemPositionChange):\n            return super(XGanttViewItem, self).itemChange( change, value )\n        \r\n        if self.isSyncing():\r\n            return super(XGanttViewItem, self).itemChange(change, value)\r\n        \n        scene = self.scene()\n        # only operate when we have a scene\n        if not scene:\n            return super(XNode, self).itemChange( change, value )\n        \n        point = value.toPointF()\n        point.setY(self.pos().y())\n        \r\n        # create the return value\n        new_value = wrapVariant(point)\n        \n        # call the base method to operate on the new point\n        return super(XGanttViewItem, self).itemChange(change, new_value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mouseReleaseEvent(self, event):\r\n        super(XGanttViewItem, self).mouseReleaseEvent(event)\r\n        \r\n        if not self.flags() & self.ItemIsMovable:\r\n            return\r\n        \r\n        # force the x position to snap to the nearest date\r\n        scene = self.scene()\r\n        \r\n        if scene:\r\n            gantt  = scene.ganttWidget()\r\n            curr_x = self.pos().x() + gantt.cellWidth() / 2.0\r\n            new_x  = curr_x - curr_x % gantt.cellWidth()\r\n            self.setPos(new_x, self.pos().y())\r\n        \r\n        # look for date based times\r\n        gantt = self.scene().ganttWidget()\r\n        \r\n        # determine hour/minute information\r\n        if gantt.timescale() in (gantt.Timescale.Minute,\r\n                                 gantt.Timescale.Hour,\r\n                                 gantt.Timescale.Day):\r\n            dstart = self.scene().datetimeAt(self.pos().x())\r\n            dend = self.scene().datetimeAt(self.pos().x() + self.rect().width())\r\n            dend.addSecs(-60)\r\n        else:\r\n            dstart = self.scene().dateAt(self.pos().x())\r\n            dend   = self.scene().dateAt(self.pos().x() + self.rect().width())\r\n            dend   = dend.addDays(-1)\r\n        \r\n        item = self._treeItem()\r\n        if item:\r\n            item.viewChanged(dstart, dend)", "response": "Updates the position of the item based on the current changes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npaints this item to the system.", "response": "def paint( self, painter, option, widget ):\r\n        \"\"\"\r\n        Paints this item to the system.\r\n        \r\n        :param      painter | <QPainter>\r\n                    option  | <QStyleOptionGraphicItem>\r\n                    widget  | <QWidget>\r\n        \"\"\"\n        style       = self.itemStyle()\n        ItemStyle   = self.treeItem().ItemStyle\n        \n        if ( style == ItemStyle.Group ):\n            self.paintGroup( painter )\n        \n        elif ( style == ItemStyle.Milestone ):\n            self.paintMilestone( painter )\n        \n        else:\n            self.paintNormal( painter )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npainting the group item.", "response": "def paintGroup( self, painter ):\n        \"\"\"\n        Paints this item as the group look.\n        \n        :param      painter | <QPainter>\n        \"\"\"\n        # generate the rect\r\n        rect    = self.rect()\r\n        \n        padding = self.padding()\n        gantt   = self.scene().ganttWidget()\n        cell_w  = gantt.cellWidth()\n        cell_h  = gantt.cellHeight()\n        \r\n        x       = 0\r\n        y       = self.padding()\r\n        w       = rect.width()\r\n        h       = rect.height() - (padding + 1)\r\n        \r\n        # grab the color options\r\n        color       = self.color()\r\n        alt_color   = self.alternateColor()\r\n        \r\n        if ( self.isSelected() ):\r\n            color       = self.highlightColor()\r\n            alt_color   = self.alternateHighlightColor()\r\n        \r\n        # create the background brush\r\n        gradient = QLinearGradient()\r\n        gradient.setStart(0, 0)\r\n        gradient.setFinalStop(0, h)\r\n        \r\n        gradient.setColorAt(0,   color)\r\n        gradient.setColorAt(0.8, alt_color)\r\n        gradient.setColorAt(1,   color)\n        \r\n        painter.setPen(self.borderColor())\r\n        painter.setBrush(QBrush(gradient))\n        \n        pen = painter.pen()\n        pen.setWidthF(0.5)\n        painter.setPen(pen)\n        painter.setRenderHint( painter.Antialiasing )\n        \r\n        path = QPainterPath()\n        path.moveTo(x - cell_w / 4.0, y)\n        path.lineTo(w + cell_w / 4.0, y)\n        path.lineTo(w + cell_w / 4.0, y + h / 2.0)\n        path.lineTo(w, h)\n        path.lineTo(w - cell_w / 4.0, y + h / 2.0)\n        path.lineTo(x + cell_w / 4.0, y + h / 2.0)\n        path.lineTo(x, h)\n        path.lineTo(x - cell_w / 4.0, y + h / 2.0)\n        path.lineTo(x - cell_w / 4.0, y)\n        \n        painter.drawPath(path)\r\n        \r\n        # create the progress brush\r\n        if ( self.showProgress() ):\r\n            gradient = QLinearGradient()\r\n            gradient.setStart(0, 0)\r\n            gradient.setFinalStop(0, h)\r\n            gradient.setColorAt(0, self.progressColor())\r\n            gradient.setColorAt(0.8, self.alternateProgressColor())\r\n            gradient.setColorAt(1, self.progressColor())\r\n            \r\n            prog_w = (w - 4) * (self._percentComplete/100.0)\r\n            \r\n            painter.setPen(Qt.NoPen)\r\n            painter.setBrush(QBrush(gradient))\r\n            painter.drawRect(x, y, prog_w, y + h / 2.0)\n        \n        # draw the text on this item\r\n        if ( self.text() ):\r\n            painter.setPen(self.textColor())\r\n            painter.drawText(x, y, w, h, Qt.AlignCenter, self.text())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npainting the milestone for this item.", "response": "def paintMilestone( self, painter ):\n        \"\"\"\n        Paints this item as the milestone look.\n        \n        :param      painter | <QPainter>\n        \"\"\"\n        # generate the rect\r\n        rect    = self.rect()\r\n        \n        padding = self.padding()\n        gantt   = self.scene().ganttWidget()\n        cell_w  = gantt.cellWidth()\n        cell_h  = gantt.cellHeight()\n        \r\n        x       = rect.width() - cell_w\r\n        y       = self.padding()\r\n        w       = cell_w\r\n        h       = rect.height() - padding - 2\r\n        \r\n        # grab the color options\r\n        color       = self.color()\r\n        alt_color   = self.alternateColor()\r\n        \r\n        if ( self.isSelected() ):\r\n            color       = self.highlightColor()\r\n            alt_color   = self.alternateHighlightColor()\r\n        \r\n        # create the background brush\r\n        gradient = QLinearGradient()\r\n        gradient.setStart(0, 0)\r\n        gradient.setFinalStop(0, h)\r\n        \r\n        gradient.setColorAt(0,   color)\r\n        gradient.setColorAt(0.8, alt_color)\r\n        gradient.setColorAt(1,   color)\n        \r\n        painter.setPen(self.borderColor())\r\n        painter.setBrush(QBrush(gradient))\n        \n        pen = painter.pen()\n        pen.setWidthF(0.5)\n        painter.setPen(pen)\n        painter.setRenderHint( painter.Antialiasing )\n        \r\n        path = QPainterPath()\n        path.moveTo(x - cell_w / 3.0, y + h / 2.0)\n        path.lineTo(x, y)\n        path.lineTo(x + cell_w / 3.0, y + h / 2.0)\n        path.lineTo(x, y + h)\n        path.lineTo(x - cell_w / 3.0, y + h / 2.0)\n        \n        painter.drawPath(path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npainting this item as the normal look.", "response": "def paintNormal( self, painter ):\n        \"\"\"\n        Paints this item as the normal look.\n        \n        :param      painter | <QPainter>\n        \"\"\"\r\n        # generate the rect\r\n        rect    = self.rect()\r\n        \r\n        x       = 0\r\n        y       = self.padding()\r\n        w       = rect.width()\r\n        h       = rect.height() - (2 * self.padding()) - 1\r\n        radius  = self.borderRadius()\r\n        \r\n        # grab the color options\r\n        color       = self.color()\r\n        alt_color   = self.alternateColor()\r\n        \r\n        if ( self.isSelected() ):\r\n            color       = self.highlightColor()\r\n            alt_color   = self.alternateHighlightColor()\r\n        \r\n        # create the background brush\r\n        gradient = QLinearGradient()\r\n        gradient.setStart(0, 0)\r\n        gradient.setFinalStop(0, h)\r\n        \r\n        gradient.setColorAt(0,   color)\r\n        gradient.setColorAt(0.8, alt_color)\r\n        gradient.setColorAt(1,   color)\r\n        painter.setPen(self.borderColor())\r\n        \r\n        if ( radius ):\r\n            painter.setRenderHint(painter.Antialiasing)\r\n            pen = painter.pen()\r\n            pen.setWidthF(0.5)\r\n            painter.setPen(pen)\r\n        \r\n        painter.setBrush(QBrush(gradient))\r\n        painter.drawRoundedRect(x, y, w, h, radius, radius)\r\n        \r\n        # create the progress brush\r\n        if ( self.showProgress() ):\r\n            gradient = QLinearGradient()\r\n            gradient.setStart(0, 0)\r\n            gradient.setFinalStop(0, h)\r\n            gradient.setColorAt(0, self.progressColor())\r\n            gradient.setColorAt(0.8, self.alternateProgressColor())\r\n            gradient.setColorAt(1, self.progressColor())\r\n            \r\n            prog_w = (w - 4) * (self._percentComplete/100.0)\r\n            radius -= 2\r\n            \r\n            painter.setPen(Qt.NoPen)\r\n            painter.setBrush(QBrush(gradient))\r\n            painter.drawRoundedRect(x + 2, y + 2, prog_w, h - 4, radius, radius)\r\n        \r\n        # draw the text on this item\r\n        if ( self.text() ):\r\n            painter.setPen(self.textColor())\r\n            painter.drawText(x, y, w, h, Qt.AlignCenter, self.text())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setColor( self, color ):\r\n        self._color = QColor(color)\r\n        self.setAlternateColor(self._color.darker(110))", "response": "Sets the color for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setHighlightColor( self, color ):\r\n        self._highlightColor = QColor(color)\r\n        self.setAlternateHighlightColor(self._highlightColor.darker(110))", "response": "Sets the primary color used for highlighting this item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the color that will be used for the progress bar for this item.", "response": "def setProgressColor( self, color ):\r\n        \"\"\"\r\n        Sets the color that for the progress bar for this item.\r\n        \r\n        :param      color | <QColor>\r\n        \"\"\"\r\n        self._progressColor = QColor(color)\r\n        self.setAlternateProgressColor(self._progressColor.darker(110))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart the process for autoloading this item when it becomes visible within the tree.", "response": "def autoload(self, state=True):\r\n        \"\"\"\r\n        Begins the process for autoloading this item when it becomes visible\r\n        within the tree.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        if state and not self._timer:\r\n            self._timer = QtCore.QTimer()\r\n            self._timer.setInterval(500)\r\n            self._timer.timeout.connect(self.testAutoload)\r\n        if state and self._timer and not self._timer.isActive():\r\n            self._timer.start()\r\n        elif not state and self._timer and self._timer.isActive():\r\n            self._timer.stop()\r\n            del self._timer\r\n            self._timer = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting loading the item.", "response": "def startLoading(self):\r\n        \"\"\"\r\n        Updates this item to mark the item as loading.  This will create\r\n        a QLabel with the loading ajax spinner to indicate that progress\r\n        is occurring.\r\n        \"\"\"\r\n        if self._loading:\r\n            return False\r\n        \r\n        tree = self.treeWidget()\r\n        if not tree:\r\n            return\r\n        \r\n        self._loading = True\r\n        self.setText(0, '')\r\n        \r\n        # create the label for this item\r\n        lbl = QtGui.QLabel(self.treeWidget())\r\n        lbl.setMovie(XLoaderWidget.getMovie())\r\n        lbl.setAlignment(QtCore.Qt.AlignCenter)\r\n        tree.setItemWidget(self, 0, lbl)\r\n        \r\n        try:\r\n            tree.loadStarted.emit(self)\r\n        except AttributeError:\r\n            pass\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new editor for the given index.", "response": "def createEditor(self, parent, option, index):\r\n        \"\"\"\r\n        Creates a new editor for the given index parented to the inputed widget.\r\n        \r\n        :param      parent | <QtGui.QWidget>\r\n                    option | <QtGui.QStyleOption>\r\n                    index  | <QtGui.QModelIndex>\r\n        \r\n        :return     <QWidget> || None\r\n        \"\"\"\r\n        if index.column() != 1:\r\n            return None\r\n        \r\n        editor = QtGui.QComboBox(parent)\r\n        \r\n        # load the levels\r\n        items = sorted(XLoggerWidget.LoggingMap.items())\r\n        for i, (level, data) in enumerate(items):\r\n            editor.addItem(projex.text.pretty(data[0]))\r\n            editor.setItemData(i, wrapVariant(level))\r\n        \r\n        return editor"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the editor with the model data.", "response": "def setEditorData(self, editor, index):\r\n        \"\"\"\r\n        Updates the editor with the model data.\r\n        \r\n        :param      editor | <QtGui.QWidget>\r\n                    index  | <QtGui.QModelIndex>\r\n        \"\"\"\r\n        data = unwrapVariant(index.data())\r\n        editor.setCurrentIndex(editor.findText(data))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setModelData(self, editor, model, index):\r\n        value = editor.currentText()\r\n        model.setData(index, wrapVariant(value))", "response": "Updates the item with the new data value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef command_list_arscons(self):\n        '''command line as list'''\n        cmd = []\n        cmd += ['scons']\n\n        if self.arduino_home:\n            cmd += ['ARDUINO_HOME=' + self.arduino_home]\n#        if os.environ.get('ARDUINO_HOME', None):\n#            cmd += ['ARDUINO_HOME=' + os.environ.get('ARDUINO_HOME')]\n\n        if self.avr_home:\n            cmd += ['AVR_HOME=' + self.avr_home]\n\n        if self.board:\n            cmd += ['ARDUINO_BOARD=' + self.board]\n\n        if self.hwpack:\n            cmd += ['ARDUINO_HARDWARE_PACKAGE=' + self.hwpack]\n\n        if self.mcu:\n            cmd += ['MCU=' + self.mcu]\n        if self.f_cpu:\n            cmd += ['F_CPU=' + str(self.f_cpu)]\n\n        if self.ver:\n            cmd += ['ARDUINO_VER=' + self.ver]\n\n        if self.extra_lib:\n            cmd += ['EXTRA_LIB=' + self.extra_lib]\n\n        return cmd", "response": "command line as list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emitCurrentChanged(self):\n        if not self.signalsBlocked():\n            self.currentIndexChanged.emit(self.currentIndex())\n            self.currentUrlChanged.emit(self.currentUrl())\r\n            \r\n            self.canGoBackChanged.emit(self.canGoBack())\r\n            self.canGoForwardChanged.emit(self.canGoForward())", "response": "Emits the current index changed signal provided signals are not blocked."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngo up one level if possible and returns the url at the current level.", "response": "def goBack(self):\n        \"\"\"\n        Goes up one level if possible and returns the url at the current level.\n        If it cannot go up, then a blank string will be returned.\n        \n        :return     <str>\n        \"\"\"\r\n        if not self.canGoBack():\r\n            return ''\n        \r\n        self._blockStack = True\n        self._index -= 1\n        self.emitCurrentChanged()\r\n        self._blockStack = False\n        return self.currentUrl()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngoing to the home url.", "response": "def goHome(self):\n        \"\"\"\n        Goes to the home url.  If there is no home url specifically set, then \\\n        this will go to the first url in the history.  Otherwise, it will \\\n        look to see if the home url is in the stack and go to that level, if \\\n        the home url is not found, then it will be pushed to the top of the \\\n        stack using the push method.\n        \"\"\"\r\n        if not self.canGoBack():\r\n            return ''\r\n        \r\n        if self.homeUrl():\r\n            self.push(self.homeUrl())\r\n        \r\n        self._blockStack = True\r\n        self._index = 0\r\n        self.emitCurrentChanged()\r\n        self._blockStack = False\r\n        return self.currentUrl()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngoing down one level if possible and returns the url at the current \\ level.", "response": "def goForward(self):\n        \"\"\"\n        Goes down one level if possible and returns the url at the current \\\n        level.  If it cannot go down, then a blank string will be returned.\n        \n        :return     <str>\n        \"\"\"\n        if not self.canGoForward():\r\n            return ''\n        \r\n        self._blockStack = True\n        self._index += 1\n        self.emitCurrentChanged()\r\n        self._blockStack = False\n        return self.currentUrl()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef indexOf(self, url):\n        for i, (m_url, _) in enumerate(self._stack):\r\n            if m_url == url:\r\n                return i\n        return -1", "response": "Returns the index of the url in the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef push(self, url, title=''):\n        # ignore refreshes of the top level\n        if self.currentUrl() == url or self._blockStack:\n            return False\n        \r\n        self._blockStack = True\r\n        \r\n        self._stack = self._stack[:self._index+1]\r\n        self._stack.append((nativestring(url), nativestring(title)))\r\n        \r\n        over = len(self._stack) - self.maximum()\r\n        if over > 0:\r\n            self._stack = self._stack[over:]\r\n        \r\n        self._index = len(self._stack) - 1\r\n        \r\n        self.canGoBackChanged.emit(self.canGoBack())\r\n        self.canGoForwardChanged.emit(self.canGoForward())\r\n        \n        self._blockStack = False\n        return True", "response": "Pushes the url into the history stack at the current index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the current index for the history stack.", "response": "def setCurrentIndex(self, index):\n        \"\"\"\n        Sets the current index for the history stack.\n        \n        :param      index | <int>\n        \n        :return     <bool> | success\n        \"\"\"\n        if 0 <= index and index < len(self._stack):\r\n            self._blockStack = True\n            self._index = index\n            self.emitCurrentChanged()\r\n            self._blockStack = False\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef urlAt(self, index):\n        if 0 <= index and index < len(self._stack):\n            return self._stack[index][0]\n        return ''", "response": "Returns the url at the inputed index wihtin the stack."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef titleOf(self, url):\r\n        for m_url, m_title in self._stack:\r\n            if url == m_url:\r\n                return m_title\r\n        \r\n        return nativestring(url).split('/')[-1]", "response": "Returns the title for the inputed url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def create(self, session, *, dc=None):\n        response = await self._api.put(\n            \"/v1/session/create\",\n            data=session,\n            params={\"dc\": dc})\n        return response.body", "response": "Creates a new session in the agent s local datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def destroy(self, session, *, dc=None):\n        session_id = extract_attr(session, keys=[\"ID\"])\n        response = await self._api.put(\"/v1/session/destroy\", session_id,\n                                       params={\"dc\": dc})\n        return response.body is True", "response": "Destroys a given session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nquerying a given session and returns the information for that session.", "response": "async def info(self, session, *, dc=None, watch=None, consistency=None):\n        \"\"\"Queries a given session\n\n        Parameters:\n            session (ObjectID): Session ID\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            ObjectMeta: where value is the queried session\n        Raises:\n            NotFound: session is absent\n\n        Returns the requested session information within a given datacenter.\n\n        It returns a mapping like this::\n\n            {\n                \"LockDelay\": datetime.timedelta(0, 15),\n                \"Checks\": [\n                    \"serfHealth\"\n                ],\n                \"Node\": \"foobar\",\n                \"ID\": \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n                \"CreateIndex\": 1086449\n            }\n        \"\"\"\n        session_id = extract_attr(session, keys=[\"ID\"])\n        response = await self._api.get(\"/v1/session/info\", session_id,\n                                       watch=watch,\n                                       consistency=consistency,\n                                       params={\"dc\": dc})\n        try:\n            result = response.body[0]\n        except IndexError:\n            meta = extract_meta(response.headers)\n            raise NotFound(\"No session for %r\" % session_id, meta=meta)\n        return consul(result, meta=extract_meta(response.headers))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenews a TTL - based session.", "response": "async def renew(self, session, *, dc=None):\n        \"\"\"Renews a TTL-based session\n\n        Parameters:\n            session (ObjectID): Session ID\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n        Returns:\n            ObjectMeta: where value is session\n        Raises:\n            NotFound: session is absent\n\n        The response looks like this::\n\n            {\n                \"LockDelay\": datetime.timedelta(0, 15),\n                \"Checks\": [\n                    \"serfHealth\"\n                ],\n                \"Node\": \"foobar\",\n                \"ID\": \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\",\n                \"CreateIndex\": 1086449\n                \"Behavior\": \"release\",\n                \"TTL\": datetime.timedelta(0, 15)\n            }\n\n        .. note:: Consul MAY return a TTL value higher than the one\n                  specified during session creation. This indicates\n                  the server is under high load and is requesting\n                  clients renew less often.\n        \"\"\"\n        session_id = extract_attr(session, keys=[\"ID\"])\n        response = await self._api.put(\"/v1/session/renew\", session_id,\n                                       params={\"dc\": dc})\n        try:\n            result = response.body[0]\n        except IndexError:\n            meta = extract_meta(response.headers)\n            raise NotFound(\"No session for %r\" % session_id, meta=meta)\n        return consul(result, meta=extract_meta(response.headers))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deconstructible(*args, path=None):\n    def decorator(klass):\n        def __new__(cls, *args, **kwargs):\n            # We capture the arguments to make returning them trivial\n            obj = super(klass, cls).__new__(cls)\n            obj._constructor_args = (args, kwargs)\n            return obj\n        klass.__new__ = staticmethod(__new__)\n\n        return klass\n\n    if not args:\n        return decorator\n\n    return decorator(*args)", "response": "Decorator that returns a class that can be serialized by the migrations subsystem."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addItems(self, menus, processed=None):\r\n        if processed is None:\r\n            processed = []\r\n        \r\n        for menu in menus:\r\n            for action in menu.actions():\r\n                # since we can have 1 action in more than 1 submenu, we\r\n                # will want to make sure we're only adding a unique one\r\n                # so we don't have duplicates\r\n                text = nativestring(action.text())\r\n                if text in processed or action.isSeparator():\r\n                    continue\r\n                \r\n                processed.append(text)\r\n                \r\n                if text and unwrapVariant(action.data()) != 'menu':\r\n                    item = XTreeWidgetItem(self._completer, [text])\r\n                    item.setFixedHeight(20)\r\n                    item.setIcon(0, action.icon())\r\n                    item.setToolTip(0, action.toolTip())\r\n                    item.setData(0, Qt.UserRole, wrapVariant(action))", "response": "Adds items to the completion tree from the menu."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the text from the search edit.", "response": "def clear(self):\r\n        \"\"\"\r\n        Clears the text from the search edit.\r\n        \"\"\"\r\n        self._searchEdit.blockSignals(True)\r\n        self._searchEdit.setText('')\r\n        self._searchEdit.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eventFilter(self, object, event):\r\n        if event.type() == event.KeyPress:\r\n            if event.key() == Qt.Key_Escape:\r\n                self._completer.hide()\r\n                self._completer.setCurrentItem(None)\r\n\r\n            elif event.key() in (Qt.Key_Enter, Qt.Key_Return):\r\n                tree = self._completer\r\n                item = tree.currentItem() or tree.itemAt(0, 0)\r\n                self.triggerItem(item)\r\n\r\n            self._searchEdit.keyPressEvent(event)\r\n\r\n        return False", "response": "Filter out the related items for the given event."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filterOptions(self, text):\r\n        if not text:\r\n            self._completer.hide()\r\n            self._completer.setCurrentItem(None)\r\n            return\r\n\r\n        # block the signals\r\n        self._completer.setUpdatesEnabled(False)\r\n        self._completer.blockSignals(True)\r\n\r\n        # initialize the actions\r\n        menu = self.parent()\r\n        if not self._initialized:\r\n            self.addItems([menu] + menu.findChildren(QMenu))\r\n            self._initialized = True\r\n\r\n        # filter the actions in the search view\r\n        visible_count = 0\r\n        item_count = self._completer.topLevelItemCount()\r\n        for i in range(item_count):\r\n            item = self._completer.topLevelItem(i)\r\n            check = nativestring(item.text(0)).lower()\r\n            hidden = not nativestring(text).lower() in check\r\n            item.setHidden(hidden)\r\n            visible_count += 1 if not hidden else 0\r\n\r\n        # show the popup widget if it is not visible\r\n        if not self._completer.isVisible():\r\n            point = QPoint(-1, self.height())\r\n            width = menu.width()\r\n            height = menu.height() - self.height() - 1\r\n            height = max(height, 22 * min(visible_count, 5))\r\n            \r\n            self._completer.move(self.mapToGlobal(point))\r\n            self._completer.resize(width, height)\r\n            self._completer.show()\r\n\r\n        # restore signals\r\n        self._completer.setUpdatesEnabled(True)\r\n        self._completer.blockSignals(False)", "response": "Filters the searched actions based on the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef triggerItem(self, item):\r\n        if not item:\r\n            return\r\n        \r\n        # emit the trigger action\r\n        self._triggerText = item.text(0)\r\n        self._completer.hide()\r\n        self._completer.setCurrentItem(None)\r\n        self.parent().hide()\r\n        \r\n        # trigger the action\r\n        unwrapVariant(item.data(0, Qt.UserRole)).trigger()", "response": "Triggers the item by calling its action s toggled state to display or hide the dock panel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addMenu(self, submenu):\n        # create a new submenu based on a string input\n        if not isinstance(submenu, QMenu):\n            title = nativestring(submenu)\n            submenu = XMenu(self)\n            submenu.setTitle(title)\n            submenu.setShowTitle(self.showTitle())\n            super(XMenu, self).addMenu(submenu)\n        else:\n            super(XMenu, self).addMenu(submenu)\r\n        \r\n        submenu.menuAction().setData(wrapVariant('menu'))\r\n        \r\n        return submenu", "response": "Adds a new submenu to this menu."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a section to the menu.", "response": "def addSection(self, section):\r\n        \"\"\"\r\n        Adds a section to this menu.  A section will create a label for the\r\n        menu to separate sections of the menu out.\r\n        \r\n        :param      section | <str>\r\n        \"\"\"\r\n        label = QLabel(section, self)\r\n        label.setMinimumHeight(self.titleHeight())\r\n        \r\n        # setup font\r\n        font = label.font()\r\n        font.setBold(True)\r\n        \r\n        # setup palette\r\n        palette = label.palette()\r\n        palette.setColor(palette.WindowText, palette.color(palette.Mid))\r\n        \r\n        # setup label\r\n        label.setFont(font)\r\n        label.setAutoFillBackground(True)\r\n        label.setPalette(palette)\r\n        \r\n        # create the widget action\r\n        action = QWidgetAction(self)\r\n        action.setDefaultWidget(label)\r\n        self.addAction(action)\r\n        \r\n        return action"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadjusting the minimum width for this item based on the font metrics of the menu s title.", "response": "def adjustMinimumWidth( self ):\n        \"\"\"\n        Updates the minimum width for this menu based on the font metrics \\\n        for its title (if its shown).  This method is called automatically \\\n        when the menu is shown.\n        \"\"\"\n        if not self.showTitle():\n            return\n        \n        metrics = QFontMetrics(self.font())\n        width   = metrics.width(self.title()) + 20\n        \n        if self.minimumWidth() < width:\n            self.setMinimumWidth(width)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear out the advanced action map.", "response": "def clearAdvancedActions( self ):\n        \"\"\"\n        Clears out the advanced action map.\n        \"\"\"\n        self._advancedMap.clear()\n        margins     = list(self.getContentsMargins())\n        margins[2]  = 0\n        self.setContentsMargins(*margins)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the custom data for the given key.", "response": "def customData( self, key, default = None ):\n        \"\"\"\n        Returns data that has been stored on this menu.\n        \n        :param      key     | <str>\n                    default | <variant>\n        \n        :return     <variant>\n        \"\"\"\n        key     = nativestring(key)\n        menu    = self\n        while (not key in menu._customData and \\\n               isinstance(menu.parent(), XMenu)):\n            menu = menu.parent()\n        \n        return menu._customData.get(nativestring(key), default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverloads the paint event for this menu based on its show title property.", "response": "def paintEvent( self, event ):\n        \"\"\"\n        Overloads the paint event for this menu to draw its title based on its \\\n        show title property.\n        \n        :param      event | <QPaintEvent>\n        \"\"\"\n        super(XMenu, self).paintEvent(event)\n        \n        if self.showTitle():\n            with XPainter(self) as painter:\n                palette = self.palette()\n                \n                painter.setBrush(palette.color(palette.Button))\n                painter.setPen(Qt.NoPen)\n                painter.drawRect(1, 1, self.width() - 2, 22)\n                \n                painter.setBrush(Qt.NoBrush)\n                painter.setPen(palette.color(palette.ButtonText))\n                painter.drawText(1, 1, self.width() - 2, 22, \n                                 Qt.AlignCenter, self.title())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rebuildButtons(self):\n        for btn in self.findChildren(XAdvancedButton):\n            btn.close()\n            btn.setParent(None)\n            btn.deleteLater()\n        \n        for standard, advanced in self._advancedMap.items():\n            rect    = self.actionGeometry(standard)\n            btn     = XAdvancedButton(self)\n            btn.setFixedWidth(22)\n            btn.setFixedHeight(rect.height())\n            btn.setDefaultAction(advanced)\n            btn.setAutoRaise(True)\n            btn.move(rect.right() + 1, rect.top())\r\n            btn.show()\n            \n            if btn.icon().isNull():\n                btn.setIcon(QIcon(resources.find('img/advanced.png')))\n            \n            btn.clicked.connect(self.acceptAdvanced)", "response": "Rebuilds the buttons for the advanced actions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setAdvancedAction(self, standardAction, advancedAction):\n        if advancedAction:\n            self._advancedMap[standardAction] = advancedAction\n            margins     = list(self.getContentsMargins())\n            margins[2]  = 22\n            self.setContentsMargins(*margins)\n            \n        elif standardAction in self._advancedMap:\n            self._advancedMap.pop(standardAction)\n            if not self._advancedMap:\n                margins     = list(self.getContentsMargins())\n                margins[2]  = 22\n                self.setContentsMargins(*margins)", "response": "Sets the advanced action for the inputed standard action."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setShowTitle( self, state ):\n        self._showTitle = state\n        \n        margins = list(self.getContentsMargins())\n        if state:\n            margins[1] = self.titleHeight()\n        else:\n            margins[1] = 0\n        \n        self.setContentsMargins(*margins)", "response": "Sets whether or not the title for this popup should be displayed in the \\ jsMenu \\ s main."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noverloads the showEvent method to update the advanced action buttons to match their corresponding standard action location.", "response": "def showEvent(self, event):\n        \"\"\"\n        Overloads the set visible method to update the advanced action buttons \\\n        to match their corresponding standard action location.\n        \n        :param      state | <bool>\n        \"\"\"\r\n        super(XMenu, self).showEvent(event)\n        \r\n        self.adjustSize()\n        self.adjustMinimumWidth()\n        self.rebuildButtons()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef showActionToolTip(self):\n        if ( not self.isVisible() ):\n            return\n            \n        geom  = self.actionGeometry(self._toolTipAction)\n        pos   = self.mapToGlobal(QPoint(geom.left(), geom.top()))\n        pos.setY(pos.y() + geom.height())\n        \n        tip   = nativestring(self._toolTipAction.toolTip()).strip().strip('.')\n        text  = nativestring(self._toolTipAction.text()).strip().strip('.')\n        \n        # don't waste time showing the user what they already see\n        if ( tip == text ):\n            return\n        \n        QToolTip.showText(pos, self._toolTipAction.toolTip())", "response": "Shows the tool tip of the action that is currently being hovered over."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts the timer to hover over an action for the current tool tip.", "response": "def startActionToolTip( self, action ):\r\n        \"\"\"\r\n        Starts the timer to hover over an action for the current tool tip.\r\n        \r\n        :param      action | <QAction>\r\n        \"\"\"\r\n        self._toolTipTimer.stop()\r\n        QToolTip.hideText()\r\n        \r\n        if not action.toolTip():\r\n            return\r\n        \r\n        self._toolTipAction = action\r\n        self._toolTipTimer.start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fromString( parent, xmlstring, actions = None ):\n        try:\n            xdata = ElementTree.fromstring(xmlstring)\n            \n        except ExpatError, e:\n            logger.exception(e)\n            return None\n        \n        return XMenu.fromXml(parent, xdata, actions)", "response": "Loads the xml string as xml data and calls the fromXml method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an XMenu from the inputed xml data and returns the resulting XMenu.", "response": "def fromXml( parent, xml, actions = None ):\n        \"\"\"\n        Generates an XMenu from the inputed xml data and returns the resulting \\\n        menu.  If no action dictionary is supplied, it will be generated based \\\n        on the parents actions.\n        \n        :param      parent      | <QWidget>\n                    xml         | <xml.etree.ElementTree.Element>\n                    actions     | {<str> name: <QAction>, } || None\n        \n        :return     <XMenu> || None\n        \"\"\"\n        # generate the actions off the parent\n        if ( actions is None ):\n            actions = {}\n            for action in parent.actions():\n                key = nativestring(action.objectName())\n                if not key:\n                    key = nativestring(action.text())\n                \n                if not key:\n                    continue\n                \n                actions[key] = action\n        \n        # create a new menu\n        menu = XMenu(parent)\n        menu.setIcon(QIcon(resources.find('img/folder.png')))\n        menu.setTitle(xml.get('title', '')) \n        \n        for xaction in xml:\n            if xaction.tag == 'separator':\n                menu.addSeparator()\n            elif xaction.tag == 'menu':\n                menu.addMenu(XMenu.fromXml(menu, xaction, actions))\n            else:\n                action = actions.get(xaction.get('name', ''))\n                if action:\n                    menu.addAction(action)\n        \n        return menu"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addItem( self, item ):\r\n        result = super(XCalendarScene, self).addItem(item)\r\n        \r\n        if ( isinstance(item, XCalendarItem) ):\r\n            item.rebuild()\r\n        \r\n        return result", "response": "Adds the item to the scene and redraws the item if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the date at the given point.", "response": "def dateAt( self, point ):\r\n        \"\"\"\r\n        Returns the date at the given point.\r\n        \r\n        :param      point | <QPoint>\r\n        \"\"\"\r\n        for date, data in self._dateGrid.items():\r\n            if ( data[1].contains(point) ):\r\n                return QDate.fromJulianDay(date)\r\n        return QDate()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dateTimeAt( self, point ):\r\n        for dtime, data in self._dateTimeGrid.items():\r\n            if ( data[1].contains(point) ):\r\n                return QDateTime.fromTime_t(dtime)\r\n        return QDateTime()", "response": "Returns the date time at the inputed point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the rect that is defined by the inputed date.", "response": "def dateRect( self, date ):\r\n        \"\"\"\r\n        Returns the rect that is defined by the inputed date.\r\n        \r\n        :return     <QRectF>\r\n        \"\"\"\r\n        data = self._dateGrid.get(date.toJulianDay())\r\n        if ( data ):\r\n            return QRectF(data[1])\r\n        return QRectF()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the rect that is defined by the inputed date time.", "response": "def dateTimeRect( self, dateTime ):\r\n        \"\"\"\r\n        Returns the rect that is defined by the inputed date time.\r\n        \r\n        :return     <QRectF>\r\n        \"\"\"\r\n        data = self._dateTimeGrid.get(dateTime.toTime_t())\r\n        if ( data ):\r\n            return QRectF(data[1])\r\n        return QRectF()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drawBackground( self, painter, rect ):\n        if ( self._rebuildRequired ):\r\n            self.rebuild()\r\n        \n        super(XCalendarScene, self).drawBackground(painter, rect)\r\n        \r\n        palette = self.palette()\r\n        \r\n        # draw custom options\r\n        if ( 'curr_date' in self._buildData ):\r\n            clr = palette.color(QPalette.Highlight)\r\n            clr.setAlpha(40)\r\n            painter.setBrush(clr)\r\n            painter.setPen(Qt.NoPen)\r\n            painter.drawRect(self._buildData['curr_date'])\r\n            painter.setBrush(Qt.NoBrush)\r\n        \r\n        if ( 'today' in self._buildData ):\r\n            painter.setPen(Qt.NoPen)\r\n            clr = palette.color(QPalette.AlternateBase)\r\n            clr.setAlpha(120)\r\n            painter.setBrush(clr)\r\n            painter.drawRect(self._buildData['today'])\r\n            painter.setBrush(Qt.NoBrush)\r\n        \r\n        # draw the grid\r\n        painter.setPen(palette.color(QPalette.Mid))\r\n        painter.drawLines(self._buildData.get('grid', []))\r\n        \r\n        # draw text fields\r\n        painter.setPen(palette.color(QPalette.Text))\r\n        for data in self._buildData.get('regular_text', []):\r\n            painter.drawText(*data)\r\n        \r\n        # draw mid text fields\r\n        painter.setPen(palette.color(QPalette.Mid))\r\n        for data in self._buildData.get('mid_text', []):\r\n            painter.drawText(*data)", "response": "Draws the background of the calendar."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying a tool tip for the given event.", "response": "def helpEvent( self, event ):\r\n        \"\"\"\r\n        Displays a tool tip for the given help event.\r\n        \r\n        :param      event | <QHelpEvent>\r\n        \"\"\"\r\n        item  = self.itemAt(event.scenePos())\r\n        if ( item and item and item.toolTip() ):\r\n            parent = self.parent()\r\n            rect   = item.path().boundingRect()\r\n            point  = event.scenePos()\r\n            point.setY(item.pos().y() + rect.bottom())\r\n            \r\n            point  = parent.mapFromScene(point)\r\n            point  = parent.mapToGlobal(point)\r\n            \r\n            XPopupWidget.showToolTip(item.toolTip(),\r\n                                     point = point,\r\n                                     parent = parent)\r\n            event.accept()\r\n        else:\r\n            super(XCalendarScene, self).helpEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mousePressEvent( self, event ):\r\n        XPopupWidget.hideToolTip()\r\n        \r\n        # update the current date\r\n        self.setCurrentDate(self.dateAt(event.scenePos()))\r\n        \r\n        super(XCalendarScene, self).mousePressEvent(event)", "response": "Updates the current date to the clicked on date."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rebuild( self ):\r\n        self._buildData.clear()\r\n        self._dateGrid.clear()\r\n        self._dateTimeGrid.clear()\r\n        \r\n        curr_min = self._minimumDate\r\n        curr_max = self._maximumDate\r\n        \r\n        self._maximumDate = QDate()\r\n        self._minimumDate = QDate()\r\n        \r\n        self.markForRebuild(False)\r\n        \r\n        # rebuilds the month view\r\n        if ( self.currentMode() == XCalendarScene.Mode.Month ):\r\n            self.rebuildMonth()\r\n        elif ( self.currentMode() in (XCalendarScene.Mode.Week,\r\n                                      XCalendarScene.Mode.Day)):\r\n            self.rebuildDays()\r\n        \r\n        # rebuild the items in the scene\r\n        items = sorted(self.items())\r\n        for item in items:\r\n            item.setPos(0, 0)\r\n            item.hide()\r\n        \r\n        for item in items:\r\n            if ( isinstance(item, XCalendarItem) ):\r\n                item.rebuild()\r\n        \r\n        if ( curr_min != self._minimumDate or curr_max != self._maximumDate ):\r\n            parent = self.parent()\r\n            if ( parent and not parent.signalsBlocked() ):\r\n                parent.dateRangeChanged.emit(self._minimumDate, \r\n                                             self._maximumDate)", "response": "Rebuilds the information for this scene."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrebuild the month for this scene.", "response": "def rebuildMonth( self ):\r\n        \"\"\"\r\n        Rebuilds the month for this scene.\r\n        \"\"\"\r\n        # make sure we start at 0 for sunday vs. 7 for sunday\r\n        day_map     = dict([(i+1, i+1) for i in range(7)])\r\n        day_map[7]  = 0\r\n        \r\n        today   = QDate.currentDate()\r\n        curr    = self.currentDate()\r\n        first   = QDate(curr.year(), curr.month(), 1)\r\n        last    = QDate(curr.year(), curr.month(), curr.daysInMonth())\r\n        first   = first.addDays(-day_map[first.dayOfWeek()])\r\n        last    = last.addDays(6-day_map[last.dayOfWeek()])\r\n        \r\n        cols    = 7\r\n        rows    = (first.daysTo(last) + 1) / cols\r\n        \r\n        hlines  = []\r\n        vlines  = []\r\n        \r\n        padx    = 6\r\n        pady    = 6\r\n        header  = 24\r\n        \r\n        w       = self.width() - (2 * padx)\r\n        h       = self.height() - (2 * pady)\r\n        \r\n        dw      = (w / cols) - 1\r\n        dh      = ((h - header) / rows) - 1\r\n        \r\n        x0      = padx\r\n        y0      = pady + header\r\n        \r\n        x       = x0\r\n        y       = y0\r\n        \r\n        for row in range(rows + 1):\r\n            hlines.append(QLine(x0, y, w, y))\r\n            y += dh\r\n        \r\n        for col in range(cols + 1):\r\n            vlines.append(QLine(x, y0, x, h))\r\n            x += dw\r\n        \r\n        self._buildData['grid'] = hlines + vlines\r\n        \r\n        # draw the date fields\r\n        date = first\r\n        row  = 0\r\n        col  = 0\r\n        \r\n        # draw the headers\r\n        x = x0\r\n        y = pady\r\n        \r\n        regular_text = []\r\n        mid_text     = []\r\n        self._buildData['regular_text'] = regular_text\r\n        self._buildData['mid_text']     = mid_text\r\n        \r\n        for day in ('Sun', 'Mon','Tue','Wed','Thu','Fri','Sat'):\r\n            regular_text.append((x + 5,\r\n                                 y,\r\n                                 dw,\r\n                                 y0,\r\n                                 Qt.AlignLeft | Qt.AlignVCenter,\r\n                                 day))\r\n            x += dw\r\n        \r\n        for i in range(first.daysTo(last) + 1):\r\n            top    = (y0 + (row * dh))\r\n            left   = (x0 + (col * dw))\r\n            rect   = QRectF(left - 1, top, dw, dh)\r\n            \r\n            # mark the current date on the calendar\r\n            if ( date == curr ):\r\n                self._buildData['curr_date'] = rect\r\n            \r\n            # mark today's date on the calendar\r\n            elif ( date == today ):\r\n                self._buildData['today'] = rect\r\n            \r\n            # determine how to draw the calendar\r\n            format = 'd'\r\n            if ( date.day() == 1 ):\r\n                format = 'MMM d'\r\n            \r\n            # determine the color to draw the text\r\n            if ( date.month() == curr.month() ):\r\n                text = regular_text\r\n            else:\r\n                text = mid_text\r\n            \r\n            # draw the text\r\n            text.append((left + 2,\r\n                         top + 2,\r\n                         dw - 4,\r\n                         dh - 4,\r\n                         Qt.AlignTop | Qt.AlignLeft,\r\n                         date.toString(format)))\r\n            \r\n            # update the limits\r\n            if ( not i ):\r\n                self._minimumDate = date\r\n            self._maximumDate = date\r\n            \r\n            self._dateGrid[date.toJulianDay()] = ((row, col), rect)\r\n            if ( col == (cols - 1) ):\r\n                row += 1\r\n                col = 0\r\n            else:\r\n                col += 1\r\n                \r\n            date = date.addDays(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrebuild the interface as a week display.", "response": "def rebuildDays( self ):\r\n        \"\"\"\r\n        Rebuilds the interface as a week display.\r\n        \"\"\"\r\n        time = QTime(0, 0, 0)\r\n        hour = True\r\n        \r\n        x = 6\r\n        y = 6 + 24\r\n        \r\n        w = self.width() - 12 - 25\r\n        \r\n        dh         = 48\r\n        indent     = 58\r\n        text_data  = []\r\n        \r\n        vlines      = []\r\n        hlines      = [QLine(x, y, w, y)]\r\n        time_grids  = []\r\n        \r\n        for i in range(48):\r\n            if ( hour ):\r\n                hlines.append(QLine(x, y, w, y))\r\n                text_data.append((x,\r\n                                  y + 6, \r\n                                  indent - 6, \r\n                                  dh, \r\n                                  Qt.AlignRight | Qt.AlignTop,\r\n                                  time.toString('hap')))\r\n            else:\r\n                hlines.append(QLine(x + indent, y, w, y))\r\n            \r\n            time_grids.append((time, y, dh / 2))\r\n            \r\n            # move onto the next line\r\n            hour = not hour\r\n            time = time.addSecs(30 * 60)\r\n            y += dh / 2\r\n        \r\n        hlines.append(QLine(x, y, w, y))\r\n        \r\n        h = y\r\n        y = 6 + 24\r\n        \r\n        # load the grid\r\n        vlines.append(QLine(x, y, x, h))\r\n        vlines.append(QLine(x + indent, y, x + indent, h))\r\n        vlines.append(QLine(w, y, w, h))\r\n        \r\n        today     = QDate.currentDate()\r\n        curr_date = self.currentDate()\r\n        \r\n        # load the days\r\n        if ( self.currentMode() == XCalendarScene.Mode.Week ):\r\n            date = self.currentDate()\r\n            day_of_week = date.dayOfWeek()\r\n            if ( day_of_week == 7 ):\r\n                day_of_week = 0\r\n            \r\n            min_date = date.addDays(-day_of_week)\r\n            max_date = date.addDays(6-day_of_week)\r\n            \r\n            self._minimumDate = min_date\r\n            self._maximumDate = max_date\r\n            \r\n            dw    = (w - (x + indent)) / 7.0\r\n            vx    = x + indent\r\n            date  = min_date\r\n            \r\n            for i in range(7):\r\n                vlines.append(QLine(vx, y, vx, h))\r\n                \r\n                text_data.append((vx + 6,\r\n                                  6,\r\n                                  dw,\r\n                                  24,\r\n                                  Qt.AlignCenter,\r\n                                  date.toString('ddd MM/dd')))\r\n                \r\n                self._dateGrid[date.toJulianDay()] = ((0, i),\r\n                                                      QRectF(vx, y, dw, h - y))\r\n                \r\n                # create the date grid for date time options\r\n                for r, data in enumerate(time_grids):\r\n                    time, ty, th = data\r\n                    dtime = QDateTime(date, time)\r\n                    key = dtime.toTime_t()\r\n                    self._dateTimeGrid[key] = ((r, i), QRectF(vx, ty, dw, th))\r\n                \r\n                if ( date == curr_date ):\r\n                    self._buildData['curr_date'] = QRectF(vx, y, dw, h - 29)\r\n                elif ( date == today ):\r\n                    self._buildData['today'] = QRectF(vx, y, dw, h - 29)\r\n                \r\n                date = date.addDays(1)\r\n                vx += dw\r\n        \r\n        # load a single day\r\n        else:\r\n            date = self.currentDate()\r\n            \r\n            self._maximumDate = date\r\n            self._minimumDate = date\r\n            \r\n            text_data.append((x + indent,\r\n                              6,\r\n                              w,\r\n                              24,\r\n                              Qt.AlignCenter,\r\n                              date.toString('ddd MM/dd')))\r\n            \r\n            self._dateGrid[date.toJulianDay()] = ((0, 0), \r\n                                                  QRectF(x, y, w - x, h - y))\r\n            \r\n            # create the date grid for date time options\r\n            for r, data in enumerate(time_grids):\r\n                time, ty, th = data\r\n                dtime = QDateTime(date, time)\r\n                key = dtime.toTime_t()\r\n                rect = QRectF(x + indent, ty, w - (x + indent), th)\r\n                self._dateTimeGrid[key] = ((r, 0), rect)\r\n        \r\n        self._buildData['grid'] = hlines + vlines\r\n        self._buildData['regular_text'] = text_data\r\n        \r\n        rect = self.sceneRect()\r\n        rect.setHeight(h + 6)\r\n        \r\n        super(XCalendarScene, self).setSceneRect(rect)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setCurrentDate( self, date ):\n        if ( date == self._currentDate or not date.isValid() ):\r\n            return\r\n        \n        self._currentDate = date\r\n        self.markForRebuild()\r\n        \r\n        parent = self.parent()\r\n        if ( not parent.signalsBlocked() ):\r\n            parent.currentDateChanged.emit(date)\r\n            parent.titleChanged.emit(self.title())", "response": "Sets the current date displayed by this calendar widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setSceneRect( self, *args ):\r\n        h = self.height()\r\n        super(XCalendarScene, self).setSceneRect(*args)\r\n        if ( self.currentMode() != XCalendarScene.Mode.Month ):\r\n            rect = self.sceneRect()\r\n            rect.setHeight(h)\r\n            super(XCalendarScene, self).setSceneRect(rect)\r\n        \r\n        self.markForRebuild()", "response": "Updates the scene rect for this item."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the title for this scene based on its information.", "response": "def title( self ):\r\n        \"\"\"\r\n        Returns the title for this scene based on its information.\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        if ( self.currentMode() == XCalendarScene.Mode.Day ):\r\n            return self.currentDate().toString('dddd, MMMM dd, yyyy')\r\n        \r\n        elif ( self.currentMode() == XCalendarScene.Mode.Week ):\r\n            title = nativestring(self.minimumDate().toString('dddd, MMMM dd'))\r\n            title += ' - '\r\n            title += nativestring(self.maximumDate().toString('dddd, MMMM dd, yyyy'))\r\n            return title\r\n        \r\n        elif ( self.currentMode() == XCalendarScene.Mode.Month ):\r\n            return self.currentDate().toString('MMMM yyyy')\r\n        \r\n        else:\r\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, time):\n        self._time = time\n        self._pb.sec = int(self._time)\n        self._pb.nsec = int((self._time - self._pb.sec) * 10 ** 9)", "response": "Sets the time in seconds since Epoch."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding the sql expression for the record set", "response": "def compile(self, db):\n        \"\"\"Building the sql expression\n\n        :param db: the database instance\n        \"\"\"\n        sql = self.expression\n        if self.alias:\n            sql += (' AS ' + db.quote_column(self.alias))\n        return sql"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def register(self, check, *, token=None):\n        token_id = extract_attr(token, keys=[\"ID\"])\n        params = {\"token\": token_id}\n        response = await self._api.put(\"/v1/agent/check/register\",\n                                       params=params,\n                                       data=check)\n        return response.status == 200", "response": "Registers a new local check in Consul."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def mark(self, check, status, *, note=None):\n        check_id = extract_attr(check, keys=[\"CheckID\", \"ID\"])\n        data = {\n            \"Status\": status,\n            \"Output\": note\n        }\n        response = await self._api.put(\"/v1/agent/check/update\", check_id,\n                                       data=data)\n        return response.status == 200", "response": "Marks a local check as passing warning or critical"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding and load the user from database by uid", "response": "def find(self, uid):\n        \"\"\"Find and load the user from database by uid(user id)\"\"\"\n        data = (db.select(self.table).select('username', 'email', 'real_name',\n                                             'password', 'bio', 'status', 'role', 'uid').\n                condition('uid', uid).execute()\n                )\n        if data:\n            logger.info('data %s', data)\n            return self.load(data[0], self.model)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_by_username(self, username):\n        data = (db.select(self.table).select('username', 'email', 'real_name',\n                                             'password', 'bio', 'status', 'role', 'uid').\n                condition('username', username).execute()\n                )\n        if data:\n            return self.load(data[0], self.model)", "response": "Return user by username if find in database otherwise None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches the users table for the users matching the condition in kw", "response": "def search(self, **kw):\n        \"\"\"Find the users match the condition in kw\"\"\"\n        q = db.select(self.table).condition('status', 'active')\n        for k, v in kw:\n            q.condition(k, v)\n        data = q.execute()\n        users = []\n        for user in data:\n            users.append(self.load(user, self.model))\n        return users"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addConnection( self, cls = None ):\n        # make sure we have a valid class\n        if ( not cls ):\n            cls = self.defaultConnectionClass()\n        if ( not cls ):\n            return None\n        \n        # create the new connection\n        connection = cls(self)\n        connection.setLayer(self.currentLayer())\n        self.addItem(connection)\n        return connection", "response": "Adds a new connection to the scene."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new layer to the scene.", "response": "def addLayer(self, cls=None):\n        \"\"\"\n        Creates a new layer instance for this scene.  If the optional cls \\\n        parameter is not supplied, then the default layer class will be \\\n        used when creating the layer.\n        \n        :param      cls     <subclass of XNodeLayer>\n        \n        :return     <XNodeLayer> || None\n        \"\"\"\n        if ( not cls ):\n            cls = self.defaultLayerClass()\n            \n        if ( not cls ):\n            return None\n        \n        # create the new layer\n        layer = cls(self)\n        self._layers.append(layer)\n        self.setCurrentLayer(layer)\n        self.setModified()\n        \n        return layer"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an item to the cache and set modified flag.", "response": "def addItem( self, item ):\n        \"\"\"\n        Overloaded from the base QGraphicsScene class to set the modified \\\n        state for this scene to being modified.\n                    \n        :param      item        <QGraphicsItem>\n        \n        :return     <bool> success\n        \"\"\"\n        result = super(XNodeScene, self).addItem(item)\n        self.setModified()\n        self._cache.add(item)\n        \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addNode(self, cls=None, point=None):\n        # make sure we have a valid class\n        if not cls:\n            cls = self.defaultNodeClass()\n            \n        if not cls:\n            return None\n        \n        # create the new node\n        node = cls(self)\n        node.setLayer(self.currentLayer())\n        node.rebuild()\n        self.addItem(node)\n        \n        if point == 'center':\n            x = self.sceneRect().width() / 2.0\n            y = self.sceneRect().height() / 2.0\n            \n            x -= (node.rect().width() / 2.0)\n            y -= (node.rect().height() / 2.0)\n            \n            node.setPos(x, y)\n            \n        elif not point:\n            pos    = self._mainView.mapFromGlobal(QCursor.pos())\n            point  = self._mainView.mapToScene(pos)\n            if ( point ):\n                x = point.x() - node.rect().width() / 2.0\n                y = point.y() - node.rect().height() / 2.0\n                node.setPos(x, y)\n        else:\n            x = float(point.x())\n            y = float(point.y())\n            node.setPos(x, y)\n        \n        return node", "response": "Creates a new node in the scene."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef autoLayoutNodes( self, \n                         nodes, \n                         padX = None, \n                         padY = None, \n                         direction = Qt.Horizontal,\n                         layout = 'Layered',\n                         animate = 0,\n                         centerOn = None,\n                         center = None,\n                         debug=False):\n        \"\"\"\n        Automatically lays out all the nodes in the scene using the private \\\n        autoLayoutNodes method.\n        \n        :param      nodes | [<XNode>, ..]\n                    padX | <int> || None | default is 2 * cell width\n                    padY | <int> || None | default is 2 * cell height\n                    direction | <Qt.Direction>\n                    layout | <str> | name of the layout plugin to use\n                    animate | <int> | number of seconds to animate over\n        \n        :return     {<XNode>: <QRectF>, ..} | new rects per affected node\n        \"\"\"\n        plugin = XNodeLayout.plugin(layout)\n        if not plugin:\n            return 0\n        \n        if not animate:\n            plugin.setTesting(debug)\n            results = plugin.layout(self, nodes, center, padX, padY, direction)\n            if centerOn:\n                self.mainView().centerOn(centerOn)\n            return results\n        else:\n            anim_group = QParallelAnimationGroup(self)\n            plugin.setTesting(debug)\n            results = plugin.layout(self,\n                                   nodes,\n                                   center,\n                                   padX,\n                                   padY,\n                                   direction,\n                                   anim_group)\n            \n            if isinstance(centerOn, XNode):\n                if centerOn in results:\n                    end_center = results[centerOn] + centerOn.rect().center()\n                else:\n                    end_center = centerOn.sceneRect().center()\n                \n                anim = XObjectAnimation(self.mainView(), 'centerOn')\n                anim.setStartValue(self.mainView().viewportRect().center())\n                anim.setEndValue(end_center)\n                anim_group.addAnimation(anim)\n            \n            for i in range(anim_group.animationCount()):\n                anim = anim_group.animationAt(i)\n                anim.setDuration(1000 * animate)\n            \n            anim_group.finished.connect(anim_group.deleteLater)\n            anim_group.start()\n            return results", "response": "Auto - layout the nodes in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef autoLayoutSelected( self, \n                             padX = None,\n                             padY = None,\n                             direction = Qt.Horizontal,\n                             layout = 'Layered',\n                             animate = 0,\n                             centerOn = None,\n                             center = None):\n        \"\"\"\n        Automatically lays out all the selected nodes in the scene using the \\\n        autoLayoutNodes method.\n        \n        :param      padX | <int> || None | default is 2 * cell width\n                    padY | <int> || None | default is 2 * cell height\n                    direction | <Qt.Direction>\n                    layout | <str> | name of the layout plugin to use\n                    animate | <int> | number of seconds to animate over\n        \n        :return     {<XNode>: <QRectF>, ..} | new rects per node\n        \"\"\"\n        nodes = self.selectedNodes()\n        return self.autoLayoutNodes(nodes, \n                                    padX, \n                                    padY, \n                                    direction, \n                                    layout, \n                                    animate,\n                                    centerOn,\n                                    center)", "response": "Auto layout selected nodes in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef blockSelectionSignals( self, state ):\n        if ( self._selectionSignalsBlocked == state ):\n            return\n        \n        self._selectionSignalsBlocked = state\n        if ( not state ):\n            self.emitSelectionFinished()", "response": "Sets the state for the seleciton finished signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calculateBoundingRect(self, nodes):\n        out = QRectF()\n        for node in nodes:\n            rect = node.rect()\n            pos = node.pos()\n            \n            bounding = QRectF(pos.x(), pos.y(), rect.width(), rect.height())\n            out = out.united(bounding)\n        \n        return out", "response": "Calculates the bounding rectangle for the inputed nodes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the current scene.", "response": "def clear( self ):\n        \"\"\"\n        Clears the current scene of all the items and layers.\n        \"\"\"\n        self.setCurrentLayer(None)\n        \n        self._layers = []\n        self._cache.clear()\n        \n        super(XNodeScene, self).clear()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a connection between the currently selected nodes and the specified class instance.", "response": "def connectSelection( self, cls = None ):\n        \"\"\"\n        Creates a connection between the currently selected \\\n        nodes, provided there are only 2 nodes selected.  If \\\n        the cls parameter is supplied then that will be the \\\n        class instance used when creating the connection. \\\n        Otherwise, the default connection class will be used.\n        \n        :param      cls         subclass of <XNodeConnection>\n        \n        :return     <XNodeConnection> || None\n        \"\"\"\n        # collect the selected nodes\n        nodes = self.selectedNodes()\n        if ( len(nodes) != 2 ):\n            return None\n        \n        # create the connection\n        con = self.addConnection(cls)\n        con.setOutputNode(nodes[0])\n        con.setInputNode(nodes[1])\n        con.rebuild()\n        \n        return con"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all the connection instances that are in this scene.", "response": "def connections(self, hotspot=None):\n        \"\"\"\n        Returns a list of all the connection instances that are in this scene.\n                    \n        :return     <list>  [ <XNodeConnection>, .. ]\n        \"\"\"\n        cons = self.findItems(XNodeConnection)\n        if hotspot is not None:\n            filt = lambda x: hotspot in (x.inputHotspot(), x.outputHotspot())\n            return filter(filt, cons)\n        return cons"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noverloads the base QGraphicsScene method to handle \\ drawing the grid for the node scene. This method should \\ not be called manually but is called internally as part \\ of the painting mechanism for the QGraphicsScene object. :param painter <QPainter> :param rect <QRect>", "response": "def drawBackground(self, painter, rect):\n        \"\"\"\n        Overloads the base QGraphicsScene method to handle \\\n        drawing the grid for the node scene.  This method should \\\n        not be called manually but is called internally as part \\\n        of the painting mechanism for the QGraphicsScene object.\n        \n        :param      painter     <QPainter>\n        :param      rect        <QRect>\n        \"\"\"\n        painter.save()\n        \n        palette = self.palette()\n        if not (self._mainView and self._mainView.isEnabled()):\n            state = palette.Disabled\n        else:\n            state = palette.Active\n        \n        bg          = palette.color(state, palette.GridBackground)\n        grid        = palette.color(state, palette.GridForeground)\n        agrid       = palette.color(state, palette.GridAlternateForeground)\n        lineColor   = palette.color(state, palette.GridCenterline)\n        \n        brush = self.backgroundBrush()\n        brush.setColor(bg)\n        \n        painter.setBrush(brush)\n        painter.drawRect(rect.x() - 1,\n                         rect.y() - 1,\n                         rect.width() + 2,\n                         rect.height() + 2)\n        \n        # draw the grid if it is currently enabled\n        if not self.showGrid():\n            painter.restore()\n            return\n        \n        # rebuild the grid if the scene is dirty\n        if self.isDirty():\n            self.rebuild()\n        \n        # if we're zoomed in above 50%, then draw the minor grid lines\n        if self.zoomAmount() > 50:\n            # draw the minor lines\n            painter.setPen(agrid)\n            painter.drawLines( self._minorLines )\n        \n        # draw the major grid lines\n        painter.setPen(grid)\n        painter.drawLines(self._majorLines)\n        \n        # draw the center lines\n        painter.setPen(lineColor)\n        painter.drawLines(self._centerLines)\n        \n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef findItems( self, cls ):\n        return filter(lambda x: isinstance(x, cls), self.items())", "response": "Returns a list of items that inherit from cls."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef findLayer( self, layerName ):\n        for layer in self._layers:\n            if ( layer.name() == layerName ):\n                return layer\n        return None", "response": "Searches the layer for this node based on the inputed layer name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch up the node based on the inputed object name.", "response": "def findNode( self, objectName ):\n        \"\"\"\n        Looks up the node based on the inputed node name.\n        \n        :param      objectName     | <str>\n        \"\"\"\n        for item in self.items():\n            if ( isinstance(item, XNode) and \n                 item.objectName() == objectName ):\n                return item\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsearching up the first instance of the node whose display name matches the inputed regex.", "response": "def findNodeByRegex( self, objectRegex ):\n        \"\"\"\n        Looks up the first instance of the node who matches the inputed regex\n        expression.\n        \n        :param      objectRegex | <str>\n        \n        :return     <XNode> || None\n        \"\"\"\n        expr = re.compile(nativestring(objectRegex))\n        for item in self.items():\n            if ( isinstance(item, XNode) and\n                 expr.match(item.displayName()) ):\n                return item\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findNodeById( self, objectId ):\n        for item in self.items():\n            if ( isinstance(item, XNode) and item.objectId() == objectId):\n                return item\n        return None", "response": "Searches the node based on the unique node identifier."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinishing the active connection.", "response": "def finishConnection(self, accept=True):\n        \"\"\"\n        Finishes the active connection.  If the accept value is \\\n        true, then the connection requested signal will be emited, \\\n        otherwise, it will simply clear the active connection \\\n        data.\n        \n        :param      accept      <bool>\n        \"\"\"\n        if not self._activeConnection:\n            return\n        \n        # when accepting, emit the connection requested signal\n        if accept:\n            self.emitConnectionRequested(self._activeConnection)\n            \n            # emit the slot for the given node dropzone\n            if self._activeConnection.customData('__output__'):\n                target = self._activeConnection.inputPoint()\n                node   = self.nodeAt(target)\n            else:\n                target = self._activeConnection.outputPoint()\n                node   = self.nodeAt(target)\n            \n            if node:\n                npos = node.mapFromScene(target)\n                node.triggerDropzoneAt(npos, self._activeConnection)\n        \n        # remove the connection\n        self.removeItem(self._activeConnection)\n        self._activeConnection = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef keyPressEvent( self, event ):\n        # otherwise, eat all other key press events until the \n        # view mode is released\n        if ( self.inViewMode() ):\n            event.accept()\n        \n        # when the user presses the space bar, put\n        # the scene into view editing mode\n        elif ( event.key() == Qt.Key_Space ):\n            self.setViewMode(True)\n            event.accept()\n        \n        # cancel the connection if escape is pressed\n        elif ( event.key() == Qt.Key_Escape ):\n            self.finishConnection(False)\n            event.accept()\n        \n        # otherwise, run the standard key press event\n        else:\n            super(XNodeScene, self).keyPressEvent(event)", "response": "Handles the key press event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle the key release event.", "response": "def keyReleaseEvent( self, event ):\n        \"\"\"\n        Intercepts the Qt key released event to look for built-in overrides.\n        \n        :param      event       <QKeyReleaseEvent>\n        \"\"\"\n        # when the user releases the space bar, remove\n        # the scene view edit override\n        if ( event.key() == Qt.Key_Space ):\n            self.setViewMode(False)\n            event.accept()\n        \n        # otherwise, eat all other key press events until the \n        # view mode is released\n        elif ( self.inViewMode() ):\n            event.accept()\n        \n        # otherwise, handle the event like normal\n        else:\n            super(XNodeScene, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nemitting the node double clicked event when a node is double clicked.", "response": "def mouseDoubleClickEvent(self, event):\n        \"\"\"\n        Emits the node double clicked event when a node is double clicked.\n        \n        :param      event | <QMouseDoubleClickEvent>\n        \"\"\"\n        super(XNodeScene, self).mouseDoubleClickEvent(event)\n        \n        # emit the node double clicked signal\n        if event.button() == Qt.LeftButton:\n            item = self.itemAt(event.scenePos())\n            \n            if not item:\n                self.clearSelection()\n            else:\n                blocked = self.signalsBlocked()\n                self.blockSignals(True)\n                self.clearSelection()\n                item.setSelected(True)\n                self.blockSignals(blocked)\n            \n                if isinstance(item, XNode) and not blocked:\n                    self.nodeDoubleClicked.emit(item)\n                elif isinstance(item, XNodeConnection) and not blocked:\n                    self.connectionDoubleClicked.emit(item)\n                \n                if not blocked:\n                    self.itemDoubleClicked.emit(item)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mousePressEvent( self, event ):\n        if event.button() == Qt.MidButton:\n            self.setViewMode(True)\n            event.accept()\n        elif event.button() == Qt.RightButton:\n            event.accept()\n        else:\n            super(XNodeScene, self).mousePressEvent(event)\n            self.blockSelectionSignals(True)", "response": "Overloads the base QGraphicsScene method to block the selection signals if the object is selected."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mouseMoveEvent( self, event ):\n        if ( self._activeConnection ):\n            if self._activeConnection.customData('__output__'):\n                self._activeConnection.setInputPoint(event.scenePos())\n            else:\n                self._activeConnection.setOutputPoint(event.scenePos())\n        \n        super(XNodeScene, self).mouseMoveEvent(event)", "response": "Overloads the base QGraphicsScene method to update the active connection if there is one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noverride this method to reset the selection blocked signals and finish the connection.", "response": "def mouseReleaseEvent( self, event ):\n        \"\"\"\n        Overloads the base QGraphicsScene method to reset the selection \\\n        signals and finish the connection.\n                    \n        :param      event   <QMouseReleaseEvent>\n        \"\"\"\n        if event.button() == Qt.MidButton:\n            self.setViewMode(False)\n            event.accept()\n            return\n        \n        super(XNodeScene, self).mouseReleaseEvent(event)\n        \n        # reset the selection blocked signals\n        self.blockSelectionSignals(False)\n        \n        # finish the connection\n        if ( self.isConnecting() ):\n            self.finishConnection()\n        \n        # emit a menu request signal if necessary\n        elif ( not event.isAccepted() and event.button() == Qt.RightButton ):\n            item = self.itemAt(event.scenePos())\n            if isinstance(item, XNode):\n                self.emitNodeMenuRequested(item)\n            else:\n                self.emitMenuRequested()\n            event.accept()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the node at the inputed positions.", "response": "def nodeAt( self, point ):\n        \"\"\"\n        Returns the node at the inputed positions.\n        \n        :return     <XNode>\n        \"\"\"\n        items = self.items(point)\n        for item in items:\n            if ( isinstance(item, XNode) ):\n                return item\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rebuild( self ):\n        rect    = self.sceneRect()\n        x       = rect.left()\n        y       = rect.top()\n        w       = rect.width()\n        h       = rect.height()\n        \n        # calculate background gridlines\n        cx      = x + (w / 2)\n        cy      = y + (h / 2)\n        \n        self._centerLines = [QLine(cx, rect.top(), cx, rect.bottom()),\n                             QLine(rect.left(), cy, rect.right(), cy) ]\n        \n        # create the horizontal grid lines\n        delta           = self.cellHeight()\n        minor_lines     = []\n        major_lines     = []\n        count           = 1\n        while delta < (h / 2):\n            pos_line = QLine(x, cy + delta, x + w, cy + delta)\n            neg_line = QLine(x, cy - delta, x + w, cy - delta)\n            \n            # every 10th line will be a major line\n            if count == 10:\n                major_lines.append(pos_line)\n                major_lines.append(neg_line)\n                count = 1\n            else:\n                minor_lines.append(pos_line)\n                minor_lines.append(neg_line)\n            \n            # update the current y location\n            delta += self.cellHeight()\n            count += 1\n        \n        # create the vertical grid lines\n        delta = self.cellWidth()\n        count = 1\n        while delta < (w / 2):\n            pos_line = QLine(cx + delta, y, cx + delta, y + h)\n            neg_line = QLine(cx - delta, y, cx - delta, y + h)\n            \n            # every 10th line will be a major line\n            if count == 10:\n                major_lines.append(pos_line)\n                major_lines.append(neg_line)\n                count = 1\n            else:\n                minor_lines.append(pos_line)\n                minor_lines.append(neg_line)\n            \n            # update the current y location\n            delta += self.cellWidth()\n            count += 1\n        \n        # set the line cache\n        self._majorLines = major_lines\n        self._minorLines = minor_lines\n        \n        # unmark the scene as being dirty\n        self.setDirty(False)", "response": "Rebuilds the grid lines based on the current settings and the scene width."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removeItem( self, item ):\n        # for nodes and connections, call the prepareToRemove method before \n        # removing\n        if ( isinstance( item, XNode ) or \n             isinstance( item, XNodeConnection ) ):\n            # make sure this item is ok to remove\n            if ( not item.prepareToRemove() ):\n                return False\n        \n        # remove the item using the base class method\n        try:\n            self._cache.remove(item)\n        except KeyError:\n            pass\n        \n        # mark the scene as modified\n        self.setModified(True)\n        super(XNodeScene, self).removeItem(item)\n        \n        if not self.signalsBlocked():\n            self.itemsRemoved.emit()\n        \n        return True", "response": "Removes the item from the scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef removeItems(self, items):\n        count = 0\n        self._removalQueue = items\n        blocked = self.signalsBlocked()\n        self.blockSignals(True)\n        update = set()\n        for item in items:\n            if isinstance(item, XNodeConnection):\n                update.add(item.inputNode())\n                update.add(item.outputNode())\n            \n            if self.removeItem(item):\n                count += 1\n        \n        self.blockSignals(blocked)\n        self._removalQueue = []\n        \n        # update any existing nodes once the connections have been removed\n        for node in update.difference(items):\n            node.setDirty(True)\n        \n        if not self.signalsBlocked():\n            self.itemsRemoved.emit()\n        \n        return count", "response": "Removes all the items from the scene at once."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the current selected items by calling removeItems.", "response": "def removeSelection( self ):\n        \"\"\"\n        Removes the current selected items by calling the removeItems method.\n        \n        :sa         removeItems\n        \n        :return     <int> number removed\n        \"\"\"\n        results = self.removeItems( self.selectedItems() )\n        self.emitSelectionFinished()\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef selectAll( self ):\n        currLayer = self._currentLayer\n        for item in self.items():\n            layer = item.layer()\n            if ( layer == currLayer or not layer ):\n                item.setSelected(True)", "response": "Selects all the items in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef selectInvert( self ):\n        currLayer = self._currentLayer\n        for item in self.items():\n            layer = item.layer()\n            if ( layer == currLayer or not layer ):\n                item.setSelected(not item.isSelected())", "response": "Inverts the currently selected items in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef selectNone( self ):\n        currLayer = self._currentLayer\n        for item in self.items():\n            layer = item.layer()\n            if ( layer == currLayer or not layer ):\n                item.setSelected(False)", "response": "Deselect all the items in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef selectedConnections( self ):\n        output = []\n        for item in self.selectedItems():\n            if ( isinstance(item, XNodeConnection) ):\n                output.append(item)\n        return output", "response": "Returns a list of the selected connections in a scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef selectedNodes( self ):\n        output = []\n        for item in self.selectedItems():\n            if ( isinstance(item, XNode) ):\n                output.append(item)\n        return output", "response": "Returns a list of the selected nodes in a scene."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setAlternateGridColor(self, color):\n        palette = self.palette()\n        palette.setColor(palette.GridAlternateForeground, QColor(color))", "response": "Sets the alternate color for the smaller grid lines."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setBackgroundBrush(self, brush):\n        if type(brush) == str:\n            brush = QBrush(QColor(brush))\n        elif type(brush) == QColor:\n            brush = QBrush(brush)\n        elif type(brush) != QBrush:\n            return\n        \n        # update the palette color\n        palette = self.palette()\n        palette.setColor(palette.GridBackground, brush.color())\n        \n        super(XNodeScene, self).setBackgroundBrush(brush)", "response": "This will set the background brush for this node scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCenterLineColor(self, color):\n        palette = self.palette()\n        palette.setColor(palette.GridCenterline, QColor(color))", "response": "Sets the color for the center line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the current layer for this scene to the inputed layer.", "response": "def setCurrentLayer(self, layer):\n        \"\"\"\n        Sets the current layer for this scene to the inputed layer.\n        \n        :param      layer | <XNodeLayer> || None\n        \"\"\"\n        if self._currentLayer == layer:\n            return False\n        \n        old = self._currentLayer\n        self._currentLayer = layer\n        \n        if old is not None:\n            old.sync()\n        if layer is not None:\n            layer.sync()\n        \n        self.selectionFinished.emit()\n        self.invalidate()\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrentNode(self, node):\n        self.blockSignals(True)\n        self.clearSelection()\n        if node:\n            node.setSelected(True)\n        self.blockSignals(False)", "response": "Sets the currently selected node in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the state of the moderation of the current object.", "response": "def setModified( self, state = True ):\n        \"\"\"\n        Flags the scene as being modified based on the inputed value.\n        \n        :param      state   <bool>\n        \"\"\"\n        if ( state == self._modified ):\n            return\n            \n        self._modified = state\n        self.emitModifiedStateChanged()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the color for the grid for this instance to the given color.", "response": "def setGridColor(self, color):\n        \"\"\"\n        Sets the color for the grid for this instance to the given color.\n        \n        :param      color | <QColor>\n        \"\"\"\n        palette = self.palette()\n        palette.setColor(palette.GridForeground, QColor(color))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setIsolationMode( self, state ):\n        self._isolationMode = state\n        self.updateIsolated(force = True)\n        self.update()", "response": "Sets whether or not this widget is in isolation mode."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setMaxZoomAmount( self, amount ):\n        self._maxZoomAmount = amount\n        view = self.mainView()\n        if view:\n            view.maxZoomAmountChanged.emit(amount)", "response": "Sets the maximum amount that a user can zoom into. Default is 100."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the minimum amount that a user can zoom into. Default is 100.", "response": "def setMinZoomAmount( self, amount ):\n        \"\"\"\n        Sets the minimum amount that a user can zoom into to.  Default is 100.\n        \n        :param      amount | <int>\n        \"\"\"\n        self._minZoomAmount = amount\n        view = self.mainView()\n        if view:\n            view.minZoomAmountChanged.emit(amount)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setSceneRect(self, *args):\n        super(XNodeScene, self).setSceneRect(*args)\n        self.setDirty()", "response": "Overloads the base QGraphicsScene method to set the scene as dirty"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setViewMode( self, state = True ):\n        if self._viewMode == state:\n            return\n            \n        self._viewMode = state\n        if state:\n            self._mainView.setDragMode( self._mainView.ScrollHandDrag )\n        else:\n            self._mainView.setDragMode( self._mainView.RubberBandDrag )\n            \n        self.emitViewModeChanged()", "response": "Sets the view mode for moving around the scene."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the zoom level for the current scene.", "response": "def setZoomAmount(self, amount):\n        \"\"\"\n        Sets the zoom level for the current scene, updating all the \\\n        views that it is connected to.\n        \n        :param      amount      <int>  (100 based %)\n        \"\"\"\n        amount = max(self._minZoomAmount, amount)\n        amount = min(self._maxZoomAmount, amount)\n        \n        # only update when necessary\n        if amount == self.zoomAmount():\n            return\n        \n        # calculate the scalar value\n        scale = (amount / 100.0)\n        \n        # assign the new transform to all of the views\n        view = self.mainView()\n        view.setTransform(QTransform.fromScale(scale, scale))\n        \n        # emit the value changed signal for the scene\n        if not (self.signalsBlocked() or view.signalsBlocked()):\n            view.zoomAmountChanged.emit(amount)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef startConnection( self, point, cls=None, output=True ):\n        # clear the last connection\n        self.finishConnection(False)\n        \n        # create a new connection\n        self._activeConnection = self.addConnection(cls)\n        if self._activeConnection:\n            self._activeConnection.setOutputPoint(point)\n            self._activeConnection.setInputPoint(point)\n            self._activeConnection.setCustomData('__output__', output)\n        \n        return self._activeConnection", "response": "Starts creating a new connection from the given output point."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef uniqueNodeName( self, name ):\n        nodenames   = []\n        for node in self.items():\n            if ( isinstance(node, XNode) ):\n                nodenames.append( node.objectName() )\n        \n        basename    = nativestring(name)\n        index       = 1\n        name        = basename\n        \n        while ( name in nodenames ):\n            name = '%s%02i' % (basename, index)\n            index += 1\n        \n        return name", "response": "Returns the unique name for the inputed node name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef updateIsolated( self, force = False ):\n        if ( not (self.isolationMode() or force) ):\n            return\n        \n        # make sure all nodes are not being hidden because of isolation\n        if ( not self.isolationMode() ):\n            for node in self.nodes():\n                node.setIsolateHidden(False)\n            return\n        \n        # make sure all the nodes are visible or hidden based on the selection\n        selected_nodes  = self.selectedNodes()\n        isolated_nodes  = set(selected_nodes)\n        connections     = self.connections()\n        for connection in connections:\n            in_node  = connection.inputNode()\n            out_node = connection.outputNode()\n            \n            if ( in_node in selected_nodes or out_node in selected_nodes ):\n                isolated_nodes.add(in_node)\n                isolated_nodes.add(out_node)\n        \n        for node in self.nodes():\n            node.setIsolateHidden(not node in isolated_nodes)", "response": "Updates the visible state of nodes based on whether or not they are isolated."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of the visible nodes in the scene.", "response": "def visibleNodes(self):\n        \"\"\"\n        Returns a list of the visible nodes in the scene.\n        \n        :return     [<XNode>, ..]\n        \"\"\"\n        return filter(lambda x: isinstance(x, XNode) and x.isVisible(),\n                      self.items())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wheelEvent( self, event ):\n        # check to see if the system is\n        # currently in view mode\n        if ( self.inViewMode() ):\n            if ( event.delta() < 0 ):\n                self.zoomOut()\n            else:\n                self.zoomIn()\n            \n            event.accept()\n            self.mainView().setFocus()\n        \n        else:\n            super(XNodeScene, self).wheelEvent(event)", "response": "Overloads the base QGraphicsScene wheelEvent method to zoom in or out depending on the system state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge(constraints):\n    # Dictionary :class:`Operator`: set of :class:`Version`.\n    operators = defaultdict(set)\n    for constraint in constraints:\n        operators[constraint.operator].add(constraint.version)\n    # Get most recent version required by > constraints.\n    if gt in operators:\n        gt_ver = sorted(operators[gt])[-1]\n    else:\n        gt_ver = None\n    # Get most recent version required by >= constraints.\n    if ge in operators:\n        ge_ver = sorted(operators[ge])[-1]\n    else:\n        ge_ver = None\n    # Get least recent version required by < constraints.\n    if lt in operators:\n        lt_ver = sorted(operators[lt])[0]\n    else:\n        lt_ver = None\n    # Get least recent version required by <= constraints.\n    if le in operators:\n        le_ver = sorted(operators[le])[0]\n    else:\n        le_ver = None\n    # Most restrictive LT/LE constraint.\n    l_constraint = None\n    if le_ver:\n        if lt_ver:\n            le_constraint = Constraint(le, le_ver)\n            lt_constraint = Constraint(lt, lt_ver)\n\n            if le_ver < lt_ver:\n                # <= 1, < 2\n                l_constraint = le_constraint\n                l_less_restrictive_c = lt_constraint\n            else:\n                # <= 2, < 1\n                # <= 2, < 2\n                l_constraint = lt_constraint\n                l_less_restrictive_c = le_constraint\n\n            LOGGER.debug('Removed constraint %s because it is less '\n                         'restrictive than %s', l_less_restrictive_c,\n                         l_constraint)\n        else:\n            l_constraint = Constraint(le, le_ver)\n    elif lt_ver:\n        l_constraint = Constraint(lt, lt_ver)\n    # Most restrictive GT/GE constraint.\n    g_constraint = None\n    if ge_ver:\n        if gt_ver:\n            gt_constraint = Constraint(gt, gt_ver)\n            ge_constraint = Constraint(ge, ge_ver)\n\n            if ge_ver <= gt_ver:\n                # >= 1, > 2\n                # >= 2, > 2\n                g_constraint = gt_constraint\n                g_less_restrictive_c = ge_constraint\n            else:\n                # >= 2, > 1\n                g_constraint = ge_constraint\n                g_less_restrictive_c = gt_constraint\n\n            LOGGER.debug('Removed constraint %s because it is less '\n                         'restrictive than %s', g_less_restrictive_c,\n                         g_constraint)\n        else:\n            g_constraint = Constraint(ge, ge_ver)\n    elif gt_ver:\n        g_constraint = Constraint(gt, gt_ver)\n\n    # Check if g_constraint and l_constraint are conflicting\n    if g_constraint and l_constraint:\n        if g_constraint.version == l_constraint.version:\n            if g_constraint.operator == ge and l_constraint.operator == le:\n                # Merge >= and <= constraints on same version to a ==\n                # constraint\n                operators[eq].add(g_constraint.version)\n                LOGGER.debug('Merged constraints: %s and %s into ==%s',\n                             l_constraint, g_constraint, g_constraint.version)\n                l_constraint, g_constraint = None, None\n            else:\n                raise ExclusiveConstraints(g_constraint, [l_constraint])\n        elif g_constraint.version > l_constraint.version:\n            raise ExclusiveConstraints(g_constraint, [l_constraint])\n\n    ne_constraints = [Constraint(ne, v) for v in operators[ne]]\n    eq_constraints = [Constraint(eq, v) for v in operators[eq]]\n\n    if eq_constraints:\n        eq_constraint = eq_constraints.pop()\n        # An eq constraint conflicts with other constraints\n        if g_constraint or l_constraint or ne_constraints or eq_constraints:\n            conflict_list = [c for c in (g_constraint, l_constraint) if c]\n            conflict_list.extend(ne_constraints)\n            conflict_list.extend(eq_constraints)\n            raise ExclusiveConstraints(eq_constraint, conflict_list)\n\n        return [eq_constraint]\n\n    else:\n        constraints = ne_constraints + [g_constraint, l_constraint]\n        return [c for c in constraints if c]", "response": "This function merges the current constraints."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match(self, version):\n        return all(constraint.match(version)\n                   for constraint in self.constraints)", "response": "Match version with this collection of constraints."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping for :func:`merge`. It merges `constraint` with current ones and returns the list of merged constraints. It does not modify the current object. :param constraint: The constraint(s) to merge with current constraints. :type: :class:`Constraint`, :class:`Constraints` or `str` :returns: List of :class:`Constraint` objects. :rtype: list", "response": "def _merge(self, constraint):\n        \"\"\"Wrapper for :func:`merge`.\n\n        It merges `constraint` with current ones and returns the list of\n        merged constraints.\n        It does not modify the current object.\n\n        :param constraint: The constraint(s) to merge with current constraints.\n        :type: :class:`Constraint`, :class:`Constraints` or `str`\n        :returns: List of :class:`Constraint` objects.\n        :rtype: list\n\n        \"\"\"\n        if isinstance(constraint, basestring):\n            constraints = Constraints.parse(constraint).constraints\n        elif isinstance(constraint, Constraint):\n            constraints = [constraint]\n        elif isinstance(constraint, Constraints):\n            constraints = constraint.constraints\n        else:\n            raise TypeError(constraint)\n\n        return merge(self.constraints + constraints)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a : ref : constraints_expression <constraints - expressions > and returns a : class:`Constraints object.", "response": "def parse(cls, constraints_expression):\n        \"\"\"Parses a :ref:`constraints_expression <constraints-expressions>`\n        and returns a :class:`Constraints` object.\n        \"\"\"\n        constraint_exprs = re.split(r'\\s*,\\s*', constraints_expression)\n        return Constraints(merge(Constraint.parse(constraint_expr)\n                                 for constraint_expr in constraint_exprs))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting whether or not the given flag is enabled or disabled.", "response": "def setFlag(self, flag, state=True):\r\n        \"\"\"\r\n        Sets whether or not the given flag is enabled or disabled.\r\n        \r\n        :param      flag | <XExporter.Flags>\r\n        \"\"\"\r\n        has_flag = self.testFlag(flag)\r\n        if has_flag and not state:\r\n            self.setFlags(self.flags() ^ flag)\r\n        elif not has_flag and state:\r\n            self.setFlags(self.flags() | flag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of plugins registered for the exporter.", "response": "def plugins(flags=None):\r\n        \"\"\"\r\n        Returns the plugins registered for the exporter.  If the optional\r\n        flags are set then only plugins with the inputed flags will be\r\n        returned.\r\n        \r\n        :param      flags | <XExporter.Flags>\r\n        \"\"\"\r\n        XExporter.init()\r\n        \r\n        plugs = XExporter._plugins[:]\r\n        if flags is not None:\r\n            return filter(lambda x: x.testFlag(flags), plugs)\r\n        return plugs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup(config,  minconn=5, maxconn=10,  adapter='mysql', key='default', slave=False):\n    global __db\n\n    if '.' in key:\n        raise TypeError('The DB Key: \"%s\" Can\\'t Contain dot' % (key))\n\n    if slave == False and key in __db:\n        raise DBError('The Key: \"%s\" was set' % (key))\n\n    database = DB(config, minconn, maxconn, key, adapter)\n\n    master_key = key\n    slave_key = key + '.slave'\n\n    if not slave:\n        __db[master_key] = database\n        if slave_key not in __db:\n            __db[slave_key] = [database]\n    else:\n        if key in __db:\n            databases = __db[slave_key]\n            if len(databases) == 1 and __db[master_key] == databases[0]:\n                __db[slave_key] = [database]\n            else:\n                __db[slave_key].append(database)\n        else:\n            __db[slave_key] = [database]", "response": "Setup the database for the current n - grams."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute(sql, args=None, key='default'):\n    database = __db[key]\n    return database.execute(sql, args)", "response": "This function is used for update delete records."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects dialect for a table", "response": "def select(table, key='default'):\n    \"\"\"Select dialect\n\n\n    :param key: a key for your dabtabase you wanna use\n    \"\"\"\n    database = choice(__db[key + '.slave'])\n    return database.select(table)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a random database entry", "response": "def database(key='default', slave=False):\n    \"\"\"datbase dialect\n\n    :param key: a key for your dabtabase you wanna use\n    :param slave boolean: If True the database can be read only, Defaults False.\n    \"\"\"\n    if slave:\n        key += '.slave'\n        return choice(__db[key])\n    return __db.get(key)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting Memcached backend based on the config and .", "response": "def set_memcached_backend(self, config):\n        \"\"\"\n        Select the most suitable Memcached backend based on the config and\n        on what's installed\n        \"\"\"\n        # This is the preferred backend as it is the fastest and most fully\n        # featured, so we use this by default\n        config['BACKEND'] = 'django_pylibmc.memcached.PyLibMCCache'\n        if is_importable(config['BACKEND']):\n            return\n        # Otherwise, binary connections can use this pure Python implementation\n        if config.get('BINARY') and is_importable('django_bmemcached'):\n            config['BACKEND'] = 'django_bmemcached.memcached.BMemcached'\n            return\n        # For text-based connections without any authentication we can fall\n        # back to Django's core backends if the supporting libraries are\n        # installed\n        if not any([config.get(key) for key in ('BINARY', 'USERNAME', 'PASSWORD')]):\n            if is_importable('pylibmc'):\n                config['BACKEND'] = \\\n                        'django.core.cache.backends.memcached.PyLibMCCache'\n            elif is_importable('memcached'):\n                config['BACKEND'] = \\\n                        'django.core.cache.backends.memcached.MemcachedCache'"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addEntry(self):\r\n        joiner = self.joiner()\r\n        curr_joiner = self._containerWidget.currentJoiner()\r\n        \r\n        # update the joining option if it is modified\r\n        if joiner != curr_joiner:\r\n            if not self._last:\r\n                self.updateJoin()\r\n                return\r\n            \r\n            self._containerWidget.setCurrentJoiner(joiner)\r\n        \r\n        # otherwise, add a new entry\r\n        self._containerWidget.addEntry(entry=self)", "response": "Add a new entry to the list of entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassigning an editor based on the current column for this schema.", "response": "def assignPlugin(self):\r\n        \"\"\"\r\n        Assigns an editor based on the current column for this schema.\r\n        \"\"\"\r\n        self.uiOperatorDDL.blockSignals(True)\r\n        self.uiOperatorDDL.clear()\r\n        \r\n        plugin = self.currentPlugin()\r\n        if plugin:\r\n            flags = 0\r\n            if not self.queryWidget().showReferencePlugins():\r\n                flags |= plugin.Flags.ReferenceRequired\r\n            \r\n            self.uiOperatorDDL.addItems(plugin.operators(ignore=flags))\r\n        \r\n        self.uiOperatorDDL.blockSignals(False)\r\n        self.assignEditor()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assignEditor(self):\r\n        plugin = self.currentPlugin()\r\n        column = self.currentColumn()\r\n        value = self.currentValue()\r\n        \r\n        if not plugin:\r\n            self.setEditor(None)\r\n            return\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        op = self.uiOperatorDDL.currentText()\r\n        self.setEditor(plugin.createEditor(self, column, op, value))\r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)", "response": "Assigns the editor for this entry based on the plugin."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the query instance for this widget.", "response": "def query(self):\r\n        \"\"\"\r\n        Returns the query instance for this widget.\r\n        \r\n        :return     <orb.Query> || <orb.QueryCompound>\r\n        \"\"\"\r\n        queryWidget = self.queryWidget()\r\n        \r\n        # check to see if there is an active container for this widget\r\n        container = queryWidget.containerFor(self)\r\n        if container:\r\n            return container.query()\r\n        \r\n        elif QueryCompound.typecheck(self._query):\r\n            return self._query\r\n        \r\n        # generate a new query from the editor\r\n        column = self.uiColumnDDL.currentSchemaPath()\r\n        plugin = self.currentPlugin()\r\n        editor = self.editor()\r\n        op     = self.uiOperatorDDL.currentText()\r\n        \r\n        if column and plugin:\r\n            query = Query(column)\r\n            plugin.setupQuery(query, op, editor)\r\n            return query\r\n        else:\r\n            return Query()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the joiner operator type for this entry widget.", "response": "def joiner(self):\r\n        \"\"\"\r\n        Returns the joiner operator type for this entry widget.\r\n        \r\n        :return     <QueryCompound.Op>\r\n        \"\"\"\r\n        act = self.uiJoinSBTN.currentAction()\r\n        if not act:\r\n            return None\r\n        elif act.text() == 'AND':\r\n            return QueryCompound.Op.And\r\n        return QueryCompound.Op.Or"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefreshing the buttons for building this sql query.", "response": "def refreshButtons(self):\r\n        \"\"\"\r\n        Refreshes the buttons for building this sql query.\r\n        \"\"\"\r\n        last = self._last\r\n        first = self._first\r\n        \r\n        joiner = self._containerWidget.currentJoiner()\r\n        \r\n        # the first button set can contain the toggle options\r\n        if first:\r\n            self.uiJoinSBTN.setActionTexts(['AND', 'OR'])\r\n        elif joiner == QueryCompound.Op.And:\r\n            self.uiJoinSBTN.setActionTexts(['AND'])\r\n        else:\r\n            self.uiJoinSBTN.setActionTexts(['OR'])\r\n        \r\n        # the last option should not show an active action\r\n        if last:\r\n            self.uiJoinSBTN.setCurrentAction(None)\r\n        \r\n        # otherwise, highlight the proper action\r\n        else:\r\n            act = self.uiJoinSBTN.findAction(QueryCompound.Op[joiner].upper())\r\n            self.uiJoinSBTN.setCurrentAction(act)\r\n        \r\n        enable = QueryCompound.typecheck(self._query) or self.isChecked()\r\n        self.uiEnterBTN.setEnabled(enable)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setEditor(self, editor):\r\n        widget = self.uiEditorAREA.takeWidget()\r\n        if widget:\r\n            widget.close()\r\n        \r\n        if editor is not None:\r\n            editor.setMinimumHeight(28)\r\n            self.uiEditorAREA.setWidget(editor)", "response": "Sets the editor widget for this entry system."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setQuery(self, query):\r\n        if not query.isNull() and hash(query) == hash(self._query):\r\n            return\r\n        \r\n        self._query = query\r\n        \r\n        if QueryCompound.typecheck(query):\r\n            self.uiColumnDDL.hide()\r\n            self.uiOperatorDDL.hide()\r\n            \r\n            # setup the compound editor\r\n            editor = XLineEdit(self)\r\n            editor.setReadOnly(True)\r\n            editor.setText(query.name() + ' %s' % nativestring(query))\r\n            editor.setHint(nativestring(query))\r\n            \r\n            self.setEditor(editor)\r\n        \r\n        else:\r\n            self.uiColumnDDL.show()\r\n            self.uiOperatorDDL.show()\r\n            \r\n            text = query.columnName()\r\n            self.uiColumnDDL.setCurrentSchemaPath(nativestring(text))\r\n            \r\n            self.uiOperatorDDL.blockSignals(True)\r\n            plug = self.currentPlugin()\r\n            if plug:\r\n                op = plug.operator(query.operatorType(), query.value())\r\n                \r\n                index = self.uiOperatorDDL.findText(op)\r\n                if index != -1:\r\n                    self.uiOperatorDDL.setCurrentIndex(index)\r\n            \r\n            self.uiOperatorDDL.blockSignals(False)\r\n        \r\n        self.refreshButtons()", "response": "Sets the query instance for this widget to the inputed query."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the joiner type for this entry widget to the given value.", "response": "def setJoiner(self, joiner):\r\n        \"\"\"\r\n        Sets the join operator type for this entry widget to the given value.\r\n        \r\n        :param      joiner | <QueryCompound.Op>\r\n        \"\"\"\r\n        text = QueryCompound.Op[joiner].upper()\r\n        \r\n        if self._first:\r\n            if self._last:\r\n                self.uiJoinSBTN.setCurrentAction(None)\r\n            else:\r\n                act = self.uiJoinSBTN.findAction(text)\r\n                self.uiJoinSBTN.setCurrentAction(act)\r\n        else:\r\n            self.uiJoinSBTN.actions()[0].setText(text)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the joining method used by the system.", "response": "def updateJoin(self):\r\n        \"\"\"\r\n        Updates the joining method used by the system.\r\n        \"\"\"\r\n        text = self.uiJoinSBTN.currentAction().text()\r\n        if text == 'AND':\r\n            joiner = QueryCompound.Op.And\r\n        else:\r\n            joiner = QueryCompound.Op.Or\r\n        \r\n        self._containerWidget.setCurrentJoiner(self.joiner())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_chinese(name):\n    if not name:\n        return False\n    for ch in name:\n        ordch = ord(ch)\n        if not (0x3400 <= ordch <= 0x9fff) and not (0x20000 <= ordch <= 0x2ceaf) \\\n                and not (0xf900 <= ordch <= ordch) and not (0x2f800 <= ordch <= 0x2fa1f): \n                return False\n    return True", "response": "Check if a symbol is a Chinese character."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pinyin(char, variant='mandarin', sep=' ', out='tones'):\n    if len(char) > 1:\n        return sep.join([pinyin(c, variant=variant, sep=sep, out=out) for c in char])\n\n    if not is_chinese(char):\n        return char\n\n    if char in _cd.GBK: \n        char = gbk2big5(char)\n\n    out_char = _cd.UNIHAN.get(char, {variant: '?({0}'.format(char)}).get(variant, '!({0})'.format(char))\n\n    if out != 'tones':\n        out_char = ''.join([tone_converter.get(x, x) for x in out_char])    \n\n    return out_char", "response": "Retrieve Pinyin of a character."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind a character for a given structure.", "response": "def character_from_structure(motivation):\n    \"\"\"Find a character for a given structure.\"\"\"\n    assert len(motivation) == 3\n\n    _c = {\n            \"+\": \"\u2ff0\",\n            \"-\": \"\u2ff1\",\n            '>': \"\u2ff1\",\n            \"\u624b\": \"\u624c\",\n            \"\u4eba\": \"\u4ebb\",\n            \"\u5200\": \"\u5202\",\n            \"\u4e1d\": \"\u7cf9\",\n            \"\u6c34\": \"\u6c35\",\n            \"0\": \"\u2ff4\",\n            }\n    structure = ''.join([_c.get(x, x) for x in motivation])\n    return _cd.IDS.get(structure, '?')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a Baxter string and return all its contents medial final and tone.", "response": "def parse_baxter(reading):\n    \"\"\"\n    Parse a Baxter string and render it with all its contents, namely\n    initial, medial, final, and tone.\n    \"\"\"\n\n    initial = ''\n    medial = ''\n    final = ''\n    tone = ''\n    \n    # determine environments\n    inienv = True\n    medienv = False\n    finenv = False\n    tonenv = False\n\n    inichars = \"pbmrtdnkgnsyhzl'x\"\n    \n\n    chars = list(reading)\n    for char in chars:\n        \n        # switch environments\n        if char in 'jw' and not finenv:\n            inienv,medienv,finenv,tonenv = False,True,False,False\n        elif char not in inichars or finenv:\n            if char in 'XH':\n                inienv,medienv,finenv,tonenv = False,False,False,True\n            else:\n                inienv,medienv,finenv,tonenv = False,False,True,False\n        \n        # fill in slots\n        if inienv:\n            initial += char\n            \n        if medienv:\n            medial += char\n\n        if finenv:\n            final += char\n\n        if tonenv:\n            tone += char\n\n    # post-parse tone\n    if not tone and final[-1] in 'ptk':\n        tone = 'R'\n    elif not tone:\n        tone = 'P'\n\n    # post-parse medial\n    if 'j' not in medial and 'y' in initial:\n        medial += 'j'\n\n    # post-parse labial\n    if final[0] in 'u' and 'w' not in medial:\n        medial = 'w' + medial\n\n    return initial,medial,final,tone"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the TLS basic gloss for a list of characters.", "response": "def chars2gloss(chars):\n    \"\"\"\n    Get the TLS basic gloss for a characters.\n    \"\"\"\n    out = []\n    chars = gbk2big5(chars)\n    for char in chars:\n        tmp = []\n        if char in _cd.TLS:\n            for entry in _cd.TLS[char]:\n                baxter = _cd.TLS[char][entry]['UNIHAN_GLOSS']\n                if baxter != '?':\n                    tmp += [baxter]\n        out += [','.join(tmp)]\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sixtuple2baxter(chars, debug=False, rhymebook=None):\n    if not rhymebook:\n        rhymebook = _cd.GY\n\n    if len(chars) != 6:\n        raise ValueError('chars should be a sixtuple')\n    \n    # convert chars to long chars\n    chars = gbk2big5(chars)\n\n    # assign basic values\n    she,hu,deng,diao,yun,sheng = list(chars) \n    \n    # try converting the values to mch representations\n    initial = rhymebook['sheng'].get(sheng, '?')\n    final = rhymebook['yun'].get(yun, '?')\n    tone = rhymebook['diao'].get(diao, '?')\n    medial = rhymebook['hu'].get(hu, '?')\n    division = rhymebook['deng'].get(deng, '?')\n        \n    # debug is for cross-checking\n    if debug:\n        return [(sheng, initial), (hu, medial), (deng, division),(yun, final),\n                (diao, tone)]\n\n    # check and raise error if things are not handled\n    if \"?\" in [initial, final, tone, medial, division]:\n        raise ValueError(\"Unrecognized elements in {0}.\".format(\n            ' '.join([initial, final, tone, medial, division])))\n\n    # treat the final if division is 3 and they start with 'j', note that so\n    # far, we don't handle chongnius\n    final = final[1:] if final[0] == 'j' and division in '4' \\\n            else final\n    final = final[1:] if final[0] == 'j' and division in '3' \\\n            else final\n\n    # reduce finals starting with 'w'\n    final = final[1:] if final[0] == 'w' else final\n    \n    # resolve the medial (the hu) by checking for labial initial\n    medial = '' if (initial[0] in 'pbm' and '*' not in final) \\\n            or final[0] in 'u' \\\n            or 'o' in final and not '*' in final and not '?' in final \\\n            else medial\n    \n    # correct for initials with sandeng-i\n    initial = initial[:-1] if initial.endswith('j') else initial\n\n    # get the medial corrected by deng\n    medial = \"j\" + medial if division == '3' \\\n            and 'i' not in final \\\n            and 'y' not in initial \\\n            else medial\n\n    # deprive the rime from its leading \"j\" if we have a medial\n    final = final[1:] if final[0] in 'j' and 'j' in medial else final\n    final = final[1:] if final[0] in 'w' and 'w' in medial else final\n    final = final[1:] if final[0] == '*' or final[0] == '?' else final\n    final = 'i' + final[1:] if final[0] == '!' \\\n            and division == '4' \\\n            and 'i' not in final \\\n            and (initial[0] in \"pbmkgx'\" or initial.startswith('ng')) \\\n            else final\n\n    # chongniu medial-re-order\n    medial = 'j' + medial if division == '4' \\\n            and '!' in final \\\n            and 'j' not in medial \\\n            and (initial[0] in \"pbmkgx'\" or initial.startswith('ng')) \\\n            else medial\n\n    final = final[1:] if final[0] == '!' else final\n    \n    # put everything together\n    return [initial,medial,final,tone]", "response": "Convert a six - tuple representation of MCH readings into a Baxter - compatible list of IPA - encoded readings."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a normal ipa string into a prostring for Chinese dialects.", "response": "def analyze_sequence(ipa):\n    \"\"\"\n    Convert a normal ipa string into a prostring for Chinese dialects.\n    \"\"\"\n    # we need some very good strategy here, which should be lightwayt and easy\n    # to re-implement in other languages (e.g. JS)\n\n    # get sound-class rep of stirng first\n    seqs = re.split('([\u2081\u2082\u2083\u2084\u2085\u2086\u2080\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2070])+', ipa)\n    out = ''\n    for i in range(len(seqs)):\n        seqs = ipa2tokens(tokens2class(ipa, merge_vowels=False, expand_nasals=True),'asjp')\n    \n        D = {}\n\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fanqie2mch(fanqie, debug=False):\n    \n    # check for gbk\n    fanqie = gbk2big5(fanqie)\n    \n    # get normal vals\n    shangxia = chars2baxter(fanqie)\n   \n    # check for good fixed solutions in our dictionary\n    if fanqie[0] in _cd.GY['sheng']:\n        shang = _cd.GY['sheng'][fanqie[0]]+'a'\n    else:\n        shang = shangxia[0]\n\n    xia = shangxia[1]\n\n    # check for bad vals\n    if ' ' in shang:\n        shang = shang[:shang.index(' ')]\n    if ' ' in xia:\n        xia = xia[:xia.index(' ')]\n\n    if ',' in shang or ',' in xia or not shang or not xia:\n        raise ValueError('fanqie {0} {1} is ambiguous'.format(shang,xia))\n    \n    # parse chars\n    shangp = parse_baxter(shang)\n    xiap = parse_baxter(xia)\n    \n    if debug:\n        return '.'.join(shangp),'.'.join(xiap),shang,xia\n    \n    i = shangp[0]\n    m = xiap[1]\n    f = xiap[2]\n    t = xiap[3].replace('P','').replace('R','') # ugly, change later XXX\n    \n    # clean medial-relations\n    if ('y' in i or 'i' in f) and 'j' in m:\n        m = m.replace('j','')\n    if 'u' in f and 'w' in m:\n        m = m.replace('w','')\n        \n    return ''.join([i,m,f,t])", "response": "Convert a F\u01cenqi\u00e8 reading to it s MCH counterpart."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef baxter2ipa(mch, segmented=False):\n\n    out = mch\n    if out[-1] in 'ptk':\n        out += 'R'\n    elif out[-1] not in 'XHP':\n        out += 'P'\n        \n    for s,t in _cd.GY['ipa']: \n        out = out.replace(s,t)\n    if segmented:\n        return parse_chinese_morphemes(out) \n    return out", "response": "Convert Baxter MCH to IPA MCH."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting from gbk format to big5 representation of chars.", "response": "def gbk2big5(chars):\n    \"\"\"\n    Convert from gbk format to big5 representation of chars.\n    \"\"\"\n    out = ''\n    for char in chars:\n        if char in _cd.GBK:\n            out += _cd.BIG5[_cd.GBK.index(char)]\n        else:\n            out += char\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef big52gbk(chars):\n    out = ''\n    for char in chars:\n        if char in _cd.BIG5:\n            out += _cd.GBK[_cd.BIG5.index(char)]\n        else:\n            out += char\n    return out", "response": "Convert from long chars to short chars."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_chinese_morphemes(seq, context=False):\n    \n    # get the tokens\n    if isinstance(seq, list):\n        tokens = [s for s in seq]\n    else:\n        tokens = lingpy.ipa2tokens(seq, merge_vowels=False)\n    \n    # get the sound classes according to the art-model\n    arts = [int(x) for x in lingpy.tokens2class(tokens, _art, cldf=True)]\n\n    # get the pro-string\n    prostring = lingpy.prosodic_string(arts)\n\n    # parse the zip of tokens and arts\n    I,M,N,C,T = '','','','',''\n    \n    ini = False\n    med = False\n    nuc = False\n    cod = False\n    ton = False\n    \n    triples = [('?','?','?')]+list(zip(\n        tokens,arts,prostring))+[('?','?','?')]\n\n    for i in range(1,len(triples)-1): #enumerate(triples[1:-1]): #zip(tokens,arts,prostring):\n        \n        t,c,p = triples[i]\n        _t,_c,_p = triples[i-1]\n        t_,c_,p_ = triples[i+1]\n\n        # check for initial entry first\n        if p == 'A' and _t == '?':\n\n            # now, if we have a j-sound and a vowel follows, we go directly to\n            # medial environment\n            if t[0] in 'j\u0265w':\n                med = True\n                ini,nuc,cod,ton = False,False,False,False\n            else:\n                ini = True\n                med,nuc,doc,ton = False,False,False,False\n        \n        # check for initial vowel\n        elif p == 'X' and _t == '?':\n            if t[0] in 'iuy' and c_ == '7':\n                med = True\n                ini,nuc,cod,ton = False,False,False,False\n            else:\n                nuc = True\n                ini,med,cod,ton = False,False,False,False\n\n        # check for medial after initial\n        elif p == 'C':\n            med = True\n            ini,nuc,cod,ton = False,False,False,False\n\n        # check for vowel medial \n        elif p == 'X' and p_ == 'Y':\n            \n            # if we have a medial vowel, we classify it as medial\n            if t in 'iyu':\n                med = True\n                ini,nuc,cod,ton = False,False,False,False\n            else:\n                nuc = True\n                ini,med,cod,ton = False,False,False,False\n\n        # check for vowel without medial\n        elif p == 'X' or p == 'Y':\n            if p_ in 'LTY' or p_ == '?':\n                nuc = True\n                ini,med,cod,ton = False,False,False,False\n            elif p == 'Y':\n                nuc = True\n                ini,med,cod,ton = 4 * [False]\n            else:\n                cod = True\n                ini,med,nuc,ton = 4 * [False]\n        \n        # check for consonant\n        elif p == 'L':\n            cod = True\n            ini,med,nuc,ton = 4 * [False]\n\n        # check for tone\n        elif p == 'T':\n            ton = True\n            ini,med,nuc,cod = 4 * [False]\n\n        if ini:\n            I += t\n        elif med:\n            M += t\n        elif nuc:\n            N += t\n        elif cod:\n            C += t\n        else:\n            T += t\n    \n    # bad conversion for output, but makes what it is supposed to do\n    out = [I,M,N,C,T]\n    tf = lambda x: x if x else '-'\n    out = [tf(x) for x in out]\n    \n    # transform tones to normal letters\n    tones = dict(zip('\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\u2070\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\u2080','1234567890123456789'))\n\n    # now, if context is wanted, we'll yield that\n    ic = '1' if [x for x in I if x in 'bdgmn\u014b\u0235\u0273\u0274'] else '0'\n    mc = '1' if [m for m in M+N if m in 'ijy\u0265'] else '0'\n    cc = '1' if C in 'ptk\u0294' else '0'\n    tc = ''.join([tones.get(x, x) for x in T])\n\n    IC = '/'.join(['I',ic,mc,cc,tc]) if I else ''\n    MC = '/'.join(['M',ic,mc,cc,tc]) if M else ''\n    NC = '/'.join(['N',ic,mc,cc,tc]) if N else ''\n    CC = '/'.join(['C',ic,mc,cc,tc]) if C else ''\n    TC = '/'.join(['T',ic,mc,cc,tc]) if T else ''\n\n    if context:\n        return out, [x for x in [IC,MC,NC,CC,TC] if x]\n    return out", "response": "Parse a Chinese syllable and return its basic structure."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reconnect(self):\n        self._converters.clear()\n        self._gateway = None\n        self._xsltFactory = None\n        try:\n            # print(\"Starting Java gateway on port: %s\" % self._gwPort)\n            self._gateway = JavaGateway(GatewayClient(port=self._gwPort))\n            self._xsltFactory = self._gateway.jvm.org.pyjxslt.XSLTTransformerFactory('')\n            self._refresh_converters()\n        except (socket.error, Py4JNetworkError) as e:\n            print(e)\n            self._gateway = None\n            return False\n        return True", "response": "Re - establish the gateway connection"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds or update a transform.", "response": "def add_transform(self, key, xslt):\n        \"\"\" Add or update a transform.\n\n        @param key: Transform key to use when executing transformations\n        @param xslt: Text or file name of an xslt transform\n\n        \"\"\"\n        self._remove_converter(key)\n        self._xsltLibrary[key] = xslt\n        self._add_converter(key)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefreshing all of the converters in the py4j library", "response": "def _refresh_converters(self):\n        \"\"\" Refresh all of the converters in the py4j library\n        @return: True if all converters were succesfully updated\n        \"\"\"\n        self._converters.clear()\n        return reduce(lambda a, b: a and b, [self._add_converter(k) for k in list(self._xsltLibrary.keys())], True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntransforming the supplied XML using the specified key.", "response": "def transform(self, key, xml, **kwargs):\n        \"\"\"\n        Transform the supplied XML using the transform identified by key\n        @param key: name of the transform to apply\n        @param xml: XML to transform\n        @param kwargs: XSLT parameters\n        @return: Transform output or None if transform failed\n        \"\"\"\n        if key in self._xsltLibrary and self.gateway_connected() and key in self._converters:\n            return self._converters[key].transform(xml, self._parms(**kwargs))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def items(self, *, dc=None, watch=None, consistency=None):\n        response = await self._api.get(\"/v1/query\", params={\"dc\": dc})\n        return response.body", "response": "Provides a listing of all prepared queries in a given datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def create(self, query, *, dc=None):\n\n        if \"Token\" in query:\n            # in case of a full token object...\n            query[\"Token\"] = extract_attr(query[\"Token\"], keys=[\"ID\"])\n\n        response = await self._api.post(\"/v1/query\",\n                                        params={\"dc\": dc}, data=query)\n        return response.body", "response": "Creates a new prepared query for the given query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def read(self, query, *, dc=None, watch=None, consistency=None):\n        query_id = extract_attr(query, keys=[\"ID\"])\n\n        response = await self._api.get(\"/v1/query\", query_id, params={\n            \"dc\": dc}, watch=watch, consistency=consistency)\n        result = response.body[0]\n        return result", "response": "Fetches existing prepared query\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def update(self, query, *, dc=None):\n        query_id = extract_attr(query, keys=[\"ID\"])\n        response = await self._api.put(\"/v1/query\", query_id,\n                                       params={\"dc\": dc}, data=query)\n        return response.status == 200", "response": "Updates existing prepared query with new data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def delete(self, query, *, dc=None):\n        query_id = extract_attr(query, keys=[\"ID\"])\n        response = await self._api.delete(\"/v1/query\", query_id,\n                                          params={\"dc\": dc})\n        return response.status == 200", "response": "Delete existing prepared query\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def execute(self, query, *,\n                      dc=None, near=None, limit=None, consistency=None):\n        \"\"\"Executes a prepared query\n\n        Parameters:\n            query (ObjectID): Query ID\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            near (str): Sort the resulting list in ascending order based on\n                        the estimated round trip time from that node\n            limit (int): Limit the list's size to the given number of nodes\n            consistency (Consistency): Force consistency\n        Returns:\n            Object:\n        Raises:\n            NotFound: the query does not exist\n\n        Returns a body like this::\n\n            {\n                \"Service\": \"redis\",\n                \"Nodes\": [\n                    {\n                        \"Node\": {\n                            \"Node\": \"foobar\",\n                            \"Address\": \"10.1.10.12\",\n                            \"TaggedAddresses\": {\n                                \"lan\": \"10.1.10.12\",\n                                \"wan\": \"10.1.10.12\"\n                            }\n                        },\n                        \"Service\": {\n                            \"ID\": \"redis\",\n                            \"Service\": \"redis\",\n                            \"Tags\": None,\n                            \"Port\": 8000\n                        },\n                        \"Checks\": [\n                            {\n                                \"Node\": \"foobar\",\n                                \"CheckID\": \"service:redis\",\n                                \"Name\": \"Service 'redis' check\",\n                                \"Status\": \"passing\",\n                                \"Notes\": \"\",\n                                \"Output\": \"\",\n                                \"ServiceID\": \"redis\",\n                                \"ServiceName\": \"redis\"\n                            },\n                            {\n                                \"Node\": \"foobar\",\n                                \"CheckID\": \"serfHealth\",\n                                \"Name\": \"Serf Health Status\",\n                                \"Status\": \"passing\",\n                                \"Notes\": \"\",\n                                \"Output\": \"\",\n                                \"ServiceID\": \"\",\n                                \"ServiceName\": \"\"\n                            }\n                        ],\n                        \"DNS\": {\n                            \"TTL\": timedelta(seconds=10)\n                        },\n                        \"Datacenter\": \"dc3\",\n                        \"Failovers\": 2\n                    }\n                ]\n            }\n\n        The **Nodes** section contains the list of healthy nodes providing\n        the given service, as specified by the constraints of the prepared\n        query.\n\n        **Service** has the service name that the query was selecting. This is\n        useful for context in case an empty list of nodes is returned.\n\n        **DNS** has information used when serving the results over DNS. This\n        is just a copy of the structure given when the prepared query was\n        created.\n\n        **Datacenter** has the datacenter that ultimately provided the list of\n        nodes and **Failovers** has the number of remote datacenters that were\n        queried while executing the query. This provides some insight into\n        where the data came from. This will be zero during non-failover\n        operations where there were healthy nodes found in the local\n        datacenter.\n        \"\"\"\n        query_id = extract_attr(query, keys=[\"ID\"])\n        response = await self._api.get(\n            \"/v1/query/%s/execute\" % query_id,\n            params={\"dc\": dc, \"near\": near, \"limit\": limit},\n            consistency=consistency)\n        return response.body", "response": "Executes a prepared query on the given ID and returns the result as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches existing prepared query", "response": "async def explain(self, query, *, dc=None, consistency=None):\n        \"\"\"Fetches existing prepared query\n\n        Parameters:\n            query (ObjectID): Query ID\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            Object: the query\n        Raises:\n            NotFound: the query does not exist\n        \"\"\"\n        query_id = extract_attr(query, keys=[\"ID\"])\n        path = \"/v1/query/%s/explain\" % query_id\n        response = await self._api.get(path, consistency=consistency, params={\n            \"dc\": dc})\n        result = response.body\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the inputed records as children to this item.", "response": "def loadRecords(self, records):\r\n        \"\"\"\r\n        Loads the inputed records as children to this item.\r\n        \r\n        :param      records | [<orb.Table>, ..] || {<str> sub: <variant>, .. }\r\n        \"\"\"\r\n        self.setChildIndicatorPolicy(self.DontShowIndicatorWhenChildless)\r\n        self._loaded = True\r\n        \r\n        if records is None:\r\n            return\r\n        \r\n        # load sub-groups if desired\r\n        if self._nextLevels and RecordSet.typecheck(records):\r\n            level = self._nextLevels[0]\r\n            sublevels = self._nextLevels[1:]\r\n            \r\n            records = records.grouped(level)\r\n            \r\n        elif RecordSet.typecheck(records):\r\n            sublevels = None\r\n            records = records.all()\r\n        \r\n        else:\r\n            sublevels = None\r\n        \r\n        # load a child set of groups\r\n        if type(records) == dict:\r\n            try:\r\n                generator = self.treeWidget().createGroupItem\r\n                cls = None\r\n            except AttributeError:\r\n                generator = None\r\n                cls = type(self)\r\n                \r\n            for subgroup, subrecords in records.items():\r\n                if generator:\r\n                    generator(subgroup, subrecords, sublevels, self)\r\n                elif cls:\r\n                    cls(self, subgroup, subrecords, sublevels)\r\n        \r\n        # load records\r\n        else:\r\n            try:\r\n                generator = self.treeWidget().createRecordItem\r\n                cls = None\r\n            except AttributeError:\r\n                generator = None\r\n                cls = XOrbRecordItem\r\n            \r\n            cls = self.treeWidget().createRecordItem\r\n            for record in records:\r\n                if generator:\r\n                    generator(record, self)\r\n                elif cls:\r\n                    cls(self, record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the records from the query set linked with this item.", "response": "def load(self):\r\n        \"\"\"\r\n        Loads the records from the query set linked with this item.\r\n        \"\"\"\r\n        if self._loaded:\r\n            return\r\n        \r\n        rset = self.recordSet()\r\n        \r\n        QApplication.setOverrideCursor(Qt.WaitCursor)\r\n        self.loadRecords(rset)\r\n        QApplication.restoreOverrideCursor()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the datasets for this renderer.", "response": "def calculateDatasets(self, scene, axes, datasets):\r\n        \"\"\"\r\n        Builds the datasets for this renderer.  Each renderer will need to\r\n        subclass and implemenent this method, otherwise, no data will be\r\n        shown in the chart.\r\n        \r\n        :param      scene | <XChartScene>\r\n                    axes | [<\r\n                    datasets | [<XChartDataset>, ..]\r\n        \"\"\"\r\n        items = self.calculateDatasetItems(scene, datasets)\r\n        if not items:\r\n            scene.clear()\r\n            return\r\n        \r\n        xaxis = scene.chart().horizontalAxis()\r\n        yaxis = scene.chart().verticalAxis()\r\n        data_axis = None\r\n        all_values = []\r\n        \r\n        # determine if we're mapping data aginst the sets themselves, in\r\n        # which case, create a pie chart of the dataset vs. its \r\n        if isinstance(xaxis, XDatasetAxis):\r\n            per_dataset = False\r\n            data_axis = yaxis\r\n            total = 1\r\n        \r\n        elif isinstance(yaxis, XDatasetAxis):\r\n            per_dataset = False\r\n            total = 1\r\n            data_axis = xaxis\r\n        \r\n        else:\r\n            per_dataset = True\r\n            total = len(items)\r\n        \r\n        if not per_dataset:\r\n            all_values = [dataset.sum(data_axis) \\\r\n                          for dataset in datasets]\r\n        \r\n        # generate the build information\r\n        rect = self.buildData('grid_rect')\r\n        rect.setX(rect.x() + 10)\r\n        rect.setY(rect.y() + 10)\r\n        rect.setWidth(rect.width() - 20)\r\n        rect.setHeight(rect.height() - 20)\r\n        \r\n        if rect.width() > rect.height():\r\n            radius = min(rect.width() / 2.0, rect.height() / 2.0)\r\n            x = rect.left()\r\n            y = rect.top() + radius\r\n            deltax = min(radius * 2, rect.width() / float(total + 1))\r\n            deltay = 0\r\n        else:\r\n            radius = min(rect.height() / 2.0, rect.width() / 2.0)\r\n            x = rect.left() + radius\r\n            y = rect.top()\r\n            deltax = 0\r\n            deltay = min(radius * 2, rect.height() / float(total + 1))\r\n        \r\n        # initialize the first pie chart\r\n        angle = 0\r\n        cx = x + deltax\r\n        cy = y + deltay\r\n        \r\n        x += deltax\r\n        y += deltay\r\n        \r\n        self.setBuildData('center', QPointF(cx, cy))\r\n        self.setBuildData('radius', radius)\r\n        \r\n        for dataset in datasets:\r\n            item = items.get(dataset)\r\n            if not item:\r\n                continue\r\n            \r\n            item.setBuildData('center', QPointF(cx, cy))\r\n            item.setBuildData('radius', radius)\r\n            \r\n            subpaths = []\r\n            bound = QRectF(cx-radius, cy-radius, radius * 2, radius * 2)\r\n            path = QPainterPath()\r\n            if per_dataset:\r\n                data_values = dataset.values(yaxis.name())\r\n                andle = 0\r\n                for value in dataset.values():\r\n                    perc = yaxis.percentOfTotal(value.get(yaxis.name()),\r\n                                                data_values)\r\n                    \r\n                    # calculate the angle as the perc\r\n                    item_angle = perc * 360\r\n                    \r\n                    subpath = QPainterPath()\r\n                    subpath.moveTo(cx, cy)\r\n                    subpath.arcTo(bound, angle, item_angle)\r\n                    subpath.lineTo(cx, cy)\r\n                    \r\n                    path.addPath(subpath)\r\n                    subpaths.append((value.get(xaxis.name()), subpath))\r\n                    \r\n                    angle += item_angle\r\n                    \r\n                cx = x + deltax\r\n                cy = y + deltay\r\n                \r\n                x += deltax\r\n                y += deltay\r\n            else:\r\n                value = dataset.sum(data_axis)\r\n                perc = data_axis.percentOfTotal(value, all_values)\r\n                \r\n                # calculate the angle as the perc\r\n                item_angle = perc * 360\r\n                \r\n                subpath = QPainterPath()\r\n                subpath.moveTo(cx, cy)\r\n                subpath.arcTo(bound, angle, item_angle)\r\n                subpath.lineTo(cx, cy)\r\n                \r\n                path.addPath(subpath)\r\n                subpaths.append((value, subpath))\r\n                \r\n                angle += item_angle\r\n                \r\n            item.setPath(path)\r\n            item.setBuildData('subpaths', subpaths)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing the item as a bar graph.", "response": "def drawItem(self, item, painter, option):\r\n        \"\"\"\r\n        Draws the inputed item as a bar graph.\r\n        \r\n        :param      item    | <XChartDatasetItem>\r\n                    painter | <QPainter>\r\n                    option  | <QStyleOptionGraphicsItem>\r\n        \"\"\"\r\n        dataset = item.dataset()\r\n        \r\n        painter.save()\r\n        painter.setRenderHint(painter.Antialiasing)\r\n        \r\n        center = item.buildData('center')\r\n        radius = item.buildData('radius')\r\n        \r\n        if int(option.state) & QStyle.State_MouseOver != 0:\r\n            alpha = 20\r\n            mouse_over = True\r\n        else:\r\n            alpha = 0\r\n            mouse_over = False\r\n        \r\n        for value, subpath in item.buildData('subpaths', []):\r\n            clr = dataset.color(value)\r\n            \r\n            bg = clr.lighter(110)\r\n            bg.setAlpha(alpha + 100)\r\n            painter.setBrush(bg)\r\n            \r\n            if mouse_over:\r\n                scale = 1.08\r\n                dx = (center.x() / scale) - center.x()\r\n                dy = (center.y() / scale) - center.y()\r\n                \r\n                painter.save()\r\n                painter.scale(scale, scale)\r\n                painter.translate(dx, dy)\r\n                painter.setPen(Qt.NoPen)\r\n                painter.drawPath(subpath)\r\n                painter.restore()\r\n            \r\n            pen = QPen(clr)\r\n            pen.setWidth(0.5)\r\n            painter.setPen(pen)\r\n            \r\n            painter.drawPath(subpath)\r\n            \r\n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a handler for standalone mode.", "response": "def _make_standalone_handler(preamble):\n    \"\"\"Class factory used so that preamble can be passed to :py:class:`_StandaloneHandler`\n     without use of static members\"\"\"\n    class _StandaloneHandler(BaseHTTPRequestHandler, object):\n        \"\"\"HTTP Handler for standalone mode\"\"\"\n\n        def do_GET(self):\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json; charset=utf-8')\n            self.send_header('Content-length', len(preamble))\n            self.end_headers()\n            self.wfile.write(preamble.encode('utf-8'))\n\n        def log_message(self, format, *args):\n            # suppress logging on requests\n            return\n    return _StandaloneHandler"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmonitor health checks from the plugin.", "response": "def _monitor(last_ping, stop_plugin, is_shutting_down, timeout=5):\n    \"\"\"Monitors health checks (pings) from the Snap framework.\n\n    If the plugin doesn't receive 3 consecutive health checks from Snap the\n    plugin will shutdown.  The default timeout is set to 5 seconds.\n    \"\"\"\n    _timeout_count = 0\n    _last_check = time.time()\n    _sleep_interval = 1\n    # set _sleep_interval if less than the timeout\n    if timeout < _sleep_interval:\n        _sleep_interval = timeout\n    while True:\n        time.sleep(_sleep_interval)\n        # Signals that stop_plugin has been called\n        if is_shutting_down():\n            return\n        # have we missed a ping during the last timeout duration\n        if ((time.time() - _last_check) > timeout) and ((time.time() - last_ping()) > timeout):\n            # reset last_check\n            _last_check = time.time()\n            _timeout_count += 1\n            LOG.warning(\"Missed ping health check from the framework. \" +\n                        \"({} of 3)\".format(_timeout_count))\n            if _timeout_count >= 3:\n                stop_plugin()\n                return\n        elif (time.time() - last_ping()) <= timeout:\n            _timeout_count = 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprepare simple table with spacing based on content", "response": "def _tabulate(rows, headers, spacing=5):\n    \"\"\"Prepare simple table with spacing based on content\"\"\"\n    if len(rows) == 0:\n        return \"None\\n\"\n    assert len(rows[0]) == len(headers)\n    count = len(rows[0])\n    widths = [0 for _ in range(count)]\n    rows = [headers] + rows\n\n    for row in rows:\n        for index, field in enumerate(row):\n            if len(str(field)) > widths[index]:\n                widths[index] = len(str(field))\n\n    output = \"\"\n    for row in rows:\n        for index, field in enumerate(row):\n            field = str(field)\n            output += field + (widths[index] - len(field) + spacing) * \" \"\n        output += \"\\n\"\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_item(self, item):\n        if not(isinstance(item.name, basestring) and isinstance(item.description, basestring)):\n            raise TypeError(\"Name and description should be strings, are of type {} and {}\"\n                            .format(type(item.name), type(item.description)))\n        if not(isinstance(item.flag_type, FlagType)):\n            raise TypeError(\"Flag type should be of type FlagType, is of {}\".format(type(item.flag_type)))\n\n        if item.name not in self._flags:\n            if item.default is not None:\n                if item.default is not False:\n                    item.description = item.description + \" (default: %(default)s)\"\n                self._flags[item.name] = item\n            else:\n                self._flags[item.name] = item", "response": "Adds single command line flag to internal flag list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding multiple flags to the command line", "response": "def add_multiple(self, flags):\n        \"\"\"Add multiple command line flags\n\n        Arguments:\n            flags (:obj:`list` of :obj:`tuple`): List of flags\n                in tuples (name, flag_type, description, (optional) default)\n\n        Raises:\n            TypeError: Provided wrong arguments or arguments of wrong types, method will raise TypeError\n        \"\"\"\n        if not isinstance(flags, list):\n            raise TypeError(\"Expected list of flags, got object of type{}\".format(type(flags)))\n        for flag in flags:\n            if isinstance(flag, Flag):\n                self.add_item(flag)\n            elif isinstance(flag, tuple):\n                try:\n                    item = Flag(*flag)\n                    self.add_item(item)\n                except TypeError as e:\n                    raise TypeError(\"Invalid arguments to initialize a flag definition, expect ({0} [, {1}]) but got {3}\"\n                        .format(\", \".join(Flag.REQUIRED_FIELDS),\n                        \", \".join(Flag.OPTIONAL_FIELDS), flag))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dragEnterEvent( self, event ):\r\n        filt = self.dragDropFilter()\r\n        if ( not filt ):\r\n            super(XCalendarWidget, self).dragEnterEvent(event)\r\n            return\r\n        \r\n        filt(self, event)", "response": "Processes the drag drop event using the filter set by the setDragDropFilter method."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess the drag drop event using the filter set by the setDragDropFilter method and returns the new event object.", "response": "def dragMoveEvent( self, event ):\r\n        \"\"\"\r\n        Processes the drag drop event using the filter set by the \\\r\n        setDragDropFilter\r\n        \r\n        :param      event | <QDragEvent>\r\n        \"\"\"\r\n        filt = self.dragDropFilter()\r\n        if ( not filt ):\r\n            super(XCalendarWidget, self).dragMoveEvent(event)\r\n            return\r\n        \r\n        filt(self, event)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dragDropFilter( self ):\r\n        filt = None\r\n        if ( self._dragDropFilterRef ):\r\n            filt = self._dragDropFilterRef()\r\n        \r\n        if ( not filt ):\r\n            self._dragDropFilterRef = None\r\n        \r\n        return filt", "response": "Returns a drag and drop filter method."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the drag drop event using the dragDropFilter set by the XCalendarWidget class.", "response": "def dropEvent( self, event ):\r\n        \"\"\"\r\n        Processes the drag drop event using the filter set by the \\\r\n        setDragDropFilter\r\n        \r\n        :param      event | <QDropEvent>\r\n        \"\"\"\r\n        filt = self.dragDropFilter()\r\n        if ( not filt ):\r\n            super(XCalendarWidget, self).dropEvent(event)\r\n            return\r\n        \r\n        filt(self, event)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngoing to the next date based on the current mode and date.", "response": "def gotoNext( self ):\r\n        \"\"\"\r\n        Goes to the next date based on the current mode and date.\r\n        \"\"\"\r\n        scene = self.scene()\r\n        date  = scene.currentDate()\r\n        \r\n        # go forward a day\r\n        if ( scene.currentMode() == scene.Mode.Day ):\r\n            scene.setCurrentDate(date.addDays(1))\r\n        \r\n        # go forward a week\r\n        elif ( scene.currentMode() == scene.Mode.Week ):\r\n            scene.setCurrentDate(date.addDays(7))\r\n        \r\n        # go forward a month\r\n        elif ( scene.currentMode() == scene.Mode.Month ):\r\n            scene.setCurrentDate(date.addMonths(1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles the mouse press event.", "response": "def mousePressEvent( self, event ):\r\n        \"\"\"\r\n        Handles the mouse press event.\r\n        \r\n        :param      event | <QMouseEvent>\r\n        \"\"\"\r\n        scene_point = self.mapToScene(event.pos())\r\n        date        = self.scene().dateAt(scene_point)\r\n        date_time   = self.scene().dateTimeAt(scene_point)\r\n        item        = self.scene().itemAt(scene_point)\r\n        \r\n        if ( not isinstance(item, XCalendarItem) ):\r\n            item = None\r\n        \r\n        # checks to see if the signals are blocked\r\n        if ( not self.signalsBlocked() ):\r\n            if ( item ):\r\n                self.calendarItemClicked.emit(item)\r\n            \r\n            elif ( date_time.isValid() ):\r\n                self.dateTimeClicked.emit(date_time)\r\n            \r\n            elif ( date.isValid() ):\r\n                self.dateClicked.emit(date)\r\n        \r\n        return super(XCalendarWidget, self).mousePressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mouseDoubleClickEvent( self, event ):\r\n        scene_point = self.mapToScene(event.pos())\r\n        date        = self.scene().dateAt(scene_point)\r\n        date_time   = self.scene().dateTimeAt(scene_point)\r\n        item        = self.scene().itemAt(scene_point)\r\n        \r\n        if ( not isinstance(item, XCalendarItem) ):\r\n            item = None\r\n        \r\n        # checks to see if the signals are blocked\r\n        if ( not self.signalsBlocked() ):\r\n            if ( item ):\r\n                self.calendarItemDoubleClicked.emit(item)\r\n            \r\n            elif ( date_time.isValid() ):\r\n                self.dateTimeDoubleClicked.emit(date_time)\r\n            \r\n            elif ( date.isValid() ):\r\n                self.dateDoubleClicked.emit(date)\r\n        \r\n        return super(XCalendarWidget, self).mouseDoubleClickEvent(event)", "response": "Handles the mouse double click event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCurrentMode( self, mode ):\n        self.scene().setCurrentMode(mode)\r\n        self.scene().setSceneRect(0, 0, self.width() - 5, self.height() - 5)\r\n        if ( not self.signalsBlocked() ):\r\n            self.currentModeChanged.emit(mode)", "response": "Sets the current mode that this calendar will be displayed in."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrestoring the dataset settings to the inputed data set for the given key.", "response": "def restoreDataSet( settings, key, dataSet ):\n    \"\"\"\n    Restores the dataset settings to the inputed data set for the given key.\n    \n    :param      settings | <QSettings>\n                key      | <str>\n                dataSet  | <projex.dataset.DataSet>\n    \"\"\"\n    for datakey in dataSet.keys():\n        vtype = unwrapVariant(settings.value('%s/%s/type' % (key, datakey)))\n        value = unwrapVariant(settings.value('%s/%s/value' % (key, datakey)))\n        \n        if ( vtype is None ):\n            continue\n        \n        vtype = nativestring(vtype)\n        \n        if ( vtype in _dataValueTypes ):\n            datavalue = _dataValueTypes[vtype][1](value)\n        else:\n            logger.warning('Could not restore %s' % vtype)\n            continue\n        \n        if ( type(datavalue).__name__ == 'QString' ):\n            datavalue = unicode(datavalue)\n        \n        dataSet.setValue(datakey, datavalue)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef saveDataSet( settings, key, dataSet ):\n    for datakey, value in dataSet.items():\n        datatype  = type(value).__name__\n        \n        if ( datatype in _dataValueTypes ):\n            datavalue = _dataValueTypes[datatype][0](value)\n        else:\n            datavalue = value\n        \n        settings.setValue('%s/%s/type' % (key, datakey), wrapVariant(datatype))\n        settings.setValue('%s/%s/value' % (key, datakey), wrapVariant(datavalue))", "response": "Saves the dataset settings for the given key to the inputed data set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef centerOn(self, *args):\r\n        super(XNodeWidget, self).centerOn(*args)\r\n        \r\n        for con in self.connections():\r\n            con.setPath(con.rebuild())\r\n            con.update()", "response": "Updates the center on method to ensure the viewport is updated."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nanimate the centering options over a given number of seconds.", "response": "def centerOnAnimated(self, centerOn, animate=0):\r\n        \"\"\"\r\n        Animates the centering options over a given number of seconds.\r\n        \r\n        :param      centerOn | <QRectF> | <QPointF> | <XNode>\r\n                    animate  | <float> | seconds\r\n        \"\"\"\r\n        if isinstance(centerOn, XNode):\r\n            center = centerOn.sceneRect().center()\r\n        elif isinstance(centerOn, QRectF):\r\n            center = centerOn.center()\r\n        elif isinstance(centerOn, QPointF):\r\n            center = centerOn\r\n        else:\r\n            return\r\n        \r\n        anim = XObjectAnimation(self, 'centerOn', self)\r\n        anim.setStartValue(self.viewportRect().center())\r\n        anim.setEndValue(center)\r\n        anim.setDuration(1000 * animate)\r\n        anim.start()\r\n        anim.finished.connect(anim.deleteLater)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncenter on the given items.", "response": "def centerOnItems(self, items = None):\r\n        \"\"\"\r\n        Centers on the given items, if no items are supplied, then all\r\n        items will be centered on.\r\n        \r\n        :param      items | [<QGraphicsItem>, ..]\r\n        \"\"\"\r\n        if not items:\r\n            rect = self.scene().visibleItemsBoundingRect()\r\n            if not rect.width():\r\n                rect = self.scene().sceneRect()\r\n            \r\n            self.centerOn(rect.center())\r\n        else:\r\n            self.centerOn(self.scene().calculateBoundingRect(items).center())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef closeEvent( self, event ):\n        if ( self.cleanupOnClose() ):\n            scene = self.scene()\n            scene.cleanup()\n            self.setScene(None)\n        \n        super(XNodeWidget, self).closeEvent(event)", "response": "Cleans up the scene before closing."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first visible viewport rect for the current view.", "response": "def viewportRect(self):\r\n        \"\"\"\r\n        Returns the QRectF that represents the visible viewport rect for the\r\n        current view.\r\n        \r\n        :return     <QRectF>\r\n        \"\"\"\r\n        w = self.width()\r\n        h = self.height()\r\n        \r\n        vbar = self.verticalScrollBar()\r\n        hbar = self.horizontalScrollBar()\r\n        \r\n        if vbar.isVisible():\r\n            w -= vbar.width()\r\n        if hbar.isVisible():\r\n            h -= hbar.height()\r\n        \r\n        top_l = self.mapToScene(QPoint(0, 0))\r\n        bot_r = self.mapToScene(QPoint(w, h))\r\n        \r\n        return QRectF(top_l.x(), \r\n                      top_l.y(), \r\n                      bot_r.x() - top_l.x(), \r\n                      bot_r.y() - top_l.y())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfits all the nodes in the view.", "response": "def zoomExtents(self):\r\n        \"\"\"\r\n        Fits all the nodes in the view.\r\n        \"\"\"\r\n        rect = self.scene().visibleItemsBoundingRect()\r\n        vrect = self.viewportRect()\r\n        \r\n        if rect.width():\r\n            changed = False\r\n            scene_rect = self.scene().sceneRect()\r\n            \r\n            if scene_rect.width() < rect.width():\r\n                scene_rect.setWidth(rect.width() + 150)\r\n                scene_rect.setX(-scene_rect.width() / 2.0)\r\n                changed = True\r\n            \r\n            if scene_rect.height() < rect.height():\r\n                scene_rect.setHeight(rect.height() + 150)\r\n                scene_rect.setY(-scene_rect.height() / 2.0)\r\n                changed = True\r\n            \r\n            if changed:\r\n                self.scene().setSceneRect(scene_rect)\r\n            \r\n            self.fitInView(rect, Qt.KeepAspectRatio)\r\n        \r\n        if not self.signalsBlocked():\r\n            self.zoomAmountChanged.emit(self.zoomAmount())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_number(self, number, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_number_with_http_info(number, **kwargs)  # noqa: E501\n        else:\n            (data) = self.get_number_with_http_info(number, **kwargs)  # noqa: E501\n            return data", "response": "Get a single number from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists all your numbers", "response": "def list_numbers(self, **kwargs):  # noqa: E501\n        \"\"\"Get your numbers  # noqa: E501\n\n        List all your purchased numbers  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.list_numbers(async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :return: ResponseNumberList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.list_numbers_with_http_info(**kwargs)  # noqa: E501\n        else:\n            (data) = self.list_numbers_with_http_info(**kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef revoke_number(self, number, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.revoke_number_with_http_info(number, **kwargs)  # noqa: E501\n        else:\n            (data) = self.revoke_number_with_http_info(number, **kwargs)  # noqa: E501\n            return data", "response": "Revoke a specific number from your corporate member."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_number(self, number, payload_number_modification, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.update_number_with_http_info(number, payload_number_modification, **kwargs)  # noqa: E501\n        else:\n            (data) = self.update_number_with_http_info(number, payload_number_modification, **kwargs)  # noqa: E501\n            return data", "response": "Assign a number to a specific account."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nzips up a directory.", "response": "def zipdir(path, ziph, **kwargs):\n    \"\"\"\n    Zip up a directory.\n\n    :param path:\n    :param ziph:\n    :param kwargs:\n    :return:\n    \"\"\"\n    str_arcroot = \"\"\n    for k, v in kwargs.items():\n        if k == 'arcroot':  str_arcroot = v\n\n    for root, dirs, files in os.walk(path):\n        for file in files:\n            str_arcfile = os.path.join(root, file)\n            if len(str_arcroot):\n                str_arcname = str_arcroot.split('/')[-1] + str_arcfile.split(str_arcroot)[1]\n            else:\n                str_arcname = str_arcfile\n            try:\n                ziph.write(str_arcfile, arcname = str_arcname)\n            except:\n                print(\"Skipping %s\" % str_arcfile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zip_process(**kwargs):\n\n    str_localPath   = \"\"\n    str_zipFileName = \"\"\n    str_action      = \"zip\"\n    str_arcroot     = \"\"\n    for k,v in kwargs.items():\n        if k == 'path':             str_localPath   = v\n        if k == 'action':           str_action      = v\n        if k == 'payloadFile':      str_zipFileName = v\n        if k == 'arcroot':          str_arcroot     = v\n\n    if str_action       == 'zip':\n        str_mode        = 'w'\n        str_zipFileName = '%s.zip' % uuid.uuid4()\n    else:\n        str_mode        = 'r'\n\n    try:\n        ziphandler          = zipfile.ZipFile(str_zipFileName, str_mode, zipfile.ZIP_DEFLATED)\n        if str_mode == 'w':\n            if os.path.isdir(str_localPath):\n                zipdir(str_localPath, ziphandler, arcroot = str_arcroot)\n            else:\n                if len(str_arcroot):\n                    str_arcname = str_arcroot.split('/')[-1] + str_localPath.split(str_arcroot)[1]\n                else:\n                    str_arcname = str_localPath\n                try:\n                    ziphandler.write(str_localPath, arcname = str_arcname)\n                except:\n                    ziphandler.close()\n                    os.remove(str_zipFileName)\n                    return {\n                        'msg':      json.dumps({\"msg\": \"No file or directory found for '%s'\" % str_localPath}),\n                        'status':   False\n                    }\n        if str_mode     == 'r':\n            ziphandler.extractall(str_localPath)\n        ziphandler.close()\n        str_msg             = '%s operation successful' % str_action\n        b_status            = True\n    except:\n        str_msg             = '%s operation failed'     % str_action\n        b_status            = False\n    return {\n        'msg':              str_msg,\n        'fileProcessed':    str_zipFileName,\n        'status':           b_status,\n        'path':             str_localPath,\n        'zipmode':          str_mode,\n        'filesize':         \"{:,}\".format(os.stat(str_zipFileName).st_size),\n        'timestamp':        '%s' % datetime.datetime.now()\n    }", "response": "Process zip operations.\n\n    :param kwargs:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef base64_process(**kwargs):\n\n    str_fileToSave      = \"\"\n    str_fileToRead      = \"\"\n    str_action          = \"encode\"\n    data                = None\n\n    for k,v in kwargs.items():\n        if k == 'action':           str_action          = v\n        if k == 'payloadBytes':     data                = v\n        if k == 'payloadFile':      str_fileToRead      = v\n        if k == 'saveToFile':       str_fileToSave      = v\n        # if k == 'sourcePath':       str_sourcePath      = v\n\n    if str_action       == \"encode\":\n        # Encode the contents of the file at targetPath as ASCII for transmission\n        if len(str_fileToRead):\n            with open(str_fileToRead, 'rb') as f:\n                data            = f.read()\n                f.close()\n        data_b64            = base64.b64encode(data)\n        with open(str_fileToSave, 'wb') as f:\n            f.write(data_b64)\n            f.close()\n        return {\n            'msg':              'Encode successful',\n            'fileProcessed':    str_fileToSave,\n            'status':           True\n            # 'encodedBytes':     data_b64\n        }\n\n    if str_action       == \"decode\":\n       # if len(data) % 4:\n            # not a multiple of 4, add padding:\n            # data += '=' * (4 - len(data) % 4)\n\n        # adding 3 padding = will never succumb to the TypeError and will always produce the same result.\n        # https://gist.github.com/perrygeo/ee7c65bb1541ff6ac770\n        bytes_decoded     = base64.b64decode(data + \"===\")\n        with open(str_fileToSave, 'wb') as f:\n            f.write(bytes_decoded)\n            f.close()\n        return {\n            'msg':              'Decode successful',\n            'fileProcessed':    str_fileToSave,\n            'status':           True\n            # 'decodedBytes':     bytes_decoded\n        }", "response": "Process base64 file io\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef storage_resolveBasedOnKey(self, *args, **kwargs):\n        global Gd_internalvar\n\n        d_msg       = {\n            'action':   'internalctl',\n            'meta': {\n                'var':      'key2address',\n                'compute':  '<key>'\n            }\n        }\n\n        str_key     = \"\"\n        b_status    = False\n\n        for k,v in kwargs.items():\n            if k == 'key':  str_key = v\n        d_msg['meta']['key']    = str_key\n\n        # \n        d_ret = self.pullPath_core(d_msg = d_msg)\n\n        return {\n            'status':   b_status,\n            'path':     str_internalLocation\n        }", "response": "Call the remote service and ask for the storage location based on the key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remoteLocation_resolveSimple(self, d_remote):\n        b_status        = False\n        str_remotePath  = \"\"\n        if 'path' in d_remote.keys():\n            str_remotePath  = d_remote['path']\n            b_status        = True\n        if 'key' in d_remote.keys():\n            str_remotePath  = d_remote['key']\n            b_status        = True\n        return {\n            'status':   b_status,\n            'path':     str_remotePath\n        }", "response": "Resolve the remote path location by returning either the\n            status or the\n            path parameter in the remote JSON record."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remoteLocation_resolve(self, d_remote):\n        b_status        = False\n        str_remotePath  = \"\"\n        if 'path' in d_remote.keys():\n            str_remotePath  = d_remote['path']\n            b_status        = True\n        if 'key' in d_remote.keys():\n            d_ret =  self.storage_resolveBasedOnKey(key = d_remote['key'])\n            if d_ret['status']:\n                b_status        = True\n                str_remotePath  = d_ret['path']\n        return {\n            'status':   b_status,\n            'path':     str_remotePath\n        }", "response": "Resolve the remote path location"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint some man for each understood command in the log file.", "response": "def man(self, **kwargs):\n        \"\"\"\n        Print some man for each understood command\n        \"\"\"\n\n        str_man     = 'commands'\n        str_amount  = 'full'\n\n        for k, v in kwargs.items():\n            if k == 'on':       str_man     = v\n            if k == 'amount':   str_amount  = v\n\n        if str_man == 'commands':\n            str_commands = \"\"\"\n            This script/module provides CURL-based GET/PUT/POST communication over http\n            to a remote REST-like service: \"\"\" + Colors.GREEN + \"\"\"\n\n                 ./pfurl.py [--auth <username:passwd>] [--verb <GET/POST>]   \\\\\n                            --http <IP>[:<port>]</some/path/>\n\n            \"\"\" + Colors.WHITE + \"\"\"\n            Where --auth is an optional authorization to pass to the REST API,\n            --verb denotes the REST verb to use and --http specifies the REST URL.\n\n            Additionally, a 'message' described in JSON syntax can be pushed to the\n            remote service, in the following syntax: \"\"\" + Colors.GREEN + \"\"\"\n\n                 pfurl     [--auth <username:passwd>] [--verb <GET/POST>]   \\\\\n                            --http <IP>[:<port>]</some/path/>               \\\\\n                           [--msg <JSON-formatted-string>]\n\n            \"\"\" + Colors.WHITE + \"\"\"\n            In the case of the 'pman' system this --msg flag has very specific\n            contextual syntax, for example:\n            \"\"\" + Colors.GREEN + \"\"\"\n\n                 pfurl      --verb POST --http %s:%s/api/v1/cmd/ --msg \\\\\n                                '{  \"action\": \"run\",\n                                    \"meta\": {\n                                        \"cmd\":      \"cal 7 1970\",\n                                        \"auid\":     \"rudolphpienaar\",\n                                        \"jid\":      \"<jid>-1\",\n                                        \"threaded\": true\n                                    }\n                                }'\n\n\n            \"\"\" % (self.str_ip, self.str_port) + Colors.CYAN + \"\"\"\n\n            The following specific action directives are directly handled by script:\n            \"\"\" + \"\\n\" + \\\n            self.man_pushPath(          description =   \"short\")      + \"\\n\" + \\\n            self.man_pullPath(          description =   \"short\")      + \"\\n\" + \\\n            Colors.YELLOW + \\\n            \"\"\"\n            To get detailed help on any of the above commands, type\n            \"\"\" + Colors.LIGHT_CYAN + \\\n            \"\"\"\n                ./pfurl.py --man <command>\n            \"\"\"\n\n            return str_commands\n\n        if str_man  == 'pushPath':  return self.man_pushPath(       description  =   str_amount)\n        if str_man  == 'pullPath':  return self.man_pullPath(       description  =   str_amount)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pull_core(self, **kwargs):\n\n        str_ip              = self.str_ip\n        str_port            = self.str_port\n        verbose             = 0\n        d_msg               = {}\n\n        for k,v in kwargs.items():\n            if k == 'ip':       str_ip      = v\n            if k == 'port':     str_port    = v\n            if k == 'msg':      d_msg       = v\n            if k == 'verbose':  verbose     = v\n\n        response            = io.BytesIO()\n\n        str_query   = ''\n        if len(d_msg):\n            d_meta              = d_msg['meta']\n            str_query           = '?%s' % urllib.parse.urlencode(d_msg)\n        \n        str_URL = \"%s://%s:%s%s%s\" % (self.str_protocol, str_ip, str_port, self.str_URL, str_query)\n        self.dp.qprint(str_URL,\n                    comms  = 'tx')\n\n\n        c = pycurl.Curl()\n        c.setopt(c.URL, str_URL)\n        # pudb.set_trace()\n        if self.b_unverifiedCerts:\n            self.dp.qprint(\"Making an insecure connection with trusted host\")\n            c.setopt(pycurl.SSL_VERIFYPEER, 0)   \n            c.setopt(pycurl.SSL_VERIFYHOST, 0)\n        if verbose: c.setopt(c.VERBOSE, 1)\n        c.setopt(c.FOLLOWLOCATION,  1)\n        c.setopt(c.WRITEFUNCTION,   response.write)\n        if len(self.str_auth):\n            self.dp.qprint(\"Using user:password authentication <%s>\" % \n                            self.str_auth)\n            c.setopt(c.USERPWD, self.str_auth)\n        elif len(self.str_authToken):\n            self.dp.qprint(\"Using token-based authorization <%s>\" % \n                            self.str_authToken)\n            header = 'Authorization: bearer %s' % self.str_authToken\n            c.setopt(pycurl.HTTPHEADER, [header])\n        self.dp.qprint(\"Waiting for PULL response...\", level = 1, comms ='status')\n        c.perform()\n        c.close()\n        try:\n            str_response        = response.getvalue().decode()\n        except:\n            str_response        = response.getvalue()\n\n        self.dp.qprint('Incoming transmission received, length = %s' % \"{:,}\".format(len(str_response)),\n                    level = 1, comms ='rx')\n        return str_response", "response": "Pull the core of the pycurl logic."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npulls the path of a copy from the server into a dictionary holder.", "response": "def pullPath_copy(self, d_msg, **kwargs):\n        \"\"\"\n        Handle the \"copy\" pull operation\n        \"\"\"\n\n        # Parse \"header\" information\n        d_meta              = d_msg['meta']\n        d_local             = d_meta['local']\n        str_localPath       = d_local['path']\n        d_remote            = d_meta['remote']\n        d_transport         = d_meta['transport']\n        d_copy              = d_transport['copy']\n\n        # Pull the actual data into a dictionary holder\n        d_curl                      = {}\n        d_curl['remoteServer']      = self.pullPath_core()\n        d_curl['copy']              = {}\n        d_curl['copy']['status']    = d_curl['remoteServer']['status']\n        if not d_curl['copy']['status']:\n            d_curl['copy']['msg']   = \"Copy on remote server failed!\"\n        else:\n            d_curl['copy']['msg']   = \"Copy on remote server success!\"\n\n        return d_curl"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if a path exists on the local filesystem.", "response": "def path_localLocationCheck(self, d_msg, **kwargs):\n        \"\"\"\n        Check if a path exists on the local filesystem\n\n        :param self:\n        :param kwargs:\n        :return:\n        \"\"\"\n        b_pull                      = False\n        d_meta                      = d_msg['meta']\n        if 'do' in d_meta:\n            if d_meta['do'] == 'pull':\n                b_pull              = True\n        if 'local' in d_meta:\n            d_local                 = d_meta['local']\n        if 'to' in d_meta:\n            d_local                 = d_meta['to']\n\n        str_localPathFull           = d_local['path']\n        str_localPath, str_unpack   = os.path.split(str_localPathFull)\n        str_msg                     = ''\n        str_checkedDir              = str_localPathFull\n\n        b_isFile                    = os.path.isfile(str_localPathFull)\n        b_isDir                     = os.path.isdir(str_localPathFull)\n        b_exists                    = os.path.exists(str_localPathFull)\n\n        if 'pull' in d_msg['action'] or b_pull:\n            # If we are \"pulling\" data to local, then we assume the local\n            # directory does not exist. If it does, and if 'createDir' is 'true', \n            # we remove the localPath and re-create it, thus assuring it will \n            # only contain the info pulled from the remote source.\n            # If 'writeInExisting' is 'true', then execution continues, but\n            # may fail if the pulled target exists in the localPath.\n\n            str_checkedDir              = str_localPath\n            b_isFile                    = os.path.isfile(str_localPath)\n            b_isDir                     = os.path.isdir(str_localPath)\n            b_exists                    = os.path.exists(str_localPath)\n\n            if 'createDir' in d_local.keys():\n                if d_local['createDir']:\n                    if os.path.isdir(str_localPathFull):\n                        self.dp.qprint('Removing local path %s...' % str_localPathFull)\n                        shutil.rmtree(str_localPathFull)\n                        str_msg         = 'Removed existing local path... '\n                    self.dp.qprint('Creating empty local path %s...' % str_localPathFull)\n                    os.makedirs(str_localPathFull)\n                    b_exists = True\n                    str_msg += 'Created new local path'\n            else:\n                str_msg = 'local path already exists!'\n                if 'writeInExisting' in d_local.keys():\n                    if not d_local['writeInExisting']: \n                        if b_isDir: b_exists = False\n                else:\n                    if b_isDir: b_exists = False\n\n        d_ret = {\n            'action':   d_msg['action'],\n            'dir':      str_checkedDir,\n            'status':   b_exists,\n            'isfile':   b_isFile,\n            'isdir':    b_isDir,\n            'msg':      str_msg\n        }\n\n        return {'check':        d_ret,\n                'status':       d_ret['status'],\n                'timestamp':    '%s' % datetime.datetime.now()}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the copy pull operation", "response": "def pushPath_copy(self, d_msg, **kwargs):\n        \"\"\"\n        Handle the \"copy\" pull operation\n        \"\"\"\n\n        # Parse \"header\" information\n        d_meta              = d_msg['meta']\n        d_local             = d_meta['local']\n        str_localPath       = d_local['path']\n        d_remote            = d_meta['remote']\n        d_transport         = d_meta['transport']\n        d_copy              = d_transport['copy']\n\n        # Pull the actual data into a dictionary holder\n        d_curl                      = {\n                                        'remoteServer': self.push_core(d_msg),\n                                        'copy': {}\n                                       }\n        d_curl['copy']['status']    = d_curl['remoteServer']['status']\n        if not d_curl['copy']['status']:\n            d_curl['copy']['msg']   = \"Copy on remote server failed!\"\n        else:\n            d_curl['copy']['msg']   = \"Copy on remote server success!\"\n\n        return d_curl"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef httpResponse_bodyParse(self, **kwargs):\n\n        str_response    = ''\n        for k,v in kwargs.items():\n            if k == 'response': str_response    = v\n        try:\n            str_body        = str_response.split('\\r\\n\\r\\n')[1]\n            d_body          = yaml.load(str_body)\n            str_body        = json.dumps(d_body)\n        except:\n            str_body        = str_response\n        return str_body", "response": "Parse the HTTP response body."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the rect that defines the boundary for the current pixmap.", "response": "def currentPixmapRect(self):\r\n        \"\"\"\r\n        Returns the rect that defines the boundary for the current pixmap\r\n        based on the size of the button and the size of the pixmap.\r\n        \r\n        :return     <QtCore.QRect>\r\n        \"\"\"\r\n        pixmap = self.currentPixmap()\r\n        rect   = self.rect()\r\n        size   = pixmap.size()\r\n        \r\n        x = rect.center().x() - (size.width() / 2.0)\r\n        y = rect.center().y() - (size.height() / 2.0)\r\n        \r\n        return QtCore.QRect(x, y, size.width(), size.height())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paintEvent(self, event):\r\n        pixmap = self.currentPixmap()\r\n        rect   = self.currentPixmapRect()\r\n        \r\n        with XPainter(self) as painter:\r\n            painter.drawPixmap(rect.x(), rect.y(), pixmap)", "response": "Draws the pixmap for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setOffPixmap(self, pixmap):\r\n        pmap = QtGui.QPixmap(pixmap)\r\n        self._offPixmap = pmap.scaled(self.width(), self.height(),\r\n                                      QtCore.Qt.KeepAspectRatio,\r\n                                      QtCore.Qt.SmoothTransformation)", "response": "Sets the off pixmap that will be used for this button to the given pixmap."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the on pixmap that will be used for this button.", "response": "def setOnPixmap(self, pixmap):\r\n        \"\"\"\r\n        Sets the on pixmap that will be used for this button to the given\r\n        pixmap.  THis can be a QPixmap instance, or a string for where to load\r\n        the pixmap from.\r\n        \r\n        :param      pixmap | <QtGui.QPixmap> || <str>\r\n        \"\"\"\r\n        pmap = QtGui.QPixmap(pixmap)\r\n        self._onPixmap = pmap.scaled(self.width(), self.height(),\r\n                                     QtCore.Qt.KeepAspectRatio,\r\n                                     QtCore.Qt.SmoothTransformation)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the color for the current data set.", "response": "def color(self, key=None):\r\n        \"\"\"\r\n        Returns the color for this data set.\r\n        \r\n        :return     <QColor>\r\n        \"\"\"\r\n        if key is not None:\r\n            return self._colorMap.get(nativestring(key), self._color)\r\n        return self._color"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dragData(self, key=None, default=None):\r\n        if key is None:\r\n            return self._dragData\r\n        \r\n        return self._dragData.get(nativestring(key), default)", "response": "Returns the drag data associated with this data set."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setColor(self, color, key=None):\r\n        self._color = QColor(color)\r\n        if key is not None:\r\n            self._colorMap[nativestring(key)] = self._color", "response": "Sets the color for the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef values(self, axis=None):\r\n        if axis is None:\r\n            return self._plot\r\n        else:\r\n            return [value.get(axis) for value in self._plot]", "response": "Returns the values for this dataset along the specified axis."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_file(name, path=os.getcwd(), deep=False, partial=False):\n\n    paths = path.split(os.pathsep) if type(path) is str else path\n    for p in paths:\n        ret = __find_file(name, p, deep, partial)\n        if ret:\n            return ret", "response": "Searches for a file and returns its path upon finding it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for a file in the given path and returns its path upon finding it.", "response": "def __find_file(name, path, deep=False, partial=False):\n    \"\"\"\n    Searches for a file and returns its path upon finding it.\n\n    Searches for a file with the given `name` in the list of directory\n    mentioned in `path`. It also supports `deep` search (recursive) and\n    `partial` search (searching for files having filename matching\n    partially with the query) through the respective boolean arguments.\n    This function is internally called by `find_file` for each of the\n    input directory of that.\n\n\n    Parameters\n    ----------\n    name : str\n        The name of the file to search for.\n    path : str\n        The path of the directory to be searched.\n    deep : bool, optional\n        Enables deep-searching, i.e. recursively looking for the file \n        in the sub-directories of the mentioned directory.\n    partial : bool, optional\n        Whether look for files having filename partially matching with \n        the query `name`.\n\n    Returns\n    -------\n    str\n        The path of the file. In case of multiple hits, it only returns \n        the first one.\n    \"\"\"\n\n    if deep:\n        for root, dirs, files in os.walk(path):\n            if partial:\n                for file in files:\n                    if name in file:\n                        return os.path.join(root, file)\n            else:\n                if name in files:\n                    return os.path.join(root, name)\n    else:\n        f = os.path.join(path, name)\n        if os.path.isfile(f):\n            return f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_executable(name):\n\n    if sys.platform.startswith('win') or os.name.startswith('os2'):\n        name = name + '.exe'\n\n    executable_path = find_file(name, deep=True)\n    return executable_path", "response": "Returns the full path of an executable file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_email(to=None, message=None, template='base',\n               context={}, subject=None):\n    \"\"\"\n    Generic Method to Send Emails from template in an easier and modular way\n    :param to: Email Address to send the email message\n    :param message: Message content that is added to context\n    :param template: Path of the email template (Without extension)\n    :param context: Dict context variables to send to the template\n    :param subject: Email subject\n    \"\"\"\n    from_email = settings.DEFAULT_FROM_EMAIL\n    if to is None:\n        if len(settings.ADMINS) > 0:\n            to = settings.ADMINS[0][1]\n        else:\n            raise AttributeError(\"Not Admins defined\")\n\n    if isinstance(to, (tuple, str)) or isinstance(to, (list, str)):\n        pass\n    elif unicode:\n        if not isinstance(to, unicode):\n            raise TypeError(\n                \"email_to parameter has to be a List, Tuple or a String\")\n    else:\n            raise TypeError(\n                \"email_to parameter has to be a List, Tuple or a String\")\n\n    email_to = to if isinstance(to, tuple) else (to,)\n\n    context.update(get_default_context())\n\n    if message is not None:\n        context.update({'message': message})\n\n    try:\n        email_template = get_email_template(template)\n    except EmailTemplateNotFound:\n        email_template = get_email_template('email/base')\n\n    email_subject = subject or \"System Notification\"\n\n    if email_template.get('txt'):\n        template_txt = email_template.get('txt')\n        msg = EmailMultiAlternatives(\n            email_subject,\n            template_txt.render(context), from_email, email_to)\n        if email_template.get('html'):\n            template_html = email_template.get('html')\n            html_content = template_html.render(context)\n            msg.attach_alternative(html_content, 'text/html')\n        return msg.send()\n    else:\n        raise AttributeError(\".txt template does not exist\")\n\n    raise Exception(\"Could Not Send Email\")", "response": "Send an email from a template"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread a corpus from a file or a directory.", "response": "def readCorpus(location):\n    \"\"\"\n    Returns the contents of a file or a group of files as a string.\n\n    :param location: .txt file or a directory to read files from.\n    :type location: str.\n\n    :returns: A string of all contents joined together.\n    :rtype: str.\n\n    .. note::\n\n        This function takes a ``location`` on disk as a parameter. Location is\n        assumed to be a string representing a text file or a directory. A text\n        file is further assumed to contain ``.txt`` as a file extension while\n        a directory may be a path.\n\n    Example:\n\n    .. code-block:: python\n\n                    from rnlp.corpus import readCorpus\n\n                    # If you have a text file:\n                    doi = readCorpus('files/doi.txt')\n\n                    # If you have multiple files to read from:\n                    corpus = readCorpus('files')\n    \"\"\"\n    print(\"Reading corpus from file(s)...\")\n\n    corpus = ''\n\n    if '.txt' in location:\n        with open(location) as fp:\n            corpus = fp.read()\n    else:\n\n        dirFiles = listdir(location)\n        nFiles = len(dirFiles)\n\n        for f in tqdm(dirFiles):\n            with open(location+\"/\"+f) as fp:\n                corpus += fp.read()\n\n    return corpus"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(data):\n    text = data.get('text')\n    if not isinstance(text, _string_types) or len(text) == 0:\n        raise ValueError('text field is required and should not be empty')\n\n    if 'markdown' in data and not type(data['markdown']) is bool:\n        raise ValueError('markdown field should be bool')\n\n    if 'attachments' in data:\n        if not isinstance(data['attachments'], (list, tuple)):\n            raise ValueError('attachments field should be list or tuple')\n\n        for attachment in data['attachments']:\n            if 'text' not in attachment and 'title' not in attachment:\n                raise ValueError('text or title is required in attachment')\n\n    return True", "response": "Validates incoming data for the\n    field"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(url, data):\n    validate(data)\n\n    return requests.post(url, json=data)", "response": "Sends an incoming message to the specified url"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addDataset(self, dataset):\r\n        item = XChartDatasetItem()\r\n        self.addItem(item)\r\n        item.setDataset(dataset)\r\n        return item", "response": "Adds a dataset instance to this scene."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the items in this scene mapped with their dataset instance.", "response": "def datasetItems(self):\r\n        \"\"\"\r\n        Returns the items in this scene mapped with their dataset instance.\r\n        \r\n        :return     {<XChartDataset>: <QGraphicsItem>, ..}\r\n        \"\"\"\r\n        out = {}\r\n        for item in self.items():\r\n            if isinstance(item, XChartDatasetItem):\r\n                out[item.dataset()] = item\r\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw the background for the current chart.", "response": "def drawBackground(self, painter, rect):\r\n        \"\"\"\r\n        Draws the background for the chart scene.\r\n        \r\n        :param      painter | <QPainter>\r\n                    rect    | <QRect>\r\n        \"\"\"\r\n        chart = self.chart()\r\n        chart._drawBackground(self, painter, rect)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef drawForeground(self, painter, rect):\r\n        chart = self.chart()\r\n        chart._drawForeground(self, painter, rect)", "response": "Draws the foreground for the chart scene."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef switch_or_run(cmd, venv_name=None):\n    if cmd:\n        return _run(venv_name, cmd)\n    inenv = InenvManager()\n    if not os.getenv(INENV_ENV_VAR):\n        activator_warn(inenv)\n        return\n    else:\n        venv = inenv.get_prepped_venv(venv_name)\n        inenv.clear_extra_source_file()\n        inenv.write_extra_source_file(\"source {}\".format(venv.activate_shell_file))\n        inenv.write_extra_source_file(override_envars_and_deactivate(inenv.get_envvars(venv_name)))\n        if autojump_enabled():\n            directory = inenv.guess_contents_dir(venv_name)\n            inenv.write_extra_source_file('cd {}'.format(directory))\n            click.secho(\"Jumping to {}\".format(directory), fg='green')\n        sys.exit(EVAL_EXIT_CODE)", "response": "Switch or run in this env"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the venv by name", "response": "def rm(venv_name):\n    \"\"\" Removes the venv by name \"\"\"\n    inenv = InenvManager()\n    venv = inenv.get_venv(venv_name)\n    click.confirm(\"Delete dir {}\".format(venv.path))\n    shutil.rmtree(venv.path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint the root directory of a virtualenv", "response": "def root(venv_name):\n    \"\"\"Print the root directory of a virtualenv\"\"\"\n    inenv = InenvManager()\n    inenv.get_venv(venv_name)\n    venv = inenv.registered_venvs[venv_name]\n    click.secho(venv['root'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_commands(self, ctx, formatter):\n        core_commands, inenv_commands = [], []\n        for subcommand in self.list_commands(ctx):\n            cmd = self.get_command(ctx, subcommand)\n            # What is this, the tool lied about a command.  Ignore it\n            if cmd is None:\n                continue\n\n            help_ = cmd.short_help or ''\n            if subcommand in self.sort_later:\n                inenv_commands.append((subcommand, help_))\n            else:\n                core_commands.append((subcommand, help_))\n\n        if core_commands:\n            with formatter.section('Commands'):\n                formatter.write_dl(core_commands)\n\n        if inenv_commands:\n            with formatter.section('Inenvs'):\n                formatter.write_dl(inenv_commands)", "response": "Extra format methods for multi - command commands."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calcTotal( self, values ):\r\n        rtype = self.rulerType()\r\n        \r\n        if ( not values ):\r\n            return 0\r\n        \r\n        if ( rtype == XChartRuler.Type.Number ):\r\n            return sum(values)\r\n        \r\n        elif ( rtype == XChartRuler.Type.Date ):\r\n            values.sort()\r\n            days = values[0].daysTo(values[-1])\r\n            return max(1, days)\r\n        \r\n        elif ( rtype in (XChartRuler.Type.Datetime, XChartRuler.Type.Time) ):\r\n            values.sort()\r\n            secs = values[0].secsTo(values[-1])\r\n            return max(1, secs)\r\n        \r\n        return -1", "response": "Calculates the total value for the given list of values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclear all the cached information about this ruler.", "response": "def clear( self ):\n        \"\"\"\n        Clears all the cached information about this ruler.\n        \"\"\"\n        self._minimum   = None\n        self._maximum   = None\n        self._step      = None\n        self._notches   = None\n        self._format    = None\r\n        self._formatter = None\r\n        self._padEnd    = 0\r\n        self._padStart  = 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompares two values based on the notches and values for this ruler.", "response": "def compareValues( self, a, b ):\r\n        \"\"\"\r\n        Compares two values based on the notches and values for this ruler.\r\n        \r\n        :param      a | <variant>\r\n                    b | <variant>\r\n        \r\n        :return     <int> 1 || 0 || -1\r\n        \"\"\"\r\n        if ( self.rulerType() in (XChartRuler.Type.Custom, \r\n                                  XChartRuler.Type.Monthly) ):\r\n            \r\n            try:\r\n                aidx = self._notches.index(a)\r\n            except ValueError:\r\n                return -1\r\n            \r\n            try:\r\n                bidx = self._notches.index(b)\r\n            except ValueError:\r\n                return 1\r\n            \r\n            return cmp(aidx, bidx)\r\n        \r\n        return cmp(a, b)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the format that will be used for this ruler.", "response": "def format( self ):\n        \"\"\"\n        Returns the format that will be used for this ruler.\n        \n        :return     <str>\n        \"\"\"\n        if ( self._format is not None ):\n            return self._format\n        \n        rtype = self.rulerType()\n        if ( rtype == XChartRuler.Type.Number ):\n            self._format = '%i'\n        \n        elif ( rtype == XChartRuler.Type.Date ):\n            self._format = 'M.d.yy'\n        \n        elif ( rtype == XChartRuler.Type.Datetime ):\n            self._format = 'M.d.yy @ h:mm ap'\n        \n        elif ( rtype == XChartRuler.Type.Time ):\n            self._format = 'h:mm ap'\n        \n        return self._format"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nformatting the inputed value based on the formatting system for this ruler.", "response": "def formatValue( self, value ):\r\n        \"\"\"\r\n        Formats the inputed value based on the formatting system for this ruler.\r\n        \r\n        :param      value | <variant>\r\n        \"\"\"\r\n        formatter = self.formatter()\r\n        if ( formatter is not None ):\r\n            return formatter(value)\r\n        \r\n        elif ( self.format() ):\r\n            rtype = self.rulerType()\r\n            if ( rtype in (XChartRuler.Type.Date, XChartRuler.Type.Datetime,\r\n                           XChartRuler.Type.Time) ):\r\n                return value.toString(self.format())\r\n            else:\r\n                try:\r\n                    return self.format() % value\r\n                except TypeError:\r\n                    return nativestring(value)\r\n        \r\n        return nativestring(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef maxNotchSize( self, orientation ):\r\n        metrics = QFontMetrics(QApplication.font())\r\n        \r\n        if orientation == Qt.Vertical:\r\n            notch = ''\r\n            for n in self.notches():\r\n                if len(nativestring(n)) > len(nativestring(notch)):\r\n                    notch = nativestring(n)\r\n            \r\n            return metrics.width(notch)\r\n        else:\r\n            return metrics.height()", "response": "Returns the maximum size for this ruler based on its notches and the given orientation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the minimum length for this ruler based on its notches and the orientation.", "response": "def minLength( self, orientation ):\r\n        \"\"\"\r\n        Returns the minimum length for this ruler based on its notches and the\r\n        given orientation.\r\n        \r\n        :param      orientation | <Qt.Orientation>\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        padding         = self.padStart() + self.padEnd()\r\n        count           = len(self.notches())\r\n        notch_padding   = self.notchPadding()\r\n        \r\n        if ( orientation == Qt.Horizontal ):\r\n            section     = self.maxNotchSize(Qt.Vertical)\r\n        else:\r\n            section     = self.maxNotchSize(Qt.Horizontal)\r\n        \r\n        return notch_padding * count + section * count + padding"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maximum( self ):\n        if ( self._maximum is not None ):\n            return self._maximum\n        \n        rtype = self.rulerType()\n        \n        if ( rtype == XChartRuler.Type.Number ):\n            self._maximum = 100\n            \n        elif ( rtype == XChartRuler.Type.Date ):\n            self._maximum = QDate.currentDate().addDays(10)\n        \n        elif ( rtype == XChartRuler.Type.Datetime ):\n            self._maximum = QDateTime.currentDateTime().addDays(10)\n        \n        elif ( rtype == XChartRuler.Type.Time ):\n            self._maximum = QDateTime.currentDateTime().time().addSecs(60 * 60)\r\n            \n        else:\r\n            notches = self.notches()\r\n            if ( notches ):\r\n                self._maximum = notches[-1]\r\n                \n        return self._maximum", "response": "Returns the maximum value for this ruler."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the minimum value for this ruler.", "response": "def minimum( self ):\n        \"\"\"\n        Returns the minimum value for this ruler.  If the cached value is None,\n        then a default value will be specified based on the ruler type.\n        \n        :return     <variant>\n        \"\"\"\n        if ( self._minimum is not None ):\n            return self._minimum\n        \n        rtype = self.rulerType()\n        \n        if ( rtype == XChartRuler.Type.Number ):\n            self._minimum = 0\n            \n        elif ( rtype == XChartRuler.Type.Date ):\n            self._minimum = QDate.currentDate()\n        \n        elif ( rtype == XChartRuler.Type.Datetime ):\n            self._minimum = QDateTime.currentDateTime()\n        \n        elif ( rtype == XChartRuler.Type.Time ):\n            self._minimum = QDateTime.currentDateTime().time()\r\n        \r\n        else:\r\n            notches = self.notches()\r\n            if ( notches ):\r\n                self._minimum = notches[0]\n        \n        return self._minimum"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef notches( self ):\n        if ( self._notches is not None ):\n            return self._notches\n        \n        rtype           = self.rulerType()\r\n        formatter       = self.formatter()\n        format          = self.format()\n        self._notches   = []\r\n        \r\n        minimum = self.minimum()\r\n        maximum = self.maximum()\r\n        step    = self.step()\r\n        \r\n        if ( step <= 0 ):\r\n            return []\n        \r\n        curr = minimum\r\n        while ( curr < maximum ):\r\n            self._notches.append(self.formatValue(curr))\r\n            \r\n            if ( rtype == XChartRuler.Type.Number ):\r\n                curr += step\r\n            elif ( rtype == XChartRuler.Type.Date ):\r\n                curr = curr.addDays(step)\r\n            elif ( rtype in (XChartRuler.Type.Datetime, XChartRuler.Type.Time)):\r\n                curr = curr.addSecs(step)\r\n            else:\r\n                break\r\n        \r\n        self._notches.append(self.formatValue(maximum))\r\n        \n        return self._notches", "response": "Returns a list of the notches that are going to be used for this ruler."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef percentAt( self, value ):\r\n        if ( value is None ):\r\n            return 0.0\r\n        \r\n        minim = self.minimum()\r\n        maxim = self.maximum()\r\n        rtype = self.rulerType()\r\n        \r\n        # simple minimum\r\n        if ( value == minim and not self.padStart() ):\r\n            perc = 0.0\r\n        \r\n        # simple maximum\r\n        elif ( value == maxim and not self.padEnd() ):\r\n            perc = 1.0\r\n        \r\n        # calculate a numeric percentage value\r\n        elif ( rtype == XChartRuler.Type.Number ):\r\n            perc  = float(value - minim) / float(maxim - minim)\r\n        \r\n        # calculate a time percentage value\r\n        elif ( rtype in (XChartRuler.Type.Datetime, XChartRuler.Type.Time) ):\r\n            maxsecs = minim.secsTo(maxim)\r\n            valsecs = minim.secsTo(value)\r\n            \r\n            perc    = float(valsecs) / maxsecs\r\n        \r\n        # calculate a date percentage value\r\n        elif ( rtype == XChartRuler.Type.Date ):\r\n            maxdays = minim.daysTo(maxim)\r\n            valdays = minim.daysTo(value)\r\n            \r\n            perc    = float(valdays) / maxdays\r\n        \r\n        # otherwise, compare against the notches\r\n        else:\r\n            perc    = 0.0\r\n            notches = self.notches()\r\n            count   = len(notches)\r\n            count  += self.padStart() + self.padEnd()\r\n            count   = max(1, count - 1)\r\n            \r\n            perc    = float(self.padStart()) / count\r\n            \r\n            for i, notch in enumerate(notches):\r\n                if ( notch == value ):\r\n                    perc += float(i) / count\r\n                    break\r\n        \r\n        # normalize the percentage\r\n        perc    = min(perc, 1.0)\r\n        perc    = max(0, perc)\r\n        \r\n        return perc", "response": "Returns the percentage between the given value and the given ruler."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setNotches( self, notches ):\n        self._rulerType = XChartRuler.Type.Custom\n        self._notches = notches", "response": "Sets the notches list for this ruler."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the ruler type for this ruler.", "response": "def setRulerType( self, rulerType ):\n        \"\"\"\n        Sets the ruler type for this ruler to the inputed type.\n        \n        :param      rulerType | <XChartRuler.Type>\n        \"\"\"\n        self._rulerType = rulerType\n        self.clear()\r\n        \r\n        # handle custom types\r\n        if ( rulerType == XChartRuler.Type.Monthly ):\r\n            self.setNotches(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\r\n                             'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the step value for this ruler.", "response": "def step( self ):\n        \"\"\"\n        Returns the step value for this ruler.  If the cached value is None,\n        then a default value will be specified based on the ruler type.\n        \n        :return     <variant>\n        \"\"\"\n        if ( self._step is not None ):\n            return self._step\n        \r\n        elif ( self.rulerType() == XChartRuler.Type.Number ):\r\n            self._step = int((self.maximum() - self.minimum()) / 10.0)\r\n        \r\n        elif ( self.rulerType() == XChartRuler.Type.Date ):\r\n            \r\n            self._step = int(self.minimum().daysTo(self.maximum()) / 10.0) - 1\r\n        \n        elif ( self.rulerType() & (XChartRuler.Type.Time | \\\r\n                                   XChartRuler.Type.Datetime) ):\n            self._step = int(self.minimum().secsTo(self.maximum()) / 10.0) - 1\n        \n        return self._step"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value at the inputed percent.", "response": "def valueAt( self, percent ):\r\n        \"\"\"\r\n        Returns the value at the inputed percent.\r\n        \r\n        :param     percent | <float>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        minim = self.minimum()\r\n        maxim = self.maximum()\r\n        rtype = self.rulerType()\r\n        \r\n        # simple minimum\r\n        if ( percent <= 0 ):\r\n            return minim\r\n        \r\n        # simple maximum\r\n        elif ( 1 <= percent ):\r\n            return maxim\r\n        \r\n        # calculate a numeric percentage value\r\n        elif ( rtype == XChartRuler.Type.Number ):\r\n            return (maxim - minim) * percent\r\n        \r\n        # calculate a time percentage value\r\n        elif ( rtype in (XChartRuler.Type.Datetime, XChartRuler.Type.Time) ):\r\n            maxsecs = minim.secsTo(maxim)\r\n            \r\n            diff = maxssecs * percent\r\n            return minim.addSecs(diff)\r\n            \r\n        # calculate a date percentage value\r\n        elif ( rtype == XChartRuler.Type.Date ):\r\n            maxdays = minim.daysTo(maxim)\r\n            \r\n            diff = maxdays * percent\r\n            return minim.addDays(diff)\r\n            \r\n        # otherwise, compare against the notches\r\n        else:\r\n            perc    = 0.0\r\n            notches = self.notches()\r\n            count   = len(notches)\r\n            count  += self.padStart() + self.padEnd()\r\n            count   = max(1, count - 1)\r\n            \r\n            perc    = float(self.padStart()) / count\r\n            last    = None\r\n            \r\n            for i, notch in enumerate(notches):\r\n                perc += float(i) / count\r\n                if ( perc <= percent ):\r\n                    break\r\n                \r\n                last = notch\r\n            \r\n            return last"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query(self):\r\n        output = Query()\r\n        for column, op, plugin, editor in self._plugins:\r\n            query = Query(column)\r\n            if plugin.setupQuery(query, op, editor):\r\n                output &= query\r\n        return output", "response": "Builds the query for this quick filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef keyPressEvent(self, event):\r\n        if event.key() in (Qt.Key_Enter, Qt.Key_Return):\r\n            self.queryEntered.emit(self.query())\r\n        \r\n        super(XOrbQuickFilterWidget, self).keyPressEvent(event)", "response": "Emits the queryEntered signal if the user has entered the query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrebuilding the data associated with this filter widget.", "response": "def rebuild(self):\r\n        \"\"\"\r\n        Rebuilds the data associated with this filter widget.\r\n        \"\"\"\r\n        table = self.tableType()\r\n        form  = nativestring(self.filterFormat())\r\n        \r\n        if not table and form:\r\n            if self.layout().count() == 0:\r\n                self.layout().addWidget(QLabel(form, self))\r\n            else:\r\n                self.layout().itemAt(0).widget().setText(form)\r\n            return\r\n        \r\n        elif not form:\r\n            return\r\n        \r\n        for child in self.findChildren(QWidget):\r\n            child.close()\r\n            child.setParent(None)\r\n            child.deleteLater()\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        schema = table.schema()\r\n        \r\n        vlayout = self.layout()\r\n        for i in range(vlayout.count()):\r\n            vlayout.takeAt(0)\r\n        \r\n        self._plugins = []\r\n        for line in form.split('\\n'):\r\n            row = QHBoxLayout()\r\n            row.setContentsMargins(0, 0, 0, 0)\r\n            row.setSpacing(0)\r\n            \r\n            for label, lookup in FORMAT_SPLITTER.findall(line):\r\n                # create the label\r\n                lbl = QLabel(label, self)\r\n                row.addWidget(lbl)\r\n                \r\n                # create the query plugin\r\n                opts = lookup.split(':')\r\n                if len(opts) == 1:\r\n                    opts.append('is')\r\n                \r\n                column = schema.column(opts[0])\r\n                if not column:\r\n                    continue\r\n                \r\n                plugin = self.pluginFactory().plugin(column)\r\n                if not plugin:\r\n                    continue\r\n                \r\n                editor = plugin.createEditor(self, column, opts[1], None)\r\n                if editor:\r\n                    editor.setObjectName(opts[0])\r\n                    row.addWidget(editor)\r\n                    self._plugins.append((opts[0], opts[1], plugin, editor))\r\n            \r\n            row.addStretch(1)\r\n            vlayout.addLayout(row)\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.adjustSize()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef showMenu(self, point):\r\n        menu = QMenu(self)\r\n        acts = {}\r\n        acts['edit'] = menu.addAction('Edit quick filter...')\r\n        \r\n        trigger = menu.exec_(self.mapToGlobal(point))\r\n        \r\n        if trigger == acts['edit']:\r\n            text, accepted = XTextEdit.getText(self.window(),\r\n                                                  'Edit Format',\r\n                                                  'Format:',\r\n                                                  self.filterFormat(),\r\n                                                  wrapped=False)\r\n            \r\n            if accepted:\r\n                self.setFilterFormat(text)", "response": "Displays the menu for this filter widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the query information for this filter widget.", "response": "def setQuery(self, query):\r\n        \"\"\"\r\n        Sets the query information for this filter widget.\r\n        \r\n        :param      query | <orb.Query> || None\r\n        \"\"\"\r\n        if query is None:\r\n            return\r\n        \r\n        count = {}\r\n        \r\n        for widget in self.findChildren(QWidget):\r\n            column = nativestring(widget.objectName())\r\n            count.setdefault(column, 0)\r\n            count[column] += 1\r\n            \r\n            success, value, _ = query.findValue(column, count[column])\r\n            if success:\r\n                projexui.setWidgetValue(widget, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the given file descriptor to non - blocking mode.", "response": "def set_nonblock(fd):\n    # type: (int) -> None\n    \"\"\"Set the given file descriptor to non-blocking mode.\"\"\"\n    fcntl.fcntl(fd,\n                fcntl.F_SETFL,\n                fcntl.fcntl(fd, fcntl.F_GETFL) | os.O_NONBLOCK)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread data from the stream.", "response": "def read(self):\n        # type: () -> str\n        \"\"\"Read data from the stream.\"\"\"\n        s = self._buf + self._raw.read()\n        self._buf = ''\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_open(self, ws):\n        def keep_alive(interval):\n            while True:\n                time.sleep(interval)\n                self.ping()\n\n        start_new_thread(keep_alive, (self.keep_alive_interval, ))", "response": "Called when the websocket connection is established."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when a message is received from the websocket.", "response": "def on_message(self, ws, message):\n        \"\"\"Websocket on_message event handler\n\n        Saves message as RTMMessage in self._inbox\n        \"\"\"\n        try:\n            data = json.loads(message)\n        except Exception:\n            self._set_error(message, \"decode message failed\")\n        else:\n            self._inbox.put(RTMMessage(data))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a RTMMessage to the loop", "response": "def send(self, message):\n        \"\"\"Sends a RTMMessage\n        Should be called after starting the loop\n\n        Args:\n            message(RTMMessage): the sending message\n\n        Raises:\n            WebSocketConnectionClosedException: if the loop is closed\n        \"\"\"\n        if \"call_id\" not in message:\n            message[\"call_id\"] = self.gen_call_id()\n\n        self._ws.send(message.to_json())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving and returns a RTMMessage from self. _inbox", "response": "def get_message(self, block=False, timeout=None):\n        \"\"\"Removes and returns a RTMMessage from self._inbox\n\n        Args:\n            block(bool): if True block until a RTMMessage is available,\n                         else it will return None when self._inbox is empty\n            timeout(int): it blocks at most timeout seconds\n\n        Returns:\n            RTMMessage if self._inbox is not empty, else None\n        \"\"\"\n        try:\n            message = self._inbox.get(block=block, timeout=timeout)\n            return message\n        except Exception:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_error(self, block=False, timeout=None):\n        try:\n            error = self._errors.get(block=block, timeout=timeout)\n            return error\n        except Exception:\n            return None", "response": "Removes and returns an error from self. _errors and returns None if there is no error"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the column types with the given factory", "response": "def init(factory):\r\n    # simple types\r\n    factory.register(BoolPlugin(),                  ColumnType.Bool)\r\n    factory.register(NumericPlugin(QLineEdit),      ColumnType.Double)\r\n    factory.register(NumericPlugin(QLineEdit),      ColumnType.Decimal)\r\n    factory.register(NumericPlugin(QLineEdit),      ColumnType.Integer)\r\n    factory.register(NumericPlugin(QLineEdit),      ColumnType.BigInt)\r\n    \r\n    # Enum\r\n    factory.register(EnumPlugin(),                  ColumnType.Enum)\r\n    \r\n    # string types\r\n    factory.register(StringPlugin(XLineEdit),       ColumnType.String)\r\n    factory.register(StringPlugin(XLineEdit),       ColumnType.Text)\r\n    factory.register(StringPlugin(XLineEdit),       ColumnType.Xml)\r\n    factory.register(StringPlugin(XLineEdit),       ColumnType.Html)\r\n    factory.register(StringPlugin(XLineEdit),       ColumnType.Color)\r\n    factory.register(PasswordPlugin(),              ColumnType.Password)\r\n    \r\n    # date/time types\r\n    dtimeplug = DateTimePlugin(XDateTimeEdit)\r\n    factory.register(DateTimePlugin(XDateEdit),     ColumnType.Date)\r\n    factory.register(dtimeplug, ColumnType.Datetime)\r\n    factory.register(dtimeplug, ColumnType.DatetimeWithTimezone)\r\n    factory.register(DateTimePlugin(XTimeEdit),     ColumnType.Time)\r\n    \r\n    # data types\r\n    'Image'        # stores images in the database as binary\r\n    'ByteArray'    # stores additional binary information\r\n    'Dict'         # stores python dictionary types\r\n    \r\n    # relation types\r\n    factory.register(ForeignKeyPlugin(), ColumnType.ForeignKey)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef createEditor(self, parent, column, operator, value):\r\n        if type(value) == datetime.timedelta:\r\n            editor = XTimeDeltaEdit(parent)\r\n            editor.setAttribute(Qt.WA_DeleteOnClose)\r\n            editor.setDelta(value)\r\n            return editor\r\n        \r\n        else:\r\n            editor = super(DateTimePlugin, self).createEditor(parent,\r\n                                                              column,\r\n                                                              operator,\r\n                                                              value)\r\n        \r\n            if isinstance(editor, XDateTimeEdit) or \\\r\n               isinstance(editor, XDateEdit):\r\n                editor.setCalendarPopup(True)\r\n            \r\n            return editor", "response": "Creates a new editor for the given parent and column and operator and value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef operator(self, operatorType, value):\r\n        if type(value) == datetime.timedelta:\r\n            if operatorType == Query.Op.After:\r\n                return 'after (delta)'\r\n            elif operatorType == Query.Op.Before:\r\n                return 'before (delta)'\r\n        \r\n        return super(DateTimePlugin, self).operator(operatorType, value)", "response": "Returns the best match for the given operator type and value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new editor for the system.", "response": "def createEditor(self, parent, column, operator, value):\r\n        \"\"\"\r\n        Creates a new editor for the system.\r\n        \"\"\"\r\n        editor = super(EnumPlugin, self).createEditor(parent,\r\n                                                      column,\r\n                                                      operator,\r\n                                                      value)\r\n        \r\n        editor.setEnum(column.enum())\r\n        if operator in ('contains', 'does not contain'):\r\n            editor.setCheckable(True)\r\n        \r\n        editor.setCurrentValue(value)\r\n        return editor"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new editor for the given parent and operator.", "response": "def createEditor(self, parent, column, operator, value):\r\n        \"\"\"\r\n        Creates a new editor for the given parent and operator.\r\n        \r\n        :param      parent      | <QWidget>\r\n                    operator    | <str>\r\n                    value       | <variant>\r\n        \"\"\"\r\n        editor = super(ForeignKeyPlugin, self).createEditor(parent,\r\n                                                            column,\r\n                                                            operator,\r\n                                                            value)\r\n        \r\n        if editor is not None:\r\n            editor.setRequired(column.required())\r\n            editor.setMinimumWidth(150)\r\n            \r\n            model = column.referenceModel()\r\n            if model:\r\n                text = model.schema().displayName().lower()\r\n                editor.setHint('any {0}'.format(text))\r\n                \r\n                editor.setRecords(model.select())\r\n                if operator in ('is in', 'is not in'):\r\n                    editor.setCheckable(True)\r\n        \r\n        return editor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setupQuery(self, query, op, editor):\r\n        if editor is not None:\r\n            value = editor.currentRecord()\r\n            if value is None:\r\n                return False\r\n        \r\n        return super(ForeignKeyPlugin, self).setupQuery(query, op, editor)", "response": "Sets up the query for this editor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new editor for the given parent and operator.", "response": "def createEditor(self, parent, column, operator, value):\r\n        \"\"\"\r\n        Creates a new editor for the given parent and operator.\r\n        \r\n        :param      parent      | <QWidget>\r\n                    operator    | <str>\r\n                    value       | <variant>\r\n        \"\"\"\r\n        editor = super(NumericPlugin, self).createEditor(parent,\r\n                                                         column,\r\n                                                         operator,\r\n                                                         value)\r\n        \r\n        if isinstance(editor, QLineEdit):\r\n            validator = QRegExpValidator(QRegExp('^-?\\d+\\.?\\d*'), editor)\r\n            editor.setValidator(validator)\r\n            if value is None:\r\n                value = 0\r\n            editor.setText(nativestring(value))\r\n        return editor"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the value for this plugin from the inputed editor.", "response": "def editorValue(self, editor):\r\n        \"\"\"\r\n        Returns the value for this plugin from the inputed editor.\r\n        \r\n        :param      editor | <QtGui.QWidget>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        if isinstance(editor, QLineEdit):\r\n            try:\r\n                return eval(nativestring(editor.text()))\r\n            except:\r\n                return 0\r\n        else:\r\n            return super(NumericPlugin, self).editorValue(editor)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncolor generator for Bokeh plots", "response": "def color_gen(colormap='viridis', key=None, n=15):\n    \"\"\"Color generator for Bokeh plots\n\n    Parameters\n    ----------\n    colormap: str, sequence\n        The name of the color map\n\n    Returns\n    -------\n    generator\n        A generator for the color palette\n    \"\"\"\n    if colormap in dir(bpal):\n        palette = getattr(bpal, colormap)\n\n        if isinstance(palette, dict):\n            if key is None:\n                key = list(palette.keys())[0]\n            palette = palette[key]\n\n        elif callable(palette):\n            palette = palette(n)\n\n        else:\n            raise TypeError(\"pallette must be a bokeh palette name or a sequence of color hex values.\")\n\n    elif isinstance(colormap, (list, tuple)):\n        palette = colormap\n\n    else:\n        raise TypeError(\"pallette must be a bokeh palette name or a sequence of color hex values.\")\n\n    yield from itertools.cycle(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filters(filter_directory=None, update=False, fmt='table', **kwargs):\n    if filter_directory is None:\n        filter_directory = resource_filename('svo_filters', 'data/filters/')\n\n    # Get the pickle path and make sure file exists\n    p_path = os.path.join(filter_directory, 'filter_list.p')\n    updated = False\n    if not os.path.isfile(p_path):\n        os.system('touch {}'.format(p_path))\n\n    if update:\n\n        print('Loading filters into table...')\n\n        # Get all the filters (except the pickle)\n        files = glob(filter_directory+'*')\n        files = [f for f in files if not f.endswith('.p')]\n        bands = [os.path.basename(b) for b in files]\n        tables = []\n\n        for band in bands:\n\n            # Load the filter\n            band = band.replace('.txt', '')\n            filt = Filter(band, **kwargs)\n            filt.Band = band\n\n            # Put metadata into table with correct dtypes\n            info = filt.info(True)\n            vals = [float(i) if i.replace('.', '').replace('-', '')\n                    .replace('+', '').isnumeric() else i\n                    for i in info['Values']]\n            dtypes = np.array([type(i) for i in vals])\n            table = at.Table(np.array([vals]), names=info['Attributes'],\n                             dtype=dtypes)\n\n            tables.append(table)\n\n            del filt, info, table\n\n        # Write to the pickle\n        with open(p_path, 'wb') as file:\n            pickle.dump(at.vstack(tables), file)\n\n    # Load the saved pickle\n    data = {}\n    if os.path.isfile(p_path):\n        with open(p_path, 'rb') as file:\n            data = pickle.load(file)\n\n    # Return the data\n    if data:\n\n        if fmt == 'dict':\n            data = {r[0]: {k: r[k].value if hasattr(r[k], 'unit') else r[k]\n                    for k in data.keys()[1:]} for r in data}\n\n        else:\n\n            # Add Band as index\n            data.add_index('Band')\n\n        return data\n\n    # Or try to generate it once\n    else:\n        if not updated:\n            updated = True\n            filters(update=True)\n        else:\n            print('No filters found in', filter_directory)", "response": "Returns a list of the available filters and generates a pickle of the table."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rebin_spec(spec, wavnew, oversamp=100, plot=False):\n    wave, flux = spec\n    nlam = len(wave)\n    x0 = np.arange(nlam, dtype=float)\n    x0int = np.arange((nlam-1.) * oversamp + 1., dtype=float)/oversamp\n    w0int = np.interp(x0int, x0, wave)\n    spec0int = np.interp(w0int, wave, flux)/oversamp\n\n    # Set up the bin edges for down-binning\n    maxdiffw1 = np.diff(wavnew).max()\n    w1bins = np.concatenate(([wavnew[0]-maxdiffw1],\n                             .5*(wavnew[1::]+wavnew[0: -1]),\n                             [wavnew[-1]+maxdiffw1]))\n\n    # Bin down the interpolated spectrum:\n    w1bins = np.sort(w1bins)\n    nbins = len(w1bins)-1\n    specnew = np.zeros(nbins)\n    inds2 = [[w0int.searchsorted(w1bins[ii], side='left'),\n              w0int.searchsorted(w1bins[ii+1], side='left')]\n             for ii in range(nbins)]\n\n    for ii in range(nbins):\n        specnew[ii] = np.sum(spec0int[inds2[ii][0]: inds2[ii][1]])\n\n    return specnew", "response": "Rebin a spectrum to a new wavelength array while preserving\n    the total flux"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies the filter to the given spectrum and returns the filtered spectrum and error arrays.", "response": "def apply(self, spectrum, plot=False):\n        \"\"\"\n        Apply the filter to the given [W, F], or [W, F, E] spectrum\n\n        Parameters\n        ----------\n        spectrum: array-like\n            The wavelength [um] and flux of the spectrum\n            to apply the filter to\n        plot: bool\n            Plot the original and filtered spectrum\n\n        Returns\n        -------\n        np.ndarray\n            The filtered spectrum and error\n\n        \"\"\"\n        # Convert to filter units if possible\n        f_units = 1.\n        if hasattr(spectrum[0], 'unit'):\n            spectrum[0] = spectrum[0].to(self.wave_units)\n        if hasattr(spectrum[1], 'unit'):\n            spectrum[1] = spectrum[1].to(self.flux_units)\n            f_units = self.flux_units\n        if len(spectrum) >= 3 and hasattr(spectrum[2], 'unit'):\n            spectrum[2] = spectrum[2].to(self.flux_units)\n\n        # Make into iterable arrays\n        wav, flx, *err = [np.asarray(i) for i in spectrum]\n\n        # Check for error array\n        if len(err) == 0:\n            err = np.ones_like(flx)*np.nan\n            unc = False\n        else:\n            err = err[0]\n            unc = True\n\n        # Make flux 2D\n        if len(flx.shape) == 1:\n            flx = np.expand_dims(flx, axis=0)\n            err = np.expand_dims(err, axis=0)\n\n        # Make throughput 3D\n        rsr = np.copy(self.rsr)\n\n        # Make empty filtered arrays\n        filtered_flx = np.zeros((rsr.shape[0], flx.shape[0], rsr.shape[2]))\n        filtered_err = np.zeros_like(filtered_flx)\n\n        # Rebin the input spectra to the filter wavelength array\n        # and apply the RSR curve to the spectrum\n        for i, bn in enumerate(rsr):\n            for j, (f, e) in enumerate(zip(flx, err)):\n                filtered_flx[i][j] = np.interp(bn[0], wav, f, left=np.nan, right=np.nan)*bn[1]\n                filtered_err[i][j] = np.interp(bn[0], wav, e, left=np.nan, right=np.nan)*bn[1]\n\n        # Propagate the filter systematic uncertainties\n        if unc:\n            filtered_err += filtered_flx*self.systematics\n\n        if plot:\n\n            # Make the figure\n            COLORS = color_gen('Category10')\n            xlab = 'Wavelength [{}]'.format(self.wave_units)\n            ylab = 'Flux Density [{}]'.format(self.flux_units)\n            fig = figure(title=self.filterID, x_axis_label=xlab, y_axis_label=ylab)\n\n            # Plot the unfiltered spectrum\n            fig.line(wav, flx[0], legend='Input spectrum', color='black')\n \n            # Plot the uncertainties\n            if unc:\n                band_x = np.append(wav, wav[::-1])\n                band_y = np.append(flx-err, (flx+err)[::-1])\n                fig.patch(band_x, band_y, color='black', fill_alpha=0.1, line_alpha=0)\n\n            # Plot each spectrum bin\n            for wav, bn, bne in zip(self.wave, filtered_flx, filtered_err):\n                color = next(COLORS)\n                fig.line(wav, bn[0], color=color)\n\n                # Plot the uncertainties\n                if unc:\n                    band_x = np.append(wav, wav[::-1])\n                    band_y = np.append(bn[0]-bne[0], (bn[0]+bne[0])[::-1])\n                    fig.patch(band_x, band_y, color=color, fill_alpha=0.1, line_alpha=0)\n\n            show(fig)\n\n        return filtered_flx.squeeze()*f_units, filtered_err.squeeze()*f_units"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbreak the filter up into bins and apply a throughput to each bin, useful for G141, G102, and other grisms Parameters ---------- n_bins: int The number of bins to dice the throughput curve into pixels_per_bin: int (optional) The number of channels per bin, which will be used to calculate n_bins wave_min: astropy.units.quantity (optional) The minimum wavelength to use wave_max: astropy.units.quantity (optional) The maximum wavelength to use", "response": "def bin(self, n_bins=1, pixels_per_bin=None, wave_min=None, wave_max=None):\n        \"\"\"\n        Break the filter up into bins and apply a throughput to each bin,\n        useful for G141, G102, and other grisms\n\n        Parameters\n        ----------\n        n_bins: int\n            The number of bins to dice the throughput curve into\n        pixels_per_bin: int (optional)\n            The number of channels per bin, which will be used\n            to calculate n_bins\n        wave_min: astropy.units.quantity (optional)\n            The minimum wavelength to use\n        wave_max: astropy.units.quantity (optional)\n            The maximum wavelength to use\n        \"\"\"\n        # Get wavelength limits\n        if wave_min is not None:\n            self.wave_min = wave_min\n        if wave_max is not None:\n            self.wave_max = wave_max\n\n        # Trim the wavelength by the given min and max\n        raw_wave = self.raw[0]\n        whr = np.logical_and(raw_wave * q.AA >= self.wave_min,\n                             raw_wave * q.AA <= self.wave_max)\n        self.wave = (raw_wave[whr] * q.AA).to(self.wave_units)\n        self.throughput = self.raw[1][whr]\n        print('Bandpass trimmed to',\n              '{} - {}'.format(self.wave_min, self.wave_max))\n\n        # Calculate the number of bins and channels\n        pts = len(self.wave)\n        if isinstance(pixels_per_bin, int):\n            self.pixels_per_bin = pixels_per_bin\n            self.n_bins = int(pts/self.pixels_per_bin)\n        elif isinstance(n_bins, int):\n            self.n_bins = n_bins\n            self.pixels_per_bin = int(pts/self.n_bins)\n        else:\n            raise ValueError(\"Please specify 'n_bins' OR 'pixels_per_bin' as integers.\")\n\n        print('{} bins of {} pixels each.'.format(self.n_bins,\n                                                  self.pixels_per_bin))\n\n        # Trim throughput edges so that there are an integer number of bins\n        new_len = self.n_bins * self.pixels_per_bin\n        start = (pts - new_len) // 2\n        self.wave = self.wave[start:new_len+start].reshape(self.n_bins, self.pixels_per_bin)\n        self.throughput = self.throughput[start:new_len+start].reshape(self.n_bins, self.pixels_per_bin)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flux_units(self, units):\n        # Check that the units are valid\n        dtypes = (q.core.PrefixUnit, q.quantity.Quantity, q.core.CompositeUnit)\n        if not isinstance(units, dtypes):\n            raise ValueError(units, \"units not understood.\")\n\n        # Check that the units changed\n        if units != self.flux_units:\n\n            # Convert to new units\n            sfd = q.spectral_density(self.wave_eff)\n            self.zp = self.zp.to(units, equivalencies=sfd)\n\n            # Store new units\n            self._flux_units = units", "response": "Sets the flux units of the zeropoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef info(self, fetch=False):\n        # Get the info from the class\n        tp = (int, bytes, bool, str, float, tuple, list, np.ndarray)\n        info = [[k, str(v)] for k, v in vars(self).items() if isinstance(v, tp)\n                and k not in ['rsr', 'raw', 'centers'] and not k.startswith('_')]\n\n        # Make the table\n        table = at.Table(np.asarray(info).reshape(len(info), 2),\n                         names=['Attributes', 'Values'])\n\n        # Sort and print\n        table.sort('Attributes')\n\n        if fetch:\n            return table\n        else:\n            table.pprint(max_width=-1, max_lines=-1, align=['>', '<'])", "response": "Print a table of info about the current filter\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_TopHat(self, wave_min, wave_max, pixels_per_bin=100):\n        # Get min, max, effective wavelengths and width\n        self.pixels_per_bin = pixels_per_bin\n        self.n_bins = 1\n        self._wave_units = q.AA\n        wave_min = wave_min.to(self.wave_units)\n        wave_max = wave_max.to(self.wave_units)\n\n        # Create the RSR curve\n        self._wave = np.linspace(wave_min, wave_max, pixels_per_bin)\n        self._throughput = np.ones_like(self.wave)\n        self.raw = np.array([self.wave.value, self.throughput])\n\n        # Calculate the effective wavelength\n        wave_eff = ((wave_min + wave_max) / 2.).value\n        width = (wave_max - wave_min).value\n\n        # Add the attributes\n        self.path = ''\n        self.refs = ''\n        self.Band = 'Top Hat'\n        self.CalibrationReference = ''\n        self.FWHM = width\n        self.Facility = '-'\n        self.FilterProfileService = '-'\n        self.MagSys = '-'\n        self.PhotCalID = ''\n        self.PhotSystem = ''\n        self.ProfileReference = ''\n        self.WavelengthMin = wave_min.value\n        self.WavelengthMax = wave_max.value\n        self.WavelengthCen = wave_eff\n        self.WavelengthEff = wave_eff\n        self.WavelengthMean = wave_eff\n        self.WavelengthPeak = wave_eff\n        self.WavelengthPhot = wave_eff\n        self.WavelengthPivot = wave_eff\n        self.WavelengthUCD = ''\n        self.WidthEff = width\n        self.ZeroPoint = 0\n        self.ZeroPointType = ''\n        self.ZeroPointUnit = 'Jy'\n        self.filterID = 'Top Hat'", "response": "Loads a top hat filter given wavelength min and max values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the filter from a txt file.", "response": "def load_txt(self, filepath):\n        \"\"\"Load the filter from a txt file\n\n        Parameters\n        ----------\n        file: str\n            The filepath\n        \"\"\"\n        self.raw = np.genfromtxt(filepath, unpack=True)\n\n        # Convert to Angstroms if microns\n        if self.raw[0][-1] < 100:\n            self.raw[0] = self.raw[0] * 10000\n\n        self.WavelengthUnit = str(q.AA)\n        self.ZeroPointUnit = str(q.erg/q.s/q.cm**2/q.AA)\n        x, f = self.raw\n\n        # Get a spectrum of Vega\n        vega_file = resource_filename('svo_filters', 'data/spectra/vega.txt')\n        vega = np.genfromtxt(vega_file, unpack=True)[: 2]\n        vega[0] = vega[0] * 10000\n        vega = rebin_spec(vega, x)*q.erg/q.s/q.cm**2/q.AA\n        flam = np.trapz((vega[1]*f).to(q.erg/q.s/q.cm**2/q.AA), x=x)\n        thru = np.trapz(f, x=x)\n        self.ZeroPoint = (flam/thru).to(q.erg/q.s/q.cm**2/q.AA).value\n\n        # Calculate the filter's properties\n        self.filterID = os.path.splitext(os.path.basename(filepath))[0]\n        self.WavelengthPeak = np.max(self.raw[0])\n        f0 = f[: np.where(np.diff(f) > 0)[0][-1]]\n        x0 = x[: np.where(np.diff(f) > 0)[0][-1]]\n        self.WavelengthMin = np.interp(max(f)/100., f0, x0)\n        f1 = f[::-1][: np.where(np.diff(f[::-1]) > 0)[0][-1]]\n        x1 = x[::-1][: np.where(np.diff(f[::-1]) > 0)[0][-1]]\n        self.WavelengthMax = np.interp(max(f)/100., f1, x1)\n        self.WavelengthEff = np.trapz(f*x*vega, x=x)/np.trapz(f*vega, x=x)\n        self.WavelengthMean = np.trapz(f*x, x=x)/np.trapz(f, x=x)\n        self.WidthEff = np.trapz(f, x=x)/f.max()\n        self.WavelengthPivot = np.sqrt(np.trapz(f, x=x)/np.trapz(f/x**2, x=x))\n        self.WavelengthPhot = np.trapz(f*vega*x**2, x=x)/np.trapz(f*vega*x, x=x)\n\n        # Half max stuff\n        halfmax = f.max()/2.\n        hm_x1 = x[f > halfmax][0]\n        hm_x2 = x[f > halfmax][-1]\n        self.FWHM = hm_x2 - hm_x1\n        self.WavelengthCen = (hm_x1 + hm_x2)/2.\n\n        # Add missing attributes\n        self.path = ''\n        self.pixels_per_bin = self.raw.shape[-1]\n        self.n_bins = 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the filter from a txt file.", "response": "def load_xml(self, filepath):\n        \"\"\"Load the filter from a txt file\n\n        Parameters\n        ----------\n        filepath: str\n            The filepath for the filter\n        \"\"\"\n        # Parse the XML file\n        vot = vo.parse_single_table(filepath)\n        self.raw = np.array([list(i) for i in vot.array]).T\n\n        # Parse the filter metadata\n        for p in [str(p).split() for p in vot.params]:\n\n            # Extract the key/value pairs\n            key = p[1].split('\"')[1]\n            val = p[-1].split('\"')[1]\n\n            # Do some formatting\n            flt1 = p[2].split('\"')[1] == 'float'\n            flt2 = p[3].split('\"')[1] == 'float'\n            if flt1 or flt2:\n                val = float(val)\n\n            else:\n                val = val.replace('b&apos;', '')\\\n                         .replace('&apos', '')\\\n                         .replace('&amp;', '&')\\\n                         .strip(';')\n\n            # Set the attribute\n            if key != 'Description':\n                setattr(self, key, val)\n\n        # Create some attributes\n        self.path = filepath\n        self.pixels_per_bin = self.raw.shape[-1]\n        self.n_bins = 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef overlap(self, spectrum):\n        swave = self.wave[np.where(self.throughput != 0)]\n        s1, s2 = swave.min(), swave.max()\n\n        owave = spectrum[0]\n        o1, o2 = owave.min(), owave.max()\n\n        if (s1 >= o1 and s2 <= o2):\n            ans = 'full'\n\n        elif (s2 < o1) or (o2 < s1):\n            ans = 'none'\n\n        else:\n            ans = 'partial'\n\n        return ans", "response": "Tests for overlap of this filter with a spectrum."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting the filter with the highest frequency.", "response": "def plot(self, fig=None, draw=True):\n        \"\"\"\n        Plot the filter\n\n        Parameters\n        ----------\n        fig: bokeh.plotting.figure (optional)\n            A figure to plot on\n        draw: bool\n            Draw the figure, else return it\n\n        Returns\n        -------\n        bokeh.plotting.figure\n            The filter figure\n        \"\"\"\n        COLORS = color_gen('Category10')\n\n        # Make the figure\n        if fig is None:\n            xlab = 'Wavelength [{}]'.format(self.wave_units)\n            ylab = 'Throughput'\n            title = self.filterID\n            fig = figure(title=title, x_axis_label=xlab, y_axis_label=ylab)\n\n        # Plot the raw curve\n        fig.line((self.raw[0]*q.AA).to(self.wave_units), self.raw[1],\n                 alpha=0.1, line_width=8, color='black')\n\n        # Plot each with bin centers\n        for x, y in self.rsr:\n            fig.line(x, y, color=next(COLORS), line_width=2)\n        fig.circle(*self.centers, size=8, color='black')\n\n        if draw:\n            show(fig)\n        else:\n            return fig"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef throughput(self, points):\n        # Test shape\n        if not points.shape == self.wave.shape:\n            raise ValueError(\"Throughput and wavelength must be same shape.\")\n\n        self._throughput = points", "response": "A setter for the throughput"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wave(self, wavelength):\n        # Test units\n        if not isinstance(wavelength, q.quantity.Quantity):\n            raise ValueError(\"Wavelength must be in length units.\")\n\n        self._wave = wavelength\n        self.wave_units = wavelength.unit", "response": "A setter for the wavelengthParameters ---------- wavelength : astropy. units. Quantity"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mousePressEvent(self, event):\r\n        if event.button() == Qt.LeftButton:\r\n            self.parent().actionTriggered.emit(self.action())\r\n            self.parent().setSelectedAction(self.action())\r\n        elif event.button() == Qt.MidButton:\r\n            self.parent().actionMiddleTriggered.emit(self.action())\r\n        elif event.button() == Qt.RightButton:\r\n            self.parent().actionMenuRequested.emit(self.action(),\r\n                                                   self.mapToParent(event.pos()))\r\n        \r\n        event.accept()", "response": "Handles the mouse press event."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setPixmapSize(self, size):\r\n        self._pixmapSize = size\r\n        self.setPixmap(self.action().icon().pixmap(size))\r\n        \r\n        max_size = self.parent().maximumPixmapSize()\r\n        \r\n        if self.position() in (XDockToolbar.Position.North,\r\n                               XDockToolbar.Position.South):\r\n            self.setFixedWidth(size.width() + self.padding())\r\n            self.setFixedHeight(max_size.height() + self.padding())\r\n        else:\r\n            self.setFixedWidth(max_size.width() + self.padding())\r\n            self.setFixedHeight(size.height() + self.padding())", "response": "Sets the pixmap size for this label."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadjusts this label to match the given position.", "response": "def setPosition(self, position):\r\n        \"\"\"\r\n        Adjusts this label to match the given position.\r\n        \r\n        :param      <XDockToolbar.Position>\r\n        \"\"\"\r\n        self._position = position\r\n        \r\n        if position == XDockToolbar.Position.North:\r\n            self.setAlignment(Qt.AlignHCenter | Qt.AlignTop)\r\n        elif position == XDockToolbar.Position.East:\r\n            self.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)\r\n        elif position == XDockToolbar.Position.South:\r\n            self.setAlignment(Qt.AlignHCenter | Qt.AlignBottom)\r\n        elif position == XDockToolbar.Position.West:\r\n            self.setAlignment(Qt.AlignRight | Qt.AlignVCenter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the action at the given position.", "response": "def actionAt(self, pos):\r\n        \"\"\"\r\n        Returns the action at the given position.\r\n        \r\n        :param      pos | <QPoint>\r\n        \r\n        :return     <QAction> || None\r\n        \"\"\"\r\n        child = self.childAt(pos)\r\n        if child:\r\n            return child.action()\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the list of action labels for this widget.", "response": "def actionLabels(self):\r\n        \"\"\"\r\n        Returns the labels for this widget.\r\n        \r\n        :return     <XDockActionLabel>\r\n        \"\"\"\r\n        l = self.layout()\r\n        return [l.itemAt(i).widget() for i in range(1, l.count() - 1)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addAction(self, action):\r\n        super(XDockToolbar, self).addAction(action)\r\n        \r\n        label = XDockActionLabel(action, self.minimumPixmapSize(), self)\r\n        label.setPosition(self.position())\r\n        \r\n        layout = self.layout()\r\n        layout.insertWidget(layout.count() - 1, label)", "response": "Adds the inputed action to this toolbar."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear(self):\r\n        # clear the actions from this widget\r\n        for act in self.actions():\r\n            act.setParent(None)\r\n            act.deleteLater()\r\n        \r\n        # clear the labels from this widget\r\n        for lbl in self.actionLabels():\r\n            lbl.close()\r\n            lbl.deleteLater()", "response": "Clears out all the actions and items from this toolbar."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter the parent objects events to rebuild this toolbar when the widget resizes.", "response": "def eventFilter(self, object, event):\r\n        \"\"\"\r\n        Filters the parent objects events to rebuild this toolbar when\r\n        the widget resizes.\r\n        \r\n        :param      object | <QObject>\r\n                    event | <QEvent>\r\n        \"\"\"\r\n        if event.type() in (event.Move, event.Resize):\r\n            if self.isVisible():\r\n                self.rebuild()\r\n            elif object.isVisible():\r\n                self.setVisible(True)\r\n        \r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef labelForAction(self, action):\r\n        for label in self.actionLabels():\r\n            if label.action() == action:\r\n                return label\r\n        return None", "response": "Returns the label that contains the inputed action."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the current action for this widget if it is currently being hidden.", "response": "def leaveEvent(self, event):\r\n        \"\"\"\r\n        Clears the current action for this widget.\r\n        \r\n        :param      event | <QEvent>\r\n        \"\"\"\r\n        super(XDockToolbar, self).leaveEvent(event)\r\n        \r\n        if not self.actionHeld():\r\n            self.setCurrentAction(None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef paintEvent(self, event):\r\n        x = 1\r\n        y = 1\r\n        w = self.width()\r\n        h = self.height()\r\n        \r\n        clr_a = QColor(220, 220, 220)\r\n        clr_b = QColor(190, 190, 190)\r\n        \r\n        grad = QLinearGradient()\r\n        grad.setColorAt(0.0, clr_a)\r\n        grad.setColorAt(0.6, clr_a)\r\n        grad.setColorAt(1.0, clr_b)\r\n        \r\n        # adjust the coloring for the horizontal toolbar\r\n        if self.position() & (self.Position.North | self.Position.South):\r\n            h = self.minimumPixmapSize().height() + 6\r\n            \r\n            if self.position() == self.Position.South:\r\n                y = self.height() - h\r\n                grad.setStart(0, y)\r\n                grad.setFinalStop(0, self.height())\r\n            else:\r\n                grad.setStart(0, 0)\r\n                grad.setFinalStart(0, h)\r\n        \r\n        # adjust the coloring for the vertical toolbar\r\n        if self.position() & (self.Position.East | self.Position.West):\r\n            w = self.minimumPixmapSize().width() + 6\r\n            \r\n            if self.position() == self.Position.West:\r\n                x = self.width() - w\r\n                grad.setStart(x, 0)\r\n                grad.setFinalStop(self.width(), 0)\r\n            else:\r\n                grad.setStart(0, 0)\r\n                grad.setFinalStop(w, 0)\r\n        \r\n        with XPainter(self) as painter:\r\n            painter.fillRect(x, y, w, h, grad)\r\n            \r\n            # show the active action\r\n            action = self.selectedAction()\r\n            if action is not None and \\\r\n               not self.currentAction() and \\\r\n               not self._animating:\r\n                for lbl in self.actionLabels():\r\n                    if lbl.action() != action:\r\n                        continue\r\n                    \r\n                    geom = lbl.geometry()\r\n                    size = lbl.pixmapSize()\r\n                    \r\n                    if self.position() == self.Position.North:\r\n                        x = geom.left()\r\n                        y = 0\r\n                        w = geom.width()\r\n                        h = size.height() + geom.top() + 2\r\n                    \r\n                    elif self.position() == self.Position.East:\r\n                        x = 0\r\n                        y = geom.top()\r\n                        w = size.width() + geom.left() + 2\r\n                        h = geom.height()\r\n                    \r\n                    painter.setPen(QColor(140, 140, 40))\r\n                    painter.setBrush(QColor(160, 160, 160))\r\n                    painter.drawRect(x, y, w, h)\r\n                    break", "response": "Paints the background for the dock toolbar."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rebuild(self):\r\n        if not self.isVisible():\r\n            return\r\n        \r\n        self.raise_()\r\n        \r\n        max_size = self.maximumPixmapSize()\r\n        min_size = self.minimumPixmapSize()\r\n        widget   = self.window()\r\n        rect     = widget.rect()\r\n        rect.setBottom(rect.bottom() - widget.statusBar().height())\r\n        rect.setTop(widget.menuBar().height())\r\n        offset   = self.padding()\r\n        \r\n        # align this widget to the north\r\n        if self.position() == XDockToolbar.Position.North:\r\n            self.move(rect.left(), rect.top())\r\n            self.resize(rect.width(), min_size.height() + offset)\r\n        \r\n        # align this widget to the east\r\n        elif self.position() == XDockToolbar.Position.East:\r\n            self.move(rect.left(), rect.top())\r\n            self.resize(min_size.width() + offset, rect.height())\r\n        \r\n        # align this widget to the south\r\n        elif self.position() == XDockToolbar.Position.South:\r\n            self.move(rect.left(), rect.top() - min_size.height() - offset)\r\n            self.resize(rect.width(), min_size.height() + offset)\r\n        \r\n        # align this widget to the west\r\n        else:\r\n            self.move(rect.right() - min_size.width() - offset, rect.top())\r\n            self.resize(min_size.width() + offset, rect.height())", "response": "Rebuilds the widget based on the position and current size and location of the parent."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setCurrentAction(self, action):\r\n        if action == self._currentAction:\r\n            return\r\n        \r\n        self._currentAction = action\r\n        self.currentActionChanged.emit(action)\r\n        \r\n        labels   = self.actionLabels()\r\n        anim_grp = QParallelAnimationGroup(self)\r\n        max_size = self.maximumPixmapSize()\r\n        min_size = self.minimumPixmapSize()\r\n        \r\n        if action:\r\n            label = self.labelForAction(action)\r\n            index = labels.index(label)\r\n            \r\n            # create the highlight effect\r\n            palette = self.palette()\r\n            effect = QGraphicsDropShadowEffect(label)\r\n            effect.setXOffset(0)\r\n            effect.setYOffset(0)\r\n            effect.setBlurRadius(20)\r\n            effect.setColor(QColor(40, 40, 40))\r\n            label.setGraphicsEffect(effect)\r\n            \r\n            offset = self.padding()\r\n            if self.position() in (XDockToolbar.Position.East,\r\n                                   XDockToolbar.Position.West):\r\n                self.resize(max_size.width() + offset, self.height())\r\n            \r\n            elif self.position() in (XDockToolbar.Position.North,\r\n                                     XDockToolbar.Position.South):\r\n                self.resize(self.width(), max_size.height() + offset)\r\n            \r\n            w  = max_size.width()\r\n            h  = max_size.height()\r\n            dw = (max_size.width() - min_size.width()) / 3\r\n            dh = (max_size.height() - min_size.height()) / 3\r\n            \r\n            for i in range(4):\r\n                before = index - i\r\n                after  = index + i\r\n                \r\n                if 0 <= before and before < len(labels):\r\n                    anim = XObjectAnimation(labels[before],\r\n                                            'setPixmapSize',\r\n                                            anim_grp)\r\n                    \r\n                    anim.setEasingCurve(self.easingCurve())\r\n                    anim.setStartValue(labels[before].pixmapSize())\r\n                    anim.setEndValue(QSize(w, h))\r\n                    anim.setDuration(self.duration())\r\n                    anim_grp.addAnimation(anim)\r\n                    \r\n                    if i:\r\n                        labels[before].setGraphicsEffect(None)\r\n                \r\n                if after != before and 0 <= after and after < len(labels):\r\n                    anim = XObjectAnimation(labels[after],\r\n                                            'setPixmapSize',\r\n                                            anim_grp)\r\n                    \r\n                    anim.setEasingCurve(self.easingCurve())\r\n                    anim.setStartValue(labels[after].pixmapSize())\r\n                    anim.setEndValue(QSize(w, h))\r\n                    anim.setDuration(self.duration())\r\n                    anim_grp.addAnimation(anim)\r\n                    \r\n                    if i:\r\n                        labels[after].setGraphicsEffect(None)\r\n            \r\n                w -= dw\r\n                h -= dh\r\n        else:\r\n            offset = self.padding()\r\n            for label in self.actionLabels():\r\n                # clear the graphics effect \r\n                label.setGraphicsEffect(None)\r\n                \r\n                # create the animation\r\n                anim = XObjectAnimation(label, 'setPixmapSize', self)\r\n                anim.setEasingCurve(self.easingCurve())\r\n                anim.setStartValue(label.pixmapSize())\r\n                anim.setEndValue(min_size)\r\n                anim.setDuration(self.duration())\r\n                anim_grp.addAnimation(anim)\r\n            \r\n            anim_grp.finished.connect(self.resizeToMinimum)\r\n        \r\n        anim_grp.start()\r\n        self._animating = True\r\n        anim_grp.finished.connect(anim_grp.deleteLater)\r\n        anim_grp.finished.connect(self.__markAnimatingFinished)\r\n        \r\n        if self._currentAction:\r\n            self._hoverTimer.start()\r\n        else:\r\n            self._hoverTimer.stop()", "response": "Sets the current action for this toolbar that highlights the size of the size of the current toolbar."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the maximum pixmap size for this toolbar.", "response": "def setMaximumPixmapSize(self, size):\r\n        \"\"\"\r\n        Sets the maximum pixmap size for this toolbar.\r\n        \r\n        :param     size | <int>\r\n        \"\"\"\r\n        self._maximumPixmapSize = size\r\n        position = self.position()\r\n        self._position = None\r\n        self.setPosition(position)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the minimum size that will be displayed for the dock widget.", "response": "def setMinimumPixmapSize(self, size):\r\n        \"\"\"\r\n        Sets the minimum pixmap size that will be displayed to the user\r\n        for the dock widget.\r\n        \r\n        :param     size | <int>\r\n        \"\"\"\r\n        self._minimumPixmapSize = size\r\n        position = self.position()\r\n        self._position = None\r\n        self.setPosition(position)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the position for this widget and its parent.", "response": "def setPosition(self, position):\r\n        \"\"\"\r\n        Sets the position for this widget and its parent.\r\n        \r\n        :param      position | <XDockToolbar.Position>\r\n        \"\"\"\r\n        if position == self._position:\r\n            return\r\n        \r\n        self._position = position\r\n        \r\n        widget   = self.window()\r\n        layout   = self.layout()\r\n        offset   = self.padding()\r\n        min_size = self.minimumPixmapSize()\r\n        \r\n        # set the layout to north\r\n        if position == XDockToolbar.Position.North:\r\n            self.move(0, 0)\r\n            widget.setContentsMargins(0, min_size.height() + offset, 0, 0)\r\n            layout.setDirection(QBoxLayout.LeftToRight)\r\n        \r\n        # set the layout to east\r\n        elif position == XDockToolbar.Position.East:\r\n            self.move(0, 0)\r\n            widget.setContentsMargins(min_size.width() + offset, 0, 0, 0)\r\n            layout.setDirection(QBoxLayout.TopToBottom)\r\n        \r\n        # set the layout to the south\r\n        elif position == XDockToolbar.Position.South:\r\n            widget.setContentsMargins(0, 0, 0, min_size.height() + offset)\r\n            layout.setDirection(QBoxLayout.LeftToRight)\r\n        \r\n        # set the layout to the west\r\n        else:\r\n            widget.setContentsMargins(0, 0, min_size.width() + offset, 0)\r\n            layout.setDirection(QBoxLayout.TopToBottom)\r\n        \r\n        # update the label alignments\r\n        for label in self.actionLabels():\r\n            label.setPosition(position)\r\n        \r\n        # rebuilds the widget\r\n        self.rebuild()\r\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets whether or not this toolbar is visible.", "response": "def setVisible(self, state):\r\n        \"\"\"\r\n        Sets whether or not this toolbar is visible.  If shown, it will rebuild.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        super(XDockToolbar, self).setVisible(state)\r\n        \r\n        if state:\r\n            self.rebuild()\r\n            self.setCurrentAction(None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unholdAction(self):\r\n        self._actionHeld = False\r\n        \r\n        point = self.mapFromGlobal(QCursor.pos())\r\n        self.setCurrentAction(self.actionAt(point))", "response": "Unholds the action from being blocked on the leave event."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef visualRect(self, action):\r\n        for widget in self.actionLabels():\r\n            if widget.action() == action:\r\n                return widget.geometry()\r\n        return QRect()", "response": "Returns the visual rect for the inputed action."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply( self ):\n        font = self.value('font')\r\n        \r\n        try:\n            font.setPointSize(self.value('fontSize'))\r\n        \r\n        # errors in linux for some reason\r\n        except TypeError:\r\n            pass\r\n        \r\n        palette = self.value('colorSet').palette()\n        \n        if ( unwrapVariant(QApplication.instance().property('useScheme')) ):\n            QApplication.instance().setFont(font)\n            QApplication.instance().setPalette(palette)\r\n            \r\n            # hack to support MDI Areas\r\n            for widget in QApplication.topLevelWidgets():\r\n                for area in widget.findChildren(QMdiArea):\r\n                    area.setPalette(palette)\n        else:\n            logger.debug('The application doesnt have the useScheme property.')", "response": "Applies the scheme to the current application."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the values to the current application information.", "response": "def reset( self ):\n        \"\"\"\n        Resets the values to the current application information.\n        \"\"\"\n        self.setValue('colorSet', XPaletteColorSet())\n        self.setValue('font',     QApplication.font())\n        self.setValue('fontSize', QApplication.font().pointSize())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an attachment to this comment.", "response": "def addAttachment(self, title, attachment):\r\n        \"\"\"\r\n        Adds an attachment to this comment.\r\n        \r\n        :param      title      | <str>\r\n                    attachment | <variant>\r\n        \"\"\"\r\n        self._attachments[title] = attachment\r\n        self.resizeToContents()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pickAttachment(self):\r\n        filename = QFileDialog.getOpenFileName(self.window(),\r\n                                               'Select Attachment',\r\n                                               '',\r\n                                               'All Files (*.*)')\r\n        \r\n        if type(filename) == tuple:\r\n            filename = nativestring(filename[0])\r\n        \r\n        filename = nativestring(filename)\r\n        if filename:\r\n            self.addAttachment(os.path.basename(filename), filename)", "response": "Prompts the user to select an attachment to add to this edit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the first attachment with the given title.", "response": "def removeAttachment(self, title):\r\n        \"\"\"\r\n        Removes the attachment from the given title.\r\n        \r\n        :param      title | <str>\r\n        \r\n        :return     <variant> | attachment\r\n        \"\"\"\r\n        attachment = self._attachments.pop(nativestring(title), None)\r\n        \r\n        if attachment:\r\n            self.resizeToContents()\r\n        \r\n        return attachment"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setShowAttachments(self, state):\r\n        self._showAttachments = state\r\n        self._attachAction.setVisible(state)", "response": "Sets whether or not the attachments should be shown for this edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setCurrentFamily(self, family):\r\n        for i in range(self.uiFontTREE.topLevelItemCount()):\r\n            item = self.uiFontTREE.topLevelItem(i)\r\n            if item.text(0) == family:\r\n                self.uiFontTREE.setCurrentItem(item)\r\n                return\r\n        \r\n        self.uiFontTREE.setCurrentItem(None)", "response": "Sets the current font family to the inputed family."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setPointSize(self, pointSize):\r\n        self.uiSizeSPN.blockSignals(True)\r\n        self.uiSizeSPN.setValue(pointSize)\r\n        self.uiSizeSPN.blockSignals(False)\r\n        \r\n        for i in range(self.uiFontTREE.topLevelItemCount()):\r\n            item = self.uiFontTREE.topLevelItem(i)\r\n            font = item.font(0)\r\n            font.setPointSize(pointSize)\r\n            item.setFont(0, font)", "response": "Sets the point size for this widget to the inputed size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninspect the Raft configuration of a specific agent.", "response": "async def configuration(self, *, dc=None, consistency=None):\n        \"\"\"Inspects the Raft configuration\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            consistency (str): Read the Raft configuration from any of the\n                               Consul servers, otherwise raise an exception\n                               if the cluster doesn't currently have a leader.\n        Returns:\n            Object:\n\n        A JSON body is returned that looks like this::\n\n            {\n                \"Servers\": [\n                    {\n                        \"ID\": \"127.0.0.1:8300\",\n                        \"Node\": \"alice\",\n                        \"Address\": \"127.0.0.1:8300\",\n                        \"Leader\": True,\n                        \"Voter\": True\n                    },\n                    {\n                        \"ID\": \"127.0.0.2:8300\",\n                        \"Node\": \"bob\",\n                        \"Address\": \"127.0.0.2:8300\",\n                        \"Leader\": False,\n                        \"Voter\": True\n                    },\n                    {\n                        \"ID\": \"127.0.0.3:8300\",\n                        \"Node\": \"carol\",\n                        \"Address\": \"127.0.0.3:8300\",\n                        \"Leader\": False,\n                        \"Voter\": True\n                    }\n                ],\n                \"Index\": 22\n            }\n\n        The **Servers** array has information about the servers in the\n        Raft peer configuration:\n\n        **ID** is the ID of the server. This is the same as the **Address**.\n\n        **Node** is the node name of the server, as known to Consul, or\n        \"(unknown)\" if the node is stale and not known.\n\n        **Address** is the IP:port for the server.\n\n        **Leader** is either ``True`` or ``False`` depending on the server's\n        role in the Raft configuration.\n\n        **Voter** is ``True`` or ``False``, indicating if the server has a\n        vote in the Raft configuration. Future versions of Consul may add\n        support for non-voting servers.\n\n        The **Index** value is the Raft corresponding to this configuration.\n        Note that the latest configuration may not yet be committed if changes\n        are in flight.\n        \"\"\"\n        response = await self._api.get(\"/v1/operator/raft/configuration\",\n                                       params={\"dc\": dc},\n                                       consistency=consistency)\n        return response.body"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the server with given address from the Raft configuration.", "response": "async def peer_delete(self, *, dc=None, address):\n        \"\"\"Remove the server with given address from the Raft configuration\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            address (str): \"IP:port\" of the server to remove.\n        Returns:\n            bool: ``True`` on success\n\n        There are rare cases where a peer may be left behind in the Raft\n        configuration even though the server is no longer present and known\n        to the cluster. This endpoint can be used to remove the failed server\n        so that it is no longer affects the Raft quorum.\n        \"\"\"\n        address = extract_attr(address, keys=[\"Address\"])\n        params = {\"dc\": dc, \"address\": address}\n        response = await self._api.delete(\"/v1/operator/raft/peer\",\n                                          params=params)\n        return response.status < 400"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addSlide(self, slide):\r\n        # create the scene\r\n        scene = XWalkthroughScene(self)\r\n        scene.setReferenceWidget(self.parent())\r\n        scene.load(slide)\r\n        \r\n        # create the view\r\n        view = QtGui.QGraphicsView(self)\r\n        view.setCacheMode(view.CacheBackground)\r\n        view.setScene(scene)\r\n        view.setStyleSheet('background: transparent')\r\n        view.setFrameShape(view.NoFrame)\r\n        view.setInteractive(False)\r\n        view.setFocusPolicy(QtCore.Qt.NoFocus)\r\n        view.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents)\r\n        view.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)\r\n        view.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        view.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        \r\n        # add the slide\r\n        self._slideshow.addWidget(view)\r\n        self.updateUi()\r\n        \r\n        return view", "response": "Adds a new slide to the widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef eventFilter(self, obj, event):\r\n        if event.type() == event.Resize:\r\n            self.resize(event.size())\r\n        \r\n        return False", "response": "Filters the parent object for the specified event."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove to the next slide in the walkthrough.", "response": "def goForward(self):\r\n        \"\"\"\r\n        Moves to the next slide or finishes the walkthrough.\r\n        \"\"\"\r\n        if self._slideshow.currentIndex() == self._slideshow.count() - 1:\r\n            self.finished.emit()\r\n        else:\r\n            self._slideshow.slideInNext()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef keyPressEvent(self, event):\r\n        if event.key() == QtCore.Qt.Key_Escape:\r\n            self.cancel()\r\n        elif event.key() == QtCore.Qt.Key_Left:\r\n            self.goBack()\r\n        elif event.key() == QtCore.Qt.Key_Right:\r\n            self.goForward()\r\n        elif event.key() == QtCore.Qt.Key_Home:\r\n            self.restart()\r\n        \r\n        super(XWalkthroughWidget, self).keyPressEvent(event)", "response": "Handles the key press event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, walkthrough):\r\n        if type(walkthrough) in (str, unicode):\r\n            walkthrough = XWalkthrough.load(walkthrough)\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        self.clear()\r\n        for slide in walkthrough.slides():\r\n            self.addSlide(slide)\r\n        self.setUpdatesEnabled(True)\r\n        self.updateUi()", "response": "Load the XML text for a new walkthrough."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resizeEvent(self, event):\r\n        super(XWalkthroughWidget, self).resizeEvent(event)\r\n        \r\n        if self.isVisible():\r\n            self.autoLayout()", "response": "Resize the widgets around the system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the interface to show the selection buttons.", "response": "def updateUi(self):\r\n        \"\"\"\r\n        Updates the interface to show the selection buttons.\r\n        \"\"\"\r\n        index = self._slideshow.currentIndex()\r\n        count = self._slideshow.count()\r\n        \r\n        self._previousButton.setVisible(index != 0)\r\n        self._nextButton.setText('Finish' if index == count - 1 else 'Next')\r\n        self.autoLayout()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mouseReleaseEvent(self, event):\r\n        if event.button() == QtCore.Qt.LeftButton:\r\n            if event.modifiers() == QtCore.Qt.ControlModifier:\r\n                self.goBack()\r\n            else:\r\n                self.goForward()\r\n        \r\n        super(XWalkthroughWidget, self).mouseReleaseEvent(event)", "response": "Moves the slide back when clicked."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall by Qt when the user hits the show event.", "response": "def showEvent(self, event):\r\n        \"\"\"\r\n        Raises this widget when it is shown.\r\n        \r\n        :param      event | <QtCore.QShowEvent>\r\n        \"\"\"\r\n        super(XWalkthroughWidget, self).showEvent(event)\r\n        \r\n        self.autoLayout()\r\n        self.restart()\r\n        self.setFocus()\r\n        self.raise_()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef http_construct(args, unknown):\n\n    str_http    = ''\n    b_httpSpecd = False\n\n    if '--http' in unknown:\n        try:\n            str_httpArg = unknown[unknown.index('--http')+1]\n            unknown.remove('--http')\n            unknown.remove(str_httpArg)\n        except:\n            str_httpArg = \"\"\n        str_http    = '--http %s' % str_httpArg\n        b_httpSpecd = True\n\n    if not b_httpSpecd:\n        str_serverIP  = \"172.17.0.2\"\n        str_serverPort  = '5010'\n        try:\n            if args.b_pman:\n                str_serverIP    = os.environ['PMAN_PORT_5010_TCP_ADDR']\n                str_serverPort  = os.environ['PMAN_PORT_5010_TCP_PORT']\n            if args.b_pfioh:\n                str_serverIP    = os.environ['PFIOH_PORT_5055_TCP_ADDR']\n                str_serverPort  = os.environ['PFIOH_PORT_5055_TCP_PORT']\n        except:\n            pass\n        str_http    = '--http %s:%s/api/v1/cmd/' % (str_serverIP, str_serverPort)\n\n    return str_http", "response": "Construct the HTTP command from the args and unknown space."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndoes a fuzzy match for prop in the dictionary taking into account unit suffix.", "response": "def parse_unit(prop, dictionary, dt=None):\n    '''Do a fuzzy match for `prop` in the dictionary, taking into account unit suffix.'''\n    # add the observation's time\n    try:\n        dt = timezone.parse_datetime(dictionary.get('date_time'))\n    except TypeError:\n        dt = None\n\n    # 'prop' is a stub of the property's attribute key, so search for matches\n    matches = [k for k in dictionary.keys() if prop in k]\n\n    try:\n        value = dictionary[matches[0]]\n        unit = re.search(r' \\(([^)]+)\\)', matches[0])\n\n    except IndexError:\n        # No matches: fail out\n        return None\n\n    # Sometimes we get a list of values (e.g. waves)\n    if ';' in value:\n        # Ignore empty values\n        values = [val for val in value.split(';') if val != '']\n\n        if unit:\n            return [Observation(v, unit.group(1), dt) for v in values]\n        else:\n            return values\n\n    # Sometimes there's no value! Sometimes there's no unit!\n    if not value or not unit:\n        return value or None\n\n    return Observation(value, unit.group(1), dt)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new query container object and slides it into the next frame. Returns the newly created container object.", "response": "def addContainer(self, query):\r\n        \"\"\"\r\n        Creates a new query container widget object and slides it into\r\n        the frame.\r\n        \r\n        :return     <XOrbQueryContainer>\r\n        \"\"\"\r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        container = XOrbQueryContainer(self)\r\n        \r\n        # setup properties\r\n        container.setShowBack(self.count() > 0)\r\n        \r\n        # create connections\r\n        container.enterCompoundRequested.connect(self.enterContainer)\r\n        container.exitCompoundRequested.connect(self.exitContainer)\r\n        \r\n        # show the widget\r\n        self.addWidget(container)\r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)\r\n        \r\n        container.setQuery(query)\r\n        self.slideInNext()\r\n        return container"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear all the container for this query.", "response": "def clear(self):\r\n        \"\"\"\r\n        Clears all the container for this query widget.\r\n        \"\"\"\r\n        for i in range(self.count()):\r\n            widget = self.widget(i)\r\n            if widget is not None:\r\n                widget.close()\r\n                widget.setParent(None)\r\n                widget.deleteLater()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cleanupContainers(self):\r\n        for i in range(self.count() - 1, self.currentIndex(), -1):\r\n            widget = self.widget(i)\r\n            widget.close()\r\n            widget.setParent(None)\r\n            widget.deleteLater()", "response": "Cleans up all containers to the right of the current one."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef containerFor(self, entry):\r\n        try:\r\n            index = self._compoundStack.index(entry)\r\n        except ValueError:\r\n            return None\r\n        \r\n        return self.widget(index + 1)", "response": "Returns a container for the inputed entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a new container for the given entry widget.", "response": "def enterContainer(self, entry, query):\r\n        \"\"\"\r\n        Enters a new container for the given entry widget.\r\n        \r\n        :param      entry | <XOrbQueryEntryWidget> || None\r\n        \"\"\"\r\n        self._compoundStack.append(entry)\r\n        self.addContainer(query)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef exitContainer(self):\r\n        try:\r\n            entry = self._compoundStack.pop()\r\n        except IndexError:\r\n            return\r\n        \r\n        container = self.currentContainer()\r\n        entry.setQuery(container.query())\r\n        \r\n        self.slideInPrev()", "response": "Removes the current query container from the compound stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query(self):\r\n        if self._loadQuery is not None:\r\n            return self._loadQuery\r\n        \r\n        container = self.widget(0)\r\n        if container:\r\n            query = container.query()\r\n        else:\r\n            query = Query()\r\n        \r\n        return query", "response": "Returns the full query for all containers within this widget."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrentQuery(self, query):\r\n        container = self.currentContainer()\r\n        if container:\r\n            container.setQuery(query)", "response": "Sets the query for the current container widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the query for this widget to the inputed query.", "response": "def setQuery(self, query):\r\n        \"\"\"\r\n        Sets the query for this widget to the inputed query.  This will clear\r\n        completely the current inforamation and reest all containers to the\r\n        inputed query information.\r\n        \r\n        :param      query | <orb.Query>\r\n        \"\"\"\r\n        if not self.isVisible():\r\n            self._loadQuery = query\r\n        else:\r\n            self._loadQuery = None\r\n            \r\n            if self._initialized and hash(query) == hash(self.query()):\r\n                return\r\n            \r\n            self._initialized = True\r\n            self.clear()\r\n            self.addContainer(query)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the table type for this instance to the given type.", "response": "def setTableType(self, tableType):\r\n        \"\"\"\r\n        Sets the table type for this instance to the given type.\r\n        \r\n        :param      tableType | <orb.Table>\r\n        \"\"\"\r\n        if tableType == self._tableType:\r\n            return\r\n        \r\n        self._initialized = False\r\n        self._tableType = tableType\r\n        self.setQuery(Query())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rebuild( self ):\r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        \r\n        # clear out all the subwidgets for this widget\r\n        for child in self.findChildren(QObject):\r\n            child.setParent(None)\r\n            child.deleteLater()\r\n        \r\n        # load up all the interface for this widget\r\n        schema = self.schema()\r\n        if ( schema ):\r\n            self.setEnabled(True)\r\n            \r\n            uifile = self.uiFile()\r\n            \r\n            # load a user defined file\r\n            if ( uifile ):\r\n                projexui.loadUi('', self, uifile)\r\n                \r\n                for widget in self.findChildren(XOrbColumnEdit):\r\n                    columnName = widget.columnName()\r\n                    column     = schema.column(columnName)\r\n                    \r\n                    if ( column ):\r\n                        widget.setColumn(column)\r\n                    else:\r\n                        logger.debug('%s is not a valid column of %s' % \\\r\n                                     (columnName, schema.name()))\r\n            \r\n            # dynamically load files\r\n            else:\r\n                layout = QFormLayout()\r\n                layout.setContentsMargins(0, 0, 0, 0)\r\n                columns = schema.columns()\r\n                columns.sort(key = lambda x: x.displayName())\r\n                \r\n                record = self.record()\r\n                \r\n                for column in columns:\r\n                    # ignore protected columns\r\n                    if ( column.name().startswith('_') ):\r\n                        continue\r\n                    \r\n                    label   = column.displayName()\r\n                    coltype = column.columnType()\r\n                    name    = column.name()\r\n                    \r\n                    # create the column edit widget\r\n                    widget  = XOrbColumnEdit(self)\r\n                    widget.setObjectName('ui_' + name)\r\n                    widget.setColumnName(name)\r\n                    widget.setColumnType(coltype)\r\n                    widget.setColumn(column)\r\n                    \r\n                    layout.addRow(QLabel(label, self), widget)\r\n                \r\n                self.setLayout(layout)\r\n                self.adjustSize()\r\n                \r\n                self.setWindowTitle('Edit %s' % schema.name())\r\n        else:\r\n            self.setEnabled(False)\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)", "response": "Rebuilds the interface for this widget based on the current model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the values from the editor to the system.", "response": "def save( self ):\r\n        \"\"\"\r\n        Saves the values from the editor to the system.\r\n        \"\"\"\r\n        schema = self.schema()\r\n        if ( not schema ):\r\n            self.saved.emit()\r\n            return\r\n        \r\n        record = self.record()\r\n        if not record:\r\n            record = self._model()\r\n        \r\n        # validate the information\r\n        save_data    = []\r\n        column_edits = self.findChildren(XOrbColumnEdit)\r\n        for widget in column_edits:\r\n            columnName  = widget.columnName()\r\n            column      = schema.column(columnName)\r\n            \r\n            if ( not column ):\r\n                logger.warning('%s is not a valid column of %s.' % \\\r\n                               (columnName, schema.name()))\r\n                continue\r\n            \r\n            value = widget.value()\r\n            if ( value == IGNORED ):\r\n                continue\r\n            \r\n            # check for required columns\r\n            if ( column.required() and not value ):\r\n                name = column.displayName()\r\n                QMessageBox.information(self, \r\n                                        'Missing Required Field',\r\n                                        '%s is a required field.' % name)\r\n                return\r\n            \r\n            # check for unique columns\r\n            elif ( column.unique() ):\r\n                # check for uniqueness\r\n                query        = Q(column.name()) == value\r\n                if ( record.isRecord() ):\r\n                    query   &= Q(self._model) != record\r\n                \r\n                columns  = self._model.schema().primaryColumns()\r\n                result   = self._model.select(columns = columns, where = query)\r\n                \r\n                if ( result.total() ):\r\n                    QMessageBox.information(self,\r\n                                            'Duplicate Entry',\r\n                                            '%s already exists.' % value)\r\n                    return\r\n            \r\n            save_data.append((column, value))\r\n        \r\n        # record the properties for the record\r\n        for column, value in save_data:\r\n            record.setRecordValue(column.name(), value)\r\n        \r\n        self._record = record\r\n        \r\n        self.saved.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setRecord( self, record ):\r\n        self._record = record\r\n        \r\n        if ( not record ):\r\n            return\r\n        \r\n        self.setModel(record.__class__)\r\n        schema = self.model().schema()\r\n        \r\n        # set the information\r\n        column_edits = self.findChildren(XOrbColumnEdit)\r\n        for widget in column_edits:\r\n            columnName  = widget.columnName()\r\n            column      = schema.column(columnName)\r\n            \r\n            if ( not column ):\r\n                logger.warning('%s is not a valid column of %s.' % \\\r\n                               (columnName, schema.name()))\r\n                continue\r\n                \r\n            # update the values\r\n            widget.setValue(record.recordValue(columnName))", "response": "Sets the record instance for this widget to the inputed record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setModel( self, model ):\r\n        if model == self._model:\r\n            return False\r\n            \r\n        self._model = model\r\n        \r\n        if not self._record and model:\r\n            self._record = model()\r\n        \r\n        if model:\r\n            uifile = model.schema().property('uifile')\r\n            if ( uifile ):\r\n                self.setUiFile(uifile)\r\n        \r\n        self.rebuild()\r\n        \r\n        return True", "response": "Sets the model that this widget is going to be used to define the interface for this model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit( cls, record, parent = None, uifile = '', commit = True ):\r\n        # create the dialog\r\n        dlg = QDialog(parent)\r\n        dlg.setWindowTitle('Edit %s' % record.schema().name())\r\n        \r\n        # create the widget\r\n        cls    = record.schema().property('widgetClass', cls)\r\n        \r\n        widget = cls(dlg)\r\n        \r\n        if ( uifile ):\r\n            widget.setUiFile(uifile)\r\n        \r\n        widget.setRecord(record)\r\n        widget.layout().setContentsMargins(0, 0, 0, 0)\r\n        \r\n        # create buttons\r\n        opts = QDialogButtonBox.Save | QDialogButtonBox.Cancel\r\n        btns = QDialogButtonBox(opts, Qt.Horizontal, dlg)\r\n        \r\n        # create layout\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(widget)\r\n        layout.addWidget(btns)\r\n        \r\n        dlg.setLayout(layout)\r\n        dlg.adjustSize()\r\n        \r\n        # create connections\r\n        #btns.accepted.connect(widget.save)\r\n        btns.rejected.connect(dlg.reject)\r\n        widget.saved.connect(dlg.accept)\r\n        \r\n        if ( dlg.exec_() ):\r\n            if commit:\r\n                result = widget.record().commit()\r\n                if 'errored' in result:\r\n                    QMessageBox.information(self.window(),\r\n                                            'Error Committing to Database',\r\n                                            result['errored'])\r\n                    return False\r\n            return True\r\n        return False", "response": "Prompts the user to edit the inputed record."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new record for the inputed table.", "response": "def create( cls, model, parent = None, uifile = '', commit = True ):\r\n        \"\"\"\r\n        Prompts the user to create a new record for the inputed table.\r\n        \r\n        :param      model   | <subclass of orb.Table>\r\n                    parent  | <QWidget>\r\n        \r\n        :return     <orb.Table> || None/ | instance of the inputed table class\r\n        \"\"\"\r\n        # create the dialog\r\n        dlg = QDialog(parent)\r\n        dlg.setWindowTitle('Create %s' % model.schema().name())\r\n        \r\n        # create the widget\r\n        cls    = model.schema().property('widgetClass', cls)\r\n        widget = cls(dlg)\r\n        \r\n        if ( uifile ):\r\n            widget.setUiFile(uifile)\r\n        \r\n        widget.setModel(model)\r\n        widget.layout().setContentsMargins(0, 0, 0, 0)\r\n        \r\n        # create buttons\r\n        opts = QDialogButtonBox.Save | QDialogButtonBox.Cancel\r\n        btns = QDialogButtonBox(opts, Qt.Horizontal, dlg)\r\n        \r\n        # create layout\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(widget)\r\n        layout.addWidget(btns)\r\n        \r\n        dlg.setLayout(layout)\r\n        dlg.adjustSize()\r\n        \r\n        # create connections\r\n        btns.accepted.connect(widget.save)\r\n        btns.rejected.connect(dlg.reject)\r\n        widget.saved.connect(dlg.accept)\r\n        \r\n        if ( dlg.exec_() ):\r\n            record = widget.record()\r\n            if ( commit ):\r\n                record.commit()\r\n            return record\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if event should be ignored.", "response": "def eventFilter(self, object, event):\r\n        \"\"\"\r\n        Ignore all events for the text label.\r\n        \r\n        :param      object | <QObject>\r\n                    event  | <QEvent>\r\n        \"\"\"\r\n        if object == self._richTextLabel:\r\n            if event.type() in (event.MouseButtonPress,\r\n                                event.MouseMove,\r\n                                event.MouseButtonRelease,\r\n                                event.MouseButtonDblClick):\r\n                event.ignore()\r\n                return True\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resizeEvent(self, event):\r\n        super(XPushButton, self).resizeEvent(event)\r\n        \r\n        if self._richTextLabel:\r\n            self._richTextLabel.resize(event.size())", "response": "Overloads the resize event to auto - resize the rich text label."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the label that is used for drawing the rich text to this button.", "response": "def richTextLabel(self):\r\n        \"\"\"\r\n        Returns the label that is used for drawing the rich text to this button.\r\n        \r\n        :return     <QLabel>\r\n        \"\"\"\r\n        if not self._richTextLabel:\r\n            self._richTextLabel = QLabel(self)\r\n            self._richTextLabel.installEventFilter(self)\r\n            self._richTextLabel.setMargin(10)\r\n        return self._richTextLabel"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setShowRichText(self, state):\r\n        self._showRichText = state\r\n        text = self.text()\r\n        \r\n        if state:\r\n            label = self.richTextLabel()\r\n            label.setText(text)\r\n            label.show()\r\n            super(XPushButton, self).setText('')\r\n        else:\r\n            if self._richTextLabel:\r\n                self._richTextLabel.hide()\r\n            \r\n            super(XPushButton, self).setText(text)", "response": "Sets whether or not to display rich text for this button."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setText(self, text):\r\n        self._text = nativestring(text)\r\n        if self.showRichText():\r\n            self.richTextLabel().setText(text)\r\n        else:\r\n            super(XPushButton, self).setText(text)", "response": "Sets the text for this button."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addLogger(self, logger, level=logging.INFO):\r\n        if isinstance(logger, logging.Logger):\r\n            logger = logger.name\r\n        \r\n        if logger in self._loggers:\r\n            return\r\n        \r\n        # allow the handler to determine the level for this logger\r\n        if logger == 'root':\r\n            _log = logging.getLogger()\r\n        else:\r\n            _log = logging.getLogger(logger)\r\n        \r\n        _log.addHandler(self.handler())\r\n        \r\n        self._loggers.add(logger)\r\n        self.handler().setLoggerLevel(logger, level)", "response": "Adds the inputed logger to the list of loggers that are being tracked\r\n            with this widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the inputed record to the internal list of log records.", "response": "def addRecord(self, record):\r\n        \"\"\"\r\n        Adds the inputed record to this logger tree widget.\r\n        \r\n        :param      record | <logging.LogRecord>\r\n        \"\"\"\r\n        if self._destroyed:\r\n            return\r\n        \r\n        if not self.uiRecordBTN.isChecked():\r\n            return\r\n        \r\n        self._queue.append(record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the inputed logger from the set for this widget.", "response": "def clearLoggers(self, logger):\r\n        \"\"\"\r\n        Removes the inputed logger from the set for this widget.\r\n        \r\n        :param      logger | <str> || <logging.Logger>\r\n        \"\"\"\r\n        for logger in self._loggers:\r\n            if logger == 'root':\r\n                logger = logging.getLogger()\r\n            else:\r\n                logger = logging.getLogger(logger)\r\n            logger.removeHandler(self.handler())\r\n        \r\n        self._loggers = set()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns whether or not the given logger is tracked by this widget.", "response": "def hasLogger(self, logger):\r\n        \"\"\"\r\n        Returns whether or not the inputed logger is tracked by this widget.\r\n        \r\n        :param      logger | <str> || <logging.Logger>\r\n        \"\"\"\r\n        if isinstance(logger, logging.Logger):\r\n            logger = logging.name\r\n        \r\n        return logger in self._loggers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removeLogger(self, logger):\r\n        if isinstance(logger, logging.Logger):\r\n            logger = logger.name\r\n        \r\n        if logger in self._loggers:\r\n            self._loggers.remove(logger)\r\n            if logger == 'root':\r\n                logger = logging.getLogger()\r\n            else:\r\n                logger = logging.getLogger(logger)\r\n            \r\n            logger.removeHandler(self.handler())", "response": "Removes the specified logger from the set for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrestoring the settings for this logger from the inputed settings.", "response": "def restoreSettings(self, settings):\r\n        \"\"\"\r\n        Restores the settings for this logger from the inputed settings.\r\n        \r\n        :param      <QtCore.QSettings>\r\n        \"\"\"\r\n        levels = unwrapVariant(settings.value('levels'))\r\n        if levels:\r\n            self.setActiveLevels(map(int, levels.split(',')))\r\n        \r\n        logger_levels = unwrapVariant(settings.value('loggerLevels'))\r\n        if logger_levels:\r\n            for key in logger_levels.split(','):\r\n                logger, lvl = key.split(':')\r\n                lvl = int(lvl)\r\n                self.setLoggerLevel(logger, lvl)\r\n        \r\n        filt = unwrapVariant(settings.value('filter'))\r\n        if filt:\r\n            self.uiFilterTXT.setText(filt)\r\n        self.uiRecordTREE.restoreSettings(settings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestores the logging settings for this widget from XML format.", "response": "def restoreXml(self, xml):\r\n        \"\"\"\r\n        Saves the logging settings for this widget to XML format.\r\n        \r\n        :param      xml | <xml.etree.ElementTree.Element>\r\n        \"\"\"\r\n        self.uiFilterTXT.setText(xml.get('filter', ''))\r\n        \r\n        xlevels = xml.find('levels')\r\n        xloggerlevels = xml.find('logger_levels')\r\n        xtree = xml.find('tree')\r\n        \r\n        if xlevels is not None and xlevels.text:\r\n            self.setActiveLevels(map(int, xlevels.text.split(',')))\r\n        if xloggerlevels is not None and xloggerlevels.text:\r\n            for key in xloggerlevels.text.split(','):\r\n                logger, lvl = key.split(':')\r\n                lvl = int(lvl)\r\n                self.setLoggerLevel(logger, lvl)\r\n        \r\n        if xtree is not None:\r\n            self.uiRecordTREE.restoreXml(xtree)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef saveXml(self, xml):\r\n        lvls = []\r\n        for logger, level in self.loggerLevels().items():\r\n            lvls.append('{0}:{1}'.format(logger, level))\r\n        \r\n        xlevels = ElementTree.SubElement(xml, 'levels')\r\n        xlevels.text = ','.join(map(str, self.activeLevels()))\r\n        \r\n        xloggerlevels = ElementTree.SubElement(xml, 'logger_levels')\r\n        xloggerlevels.text = ','.join(lvls)\r\n        \r\n        xml.set('filter', wrapVariant(self.uiFilterTXT.text()))\r\n        \r\n        xtree = ElementTree.SubElement(xml, 'tree')\r\n        self.uiRecordTREE.saveXml(xtree)", "response": "Save the logging settings for this widget to XML format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setActiveLevels(self, levels):\r\n        self._activeLevels = levels\r\n        tree = self.uiRecordTREE\r\n        tree.setUpdatesEnabled(False)\r\n        tree.blockSignals(True)\r\n        \r\n        for i in tree.topLevelItems():\r\n            if levels and i.record().levelno not in levels:\r\n                i.setHidden(True)\r\n            else:\r\n                i.setHidden(False)\r\n        \r\n        tree.blockSignals(False)\r\n        tree.setUpdatesEnabled(True)", "response": "Sets the active levels for this widgets visible and processed levels."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the logging level for the inputed logger.", "response": "def setLoggerLevel(self, logger, level):\r\n        \"\"\"\r\n        Returns the logging level for the inputed logger.\r\n        \r\n        :param      logger | <logging.Logger> || <str>\r\n                    level  | <logging.LEVEL>\r\n        \"\"\"\r\n        if level == logging.NOTSET:\r\n            self.removeLogger(logger)\r\n            self.handler().setLoggerLevel(logger, level)\r\n            return\r\n            \r\n        if isinstance(logger, logging.Logger):\r\n            logger = logger.name\r\n        \r\n        if not logger in self._loggers:\r\n            self.addLogger(logger, level)\r\n        else:\r\n            self.handler().setLoggerLevel(logger, level)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setLogo( self, logo ):\n        if ( isinstance(logo, basestring) ):\n            logo = QPixmap(logo)\n        \n        self.uiLogoLBL.setHidden(logo.isNull())\n        self.uiLogoLBL.setPixmap(logo)", "response": "Sets the logo for this dialog."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef aboutModule( module, parent = None, logo = '' ):\n        \n        dlg = XAboutDialog( parent )\n        dlg.setLogo( logo )\n        dlg.setInfo( XAboutDialog.moduleInfo(module) )\n        \n        dlg.exec_()", "response": "Displays information about a module."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay information in a popup dialog.", "response": "def about( info, parent = None, logo = '' ):\n        \"\"\"\n        Displays about information in a popup dialog.\n        \n        :param      info    | <str>\n                    parent  | <QWidget>\n                    logo    | <QPixmap> || <str>\n        \"\"\"\n        \n        dlg = XAboutDialog(parent)\n        dlg.setLogo(logo)\n        dlg.setInfo(info)\n        \n        dlg.exec_()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef moduleInfo( module ):\n        data = module.__dict__\n        \n        html = []\n        html.append( '<h2>%s</h2>' % data.get('__name__', 'Unknown') )\n        html.append( '<hr/>' )\n        ver = data.get('__version__', '0')\n        html.append( '<small>version: %s</small>' % ver)\n        html.append( '<br/>' )\n        html.append( nativestring(data.get('__doc__', '')) )\n        html.append( '<br/><br/><b>Authors</b><ul/>' )\n        \n        for author in data.get('__authors__', []):\n            html.append( '<li>%s</li>' % author )\n            \n        html.append( '</ul>' )\n        html.append( '<br/><br/><b>Depends on:</b>' )\n        for depends in data.get('__depends__', []):\n            html.append( '<li>%s</li>' % depends )\n            \n        html.append( '</ul>' )\n        html.append( '' )\n        html.append( '<br/><br/><b>Credits</b></ul>' )\n        \n        for credit in data.get('__credits__', []):\n            html.append('<li>%s: %s</li>' % credit)\n            \n        html.append( '</ul>' )\n        \n        opts = (data.get('__maintainer__', ''), data.get('__email__', ''))\n        html.append('<br/><br/><small>maintained by: %s email: %s</small>' % opts)\n        \n        opts = (data.get('__copyright__', ''), data.get('__license__', ''))\n        html.append('<br/><small>%s | license: %s</small>' % opts)\n        \n        return '\\n'.join(html)", "response": "Generates the HTML information to display for the about info for a module."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef acceptText(self):\r\n        if not self.signalsBlocked():\r\n            self.textEntered.emit(self.toPlainText())\r\n            self.htmlEntered.emit(self.toHtml())\r\n            self.returnPressed.emit()", "response": "Emits the editing finished signals for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear the text for this edit and resizes the toolbar information.", "response": "def clear(self):\r\n        \"\"\"\r\n        Clears the text for this edit and resizes the toolbar information.\r\n        \"\"\"\r\n        super(XTextEdit, self).clear()\r\n        \r\n        self.textEntered.emit('')\r\n        self.htmlEntered.emit('')\r\n        \r\n        if self.autoResizeToContents():\r\n            self.resizeToContents()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef focusInEvent(self, event):\r\n        if not self.signalsBlocked():\r\n            self.focusChanged.emit(True)\r\n            self.focusEntered.emit()\r\n        \r\n        return super(XTextEdit, self).focusInEvent(event)", "response": "Processes when this widget recieves focus."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing when this widget loses focus.", "response": "def focusOutEvent(self, event):\r\n        \"\"\"\r\n        Processes when this widget loses focus.\r\n        \r\n        :param      event | <QFocusEvent>\r\n        \"\"\"\r\n        if not self.signalsBlocked():\r\n            self.focusChanged.emit(False)\r\n            self.focusExited.emit()\r\n        \r\n        return super(XTextEdit, self).focusOutEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef keyPressEvent(self, event):\r\n        # emit the return pressed signal for this widget\r\n        if event.key() in (Qt.Key_Return, Qt.Key_Enter) and \\\r\n           event.modifiers() == Qt.ControlModifier:\r\n            self.acceptText()\r\n            event.accept()\r\n            return\r\n        \r\n        elif event.key() == Qt.Key_Tab:\r\n            if self.tabsAsSpaces():\r\n                count = 4 - (self.textCursor().columnNumber() % 4)\r\n                self.insertPlainText(' ' * count)\r\n                event.accept()\r\n                return\r\n        \r\n        elif event.key() == Qt.Key_V and event.modifiers() == Qt.ControlModifier:\r\n            self.paste()\r\n            event.accept()\r\n            return\r\n        \r\n        super(XTextEdit, self).keyPressEvent(event)\r\n        \r\n        if self.autoResizeToContents():\r\n            self.resizeToContents()", "response": "Process user input when they enter a key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverloading the paint event to support rendering of hints if there are no items in the tree.", "response": "def paintEvent(self, event):\r\n        \"\"\"\r\n        Overloads the paint event to support rendering of hints if there are\r\n        no items in the tree.\r\n        \r\n        :param      event | <QPaintEvent>\r\n        \"\"\"\r\n        super(XTextEdit, self).paintEvent(event)\r\n        \r\n        if self.document().isEmpty() and self.hint():\r\n            text    = self.hint()\r\n            rect    = self.rect()\r\n            \r\n            # modify the padding on the rect\r\n            rect.setX(4)\r\n            rect.setY(4)\r\n            align = int(Qt.AlignLeft | Qt.AlignTop)\r\n            \r\n            # setup the coloring options\r\n            clr = self.hintColor()\r\n            \r\n            # paint the hint\r\n            with XPainter(self.viewport()) as painter:\r\n                painter.setPen(clr)\r\n                painter.drawText(rect, align | Qt.TextWordWrap, text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npaste text from the clipboard into this edit.", "response": "def paste(self):\r\n        \"\"\"\r\n        Pastes text from the clipboard into this edit.\r\n        \"\"\"\r\n        html = QApplication.clipboard().text()\r\n        if not self.isRichTextEditEnabled():\r\n            self.insertPlainText(projex.text.toAscii(html))\r\n        else:\r\n            super(XTextEdit, self).paste()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resizeEvent(self, event):\r\n        super(XTextEdit, self).resizeEvent(event)\r\n        \r\n        if self.autoResizeToContents():\r\n            self.resizeToContents()", "response": "Handles the resize event."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resizeToContents(self):\r\n        doc = self.document()\r\n        h = doc.documentLayout().documentSize().height()\r\n        self.setFixedHeight(h + 4)", "response": "Resizes this widget to fit the contents of its text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setText(self, text):\r\n        super(XTextEdit, self).setText(projex.text.toAscii(text))", "response": "Sets the text for this instance to the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprompt the user for a text entry using the text edit class. Returns the text or plain text if the user is not authorized to edit the entry.", "response": "def getText(cls,\r\n                parent=None,\r\n                windowTitle='Get Text',\r\n                label='',\r\n                text='',\r\n                plain=True,\r\n                wrapped=True):\r\n        \"\"\"\r\n        Prompts the user for a text entry using the text edit class.\r\n        \r\n        :param      parent | <QWidget>\r\n                    windowTitle | <str>\r\n                    label       | <str>\r\n                    text        | <str>\r\n                    plain       | <bool> | return plain text or not\r\n        \r\n        :return     (<str> text, <bool> accepted)\r\n        \"\"\"\r\n        # create the dialog\r\n        dlg = QDialog(parent)\r\n        dlg.setWindowTitle(windowTitle)\r\n        \r\n        # create the layout\r\n        layout = QVBoxLayout()\r\n        \r\n        # create the label\r\n        if label:\r\n            lbl = QLabel(dlg)\r\n            lbl.setText(label)\r\n            layout.addWidget(lbl)\r\n        \r\n        # create the widget\r\n        widget = cls(dlg)\r\n        widget.setText(text)\r\n        \r\n        if not wrapped:\r\n            widget.setLineWrapMode(XTextEdit.NoWrap)\r\n        \r\n        layout.addWidget(widget)\r\n        \r\n        # create the buttons\r\n        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel,\r\n                                Qt.Horizontal,\r\n                                dlg)\r\n        layout.addWidget(btns)\r\n        \r\n        dlg.setLayout(layout)\r\n        dlg.adjustSize()\r\n        \r\n        # create connections\r\n        btns.accepted.connect(dlg.accept)\r\n        btns.rejected.connect(dlg.reject)\r\n        \r\n        if dlg.exec_():\r\n            if plain:\r\n                return (widget.toPlainText(), True)\r\n            else:\r\n                return (widget.toHtml(), True)\r\n        else:\r\n            return ('', False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn whether or not this group box is collapsed.", "response": "def isCollapsed( self ):\r\n        \"\"\"\r\n        Returns whether or not this group box is collapsed.\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        if not self.isCollapsible():\r\n            return False\r\n        \r\n        if self._inverted:\r\n            return self.isChecked()\r\n        return not self.isChecked()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noverload the paint event for this group box if it is currently collpased.", "response": "def paintEvent( self, event ):\r\n        \"\"\"\r\n        Overloads the paint event for this group box if it is currently\r\n        collpased.\r\n        \r\n        :param      event | <QPaintEvent>\r\n        \"\"\"\r\n        if ( self.isCollapsed() ):\r\n            self.setFlat(True)\r\n        \r\n        elif ( self.isCollapsible() ):\r\n            self.setFlat(False)\r\n            \r\n        super(XGroupBox, self).paintEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmatch the collapsed state for this groupbox.", "response": "def matchCollapsedState( self ):\n        \"\"\"\n        Matches the collapsed state for this groupbox.\n        \"\"\"\r\n        collapsed = not self.isChecked()\r\n        if self._inverted:\r\n            collapsed = not collapsed\r\n        \n        if ( not self.isCollapsible() or not collapsed ):\n            for child in self.children():\n                if ( not isinstance(child, QWidget) ):\n                    continue\n                \n                child.show()\n            \n            self.setMaximumHeight(MAX_INT)\n            self.adjustSize()\r\n            \r\n            if ( self.parent() ):\r\n                self.parent().adjustSize()\n        else:\n            self.setMaximumHeight(self.collapsedHeight())\r\n            \n            for child in self.children():\n                if ( not isinstance(child, QWidget) ):\n                    continue\n                \n                child.hide()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setCollapsed( self, state ):\r\n        self.setCollapsible(True)\r\n        if not self._inverted:\r\n            self.setChecked(not state)\r\n        else:\r\n            self.setChecked(state)", "response": "Sets whether or not this group box is collapsed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting whether or not the check state for collapsing is inverted.", "response": "def setInverted(self, state):\r\n        \"\"\"\r\n        Sets whether or not to invert the check state for collapsing.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        collapsed = self.isCollapsed()\r\n        self._inverted = state\r\n        if self.isCollapsible():\r\n            self.setCollapsed(collapsed)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the first ancestor of the inputed QObject based on the given class type.", "response": "def ancestor(qobject, classType):\r\n    \"\"\"\r\n    Looks up the ancestor of the inputed QObject based on the given class type.\r\n    \r\n    :param      qobject   | <QObject>\r\n                classType | <subclass of QObject> || <str>\r\n    \r\n    :return     <subclass of QObject> || None\r\n    \"\"\"\r\n    parent = qobject\r\n    is_class = True\r\n    while parent:\r\n        if type(parent).__name__ == classType:\r\n            return parent\r\n        \r\n        if is_class:\r\n            try:\r\n                if isinstance(parent, classType):\r\n                    return parent\r\n            except TypeError:\r\n                is_class = False\r\n        \r\n        parent = parent.parent()\r\n    \r\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a new resource file based on the given path.", "response": "def buildResourceFile(rscpath, outpath=''):\r\n    \"\"\"\r\n    Generates a Qt resource module based on the given source path.  This will\r\n    take all the files and folders within the source and generate a new XML\r\n    representation of that path.  An optional outpath can be provided as the\r\n    generated resource path, by default it will be called the name of the\r\n    source path.\r\n    \r\n    :param      rscpath | <str>\r\n                buildpath | <str>\r\n    \"\"\"\r\n    import xqt\r\n    wrapper = QT_WRAPPER.lower()\r\n    if not outpath:\r\n        name = os.path.basename(rscpath).split('.')[0]\r\n        filename = '{0}_{1}_rc.py'.format(wrapper, name)\r\n        outpath = os.path.join(os.path.dirname(rscpath), filename)\r\n    elif os.path.isdir(outpath):\r\n        name = os.path.basename(rscpath).split('.')[0]\r\n        filename = '{0}_{1}_rc.py'.format(wrapper, name)\r\n        outpath = os.path.join(outpath, filename)\r\n    \r\n    # try to use Qt first, because it is so much better\r\n    PYQT_RCC_EXE = os.environ.get('PYQT_RCC_EXE', 'pyrcc4')\r\n    try:\r\n        subprocess.call([PYQT_RCC_EXE, '-o', outpath, rscpath])\r\n        used_pyqt = True\r\n    except StandardError:\r\n        used_pyqt = False\r\n\r\n    if not used_pyqt:\r\n        # make sure it is not outdated\r\n        try:\r\n            subprocess.call([xqt.rcc_exe, '-o', outpath, rscpath])\r\n        except StandardError:\r\n            exe = xqt.rcc_exe\r\n            msg = 'You need to add the path to {0} to your system Path.'\r\n            logger.error(msg.format(exe))\r\n            return False\r\n    \r\n    # make sure we actually generated a file\r\n    if not os.path.exists(outpath):\r\n        logger.error('Failed to generate output file: {0}'.format(outpath))\r\n        return False\r\n    \r\n    # map the output back to PySide if necessary\r\n    if QT_WRAPPER == 'PySide' and used_pyqt:\r\n        # clean up resource file\r\n        with open(outpath, 'r') as f:\r\n            data = f.read()\r\n        \r\n        data = data.replace('PyQt4', 'xqt')\r\n        \r\n        with open(outpath, 'w') as f:\r\n            f.write(data)\r\n    \r\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the UI classes for all the items in srcpath.", "response": "def generateUiClasses(srcpath):\r\n    \"\"\"\r\n    Generates the UI classes using the compilation system for Qt.\r\n    \r\n    :param      srcpath | <str>\r\n    \"\"\"\r\n    import_qt(globals())\r\n    \r\n    for root, folders, files in os.walk(srcpath):\r\n        found = False\r\n        for file in files:\r\n            name, ext = os.path.splitext(file)\r\n            if ext != '.ui':\r\n                continue\r\n            \r\n            found = True\r\n            \r\n            wrapper = QT_WRAPPER.lower()\r\n            basename = file.replace('.ui', '').replace('.', '_')\r\n            filename = '{0}_{1}_ui.py'.format(basename, wrapper)\r\n            \r\n            outfile = os.path.join(root, filename)\r\n            \r\n            # compile the ui\r\n            f = open(outfile, 'w')\r\n            uic.compileUi(os.path.join(root, file), f)\r\n            f.close()\r\n            \r\n            # cleanup import content\r\n            f = open(outfile, 'r')\r\n            data = f.read()\r\n            f.close()\r\n            \r\n            data = re.sub('import .*_rc', '', data)\r\n            \r\n            # save back out the content\r\n            f = open(outfile, 'w')\r\n            f.write(data)\r\n            f.close()\r\n        \r\n        if found and not '__init__.py' in files:\r\n            f = open(os.path.join(root, '__init__.py'), 'w')\r\n            f.write('# auto created for UI import')\r\n            f.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generateResourceFile(srcpath, outpath='', buildpath='', build=True):\r\n    if not outpath:\r\n        outpath = os.path.join(os.path.dirname(srcpath), \r\n                               os.path.basename(srcpath) + '.qrc')\r\n        relpath = './%s' % os.path.basename(srcpath)\r\n    else:\r\n        relpath = os.path.relpath(srcpath, os.path.dirname(outpath))\r\n    \r\n    xml = ElementTree.Element('RCC')\r\n    xml.set('header', 'projexui.resources')\r\n    \r\n    srcpath = nativestring(srcpath)\r\n    srcpath = os.path.normpath(srcpath)\r\n    root_prefix = os.path.basename(srcpath) + '/'\r\n    count = len(srcpath)\r\n    \r\n    for root, folders, files in os.walk(srcpath):\r\n        if not files:\r\n            continue\r\n        \r\n        relpath = os.path.relpath(root, os.path.dirname(outpath))\r\n        prefix = (root_prefix + root[count+1:].replace('\\\\', '/')).strip('/')\r\n        \r\n        xresource = ElementTree.SubElement(xml, 'qresource')\r\n        xresource.set('prefix', prefix)\r\n        \r\n        for file in files:\r\n            xfile = ElementTree.SubElement(xresource, 'file')\r\n            xfile.set('alias', file)\r\n            xfile.text = os.path.join(relpath, file).replace('\\\\', '/')\r\n    \r\n    projex.text.xmlindent(xml)\r\n    xml_str = ElementTree.tostring(xml)\r\n    \r\n    # save the exported information\r\n    with open(outpath, 'w') as f:\r\n        f.write(xml_str)\r\n\r\n    if build:\r\n        buildResourceFile(outpath, buildpath)", "response": "This method generates a Qt resource file based on the given source path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generateResourceFiles(srcpath, outpath='', buildpath='', build=True):\r\n    for filename in os.listdir(srcpath):\r\n        rscpath = os.path.join(srcpath, filename)\r\n        if os.path.isdir(rscpath):\r\n            generateResourceFile(rscpath, outpath, buildpath, build)", "response": "Generates a Qt resource file based on the given source path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new pixmap based on the inputed base64 data.", "response": "def generatePixmap(base64_data):\r\n    \"\"\"\r\n    Generates a new pixmap based on the inputed base64 data.\r\n    \r\n    :param      base64 | <str>\r\n    \"\"\"\r\n    import_qt(globals())\r\n    \r\n    binary_data = binascii.a2b_base64(base64_data)\r\n    arr = QtCore.QByteArray.fromRawData(binary_data)\r\n    img = QtGui.QImage.fromData(arr)\r\n    return QtGui.QPixmap(img)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findUiActions( widget ):\r\n    import_qt(globals())\r\n    \r\n    output = []\r\n    for action in widget.findChildren(QtGui.QAction):\r\n        name = nativestring(action.objectName()).lower()\r\n        if ( name.startswith('ui') and name.endswith('act') ):\r\n            output.append(action)\r\n    return output", "response": "Returns a list of all actions that are in the UI."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the drop event into a list of text.", "response": "def formatDropEvent(event):\r\n    \"\"\"\r\n    Formats information from the drop event.\r\n    \r\n    :param      event | <QtGui.QDropEvent>\r\n    \"\"\"\r\n    text = []\r\n    \r\n    text.append('#------------------------------------------------------')\r\n    text.append('#                      Drop Data                     ')\r\n    text.append('#------------------------------------------------------')\r\n    \r\n    text.append('\\taction: {0}'.format(event.dropAction()))\r\n    text.append('\\tmodifiers: {0}'.format(event.keyboardModifiers()))\r\n    text.append('\\tbuttons: {0}'.format(event.mouseButtons()))\r\n    text.append('\\tpos: {0}'.format(event.pos()))\r\n    text.append('\\tpossibleActions: {0}'.format(event.possibleActions()))\r\n    text.append('\\tproposedAction: {0}'.format(event.proposedAction()))\r\n    text.append('\\tsource: {0}'.format(event.source()))\r\n    \r\n    text.append('#------------------------------------------------------')\r\n    text.append('#                      Mime Data                     ')\r\n    text.append('#------------------------------------------------------')\r\n    \r\n    data = event.mimeData()\r\n    text.append('\\tcolorData: {0}'.format(data.colorData()))\r\n    text.append('\\thasImage: {0}'.format(data.hasImage()))\r\n    text.append('\\thasHtml: {0}'.format(data.hasHtml()))\r\n    text.append('\\ttext: {0}'.format(data.text()))\r\n    text.append('\\turls: {0}'.format(data.urls()))\r\n    \r\n    text.append('#------------------------------------------------------')\r\n    text.append('#                      Custom Data                     ')\r\n    text.append('#------------------------------------------------------')\r\n    \r\n    for format in data.formats():\r\n        try:\r\n            text.append('\\t{0}: {1}'.format(format, data.data(format)))\r\n        except:\r\n            text.append('\\t{0}: !!unable to format!!'.format(format))\r\n    \r\n    return '\\n'.join(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef localizeShortcuts(widget):\r\n    import_qt(globals())\r\n    \r\n    for action in widget.findChildren(QtGui.QAction):\r\n        action.setShortcutContext(QtCore.Qt.WidgetWithChildrenShortcut)", "response": "Localizes all action shortcuts for the given widget to us the same context as the given widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loadUi(modulefile, inst, uifile=None, theme='default', className=None):\r\n    if className is None:\r\n        className = inst.__class__.__name__\r\n\r\n    import_qt(globals())\r\n    \r\n    currpath = QtCore.QDir.currentPath()\r\n    \r\n    # use compiled information vs. dynamic generation\r\n    widget = None\r\n    if USE_COMPILED:\r\n        # find the root module\r\n        def find_root_module(cls, name):\r\n            if cls.__name__ == name:\r\n                return cls.__module__.rpartition('.')[0]\r\n            else:\r\n                for base in cls.__bases__:\r\n                    if not issubclass(base, QtGui.QWidget):\r\n                        continue\r\n\r\n                    out = find_root_module(base, name)\r\n                    if out:\r\n                        return out\r\n\r\n        wrapper = QT_WRAPPER.lower()\r\n        root_module = find_root_module(inst.__class__, className)\r\n        if not root_module:\r\n            root_module = inst.__module__.rpartition('.')[0]\r\n        basename = className.lower()\r\n        \r\n        modname_a = '{0}.ui.{1}_{2}_{3}_ui'.format(root_module, basename, theme, wrapper)\r\n        modname_b = '{0}.ui.{1}_{2}_ui'.format(root_module, basename, wrapper)\r\n        modname_c = '{0}.ui.{1}_{2}_ui'.format(root_module, basename, theme)\r\n        modname_d = '{0}.ui.{1}_ui'.format(root_module, basename)\r\n        \r\n        module = None\r\n        for modname in (modname_a, modname_b, modname_c, modname_d):\r\n            modname = modname.strip('.')\r\n            logger.debug('Loading module: {0}...'.format(modname))\r\n            try:\r\n                __import__(modname)\r\n                module = sys.modules[modname]\r\n                break\r\n            except StandardError:\r\n                pass\r\n        \r\n        # successfully loaded a module\r\n        if module:\r\n            # load the module information\r\n            cls = getattr(module, 'Ui_%s' % className, None)\r\n            if not cls:\r\n                for key in module.__dict__.keys():\r\n                    if key.startswith('Ui_'):\r\n                        cls = getattr(module, key)\r\n                        break\r\n            \r\n            # generate the class information\r\n            if cls:\r\n                widget = cls()\r\n                widget.setupUi(inst)\r\n                inst.__dict__.update(widget.__dict__)\r\n    \r\n    if not widget:\r\n        if not uifile:\r\n            uifile = uiFile(modulefile, inst, theme, className=className)\r\n        \r\n        # normalize the path\r\n        uifile = os.path.normpath(uifile)\r\n        if os.path.exists(uifile):\r\n            QtCore.QDir.setCurrent(os.path.dirname(uifile))\r\n            widget = uic.loadUi(uifile, inst)\r\n            QtCore.QDir.setCurrent(currpath)\r\n    \r\n    inst.addActions(findUiActions(inst))\r\n    \r\n    return widget", "response": "Load the ui file based on the module file location and the class name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the startup data for the given main window.", "response": "def exec_( window, data ):\r\n    \"\"\"\r\n    Executes the startup data for the given main window.  This method needs to \r\n    be called in conjunction with the setup method.\r\n    \r\n    :sa     setup\r\n    \r\n    :param      window  | <QWidget>\r\n                data    | { <str> key: <variant> value, .. }\r\n    \r\n    :return     <int> err\r\n    \"\"\"\r\n    import_qt(globals())\r\n    \r\n    if 'splash' in data:\r\n        data['splash'].finish(window)\r\n    \r\n    if not window.parent():\r\n        window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\r\n    \r\n    if 'app' in data:\r\n        # setup application information\r\n        data['app'].setPalette(window.palette())\r\n        data['app'].setWindowIcon(window.windowIcon())\r\n        \r\n        # create the tray menu\r\n        if not window.windowIcon().isNull():\r\n            menu   = QtGui.QMenu(window)\r\n            action = menu.addAction('Quit')\r\n            action.triggered.connect( window.close )\r\n            \r\n            # create the tray icon\r\n            tray_icon = QtGui.QSystemTrayIcon(window)\r\n            tray_icon.setObjectName('trayIcon')\r\n            tray_icon.setIcon(window.windowIcon())\r\n            tray_icon.setContextMenu(menu)\r\n            tray_icon.setToolTip(data['app'].applicationName())\r\n            tray_icon.show()\r\n            window.destroyed.connect(tray_icon.deleteLater)\r\n        \r\n        return data['app'].exec_()\r\n    \r\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new application with the given parameters.", "response": "def setup(applicationName,\r\n          applicationType=None,\r\n          style='plastique',\r\n          splash='',\r\n          splashType=None,\r\n          splashTextColor='white',\r\n          splashTextAlign=None,\r\n          theme=''):\r\n    \"\"\"\r\n    Wrapper system for the QApplication creation process to handle all proper\r\n    pre-application setup.  This method will verify that there is no application\r\n    running, creating one if necessary.  If no application is created, a None\r\n    value is returned - signaling that there is already an app running.  If you\r\n    need to specify your own QApplication subclass, you can do so through the \r\n    applicationType parameter.\r\n    \r\n    :note       This method should always be used with the exec_ method to \r\n                handle the post setup process.\r\n    \r\n    :param      applicationName | <str>\r\n                applicationType | <subclass of QApplication> || None\r\n                style    | <str> || <QStyle> | style to use for the new app\r\n                splash   | <str> | filepath to use for a splash screen\r\n                splashType   | <subclass of QSplashScreen> || None\r\n                splashTextColor   | <str> || <QColor>\r\n                splashTextAlign   | <Qt.Alignment>\r\n    \r\n    :usage      |import projexui\r\n                |\r\n                |def main(argv):\r\n                |   # initialize the application\r\n                |   data = projexui.setup()\r\n                |   \r\n                |   # do some initialization code\r\n                |   window = MyWindow()\r\n                |   window.show()\r\n                |   \r\n                |   # execute the application\r\n                |   projexui.exec_(window, data)\r\n    \r\n    :return     { <str> key: <variant> value, .. }\r\n    \"\"\"\r\n    import_qt(globals())\r\n    \r\n    output = {}\r\n    \r\n    # check to see if there is a qapplication running\r\n    if not QtGui.QApplication.instance():\r\n        # make sure we have a valid QApplication type\r\n        if applicationType is None:\r\n            applicationType = QtGui.QApplication\r\n        \r\n        app = applicationType([applicationName])\r\n        app.setApplicationName(applicationName)\r\n        app.setQuitOnLastWindowClosed(True)\r\n        \r\n        stylize(app, style=style, theme=theme)\r\n        \r\n        # utilized with the projexui.config.xschemeconfig\r\n        app.setProperty('useScheme', wrapVariant(True))\r\n        output['app'] = app\r\n    \r\n    # create a new splash screen if desired\r\n    if splash:\r\n        if not splashType:\r\n            splashType = XLoggerSplashScreen\r\n        \r\n        pixmap = QtGui.QPixmap(splash)\r\n        screen = splashType(pixmap)\r\n        \r\n        if splashTextAlign is None:\r\n            splashTextAlign = QtCore.Qt.AlignLeft | QtCore.Qt.AlignBottom\r\n        \r\n        screen.setTextColor(QtGui.QColor(splashTextColor))\r\n        screen.setTextAlignment(splashTextAlign)\r\n        screen.show()\r\n        \r\n        QtGui.QApplication.instance().processEvents()\r\n        \r\n        output['splash'] = screen\r\n    \r\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stylize(obj, style='plastique', theme='projexui'):\r\n    obj.setStyle(style)\r\n    if theme:\r\n        sheet = resources.read('styles/{0}/style.css'.format(theme))\r\n        if sheet:\r\n            obj.setStyleSheet(sheet)", "response": "Stylizes the inputed object with the given options."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the very top window for all Qt purposes.", "response": "def topWindow():\r\n    \"\"\"\r\n    Returns the very top window for all Qt purposes.\r\n    \r\n    :return     <QWidget> || None\r\n    \"\"\"\r\n    import_qt(globals())\r\n    \r\n    window = QtGui.QApplication.instance().activeWindow()\r\n    if not window:\r\n        return None\r\n    \r\n    parent = window.parent()\r\n    \r\n    while parent:\r\n        window = parent\r\n        parent = window.parent()\r\n        \r\n    return window"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uiFile(modulefile, inst, theme='', className=None):\r\n    if className is None:\r\n        className = inst.__class__.__name__\r\n\r\n    # use a module's name vs. filepath\r\n    if modulefile in sys.modules:\r\n        modulefile = sys.modules[modulefile].__file__\r\n    \r\n    clsname  = className.lower()\r\n    basepath = os.path.dirname(nativestring(modulefile))\r\n    \r\n    if theme:\r\n        theme_name = '{0}.{1}.ui'.format(clsname, theme)\r\n        theme_file = os.path.join(basepath, 'ui', theme_name)\r\n        theme_file = re.sub('[\\w\\.]+\\?\\d+', '', theme_file)\r\n        \r\n        if os.path.exists(theme_file):\r\n            return theme_file\r\n    \r\n    base_name = '{0}.ui'.format(clsname)\r\n    base_file = os.path.join(basepath, 'ui', base_name)\r\n    base_file = re.sub('[\\w\\.]+\\?\\d+', '', base_file)\r\n    \r\n    return base_file", "response": "Returns the ui file for the given modulefile and inst."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_value(value, flags=None, base64=False):\n    if flags:\n        # still a no-operation\n        logger.debug(\"Flag %s encoding not implemented yet\" % flags)\n    if not isinstance(value, bytes):\n        raise ValueError(\"value must be bytes\")\n    return b64encode(value) if base64 else value", "response": "Encode a value for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef drawForeground(self, painter, rect, showGrid, showColumns, showRows):\r\n        painter.save()\r\n        center = self.buildData('center')\r\n        radius = self.buildData('radius') / 2.0\r\n        palette = QtGui.QApplication.palette()\r\n        pen = QtGui.QPen(palette.color(palette.Text))\r\n        pen.setWidthF(0.75)\r\n        painter.setBrush(palette.color(palette.Base))\r\n        painter.setPen(pen)\r\n        painter.setRenderHint(painter.Antialiasing)\r\n        painter.drawEllipse(center, radius, radius)\r\n        painter.restore()", "response": "Draws the foreground of the current time - item."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclears out the widgets from this stack.", "response": "def clear(self):\r\n        \"\"\"\r\n        Clears out the widgets from this stack.\r\n        \"\"\"\r\n        for i in range(self.count() - 1, -1, -1):\r\n            w = self.widget(i)\r\n            if w:\r\n                self.removeWidget(w)\r\n                w.close()\r\n                w.deleteLater()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef slideIn(self, index, direction=Direction.Automatic):\r\n        # do not allow multiple slides while it is active\r\n        if self._active:\r\n            return False\r\n        \r\n        # determine the proper index to calculate\r\n        invert = False\r\n        if self.count() <= index:\r\n            if not self.wrap():\r\n                return False\r\n            index = self.count() % index\r\n            invert = True\r\n        elif index < 0:\r\n            if not self.wrap():\r\n                return False\r\n            index = self.count() + index\r\n            invert = True\r\n        \r\n        # define the direction information\r\n        if index == self.currentIndex():\r\n            return False\r\n        elif self.currentIndex() < index:\r\n            if direction == XStackedWidget.Direction.Automatic:\r\n                if self.isVerticalMode():\r\n                    direction = XStackedWidget.Direction.BottomToTop\r\n                else:\r\n                    direction = XStackedWidget.Direction.RightToLeft\r\n        else:\r\n            if direction == XStackedWidget.Direction.Automatic:\r\n                if self.isVerticalMode():\r\n                    direction = XStackedWidget.Direction.TopToBottom\r\n                else:\r\n                    direction = XStackedWidget.Direction.LeftToRight\r\n        \r\n        # invert the animation if we are wrapping\r\n        if invert:\r\n            if direction == XStackedWidget.Direction.BottomToTop:\r\n                direction = XStackedWidget.Direction.TopToBottom\r\n            elif direction == XStackedWidget.Direction.TopToBottom:\r\n                direction = XStackedWidget.Direction.BottomToTop\r\n            elif direction == XStackedWidget.Direction.LeftToRight:\r\n                direction = XStackedWidget.Direction.RightToLeft\r\n            else:\r\n                direction = XStackedWidget.Direction.LeftToRight\r\n        \r\n        self._active = True\r\n        offset_x = self.frameRect().width()\r\n        offset_y = self.frameRect().height()\r\n        \r\n        next_widget = self.widget(index)\r\n        curr_widget = self.widget(self.currentIndex())\r\n        \r\n        next_widget.setGeometry(0, 0, offset_x, offset_y)\r\n        \r\n        if direction == XStackedWidget.Direction.BottomToTop:\r\n            offset_x = 0\r\n            offset_y = -offset_y\r\n        elif direction == XStackedWidget.Direction.TopToBottom:\r\n            offset_x = 0\r\n        elif direction == XStackedWidget.Direction.RightToLeft:\r\n            offset_x = -offset_x\r\n            offset_y = 0\r\n        elif direction == XStackedWidget.Direction.LeftToRight:\r\n            offset_y = 0\r\n        \r\n        next_point = next_widget.pos()\r\n        curr_point = curr_widget.pos()\r\n        \r\n        self._nextIndex = index\r\n        self._lastIndex = self.currentIndex()\r\n        self._lastPoint = QPoint(curr_point)\r\n        \r\n        next_widget.move(next_point.x()-offset_x, next_point.y()-offset_y)\r\n        next_widget.raise_()\r\n        next_widget.show()\r\n        \r\n        curr_anim = QPropertyAnimation(curr_widget, 'pos')\r\n        curr_anim.setDuration(self.speed())\r\n        curr_anim.setEasingCurve(self.animationType())\r\n        curr_anim.setStartValue(curr_point)\r\n        curr_anim.setEndValue(QPoint(curr_point.x()+offset_x,\r\n                                     curr_point.y()+offset_y))\r\n        \r\n        next_anim = QPropertyAnimation(next_widget, 'pos')\r\n        next_anim.setDuration(self.speed())\r\n        next_anim.setEasingCurve(self.animationType())\r\n        next_anim.setStartValue(QPoint(next_point.x()-offset_x,\r\n                                       next_point.y()-offset_y))\r\n        next_anim.setEndValue(next_point)\r\n        \r\n        anim_group = QParallelAnimationGroup(self)\r\n        anim_group.addAnimation(curr_anim)\r\n        anim_group.addAnimation(next_anim)\r\n        \r\n        anim_group.finished.connect(self._finishAnimation)\r\n        anim_group.finished.connect(anim_group.deleteLater)\r\n        anim_group.start()\r\n        \r\n        return True", "response": "Returns a new list of items in the panel at the given index in the given direction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list(conf):\n    try:\n        config = init_config(conf)\n        conn = get_conn(config.get('DEFAULT','statusdb'))\n        cur = conn.cursor()\n        sqlstr = '''select * from client_status order by ctime desc '''\n        cur.execute(sqlstr)\n        result = cur.fetchall()\n        conn.commit()\n        conn.close()\n        for r in result:\n            print r\n    except Exception, e:\n        traceback.print_exc()", "response": "List all OpenVPN status items"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cli(conf):\n    try:\n        config = init_config(conf)\n        debug = config.getboolean('DEFAULT', 'debug')\n        conn = get_conn(config.get('DEFAULT','statusdb'))\n        cur = conn.cursor()\n        sqlstr = '''create table client_status\n        (session_id text PRIMARY KEY, username text, userip text, \n            realip text, realport int,ctime int,\n            inbytes int, outbytes int, \n            acct_interval int, session_timeout int, uptime int)\n        '''\n        try:\n            cur.execute('drop table client_status')\n        except:\n            pass\n        cur.execute(sqlstr)\n        print 'flush client status database'\n        conn.commit()\n        conn.close()\n    except:\n        traceback.print_exc()", "response": "OpenVPN status initdb method"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef browserWidget( self ):\r\n        from projexui.widgets.xorbbrowserwidget import XOrbBrowserWidget\r\n        return projexui.ancestor(self, XOrbBrowserWidget)", "response": "Returns the browser widget this card is linked to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setRecord( self, record ):\r\n        super(XBasicCardWidget, self).setRecord(record)\r\n        \r\n        browser = self.browserWidget()\r\n        if ( not browser ):\r\n            return\r\n        \r\n        factory = browser.factory()\r\n        if ( not factory ):\r\n            return\r\n        \r\n        self._thumbnailButton.setIcon(factory.thumbnail(record))\r\n        self._titleLabel.setText(factory.thumbnailText(record))", "response": "Sets the record that is linked with this widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createEditor(self, parent, column, op, value):\r\n        try:\r\n            cls = self._operatorMap[nativestring(op)].cls\r\n        except KeyError, AttributeError:\r\n            return None\r\n        \r\n        # create the new editor\r\n        if cls:\r\n            widget = cls(parent)\r\n            widget.setAttribute(Qt.WA_DeleteOnClose)\r\n            projexui.setWidgetValue(widget, value)\r\n            return widget\r\n        \r\n        return None", "response": "Creates a new editor for the given parent based on the plugin parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the value of the given editor for this widget.", "response": "def editorValue(self, editor):\r\n        \"\"\"\r\n        Returns the value from the editor for this widget.\r\n        \r\n        :param      editor | <QWidget> || None\r\n        \r\n        :return     <variant> value\r\n        \"\"\"\r\n        value, success = projexui.widgetValue(editor)\r\n        if not success:\r\n            return None\r\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the name of the first available operator that best matches the type and value.", "response": "def operator(self, operatorType, value):\r\n        \"\"\"\r\n        Returns the operator that best matches the type and value.\r\n        \r\n        :param      operatorType | <Query.Op>\r\n                    value        | <variant>\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        if value is None:\r\n            if 'is none' in self._operatorMap and operatorType == Query.Op.Is:\r\n                return 'is none'\r\n            elif 'is not none' in self._operatorMap:\r\n                return 'is not none'\r\n            \r\n        for op, data in self._operatorMap.items():\r\n            if data.op == operatorType:\r\n                return op\r\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef operators(self, ignore=0):\r\n        return [k for k, v in self._operatorMap.items() if not v.flags & ignore]", "response": "Returns a list of operators for this plugin."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters an editor for the given operator as the given name.", "response": "def registerEditor(self,\r\n                       name,\r\n                       op,\r\n                       cls=None,\r\n                       defaultValue=None,\r\n                       flags=0):\r\n        \"\"\"\r\n        Registers an editor for the given operator as the given name.  If no\r\n        editor class is supplied, no editor widget will be created for the\r\n        operator unless you overload the createEditor method and create your own\r\n        \r\n        :param      name         | <str>\r\n                    op           | <Query.Op>\r\n                    cls          | <subclass of QWidget> || None\r\n                    defaultValue | <variant>\r\n        \"\"\"\r\n        registry = XEditorRegistry(op=op,\r\n                                   cls=cls,\r\n                                   defaultValue=defaultValue,\r\n                                   flags=flags)\r\n        \r\n        self._operatorMap[nativestring(name)] = registry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting up the query object according to the operator type and value.", "response": "def setupQuery(self, query, op, editor):\r\n        \"\"\"\r\n        Returns the value from the editor.\r\n        \r\n        :param      op       | <str>\r\n                    editor   | <QWidget> || None\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        try:\r\n            registry = self._operatorMap[nativestring(op)]\r\n        except KeyError:\r\n            return False\r\n        \r\n        op = registry.op\r\n        value = registry.defaultValue\r\n        \r\n        if op is None:\r\n            return False\r\n        \r\n        if editor is not None:\r\n            value = self.editorValue(editor)\r\n        \r\n        query.setOperatorType(op)\r\n        query.setValue(value)\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plugin(self, column):\r\n        base = ColumnType.base(column.columnType())\r\n        \r\n        a = (column.columnType(), column.name())\r\n        b = (column.columnType(), None)\r\n        c = (base, column.name())\r\n        d = (base, None)\r\n        e = (None, column.name())\r\n        f = (None, None)\r\n        \r\n        for check in (a, b, c, d, e, f):\r\n            try:\r\n                return self._plugins[check]\r\n            except KeyError:\r\n                continue\r\n        \r\n        return None", "response": "Returns the first plugin that matches the given column."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a new plugin to handle particular column types and column names based on user selection.", "response": "def register(self, plugin, columnType=None, columnName=None):\r\n        \"\"\"\r\n        Registers a plugin to handle particular column types and column names\r\n        based on user selection.\r\n        \r\n        :param      plugin     | <XOrbQueryPlugin>\r\n                    columnType | <orb.ColumnType> || None\r\n                    columnName | <str> || None\r\n        \"\"\"\r\n        self._plugins[(columnType, columnName)] = plugin"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def register(self, service):\n        response = await self._api.put(\"/v1/agent/service/register\",\n                                       data=service)\n        return response.status == 200", "response": "Registers a new local service with the local agent."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def disable(self, service, *, reason=None):\n        return await self.maintenance(service, False, reason=reason)", "response": "Enables maintenance mode for a given service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def enable(self, service, *, reason=None):\n        return await self.maintenance(service, False, reason=reason)", "response": "Resumes normal operation for the specified service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nentering or resumes maintenance mode for a specific service.", "response": "async def maintenance(self, service, enable, *, reason=None):\n        \"\"\"Enters maintenance mode / Resumes normal operation for service\n\n        Parameters:\n            service (ObjectID): Service ID\n            enable (bool): Enter or exit maintenance mode\n            reason (str): Text string explaining the reason for placing the\n                          service into normal mode.\n        Returns:\n            bool: ``True`` on success\n        \"\"\"\n        service_id = extract_attr(service, keys=[\"ServiceID\", \"ID\"])\n        response = await self._api.put(\n            \"/v1/agent/service/maintenance\", service_id,\n            params={\"enable\": enable, \"reason\": reason})\n        return response.status == 200"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mppe_chap2_gen_keys(password, nt_response):\n    password_hash = mschap.nt_password_hash(password)\n    password_hash_hash = mschap.hash_nt_password_hash(password_hash)\n    master_key = get_master_key(password_hash_hash, nt_response)\n    master_send_key = get_asymetric_start_key(master_key, 16, True, True)\n    master_recv_key = get_asymetric_start_key(master_key, 16, False, True)\n    return master_send_key, master_recv_key", "response": "This function generates 128 - bit session keys for the given NT - Response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef radius_encrypt_keys(plain_text, secret, request_authenticator, salt):\n    i = len(plain_text) / 16\n    b = hashlib.new(\"md5\", secret + request_authenticator + salt).digest()\n    c = xor(plain_text[:16], b)\n    result = c\n    for x in range(1, i):\n        b = hashlib.new(\"md5\", secret + c).digest()\n        c = xor(plain_text[x * 16:(x + 1) * 16], b)\n        result += c\n    return result", "response": "This function is used to encrypt a string field with a shared secret request_authenticator and salt."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, sql, args=None):\n        con = self.pool.pop()\n        c = None\n        try:\n            c = con.cursor()\n            LOGGER.debug(\"Execute sql: \" + sql + \" args:\" + str(args))\n            if type(args) is tuple:\n                c.execute(sql, args)\n            elif type(args) is list:\n                if len(args) > 1 and type(args[0]) in (list, tuple):\n                    c.executemany(sql, args)\n                else:\n                    c.execute(sql, args)\n            elif args is None:\n                c.execute(sql)\n            if sql.lstrip()[:6].upper() == 'INSERT':\n                return c.lastrowid\n            return c.rowcount\n        except Exception as e:\n            LOGGER.error(\"Error Execute on %s\", str(e))\n            raise DBError(str(e))\n        finally:\n            c and c.close()\n            con and self.pool.push(con)", "response": "This function is used for update delete records. It is used for update delete records."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connection_class(self, adapter):\n        if self.adapters.get(adapter):\n            return self.adapters[adapter]\n        try:\n            class_prefix = getattr(\n                __import__('db.' + adapter, globals(), locals(),\n                           ['__class_prefix__']), '__class_prefix__')\n            driver = self._import_class('db.' + adapter + '.connection.' +\n                                        class_prefix + 'Connection')\n        except ImportError:\n            raise DBError(\"Must install adapter `%s` or doesn't support\" %\n                          (adapter))\n\n        self.adapters[adapter] = driver\n        return driver", "response": "Get connection class by adapter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dialect_class(self, adapter):\n        if self.dialects.get(adapter):\n            return self.dialects[adapter]\n        try:\n            class_prefix = getattr(\n                __import__('db.' + adapter, globals(), locals(),\n                           ['__class_prefix__']), '__class_prefix__')\n            driver = self._import_class('db.' + adapter + '.dialect.' +\n                                        class_prefix + 'Dialect')\n        except ImportError:\n            raise DBError(\"Must install adapter `%s` or doesn't support\" %\n                          (adapter))\n\n        self.dialects[adapter] = driver\n        return driver", "response": "Get dialect sql class by adapter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimporting class by module dot split string", "response": "def _import_class(self, module2cls):\n        \"\"\"Import class by module dot split string\"\"\"\n        d = module2cls.rfind(\".\")\n        classname = module2cls[d + 1: len(module2cls)]\n        m = __import__(module2cls[0:d], globals(), locals(), [classname])\n        return getattr(m, classname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes sql with args", "response": "def execute(self, sql, args):\n        \"\"\"Execute sql\n\n        :param sql string: the sql stamtement like 'select * from %s'\n        :param args  list: Wen set None, will use dbi execute(sql), else\n            db execute(sql, args), the args keep the original rules, it shuld be tuple or list of list\n        \"\"\"\n        c = None\n        try:\n            c = self._con.cursor()\n            LOGGER.debug(\"execute sql: \" + sql + \" args:\" + str(args))\n            if type(args) is tuple:\n                c.execute(sql, args)\n            elif type(args) is list:\n                if len(args) > 1 and type(args[0]) in (list, tuple):\n                    c.executemany(sql, args)\n                else:\n                    c.execute(sql, args)\n            elif args is None:\n                c.execute(sql)\n            if sql.lstrip()[:6].upper() == 'INSERT':\n                return c.lastrowid\n            return c.rowcount\n        finally:\n            c and c.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npainting this item. :param painter | <QPainter> option | <QGraphicsOption> widget | <QWidget>", "response": "def paint( self, painter, option, widget ):\r\n        \"\"\"\r\n        Paints this item.\r\n        \r\n        :param      painter | <QPainter>\r\n                    option  | <QGraphicsOption>\r\n                    widget  | <QWidget>\r\n        \"\"\"\r\n        painter.save()\r\n        pen = QPen(self.color())\r\n        pen.setWidth(2)\r\n        painter.setPen(pen)\r\n        painter.drawPath(self._basePath)\r\n        painter.setRenderHint(painter.Antialiasing)\r\n        \r\n        \r\n        pen.setColor(QColor('white'))\r\n        painter.setPen(pen)\r\n        painter.setBrush(self.color())\r\n        for ellipse in self._ellipses:\r\n            painter.drawEllipse(ellipse, 6, 6)\r\n        \r\n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rebuild( self, gridRect ):\r\n        scene = self.scene()\r\n        if ( not scene ):\r\n            return\r\n        \r\n        self.setVisible(gridRect.contains(self.pos()))\r\n        self.setZValue(100)\r\n        \r\n        path = QPainterPath()\r\n        path.moveTo(0, 0)\r\n        path.lineTo(0, gridRect.height())\r\n        \r\n        tip             = ''\r\n        tip_point       = None\r\n        self._ellipses  = []\r\n        items           = scene.collidingItems(self)\r\n        self._basePath  = QPainterPath(path)\r\n        \r\n        for item in items:\r\n            item_path = item.path()\r\n            found = None\r\n            for y in range(int(gridRect.top()), int(gridRect.bottom())):\r\n                point = QPointF(self.pos().x(), y)\r\n                if ( item_path.contains(point) ):\r\n                    found = QPointF(0, y - self.pos().y())\r\n                    break\r\n            \r\n            if ( found ):\r\n                path.addEllipse(found, 6, 6)\r\n                self._ellipses.append(found)\r\n                \r\n                # update the value information\r\n                value     = scene.valueAt(self.mapToScene(found))\r\n                tip_point = self.mapToScene(found)\r\n                hruler    = scene.horizontalRuler()\r\n                vruler    = scene.verticalRuler()\r\n                \r\n                x_value = hruler.formatValue(value[0])\r\n                y_value = vruler.formatValue(value[1])\r\n                \r\n                tip = '<b>x:</b> %s<br/><b>y:</b> %s' % (x_value, y_value)\r\n        \r\n        self.setPath(path)\r\n        self.setVisible(True)\r\n        \r\n        # show the popup widget\r\n        if ( tip ):\r\n            anchor    = XPopupWidget.Anchor.RightCenter\r\n            widget    = self.scene().chartWidget()\r\n            tip_point = widget.mapToGlobal(widget.mapFromScene(tip_point))\r\n            \r\n            XPopupWidget.showToolTip(tip, \r\n                                     anchor = anchor,\r\n                                     parent = widget,\r\n                                     point  = tip_point,\r\n                                     foreground = QColor('blue'),\r\n                                     background = QColor(148, 148, 255))", "response": "Rebuilds the tracker item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the line to the given value and rebuilds it", "response": "def setValue( self, value ):\r\n        \"\"\"\r\n        Moves the line to the given value and rebuilds it\r\n        \r\n        :param      value | <variant>\r\n        \"\"\"\r\n        scene = self.scene()\r\n        point = scene.mapFromChart(value, None)\r\n        \r\n        self.setPos(point.x(), self.pos().y())\r\n        self.rebuild(scene.gridRect())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the access token from the server", "response": "def get_access_token(self):\n        \"\"\"\n        If a valid access token is in memory, returns it\n        Else feches a new token and returns it\n        \"\"\"\n        if self.token_info and not self.is_token_expired(self.token_info):\n            return self.token_info['access_token']\n\n        token_info = self._request_access_token()\n        token_info = self._add_custom_values_to_token_info(token_info)\n        self.token_info = token_info\n        return self.token_info['access_token']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests an access token from the client", "response": "def _request_access_token(self):\n        \"\"\"Gets client credentials access token \"\"\"\n        payload = {'grant_type': 'authorization_code',\n                   'code': code,\n                   'redirect_uri': self.redirect_uri}\n\n        headers = _make_authorization_headers(self.client_id,\n                                              self.client_secret)\n\n        response = requests.post(self.OAUTH_TOKEN_URL, data=payload,\n                                 headers=headers,\n                                 verify=LOGIN_VERIFY_SSL_CERT)\n\n        if response.status_code is not 200:\n            raise MercedesMeAuthError(response.reason)\n        token_info = response.json()\n        return token_info"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a cached auth token", "response": "def get_cached_token(self):\n        ''' Gets a cached auth token\n        '''\n        token_info = None\n        if self.cache_path:\n            try:\n                f = open(self.cache_path)\n                token_info_string = f.read()\n                f.close()\n                token_info = json.loads(token_info_string)\n\n                if self.is_token_expired(token_info):\n                    token_info = self.refresh_access_token(token_info['refresh_token'])\n\n            except IOError:\n                pass\n        return token_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the URL to use to authorize this app", "response": "def get_authorize_url(self, state=None):\n        \"\"\" Gets the URL to use to authorize this app\n        \"\"\"\n        payload = {'client_id': self.client_id,\n                   'response_type': 'code',\n                   'redirect_uri': self.redirect_uri,\n                   'scope': self.scope}\n\n        urlparams = urllib.parse.urlencode(payload)\n\n        return \"%s?%s\" % (self.OAUTH_AUTHORIZE_URL, urlparams)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the access token for the app given the code", "response": "def get_access_token(self, code):\n        \"\"\" Gets the access token for the app given the code\n\n            Parameters:\n                - code - the response code\n        \"\"\"\n\n        payload = {'redirect_uri': self.redirect_uri,\n                   'code': code,\n                   'grant_type': 'authorization_code'}\n\n        headers = self._make_authorization_headers()\n\n        response = requests.post(self.OAUTH_TOKEN_URL, data=payload,\n            headers=headers, verify=LOGIN_VERIFY_SSL_CERT)\n        if response.status_code is not 200:\n            raise MercedesMeAuthError(response.reason)\n        token_info = response.json()\n        token_info = self._add_custom_values_to_token_info(token_info)\n        self._save_token_info(token_info)\n        return token_info"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_custom_values_to_token_info(self, token_info):\n        '''\n        Store some values that aren't directly provided by a Web API\n        response.\n        '''\n        token_info['expires_at'] = int(time.time()) + token_info['expires_in']\n        token_info['scope'] = self.scope\n        return token_info", "response": "Add custom values to the token info dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the inputed action to this widget s action group.", "response": "def addAction(self, action, checked=None, autoBuild=True):\r\n        \"\"\"\r\n        Adds the inputed action to this widget's action group.  This will auto-\\\r\n        create a new group if no group is already defined.\r\n        \r\n        :param      action | <QAction> || <str>\r\n        \r\n        :return     <QAction>\r\n        \"\"\"\r\n        # clear the holder\r\n        actions = self._actionGroup.actions()\r\n        if actions and actions[0].objectName() == 'place_holder':\r\n            self._actionGroup.removeAction(actions[0])\r\n            actions[0].deleteLater()\r\n        \r\n        # create an action from the name\r\n        if not isinstance(action, QAction):\r\n            action_name = nativestring(action)\r\n            action = QAction(action_name, self)\r\n            action.setObjectName(action_name)\r\n            action.setCheckable(self.isCheckable())\r\n            \r\n            # auto-check the first option\r\n            if checked or (not self._actionGroup.actions() and checked is None):\r\n                action.setChecked(True)\r\n        \r\n        elif self.isCheckable():\r\n            action.setCheckable(True)\r\n            if not self.currentAction():\r\n                action.setChecked(True)\r\n        \r\n        self._actionGroup.addAction(action)\r\n        \r\n        if autoBuild:\r\n            self.rebuild()\r\n        \r\n        return action"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear the actions for this widget.", "response": "def clear(self, autoBuild=True):\r\n        \"\"\"\r\n        Clears the actions for this widget.\r\n        \"\"\"\r\n        for action in self._actionGroup.actions():\r\n            self._actionGroup.removeAction(action)\r\n        \r\n        action = QAction('', self)\r\n        action.setObjectName('place_holder')\r\n        self._actionGroup.addAction(action)\r\n        if autoBuild:\r\n            self.rebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef count(self):\r\n        actions = self._actionGroup.actions()\r\n        if len(actions) == 1 and actions[0].objectName() == 'place_holder':\r\n            return 0\r\n        \r\n        return len(actions)", "response": "Returns the number of actions associated with this button."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef emitTriggered(self, action):\r\n        self.currentActionChanged.emit(action)\r\n        self.currentIndexChanged.emit(self.indexOf(action))\r\n        \r\n        if not self.signalsBlocked():\r\n            self.triggered.emit(action)", "response": "Emits the triggered action for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef indexOf(self, action):\r\n        for i, act in enumerate(self.actionGroup().actions()):\r\n            if action in (act, act.objectName(), act.text()):\r\n                return i\r\n        return -1", "response": "Returns the index of the inputed action in the action group."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrebuilding the user interface buttons for this widget.", "response": "def rebuild( self ):\r\n        \"\"\"\r\n        Rebuilds the user interface buttons for this widget.\r\n        \"\"\"\r\n        self.setUpdatesEnabled(False)\r\n        \r\n        # sync up the toolbuttons with our actions\r\n        actions = self._actionGroup.actions()\r\n        btns    = self.findChildren(QToolButton)\r\n        horiz   = self.direction() in (QBoxLayout.LeftToRight, \r\n                                       QBoxLayout.RightToLeft)\r\n        \r\n        # remove unnecessary buttons\r\n        if len(actions) < len(btns):\r\n            rem_btns = btns[len(actions)-1:]\r\n            btns = btns[:len(actions)]\r\n            \r\n            for btn in rem_btns:\r\n                btn.close()\r\n                btn.setParent(None)\r\n                btn.deleteLater()\r\n        \r\n        # create new buttons\r\n        elif len(btns) < len(actions):\r\n            for i in range(len(btns), len(actions)):\r\n                btn = QToolButton(self)\r\n                btn.setAutoFillBackground(True)\r\n                btns.append(btn)\r\n                self.layout().addWidget(btn)\r\n                \r\n                btn.clicked.connect(self.emitClicked)\r\n        \r\n        # determine coloring options\r\n        palette      = self.palette()\r\n        checked      = palette.color(palette.Highlight)\r\n        checked_fg   = palette.color(palette.HighlightedText)\r\n        unchecked    = palette.color(palette.Button)\r\n        unchecked_fg = palette.color(palette.ButtonText)\r\n        border       = palette.color(palette.Mid)\r\n        \r\n        # define the stylesheet options\r\n        options = {}\r\n        options['top_left_radius']      = 0\r\n        options['top_right_radius']     = 0\r\n        options['bot_left_radius']      = 0\r\n        options['bot_right_radius']     = 0\r\n        options['border_color']         = border.name()\r\n        options['checked_fg']           = checked_fg.name()\r\n        options['checked_bg']           = checked.name()\r\n        options['checked_bg_alt']       = checked.darker(120).name()\r\n        options['unchecked_fg']         = unchecked_fg.name()\r\n        options['unchecked_bg']         = unchecked.name()\r\n        options['unchecked_bg_alt']     = unchecked.darker(120).name()\r\n        options['padding_top']          = 1\r\n        options['padding_bottom']       = 1\r\n        options['padding_left']         = 1\r\n        options['padding_right']        = 1\r\n        \r\n        if horiz:\r\n            options['x1'] = 0\r\n            options['y1'] = 0\r\n            options['x2'] = 0\r\n            options['y2'] = 1\r\n        else:\r\n            options['x1'] = 0\r\n            options['y1'] = 0\r\n            options['x2'] = 1\r\n            options['y2'] = 1\r\n        \r\n        # sync up the actions and buttons\r\n        count = len(actions)\r\n        palette = self.palette()\r\n        font = self.font()\r\n        for i, action in enumerate(actions):\r\n            btn = btns[i]\r\n            \r\n            # assign the action for this button\r\n            if btn.defaultAction() != action:\r\n                # clear out any existing actions\r\n                for act in btn.actions():\r\n                    btn.removeAction(act)\r\n                \r\n                # assign the given action\r\n                btn.setDefaultAction(action)\r\n            \r\n            options['top_left_radius']  = 1\r\n            options['bot_left_radius']  = 1\r\n            options['top_right_radius'] = 1\r\n            options['bot_right_radius'] = 1\r\n            \r\n            if horiz:\r\n                options['padding_left']     = self._padding\r\n                options['padding_right']    = self._padding\r\n            else:\r\n                options['padding_top']      = self._padding\r\n                options['padding_bottom']   = self._padding\r\n            \r\n            if not i:\r\n                if horiz:\r\n                    options['top_left_radius'] = self.cornerRadius()\r\n                    options['bot_left_radius'] = self.cornerRadius()\r\n                    options['padding_left']    += self.cornerRadius() / 3.0\r\n                else:\r\n                    options['top_left_radius'] = self.cornerRadius()\r\n                    options['top_right_radius'] = self.cornerRadius()\r\n                    options['padding_top']     += self.cornerRadius() / 3.0\r\n                    \r\n            if i == count - 1:\r\n                if horiz:\r\n                    options['top_right_radius'] = self.cornerRadius()\r\n                    options['bot_right_radius'] = self.cornerRadius()\r\n                    options['padding_right']    += self.cornerRadius() / 3.0\r\n                else:\r\n                    options['bot_left_radius']  = self.cornerRadius()\r\n                    options['bot_right_radius'] = self.cornerRadius()\r\n                    options['padding_bottom']   += self.cornerRadius() / 3.0\r\n            \r\n            btn.setFont(font)\r\n            btn.setPalette(palette)\r\n            btn.setStyleSheet(TOOLBUTTON_STYLE % options)\r\n            if horiz:\r\n                btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\r\n            else:\r\n                btn.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)\r\n        \r\n        self.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setActions(self, actions):\r\n        self.clear(autoBuild=False)\r\n        for action in actions:\r\n            self.addAction(action, autoBuild=False)\r\n        self.rebuild()", "response": "Sets the actions for this widget to the inputed list of actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCheckable(self, state):\r\n        self._checkable = state\r\n        for act in self._actionGroup.actions():\r\n            act.setCheckable(state)", "response": "Sets whether or not the actions within this button should be checkable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the current action for this button to the inputed action.", "response": "def setCurrentAction(self, action):\r\n        \"\"\"\r\n        Sets the current action for this button to the inputed action.\r\n        \r\n        :param      action | <QAction> || <str>\r\n        \"\"\"\r\n        self._actionGroup.blockSignals(True)\r\n        for act in self._actionGroup.actions():\r\n            act.setChecked(act == action or act.text() == action)\r\n        self._actionGroup.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setFont(self, font):\r\n        super(XSplitButton, self).setFont(font)\r\n        self.rebuild()", "response": "Sets the font for this widget and propogates down to the buttons."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the palette for this widget.", "response": "def setPalette(self, palette):\r\n        \"\"\"\r\n        Rebuilds the buttons for this widget since they use specific palette\r\n        options.\r\n        \r\n        :param      palette | <QPalette>\r\n        \"\"\"\r\n        super(XSplitButton, self).setPalette(palette)\r\n        self.rebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_dimensions(filenames):\n\n    dims = []\n    for filename in filenames:\n        implemented = False\n        with open(filename, 'rb') as fp:\n\n            img_types = (PNGFile, GIFFile, JPEGFile)\n            for img_type in img_types:\n                sig = str(getattr(img_type, 'SIGNATURE')[0])\n                magic = fp.read(len(sig))\n                fp.seek(0)\n                if magic == sig:\n                    cls = img_type.__name__.split('.')[-1]\n                    img = getattr(img_type, cls)(fp)\n                    x, y = img.size\n                    dims.append((x, y, img.content_type, filename))\n                    implemented = True\n                    break\n            if not implemented:\n                # might want to fail silently, or print error to stdout...\n                print('cannot handle file: %s' % filename)\n                raise NotImplementedError\n    return dims", "response": "given a sequence of filenames compute dimensions\n    return sequence of tuples x y content - type filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a filename or list of filenames return a tuple or sequence of tuples x y filename", "response": "def dimensions(filenames):\n    \"\"\"given a filename or list of filenames,\n    return a tuple or sequence of tuples (x, y, filename)\"\"\"\n\n    single = type(filenames) is str\n    if single:\n        filenames = [filenames]\n    dims = get_dimensions(filenames)\n    if single:\n        dims = dims[0]\n    return dims"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncopying the current filepath contents to the current clipboard.", "response": "def copyFilepath( self ):\n        \"\"\"\n        Copies the current filepath contents to the current clipboard.\n        \"\"\"\n        clipboard = QApplication.instance().clipboard()\n        clipboard.setText(self.filepath())\n        clipboard.setText(self.filepath(), clipboard.Selection)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dropEvent( self, event ):\r\n        if event.mimeData().hasUrls():\r\n            url      = event.mimeData().urls()[0]\r\n            filepath = url.toLocalFile()\r\n            if filepath:\r\n                self.setFilepath(filepath)", "response": "Updates the filepath attribute of the object based on the event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef eventFilter( self, object, event ):\n        if ( object == self._filepathEdit and \\\n             self._filepathEdit.isReadOnly() and \\\n             event.type() == event.MouseButtonPress and \\\n             event.button() == Qt.LeftButton ):\n            self.pickFilepath()\n            \n        return False", "response": "This method is used to filter out click events on the line edit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the filepath for this widget.", "response": "def filepath( self, validated = False ):\n        \"\"\"\n        Returns the filepath for this widget.  If the validated flag is set \\\n        then this method will only return if the file or folder actually \\\n        exists for this path.  In the case of a SaveFile, only the base folder \\\n        needs to exist on the system, in other modes the actual filepath must \\\n        exist.  If not validated, the text will return whatever is currently \\\n        entered.\n        \n        :return     <str>\n        \"\"\"\r\n        paths = self.filepaths()\r\n        if not paths:\r\n            return ''\r\n        \n        if not validated or self.isValid():\n            return paths[0]\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filepaths(self):\r\n        return nativestring(self._filepathEdit.text()).split(os.path.pathsep)", "response": "Returns a list of the filepaths for this edit."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning whether or not the filepath exists on the system.", "response": "def isValid( self ):\n        \"\"\"\n        Returns whether or not the filepath exists on the system. \\\n        In the case of a SaveFile, only the base folder \\\n        needs to exist on the system, in other modes the actual filepath must \\\n        exist.\n        \n        :return     <bool>\n        \"\"\"\n        check = nativestring(self._filepathEdit.text()).split(os.path.pathsep)[0]\n        if ( self.filepathMode() == XFilepathEdit.Mode.SaveFile ):\n            check = os.path.dirname(check)\n        \n        return os.path.exists(check)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pickFilepath( self ):\n        mode = self.filepathMode()\n        \r\n        filepath = ''\r\n        filepaths = []\n        curr_dir = nativestring(self._filepathEdit.text())\n        if ( not curr_dir ):\n            curr_dir = QDir.currentPath()\n        \n        if mode == XFilepathEdit.Mode.SaveFile:\n            filepath = QFileDialog.getSaveFileName( self,\n                                                    self.windowTitle(),\n                                                    curr_dir,\n                                                    self.filepathTypes() )\n                                                    \n        elif mode == XFilepathEdit.Mode.OpenFile:\n            filepath = QFileDialog.getOpenFileName( self,\n                                                    self.windowTitle(),\n                                                    curr_dir,\n                                                    self.filepathTypes() )\n        \r\n        elif mode == XFilepathEdit.Mode.OpenFiles:\r\n            filepaths = QFileDialog.getOpenFileNames( self,\r\n                                                      self.windowTitle(),\r\n                                                      curr_dir,\r\n                                                      self.filepathTypes() )\r\n        \n        else:\n            filepath = QFileDialog.getExistingDirectory( self,\n                                                         self.windowTitle(),\n                                                         curr_dir )\n        \n        if filepath:\r\n            if type(filepath) == tuple:\r\n                filepath = filepath[0]\n            self.setFilepath(nativestring(filepath))\r\n        elif filepaths:\r\n            self.setFilepaths(map(str, filepaths))", "response": "Prompts the user to select a filepath from the system based on the current filepath mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setFilepathModeText( self, text ):\n        try:\n            self.setFilepathMode(XFilepathEdit.Mode[nativestring(text)])\n            return True\n        except KeyError:\n            return False", "response": "Sets the filepath mode for this widget based on the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the filepath text for this widget to the inputed path.", "response": "def setFilepath(self, filepath):\n        \"\"\"\n        Sets the filepath text for this widget to the inputed path.\n        \n        :param      filepath | <str>\n        \"\"\"\r\n        if not filepath:\r\n            self._filepathEdit.setText('')\r\n            return\r\n        \r\n        if self.normalizePath():\r\n            filepath = os.path.normpath(nativestring(filepath))\r\n        else:\r\n            filepath = os.path.normpath(nativestring(filepath)).replace('\\\\', '/')\r\n            \n        self._filepathEdit.setText(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the list of filepaths for this widget to the inputed paths.", "response": "def setFilepaths(self, filepaths):\r\n        \"\"\"\r\n        Sets the list of the filepaths for this widget to the inputed paths.\r\n        \r\n        :param      filepaths | [<str>, ..]\r\n        \"\"\"\r\n        self.setFilepath(os.path.pathsep.join(filepaths))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the hint for this filepath.", "response": "def setHint(self, hint):\n        \"\"\"\n        Sets the hint for this filepath.\n        \n        :param      hint | <str>\n        \"\"\"\r\n        if self.normalizePath():\r\n            filepath = os.path.normpath(nativestring(hint))\r\n        else:\r\n            filepath = os.path.normpath(nativestring(hint)).replace('\\\\', '/')\r\n            \n        self._filepathEdit.setHint(hint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets whether or not the path is valid.", "response": "def setValidated( self, state ):\n        \"\"\"\n        Set whether or not to validate the path as the user edits it.\n        \n        :param      state | <bool>\n        \"\"\"\n        self._validated = state\n        palette = self.palette()\n        \n        # reset the palette to default, revalidate\n        self._filepathEdit.setPalette(palette)\n        self.validate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef showMenu( self, pos ):\n        menu = QMenu(self)\n        menu.setAttribute(Qt.WA_DeleteOnClose)\n        menu.addAction('Clear').triggered.connect(self.clearFilepath)\n        menu.addSeparator()\n        menu.addAction('Copy Filepath').triggered.connect(self.copyFilepath)\n        \n        menu.exec_(self.mapToGlobal(pos))", "response": "Show the menu at the given position."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the color scheme based on the validation settings.", "response": "def validateFilepath( self ):\n        \"\"\"\n        Alters the color scheme based on the validation settings.\n        \"\"\"\n        if ( not self.isValidated() ):\n            return\n        \n        valid = self.isValid()\n        if ( not valid ):\n            fg = self.invalidForeground()\n            bg = self.invalidBackground()\n        else:\n            fg = self.validForeground()\n            bg = self.validBackground()\n        \n        palette = self.palette()\n        palette.setColor(palette.Base, bg)\n        palette.setColor(palette.Text, fg)\n        self._filepathEdit.setPalette(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the query for this item by joining together its children and building its data.", "response": "def query( self ):\r\n        \"\"\"\r\n        Returns the query for this item by joining together its children, \r\n        or building its data.\r\n        \r\n        :return     <Query> || <QueryCompound>\r\n        \"\"\"\r\n        if ( self.childCount() ):\r\n            q = Q()\r\n            for i in range(self.childCount()):\r\n                q &= self.child(i).query()\r\n            return q\r\n        else:\r\n            op_name = projex.text.classname(self.text(2))\r\n            q = Q(nativestring(self.text(1)))\r\n            q.setOperatorType(Q.Op[op_name])\r\n            q.setValueString(nativestring(self.text(3)))\r\n            return q"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply the query for this widget to the quick query text builder.", "response": "def applyQuery( self ):\r\n        \"\"\"\r\n        Sets the query for this widget from the quick query text builder.\r\n        \"\"\"\r\n        query = Q.fromString(nativestring(self.uiQueryTXT.text()))\r\n        self.setQuery(query)\r\n        self.uiQueryTXT.setText('')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear( self ):\r\n        self.uiQueryTXT.setText('')\r\n        self.uiQueryTREE.clear()\r\n        self.uiGroupingTXT.setText('')\r\n        self.uiSortingTXT.setText('')", "response": "Clears the information for this edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query( self ):\r\n        if ( not self.uiQueryCHK.isChecked() ):\r\n            return None\r\n        \r\n        # build a query if not searching all\r\n        q = Q()\r\n        for i in range(self.uiQueryTREE.topLevelItemCount()):\r\n            item = self.uiQueryTREE.topLevelItem(i)\r\n            q &= item.query()\r\n        return q", "response": "Returns the query this widget is representing from the tree widget."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recordSet( self ):\r\n        if ( not self.table() ):\r\n            return None\r\n        \r\n        recordSet = RecordSet(self.table())\r\n        recordSet.setQuery(self.query())\r\n        \r\n        # set the grouping options\r\n        grouping = nativestring(self.uiGroupingTXT.text()).split(',')\r\n        while ( '' in grouping ):\r\n            grouping.remove('')\r\n        \r\n        recordSet.setGroupBy( grouping )\r\n        \r\n        # set the sorting options\r\n        sorting = nativestring(self.uiSortingTXT.text()).split(',')\r\n        while ( '' in sorting ):\r\n            sorting.remove('')\r\n        \r\n        recordSet.setOrder([i.split('|') for i in sorting])\r\n        \r\n        # set the paged options\r\n        recordSet.setPaged(self.uiPagedCHK.isChecked())\r\n        recordSet.setPageSize(self.uiPagedSPN.value())\r\n        \r\n        return recordSet", "response": "Returns the record set that is associated with this widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the record set that this widget will use.", "response": "def setRecordSet( self, recordSet ):\r\n        \"\"\"\r\n        Sets the record set instance that this widget will use.\r\n        \r\n        :param      recordSet | <orb.RecordSet>\r\n        \"\"\"\r\n        if ( recordSet ):\r\n            self.setQuery(      recordSet.query() )\r\n            self.setGroupBy(    recordSet.groupBy() )\r\n            self.setPageSize(   recordSet.pageSize() )\r\n            self.setSortBy(     recordSet.order() )\r\n            \r\n            self.uiPagedCHK.setChecked( recordSet.isPaged() )\r\n        else:\r\n            self.setQuery(Q())\r\n            self.setGroupBy('')\r\n            self.setPageSize(100)\r\n            self.setSortBy('')\r\n            \r\n            self.uiPagedCHK.setChecked( False )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setGroupBy( self, groupBy ):\r\n        if ( type(groupBy) in (list, tuple) ):\r\n            groupBy = ','.join(map(str, groupBy))\r\n        \r\n        self.uiGroupingTXT.setText(groupBy)", "response": "Sets the group by information for this widget to the inputed groupingTXT options."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the sorting information for this widget to the inputed sorting information.", "response": "def setSortedBy( self, sortedBy ):\r\n        \"\"\"\r\n        Sets the sorting information for this widget to the inputed sorting\r\n        options.  This can be either a list of terms, or a comma deliminated\r\n        string.\r\n        \r\n        :param      sortedBy | <str> || [(<str> column, <str> direction), ..]\r\n        \"\"\"\r\n        if ( type(groupBy) in (list, tuple) ):\r\n            sortedBy = ','.join(map(lambda x: '%s|%s' % x, sortedBy))\r\n        \r\n        self.uiSortingTXT.setText(sortedBy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the table that this widget is assigned to.", "response": "def setTable( self, table ):\r\n        \"\"\"\r\n        Sets the table that is assigned to this widget to the inputed table.\r\n        \r\n        :param      table | <subclass of orb.Table>\r\n        \"\"\"\r\n        self._table = table\r\n        self.setEnabled(table is not None)\r\n        self.clear()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the values from the inputed dictionary to the widget.", "response": "def loadValues(self, values):\r\n        \"\"\"\r\n        Loads the values from the inputed dictionary to the widget.\r\n        \r\n        :param      values | <dict>\r\n        \"\"\"\r\n        table = self.tableType()\r\n        if table:\r\n            schema = table.schema()\r\n        else:\r\n            schema = None\r\n        \r\n        process = []\r\n        for widget in self.findChildren(QWidget):\r\n            prop = widget.property('columnName')\r\n            if not prop:\r\n                continue\r\n            \r\n            order = widget.property('columnOrder')\r\n            if order:\r\n                order = unwrapVariant(order)\r\n            else:\r\n                order = 10000000\r\n            \r\n            process.append((order, widget, prop))\r\n        \r\n        process.sort()\r\n        for order, widget, prop in process:\r\n            columnName = nativestring(unwrapVariant(prop, ''))\r\n            \r\n            if not columnName:\r\n                continue\r\n            \r\n            if isinstance(widget, XEnumBox) and schema:\r\n                column = schema.column(columnName)\r\n                if column.enum() is not None:\r\n                    widget.setEnum(column.enum())\r\n            \r\n            if columnName in values:\r\n                projexui.setWidgetValue(widget, values.get(columnName))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self):\r\n        ttype = self.tableType()\r\n        if ( not ttype ):\r\n            return False\r\n        \r\n        values = self.saveValues()\r\n        self.setRecord(ttype())\r\n        restore_values = {}\r\n        for column in self.savedColumnsOnReset():\r\n            if column in restore_values:\r\n                restore_values[column] = values[column]\r\n        if restore_values:\r\n            self.loadValues(restore_values)\r\n        \r\n        return True", "response": "Resets this widget s data to a new class an reinitializes it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef saveValues(self):\r\n        output = {}\r\n        \r\n        for widget in self.findChildren(QWidget):\r\n            prop = widget.property('columnName')\r\n            if not prop:\r\n                continue\r\n            \r\n            columnName = nativestring(unwrapVariant(prop, ''))\r\n            \r\n            if ( not columnName ):\r\n                continue\r\n            \r\n            value, success = projexui.widgetValue(widget)\r\n            if ( not success ):\r\n                continue\r\n            \r\n            # convert from values to standard python values\r\n            if ( isinstance(value, QDateTime) ):\r\n                value = value.toPyDateTime()\r\n            elif ( isinstance(value, QDate) ):\r\n                value = value.toPyDate()\r\n            elif ( isinstance(value, QTime) ):\r\n                value = value.toPyTime()\r\n            elif ( type(value).__name__ == 'QString' ):\r\n                value = nativestring(value)\r\n            \r\n            output[columnName] = value\r\n        \r\n        return output", "response": "Returns a dictionary of values that can be saved on the record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\r\n        record = self.record()\r\n        if not record:\r\n            logger.warning('No record has been defined for %s.' % self)\r\n            return False\r\n        \r\n        if not self.signalsBlocked():\r\n            self.aboutToSaveRecord.emit(record)\r\n            self.aboutToSave.emit()\r\n        \r\n        values = self.saveValues()\r\n        \r\n        # ignore columns that are the same (fixes bugs in encrypted columns)\r\n        check = values.copy()\r\n        for column_name, value in check.items():\r\n            try:\r\n                equals = value == record.recordValue(column_name)\r\n            except UnicodeWarning:\r\n                equals = False\r\n            \r\n            if equals:\r\n                check.pop(column_name)\r\n        \r\n        # check to see if nothing has changed\r\n        if not check and record.isRecord():\r\n            if not self.signalsBlocked():\r\n                self.recordSaved.emit(record)\r\n                self.saved.emit()\r\n                self._saveSignalBlocked = False\r\n            else:\r\n                self._saveSignalBlocked = True\r\n            \r\n            if self.autoCommitOnSave():\r\n                status, result = record.commit()\r\n                if status == 'errored':\r\n                    if 'db_error' in result:\r\n                        msg = nativestring(result['db_error'])\r\n                    else:\r\n                        msg = 'An unknown database error has occurred.'\r\n                    \r\n                    QMessageBox.information(self,\r\n                                            'Commit Error',\r\n                                            msg)\r\n                    return False\r\n            return True\r\n        \r\n        # validate the modified values\r\n        success, msg = record.validateValues(check)\r\n        if ( not success ):\r\n            QMessageBox.information(None, 'Could Not Save', msg)\r\n            return False\r\n        \r\n        record.setRecordValues(**values)\r\n        success, msg = record.validateRecord()\r\n        if not success:\r\n            QMessageBox.information(None, 'Could Not Save', msg)\r\n            return False\r\n        \r\n        if ( self.autoCommitOnSave() ):\r\n            result = record.commit()\r\n            if 'errored' in result:\r\n                QMessageBox.information(None, 'Could Not Save', msg)\r\n                return False\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.recordSaved.emit(record)\r\n            self.saved.emit()\r\n            self._saveSignalBlocked = False\r\n        else:\r\n            self._saveSignalBlocked = True\r\n        \r\n        return True", "response": "Saves the changes from the ui to this widgets record instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the record but does not emit the saved signal.", "response": "def saveSilent(self):\r\n        \"\"\"\r\n        Saves the record, but does not emit the saved signal.  This method\r\n        is useful when chaining together multiple saves.  Check the \r\n        saveSignalBlocked value to know if it was muted to know if any\r\n        saves occurred.\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        self.blockSignals(True)\r\n        success = self.save()\r\n        self.blockSignals(False)\r\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setRecord(self, record):\r\n        self._record = record\r\n        if record is not None:\r\n            self.loadValues(record.recordValues(autoInflate=True))\r\n        else:\r\n            self.loadValues({})", "response": "Sets the record instance linked with this widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new dialog with the given name and parent.", "response": "def getDialog(cls, name, parent=None):\r\n        \"\"\"\r\n        Generates a dialog for this class widget and returns it.\r\n        \r\n        :param      parent | <QtGui.QWidget> || None\r\n        \r\n        :return     <QtGui.QDialog>\r\n        \"\"\"\r\n        key = '_{0}__{1}_dialog'.format(cls.__name__, name)\r\n        dlgref = getattr(cls, key, None)\r\n        \r\n        if dlgref is not None:\r\n            dlg = dlgref()\r\n            if dlg:\r\n                return dlg\r\n            \r\n        if parent is None:\r\n            parent = QApplication.activeWindow()\r\n        \r\n        dlg = QDialog(parent)\r\n        \r\n        # create widget\r\n        widget = cls(dlg)\r\n        dlg.__dict__['_mainwidget'] = widget\r\n        widget.layout().setContentsMargins(0, 0, 0, 0)\r\n        \r\n        # create buttons\r\n        opts    = QDialogButtonBox.Save | QDialogButtonBox.Cancel\r\n        buttons = QDialogButtonBox(opts, Qt.Horizontal, dlg)\r\n        \r\n        # create layout\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(widget)\r\n        layout.addWidget(buttons)\r\n        dlg.setLayout(layout)\r\n        dlg.resize(widget.minimumSize() + QSize(15, 15))\r\n        widget.resizeRequested.connect(dlg.adjustSize)\r\n        \r\n        # create connections\r\n        buttons.accepted.connect(widget.save)\r\n        buttons.rejected.connect(dlg.reject)\r\n        widget.saved.connect(dlg.accept)\r\n        widget.setFocus()\r\n        \r\n        dlg.adjustSize()\r\n        if parent and parent.window():\r\n            center = parent.window().geometry().center()\r\n            dlg.move(center.x() - dlg.width() / 2.0,\r\n                     center.y() - dlg.height() / 2.0)\r\n        \r\n        setattr(cls, key, weakref.ref(dlg))\r\n        return dlg"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef edit(cls, record, parent=None, autoCommit=True, title=''):\r\n        dlg = cls.getDialog('edit', parent)\r\n        \r\n        # update the title\r\n        try:\r\n            name = record.schema().displayName()\r\n        except AttributeError:\r\n            name = record.__class__.__name__\r\n        \r\n        if not title:\r\n            title = 'Edit {0}'.format(name)\r\n        dlg.setWindowTitle(title)\r\n        \r\n        widget = dlg._mainwidget\r\n        widget.setRecord(record)\r\n        widget.setAutoCommitOnSave(autoCommit)\r\n        \r\n        result = dlg.exec_()\r\n        \r\n        return result == 1", "response": "Prompts the user to edit the inputed record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(cls,\r\n               model=None,\r\n               parent=None,\r\n               autoCommit=True,\r\n               defaults=None,\r\n               title=''):\r\n        \"\"\"\r\n        Prompts the user to create a new record.\r\n        \r\n        :param      model  | <subclass of orb.Table>\r\n                    parent | <QWidget>\r\n                    autoCommit | <bool>\r\n                    defaults | <dict> || None\r\n        \r\n        :return     <orb.Table> || None\r\n        \"\"\"\r\n        if model is None:\r\n            model = cls.tableType()\r\n            if model is None:\r\n                return None\r\n        \r\n        dlg = cls.getDialog('create', parent)\r\n        \r\n        # create dialog\r\n        if not title:\r\n            title = 'Create {0}'.format(type(model).__name__)\r\n        dlg.setWindowTitle(title)\r\n        \r\n        widget = dlg._mainwidget\r\n        widget.setRecord(model())\r\n        widget.setAutoCommitOnSave(autoCommit)\r\n        \r\n        if defaults:\r\n            widget.loadValues(defaults)\r\n        else:\r\n            widget.loadValues({})\r\n        \r\n        result = dlg.exec_()\r\n        if result or widget.saveSignalBlocked():\r\n            output = widget.record()\r\n        else:\r\n            output = None\r\n        \r\n        return output", "response": "Prompts the user to create a new record."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a dynamic namespace element to the end of the Namespace.", "response": "def add_dynamic_element(self, name, description):\n        \"\"\"Adds a dynamic namespace element to the end of the Namespace.\n\n        A dynamic namespace element is defined by an element that contains a\n        non-static data relative to the metric being collected.  For instance,\n        when collecting metrics for a given virtual machine the namespace\n        element that contains the virtual-machine-id would be dynamic.  This is\n        modeled by the a NamespaceElement when its `name` attribute contains the\n        value 'virtual-machine-id'.  In this example the `value` attribute would\n        be set to the ID of the virtual machine when the metric is collected.\n\n        Args:\n            value (:py:class:`snap_plugin.v1.namespace_element.NamespaceElement`):\n                namespace element\n\n        Returns:\n            :py:class:`snap_plugin.v1.namespace.Namespace`\n        \"\"\"\n        self._pb.add(Name=name, Description=description, Value=\"*\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart and returns a Selenium webdriver object for Chrome.", "response": "def Chrome(headless=False, user_agent=None, profile_path=None):\n    \"\"\"\n    Starts and returns a Selenium webdriver object for Chrome.\n\n    Starts a Selenium webdriver according to the given specifications, \n    and returns the corresponding `selenium.webdriver.Chrome` object.\n\n    Parameters\n    ----------\n    headless : bool\n        Whether to start the browser in headless mode.\n    user_agent : str, optional\n        The `user_agent` string the webdriver should use.\n    profile_path : str, optional\n        The path of the browser profile (only for Firefox and Chrome).\n\n    Returns\n    -------\n    `selenium.webdriver.Chrome`\n        Selenium webdriver, according to the given specifications.\n    \"\"\"\n    chromedriver = drivers.ChromeDriver(headless, user_agent, profile_path)\n    return chromedriver.driver"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting and returns a Selenium webdriver object for Firefox.", "response": "def Firefox(headless=False, user_agent=None, profile_path=None):\n    \"\"\"\n    Starts and returns a Selenium webdriver object for Firefox.\n\n    Starts a Selenium webdriver according to the given specifications, \n    and returns the corresponding `selenium.webdriver.Chrome` object.\n\n    Parameters\n    ----------\n    headless : bool\n        Whether to start the browser in headless mode.\n    user_agent : str, optional\n        The `user_agent` string the webdriver should use.\n    profile_path : str, optional\n        The path of the browser profile (only for Firefox and Chrome).\n\n    Returns\n    -------\n    `selenium.webdriver.Firefox`\n        Selenium webdriver, according to the given specifications.\n    \"\"\"\n    firefoxdriver = drivers.FirefoxDriver(headless, user_agent, profile_path)\n    return firefoxdriver.driver"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generatePixmap(color, style=Style.Plain, size=None):\r\n        if size is None:\r\n            size = QSize(32, 32)\r\n        \r\n        pixmap = QPixmap(size)\r\n        \r\n        # create a plain pixmap\r\n        if style == XColorIcon.Style.Plain:\r\n            pixmap.fill(color)\r\n        \r\n        return pixmap", "response": "Returns a new pixmap for the inputed color and style."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cancel(self):\r\n        if self._running:\r\n            self.interrupt()\r\n            self._running = False\r\n            self._cancelled = True\r\n            self.loadingFinished.emit()", "response": "Cancels the current lookup."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef loadColumns(self, records, columnName):\r\n        try:\r\n            for record in records:\r\n                col = record.schema().column(columnName)\r\n                if not col:\r\n                    continue\r\n                \r\n                value = record.recordValue(col.name(), autoInflate=True)\r\n                self.columnLoaded.emit(record, col.name(), wrapNone(value))\r\n        \r\n        except ConnectionLostError:\r\n            self.connectionLost.emit()\r\n        \r\n        except Interruption:\r\n            pass", "response": "Loads the column information for the given records."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loadBatch(self, records):\r\n        try:\r\n            curr_batch = records[:self.batchSize()]\r\n            next_batch = records[self.batchSize():]\r\n            \r\n            curr_records = list(curr_batch)\r\n            if self._preloadColumns:\r\n                for record in curr_records:\r\n                    record.recordValues(self._preloadColumns)\r\n            \r\n            if len(curr_records) == self.batchSize():\r\n                self.loadedRecords[object, object].emit(curr_records,\r\n                                                        next_batch)\r\n            else:\r\n                self.loadedRecords[object].emit(curr_records)\r\n        \r\n        except ConnectionLostError:\r\n            self.connectionLost.emit()\r\n        \r\n        except Interruption:\r\n            pass", "response": "Loads the records for this instance in a batched mode."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loadRecords(self, records):\r\n        try:\r\n            if self._running:\r\n                return\r\n            \r\n            self._cancelled = False\r\n            self._running = True\r\n            \r\n            try:\r\n                self.setDatabase(records.database())\r\n            except AttributeError:\r\n                pass\r\n            \r\n            self.startLoading()\r\n            \r\n            # make sure the orb module is loaded, or there is really no point\r\n            if RecordSet is None:\r\n                logger.error('Orb was not loaded.')\r\n            \r\n            # lookup a group of results\r\n            if RecordSet.typecheck(records) and records.groupBy():\r\n                levels = records.groupBy()\r\n                next_levels = levels[1:]\r\n                \r\n                for key, records in records.grouped(levels[0]).items():\r\n                    if self._cancelled:\r\n                        break\r\n                    \r\n                    # PySide Hack! Emitting None across threads will crash Qt\r\n                    #              when in PySide mode.\r\n                    if key == None:\r\n                        key = 'None'\r\n                    \r\n                    self.loadedGroup.emit(key, records, next_levels)\r\n            \r\n            # lookup a list of results, in batched mode\r\n            elif self.isBatched():\r\n                self.loadBatch(records)\r\n                \r\n            # lookup a list of results, not in batched mode\r\n            else:\r\n                records = list(records)\r\n                if self._preloadColumns:\r\n                    for record in curr_records:\r\n                        record.recordValues(self._preloadColumns)\r\n                \r\n                self.loadedRecords[object].emit(records)\r\n            \r\n            self._running = False\r\n            self.finishLoading()\r\n        except ConnectionLostError:\r\n            self.finishLoading()\r\n            self.connectionLost.emit()\r\n        except Interruption:\r\n            self.finishLoading()\r\n        finally:\r\n            self.finishLoading()", "response": "Loads the records into the appropriate record sets."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the visible state for this message box.", "response": "def setVisible( self, state ):\n        \"\"\"\n        Updates the visible state for this message box.\n        \n        :param      state | <bool>\n        \"\"\"\n        super(XMessageBox, self).setVisible(state)\n        \n        if ( state ):\n            self.startTimer(100)\n            self.layout().setSizeConstraint(QLayout.SetNoConstraint)\n            self.resize( self.width() + 100, self.height() )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setDetailedText( self, text ):\n        super(XMessageBox, self).setDetailedText(text)\n        \n        if ( text ):\n            # update the text edit\n            widgets = self.findChildren(QTextEdit)\n            widgets[0].setLineWrapMode(QTextEdit.NoWrap)\n            widgets[0].setHtml(text)\n            widgets[0].setMaximumHeight(1000)\n            widgets[0].setSizePolicy(QSizePolicy.Expanding, \n                                     QSizePolicy.Expanding)\n            \n            # update push button\n            buttons = self.findChildren(QPushButton)\n            for button in buttons:\n                if ( button.text() == 'Show Details...' ):\n                    button.clicked.connect( self.updateSizeMode )\n                    break", "response": "Sets the detailed text for this message box to the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the min and max sizes for this message box.", "response": "def timerEvent( self, event ):\n        \"\"\"\n        Updates the min and max sizes to allow this message box to be resizable.\n        \n        :param      event | <QTimerEvent>\n        \"\"\"\n        self.killTimer(event.timerId())\n        \n        self.setMaximumWidth(10000)\n        self.setMaximumHeight(10000)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detailedInformation( cls, parent, title, info, details, buttons = None ):\n        if ( buttons == None ):\n            buttons = XMessageBox.Ok\n        \n        dlg = cls(parent)\n        dlg.setWindowTitle(title)\n        dlg.setText(info)\n        dlg.setDetailedText(details)\n        dlg.setStandardButtons(buttons)\n        dlg.exec_()\n        \n        return dlg.clickedButton()", "response": "Create a detailed information dialog with the given title info and details and buttons."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nname of the instance.", "response": "def names(self):\n        \"\"\"Names, by which the instance can be retrieved.\"\"\"\n        if getattr(self, 'key', None) is None:\n            result = []\n        else:\n            result = [self.key]\n        if hasattr(self, 'aliases'):\n            result.extend(self.aliases)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new graphic to the scene.", "response": "def addGraphic(self, typ='basic'):\r\n        \"\"\"\r\n        Adds a new graphic to the scene.\r\n        \r\n        :param      typ | <str>\r\n        \r\n        :return     <XWalkthroughGraphic> || None\r\n        \"\"\"\r\n        cls = XWalkthroughGraphic.find(typ)\r\n        if not cls:\r\n            return None\r\n\r\n        graphic = cls()\r\n        self.addItem(graphic)\r\n        \r\n        return graphic"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef autoLayout(self, size=None):\r\n        if size is None:\r\n            size = self._view.size()\r\n        \r\n        self.setSceneRect(0, 0, size.width(), size.height())\r\n        for item in self.items():\r\n            if isinstance(item, XWalkthroughGraphic):\r\n                item.autoLayout(size)", "response": "Updates the layout for the graphics within this scene."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findReference(self, name, cls=QtGui.QWidget):\r\n        ref_widget = self._referenceWidget\r\n        if not ref_widget:\r\n            return None\r\n        \r\n        if ref_widget.objectName() == name:\r\n            return ref_widget\r\n        return ref_widget.findChild(cls, name)", "response": "Returns the first child of the given class with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare(self):\r\n        for item in self.items():\r\n            if isinstance(item, XWalkthroughGraphic):\r\n                item.prepare()", "response": "Prepares the items for display."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the inputed slide into the scene.", "response": "def load(self, slide):\r\n        \"\"\"\r\n        Loads the inputed slide to the scene.\r\n        \r\n        :param      slide | <XWalkthroughSlide>\r\n        \"\"\"\r\n        self._direction = getattr(QtGui.QBoxLayout,\r\n                                  slide.attributes().get('direction', 'TopToBottom'),\r\n                                  QtGui.QBoxLayout.TopToBottom)\r\n        \r\n        for item in slide.items():\r\n            graphic = self.addGraphic(item.attributes().get('type', 'basic'))\r\n            if graphic is not None:\r\n                graphic.load(item)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addToGroup(self, item):\r\n        effect = QtGui.QGraphicsDropShadowEffect(self.scene())\r\n        effect.setColor(QtGui.QColor('black'))\r\n        effect.setOffset(0, 0)\r\n        effect.setBlurRadius(40)\r\n        item.setGraphicsEffect(effect)\r\n        \r\n        item.setParentItem(self)\r\n        super(XWalkthroughGraphic, self).addToGroup(item)", "response": "Adds the inputed item to this group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a pixmap to this graphics item and returns the newly added item.", "response": "def addPixmap(self, pixmap):\r\n        \"\"\"\r\n        Adds a pixmap to this graphics item.\r\n        \r\n        :param      pixmap | <QtGui.QPixmap>\r\n        \"\"\"\r\n        # add the item to the group\r\n        item = QtGui.QGraphicsPixmapItem(pixmap)\r\n        self.addToGroup(item)\r\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a simple text item to this group.", "response": "def addText(self, text, width=None):\r\n        \"\"\"\r\n        Adds a simple text item to this group.\r\n        \r\n        :param      text            | <str>\r\n                    maximumWidth    | <float> || None\r\n                    maximumHeight   | <float> || None\r\n        \"\"\"\r\n        item = QtGui.QGraphicsTextItem()\r\n        \r\n        font = item.font()\r\n        font.setFamily('Arial')\r\n        font.setPointSize(12)\r\n        item.setFont(font)\r\n        \r\n        item.setHtml(text)\r\n        item.setDefaultTextColor(QtGui.QColor('white'))\r\n        self.addToGroup(item)\r\n        item.graphicsEffect().setBlurRadius(8)\r\n        \r\n        if width:\r\n            item.setTextWidth(width)\r\n        \r\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef autoLayout(self, size):\r\n        # update the children alignment\r\n        direction = self.property('direction', QtGui.QBoxLayout.TopToBottom)\r\n        x = 0\r\n        y = 0\r\n        base_off_x = 0\r\n        base_off_y = 0\r\n        \r\n        for i, child in enumerate(self.childItems()):\r\n            off_x = 6 + child.boundingRect().width()\r\n            off_y = 6 + child.boundingRect().height()\r\n            \r\n            if direction == QtGui.QBoxLayout.TopToBottom:\r\n                child.setPos(x, y)\r\n                y += off_y\r\n            \r\n            elif direction == QtGui.QBoxLayout.BottomToTop:\r\n                y -= off_y\r\n                child.setPos(x, y)\r\n                if not base_off_y:\r\n                    base_off_y = off_y\r\n            \r\n            elif direction == QtGui.QBoxLayout.LeftToRight:\r\n                child.setPos(x, y)\r\n                x += off_x\r\n                \r\n            else:\r\n                x -= off_x\r\n                child.setPos(x, y)\r\n                if not base_off_x:\r\n                    base_off_x = off_x\r\n        \r\n        #----------------------------------------------------------------------\r\n        \r\n        pos = self.property('pos')\r\n        align = self.property('align')\r\n        offset = self.property('offset')\r\n        rect = self.boundingRect()\r\n        \r\n        if pos:\r\n            x = pos.x()\r\n            y = pos.y()\r\n        \r\n        elif align == QtCore.Qt.AlignCenter:\r\n            x = (size.width() - rect.width()) / 2.0\r\n            y = (size.height() - rect.height()) / 2.0\r\n        \r\n        else:\r\n            if align & QtCore.Qt.AlignLeft:\r\n                x = 0\r\n            elif align & QtCore.Qt.AlignRight:\r\n                x = (size.width() - rect.width())\r\n            else:\r\n                x = (size.width() - rect.width()) / 2.0\r\n            \r\n            if align & QtCore.Qt.AlignTop:\r\n                y = 0\r\n            elif align & QtCore.Qt.AlignBottom:\r\n                y = (size.height() - rect.height())\r\n            else:\r\n                y = (size.height() - rect.height()) / 2.0\r\n        \r\n        if offset:\r\n            x += offset.x()\r\n            y += offset.y()\r\n        \r\n        x += base_off_x\r\n        y += base_off_y\r\n        \r\n        self.setPos(x, y)", "response": "Returns the new size of the current widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading information for this item from the xml data.", "response": "def load(self, graphic):\r\n        \"\"\"\r\n        Loads information for this item from the xml data.\r\n        \r\n        :param      graphic | <XWalkthroughItem>\r\n        \"\"\"\r\n        for prop in graphic.properties():\r\n            key = prop.name()\r\n            value = prop.value()\r\n            \r\n            if key == 'caption':\r\n                value = projex.wikitext.render(value.strip())\r\n            \r\n            self.setProperty(key, value)\r\n            for attr, attr_value in prop.attributes().items():\r\n                self.setProperty('{0}_{1}'.format(key, attr), attr_value)\r\n        \r\n        self.prepare()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the first reference that matches the given name and class.", "response": "def findReference(self, name, cls=QtGui.QWidget):\r\n        \"\"\"\r\n        Looks up a reference from the widget based on its object name.\r\n        \r\n        :param      name | <str>\r\n                    cls  | <subclass of QtGui.QObject>\r\n        \r\n        :return     <QtGui.QObject> || None\r\n        \"\"\"\r\n        return self.scene().findReference(name, cls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare(self):\r\n        text = self.property('caption')\r\n        if text:\r\n            capw = int(self.property('caption_width', 0))\r\n            item = self.addText(text, capw)", "response": "Prepares this graphic item to be displayed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setProperty(self, name, value):\r\n        if type(value) in (unicode, str):\r\n            try:\r\n                value = self._parsers[name](value)\r\n            except StandardError:\r\n                pass\r\n        \r\n        self._properties[name] = value", "response": "Sets the property for this item to the inputed value for the given name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare(self):\r\n        # determine if we already have a snapshot setup\r\n        pixmap = self.property('pixmap')\r\n        if pixmap is not None:\r\n            return super(XWalkthroughSnapshot, self).prepare()\r\n        \r\n        # otherwise, setup the snapshot\r\n        widget = self.property('widget')\r\n        if type(widget) in (unicode, str):\r\n            widget = self.findReference(widget)\r\n            if not widget:\r\n                return super(XWalkthroughSnapshot, self).prepare()\r\n        \r\n        # test if this is an overlay option\r\n        if self.property('overlay') and widget.parent():\r\n            ref = self.referenceWidget()\r\n            if ref == widget:\r\n                pos = QtCore.QPoint(0, 0)\r\n            else:\r\n                glbl_pos = widget.mapToGlobal(QtCore.QPoint(0, 0))\r\n                pos = ref.mapFromGlobal(glbl_pos)\r\n            \r\n            self.setProperty('pos', pos)\r\n        \r\n        # crop out the options\r\n        crop = self.property('crop', QtCore.QRect(0, 0, 0, 0))\r\n        \r\n        if crop:\r\n            rect = widget.rect()\r\n            if crop.width():\r\n                rect.setWidth(crop.width())\r\n            if crop.height():\r\n                rect.setHeight(crop.height())\r\n            if crop.x():\r\n                rect.setX(rect.width() - crop.x())\r\n            if crop.y():\r\n                rect.setY(rect.height() - crop.y())\r\n            \r\n            pixmap = QtGui.QPixmap.grabWidget(widget, rect)\r\n        else:\r\n            pixmap = QtGui.QPixmap.grabWidget(widget)\r\n        \r\n        scaled = self.property('scaled')\r\n        if scaled:\r\n            pixmap = pixmap.scaled(pixmap.width() * scaled,\r\n                                   pixmap.height() * scaled,\r\n                                   QtCore.Qt.KeepAspectRatio,\r\n                                   QtCore.Qt.SmoothTransformation)\r\n        \r\n        kwds = {}\r\n        kwds['whatsThis'] = widget.whatsThis()\r\n        kwds['toolTip'] = widget.toolTip()\r\n        kwds['windowTitle'] = widget.windowTitle()\r\n        kwds['objectName'] = widget.objectName()\r\n        \r\n        self.setProperty('caption', self.property('caption', '').format(**kwds))\r\n        self.setProperty('pixmap', pixmap)\r\n        self.addPixmap(pixmap)\r\n        \r\n        return super(XWalkthroughSnapshot, self).prepare()", "response": "Sets the properties of this graphic to the position of the first image that is used to create the snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset whether or not this combo box is editable.", "response": "def setEditable(self, state):\r\n        \"\"\"\r\n        Sets whether or not this combo box is editable.\r\n\r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._editable = state\r\n        self._hourCombo.setEditable(state)\r\n        self._minuteCombo.setEditable(state)\r\n        self._secondCombo.setEditable(state)\r\n        self._timeOfDayCombo.setEditable(state)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setFont(self, font):\r\n        super(XTimeEdit, self).setFont(font)\r\n\r\n        # update the fonts for the time combos\r\n        self._hourCombo.setFont(font)\r\n        self._minuteCombo.setFont(font)\r\n        self._secondCombo.setFont(font)\r\n        self._timeOfDayCombo.setFont(font)", "response": "Sets the font for this widget and all of its children."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets whether or not this widget will be displayed in military time.", "response": "def setMilitaryTime(self, state=True):\r\n        \"\"\"\r\n        Sets whether or not this widget will be displayed in military time.  When in military time, the hour options\r\n        will go from 01-24, when in normal mode, the hours will go 1-12.\r\n\r\n        :param      state   | <bool>\r\n        \"\"\"\r\n        time = self.time()\r\n\r\n        self._militaryTime = state\r\n        self._hourCombo.clear()\r\n\r\n        if state:\r\n            self._timeOfDayCombo.hide()\r\n            self._hourCombo.addItems(['{0:02d}'.format(i+1) for i in xrange(24)])\r\n        else:\r\n            self._timeOfDayCombo.show()\r\n            self._hourCombo.addItems(['{0}'.format(i+1) for i in xrange(12)])\r\n\r\n        self.setTime(time)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setShowHours(self, state=True):\r\n        self._showHours = state\r\n        if state:\r\n            self._hourSeparator.show()\r\n            self._hourCombo.show()\r\n        else:\r\n            self._hourSeparator.hide()\r\n            self._hourCombo.hide()", "response": "Sets whether or not to display the hours combo box for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setShowMinutes(self, state=True):\r\n        self._showMinutes = state\r\n        if state:\r\n            self._minuteCombo.show()\r\n        else:\r\n            self._minuteCombo.hide()", "response": "Sets whether or not to display the minutes combo box for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting whether or not to display the seconds combo box for this widget.", "response": "def setShowSeconds(self, state=True):\r\n        \"\"\"\r\n        Sets whether or not to display the seconds combo box for this widget.\r\n\r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._showSeconds = state\r\n        if state:\r\n            self._minuteSeparator.show()\r\n            self._secondCombo.show()\r\n        else:\r\n            self._minuteSeparator.hide()\r\n            self._secondCombo.hide()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the current time for this edit.", "response": "def setTime(self, time):\r\n        \"\"\"\r\n        Sets the current time for this edit.\r\n\r\n        :param     time | <QtCore.QTime>\r\n        \"\"\"\r\n        hour = time.hour()\r\n        minute = time.minute()\r\n        second = time.second()\r\n\r\n        if not self.isMilitaryTime():\r\n            if hour > 12:\r\n                hour -= 12\r\n                self._timeOfDayCombo.setCurrentIndex(1)\r\n            else:\r\n                self._timeOfDayCombo.setCurrentIndex(0)\r\n            hour = str(hour)\r\n        else:\r\n            hour = '{0:02d}'.format(hour)\r\n\r\n        nearest = lambda x: int(round(x/5.0)*5.0)\r\n\r\n        self._hourCombo.setCurrentIndex(self._hourCombo.findText(hour))\r\n        self._minuteCombo.setCurrentIndex(self._minuteCombo.findText('{0:02d}'.format(nearest(minute))))\r\n        self._secondCombo.setCurrentIndex(self._secondCombo.findText('{0:02d}'.format(nearest(second))))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the current time for this edit.", "response": "def time(self):\r\n        \"\"\"\r\n        Returns the current time for this edit.\r\n\r\n        :return     <QtCore.QTime>\r\n        \"\"\"\r\n        if self.isMilitaryTime():\r\n            format = 'hh:mm:ss'\r\n            time_of_day = ''\r\n        else:\r\n            format = 'hh:mm:ssap'\r\n            time_of_day = self._timeOfDayCombo.currentText().lower()\r\n\r\n        try:\r\n            hour = int(self._hourCombo.currentText()) if self.showHours() else 1\r\n        except ValueError:\r\n            hour = 1\r\n\r\n        try:\r\n            minute = int(self._minuteCombo.currentText()) if self.showMinutes() else 0\r\n        except ValueError:\r\n            minute = 0\r\n\r\n        try:\r\n            second = int(self._secondCombo.currentText()) if self.showSeconds() else 0\r\n        except ValueError:\r\n            second = 0\r\n\r\n        combined = '{0:02}:{1:02}:{2:02}{3}'.format(hour, minute, second, time_of_day)\r\n        return QtCore.QTime.fromString(combined, format)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_real_layer_path(self, path):\n        filename = path.split('/')[-1]\n        local_path = path\n        filetype = os.path.splitext(filename)[1]\n\n        # Url\n        if re.match(r'^[a-zA-Z]+://', path):\n            local_path = os.path.join(DATA_DIRECTORY, filename)\n\n            if not os.path.exists(local_path):\n                sys.stdout.write('* Downloading %s...\\n' % filename)\n                self.download_file(path, local_path)\n            elif self.args.redownload:\n                os.remove(local_path)\n\n                sys.stdout.write('* Redownloading %s...\\n' % filename)\n                self.download_file(path, local_path)\n        # Non-existant file\n        elif not os.path.exists(local_path):\n            raise Exception('%s does not exist' % local_path)\n\n        real_path = path\n\n        # Zip files\n        if filetype == '.zip':\n            slug = os.path.splitext(filename)[0]\n            real_path = os.path.join(DATA_DIRECTORY, slug)\n\n            if not os.path.exists(real_path):\n                sys.stdout.write('* Unzipping...\\n')\n                self.unzip_file(local_path, real_path)\n\n        return real_path", "response": "Get the path the actual layer file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_file(self, url, local_path):\n        response = requests.get(url, stream=True)\n\n        with open(local_path, 'wb') as f:\n            for chunk in tqdm(response.iter_content(chunk_size=1024), unit='KB'):\n                if chunk: # filter out keep-alive new chunks\n                    f.write(chunk)\n                    f.flush()", "response": "Download a file from a remote host."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunzip a local file into a specified directory.", "response": "def unzip_file(self, zip_path, output_path):\n        \"\"\"\n        Unzip a local file into a specified directory.\n        \"\"\"\n        with zipfile.ZipFile(zip_path, 'r') as z:\n            z.extractall(output_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_ogr2ogr(self, name, layer, input_path):\n        output_path = os.path.join(TEMP_DIRECTORY, '%s.json' % name)\n\n        if os.path.exists(output_path):\n            os.remove(output_path)\n\n        ogr2ogr_cmd = [\n            'ogr2ogr',\n                '-f', 'GeoJSON',\n                '-clipsrc', self.config['bbox']\n        ]\n\n        if 'where' in layer:\n            ogr2ogr_cmd.extend([\n                '-where', '\"%s\"' % layer['where']\n            ])\n\n        ogr2ogr_cmd.extend([\n            output_path,\n            input_path\n        ])\n\n        sys.stdout.write('* Running ogr2ogr\\n')\n\n        if self.args.verbose:\n            sys.stdout.write('  %s\\n' % ' '.join(ogr2ogr_cmd))\n\n        r = envoy.run(' '.join(ogr2ogr_cmd))\n\n        if r.status_code != 0:\n            sys.stderr.write(r.std_err)\n\n        return output_path", "response": "Process a layer using ogr2ogr."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_topojson(self, name, layer, input_path):\n        output_path = os.path.join(TEMP_DIRECTORY, '%s.topojson' % name)\n\n        # Use local topojson binary\n        topojson_binary = 'node_modules/bin/topojson'\n\n        if not os.path.exists(topojson_binary):\n            # try with global topojson binary\n            topojson_binary = 'topojson'\n\n        topo_cmd = [\n            topojson_binary,\n            '-o', output_path\n        ]\n\n        if 'id-property' in layer:\n            topo_cmd.extend([\n                '--id-property', layer['id-property']\n            ])\n\n        if layer.get('all-properties', False):\n            topo_cmd.append('-p')\n        elif 'properties' in layer:\n            topo_cmd.extend([\n                '-p', ','.join(layer['properties'])\n            ])\n\n        topo_cmd.extend([\n            '--',\n            input_path\n        ])\n\n        sys.stdout.write('* Running TopoJSON\\n')\n\n        if self.args.verbose:\n            sys.stdout.write('  %s\\n' % ' '.join(topo_cmd))\n\n        r = envoy.run(' '.join(topo_cmd))\n\n        if r.status_code != 0:\n            sys.stderr.write(r.std_err)\n\n        return output_path", "response": "Process a topojson layer using topojson."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmerge data layers into a single topojson file.", "response": "def merge(self, paths):\n        \"\"\"\n        Merge data layers into a single topojson file.\n        \"\"\"\n\n        # Use local topojson binary\n        topojson_binary = 'node_modules/bin/topojson'\n\n        if not os.path.exists(topojson_binary):\n            # try with global topojson binary\n            topojson_binary = 'topojson'\n\n        merge_cmd = '%(binary)s -o %(output_path)s --bbox -p -- %(paths)s' % {\n            'output_path': self.args.output_path,\n            'paths': ' '.join(paths),\n            'binary': topojson_binary\n        }\n\n        sys.stdout.write('Merging layers\\n')\n\n        if self.args.verbose:\n            sys.stdout.write('  %s\\n' % merge_cmd)\n\n        r = envoy.run(merge_cmd)\n\n        if r.status_code != 0:\n            sys.stderr.write(r.std_err)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new item at the given item.", "response": "def addMenuItem( self, newItem, atItem ):\n        \"\"\"\n        Adds a new menu item at the given item.\n        \n        :param      newItem | <QTreeWidgetItem>\n                    atItem  | <QTreeWidgetItem>\n        \"\"\"\n        tree = self.uiMenuTREE\n        \n        if ( not atItem ):\n            tree.addTopLevelItem(newItem)\n            \n        elif ( atItem.data(0, Qt.UserRole) == 'menu' ):\n            atItem.addChild(newItem)\n        \n        elif ( atItem.parent() ):\n            index = atItem.parent().indexOfChild(atItem)\n            atItem.parent().insertChild(index + 1, newItem)\n        \n        else:\n            index = tree.indexOfTopLevelItem(atItem)\n            tree.insertTopLevelItem(index + 1, newItem)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef createActionItem( self, key ):\n        action = self._actions.get(key)\n        if ( not action ):\n            text = 'Missing Action: %s' % key\n            item = QTreeWidgetItem([text])\n            ico = projexui.resources.find('img/log/warning.png')\n            item.setIcon(0, QIcon(ico))\n        else:\n            item = QTreeWidgetItem([nativestring(action.text()).replace('&', '')])\n            item.setIcon(0, action.icon())\n        \n        item.setSizeHint(0, QSize(120, 20))\n        item.setData(0, Qt.UserRole, wrapVariant(key))\n        \n        flags = item.flags()\n        flags ^= Qt.ItemIsDropEnabled\n        item.setFlags(flags)\n        \n        return item", "response": "Creates a new action item for the inputed key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef createMenu( self ):\n        name, accepted = QInputDialog.getText( self,\n                                               'Create Menu',\n                                               'Name: ')\n        \n        if ( accepted ):\n            self.addMenuItem(self.createMenuItem(name), \n                             self.uiMenuTREE.currentItem())", "response": "Creates a new menu with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new menu item with the given title.", "response": "def createMenuItem( self, title ):\n        \"\"\"\n        Creates a new menu item with the given title.\n        \n        :param      title | <str>\n        \n        :return     <QTreeWidgetItem>\n        \"\"\"\n        item = QTreeWidgetItem([title])\n        ico = projexui.resources.find('img/folder.png')\n        \n        item.setIcon(0, QIcon(ico))\n        item.setSizeHint(0, QSize(120, 20))\n        item.setData(0, Qt.UserRole, wrapVariant('menu'))\n        \n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new separator item.", "response": "def createSeparatorItem( self ):\n        \"\"\"\n        Creates a new separator item.\n        \n        :return     <QTreeWidgetItem>\n        \"\"\"\n        item = QTreeWidgetItem(['                                    '])\n        font = item.font(0)\n        font.setStrikeOut(True)\n        item.setFont(0, font)\n        item.setData(0, Qt.UserRole, wrapVariant('separator'))\n        flags = item.flags()\n        flags ^= Qt.ItemIsDropEnabled\n        item.setFlags(flags)\n        \n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters the menu tree items based on the event.", "response": "def eventFilter( self, object, event ):\n        \"\"\"\n        Processes events for the menu tree.\n        \n        :param      event | <QEvent>\n        \"\"\"\n        if ( not event.type() in (QEvent.DragEnter,\n                                  QEvent.DragMove,\n                                  QEvent.Drop) ):\n            return False\n        \n        # support dragging and dropping\n        if ( event.type() in (event.DragEnter, event.DragMove) ):\n            data = event.mimeData()\n            if ( data.hasFormat('application/x-actions') ):\n                event.acceptProposedAction()\n            return True\n        \n        # handle creation of new items\n        if ( event.type() == QEvent.Drop ):\n            data      = event.mimeData()\n            actions   = nativestring(data.data('application/x-actions'))\n            \n            # determine the drop item\n            pos       = event.pos()\n            pos.setY(pos.y() - 20)\n            drop_item = self.uiMenuTREE.itemAt(pos)\n            \n            tree = self.uiMenuTREE\n            for key in actions.split(','):\n                if ( not key ):\n                    continue\n                \n                item = self.createActionItem(key)\n                self.addMenuItem(item, drop_item)\n                drop_item = item\n                \n            return True\n            \n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loadXml( self, xaction ):\n        if ( xaction.tag == 'menu' ):\n            title = xaction.get('title', '')\n            item = self.createMenuItem(title)\n            for xchild in xaction:\n                item.addChild(self.loadXml(xchild))\n            \n        elif ( xaction.tag == 'separator' ):\n            item = self.createSeparatorItem()\n        \n        else:\n            key = xaction.get('name', '')\n            item = self.createActionItem(key)\n        \n        return item", "response": "Loads the xml action into the menu template tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the menu template based on the user preferences.", "response": "def menuTemplate( self ):\n        \"\"\"\n        Returns the new menu template based on the user preferences.\n        \n        :return     <str>\n        \"\"\"\n        xml = ElementTree.Element('menu')\n        for i in range(self.uiMenuTREE.topLevelItemCount()):\n            self.saveXml(xml, self.uiMenuTREE.topLevelItem(i))\n        \n        projex.text.xmlindent(xml)\n        return ElementTree.tostring(xml)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the item from the menu.", "response": "def removeItem( self ):\n        \"\"\"\n        Removes the item from the menu.\n        \"\"\"\n        item = self.uiMenuTREE.currentItem()\n        if ( not item ):\n            return\n        \n        opts = QMessageBox.Yes | QMessageBox.No\n        answer = QMessageBox.question( self,\n                                       'Remove Item',\n                                       'Are you sure you want to remove this '\\\n                                       ' item?',\n                                       opts )\n        \n        if ( answer == QMessageBox.Yes ):\n            parent = item.parent()\n            if ( parent ):\n                parent.takeChild(parent.indexOfChild(item))\n            else:\n                tree = self.uiMenuTREE\n                tree.takeTopLevelItem(tree.indexOfTopLevelItem(item))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprompts the user to supply a new name for the menu.", "response": "def renameMenu( self ):\n        \"\"\"\n        Prompts the user to supply a new name for the menu.\n        \"\"\"\n        item = self.uiMenuTREE.currentItem()\n        \n        name, accepted = QInputDialog.getText( self,\n                                               'Rename Menu',\n                                               'Name:',\n                                               QLineEdit.Normal,\n                                               item.text(0))\n        if ( accepted ):\n            item.setText(0, name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef saveXml( self, xparent, item ):\n        key = nativestring(unwrapVariant(item.data(0, Qt.UserRole)))\n        \n        if ( key == 'separator' ):\n            ElementTree.SubElement(xparent, 'separator')\n        elif ( key == 'menu' ):\n            elem = ElementTree.SubElement(xparent, 'menu')\n            elem.set('title', nativestring(item.text(0)))\n            \n            for c in range(item.childCount()):\n                self.saveXml(elem, item.child(c))\n        else:\n            elem = ElementTree.SubElement(xparent, 'action')\n            elem.set('name', key)", "response": "Saves the information from the tree item to xml."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setActions( self, actions ):\n        self._actions = actions\n        \n        self.uiActionTREE.blockSignals(True)\n        self.uiActionTREE.setUpdatesEnabled(False)\n        \n        self.uiActionTREE.clear()\n        actions = actions.items()\n        actions.sort(key = lambda x: nativestring(x[1].text()).replace('&', ''))\n        \n        for key, action in actions:\n            item = self.createActionItem(key)\n            self.uiActionTREE.addTopLevelItem(item)\n        \n        self.uiActionTREE.setUpdatesEnabled(True)\n        self.uiActionTREE.blockSignals(False)", "response": "Sets the actions for this widget to the inputed list of actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setMenuTemplate( self, template ):\n        try:\n            xtree = ElementTree.fromstring(nativestring(template))\n        except ExpatError, e:\n            logger.exception(e)\n            return\n        \n        self.uiMenuTREE.setUpdatesEnabled(False)\n        self.uiMenuTREE.blockSignals(True)\n        \n        self.uiMenuTREE.clear()\n        for xaction in xtree:\n            self.uiMenuTREE.addTopLevelItem(self.loadXml(xaction))\n        \n        self.uiMenuTREE.setUpdatesEnabled(True)\n        self.uiMenuTREE.blockSignals(False)", "response": "Sets the menu template for this widget to the inputed string template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef showMenu( self ):\n        item = self.uiMenuTREE.currentItem()\n        \n        menu = QMenu(self)\n        act = menu.addAction('Add Menu...')\n        act.setIcon(QIcon(projexui.resources.find('img/folder.png')))\n        act.triggered.connect(self.createMenu)\n        \n        if ( item and item.data(0, Qt.UserRole) == 'menu' ):\n            act = menu.addAction('Rename Menu...')\n            ico = QIcon(projexui.resources.find('img/edit.png'))\n            act.setIcon(ico)\n            act.triggered.connect(self.renameMenu)\n        \n        act = menu.addAction('Add Separator')\n        act.setIcon(QIcon(projexui.resources.find('img/ui/splitter.png')))\n        act.triggered.connect(self.createSeparator)\n        \n        menu.addSeparator()\n        \n        act = menu.addAction('Remove Item')\n        act.setIcon(QIcon(projexui.resources.find('img/remove.png')))\n        act.triggered.connect(self.removeItem)\n        act.setEnabled(item is not None)\n        \n        menu.exec_(QCursor.pos())", "response": "Shows the menu for the current template information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprompt the user to edit the menu template with the given actions.", "response": "def edit( parent, template, actions = None ):\n        \"\"\"\n        Prompts the user to edit the menu template with the given actions. \\\n        If no actions are supplied, then the actions from the parent will \\\n        be used.\n        \n        :param      parent   | <QWidget>\n                    template | <str>\n                    actions  | {<str> name: <QAction>, .. } || None\n        \n        :return     (<str> template, <bool> accepted)\n        \"\"\"\n        # collect the potential actions from the widget\n        if ( actions is None ):\n            actions = {}\n            for action in parent.actions():\n                key = nativestring(action.objectName())\n                if ( not key ):\n                    key = nativestring(action.text()).replace('&', '')\n                \n                if ( key ):\n                    actions[key] = action\n        \n        if ( not actions ):\n            return ('', False)\n        \n        dlg = QDialog(parent)\n        dlg.setWindowTitle('Edit Menu')\n        \n        widget = XMenuTemplateWidget(dlg)\n        widget.setActions(actions)\n        widget.setMenuTemplate(template)\n        widget.layout().setContentsMargins(0, 0, 0, 0)\n        \n        opts = QDialogButtonBox.Save | QDialogButtonBox.Cancel\n        btns = QDialogButtonBox(opts, Qt.Horizontal, dlg)\n        \n        btns.accepted.connect( dlg.accept )\n        btns.rejected.connect( dlg.reject )\n        \n        layout = QVBoxLayout()\n        layout.addWidget(widget)\n        layout.addWidget(btns)\n        \n        dlg.setLayout(layout)\n        dlg.adjustSize()\n        dlg.resize(650, 400)\n        \n        if ( dlg.exec_() ):\n            return (widget.menuTemplate(), True)\n        return ('', False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_app(self, app):\n        host = app.config.get('STATS_HOSTNAME', 'localhost')\n        port = app.config.get('STATS_PORT', 8125)\n        base_key = app.config.get('STATS_BASE_KEY', app.name)\n\n        client = _StatsClient(\n            host=host,\n            port=port,\n            prefix=base_key,\n        )\n\n        app.before_request(client.flask_time_start)\n        app.after_request(client.flask_time_end)\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions.setdefault('stats', {})\n        app.extensions['stats'][self] = client\n\n        return client", "response": "Inititialise the extension with the app object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef depends(func=None, after=None, before=None, priority=None):\n    if not (func is None or inspect.ismethod(func) or inspect.isfunction(func)):\n        raise ValueError(\"depends decorator can only be used on functions or methods\")\n    if not (after or before or priority):\n        raise ValueError(\"depends decorator needs at least one argument\")\n\n    # This avoids some nesting in the decorator\n    # If called without func the decorator was called with optional args\n    # so we'll return a function with those args filled in.\n    if func is None:\n        return partial(depends, after=after, before=before, priority=priority)\n\n    def self_check(a, b):\n        if a == b:\n            raise ValueError(\"Test '{}' cannot depend on itself\".format(a))\n\n    def handle_dep(conditions, _before=True):\n        if conditions:\n            if type(conditions) is not list:\n                conditions = [conditions]\n            for cond in conditions:\n                if hasattr(cond, '__call__'):\n                    cond = cond.__name__\n                self_check(func.__name__, cond)\n                if _before:\n                    soft_dependencies[cond].add(func.__name__)\n                else:\n                    dependencies[func.__name__].add(cond)\n\n    handle_dep(before)\n    handle_dep(after, False)\n\n    if priority:\n        priorities[func.__name__] = priority\n\n    @wraps(func)\n    def inner(*args, **kwargs):\n        return func(*args, **kwargs)\n    return inner", "response": "Decorator to specify test dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting a sequence into two iterables without looping twice", "response": "def split_on_condition(seq, condition):\n    \"\"\"Split a sequence into two iterables without looping twice\"\"\"\n    l1, l2 = tee((condition(item), item) for item in seq)\n    return (i for p, i in l1 if p), (i for p, i in l2 if not p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calculate_dependencies():\n        order = []\n        for g in toposort(merge_dicts(dependencies, soft_dependencies)):\n            for t in sorted(g, key=lambda x: (priorities[x], x)):\n                order.append(t)\n        return order", "response": "Calculate test dependencies\n        First do a topological sorting based on the dependencies.\n        Then sort the different dependency groups based on priorities."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npreparing suite and determine test ordering", "response": "def prepare_suite(self, suite):\n        \"\"\"Prepare suite and determine test ordering\"\"\"\n        all_tests = {}\n        for s in suite:\n            m = re.match(r'(\\w+)\\s+\\(.+\\)', str(s))\n            if m:\n                name = m.group(1)\n            else:\n                name = str(s).split('.')[-1]\n            all_tests[name] = s\n\n        return self.orderTests(all_tests, suite)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an error string if any of the dependencies failed", "response": "def dependency_failed(self, test):\n        \"\"\"Returns an error string if any of the dependencies failed\"\"\"\n        for d in (self.test_name(i) for i in dependencies[test]):\n            if d in (self.test_name(str(t[0])) for t in self.results.failures):\n                return \"Required test '{}' FAILED\".format(d)\n            if d in (self.test_name(str(t[0])) for t in self.results.errors):\n                return \"Required test '{}' ERRORED\".format(d)\n            if d in (self.test_name(str(t[0])) for t in self.results.skipped):\n                return \"Required test '{}' SKIPPED\".format(d)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dependency_ran(self, test):\n        for d in (self.test_name(i) for i in dependencies[test]):\n            if d not in self.ok_results:\n                return \"Required test '{}' did not run (does it exist?)\".format(d)\n        return None", "response": "Returns an error string if any of the dependencies did not run"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef class_path(cls):\n    if cls.__module__ == '__main__':\n        path = None\n    else:\n        path = os.path.dirname(inspect.getfile(cls))\n\n    if not path:\n        path = os.getcwd()\n\n    return os.path.realpath(path)", "response": "Return the path to the source file of the given class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the path to the source file of the current frames caller.", "response": "def caller_path(steps=1):\n    \"\"\"Return the path to the source file of the current frames' caller.\"\"\"\n    frame = sys._getframe(steps + 1)\n\n    try:\n        path = os.path.dirname(frame.f_code.co_filename)\n    finally:\n        del frame\n\n    if not path:\n        path = os.getcwd()\n\n    return os.path.realpath(path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(cls, version_string):\n        match = RE.match(version_string)\n        if match:\n            major_str, minor_str, patch_str, postrelease_alpha, \\\n                postrelease_digit, prerelease_str, build_metadata = \\\n                match.groups()\n\n            if postrelease_digit:\n                postrelease = int(postrelease_digit)\n            else:\n                postrelease = postrelease_alpha\n\n            # A well-defined version cannot both have a pre- and a\n            # post-release identifier.\n            if postrelease and prerelease_str:\n                raise InvalidVersionExpression(version_string)\n\n            major = int(major_str)\n\n            if minor_str:\n                minor = int(minor_str)\n            else:\n                minor = 0\n\n            if patch_str:\n                patch = int(patch_str)\n            else:\n                patch = 0\n\n            if prerelease_str:\n                try:\n                    prerelease = int(prerelease_str)\n                except ValueError:\n                    prerelease = prerelease_str\n            else:\n                prerelease = None\n\n            return cls(major, minor, patch,\n                       postrelease, prerelease, build_metadata)\n\n        else:\n            raise InvalidVersionExpression(version_string)", "response": "Parses a version_string and returns a : py : class ~Version object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find( self, flags = 0 ):\r\n        # check against the web and text views\r\n        if ( not (self._textEdit or self._webView) ):\r\n            fg = QColor('darkRed')\r\n            bg = QColor('red').lighter(180)\r\n            \r\n            palette = self.palette()\r\n            palette.setColor(palette.Text, fg)\r\n            palette.setColor(palette.Base, bg)\r\n            \r\n            self._searchEdit.setPalette(palette)\r\n            self._searchEdit.setToolTip( 'No Text Edit is linked.' )\r\n            \r\n            return False\r\n        \r\n        if ( self._caseSensitiveCheckbox.isChecked() ):\r\n            flags |= QTextDocument.FindCaseSensitively\r\n        \r\n        if ( self._textEdit and self._wholeWordsCheckbox.isChecked() ):\r\n            flags |= QTextDocument.FindWholeWords\r\n        \r\n        terms = self._searchEdit.text()\r\n        if ( terms != self._lastText ):\r\n            self._lastCursor = QTextCursor()\r\n        \r\n        if ( self._regexCheckbox.isChecked() ):\r\n            terms = QRegExp(terms)\r\n        \r\n        palette = self.palette()\r\n        \r\n        # search on a text edit\r\n        if ( self._textEdit ):\r\n            cursor  = self._textEdit.document().find(terms, \r\n                                                 self._lastCursor, \r\n                                                 QTextDocument.FindFlags(flags))\r\n            found   = not cursor.isNull()\r\n            self._lastCursor = cursor\r\n            self._textEdit.setTextCursor(cursor)\r\n        \r\n        elif ( QWebPage ):\r\n            flags = QWebPage.FindFlags(flags)\r\n            flags |= QWebPage.FindWrapsAroundDocument\r\n            \r\n            found = self._webView.findText(terms, flags)\r\n        \r\n        self._lastText = self._searchEdit.text()\r\n        \r\n        if ( not terms or found ):\r\n            fg = palette.color(palette.Text)\r\n            bg = palette.color(palette.Base)\r\n        else:\r\n            fg = QColor('darkRed')\r\n            bg = QColor('red').lighter(180)\r\n        \r\n        palette.setColor(palette.Text, fg)\r\n        palette.setColor(palette.Base, bg)\r\n        \r\n        self._searchEdit.setPalette(palette)\r\n        \r\n        return found", "response": "Returns True if the text document contains at least one entry in the text document."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the text edit that this find widget will use to search for.", "response": "def setTextEdit( self, textEdit ):\r\n        \"\"\"\r\n        Sets the text edit that this find widget will use to search.\r\n        \r\n        :param      textEdit | <QTextEdit>\r\n        \"\"\"\r\n        if ( self._textEdit ):\r\n            self._textEdit.removeAction(self._findAction)\r\n            \r\n        self._textEdit = textEdit\r\n        if ( textEdit ):\r\n            textEdit.addAction(self._findAction)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setWebView( self, webView ):\r\n        if ( self._webView ):\r\n            self._webView.removeAction(self._findAction)\r\n        \r\n        self._webView = webView\r\n        if ( webView ):\r\n            webView.addAction(self._findAction)", "response": "Sets the web view that this find widget will use to search."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresourcing builder with resources url", "response": "def resource(self, *resources):\n        \"\"\"Resource builder with resources url\n\n        :param resources: 'one', 'two', 'three'\n        :return: instance of Resource\n        \"\"\"\n        resources = tuple(self.resources) + resources\n        return Resource(self.client, resources)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmatches the version with the constraint.", "response": "def match(self, version):\n        \"\"\"Match ``version`` with the constraint.\n\n        :param version: Version to match against the constraint.\n        :type version: :ref:`version expression <version-expressions>` or \\\n        :class:`.Version`\n        :rtype: ``True`` if ``version`` satisfies the constraint, \\\n        ``False`` if it doesn't.\n        \"\"\"\n        if isinstance(version, basestring):\n            version = Version.parse(version)\n        return self.operator(version, self.version)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a constraint_expression string and returns a : class:`Constraint` object.", "response": "def parse(cls, constraint_expression):\n        \"\"\"Parses a :ref:`constraint_expression <constraint-expressions>` \\\n        and returns a :class:`Constraint` object.\n\n        :param constraint_expression: A \\\n        :ref:`constraint expression <constraint-expressions>`\n        :type constraint_expression: str\n        :raises: :exc:`InvalidConstraintExpression` when parsing fails.\n        :rtype: :class:`Constraint`\n        \"\"\"\n        match = RE.match(constraint_expression)\n\n        if match:\n            operator_str, version_str = match.groups()\n            operator = Operator.parse(operator_str)\n            version = Version.parse(version_str)\n            return cls(operator, version)\n\n        else:\n            raise InvalidConstraintExpression(constraint_expression)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warnings(filename,\n             board='pro',\n             hwpack='arduino',\n             mcu='',\n                 f_cpu='',\n                 extra_lib='',\n                 ver='',\n             #                 home='auto',\n                 backend='arscons',\n             ):\n    '''\n    build Arduino sketch and display results\n    '''\n    cc = Arduino(\n        board=board,\n        hwpack=hwpack,\n        mcu=mcu,\n        f_cpu=f_cpu,\n        extra_lib=extra_lib,\n        ver=ver,\n        #                 home=home,\n        backend=backend,\n    )\n    cc.build(filename)\n\n    print 'backend:', cc.backend\n    print 'MCU:', cc.mcu_compiler()\n#    print 'avr-gcc:', AvrGcc().version()\n\n    print\n    print('=============================================')\n    print('SIZE')\n    print('=============================================')\n    print 'program:', cc.size().program_bytes\n    print 'data:', cc.size().data_bytes\n\n    core_warnings = [x for x in cc.warnings if 'gcc' in x] + [\n        x for x in cc.warnings if 'core' in x]\n    lib_warnings = [x for x in cc.warnings if 'lib_' in x]\n    notsketch_warnings = core_warnings + lib_warnings\n    sketch_warnings = [x for x in cc.warnings if x not in notsketch_warnings]\n\n    print\n    print('=============================================')\n    print('WARNINGS')\n    print('=============================================')\n    print\n    print('core')\n    print('-------------------')\n    print('\\n'.join(core_warnings))\n    print\n    print('lib')\n    print('-------------------')\n    print('\\n'.join(lib_warnings))\n    print\n    print('sketch')\n    print('-------------------')\n    print('\\n'.join(sketch_warnings))", "response": "prints out the warnings of the current language"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the date at the inputed x position.", "response": "def dateAt(self, x):\r\n        \"\"\"\r\n        Returns the date at the inputed x position.\r\n        \r\n        :return     <QDate>\r\n        \"\"\"\r\n        gantt       = self.ganttWidget()\r\n        dstart      = gantt.dateStart()\r\n        days        = int(x / float(gantt.cellWidth()))\r\n        \r\n        return dstart.addDays(days)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the datetime at the inputed x position.", "response": "def datetimeAt(self, x):\r\n        \"\"\"\r\n        Returns the datetime at the inputed x position.\r\n        \r\n        :return     <QDateTime>\r\n        \"\"\"\r\n        gantt = self.ganttWidget()\r\n        dstart = gantt.dateTimeStart()\r\n        distance = int(x / float(gantt.cellWidth()))\r\n        \r\n        # calculate the time for a minute\r\n        if scale == gantt.Timescale.Minute:\r\n            return dstart.addSecs(distance)\r\n        \r\n        # calculate the time for an hour\r\n        elif scale == gantt.Timescale.Hour:\r\n            return dstart.addSecs(distance * 2.0)\r\n\r\n        # calculate the time for a day\r\n        elif scale == gantt.Timescale.Day:\r\n            dstart = QDateTime(gantt.dateStart(), QTime(0, 0, 0))\r\n            return dstart.addSecs(distance * (60 * 2.0))\r\n        \r\n        # calculate the time off the date only\r\n        else:\r\n            date = self.dateAt(x)\r\n            return QDateTime(date, QTime(0, 0, 0))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the x - position of the inputed date.", "response": "def dateXPos(self, date):\r\n        \"\"\"\r\n        Returns the x-position for the inputed date.\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        gantt = self.ganttWidget()\r\n        distance = gantt.dateStart().daysTo(date)\r\n        return gantt.cellWidth() * distance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef datetimeXPos(self, dtime):\r\n        gantt = self.ganttWidget()\r\n        scale = gantt.timescale()\r\n        \r\n        # calculate the distance for a minute\r\n        if scale == gantt.Timescale.Minute:\r\n            dstart = gantt.dateTimeStart()\r\n            secs = dstart.secsTo(dtime)\r\n            return secs\r\n        \r\n        # calculate the distance for an hour\r\n        elif scale == gantt.Timescale.Hour:\r\n           dstart = gantt.dateTimeStart()\r\n           secs = dstart.secsTo(dtime)\r\n           return secs / 2.0\r\n        \r\n        # calculate the distance for a day\r\n        elif scale == gantt.Timescale.Day:\r\n            dstart = QDateTime(gantt.dateStart(), QTime(0, 0, 0))\r\n            secs = dstart.secsTo(dtime)\r\n            return (secs / (60.0 * 2.0))\r\n        \r\n        # calculate the distance off the date only\r\n        else:\r\n            return self.dateXPos(dtime.date())", "response": "Returns the x - position of the inputed date time."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws the foreground for this scene.", "response": "def drawForeground(self, painter, rect):\r\n        \"\"\"\r\n        Draws the foreground for this scene.\r\n        \r\n        :param      painter | <QPainter>\r\n                    rect    | <QRect>\r\n        \"\"\"\r\n        gantt  = self.ganttWidget()\r\n        header = gantt.treeWidget().header()\r\n        width  = self.sceneRect().width()\r\n        height = header.height()\r\n        \r\n        for tile_rect, tile in self._tiles:\r\n            painter.drawPixmap(tile_rect.x(), rect.top(), tile)\r\n        \r\n        palette = self.palette()\r\n        textColor = palette.color(palette.Button).darker(125)\r\n        painter.setPen(textColor)\r\n        painter.drawLine(0, rect.top() + height, width, rect.top() + height)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing the background for the current date.", "response": "def drawBackground(self, painter, rect):\r\n        \"\"\"\r\n        Draws the background for this scene.\r\n        \r\n        :param      painter | <QPainter>\r\n                    rect    | <QRect>\r\n        \"\"\"\r\n        if self._dirty:\r\n            self.rebuild()\r\n        \r\n        # draw the alternating rects\r\n        gantt   = self.ganttWidget()\r\n        \r\n        # draw the alternating rects\r\n        painter.setPen(Qt.NoPen)\r\n        painter.setBrush(gantt.alternateBrush())\r\n        for rect in self._alternateRects:\r\n            painter.drawRect(rect)\r\n        \r\n        # draw the weekends\r\n        painter.setBrush(gantt.weekendBrush())\r\n        for rect in self._weekendRects:\r\n            painter.drawRect(rect)\r\n        \r\n        # draw the default background\r\n        painter.setPen(gantt.gridPen())\r\n        painter.drawLines(self._hlines + self._vlines)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rebuild(self):\r\n        gantt = self.ganttWidget()\r\n        scale = gantt.timescale()\r\n        rect = self.sceneRect()\r\n        header = gantt.treeWidget().header()\r\n        \r\n        # define the rendering options\r\n        options = {}\r\n        options['start']         = gantt.dateStart()\r\n        options['end']           = gantt.dateEnd()\r\n        options['cell_width']    = gantt.cellWidth()\r\n        options['cell_height']   = gantt.cellHeight()\r\n        options['rect']          = rect\r\n        options['height']        = rect.height()\r\n        \r\n        options['header_height'] = header.height()\r\n        if not header.isVisible():\r\n            options['header_height'] = 0\r\n        \r\n        opt = XGanttRenderOptions(**options)\r\n        \r\n        # rebuild the minute timescale\r\n        if scale in (gantt.Timescale.Minute, gantt.Timescale.Hour):\r\n            opt.start = gantt.dateTimeStart()\r\n            opt.end = gantt.dateTimeEnd()\r\n            \r\n            self.rebuildHour(opt)\r\n        \r\n        # rebuild the day timescale\r\n        elif scale == gantt.Timescale.Day:\r\n            self.rebuildDay(opt)\r\n        \r\n        # rebuild the week timescale\r\n        elif scale == gantt.Timescale.Week:\r\n            self.rebuildWeek(opt)\r\n        \r\n        self.rebuildTiles()", "response": "Rebuilds the scene based on the current settings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrebuilding the scale for the day mode.", "response": "def rebuildDay(self, opt):\r\n        \"\"\"\r\n        Rebuilds the scale for the day mode.\r\n        \r\n        :param      opt | <XGanttRenderOptions>\r\n        \"\"\"\r\n        self._labels            = []\r\n        self._hlines            = []\r\n        self._vlines            = []\r\n        self._weekendRects      = []\r\n        self._alternateRects    = []\r\n        self._topLabels         = []\r\n        \r\n        top_format = 'dddd MMMM dd'\r\n        label_format = 'ha'\r\n        increment = 60 # hour\r\n        \r\n        # generate vertical lines\r\n        x           = 0\r\n        i           = 0\r\n        half        = opt.header_height / 2.0\r\n        curr        = QDateTime(opt.start, QTime(0, 0, 0))\r\n        end         = QDateTime(opt.end, QTime(23, 0, 0))\r\n        top_label   = opt.start.toString(top_format)\r\n        top_rect    = QRect(0, 0, 0, half)\r\n        alt_rect    = None\r\n        \r\n        while curr <= end:\r\n            # update the top rect\r\n            new_top_label = curr.toString(top_format)\r\n            if new_top_label != top_label:\r\n                top_rect.setRight(x)\r\n                self._topLabels.append((top_rect, top_label))\r\n                top_rect  = QRect(x, 0, 0, half)\r\n                top_label = new_top_label\r\n                \r\n                if alt_rect is not None:\r\n                    alt_rect.setRight(x)\r\n                    self._alternateRects.append(alt_rect)\r\n                    alt_rect = None\r\n                else:\r\n                    alt_rect = QRect(x, 0, 0, opt.height)\r\n            \r\n            # create the line\r\n            self._hlines.append(QLine(x, 0, x, opt.height))\r\n            \r\n            # create the header label/rect\r\n            label = nativestring(curr.toString(label_format))[:-1]\r\n            rect  = QRect(x, half, opt.cell_width, half)\r\n            self._labels.append((rect, label))\r\n            \r\n            # increment the dates\r\n            curr = curr.addSecs(increment * 60)\r\n            x += opt.cell_width\r\n            i += 1\r\n        \r\n        # update the top rect\r\n        top_rect.setRight(x)\r\n        top_label = opt.end.toString(top_format)\r\n        self._topLabels.append((top_rect, top_label))\r\n        \r\n        if alt_rect is not None:\r\n            alt_rect.setRight(x)\r\n            self._alternateRects.append(alt_rect)\r\n        \r\n        # resize the width to match the last date range\r\n        new_width = x\r\n        self.setSceneRect(0, 0, new_width, opt.height)\r\n        \r\n        # generate horizontal lines\r\n        y       = 0\r\n        h       = opt.height\r\n        width   = new_width\r\n        \r\n        while y < h:\r\n            self._vlines.append(QLine(0, y, width, y))\r\n            y += opt.cell_height\r\n        \r\n        # clear the dirty flag\r\n        self._dirty = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the day width that will be used for drawing this gantt widget.", "response": "def setDayWidth(self, width):\r\n        \"\"\"\r\n        Sets the day width that will be used for drawing this gantt widget.\r\n        \r\n        :param      width | <int>\r\n        \"\"\"\r\n        self._dayWidth = width\r\n        \r\n        start = self.ganttWidget().dateStart()\r\n        end = self.ganttWidget().dateEnd()\r\n        \r\n        self._dirty = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverloading the setSceneRect method to signal that the scene is rebuilt.", "response": "def setSceneRect(self, *args):\r\n        \"\"\"\r\n        Overloads the set rect method to signal that the scene needs to be \r\n        rebuilt.\r\n        \r\n        :param      args | <arg variant>\r\n        \"\"\"\r\n        curr = self.sceneRect()\r\n        \r\n        super(XGanttScene, self).setSceneRect(*args)\r\n        \r\n        if curr != QRectF(*args):\r\n            self._dirty = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef accept( self ):\n        if ( not self.save() ):\n            return\n            \n        for i in range(self.uiActionTREE.topLevelItemCount()):\n            item = self.uiActionTREE.topLevelItem(i)\n            action = item.action()\n            action.setShortcut( QKeySequence(item.text(1)) )\n        \n        super(XShortcutDialog, self).accept()", "response": "Saves the current settings for the actions in the list and exits the dialog."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of actions that are associated with this shortcut edit.", "response": "def actions( self ):\n        \"\"\"\n        Returns a list of actions that are associated with this shortcut edit.\n        \n        :return     [<QAction>, ..]\n        \"\"\"\n        output = []\n        for i in range(self.uiActionTREE.topLevelItemCount()):\n            output.append(self.uiActionTREE.topLevelItem(i).action())\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclears the current settings for the current action.", "response": "def clear( self ):\n        \"\"\"\n        Clears the current settings for the current action.\n        \"\"\"\n        item = self.uiActionTREE.currentItem()\n        if ( not item ):\n            return\n        \n        self.uiShortcutTXT.setText('')\n        item.setText(1, '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters out key press events for the shortcut section for this edit.", "response": "def eventFilter( self, object, event ):\n        \"\"\"\n        Filters out key press events for the shortcut section for this edit.\n        \n        :param      object | <QObject>\n                    event  | <QEvent>\n        \"\"\"\n        if ( object != self.uiShortcutTXT ):\n            return False\n            \n        if ( event.type() == event.KeyPress ):\n            seq = QKeySequence(event.key() + int(event.modifiers()))\n            self.uiShortcutTXT.setText( seq.toString() )\n            return True\n            \n        elif ( event.type() == event.KeyRelease):\n            return True\n        \n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setActions( self, actions ):\n        self.uiActionTREE.blockSignals(True)\n        self.uiActionTREE.setUpdatesEnabled(False)\n        \n        self.uiActionTREE.clear()\n        for action in actions:\n            self.uiActionTREE.addTopLevelItem(ActionItem(action))\n        \n        self.uiActionTREE.sortByColumn(0, Qt.AscendingOrder)\n        self.uiActionTREE.blockSignals(False)\n        self.uiActionTREE.setUpdatesEnabled(True)", "response": "Sets the list of actions that will be used for this shortcut dialog when editing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the action to edit based on the current item.", "response": "def updateAction( self ):\n        \"\"\"\n        Updates the action to edit based on the current item.\n        \"\"\"\n        item = self.uiActionTREE.currentItem()\n        if ( item ):\n            action = item.action()\n        else:\n            action = QAction()\n            \n        self.uiShortcutTXT.setText(action.shortcut().toString())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprompt the user to edit the inputed key value pairing.", "response": "def edit( key = '', value = '', parent = None ):\n        \"\"\"\n        Prompts the user to edit the inputed key/value pairing.\n        \n        :param      key     | <str>\n                    value   | <str>\n                    parent  | <QWidget>\n        \n        :return     (<bool> accepted, <str> key, <str> value)\n        \"\"\"\n        dlg = XKeyValueDialog(parent)\n        dlg.setKey(key)\n        dlg.setValue(value)\n        \n        if ( dlg.exec_() ):\n            return (True, dlg.key(), dlg.value())\n        \n        return (False, '', '')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculateDatasets(self, scene, axes, datasets):\r\n        items = self.calculateDatasetItems(scene, datasets)\r\n        if not items:\r\n            scene.clear()\r\n            return\r\n        \r\n        rect = self.buildData('axis_rect')\r\n        \r\n        for dataset, item in items.items():\r\n            first = True\r\n            pos = None\r\n            home = None\r\n            ellipses = []\r\n            \r\n            path = QPainterPath()\r\n            for value in dataset.values():\r\n                pos = self.pointAt(axes, value)\r\n                ellipses.append(pos)\r\n                \r\n                if first:\r\n                    path.moveTo(pos)\r\n                    first = False\r\n                else:\r\n                    path.lineTo(pos)\r\n            \r\n            item.setPath(path)\r\n            item.setBuildData('ellipses', ellipses)", "response": "Calculates the datasets for this renderer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndrawing the item as a bar graph.", "response": "def drawItem(self, item, painter, option):\r\n        \"\"\"\r\n        Draws the inputed item as a bar graph.\r\n        \r\n        :param      item    | <XChartDatasetItem>\r\n                    painter | <QPainter>\r\n                    option  | <QStyleOptionGraphicsItem>\r\n        \"\"\"\r\n        dataset = item.dataset()\r\n        \r\n        painter.save()\r\n        painter.setRenderHint(painter.Antialiasing)\r\n        \r\n        pen = QPen(dataset.color())\r\n        pen.setWidth(3)\r\n        painter.setPen(pen)\r\n        painter.setBrush(Qt.NoBrush)\r\n        painter.drawPath(item.path())\r\n        \r\n        if self.showPoints():\r\n            palette = QApplication.palette()\r\n            pen = QPen(palette.color(palette.Base))\r\n            pen.setWidth(2)\r\n            \r\n            painter.setBrush(dataset.color())\r\n            painter.setPen(pen)\r\n            \r\n            for point in item.buildData('ellipses', []):\r\n                painter.drawEllipse(point,\r\n                                    self.pointRadius(),\r\n                                    self.pointRadius())\r\n        \r\n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nflatten the return values of the mite api.", "response": "def declassify(to_remove, *args, **kwargs):\n    \"\"\" flatten the return values of the mite api.\n    \"\"\"\n    def argdecorate(fn):\n        \"\"\" enable the to_remove argument to the decorator. \"\"\"\n        # wrap the function to get the original docstring\n        @wraps(fn)\n        def declassed(*args, **kwargs):\n            # call the method\n            ret = fn(*args, **kwargs)\n            # catch errors that are thrown by the api\n            try:\n                # ensure that ret is a list\n                if type(ret) is list:\n                    return [r[to_remove] for r in ret]\n                return ret[to_remove]\n            except KeyError:\n                return ret\n        return declassed\n    return argdecorate"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean_dict(d):\n    ktd = list()\n    for k, v in d.items():\n        if not v:\n            ktd.append(k)\n        elif type(v) is dict:\n            d[k] = clean_dict(v)\n    for k in ktd:\n        d.pop(k)\n    return d", "response": "Remove the keys with None values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef defineOperator( self, operator, widget = -1 ):\n        if ( widget == -1 ):\n            widget = QLineEdit\n            \n        self._operators[nativestring(operator)] = widget", "response": "Adds a new operator for this rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef operatorLabel( self, operator ):\r\n        for key, value in self._operatorMap.items():\r\n            if ( value == operator ):\r\n                return key\r\n        return operator", "response": "Returns the label for the inputed operator."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the children for this item.", "response": "def load(self):\r\n        \"\"\"\r\n        Loads the children for this item.\r\n        \"\"\"\r\n        if self._loaded:\r\n            return\r\n        \r\n        self.setChildIndicatorPolicy(self.DontShowIndicatorWhenChildless)\r\n        \r\n        self._loaded = True\r\n        column = self.schemaColumn()\r\n        if not column.isReference():\r\n            return\r\n        \r\n        ref = column.referenceModel()\r\n        if not ref:\r\n            return\r\n        \r\n        columns = sorted(ref.schema().columns(),\r\n                         key=lambda x: x.name().strip('_'))\r\n        for column in columns:\r\n            XOrbColumnItem(self, column)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCurrentSchemaColumn(self, column):\r\n        if column == self._column:\r\n            self.treeWidget().setCurrentItem(self)\r\n            return True\r\n        \r\n        for c in range(self.childCount()):\r\n            if self.child(c).setCurrentSchemaColumn(column):\r\n                self.setExpanded(True)\r\n                return True\r\n        return None", "response": "Sets the current item based on the inputed column."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current item based on the inputed column.", "response": "def setCurrentSchemaPath(self, path):\r\n        \"\"\"\r\n        Sets the current item based on the inputed column.\r\n        \r\n        :param      path | <str>\r\n        \"\"\"\r\n        if not path:\r\n            return False\r\n        \r\n        parts = path.split('.')\r\n        name  = parts[0]\r\n        next  = parts[1:]\r\n        \r\n        if name == self.text(0):\r\n            if next:\r\n                self.load()\r\n                path = '.'.join(next)\r\n                for c in range(self.childCount()):\r\n                    if self.child(c).setCurrentSchemaPath(path):\r\n                        self.setExpanded(True)\r\n                        return True\r\n                return False\r\n            else:\r\n                self.treeWidget().setCurrentItem(self)\r\n                return True\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef currentSchemaPath(self):\r\n        item = self.currentItem()\r\n        path = []\r\n        while item:\r\n            path.append(nativestring(item.text(0)))\r\n            item = item.parent()\r\n        \r\n        return '.'.join(reversed(path))", "response": "Returns the path to the current schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrefreshes the data for this navigator.", "response": "def refresh(self):\r\n        \"\"\"\r\n        Resets the data for this navigator.\r\n        \"\"\"\r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        self.clear()\r\n        tableType = self.tableType()\r\n        if not tableType:\r\n            self.setUpdatesEnabled(True)\r\n            self.blockSignals(False)\r\n            return\r\n        \r\n        schema = tableType.schema()\r\n        columns = list(sorted(schema.columns(),\r\n                              key=lambda x: x.name().strip('_')))\r\n        for column in columns:\r\n            XOrbColumnItem(self, column)\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrentSchemaColumn(self, column):\r\n        if not column:\r\n            self.setCurrentItem(None)\r\n            return\r\n        \r\n        for item in self.topLevelItems():\r\n            if item.setCurrentSchemaColumn(column):\r\n                return\r\n        \r\n        self.setCurrentItem(None)", "response": "Sets the current column associated with this navigator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the column path for the current item.", "response": "def setCurrentSchemaPath(self, path):\r\n        \"\"\"\r\n        Sets the column path for the current item.  This will be a '.'\r\n        joined path based on the root schema to the given column.\r\n        \r\n        :param      path | <str>\r\n        \"\"\"\r\n        if not path:\r\n            self.setCurrentItem(None)\r\n            return False\r\n        \r\n        for item in self.topLevelItems():\r\n            if item.setCurrentSchemaPath(nativestring(path)):\r\n                return True\r\n        \r\n        self.setCurrentItem(None)\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the lineEdit to reflect the current column.", "response": "def acceptColumn(self):\r\n        \"\"\"\r\n        Accepts the current item as the current column.\r\n        \"\"\"\r\n        self.navigator().hide()\r\n        self.lineEdit().setText(self.navigator().currentSchemaPath())\r\n        self.emitSchemaColumnChanged(self.navigator().currentColumn())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nemitting the current schema path changed signal.", "response": "def emitSchemaColumnChanged(self, column):\r\n        \"\"\"\r\n        Emits the current column changed signal.\r\n        \r\n        :param      column | <orb.Column> || None\r\n        \"\"\"\r\n        edit = self.lineEdit()\r\n        if edit:\r\n            edit.setText(self.navigator().currentSchemaPath())\r\n            \r\n        if not self.signalsBlocked():\r\n            self.schemaColumnChanged.emit(column)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter events for the popup tree widget.", "response": "def eventFilter(self, object, event):\r\n        \"\"\"\r\n        Filters events for the popup tree widget.\r\n        \r\n        :param      object | <QObject>\r\n                    event  | <QEvent>\r\n        \r\n        :retuen     <bool> | consumed\r\n        \"\"\"\r\n        try:\r\n            is_lineedit = object == self.lineEdit()\r\n        except RuntimeError:\r\n            is_lineedit = False\r\n        \r\n        try:\r\n            is_nav = object == self._navigator\r\n        except RuntimeError:\r\n            is_nav = False\r\n        \r\n        if not (is_nav or is_lineedit):\r\n            return super(XOrbColumnNavigatorBox, self).eventFilter(object, event)\r\n        \r\n        if event.type() == event.KeyPress:\r\n            # accept lookup\r\n            if event.key() in (Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab):\r\n                self.acceptColumn()\r\n                event.accept()\r\n                return True\r\n                \r\n            # cancel lookup\r\n            elif event.key() == Qt.Key_Escape:\r\n                self.hidePopup()\r\n                event.accept()\r\n                return True\r\n            \r\n            # update the search info\r\n            else:\r\n                self.lineEdit().keyPressEvent(event)\r\n                event.accept()\r\n                return True\r\n        \r\n        elif is_nav and event.type() == event.Show:\r\n            object.resizeToContents()\r\n            object.horizontalScrollBar().setValue(0)\r\n            \r\n        elif event.type() == event.KeyRelease:\r\n            self.lineEdit().keyReleaseEvent(event)\r\n            self.navigator().blockSignals(True)\r\n            self.navigator().setCurrentSchemaPath(self.lineEdit().text())\r\n            self.navigator().blockSignals(False)\r\n            event.accept()\r\n            return True\r\n        \r\n        elif event.type() == event.MouseButtonPress:\r\n            local_pos = object.mapFromGlobal(event.globalPos())\r\n            in_widget = object.rect().contains(local_pos)\r\n            \r\n            if not in_widget:\r\n                self.hidePopup()\r\n                event.accept()\r\n                return True\r\n            \r\n        return super(XOrbColumnNavigatorBox, self).eventFilter(object, event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the navigator associated with this box.", "response": "def navigator(self):\r\n        \"\"\"\r\n        Returns the navigator associated with this box.\r\n        \r\n        :return     <XOrbColumnNavigator>\r\n        \"\"\"\r\n        if self._navigator is None:\r\n            self._navigator = nav = XOrbColumnNavigator()\r\n            self.lineEdit().setCompleter(None)\r\n            \r\n            # initialize settings\r\n            nav.hide()\r\n            nav.header().hide()\r\n            nav.setWindowFlags(Qt.Popup)\r\n            nav.setFocusPolicy(Qt.ClickFocus)\r\n            nav.installEventFilter(self)\r\n            nav.setVerticalScrollMode(nav.ScrollPerPixel)\r\n            \r\n            # create connections\r\n            nav.itemClicked.connect(self.acceptColumn)\r\n            self.lineEdit().textEdited.connect(self.showPopup)\r\n            nav.schemaColumnChanged.connect(self.emitSchemaColumnChanged)\r\n        \r\n        return self._navigator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the table type associated with this navigator.", "response": "def setTableType(self, tableType):\r\n        \"\"\"\r\n        Sets the table type associated with this navigator.\r\n        \r\n        :param      tableType | <subclass of orb.Table>\r\n        \"\"\"\r\n        self.navigator().setTableType(tableType)\r\n        completer = XJoinCompleter(self.navigator().model(), self)\r\n        completer.setCompletionMode(XJoinCompleter.InlineCompletion)\r\n        self.setCompleter(completer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays the popup associated with this navigator.", "response": "def showPopup(self):\r\n        \"\"\"\r\n        Displays the popup associated with this navigator.\r\n        \"\"\"\r\n        nav = self.navigator()\r\n        \r\n        nav.move(self.mapToGlobal(QPoint(0, self.height())))\r\n        nav.resize(400, 250)\r\n        nav.show()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculateRange(self, values):\r\n        vals = filter(lambda x: x is not None, values)\r\n        \r\n        try:\r\n            min_val = min(min(vals), 0)\r\n        except ValueError:\r\n            min_val = 0\r\n        \r\n        try:\r\n            max_val = max(max(vals), 0)\r\n        except ValueError:\r\n            max_val = 10\r\n        \r\n        ndigits  = max(len(nativestring(abs(int(min_val)))), len(nativestring(abs(int(max_val)))))\r\n        rounding = 10 ** (ndigits - 1)\r\n        \r\n        self.setRoundTo(rounding)\r\n        self.setMinimum(self.rounded(min_val, rounding))\r\n        self.setMaximum(self.rounded(max_val, rounding))\r\n        self.reset()", "response": "Calculates the range of values for this axis based on the dataset\r\n            value amount."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of values for the most recent values for the given time series.", "response": "def calculateValues(self):\r\n        \"\"\"\r\n        Overloads the calculate values method to calculate the values for\r\n        this axis based on the minimum and maximum values, and the number\r\n        of steps desired.\r\n        \r\n        :return     [<variant>, ..]\r\n        \"\"\"\r\n        if self.maximum() <= self.minimum():\r\n            return []\r\n        \r\n        max_labels = self.maximumLabelCount()\r\n        step = (self.maximum() - self.minimum()) / float(max_labels)\r\n        step = int(round(step))\r\n        if not step:\r\n            step = 1\r\n        \r\n        values = []\r\n        value = self.minimum()\r\n        roundto = self.roundTo()\r\n        first = True\r\n        while value <= self.maximum():\r\n            if not first and roundto < self.maximum():\r\n                value = self.rounded(value)\r\n            \r\n            first = False\r\n            values.append(value)\r\n            value += step\r\n        \r\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the percentage of value represents between the minimum and maximum for this axis.", "response": "def percentAt(self, value):\r\n        \"\"\"\r\n        Returns the percentage the value represents between the minimum and\r\n        maximum for this axis.\r\n        \r\n        :param      value | <int> || <float>\r\n        \r\n        :return     <float>\r\n        \"\"\"\r\n        min_val = self.minimum()\r\n        max_val = self.maximum()\r\n        \r\n        if value < min_val:\r\n            return 0.0\r\n        elif max_val < value:\r\n            return 1.0\r\n        \r\n        # round the max value to sync with the values in the grid\r\n        max_val = self.rounded(max_val)\r\n        \r\n        try:\r\n            perc = (value - min_val) / float(max_val - min_val)\r\n        except (TypeError, ZeroDivisionError):\r\n            return 0.0\r\n        \r\n        return max(min(perc, 1.0), 0.0)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef percentOfTotal(self, value, values):\r\n        try:\r\n            return float(value) / sum(values)\r\n        except (ZeroDivisionError, TypeError, ValueError):\r\n            return 0.0", "response": "Returns the percentage of total value in the inputed value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rounded(self, number, roundto=None):\r\n        if roundto is None:\r\n            roundto = self.roundTo()\r\n        \r\n        if not roundto:\r\n            return number\r\n    \r\n        remain = number % roundto\r\n        if remain:\r\n            return number + (roundto - remain)\r\n        return number", "response": "Rounds the inputed number to the nearest value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef roundTo(self):\r\n        if self._roundTo is None:\r\n            min_val = max(self.minimum(), 1)\r\n            max_val = max(self.maximum(), 1)\r\n            max_labels = self.maximumLabelCount()\r\n            \r\n            return int(round((max_val - min_val) / float(max_labels)))\r\n            \r\n        return self._roundTo", "response": "Returns the number of times this calendar should be rounded to."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value at the given percent for this axis.", "response": "def valueAt(self, percent):\r\n        \"\"\"\r\n        Returns the value the percent represents between the minimum and\r\n        maximum for this axis.\r\n        \r\n        :param      value | <int> || <float>\r\n        \r\n        :return     <float>\r\n        \"\"\"\r\n        min_val = self.minimum()\r\n        max_val = self.maximum()\r\n        \r\n        # round the max value to sync with the values in the grid\r\n        max_val = self.rounded(max_val)\r\n        range_val = max(min(percent, 1.0), 0.0) * (max_val - min_val)\r\n        return round(range_val + min_val, 1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the sha256 hash of the content.", "response": "def sha256(content):\n    \"\"\"Finds the sha256 hash of the content.\"\"\"\n    if isinstance(content, str):\n        content = content.encode('utf-8')\n    return hashlib.sha256(content).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cursor(self, as_dict=False):\n        self.ensure_connect()\n        ctype = self.real_ctype(as_dict)\n        return self._connect.cursor(ctype)", "response": "Gets the cursor by type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the central widget for this popup button.", "response": "def setCentralWidget(self, widget, createsNew=True, autoCommit=True):\r\n        \"\"\"\r\n        Sets the central widget for this popup button.  If createsNew is set\r\n        to True, then the about to show signal from the popup will be linked to\r\n        the widget's reset slot.  If autoCommit is set to True, then the widget\r\n        will commit it's information to the database.\r\n        \r\n        :param      widget | <prjexui.widgets.xorbrecordwidget.XOrbRecordWidget>\r\n                    createsNew | <bool>\r\n                    autoCommit | <boo>\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        if not isinstance(widget, XOrbRecordWidget):\r\n            return False\r\n        \r\n        # assign the widget\r\n        super(XOrbPopupButton, self).setCentralWidget(widget)\r\n        \r\n        # setup widget options\r\n        widget.setAutoCommitOnSave(autoCommit)\r\n        \r\n        # setup popup options\r\n        popup = self.popupWidget()\r\n        popup.setAutoCloseOnAccept(False)\r\n        \r\n        if createsNew and widget.multipleCreateEnabled():\r\n            btn = popup.addButton('Save && Create Another')\r\n            btn.clicked.connect(widget.saveSilent)\r\n        \r\n        # create connections\r\n        popup.accepted.connect(widget.save)\r\n        widget.saved.connect(popup.close)\r\n        widget.saved.connect(self.saved)\r\n        \r\n        if createsNew:\r\n            popup.aboutToShow.connect(widget.reset)\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget members of current team", "response": "def members(self):\n        \"\"\"Gets members of current team\n\n        Returns:\n            list of User\n\n        Throws:\n            RTMServiceError when request failed\n        \"\"\"\n        resp = self._rtm_client.get('v1/current_team.members?all=true')\n        if resp.is_fail():\n            raise RTMServiceError(\n                'Failed to get members of current team',\n                resp\n            )\n        return resp.data['result']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef channels(self):\n        resp = self._rtm_client.get('v1/current_team.channels')\n        if resp.is_fail():\n            raise RTMServiceError(\n                'Failed to get channels of current team',\n                resp\n            )\n        return resp.data['result']", "response": "Gets the list of channels of current team"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting user information by user id", "response": "def info(self, user_id):\n        \"\"\"Gets user information by user id\n\n        Args:\n            user_id(int): the id of user\n\n        Returns:\n            User\n\n        Throws:\n            RTMServiceError when request failed\n        \"\"\"\n        resp = self._rtm_client.get('v1/user.info?user_id={}'.format(user_id))\n        if resp.is_fail():\n            raise RTMServiceError('Failed to get user information', resp)\n\n        return resp.data['result']"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the channel information by channel id", "response": "def info(self, channel_id):\n        \"\"\"Gets channel information by channel id\n\n        Args:\n            channel_id(int): the id of channel\n\n        Returns:\n            Channel\n\n        Throws:\n            RTMServiceError when request failed\n        \"\"\"\n        resource = 'v1/channel.info?channel_id={}'.format(channel_id)\n        resp = self._rtm_client.get(resource)\n        if resp.is_fail():\n            raise RTMServiceError(\"Failed to get channel information\", resp)\n\n        return resp.data['result']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setLanguage(self, language):\r\n        cls = XCodeHighlighter.byName(language)\r\n        if cls:\r\n            self._highlighter = cls(self.document())", "response": "Sets the language for this code."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _transform_to_dict(result):\n        result_dict = {}\n        property_list = result.item\n        for item in property_list:\n            result_dict[item.key[0]] = item.value[0]\n        return result_dict", "response": "Transform the array from Ideone into a Python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the Ideone language list into a Python dictionary.", "response": "def _collapse_language_array(language_array):\n        \"\"\"\n        Convert the Ideone language list into a Python dictionary.\n        \"\"\"\n        language_dict = {}\n        for language in language_array.item:\n            key = language.key[0]\n            value = language.value[0]\n            language_dict[key] = value\n\n        return language_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _translate_language_name(self, language_name):\n\n        languages = self.languages()\n        language_id = None\n\n        # Check for exact match first including the whole version\n        # string\n        for ideone_index, ideone_language in languages.items():\n            if ideone_language.lower() == language_name.lower():\n                return ideone_index\n\n        # Check for a match of just the language name without any\n        # version information\n        simple_languages = dict((k,v.split('(')[0].strip())\n                                for (k,v) in languages.items())\n        for ideone_index, simple_name in simple_languages.items():\n            if simple_name.lower() == language_name.lower():\n                return ideone_index\n\n        # Give up, but first find a similar name, suggest it and error\n        # out\n        language_choices = languages.values() + simple_languages.values()\n        similar_choices = difflib.get_close_matches(language_name,\n                                                    language_choices,\n                                                    n=3,\n                                                    cutoff=0.3)\n        # Add quotes and delimit with strings for easier to read\n        # output\n        similar_choices_string = \", \".join([\"'\" + s + \"'\"\n                                            for s in similar_choices])\n        error_string = (\"Couldn't match '%s' to an Ideone accepted language.\\n\"\n                        \"Did you mean one of the following: %s\")\n        raise IdeoneError(error_string % (language_name, similar_choices_string))", "response": "Translate a human readable langauge name into its Ideone language name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_submission(self, source_code, language_name=None, language_id=None,\n                          std_input=\"\", run=True, private=False):\n        \"\"\"\n        Create a submission and upload it to Ideone.\n\n        Keyword Arguments\n        -----------------\n\n        * source_code: a string of the programs source code\n        * language_name: the human readable language string (e.g. 'python')\n        * language_id: the ID of the programming language\n        * std_input: the string to pass to the program on stdin\n        * run: a boolean flag to signifying if Ideone should compile and\n               run the program\n        * private: a boolean flag signifying the code is private\n\n        Returns\n        -------\n\n        A dictionary with the keys error and link.  The link is the\n        unique id of the program.  The URL of the submission is\n        http://ideone.com/LINK.\n\n        Examples\n        --------\n\n        >>> ideone_object = Ideone('username', 'password')\n        >>> ideone_object.create_submission('print(42)', language_name='python')\n        {'error': 'OK',\n         'link' : 'LsSbo'}\n\n        \"\"\"\n        language_id = language_id or self._translate_language_name(language_name)\n        result = self.client.service.createSubmission(self.user, self.password,\n                                                      source_code, language_id,\n                                                      std_input, run, private)\n        result_dict = Ideone._transform_to_dict(result)\n        Ideone._handle_error(result_dict)\n        return result_dict", "response": "Create a submission and upload it to Ideone."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the status of a submission.", "response": "def submission_status(self, link):\n        \"\"\"\n        Given the unique link of a submission, returns its current\n        status.\n\n        Keyword Arguments\n        -----------------\n\n        * link: the unique id string of a submission\n\n        Returns\n        -------\n\n        A dictionary of the error, the result code and the status\n        code.\n\n        Notes\n        -----\n\n        Status specifies the stage of execution.\n\n        * status < 0 means the program awaits compilation\n        * status == 0 means the program is done\n        * status == 1 means the program is being compiled\n        * status == 3 means the program is running\n\n        Result specifies how the program finished.\n\n        * result == 0 means not running, the program was submitted\n                      with run=False\n        * result == 11 means compilation error\n        * result == 12 means runtime error\n        * result == 13 means timelimit exceeded\n        * result == 15 means success\n        * result == 17 means memory limit exceeded\n        * result == 19 means illegal system call\n        * result == 20 means Ideone internal error, submit a bug report\n\n\n\n        Examples\n        --------\n\n        >>> ideone_object = Ideone('username', 'password')\n        >>> ideone_object.submission_status('LsSbo')\n        {'error': 'OK',\n         'result': 15,\n         'status': 0}\n\n        \"\"\"\n        result = self.client.service.getSubmissionStatus(self.user, self.password, link)\n        result_dict = Ideone._transform_to_dict(result)\n        Ideone._handle_error(result_dict)\n        return result_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef submission_details(self, link, with_source=True,\n                               with_input=True, with_output=True,\n                               with_stderr=True, with_compilation_info=True):\n        \"\"\"\n        Return a dictionary of requested details about a submission\n        with the id of link.\n\n        Keyword Arguments\n        -----------------\n\n        * link: the unique string ID of a submission\n        * with_source: should we request the source code\n        * with_input: request the program input\n        * with_output: request the program output\n        * with_stderr: request the error output\n        * with_compilation_info: request compilation flags\n\n        Examples\n        --------\n\n        >>> ideone_object = Ideone('username', 'password')\n        >>> ideone_object.submission_details('LsSbo')\n        {'cmpinfo': ,\n         'date': \"2011-04-18 15:24:14\",\n         'error': \"OK\",\n         'input': \"\",\n         'langId': 116,\n         'langName': \"Python 3\",\n         'langVersion': \"python-3.1.2\",\n         'memory': 5852,\n         'output': 42,\n         'public': True,\n         'result': 15,\n         'signal': 0,\n         'source': \"print(42)\",\n         'status': 0,\n         'stderr': \"\",\n         'time': 0.02}\n\n        \"\"\"\n        result = self.client.service.getSubmissionDetails(self.user, self.password,\n                                                          link,\n                                                          with_source, with_input,\n                                                          with_output, with_stderr,\n                                                          with_compilation_info)\n        result_dict = Ideone._transform_to_dict(result)\n        Ideone._handle_error(result_dict)\n        return result_dict", "response": "Get the details about a submission."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef languages(self):\n        if self._language_dict is None:\n            result = self.client.service.getLanguages(self.user, self.password)\n            result_dict = Ideone._transform_to_dict(result)\n            Ideone._handle_error(result_dict)\n            languages = result_dict['languages']\n            result_dict['languages'] = Ideone._collapse_language_array(languages)\n            self._language_dict = result_dict['languages']\n        return self._language_dict", "response": "Get a list of supported languages and cache it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_binary(filename):\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "response": "Returns True if the file is binary False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces a regular expression in a file.", "response": "def replace_in_file(args, in_file, regexp, repl):\n    \"\"\"\n    Perfoms re.sub(regexp, repl, line) for each line in\n    in_file\n    \"\"\"\n    in_lines = []\n    try:\n        with open(in_file, \"r\") as in_fd:\n            in_lines = in_fd.readlines()\n    except (OSError, UnicodeDecodeError) as error:\n        print(\"Cant open file:\", in_file, error)\n        return\n\n    out_lines = in_lines[:]\n    out_lines = [re.sub(regexp, repl, l) for l in in_lines]\n\n    # Exit early if there's no diff:\n    if in_lines == out_lines:\n        return\n\n    if not args.quiet:\n        display_diff(in_file, regexp, repl, in_lines, out_lines)\n\n    if not args.go:\n        return\n\n    if args.backup:\n        backup(in_file, in_lines)\n\n    with open(in_file, \"w\") as fd:\n        fd.writelines(out_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(args=None):\n    parser = ArgumentParser(usage=__usage__)\n    parser.add_argument(\"--no-skip-hidden\", action=\"store_false\",\n                        dest=\"skip_hidden\",\n                        help=\"Do not skip hidden files. \"\n                        \"Use this if you know what you are doing...\")\n    parser.add_argument(\"--include\", dest=\"includes\", action=\"append\",\n                        help=\"Only replace in files matching theses patterns\")\n    parser.add_argument(\"--exclude\", dest=\"excludes\", action=\"append\",\n                        help=\"Ignore files matching theses patterns\")\n    parser.add_argument(\"--backup\",\n                        action=\"store_true\", dest=\"backup\",\n                        help=\"Create a backup for each file. \"\n                             \"By default, files are modified in place\")\n    parser.add_argument(\"--go\",\n                        action=\"store_true\", dest=\"go\",\n                        help=\"Perform changes rather than just printing then\")\n    parser.add_argument(\"--dry-run\", \"-n\",\n                        action=\"store_false\", dest=\"go\",\n                        help=\"Do not change anything. This is the default\")\n    parser.add_argument(\"--color\", choices=[\"always\", \"never\", \"auto\"],\n                        help=\"When to colorize the output. \"\n                             \"Default: when output is a tty\")\n    parser.add_argument(\"--no-color\", action=\"store_false\", dest=\"color\",\n                        help=\"Do not colorize output\")\n    parser.add_argument(\"--quiet\", \"-q\", action=\"store_true\", dest=\"quiet\",\n                        help=\"Do not produce any output\")\n    parser.add_argument(\"pattern\")\n    parser.add_argument(\"replacement\")\n    parser.add_argument(\"paths\", nargs=\"*\")\n\n    parser.set_defaults(\n        includes=list(),\n        excludes=list(),\n        skip_hidden=True,\n        backup=False,\n        go=False,\n        color=\"auto\",\n        quiet=False,\n        )\n\n    args = parser.parse_args(args=args)\n    setup_colors(args)\n    repl_main(args)", "response": "This function is called from command line. It is called by the command line to run the main function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the item from the file system.", "response": "def load( self ):\r\n        \"\"\"\r\n        Loads this item.\r\n        \"\"\"\r\n        if self._loaded:\r\n            return\r\n        \r\n        self._loaded = True\r\n        self.setChildIndicatorPolicy(self.DontShowIndicatorWhenChildless)\r\n        \r\n        if not self.isFolder():\r\n            return\r\n        \r\n        path = self.filepath()\r\n        if not os.path.isdir(path):\r\n            path = os.path.dirname(path)\r\n        \r\n        for name in os.listdir(path):\r\n            # ignore 'hidden' folders\r\n            if name.startswith('_') and not name.startswith('__'):\r\n                continue\r\n            \r\n            # ignore special cases (only want modules for this)\r\n            if '-' in name:\r\n                continue\r\n            \r\n            # use the index or __init__ information\r\n            if name in ('index.html', '__init__.html'):\r\n                self._url = 'file:///%s/%s' % (path, name)\r\n                continue\r\n            \r\n            # otherwise, load a childitem\r\n            filepath = os.path.join(path, name)\r\n            folder = os.path.isdir(filepath)\r\n            XdkEntryItem(self, filepath, folder=folder)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a gui title for the given file path.", "response": "def titleForFilepath( url ):\r\n        \"\"\"\r\n        Returns a gui title for this url.\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        url = nativestring(url)\r\n        if url in XdkEntryItem.TITLE_MAP:\r\n            return XdkEntryItem.TITLE_MAP.get(url)\r\n        \r\n        url      = nativestring(url).replace('\\\\', '/')\r\n        basename = os.path.basename(url)\r\n        title    = os.path.splitext(basename)[0]\r\n        \r\n        if title == 'index':\r\n            title = url.split('/')[-2]\r\n        \r\n        if title.endswith('-allmembers'):\r\n            title = 'List of All Members for %s' % title.split('-')[-2]\r\n        elif title.endswith('-source'):\r\n            title = 'Source Code for %s' % title.split('-')[-2]\r\n        elif len(nativestring(url).split('/')) <= 2 and title in TITLE_MAP:\r\n            title = TITLE_MAP[title]\r\n        elif not 'api/' in url:\r\n            title = projex.text.pretty(title)\r\n        \r\n        return title"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of files in alphabetical order for index lookups.", "response": "def indexlist( self ):\r\n        \"\"\"\r\n        Returns the list of files in alphabetical order for index lookups.\r\n        \r\n        :return     [(<str> name, <str> url), ..]\r\n        \"\"\"\r\n        output = [(child.text(0), child.url())\r\n                   for child in self.children(recursive=True)]\r\n        \r\n        output.sort()\r\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search(self, terms):\r\n        # load the search information\r\n        if not self._searchurls:\r\n            base = self.tempFilepath()\r\n            root_url = projex.text.underscore(self.text(0))\r\n            for root, folders, files in os.walk(base):\r\n                if '_static' in root:\r\n                    continue\r\n                \r\n                for file in files:\r\n                    if not file.endswith('.html'):\r\n                        continue\r\n                    \r\n                    filename = os.path.join(root, file)\r\n                    url = filename[len(base)+1:].replace('\\\\', '/')\r\n                    url = root_url + '/' + url.strip('/')\r\n                    url = url.replace('.html', '')\r\n                    \r\n                    f = open(filename, 'r')\r\n                    content = f.read()\r\n                    f.close()\r\n                    \r\n                    self._searchurls[url] = content\r\n\r\n        # search for the contents\r\n        output = [] # [(<int> strength>\r\n        term_list = nativestring(terms).split(' ')\r\n        for url, html in self._searchurls.items():\n            title           = self.titleForFilepath(url)\r\n            strength        = 0\n            all_title_found = True\n            all_found       = True\n            \r\n            for term in term_list:\n                if ( term == title ):\n                    strength += 5\n                \n                elif ( term.lower() == title.lower() ):\n                    strength += 4\n                    \n                elif ( term in title ):\n                    strength += 3\n                \n                elif ( term.lower() in title.lower() ):\n                    strength += 2\n                \n                else:\n                    all_title_found = False\n                \r\n                if ( not term in html ):\r\n                    all_found = False\n                else:\n                    strength += 1\r\n            \n            if ( all_title_found ):\n                strength += len(terms) * 2\n            \n            if ( all_found ):\n                strength += len(terms)\n            \n            # determine the strength\r\n            if ( strength ):\r\n                output.append({'url': url, \n                               'title': self.titleForFilepath(url),\n                               'strength': strength})\r\n        \r\n        return output", "response": "Returns a list of dicts with the url title and strength of the documents that match the inputed terms."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nasserting that the transform exists.", "response": "def assert_transform_exists(cli, transform_path):\n    \"\"\"\n    Asserts that the transform exists.\n    :param cli:\n    :param transform_path:\n    :return:\n    \"\"\"\n    result = commands.query_transform_exists(cli, transform_path)\n    assert result is True\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assert_scene_loaded(cli, scene_name):\n    result = commands.query_scene_loaded(cli, scene_name)\n    assert result is True\n    return result", "response": "Assert that the scene is loaded."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nasserting that a transform exists based on does_exist.", "response": "def assert_await_transform_exists(cli, transform_path, does_exist=DEFAULT_TRANSFORM_EXISTS, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    \"\"\"\n    Asserts that we successfully awaited for the transform to exist based on does_exist. If the timeout passes\n    or the expression is_registered != actual state, then it will fail.\n    :param cli:\n    :param transform_path:\n    :param does_exist: (True | False) the state change we are waiting for.\n    :param timeout_seconds: The amount of time to wait for a change before fail.\n    :return:\n    \"\"\"\n    result = commands.await_transform_exists(cli, transform_path, does_exist, timeout_seconds)\n    assert result is True\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assert_await_any_transforms_exist(cli, transform_paths, does_exist=DEFAULT_TRANSFORM_EXISTS, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    result = commands.await_any_transforms_exist(cli, transform_paths, does_exist, timeout_seconds)\n    assert result is True\n    return result", "response": "Assert that there are any transforms that exist based on does_exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassert that all transform paths exist based on does_exist.", "response": "def assert_await_all_transforms_exist(cli, transform_paths, does_exist=DEFAULT_TRANSFORM_EXISTS, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    \"\"\"\n    Asserts that we successfully awaited for all transforms to exist based on does_exist. If the timeout passes\n    or the expression is_registered != actual state, then it will fail.\n    :param cli:\n    :param transform_paths:\n    :param does_exist: (True | False) the state change we are waiting for.\n    :param timeout_seconds: The amount of time to wait for a change before fail.\n    :return:\n    \"\"\"\n    result = commands.await_all_transforms_exist(cli, transform_paths, does_exist, timeout_seconds)\n    assert result is True\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_await_renderer_visible(cli, transform_path, is_visible=DEFAULT_RENDERER_VISIBLE, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    result = commands.await_renderer_visible(cli, transform_path, is_visible, timeout_seconds)\n    assert result is True\n    return result", "response": "Assert that the renderer is visible based on is_visible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nassert that a scene is loaded based on is_loaded.", "response": "def assert_await_scene_loaded(cli, scene_name, is_loaded=DEFAULT_SCENE_LOADED, timeout_seconds=DEFAULT_TIMEOUT_SECONDS):\n    \"\"\"\n    Asserts that we successfully awaited for the scene to be loaded based on is_loaded. If the timeout passes\n    or the expression is_registered != actual state, then it will fail.\n    :param cli:\n    :param scene_name:\n    :param is_loaded: (True | False) the state change we are waiting for.\n    :param timeout_seconds: The amount of time to wait for a change before fail.\n    :return:\n    \"\"\"\n    result = commands.await_scene_loaded(cli, scene_name, is_loaded, timeout_seconds)\n    assert result is True\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninstalling the Sphinx docs and index. rst files for the project.", "response": "def install():\n    \"\"\"\n    Main entry point for running sphinx_me as a script.\n    Creates a docs directory in the current directory and adds the\n    required files for generating Sphinx docs from the project's\n    README file - a conf module that calls setup_conf() from this\n    module, and an index file that includes the project's README.\n    \"\"\"\n    for name in listdir(getcwd()):\n        if splitext(name)[0].upper() == \"README\":\n            readme = name\n            break\n    else:\n        print()\n        print(\"ABORT: No README file in the current directory.\")\n        return\n\n    docs_path = join(getcwd(), \"docs\")\n    if not isdir(docs_path):\n        mkdir(docs_path)\n    with open(join(docs_path, \"index.rst\"), \"w\") as f:\n        f.write(\".. include:: ../%s\" % readme)\n    with open(join(docs_path, \"conf.py\"), \"w\") as f:\n        f.write(\"# This file is automatically generated via sphinx-me\\n\")\n        f.write(\"from sphinx_me import setup_conf; setup_conf(globals())\\n\")\n    print()\n    print(\"SUCCESS: Sphinx docs layout created in %s\" % docs_path)\n    try:\n        import sphinx\n    except ImportError:\n        print()\n        print(\"Sphinx not installed. Not building docs.\")\n    else:\n        build_path = join(docs_path, \"build\")\n        Popen([\"sphinx-build\", docs_path, build_path]).wait()\n        print()\n        print(\"Docs built in %s\" % build_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_version(module):\n    version_names = [\"__version__\", \"get_version\", \"version\"]\n    version_names.extend([name.upper() for name in version_names])\n    for name in version_names:\n        try:\n            version = getattr(module, name)\n        except AttributeError:\n            continue\n        if callable(version):\n            version = version()\n        try:\n            version = \".\".join([str(i) for i in version.__iter__()])\n        except AttributeError:\n            pass\n        return version", "response": "Reads the version attribute from the given module that is a sequence of strings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the setup. py script to get the value for a particular attribute.", "response": "def get_setup_attribute(attribute, setup_path):\n    \"\"\"\n    Runs the project's setup.py script in a process with an arg that\n    will print out the value for a particular attribute such as author\n    or version, and returns the value.\n    \"\"\"\n    args = [\"python\", setup_path, \"--%s\" % attribute]\n    return Popen(args, stdout=PIPE).communicate()[0].decode('utf-8').strip()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_conf(conf_globals):\n    project_path = abspath(join(dirname(conf_globals[\"__file__\"]), \"..\"))\n    chdir(project_path)\n    sys.path.insert(0, project_path)\n    authors_file = \"AUTHORS\"\n    version = None\n    author = None\n    setup = \"setup.py\"\n    setup_path = join(project_path, setup)\n    ignore = (setup,)\n\n    # First try and get the author and version from setup.py\n    if exists(setup_path):\n        try:\n            import setuptools\n        except ImportError:\n            pass\n        else:\n            version = get_setup_attribute(\"version\", setup_path)\n            if version == \"0.0.0\":\n                version = None\n            author = get_setup_attribute(\"author\", setup_path)\n            if author == \"UNKNOWN\":\n                author = None\n\n    # Iterate through each of the files in the project's directory,\n    # looking for an AUTHORS file for the project's author, or\n    # importable packages/modules for the version.\n    for name in listdir(project_path):\n        path = join(project_path, name)\n        if name.upper() == authors_file:\n            with open(path, \"r\") as f:\n                for line in f.readlines():\n                    line = line.strip(\"*- \\n\\r\\t\")\n                    if line:\n                        author = decode_utf8(line)\n                        break\n        elif name not in ignore and (isdir(path) or splitext(name)[1] == \".py\"):\n            try:\n                module = __import__(name)\n            except (ImportError, ValueError):\n                continue\n            if not version:\n                version = get_version(module)\n            if version and not author:\n                try:\n                    author = decode_utf8(getattr(module, \"__author__\"))\n                except AttributeError:\n                    pass\n\n    # Ask for any values that couldn't be found.\n    if not version:\n        version = input(\"No version number found, please enter one: \")\n    if not author:\n        author = input(\"No author found, please enter one: \")\n        author = decode_utf8(author)\n        with open(join(project_path, authors_file), \"wb\") as f:\n            f.write(author.encode('utf-8'))\n\n    # Inject the minimum required names into the conf module.\n    settings = {\n        \"version\": version,\n        \"release\": version,\n        \"project\": project_path.rstrip(sep).split(sep)[-1],\n        \"master_doc\": \"index\",\n        \"copyright\": \"%s, %s\" % (datetime.now().year, author),\n    }\n    pad = max([len(k) for k in settings.keys()]) + 3\n    print()\n    print(\"sphinx-me using the following values:\")\n    print()\n    print(\"\\n\".join([(k + \":\").ljust(pad) + v for k, v in settings.items()]))\n    print()\n    conf_globals.update(settings)", "response": "Setup function that is called from within the project s conf. py module that takes the conf module s globals and assigns the values that can be automatically determined from the project s version and author."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch the items from the backend", "response": "def fetch_items(self, category, **kwargs):\n        \"\"\"Fetch the modules\n\n        :param category: the category of items to fetch\n        :param kwargs: backend arguments\n\n        :returns: a generator of items\n        \"\"\"\n        from_date = kwargs['from_date']\n\n        logger.info(\"Fetching modules from %s\", str(from_date))\n\n        from_date_ts = datetime_to_utc(from_date).timestamp()\n\n        nmodules = 0\n        stop_fetching = False\n\n        raw_pages = self.client.modules()\n\n        for raw_modules in raw_pages:\n            modules = [mod for mod in self.parse_json(raw_modules)]\n\n            for module in modules:\n                # Check timestamps to stop fetching more modules\n                # because modules fetched sorted by 'updated_at'\n                # from newest to oldest.\n                updated_at_ts = self.metadata_updated_on(module)\n\n                if from_date_ts > updated_at_ts:\n                    stop_fetching = True\n                    break\n\n                owner = module['owner']['username']\n                name = module['name']\n                module['releases'] = self.__fetch_and_parse_releases(owner, name)\n                module['owner_data'] = self.__get_or_fetch_owner(owner)\n\n                yield module\n                nmodules += 1\n\n            if stop_fetching:\n                break\n\n        logger.info(\"Fetch process completed: %s modules fetched\", nmodules)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_json(raw_json):\n        result = json.loads(raw_json)\n\n        if 'results' in result:\n            result = result['results']\n\n        return result", "response": "Parse a Puppet forge JSON stream and return a list with the parsed data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef releases(self, owner, module):\n\n        resource = self.RRELEASES\n\n        params = {\n            self.PMODULE: owner + '-' + module,\n            self.PLIMIT: self.max_items,\n            self.PSHOW_DELETED: 'true',\n            self.PSORT_BY: self.VRELEASE_DATE,\n        }\n\n        for page in self._fetch(resource, params):\n            yield page", "response": "Fetch the releases of a module."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a resource. A resource. A resource is returned and the parameters are included in the URL.", "response": "def _fetch(self, resource, params):\n        \"\"\"Fetch a resource.\n\n        Method to fetch and to iterate over the contents of a\n        type of resource. The method returns a generator of\n        pages for that resource and parameters.\n\n        :param resource: type of the resource\n        :param params: parameters to filter\n\n        :returns: a generator of pages for the requested resource\n        \"\"\"\n        url = urijoin(self.base_url, 'v3', resource)\n\n        do_fetch = True\n\n        while do_fetch:\n            logger.debug(\"Puppet forge client calls resource: %s params: %s\",\n                         resource, str(params))\n\n            r = self.fetch(url, payload=params)\n            yield r.text\n\n            json_data = r.json()\n\n            if 'pagination' in json_data:\n                next_url = json_data['pagination']['next']\n\n                if next_url:\n                    # Params are already included in the URL\n                    url = urijoin(self.base_url, next_url)\n                    params = {}\n                else:\n                    do_fetch = False\n            else:\n                do_fetch = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the current tree to empty.", "response": "def reset_tree(self):\n        \"\"\"\n        Resets the current tree to empty.\n        \"\"\"\n        self.tree = {}\n        self.tree['leaves'] = []\n        self.tree['levels'] = []\n        self.tree['is_ready'] = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_leaf(self, value, do_hash=False):\n        self.tree['is_ready'] = False\n        self._add_leaf(value, do_hash)", "response": "Add a leaf to the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds leaves to the tree.", "response": "def add_leaves(self, values_array, do_hash=False):\n        \"\"\"\n        Add leaves to the tree.\n\n        Similar to chainpoint merkle tree library, this accepts hash values as an array of Buffers or hex strings.\n        :param values_array: array of values to add\n        :param do_hash: whether to hash the values before inserting\n        \"\"\"\n        self.tree['is_ready'] = False\n        [self._add_leaf(value, do_hash) for value in values_array]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a leaf at the given index.", "response": "def get_leaf(self, index):\n        \"\"\"\n        Returns a leaf at the given index.\n        :param index:\n        :return: leaf (value) at index\n        \"\"\"\n        leaf_level_index = len(self.tree['levels']) - 1\n        if index < 0 or index > len(self.tree['levels'][leaf_level_index]) - 1:\n            # index is out of bounds\n            return None\n        return self.tree['levels'][leaf_level_index][index]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_tree(self):\n        self.tree['is_ready'] = False\n        leaf_count = len(self.tree['leaves'])\n        if leaf_count > 0:\n            # skip this whole process if there are no leaves added to the tree\n            self._unshift(self.tree['levels'], self.tree['leaves'])\n            while len(self.tree['levels'][0]) > 1:\n                self._unshift(self.tree['levels'], self._calculate_next_level())\n        self.tree['is_ready'] = True", "response": "Generates the merkle tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_proof(self, index):\n\n        if not self.tree['is_ready']:\n            return None\n        current_row_index = len(self.tree['levels']) - 1\n        if index < 0 or index > len(self.tree['levels'][current_row_index]) - 1:\n            # the index it out of the bounds of the leaf array\n            return None\n\n        proof = []\n        for current_level in range(current_row_index, 0, -1):\n            current_level_node_count = len(self.tree['levels'][current_level])\n            # skip if this is an odd end node\n            if index == current_level_node_count - 1 and current_level_node_count % 2 == 1:\n                index = int(math.floor(index / 2))\n                continue\n\n            # determine the sibling for the current index and get its value\n            is_right_node = index % 2\n            if is_right_node:\n                sibling_index = index - 1\n            else:\n                sibling_index = index + 1\n            sibling = {}\n\n            if is_right_node:\n                sibling_position = 'left'\n            else:\n                sibling_position = 'right'\n\n            sibling_value = self.tree['levels'][current_level][sibling_index]\n            sibling[sibling_position] = hexlify(sibling_value)\n\n            proof.append(sibling)\n\n            index = int(math.floor(index / 2))  # set index to the parent index\n\n        return proof", "response": "Returns the proof for a leaf at the given index as an array of merkle siblings in hex format\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_proof(self, proof, target_hash, merkle_root):\n        return validate_proof(proof, target_hash, merkle_root, self.hash_f)", "response": "Checks the validity of a proof array and returns true or false\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the full path from the given index.", "response": "def pathFromIndex(self, index):\r\n        \"\"\"\r\n        Returns the joined path from the given model index.  This will\r\n        join together the full path with periods.\r\n        \r\n        :param      index | <QModelIndex>\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        out  = []\r\n        while index and index.isValid():\r\n            out.append(nativestring(unwrapVariant(index.data())))\r\n            index = self._model.parent(index)\r\n        \r\n        return self.joiner().join(reversed(out))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef duration_to_timedelta(obj):\n    matches = DURATION_PATTERN.search(obj)\n    matches = matches.groupdict(default=\"0\")\n    matches = {k: int(v) for k, v in matches.items()}\n    return timedelta(**matches)", "response": "Converts a duration to timedelta"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef timedelta_to_duration(obj):\n    minutes, hours, days = 0, 0, 0\n    seconds = int(obj.total_seconds())\n    if seconds > 59:\n        minutes = seconds // 60\n        seconds = seconds % 60\n    if minutes > 59:\n        hours = minutes // 60\n        minutes = minutes % 60\n    if hours > 23:\n        days = hours // 24\n        hours = hours % 24\n    response = []\n    if days:\n        response.append('%sd' % days)\n    if hours:\n        response.append('%sh' % hours)\n    if minutes:\n        response.append('%sm' % minutes)\n    if seconds or not response:\n        response.append('%ss' % seconds)\n    return \"\".join(response)", "response": "Converts timedelta to duration\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fromXml(xml):\r\n        slide = XWalkthroughSlide(**xml.attrib)\r\n        \r\n        # create the items\r\n        for xgraphic in xml:\r\n            slide.addItem(XWalkthroughItem.fromXml(xgraphic))\r\n        \r\n        return slide", "response": "Creates a new slide from an XML object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the contents of this walkthrough from XML.", "response": "def load(xmlstr):\r\n        \"\"\"\r\n        Loads the contents for this walkthrough from XML.\r\n        \r\n        :param      xmlstr | <str>\r\n        \r\n        :return     <XWalkthrough> || None\r\n        \"\"\"\r\n        try:\r\n            xml = ElementTree.fromstring(xmlstr)\r\n        except StandardError:\r\n            return None\r\n\r\n        return XWalkthrough.fromXml(xml)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new walkthrough element from XML object xml.", "response": "def fromXml(xml):\r\n        \"\"\"\r\n        Creates a new walkthrough element from XML\r\n        \r\n        :param      xml | <xml.etree.ElementTree.Element>\r\n        \r\n        :return     <XWalkthrough> || None\r\n        \"\"\"\r\n        walkthrough = XWalkthrough(name=xml.get('name', ''),\r\n                                   version=xml.get('version'))\r\n        \r\n        for xslide in xml:\r\n            walkthrough.addSlide(XWalkthroughSlide.fromXml(xslide))\r\n        \r\n        return walkthrough"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating ikuai dm message", "response": "def create_dm_pkg(secret,username):\n    ''' create ikuai dm message'''\n    secret = tools.EncodeString(secret)\n    username = tools.EncodeString(username)\n    pkg_format = '>HHHH32sHH32s'\n    pkg_vals = [\n        IK_RAD_PKG_VER,\n        IK_RAD_PKG_AUTH,\n        IK_RAD_PKG_USR_PWD_TAG,\n        len(secret),\n        secret.ljust(32,'\\x00'),\n        IK_RAD_PKG_CMD_ARGS_TAG,\n        len(username),\n        username.ljust(32,'\\x00')\n    ]\n    return struct.pack(pkg_format,*pkg_vals)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addBreakpoint( self, lineno = -1 ):\r\n        if ( lineno == -1 ):\r\n            lineno, colno = self.getCursorPosition()\r\n            \r\n        self.markerAdd(lineno, self._breakpointMarker)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.breakpointsChanged.emit()", "response": "Adds a breakpoint at the given line number to this edit."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of lines that have breakpoints for this edit.", "response": "def breakpoints( self ):\r\n        \"\"\"\r\n        Returns a list of lines that have breakpoints for this edit.\r\n        \r\n        :return     [<int>, ..]\r\n        \"\"\"\r\n        lines = []\r\n        result = self.markerFindNext(0, self._breakpointMarker + 1)\r\n        while ( result != -1 ):\r\n            lines.append(result)\r\n            result = self.markerFindNext(result + 1, self._breakpointMarker + 1)\r\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clearBreakpoints( self ):\r\n        self.markerDeleteAll(self._breakpointMarker)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.breakpointsChanged.emit()", "response": "Clears the file of all the breakpoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef closeEvent( self, event ):\n        if ( not (self.saveOnClose() and self.checkForSave()) ):\n            event.ignore()\n        else:\n            super(XScintillaEdit, self).closeEvent(event)", "response": "Overloads the close event for this widget to make sure that the data is properly saved before exiting."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck to see if the current document has been modified and should be saved.", "response": "def checkForSave( self ):\n        \"\"\"\n        Checks to see if the current document has been modified and should \\\n        be saved.\n        \n        :return     <bool>\n        \"\"\"\n        # if the file is not modified, then save is not needed\n        if ( not self.isModified() ):\n            return True\n        \n        options     = QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel\n        question    = 'Would you like to save your changes to %s?' % \\\n                                            self.windowTitle()\n                                            \n        answer      = QMessageBox.question( None, \n                                            'Save Changes', \n                                            question, \n                                            options )\n        \n        if ( answer == QMessageBox.Yes ):\n            return self.save()\n        elif ( answer == QMessageBox.Cancel ):\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the next iteration of the search term in the list.", "response": "def findNext( self, \n                  text, \n                  wholeWords    = False, \n                  caseSensitive = False, \n                  regexed       = False,\n                  wrap          = True ):\n        \"\"\"\n        Looks up the next iteration fot the inputed search term.\n        \n        :param      text            | <str>\n                    wholeWords      | <bool>\n                    caseSensitive   | <bool>\n                    regexed         | <bool>\n        \n        :return     <bool>\n        \"\"\"\n        return self.findFirst( text,\r\n                               regexed,\n                               caseSensitive,\n                               wholeWords,\r\n                               wrap,\n                               True )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef findPrev( self,\n                  text,\n                  wholeWords    = False,\n                  caseSensitive = False,\n                  regexed       = False,\n                  wrap          = True ):\n        \"\"\"\n        Looks up the previous iteration for the inputed search term.\n        \n        :param      text            | <str>\n                    wholeWords      | <bool>\n                    caseSensitive   | <bool>\n                    regexed         | <bool>\n                    wrap            | <bool>\n        \n        :return     <bool>\n        \"\"\"\r\n        lineFrom, indexFrom, lineTo, indexTo = self.getSelection()\r\n        \n        return self.findFirst( text,\n                               regexed,\n                               caseSensitive,\n                               wholeWords,\r\n                               wrap,\n                               False,\r\n                               lineFrom,\r\n                               indexFrom )", "response": "Returns the previous iteration of the inputed search term."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef findRepl( self, \r\n                  text,\r\n                  repl,\r\n                  caseSensitive = False,\r\n                  replaceAll    = False ):\r\n        \"\"\"\r\n        Looks for the inputed text and replaces it with the given replacement \\\r\n        text.\r\n        \r\n        :param      text            | <str>\r\n                    repl            | <str>\r\n                    caseSensitive   | <bool>\r\n                    replaceAll      | <bool>\r\n        \r\n        :return     <int> number of items replace\r\n        \"\"\"\n        # make sure something is selected\n        if ( not text ):\n            return 0\n        \r\n        # make sure we have some text selected to replace\r\n        if ( self.selectedText() != text ):\r\n            found = self.findNext( text,\r\n                                   False,\r\n                                   caseSensitive,\r\n                                   False,\r\n                                   True )\r\n            \r\n            if ( not found ):\r\n                return 0\r\n        \r\n        sel     = self.getSelection()\r\n        alltext = self.text()\r\n        \r\n        # replace all instances\r\n        if ( replaceAll ):\r\n            sensitivity = Qt.CaseInsensitive\r\n            if ( caseSensitive ):\r\n                sensitivity = Qt.CaseSensitive\r\n                \r\n            count = alltext.count(text, sensitivity)\r\n            alltext.replace(text, repl, sensitivity)\r\n            \r\n        else:\r\n            count    = 1\r\n            startpos = self.positionFromLineIndex(sel[0], sel[1])\r\n            alltext.replace(startpos, len(text), repl)\r\n            \r\n        self.setText(alltext)\r\n        \r\n        if ( count == 1 ):\r\n            sel = list(sel)\r\n            sel[3] += len(repl) - len(text)\r\n            \r\n            self.setSelection(*sel)\r\n        else:\r\n            self.findNext( repl,\r\n                           False,\r\n                           caseSensitive,\r\n                           False,\r\n                           True )\r\n        \r\n        return count", "response": "Find the next replacement in the given text and replace it with the given replacement."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initOptions(self, options):\n        self.setAutoIndent(             options.value('autoIndent'))\n        self.setIndentationsUseTabs(    options.value('indentationsUseTabs'))\n        self.setTabIndents(             options.value('tabIndents'))\n        self.setTabWidth(               options.value('tabWidth'))\n        \n        self.setCaretLineVisible(       options.value('showCaretLine'))\n        self.setShowWhitespaces(        options.value('showWhitespaces'))\n        self.setMarginLineNumbers( 0,   options.value('showLineNumbers'))\n        self.setIndentationGuides(      options.value('showIndentations'))\n        self.setEolVisibility(          options.value('showEndlines'))\n        \n        if options.value('showLimitColumn'):\n            self.setEdgeMode(self.EdgeLine)\n            self.setEdgeColumn(options.value('limitColumn'))\n        else:\n            self.setEdgeMode(self.EdgeNone)\n        \n        if options.value('showLineWrap'):\n            self.setWrapMode(self.WrapWord)\n        else:\n            self.setWrapMode(self.WrapNone)\n        \n        # set the autocompletion source\n        if options.value('autoComplete'):\n            self.setAutoCompletionSource(QsciScintilla.AcsAll)\n        else:\n            self.setAutoCompletionSource(QsciScintilla.AcsNone)\n        \n        self.setAutoCompletionThreshold(options.value('autoCompleteThreshold'))\r\n        \r\n        # update the font information\r\n        font = options.value('documentFont')\r\n        font.setPointSize(options.value('documentFontSize'))\n        self.setFont(font)\n        \n        # udpate the lexer\r\n        lexer = self.lexer()\r\n        if lexer:\r\n            lexer.setFont(font)\n        \r\n        # create the margin font option\n        mfont = options.value('documentMarginFont')\r\n        mfont.setPointSize(font.pointSize() - 2)\n        self.setMarginsFont(mfont)\n        self.setMarginWidth(0, QFontMetrics(mfont).width('0000000') + 5)", "response": "Initializes the edit with the inputed options data set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninsert comments into the editor based on the current selection.", "response": "def insertComments( self, comment = None ):\n        \"\"\"\n        Inserts comments into the editor based on the current selection.\\\n        If no comment string is supplied, then the comment from the language \\\n        will be used.\n        \n        :param      comment | <str> || None\n        \n        :return     <bool> | success\n        \"\"\"\n        if ( not comment ):\n            lang = self.language()\n            if ( lang ):\n                comment = lang.lineComment()\n        \n        if ( not comment ):\n            return False\n        \n        startline, startcol, endline, endcol = self.getSelection()\n        line, col = self.getCursorPosition()\n        \n        for lineno in range(startline, endline+1 ):\n            self.setCursorPosition(lineno, 0)\n            self.insert(comment)\n        \n        self.setSelection(startline, startcol, endline, endcol)\n        self.setCursorPosition(line, col)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverload the keyPressEvent method to support backtab operations.", "response": "def keyPressEvent( self, event ):\r\n        \"\"\"\r\n        Overloads the keyPressEvent method to support backtab operations.\r\n        \r\n        :param      event | <QKeyPressEvent>\r\n        \"\"\"\r\n        if ( event.key() == Qt.Key_Backtab ):\r\n            self.unindentSelection()\r\n        else:\r\n            super(XScintillaEdit, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the inputed filename as the current document for this edit.", "response": "def load( self, filename, lineno = 0 ):\n        \"\"\"\n        Loads the inputed filename as the current document for this edit.\n        \n        :param      filename | <str>\n                    lineno   | <int>\n        \n        :return     <bool> | success\n        \"\"\"\n        filename = nativestring(filename)\n        \n        if ( not (filename and os.path.exists(filename)) ):\n            return False\n        \n        # load the file\n        docfile = QFile(filename)\n        if ( not docfile.open(QFile.ReadOnly) ):\n            return False\n            \n        success = self.read(docfile)\n        docfile.close()\n        \n        if ( not success ):\n            return False\n        \n        self._filename = nativestring(filename)\n        ext = os.path.splitext(filename)[1]\n        self.setCurrentLine(lineno)\n        \n        lang = XLanguage.byFileType(ext)\n        if ( lang != self.language() ):\n            self.setLanguage(lang)\n        \r\n        self.setModified(False)\r\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves comments from the editor based on the current selection.", "response": "def removeComments( self, comment = None ):\n        \"\"\"\n        Inserts comments into the editor based on the current selection.\\\n        If no comment string is supplied, then the comment from the language \\\n        will be used.\n        \n        :param      comment | <str> || None\n        \n        :return     <bool> | success\n        \"\"\"\n        if ( not comment ):\n            lang = self.language()\n            if ( lang ):\n                comment = lang.lineComment()\n        \n        if ( not comment ):\n            return False\n        \n        startline, startcol, endline, endcol = self.getSelection()\n        len_comment = len(comment)\n        line, col = self.getCursorPosition()\n        \n        for lineno in range(startline, endline+1 ):\n            self.setSelection(lineno, 0, lineno, len_comment)\n            if ( self.selectedText() == comment ):\n                self.removeSelectedText()\n        \n        self.setSelection(startline, startcol, endline, endcol)    \n        self.setCursorPosition(line, col)\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the breakpoint at the inputed line number.", "response": "def removeBreakpoint( self, lineno = -1 ):\r\n        \"\"\"\r\n        Removes the breakpoint at the inputed line number.  If the lineno is -1,\r\n        then the current line number will be used\r\n        \r\n        :note       The lineno is 0-based, while the editor displays lines as\r\n                    a 1-based system.  So, if you remove a breakpoint at\r\n                    visual line 3, you would pass in lineno as 2\r\n        \r\n        :param      lineno | <int>\r\n        \"\"\"\r\n        if ( lineno == -1 ):\r\n            lineno, colno = self.getCursorPosition()\r\n        \r\n        self.markerDelete(lineno, self._breakpointMarker)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.breakpointsChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef saveAs( self, filename = '' ):\n        if ( not (filename and isinstance(filename, basestring)) ):\n            langTypes = XLanguage.pluginFileTypes()\n            filename = QFileDialog.getSaveFileName( None,\n                                                    'Save File As...',\n                                                    QDir.currentPath(),\n                                                    langTypes)\r\n            \r\n            if type(filename) == tuple:\r\n                filename = nativestring(filename[0])\n        \n        if ( not filename ):\n            return False\n        \n        docfile = QFile(filename)\n        if ( not docfile.open(QFile.WriteOnly) ):\n            logger.warning('Could not open %s for writing.' % filename)\n            return False\n        \n        success = self.write(docfile)\n        docfile.close()\n        \n        if success:\r\n            filename = nativestring(filename)\n            self._filename = filename\r\n            \n            self.setModified(False)\n            \r\n            # set the language\r\n            lang = XLanguage.byFileType(os.path.splitext(filename)[1])\n            if ( lang != self.language() ):\n                self.setLanguage(lang)\n        \n        return success", "response": "Saves the current document to the inputed filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setBreakpoints( self, breakpoints ):\r\n        self.clearBreakpoints()\r\n        for breakpoint in breakpoints:\r\n            self.addBreakpoint(breakpoint)", "response": "Sets the breakpoints for this edit to the inputed list of breakpoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setColorSet( self, colorSet ):\r\n        self._colorSet = colorSet\r\n        \r\n        if ( not colorSet ):\r\n            return\r\n        \r\n        palette = self.palette()\r\n        palette.setColor( palette.Base, colorSet.color('Background'))\r\n        self.setPalette(palette)\r\n        \r\n        # set the global colors\r\n        self.setCaretForegroundColor(\r\n                                colorSet.color('CaretForeground'))\r\n        self.setMarginsBackgroundColor(\r\n                                colorSet.color('MarginsBackground'))\r\n        self.setMarginsForegroundColor(\r\n                                colorSet.color('MarginsForeground'))\r\n        self.setPaper(          colorSet.color('Background'))\r\n        self.setSelectionBackgroundColor(\r\n                                colorSet.color('SelectionBackground'))\r\n        self.setSelectionForegroundColor(\r\n                                colorSet.color('SelectionForeground'))\r\n        self.setFoldMarginColors(colorSet.color('FoldMarginsForeground'),\r\n                                 colorSet.color('FoldMarginsBackground'))\r\n        self.setCallTipsBackgroundColor(\r\n                                colorSet.color('CallTipsBackground'))\r\n        self.setCallTipsForegroundColor(\r\n                                colorSet.color('CallTipsForeground'))\r\n        self.setCallTipsHighlightColor(\r\n                                colorSet.color('CallTipsHighlight'))\r\n        self.setEdgeColor(      colorSet.color('Edge'))\r\n        self.setMarkerBackgroundColor(\r\n                                colorSet.color('MarkerBackground'))\r\n        self.setMarkerForegroundColor(\r\n                                colorSet.color('MarkerForeground'))\r\n        self.setMatchedBraceBackgroundColor(\r\n                                colorSet.color('MatchedBraceBackground'))\r\n        self.setMatchedBraceForegroundColor(\r\n                                colorSet.color('MatchedBraceForeground'))\r\n        self.setUnmatchedBraceBackgroundColor(\r\n                                colorSet.color('UnmatchedBraceBackground'))\r\n        self.setUnmatchedBraceForegroundColor(\r\n                                colorSet.color('UnmatchedBraceForeground'))\r\n        self.setColor(          colorSet.color('Text'))\n        \r\n        self.setIndentationGuidesBackgroundColor(\r\n                                    colorSet.color('IndentBackground'))\r\n        self.setIndentationGuidesForegroundColor(\r\n                                colorSet.color('IndentForeground'))\n        \n        # backwards support\n        if ( hasattr(self, 'setCaretBackgroundColor') ):\n            self.setCaretBackgroundColor(\r\n                                    colorSet.color('CaretBackground'))\n        elif ( hasattr(self, 'setCaretLineBackgroundColor') ):\n            self.setCaretLineBackgroundColor(\r\n                                    colorSet.color('CaretBackground'))\n                                    \r\n        \n        # supported in newer QScintilla versions\n        if ( hasattr(self, 'setIndicatorForegroundColor') ):\r\n            self.setIndicatorForegroundColor(\r\n                                    colorSet.color('IndicatorForeground'))\r\n            self.setIndicatorOutlineColor(\r\n                                    colorSet.color('IndicatorOutline'))\n        \n        # set the language and lexer colors\r\n        lang  = self.language()\r\n        lexer = self.lexer()\r\n        \r\n        if ( lang and lexer ):\r\n            lang.setColorSet(lexer, colorSet)", "response": "Sets the color set for this edit to the inputed colorSet."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setCurrentDebugLine( self, lineno ):\r\n        self.markerDeleteAll(self._currentDebugMarker)\r\n        self.markerAdd(lineno, self._currentDebugMarker)\r\n        self.setCurrentLine(lineno)", "response": "Sets the current debug line number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unindentSelection( self ):\r\n        sel = self.getSelection()\r\n        \r\n        for line in range(sel[0], sel[2] + 1):\r\n            self.unindent(line)", "response": "Unindents the current selected text."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the window title based on the filename and modified state.", "response": "def windowTitle( self ):\n        \"\"\"\n        Returns the window title for this edit based on its filename and \\\n        modified state.\n        \n        :return     <str>\n        \"\"\"\n        output = os.path.basename(self._filename)\n        if ( not output ):\n            output = 'New Document'\n        \n        if ( self.isModified() ):\n            output += '*'\n        \n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _removePunctuation(text_string):\n    try:\n        return text_string.translate(None, _punctuation)\n    except TypeError:\n        return text_string.translate(str.maketrans('', '', _punctuation))", "response": "Removes punctuation symbols from a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _removeStopwords(text_list):\n\n    output_list = []\n\n    for word in text_list:\n        if word.lower() not in _stopwords:\n            output_list.append(word)\n\n    return output_list", "response": "Removes stopwords contained in a list of words."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getBlocks(sentences, n):\n    blocks = []\n    for i in range(0, len(sentences), n):\n        blocks.append(sentences[i:(i+n)])\n    return blocks", "response": "Get blocks of n sentences together."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __collectFilterTerms( self, \r\n                            mapping, \r\n                            item = None, \r\n                            level = 0 ):\r\n        \"\"\"\r\n        Generates a list of filter terms based on the column data for the \\\r\n        items in the tree.  If no parent is supplied, then the top level items \\\r\n        will be used, otherwise the children will be searched through.  The \\\r\n        level value will drive how far down the tree we will look for the terms.\r\n        \r\n        :param      mapping | {<int> column: <set> values, ..}\r\n                    item    | <QtGui.QTreeWidgetItem> || None\r\n                    level   | <int>\r\n        \"\"\"\r\n        if not mapping:\r\n            return\r\n        \r\n        max_level = self.maximumFilterLevel()\r\n        if max_level != None and level > max_level:\r\n            return False\r\n        \r\n        if not item:\r\n            for i in range(self.topLevelItemCount()):\r\n                self.__collectFilterTerms(mapping, self.topLevelItem(i))\r\n        else:\r\n            # add the item data to the mapping\r\n            for index in mapping.keys():\r\n                text = nativestring(item.text(index))\r\n                if not text:\r\n                    continue\r\n                    \r\n                mapping[index].add(text)\r\n            \r\n            for c in range(item.childCount()):\r\n                self.__collectFilterTerms(mapping, item.child(c), level + 1)", "response": "This method returns a list of filter terms based on the column data for the items in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndestroying the locked view from this widget.", "response": "def __destroyLockedView(self):\r\n        \"\"\"\r\n        Destroys the locked view from this widget.\r\n        \"\"\"\r\n        if self._lockedView:\r\n            self._lockedView.close()\r\n            self._lockedView.deleteLater()\r\n            self._lockedView = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __filterItems(self,\r\n                      terms,\r\n                      autoExpand=True, \r\n                      caseSensitive=False,\r\n                      parent=None,\r\n                      level=0):\r\n        \"\"\"\r\n        Filters the items in this tree based on the inputed keywords.\r\n        \r\n        :param      terms           | {<int> column: [<str> term, ..], ..}\r\n                    autoExpand      | <bool>\r\n                    caseSensitive   | <bool>\r\n                    parent          | <QtGui.QTreeWidgetItem> || None\r\n        \r\n        :return     <bool> | found\r\n        \"\"\"\r\n        # make sure we're within our mex level for filtering\r\n        max_level = self.maximumFilterLevel()\r\n        if max_level != None and level > max_level:\r\n            return False\r\n        \r\n        found = False\r\n        items = []\r\n        \r\n        # collect the items to process\r\n        if not parent:\r\n            for i in range(self.topLevelItemCount()):\r\n                items.append(self.topLevelItem(i))\r\n        else:\r\n            for c in range(parent.childCount()):\r\n                items.append(parent.child(c))\r\n        \r\n        for item in items:\r\n            # if there is no filter keywords, then all items will be visible\r\n            if not any(terms.values()):\r\n                found = True\r\n                item.setHidden(False)\r\n                if autoExpand:\r\n                    if item.parent() is not None or self.rootIsDecorated():\r\n                        item.setExpanded(False)\r\n                \r\n                self.__filterItems(terms,\r\n                                   autoExpand, \r\n                                   caseSensitive,\r\n                                   item,\r\n                                   level + 1)\r\n            \r\n            else:\r\n                # match all generic keywords\r\n                generic         = terms.get(-1, [])\r\n                generic_found   = dict((key, False) for key in generic)\r\n                \r\n                # match all specific keywords\r\n                col_found  = dict((col, False) for col in terms if col != -1)\r\n                \r\n                # look for any matches for any column\r\n                mfound = False\r\n                \r\n                for column in self._filteredColumns:\r\n                    # determine the check text based on case sensitivity\r\n                    if caseSensitive:\r\n                        check = nativestring(item.text(column))\r\n                    else:\r\n                        check = nativestring(item.text(column)).lower()\r\n                    \r\n                    specific = terms.get(column, [])\r\n                    \r\n                    # make sure all the keywords match\r\n                    for key in generic + specific:\r\n                        if not key:\r\n                            continue\r\n                        \r\n                        # look for exact keywords\r\n                        elif key.startswith('\"') and key.endswith('\"'):\r\n                            if key.strip('\"') == check:\r\n                                if key in generic:\r\n                                    generic_found[key] = True\r\n                                \r\n                                if key in specific:\r\n                                    col_found[column] = True\r\n                        \r\n                        # look for ending keywords\r\n                        elif key.startswith('*') and not key.endswith('*'):\r\n                            if check.endswith(key.strip('*')):\r\n                                if key in generic:\r\n                                    generic_found[key] = True\r\n                                if key in specific:\r\n                                    col_found[column] = True\r\n                        \r\n                        # look for starting keywords\r\n                        elif key.endswith('*') and not key.startswith('*'):\r\n                            if check.startswith(key.strip('*')):\r\n                                if key in generic:\r\n                                    generic_found[key] = True\r\n                                if key in specific:\r\n                                    col_found[column] = True\r\n                        \r\n                        # look for generic keywords\r\n                        elif key.strip('*') in check:\r\n                            if key in generic:\r\n                                generic_found[key] = True\r\n                            if key in specific:\r\n                                col_found[column] = True\r\n                    \r\n                    mfound = all(col_found.values()) and \\\r\n                             all(generic_found.values())\r\n                    if mfound:\r\n                        break\r\n                \r\n                # if this item is not found, then check all children\r\n                if not mfound and (autoExpand or item.isExpanded()):\r\n                    mfound = self.__filterItems(terms,\r\n                                                autoExpand, \r\n                                                caseSensitive,\r\n                                                item,\r\n                                                level + 1)\r\n                \r\n                item.setHidden(not mfound)\r\n                \r\n                if mfound:\r\n                    found = True\r\n                \r\n                if mfound and autoExpand and item.childCount():\r\n                    item.setExpanded(True)\r\n        \r\n        return found", "response": "Filter the items in this tree based on the inputed keywords."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the user minimum size for a column.", "response": "def __setUserMinimumSize( self, section, oldSize, newSize ):\r\n        \"\"\"\r\n        Records the user minimum size for a column.\r\n        \r\n        :param      section | <int>\r\n                    oldSize | <int>\r\n                    newSize | <int>\r\n        \"\"\"\r\n        if self.isVisible():\r\n            self._columnMinimums[section] = newSize"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blockAllSignals( self, state ):\r\n        self.blockSignals(state)\r\n        self.header().blockSignals(state)", "response": "Blocks all the signals in the tree and header signals."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checkedItems(self, column=0, parent=None, recurse=True):\r\n        output = []\r\n        if not parent:\r\n            for i in range(self.topLevelItemCount()):\r\n                item = self.topLevelItem(i)\r\n                if item.checkState(column) == QtCore.Qt.Checked:\r\n                    output.append(item)\r\n                \r\n                if recurse:\r\n                    output += self.checkedItems(column, item, recurse)\r\n        else:\r\n            for c in range(parent.childCount()):\r\n                item = parent.child(c)\r\n                if item.checkState(column) == QtCore.Qt.Checked:\r\n                    output.append(item)\r\n                \r\n                if recurse:\r\n                    output += self.checkedItems(column, item, recurse)\r\n        return output", "response": "Returns a list of the checked items for this tree widget based on the inputed column and parent information."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears the items for this tree widget.", "response": "def clear(self):\r\n        \"\"\"\r\n        Removes all the items from this tree widget.  This will go through\r\n        and also destroy any XTreeWidgetItems prior to the model clearing\r\n        its references.\r\n        \"\"\"\r\n        # go through and properly destroy all the items for this tree\r\n        for item in self.traverseItems():\r\n            if isinstance(item, XTreeWidgetItem):\r\n                item.destroy()\r\n        \r\n        super(XTreeWidget, self).clear()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dictionary of filter terms for this tree widget based on the given columns and ignore list.", "response": "def collectFilterTerms( self, columns = None, ignore = None ):\r\n        \"\"\"\r\n        Returns a collection of filter terms for this tree widget based on \\\r\n        the results in the tree items.  If the optional columns or ignore \\\r\n        values are supplied then the specific columns will be used to generate \\\r\n        the search terms, and the columns in the ignore list will be stripped \\\r\n        out.\r\n        \r\n        :param      columns | [<str> column, ..] || None\r\n                    ignore  | [<str> column, ..] || None\r\n        \r\n        :return     {<str> column: [<str> term, ..]}\r\n        \"\"\"\r\n        if ( columns == None ):\r\n            columns = self.columns()\r\n            \r\n        if ( ignore ):\r\n            columns = [column for column in columns if not column in ignore]\r\n        \r\n        # this will return an int/set pairing which we will change to a str/list\r\n        terms = {}\r\n        for column in columns:\r\n            index = self.column(column)\r\n            if ( index == -1 ):\r\n                continue\r\n            \r\n            terms[index] = set()\r\n        \r\n        self.__collectFilterTerms(terms)\r\n        return dict([(self.columnOf(i[0]), list(i[1])) for i in terms.items()])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the index of the column with the given name.", "response": "def column(self, name):\r\n        \"\"\"\r\n        Returns the index of the column at the given name.\r\n        \r\n        :param      name | <str>\r\n        \r\n        :return     <int> (-1 if not found)\r\n        \"\"\"\r\n        columns = self.columns()\r\n        if name in columns:\r\n            return columns.index(name)\r\n        else:\r\n            check = projex.text.underscore(name)\r\n            for i, column in enumerate(columns):\r\n                if projex.text.underscore(column) == check:\r\n                    return i\r\n        return -1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the name of the column at the inputed index.", "response": "def columnOf(self, index):\r\n        \"\"\"\r\n        Returns the name of the column at the inputed index.\r\n        \r\n        :param      index | <int>\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        columns = self.columns()\r\n        if ( 0 <= index and index < len(columns) ):\r\n            return columns[index]\r\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef createHeaderMenu(self, index):\r\n        menu = QtGui.QMenu(self)\r\n        act = menu.addAction(\"Hide '%s'\" % self.columnOf(index))\r\n        act.triggered.connect( self.headerHideColumn )\r\n        \r\n        menu.addSeparator()\r\n        \r\n        act = menu.addAction('Sort Ascending')\r\n        act.setIcon(QtGui.QIcon(resources.find('img/sort_ascending.png')))\r\n        act.triggered.connect( self.headerSortAscending )\r\n        \r\n        act = menu.addAction('Sort Descending')\r\n        act.setIcon(QtGui.QIcon(resources.find('img/sort_descending.png')))\r\n        act.triggered.connect( self.headerSortDescending )\r\n        \r\n        act = menu.addAction('Resize to Contents')\r\n        act.setIcon(QtGui.QIcon(resources.find('img/treeview/fit.png')))\r\n        act.triggered.connect( self.resizeToContents )\r\n        \r\n        menu.addSeparator()\r\n        \r\n        colmenu = menu.addMenu( 'Show/Hide Columns' )\r\n        colmenu.setIcon(QtGui.QIcon(resources.find('img/columns.png')))\r\n        colmenu.addAction('Show All')\r\n        colmenu.addAction('Hide All')\r\n        colmenu.addSeparator()\r\n        \r\n        hitem = self.headerItem()\r\n        columns = self.columns()\r\n        for column in sorted(columns):\r\n            col    = self.column(column)\r\n            action = colmenu.addAction(column)\r\n            action.setCheckable(True)\r\n            action.setChecked(not self.isColumnHidden(col))\r\n        \r\n        colmenu.triggered.connect( self.toggleColumnByAction )\r\n        \r\n        menu.addSeparator()\r\n        exporters = self.exporters()\r\n        if exporters:\r\n            submenu = menu.addMenu('Export as')\r\n            submenu.setIcon(QtGui.QIcon(resources.find('img/export.png')))\r\n            for exporter in exporters:\r\n                act = submenu.addAction(exporter.name())\r\n                act.setData(wrapVariant(exporter.filetype()))\r\n            submenu.triggered.connect(self.exportAs)\r\n        \r\n        return menu", "response": "Creates a new header menu for the current index."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dragEnterEvent( self, event ):\r\n        filt = self.dragDropFilter()\r\n        if not filt:\r\n            super(XTreeWidget, self).dragEnterEvent(event)\r\n            return\r\n            \r\n        filt(self, event)", "response": "Processes the drag drop event using the filter set by the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess the drag move event using the filter set by the XTreeWidget class.", "response": "def dragMoveEvent( self, event ):\r\n        \"\"\"\r\n        Processes the drag drop event using the filter set by the \\\r\n        setDragDropFilter\r\n        \r\n        :param      event | <QDragEvent>\r\n        \"\"\"\r\n        filt = self.dragDropFilter()\r\n        if not filt:\r\n            super(XTreeWidget, self).dragMoveEvent(event)\r\n            return\r\n        \r\n        filt(self, event)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dropEvent( self, event ):\r\n        filt = self.dragDropFilter()\r\n        if not filt:\r\n            super(XTreeWidget, self).dropEvent(event)\r\n            return\r\n        \r\n        filt(self, event)", "response": "Processes the drag drop event using the dragDropFilter method setDragDropFilter\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprompting the edit for the inputed index given a trigger and event. Returns True if the edit was successful False otherwise.", "response": "def edit(self, index, trigger, event):\r\n        \"\"\"\r\n        Prompts the edit for the inputed index given a trigger and event.\r\n        \r\n        :param      index   | <QModelIndex>\r\n                    trigger | <EditTrigger>\r\n                    event   | <QEvent>\r\n        \"\"\"\r\n        # disable right-click editing\r\n        if trigger in (self.SelectedClicked, self.DoubleClicked) and \\\r\n           event.button() in (QtCore.Qt.RightButton, QtCore.Qt.MidButton):\r\n            return False\r\n        \r\n        if not self.isColumnEditingEnabled(index.column()):\r\n            return False\r\n        \r\n        item = self.itemFromIndex(index)\r\n        if isinstance(item, XTreeWidgetItem) and \\\r\n            not item.isColumnEditingEnabled(index.column()):\r\n            return False\r\n        \r\n        return super(XTreeWidget, self).edit(index, trigger, event)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nemit the sorting changed signal if the user clicks on a sorting column.", "response": "def emitSortingChanged( self, index ):\r\n        \"\"\"\r\n        Emits the sorting changed signal if the user clicks on a sorting\r\n        column.\r\n        \r\n        :param      index | <int>\r\n        \"\"\"\r\n        if not self.signalsBlocked() and self.isSortingEnabled():\r\n            self.sortingChanged.emit(index, self.header().sortIndicatorOrder())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef export(self, filename, exporter=None):\r\n        filename = nativestring(filename)\r\n        if exporter is None:\r\n            ext = os.path.splitext(filename)[1]\r\n            exporter = self.exporter(ext)\r\n        \r\n        if exporter:\r\n            return exporter.exportTree(self, filename)\r\n        else:\r\n            return False", "response": "Exports the data from this tree to the given file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exportAs(self, action):\r\n        plugin = self.exporter(unwrapVariant(action.data()))\r\n        if not plugin:\r\n            return False\r\n        \r\n        ftypes = '{0} (*{1});;All Files (*.*)'.format(plugin.name(),\r\n                                                      plugin.filetype())\r\n        filename = QtGui.QFileDialog.getSaveFileName(self.window(),\r\n                                                     'Export Data',\r\n                                                     '',\r\n                                                     ftypes)\r\n        \r\n        if type(filename) == tuple:\r\n            filename = filename[0]\r\n        \r\n        if filename:\r\n            return self.export(nativestring(filename), exporter=plugin)\r\n        return False", "response": "Prompts the user to export the information for this tree based on the available exporters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef viewportEvent( self, event ):\r\n        # intercept tooltips to use the XPopupWidget when desired\r\n        if event.type() == event.ToolTip and self.usePopupToolTip():\r\n            index = self.indexAt(event.pos())\r\n            item  = self.itemAt(event.pos())\r\n            \r\n            if not (index and item):\r\n                event.ignore()\r\n                return False\r\n            \r\n            tip   = item.toolTip(index.column())\r\n            rect  = self.visualRect(index)\r\n            point = QtCore.QPoint(rect.left() + 5, rect.bottom() + 1)\r\n            point = self.viewport().mapToGlobal(point)\r\n            \r\n            if tip:\r\n                XPopupWidget.showToolTip(tip, \r\n                                         anchor = XPopupWidget.Anchor.TopLeft,\r\n                                         point  = point,\r\n                                         parent = self)\r\n            \r\n            event.accept()\r\n            return True\r\n        else:\r\n            return super(XTreeWidget, self).viewportEvent(event)", "response": "Handles the viewport event."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next item in the tree.", "response": "def findNextItem(self, item):\r\n        \"\"\"\r\n        Returns the next item in the tree.\r\n        \r\n        :param      item | <QtGui.QTreeWidgetItem>\r\n        \r\n        :return     <QtGui.QTreeWidgetItem>\r\n        \"\"\"\r\n        if not item:\r\n            return None\r\n        \r\n        if item.childCount():\r\n            return item.child(0)\r\n        \r\n        while item.parent():\r\n            index = item.parent().indexOfChild(item)\r\n            child = item.parent().child(index+1)\r\n            if child:\r\n                return child\r\n            \r\n            item = item.parent()\r\n        \r\n        index = self.indexOfTopLevelItem(item)\r\n        return self.topLevelItem(index+1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the previous item in the tree.", "response": "def findPreviousItem(self, item):\r\n        \"\"\"\r\n        Returns the previous item in the tree.\r\n        \r\n        :param      item | <QtGui.QTreeWidgetItem>\r\n        \r\n        :return     <QtGui.QTreeWidgetItem> || None\r\n        \"\"\"\r\n        if not item:\r\n            return None\r\n        \r\n        while item.parent():\r\n            index = item.parent().indexOfChild(item)\r\n            if index == 0:\r\n                return item.parent()\r\n            \r\n            child = item.parent().child(index-1)\r\n            if child:\r\n                while child.childCount():\r\n                    child = child.child(child.childCount() - 1)\r\n                return child\r\n            \r\n            item = item.parent()\r\n        \r\n        index = self.indexOfTopLevelItem(item)\r\n        out = self.topLevelItem(index-1)\r\n        while out and out.childCount():\r\n            out = out.child(out.childCount() - 1)\r\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filterItems(self,\r\n                    terms,\r\n                    autoExpand=True,\r\n                    caseSensitive=False):\r\n        \"\"\"\r\n        Filters the items in this tree based on the inputed text.\r\n        \r\n        :param      terms           | <str> || {<str> column: [<str> opt, ..]}\r\n                    autoExpand      | <bool>\r\n                    caseSensitive   | <bool>\r\n        \"\"\"\r\n        # create a dictionary of options\r\n        if type(terms) != dict:\r\n            terms = {'*': nativestring(terms)}\r\n        \r\n        # create a dictionary of options\r\n        if type(terms) != dict:\r\n            terms = {'*': nativestring(terms)}\r\n        \r\n        # validate the \"all search\"\r\n        if '*' in terms and type(terms['*']) != list:\r\n            sterms = nativestring(terms['*'])\r\n            \r\n            if not sterms.strip():\r\n                terms.pop('*')\r\n            else:\r\n                dtype_matches = COLUMN_FILTER_EXPR.findall(sterms)\r\n                \r\n                # generate the filter for each data type\r\n                for match, dtype, values in dtype_matches:\r\n                    sterms = sterms.replace(match, '')\r\n                    terms.setdefault(dtype, [])\r\n                    terms[dtype] += values.split(',')\r\n                \r\n                keywords = sterms.replace(',', '').split()\r\n                while '' in keywords:\r\n                    keywords.remove('')\r\n                \r\n                terms['*'] = keywords\r\n        \r\n        # filter out any columns that are not being searched\r\n        filtered_columns = self.filteredColumns()\r\n        filter_terms = {}\r\n        for column, keywords in terms.items():\r\n            index = self.column(column)\r\n            if column != '*' and not index in filtered_columns:\r\n                continue\r\n            \r\n            if not caseSensitive:\r\n                keywords = [nativestring(keyword).lower() for keyword in keywords]\r\n            else:\r\n                keywords = map(str, keywords)\r\n            \r\n            filter_terms[index] = keywords\r\n        \r\n        self.__filterItems(filter_terms, autoExpand, caseSensitive, 0)", "response": "Filter the items in this tree based on the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gridPen(self):\r\n        delegate = self.itemDelegate()\r\n        if isinstance(delegate, XTreeWidgetDelegate):\r\n            return delegate.gridPen()\r\n        return QtGui.QPen()", "response": "Returns the pen that will be used when drawing the grid lines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning whether or not the grid lines should extend through the tree area or not.", "response": "def extendsTree( self ):\r\n        \"\"\"\r\n        Returns whether or not the grid lines should extend through the tree \\\r\n        area or not.\r\n        \r\n        :return <bool>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            return delegate.extendsTree()\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef headerHideColumn( self ):\r\n        self.setColumnHidden(self._headerIndex, True)\r\n        \r\n        # ensure we at least have 1 column visible\r\n        found = False\r\n        for col in range(self.columnCount()):\r\n            if ( not self.isColumnHidden(col) ):\r\n                found = True\r\n                break\r\n        \r\n        if ( not found ):\r\n            self.setColumnHidden(0, False)", "response": "Hides the current column set by the header index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef headerSortAscending( self ):\r\n        self.setSortingEnabled(True)\r\n        self.sortByColumn(self._headerIndex, QtCore.Qt.AscendingOrder)", "response": "Sort the column at the current header index by ascending order."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef headerSortDescending( self ):\r\n        self.setSortingEnabled(True)\r\n        self.sortByColumn(self._headerIndex, QtCore.Qt.DescendingOrder)", "response": "Sort the column at the current header index by descending order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hiddenColumns( self ):\r\n        output  = []\r\n        columns = self.columns()\r\n        for c, column in enumerate(columns):\r\n            if ( not self.isColumnHidden(c) ):\r\n                continue\r\n            output.append(column)\r\n        return output", "response": "Returns a list of the hidden columns for this tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef highlightByAlternate(self):\r\n        palette = QtGui.QApplication.palette()\r\n        palette.setColor(palette.HighlightedText, palette.color(palette.Text))\r\n        \r\n        clr = palette.color(palette.AlternateBase)\r\n        palette.setColor(palette.Highlight, clr.darker(110))\r\n        self.setPalette(palette)", "response": "Sets the palette highlighting for this tree widget to use a darkerer version of the alternate color vs. the standard highlighting."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hoveredItem(self):\r\n        out = None\r\n        if ( self._hoveredItem is not None ):\r\n            out = self._hoveredItem()\r\n            \r\n            if out is None:\r\n                self._hoveredItem = None\r\n        \r\n        return out", "response": "Returns the currently hovered item or None if no item is currently hovered."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndismiss the hovered item when the tree is exited.", "response": "def leaveEvent( self, event ):\r\n        \"\"\"\r\n        Dismisses the hovered item when the tree is exited.\r\n        \r\n        :param      event | <QEvent>\r\n        \"\"\"\r\n        hitem = self.hoveredItem()\r\n        hcol  = self.hoveredColumn()\r\n        \r\n        if ( hitem != None ):\r\n            self._hoveredItem   = None\r\n            self._hoveredColumn = -1\r\n            \r\n            rect = self.visualItemRect(hitem)\r\n            rect.setWidth(self.viewport().width())\r\n            self.viewport().update(rect)\r\n        \r\n        super(XTreeWidget, self).leaveEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlocks the tree view to the specified column.", "response": "def lockToColumn(self, index):\r\n        \"\"\"\r\n        Sets the column that the tree view will lock to.  If None is supplied,\r\n        then locking will be removed.\r\n        \r\n        :param      index | <int> || None\r\n        \"\"\"\r\n        self._lockColumn = index\r\n        \r\n        if index is None:\r\n            self.__destroyLockedView()\r\n            return\r\n        else:\r\n            if not self._lockedView:\r\n                view = QtGui.QTreeView(self.parent())\r\n                view.setModel(self.model())\r\n                view.setSelectionModel(self.selectionModel())\r\n                view.setItemDelegate(self.itemDelegate())\r\n                view.setFrameShape(view.NoFrame)\r\n                view.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n                view.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n                view.setRootIsDecorated(self.rootIsDecorated())\r\n                view.setUniformRowHeights(True)\r\n                view.setFocusProxy(self)\r\n                view.header().setFocusProxy(self.header())\r\n                view.setStyleSheet(self.styleSheet())\r\n                view.setAutoScroll(False)\r\n                view.setSortingEnabled(self.isSortingEnabled())\r\n                view.setPalette(self.palette())\r\n                view.move(self.x(), self.y())\r\n                \r\n                self.setAutoScroll(False)\r\n                self.setUniformRowHeights(True)\r\n                \r\n                view.collapsed.connect(self.collapse)\r\n                view.expanded.connect(self.expand)\r\n                view.expanded.connect(self.__updateLockedView)\r\n                view.collapsed.connect(self.__updateLockedView)\r\n                \r\n                view_head = view.header()\r\n                for i in range(self.columnCount()):\r\n                    view_head.setResizeMode(i, self.header().resizeMode(i))\r\n                \r\n                view.header().sectionResized.connect(self.__updateStandardSection)\r\n                self.header().sectionResized.connect(self.__updateLockedSection)\r\n                \r\n                vbar = view.verticalScrollBar()\r\n                self.verticalScrollBar().valueChanged.connect(vbar.setValue)\r\n                \r\n                self._lockedView = view\r\n            \r\n            self.__updateLockedView()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the mime data for dragging for this instance.", "response": "def mimeData(self, items):\r\n        \"\"\"\r\n        Returns the mime data for dragging for this instance.\r\n        \r\n        :param      items | [<QtGui.QTreeWidgetItem>, ..]\r\n        \"\"\"\r\n        func = self.dataCollector()\r\n        if func:\r\n            return func(self, items)\r\n        \r\n        data = super(XTreeWidget, self).mimeData(items)\r\n        \r\n        # return defined custom data\r\n        if len(items) == 1:\r\n            try:\r\n                dragdata = items[0].dragData()\r\n            except AttributeError:\r\n                return data\r\n            \r\n            if not data:\r\n                data = QtCore.QMimeData()\r\n            \r\n            urls = []\r\n            for format, value in dragdata.items():\r\n                if format == 'url':\r\n                    urls.append(QtCore.QUrl(value))\r\n                else:\r\n                    data.setData(format, QtCore.QByteArray(value))\r\n            \r\n            data.setUrls(urls)\r\n            return data\r\n        \r\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noverloads when a mouse click occurs on a selected item.", "response": "def mouseDoubleClickEvent(self, event):\r\n        \"\"\"\r\n        Overloads when a mouse press occurs.  If in editable mode, and the\r\n        click occurs on a selected index, then the editor will be created\r\n        and no selection change will occur.\r\n        \r\n        :param      event | <QMousePressEvent>\r\n        \"\"\"\r\n        item = self.itemAt(event.pos())\r\n        column = self.columnAt(event.pos().x())\r\n        \r\n        mid_button = event.button() == QtCore.Qt.MidButton\r\n        ctrl_click = event.button() == QtCore.Qt.LeftButton and \\\r\n                     event.modifiers() == QtCore.Qt.ControlModifier\r\n        \r\n        if mid_button or ctrl_click:\r\n            self.itemMiddleDoubleClicked.emit(item, column)\r\n        elif event.button() == QtCore.Qt.RightButton:\r\n            self.itemRightDoubleClicked.emit(item, column)\r\n        else:\r\n            super(XTreeWidget, self).mouseDoubleClickEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mousePressEvent(self, event):\r\n        item = self.itemAt(event.pos())\r\n        column = self.columnAt(event.pos().x())\r\n\r\n        mid_button = event.button() == QtCore.Qt.MidButton\r\n        ctrl_click = event.button() == QtCore.Qt.LeftButton and \\\r\n                     event.modifiers() == QtCore.Qt.ControlModifier\r\n\r\n        if item and column != -1:\r\n            self._downItem   = weakref.ref(item)\r\n            self._downColumn = column\r\n            self._downState  = item.checkState(column)\r\n\r\n        elif not item:\r\n            self.setCurrentItem(None)\r\n            self.clearSelection()\r\n\r\n        if (mid_button or ctrl_click) and item and column != -1:\r\n            self.itemMiddleClicked.emit(item, column)\r\n\r\n        index = self.indexAt(event.pos())\r\n        sel_model = self.selectionModel()\r\n\r\n        if self.isEditable() and index and sel_model.isSelected(index):\r\n            sel_model.setCurrentIndex(index, sel_model.NoUpdate)\r\n            self.edit(index, self.SelectedClicked, event)\r\n            event.accept()\r\n        else:\r\n            super(XTreeWidget, self).mousePressEvent(event)", "response": "Overloads when a mouse press occurs on a tree item or a selection change occurs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mouseMoveEvent(self, event):\r\n        if self.hoverMode() != XTreeWidget.HoverMode.NoHover:\r\n            item  = self.itemAt(event.pos())\r\n            col   = self.columnAt(event.pos().x())\r\n            hitem = self.hoveredItem()\r\n            hcol  = self.hoveredColumn()\r\n\r\n            if (id(item), col) != (id(hitem), hcol):\r\n                if ( item ):\r\n                    self._hoveredItem = weakref.ref(item)\r\n                else:\r\n                    self._hoveredItem = None\r\n\r\n                self._hoveredColumn = col\r\n\r\n                rect  = self.visualItemRect(item)\r\n                hrect = self.visualItemRect(hitem)\r\n\r\n                rect.setWidth(self.viewport().width())\r\n                hrect.setWidth(self.viewport().width())\r\n\r\n                self.viewport().update(rect)\r\n                self.viewport().update(hrect)\r\n\r\n        super(XTreeWidget, self).mouseMoveEvent(event)", "response": "Handles the mouse move event."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef moveCursor(self, cursorAction, modifiers):\r\n        # moves to the next index\r\n        if cursorAction not in (self.MoveNext,\r\n                                self.MoveRight,\r\n                                self.MovePrevious,\r\n                                self.MoveLeft,\r\n                                self.MoveHome,\r\n                                self.MoveEnd):\r\n            return super(XTreeWidget, self).moveCursor(cursorAction, modifiers)\r\n        \r\n        header = self.header()\r\n        index = self.currentIndex()\r\n        row  = index.row()\r\n        col  = index.column()\r\n        vcol = None\r\n        \r\n        if cursorAction == self.MoveEnd:\r\n            vcol = header.count() - 1\r\n            delta = -1\r\n        elif cursorAction == self.MoveHome:\r\n            vcol = 0\r\n            delta = +1\r\n        elif cursorAction in (self.MoveNext, self.MoveRight):\r\n            delta = +1\r\n        elif cursorAction in (self.MovePrevious, self.MoveLeft):\r\n            delta = -1\r\n        \r\n        if vcol is None:\r\n            vcol = header.visualIndex(col) + delta\r\n        \r\n        ncol = header.count()\r\n        lcol = header.logicalIndex(vcol)\r\n        \r\n        while 0 <= vcol and vcol < ncol and self.isColumnHidden(lcol):\r\n            vcol += delta\r\n            lcol = header.logicalIndex(vcol)\r\n        \r\n        sibling = index.sibling(index.row(), lcol)\r\n        if sibling and sibling.isValid():\r\n            return sibling\r\n        elif delta < 0:\r\n            return index.sibling(index.row() - 1, header.logicalIndex(ncol - 1))\r\n        else:\r\n            return index.sibling(index.row() + 1, header.visualIndex(0))", "response": "Returns a new index pointing to the next object in the view based on the given cursorAction and modifiers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestoring properties for this tree widget from the inputed XML.", "response": "def restoreXml(self, xml):\r\n        \"\"\"\r\n        Restores properties for this tree widget from the inputed XML.\r\n        \r\n        :param      xml | <xml.etree.ElementTree.Element>\r\n        \r\n        :return     <bool> success\r\n        \"\"\"\r\n        if xml is None:\r\n            return False\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        \r\n        # restore column data\r\n        header = self.header()\r\n        xcolumns = xml.find('columns')\r\n        if xcolumns is not None:\r\n            for xcolumn in xcolumns:\r\n                name   = xcolumn.get('name')\r\n                index  = self.column(name)\r\n                vindex = int(xcolumn.get('visualIndex', index))\r\n                currvi = header.visualIndex(index)\r\n                \r\n                # restore from name\r\n                if index == -1:\r\n                    continue\r\n                \r\n                if currvi != vindex:\r\n                    header.moveSection(currvi, vindex)\r\n                \r\n                self.setColumnHidden(index, xcolumn.get('hidden') == 'True')\r\n                \r\n                if not self.isColumnHidden(index):\r\n                    width  = int(xcolumn.get('width', self.columnWidth(index)))\r\n                    self.setColumnWidth(index, width)\r\n        \r\n        # restore order data\r\n        headerState = xml.get('headerState')\r\n        if headerState is not None:\r\n            state = QtCore.QByteArray.fromBase64(str(headerState))\r\n            self.header().restoreState(state)\r\n        \r\n        sortColumn = int(xml.get('sortColumn', 0))\r\n        sortingEnabled = xml.get('sortingEnabled') == 'True'\r\n        sortOrder = QtCore.Qt.SortOrder(int(xml.get('sortOrder', 0)))\r\n        \r\n        if sortingEnabled:\r\n            self.setSortingEnabled(sortingEnabled)\r\n            self.sortByColumn(sortColumn, sortOrder)\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef restoreSettings(self, settings):\r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        \r\n        # restore order data\r\n        headerState = unwrapVariant(settings.value('headerState'))\r\n        if headerState is not None:\r\n            state = QtCore.QByteArray.fromBase64(str(headerState))\r\n            self.header().restoreState(state)\r\n        \r\n        sortingEnabled = unwrapVariant(settings.value('sortingEnabled'))\r\n        if sortingEnabled:\r\n            sortColumn = unwrapVariant(settings.value('sortColumn', 0))\r\n            sortOrder = QtCore.Qt.SortOrder(unwrapVariant(settings.value('sortOrder')))\r\n            self.setSortingEnabled(sortingEnabled)\r\n            self.sortByColumn(sortColumn, sortOrder)\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)", "response": "Restores properties for this tree widget from the inputed XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef saveSettings(self, settings):\r\n        # save order data\r\n        settings.setValue('headerState', wrapVariant(str(self.header().saveState().toBase64())))\r\n        settings.setValue('sortColumn', wrapVariant(str(self.sortColumn())))\r\n        settings.setValue('sortOrder', wrapVariant(str(int(self.sortOrder()))))\r\n        settings.setValue('sortingEnabled', wrapVariant(str(self.isSortingEnabled())))", "response": "Saves the settings for this tree to the inputed xml entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef saveXml(self, xml):\r\n        if xml is None:\r\n            return False\r\n        \r\n        # save order data\r\n        xml.set('headerState', str(self.header().saveState().toBase64()))\r\n        xml.set('sortColumn', str(self.sortColumn()))\r\n        xml.set('sortOrder', str(int(self.sortOrder())))\r\n        xml.set('sortingEnabled', str(self.isSortingEnabled()))\r\n        \r\n        return True", "response": "Saves the data for this tree to the inputed xml entry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset whether or not to use arrows for the grouping mechanism.", "response": "def setArrowStyle( self, state ):\r\n        \"\"\"\r\n        Sets whether or not to use arrows for the grouping mechanism.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._arrowStyle = state\r\n        \r\n        if not state:\r\n            self.setStyleSheet('')\r\n        else:\r\n            right = resources.find('img/treeview/triangle_right.png')\r\n            down  = resources.find('img/treeview/triangle_down.png')\r\n            opts  = (right.replace('\\\\', '/'), down.replace('\\\\', '/'))\r\n            self.setStyleSheet(ARROW_STYLESHEET % opts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the column count and header labels of the table.", "response": "def setColumns(self, columns):\r\n        \"\"\"\r\n        Sets the column count and list of columns to the inputed column list.\r\n        \r\n        :param      columns | [<str>, ..]\r\n        \"\"\"\r\n        self.setColumnCount(len(columns))\r\n        self.setHeaderLabels(columns)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the method that will be used to collect mime data for dragging items from this tree.", "response": "def setDataCollector( self, collector ):\r\n        \"\"\"\r\n        Sets the method that will be used to collect mime data for dragging \\\r\n        items from this tree.\r\n        \r\n        :warning    The data collector is stored as a weak-reference, so using \\\r\n                    mutable methods will not be stored well.  Things like \\\r\n                    instancemethods will not hold their pointer after they \\\r\n                    leave the scope that is being used.  Instead, use a \\\r\n                    classmethod or staticmethod to define the collector.\r\n        \r\n        :param      collector | <function> || <method> || None\r\n        \"\"\"\r\n        if ( collector ):\r\n            self._dataCollectorRef = weakref.ref(collector)\r\n        else:\r\n            self._dataCollectorRef = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the drag drop filter for this widget.", "response": "def setDragDropFilter( self, ddFilter ):\r\n        \"\"\"\r\n        Sets the drag drop filter for this widget.\r\n        \r\n        :warning    The dragdropfilter is stored as a weak-reference, so using \\\r\n                    mutable methods will not be stored well.  Things like \\\r\n                    instancemethods will not hold their pointer after they \\\r\n                    leave the scope that is being used.  Instead, use a \\\r\n                    classmethod or staticmethod to define the dragdropfilter.\r\n        \r\n        :param      ddFilter | <function> || <method> || None\r\n        \"\"\"\r\n        if ddFilter:\r\n            self._dragDropFilterRef = weakref.ref(ddFilter)\r\n        else:\r\n            self._dragDropFilterRef = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the editable state for this instance.", "response": "def setEditable( self, state ):\r\n        \"\"\"\r\n        Sets the editable state for this instance.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._editable = state\r\n        \r\n        if not state:\r\n            self.setEditTriggers(QtGui.QTreeWidget.NoEditTriggers)\r\n        else:\r\n            triggers  = QtGui.QTreeWidget.DoubleClicked\r\n            triggers |= QtGui.QTreeWidget.AnyKeyPressed\r\n            triggers |= QtGui.QTreeWidget.EditKeyPressed\r\n            triggers |= QtGui.QTreeWidget.SelectedClicked\r\n            \r\n            self.setEditTriggers(triggers)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting whether or not this delegate should render its row line through the tree area.", "response": "def setExtendsTree( self, state ):\r\n        \"\"\"\r\n        Set whether or not this delegate should render its row line through \\\r\n        the tree area.\r\n        \r\n        :return     <state>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            delegate.setExtendsTree(state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the pen that will be used when drawing the grid lines.", "response": "def setGridPen( self, gridPen ):\r\n        \"\"\"\r\n        Sets the pen that will be used when drawing the grid lines.\r\n        \r\n        :param      gridPen | <QtGui.QPen> || <QtGui.QColor>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            delegate.setGridPen(gridPen)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setColumnHidden( self, column, state ):\r\n        super(XTreeWidget, self).setColumnHidden(column, state)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.columnHiddenChanged.emit(column, state)\r\n            self.executeDelayedItemsLayout()", "response": "Sets the hidden state for the inputed column."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setHiddenColumns(self, hidden):\r\n        colnames = self.columns()\r\n        for c, column in enumerate(colnames):\r\n            self.setColumnHidden(c, column in hidden)", "response": "Sets the columns that should be hidden based on the inputed list of names."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setShowGrid( self, state ):\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            delegate.setShowGrid(state)", "response": "Sets whether or not this item should draw its grid lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets whether or not columns should be rendered when drawing the grid.", "response": "def setShowGridColumns( self, state ):\r\n        \"\"\"\r\n        Sets whether or not columns should be rendered when drawing the grid.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            delegate.setShowGridColumns(state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting whether or not the grid rows should be rendered when drawing the grid.", "response": "def setShowGridRows( self, state ):\r\n        \"\"\"\r\n        Sets whether or not the grid rows should be rendered when drawing the \\\r\n        grid.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            delegate.setShowGridRows(state)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset whether or not the delegate should render rich text information as HTML when drawing the contents of the item.", "response": "def setShowRichText( self, state ):\r\n        \"\"\"\r\n        Sets whether or not the delegate should render rich text information \\\r\n        as HTML when drawing the contents of the item.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if isinstance(delegate, XTreeWidgetDelegate):\r\n            delegate.setShowRichText(state)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setVisibleColumns(self, visible):\r\n        colnames = self.columns()\r\n        for c, column in enumerate(colnames):\r\n            self.setColumnHidden(c, column not in visible)", "response": "Sets the list of visible columns for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef showGrid( self ):\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            return delegate.showGrid()\r\n        return False", "response": "Returns whether or not this item should draw its grid lines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef showGridRows( self ):\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            return delegate.showGridRows()\r\n        return None", "response": "Returns whether or not this delegate should draw rows when rendering the grid."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows the header menu at the given position.", "response": "def showHeaderMenu( self, pos):\r\n        \"\"\"\r\n        Displays the header menu for this tree widget.\r\n        \r\n        :param      pos | <QtCore.QPoint> || None\r\n        \"\"\"\r\n        header = self.header()\r\n        index  = header.logicalIndexAt(pos)\r\n        self._headerIndex = index\r\n        \r\n        # show a pre-set menu\r\n        if self._headerMenu:\r\n            menu = self._headerMenu\r\n        else:\r\n            menu = self.createHeaderMenu(index)\r\n        \r\n        # determine the point to show the menu from\r\n        if pos is not None:\r\n            point = header.mapToGlobal(pos)\r\n        else:\r\n            point = QtGui.QCursor.pos()\r\n        \r\n        self.headerMenuAboutToShow.emit(menu, index)\r\n        menu.exec_(point)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn whether or not the tree is holding richtext information and should render HTML when drawing the data.", "response": "def showRichText( self ):\r\n        \"\"\"\r\n        Returns whether or not the tree is holding richtext information and \\\r\n        should render HTML when drawing the data.\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        delegate = self.itemDelegate()\r\n        if ( isinstance(delegate, XTreeWidgetDelegate) ):\r\n            return delegate.showRichText()\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sortByColumn(self, column, order=QtCore.Qt.AscendingOrder):\r\n        super(XTreeWidget, self).sortByColumn(column, order)\r\n        self._sortOrder = order", "response": "Sort the tree by the given column."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsorting the tree by the inputed column name.", "response": "def sortByColumnName(self, name, order=QtCore.Qt.AscendingOrder):\r\n        \"\"\"\r\n        Sorts the tree by the inputed column name's index and the given order.\r\n        \r\n        :param      name    | <str>\r\n                    order   | <QtCore.Qt.SortOrder>\r\n        \"\"\"\r\n        self.setSortingEnabled(True)\r\n        self.sortByColumn(self.column(name), order)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart a new drag event for this tree widget.", "response": "def startDrag( self, supportedActions ):\r\n        \"\"\"\r\n        Starts a new drag event for this tree widget.  Overloading from the\r\n        default QTreeWidget class to define a better pixmap option when\r\n        dragging many items.\r\n        \r\n        :param      supportedActions | <QtCore.Qt.DragActions>\r\n        \"\"\"\r\n        if ( not self.useDragPixmaps() ):\r\n            return super(XTreeWidget, self).startDrag(supportedActions)\r\n        \r\n        filt  = lambda x: x.flags() & QtCore.Qt.ItemIsDragEnabled\r\n        items = filter(filt, self.selectedItems())\r\n        if ( not items ):\r\n            return\r\n        \r\n        data = self.mimeData(items)\r\n        if ( not data ):\r\n            return\r\n        \r\n        if ( len(items) > 1 ):\r\n            pixmap = self.dragMultiPixmap()\r\n        else:\r\n            pixmap = self.dragSinglePixmap()\r\n        \r\n        # create the drag event\r\n        drag = QtGui.QDrag(self)\r\n        drag.setMimeData(data)\r\n        drag.setPixmap(pixmap)\r\n        \r\n        drag.exec_(supportedActions, QtCore.Qt.MoveAction)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef toggleColumnByAction( self, action ):\r\n        if ( action.text() == 'Show All' ):\r\n            self.blockSignals(True)\r\n            self.setUpdatesEnabled(False)\r\n            for col in range(self.columnCount()):\r\n                self.setColumnHidden(col, False)\r\n            self.setUpdatesEnabled(True)\r\n            self.blockSignals(False)\r\n            \r\n            self.setColumnHidden(0, False)\r\n            \r\n        elif ( action.text() == 'Hide All' ):\r\n            self.blockSignals(True)\r\n            self.setUpdatesEnabled(False)\r\n            for col in range(self.columnCount()):\r\n                self.setColumnHidden(col, True)\r\n                \r\n            # ensure we have at least 1 column visible\r\n            self.blockSignals(False)\r\n            self.setUpdatesEnabled(True)\r\n            \r\n            self.setColumnHidden(0, False)\r\n            \r\n        else:\r\n            col     = self.column(action.text())\r\n            state   = not action.isChecked()\r\n            self.setColumnHidden(col, state)\r\n            if ( state ):\r\n                self.resizeColumnToContents(col)\r\n            \r\n            # ensure we at least have 1 column visible\r\n            found = False\r\n            for col in range(self.columnCount()):\r\n                if ( not self.isColumnHidden(col) ):\r\n                    found = True\r\n                    break\r\n            \r\n            if not found:\r\n                self.setColumnHidden(0, False)\r\n        \r\n        self.resizeToContents()\r\n        self.update()", "response": "Toggles whether or not the column at the inputed action s name should be hidden."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of top level items for this tree.", "response": "def topLevelItems(self):\r\n        \"\"\"\r\n        Returns the list of top level nodes for this tree.\r\n        \r\n        :return     [<QtGui.QTreeWidgetItem>, ..]\r\n        \"\"\"\r\n        try:\r\n            for i in xrange(self.topLevelItemCount()):\r\n                yield self.topLevelItem(i)\r\n        except RuntimeError:\r\n            # can be raised when iterating on a deleted tree widget.\r\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an iterator that yields the items of this tree in depth - first or breadth - first fashion.", "response": "def traverseItems(self,\r\n                      mode=TraverseMode.DepthFirst,\r\n                      parent=None):\r\n        \"\"\"\r\n        Generates a tree iterator that will traverse the items of this tree\r\n        in either a depth-first or breadth-first fashion.\r\n        \r\n        :param      mode | <XTreeWidget.TraverseMode>\r\n                    recurse | <bool>\r\n        \r\n        :return     <generator>\r\n        \"\"\"\r\n        try:\r\n            if parent:\r\n                count = parent.childCount()\r\n                func = parent.child\r\n            else:\r\n                count = self.topLevelItemCount()\r\n                func = self.topLevelItem\r\n        except RuntimeError:\r\n            # can be raised when iterating on a deleted tree widget.\r\n            return\r\n        \r\n        next = []\r\n        for i in range(count):\r\n            try:\r\n                item = func(i)\r\n            except RuntimeError:\r\n                # can be raised when iterating on a deleted tree widget\r\n                return\r\n            else:\r\n                yield item\r\n                if mode == XTreeWidget.TraverseMode.DepthFirst:\r\n                    for child in self.traverseItems(mode, item):\r\n                        yield child\r\n                else:\r\n                    next.append(item)\r\n        \r\n        for item in next:\r\n            for child in self.traverseItems(mode, item):\r\n                yield child"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef visibleColumns(self):\r\n        return [self.columnOf(c) for c in range(self.columnCount()) \\\r\n                if not self.isColumnHidden(c)]", "response": "Returns a list of the visible column names for this widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visualRect(self, index):\r\n        rect = super(XTreeWidget, self).visualRect(index)\r\n        item = self.itemFromIndex(index)\r\n        if not rect.isNull() and item and item.isFirstColumnSpanned():\r\n            vpos = self.viewport().mapFromParent(QtCore.QPoint(0, 0))\r\n            rect.setX(vpos.x())\r\n            rect.setWidth(self.width())\r\n            return rect\r\n        return rect", "response": "Returns the visual rectangle for the inputed index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun your app in gevent. spawn", "response": "def gevent_run(app, monkey_patch=True, start=True, debug=False,\n               **kwargs):  # pragma: no cover\n    \"\"\"Run your app in gevent.spawn, run simple loop if start == True\n\n    :param app: queues.Microservice instance\n    :param monkey_patch: boolean, use gevent.monkey.patch_all() for patching standard modules, default: True\n    :param start: boolean, if True, server will be start (simple loop)\n    :param kwargs: other params for WSGIServer(**kwargs)\n    :return: server\n    \"\"\"\n    if monkey_patch:\n        from gevent import monkey\n\n        monkey.patch_all()\n\n    import gevent\n\n    gevent.spawn(app.run, debug=debug, **kwargs)\n\n    if start:\n        while not app.stopped:\n            gevent.sleep(0.1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the index of the column with the given name.", "response": "def column( self, name ):\r\n        \"\"\"\r\n        Returns the index of the column at the given name.\r\n        \r\n        :param      name | <str>\r\n        \r\n        :return     <int> (-1 if not found)\r\n        \"\"\"\r\n        columns = self.columns()\r\n        if ( name in columns ):\r\n            return columns.index(name)\r\n        return -1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the name of the column at the inputed index.", "response": "def columnNameAt( self, index ):\n        \"\"\"\n        Returns the name of the column at the inputed index.\n        \n        :param      index | <int>\n        \n        :return     <str>\n        \"\"\"\n        columns = self.columns()\n        if ( 0 <= index and index < len(columns) ):\n            return columns[index]\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of column names for this table widget s columns.", "response": "def columns( self ):\r\n        \"\"\"\r\n        Returns the list of column names for this table widget's columns.\r\n        \r\n        :return     [<str>, ..]\r\n        \"\"\"\n        output = []\n        for c in range(self.columnCount()):\n            hitem  = self.horizontalHeaderItem(c)\n            text = nativestring(hitem.text())\n            if ( not text ):\n                text = nativestring(hitem.toolTip())\n            output.append(text)\r\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dataCollector( self ):\n        func = None\n        if ( self._dataCollectorRef ):\n            func = self._dataCollectorRef()\n        \n        if ( not func ):\n            self._dataCollectorRef = None\n        \n        return func", "response": "Returns a method or function that will be used to collect mime data for a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the drag drop event using the filter set by the dragDropFilter returns True if the event was handled by the filter set by the setDragDropFilter otherwise returns False", "response": "def dragEnterEvent( self, event ):\n        \"\"\"\n        Processes the drag drop event using the filter set by the \\\n        setDragDropFilter\n        \n        :param      event | <QDragEvent>\n        \"\"\"\n        filt = self.dragDropFilter()\n        if ( filt and filt(self, event) ):\r\n            return\r\n            \n        super(XTableWidget, self).dragEnterEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing the drag drop event using the filter set by the dragDropFilterProperty method.", "response": "def dragMoveEvent( self, event ):\n        \"\"\"\n        Processes the drag drop event using the filter set by the \\\n        setDragDropFilter\n        \n        :param      event | <QDragEvent>\n        \"\"\"\n        filt = self.dragDropFilter()\n        if ( filt and filt(self, event) ):\r\n            return\r\n        \n        super(XTableWidget, self).dragMoveEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess the drag drop event and returns the related object.", "response": "def dropEvent( self, event ):\n        \"\"\"\n        Processes the drag drop event using the filter set by the \\\n        setDragDropFilter\n        \n        :param      event | <QDropEvent>\n        \"\"\"\n        filt = self.dragDropFilter()\n        if ( filt and not filt(self, event) ):\n            return\n        \n        super(XTableWidget, self).dropEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mimeData( self, items ):\n        func = self.dataCollector()\n        if ( func ):\n            return func(self, items)\n            \n        return super(XTableWidget, self).mimeData(items)", "response": "Returns the mime data for dragging for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setColumns( self, columns ):\r\n        self.setColumnCount(len(columns))\r\n        self.setHorizontalHeaderLabels(columns)", "response": "Sets the column count and horizontal header labels for the given list of columns."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dict_update(d, u):\n    for k, v in six.iteritems(u):\n        if isinstance(v, collections.Mapping):\n            r = dict_update(d.get(k, {}), v)\n            d[k] = r\n        else:\n            d[k] = u[k]\n    return d", "response": "Recursive dict update of the dict d with the contents of u"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve the schema with the given schema_id from the registry and returns it as a dict.", "response": "def get_schema(self, schema_id):\n        \"\"\"\n        Retrieves the schema with the given schema_id from the registry\n        and returns it as a `dict`.\n        \"\"\"\n        res = requests.get(self._url('/schemas/ids/{}', schema_id))\n        raise_if_failed(res)\n        return json.loads(res.json()['schema'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_subjects(self):\n        res = requests.get(self._url('/subjects'))\n        raise_if_failed(res)\n        return res.json()", "response": "Returns the list of subject names present in the schema registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the list of schema version ids which have been registered under the given subject.", "response": "def get_subject_version_ids(self, subject):\n        \"\"\"\n        Return the list of schema version ids which have been registered\n        under the given subject.\n        \"\"\"\n        res = requests.get(self._url('/subjects/{}/versions', subject))\n        raise_if_failed(res)\n        return res.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_subject_version(self, subject, version_id):\n        res = requests.get(self._url('/subjects/{}/versions/{}', subject, version_id))\n        raise_if_failed(res)\n        return json.loads(res.json()['schema'])", "response": "Retrieves the schema registered under the given subject with\n        the given version id. Returns the schema as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters the given schema to the given subject. Returns the id allocated to the schema in the registry.", "response": "def register_subject_version(self, subject, schema):\n        \"\"\"\n        Registers the given schema (provided as a `dict`) to the given\n        subject. Returns the id allocated to the schema in the registry.\n        \"\"\"\n        data = json.dumps({'schema': json.dumps(schema)})\n        res = requests.post(self._url('/subjects/{}/versions', subject), data=data, headers=HEADERS)\n        raise_if_failed(res)\n        return res.json()['id']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef schema_is_registered_for_subject(self, subject, schema):\n        data = json.dumps({'schema': json.dumps(schema)})\n        res = requests.post(self._url('/subjects/{}', subject), data=data, headers=HEADERS)\n        if res.status_code == 404:\n            return False\n        raise_if_failed(res)\n        return True", "response": "Returns True if the given schema is already registered under the given subject."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_global_compatibility_level(self):\n        res = requests.get(self._url('/config'), headers=HEADERS)\n        raise_if_failed(res)\n        return res.json()['compatibility']", "response": "Gets the global compatibility level."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the compatibility level for the given subject.", "response": "def set_subject_compatibility_level(self, subject, level):\n        \"\"\"\n        Sets the compatibility level for the given subject.\n        \"\"\"\n        res = requests.put(\n            self._url('/config/{}', subject),\n            data=json.dumps({'compatibility': level}),\n            headers=HEADERS)\n        raise_if_failed(res)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_subject_compatibility_level(self, subject):\n        res = requests.get(self._url('/config/{}', subject), headers=HEADERS)\n        raise_if_failed(res)\n        return res.json()['compatibility']", "response": "Gets the compatibility level for the given subject."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a payload from the API and returns a new instance of the class cls.", "response": "def from_api(cls, api, **kwargs):\n        \"\"\" Parses a payload from the API, guided by `_api_attrs` \"\"\"\n        if not cls._api_attrs:\n            raise NotImplementedError()\n\n        def resolve_attribute_type(attr_type):\n            # resolve arrays of types down to base type\n            while isinstance(attr_type, list):\n                attr_type = attr_type[0]\n            # attribute type 'self' resolves to current class\n            if attr_type == 'self':\n                attr_type = cls\n            # attribute type 'date' is a unix timestamp\n            if attr_type == 'date':\n                attr_type = datetime.datetime.fromtimestamp\n            # string attributes should use unicode literals\n            if attr_type is str:\n                attr_type = unicode\n            # if attribute type is an APIObject, use the from_api factory method and pass the `api` argument\n            if hasattr(attr_type, 'from_api'):\n                return lambda **kw: attr_type.from_api(api, **kw)\n            return attr_type\n\n        def instantiate_attr(attr_value, attr_type):\n            if isinstance(attr_value, dict):\n                return attr_type(**attr_value)\n            return attr_type(attr_value)\n\n        def instantiate_array(attr_values, attr_type):\n            func = instantiate_attr\n            if isinstance(attr_values[0], list):\n                func = instantiate_array\n            return [func(val, attr_type) for val in attr_values]\n\n        def instantiate(attr_value, attr_type):\n            if isinstance(attr_value, list):\n                return instantiate_array(attr_value, attr_type)\n            return instantiate_attr(attr_value, attr_type)\n\n        instance = cls(api)\n        for attr_name, attr_type, attr_default in cls._api_attrs:\n            # grab the current attribute value\n            attr_value = kwargs.get(attr_name, attr_default)\n            # default of TypeError means a required attribute, raise Exception\n            if attr_value is TypeError:\n                raise TypeError('{} requires argument {}'.format(cls.__name__, attr_name))\n            attr_type = resolve_attribute_type(attr_type)\n            # if value has been provided from API, instantiate it using `attr_type`\n            if attr_value != attr_default:\n                attr_value = instantiate(attr_value, attr_type)\n            # rename the 'from' variable, reserved word\n            if attr_name == 'from':\n                attr_name = 'froom'\n            # and finally set the attribute value on the instance\n            setattr(instance, attr_name, attr_value)\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the api method to send the current API Object type", "response": "def api_method(self):\n        \"\"\" Returns the api method to `send` the current API Object type \"\"\"\n        if not self._api_method:\n            raise NotImplementedError()\n        return getattr(self.api, self._api_method)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a dict ready for submission to the API.", "response": "def api_payload(self):\n        \"\"\" Generates a payload ready for submission to the API, guided by `_api_payload` \"\"\"\n        if not self._api_payload:\n            raise NotImplementedError()\n        payload = {}\n        for attr_name in self._api_payload:\n            value = getattr(self, attr_name, None)\n            if value is not None:\n                payload[attr_name] = value\n        return payload"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, **kwargs):\n        payload = self.api_payload()\n        payload.update(**kwargs)\n        return self.api_method()(**payload)", "response": "Combines api_payload and api_method to submit the current object to the API"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of values for the current axis.", "response": "def calculateValues(self):\r\n        \"\"\"\r\n        Overloads the calculate values method to calculate the values for\r\n        this axis based on the minimum and maximum values, and the number\r\n        of steps desired.\r\n        \r\n        :return     [<variant>, ..]\r\n        \"\"\"\r\n        chart = self.chart()\r\n        if not chart:\r\n            return super(XDatasetAxis, self).calculateValues()\r\n        else:\r\n            values = []\r\n            for dataset in chart.datasets():\r\n                values.append(dataset.name())\r\n            values.sort()\r\n            return values"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addAction( self, action ):\n        if not isinstance(action, QAction):\n            action_name = nativestring(action)\n            action = QAction(action_name, self)\n            action.setObjectName(action_name)\n        \n        action.setCheckable(True)\n        \n        if ( not self._actionGroup ):\n            self._actionGroup = QActionGroup(self)\n            action.setChecked(True)\n            \n        self._actionGroup.addAction(action)\n        self.reset()\n        return action", "response": "Adds the inputed action to this widget s action group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef currentAction( self ):\n        if ( not self._actionGroup ):\n            return None\n            \n        for act in self._actionGroup.actions():\n            if ( act.isChecked() ):\n                return act\n        return None", "response": "Returns the current action that is currently checked in the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching the action group for the given text.", "response": "def findAction( self, text ):\n        \"\"\"\n        Looks up the action based on the inputed text.\n        \n        :return     <QAction> || None\n        \"\"\"\n        for action in self.actionGroup().actions():\n            if ( text in (action.objectName(), action.text()) ):\n                return action\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets the user interface buttons for this widget.", "response": "def reset( self ):\n        \"\"\"\n        Resets the user interface buttons for this widget.\n        \"\"\"\n        # clear previous widgets\n        for btn in self.findChildren(QToolButton):\n            btn.close()\n            btn.setParent(None)\n            btn.deleteLater()\n        \n        # determine coloring options\n        palette             = self.palette()\n        unchecked           = palette.color(palette.Button)\n        \n        # determine if this is a dark or light scheme\n        avg = (unchecked.red() + unchecked.green() + unchecked.blue()) / 3.0\n        if ( avg < 140 ):\n            checked             = unchecked.lighter(115)\n            \n            checked_clr         = self.colorString(unchecked.lighter(120))\n            border_clr          = self.colorString(unchecked.darker(140))\n            unchecked_clr       = self.colorString(checked.lighter(140))\n            unchecked_clr_alt   = self.colorString(checked.lighter(120))\n            checked_clr_alt     = self.colorString(unchecked)\n        else:\n            checked             = unchecked.lighter(120)\n            \n            checked_clr         = self.colorString(unchecked)\n            border_clr          = self.colorString(unchecked.darker(160))\n            unchecked_clr       = self.colorString(checked)\n            unchecked_clr_alt   = self.colorString(checked.darker(130))\n            checked_clr_alt     = self.colorString(unchecked.darker(120))\n        \n        # define the stylesheet options\n        options = {}\n        options['top_left_radius']      = 0\n        options['top_right_radius']     = 0\n        options['bot_left_radius']      = 0\n        options['bot_right_radius']     = 0\n        options['border_color']         = border_clr\n        options['checked_clr']          = checked_clr\n        options['checked_clr_alt']      = checked_clr_alt\n        options['unchecked_clr']        = unchecked_clr\n        options['unchecked_clr_alt']    = unchecked_clr_alt\n        options['padding_top']          = 1\n        options['padding_bottom']       = 1\n        options['padding_left']         = 1\n        options['padding_right']        = 1\n        \n        horiz = self.direction() in (QBoxLayout.LeftToRight, \n                                     QBoxLayout.RightToLeft)\n        \n        if ( horiz ):\n            options['x1'] = 0\n            options['y1'] = 0\n            options['x2'] = 0\n            options['y2'] = 1\n        else:\n            options['x1'] = 0\n            options['y1'] = 0\n            options['x2'] = 1\n            options['y2'] = 1\n        \n        actions = self.actionGroup().actions()\n        count = len(actions)\n        for i, action in enumerate(actions):\n            btn = QToolButton(self)\n            btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n            btn.setDefaultAction(action)\n            self.layout().insertWidget(i, btn)\n            \n            options['top_left_radius']  = 1\n            options['bot_left_radius']  = 1\n            options['top_right_radius'] = 1\n            options['bot_right_radius'] = 1\n            \n            if ( horiz ):\n                options['padding_left']     = self._padding\n                options['padding_right']    = self._padding\n            else:\n                options['padding_top']      = self._padding\n                options['padding_bottom']   = self._padding\n            \n            if ( not i ):\n                if ( horiz ):\n                    options['top_left_radius'] = self.cornerRadius()\n                    options['bot_left_radius'] = self.cornerRadius()\n                    options['padding_left']    += self.cornerRadius() / 3.0\n                else:\n                    options['top_left_radius'] = self.cornerRadius()\n                    options['top_right_radius'] = self.cornerRadius()\n                    options['padding_top']     += self.cornerRadius() / 3.0\n                    \n            elif ( i == count - 1 ):\n                if ( horiz ):\n                    options['top_right_radius'] = self.cornerRadius()\n                    options['bot_right_radius'] = self.cornerRadius()\n                    options['padding_right']    += self.cornerRadius() / 3.0\n                else:\n                    options['bot_left_radius']  = self.cornerRadius()\n                    options['bot_right_radius'] = self.cornerRadius()\n                    options['padding_bottom']   += self.cornerRadius() / 3.0\n            \n            btn.setStyleSheet(TOOLBUTTON_STYLE % options)\n            btn.setAutoFillBackground(True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_addr(addr, *, proto=None, host=None):\n    port = None\n\n    if isinstance(addr, Address):\n        return addr\n    elif isinstance(addr, str):\n        if addr.startswith('http://'):\n            proto, addr = 'http', addr[7:]\n        if addr.startswith('udp://'):\n            proto, addr = 'udp', addr[6:]\n        elif addr.startswith('tcp://'):\n            proto, addr = 'tcp', addr[6:]\n        elif addr.startswith('unix://'):\n            proto, addr = 'unix', addr[7:]\n        a, _, b = addr.partition(':')\n        host = a or host\n        port = b or port\n    elif isinstance(addr, (tuple, list)):\n        # list is not good\n        a, b = addr\n        host = a or host\n        port = b or port\n    elif isinstance(addr, int):\n        port = addr\n    else:\n        raise ValueError('bad value')\n\n    if port is not None:\n        port = int(port)\n    return Address(proto, host, port)", "response": "Parses an address into a new Address object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef applyRule( self ):\n        widget = self.queryBuilderWidget()\n        if ( not widget ):\n            return\n        \n        rule = widget.findRule(self.uiTermDDL.currentText())\n        self.setCurrentRule(rule)", "response": "Applies the rule from the builder system to this line edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query( self ):\n        widget = self.uiWidgetAREA.widget()\n        if ( widget and type(widget) != QWidget ):\n            value = nativestring(widget.text())\n        else:\n            value = ''\n        \r\n        op = nativestring(self.uiOperatorDDL.currentText())\r\n        if ( self.currentRule() ):\r\n            op = self.currentRule().labelOperator(op)\r\n        \n        return (nativestring(self.uiTermDDL.currentText()), op, value)", "response": "Returns the query that will be used for the widget."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef queryBuilderWidget( self ):\n        from projexui.widgets.xquerybuilderwidget import XQueryBuilderWidget\n        \n        builder = self.parent()\n        while ( builder and not isinstance(builder, XQueryBuilderWidget) ):\n            builder = builder.parent()\n        \n        return builder", "response": "Returns the query builder widget that this widget is associated with."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current query rule for this widget updating its editor if the types do not match.", "response": "def setCurrentRule( self, rule ):\n        \"\"\"\n        Sets the current query rule for this widget, updating its widget \\\n        editor if the types do not match.\n        \n        :param      rule | <QueryRule> || None\n        \"\"\"\n        curr_rule = self.currentRule()\n        if ( curr_rule == rule ):\n            return\n        \n        self._currentRule = rule\n        \n        curr_op     = self.uiOperatorDDL.currentText()\n        self.uiOperatorDDL.blockSignals(True)\n        self.uiOperatorDDL.clear()\n        if ( rule ):\n            self.uiOperatorDDL.addItems(rule.operators())\n            index = self.uiOperatorDDL.findText(curr_op)\n            if ( index != -1 ):\n                self.uiOperatorDDL.setCurrentIndex(index)\n                \n        self.uiOperatorDDL.blockSignals(False)\n        \n        self.updateEditor()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setQuery( self, query ):\n        if ( not (type(query) in (list, tuple) and len(query) == 3) ):\n            return False\n        \n        term, op, value = query\n        \r\n        if ( self.currentRule() ):\r\n            op = self.currentRule().operatorLabel(op)\r\n        \n        self.uiTermDDL.setCurrentIndex(self.uiTermDDL.findText(term))\n        self.applyRule()\n        \n        self.uiOperatorDDL.setCurrentIndex(self.uiOperatorDDL.findText(op))\n        \n        widget = self.uiWidgetAREA.widget()\n        if ( widget and not type(widget) == QWidget ):\n            widget.setText(value)\n        \n        return True", "response": "Sets the query that is used for this widget to the inputed query."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setTerms( self, terms ):\n        self.uiTermDDL.blockSignals(True)\n        \n        term = self.uiTermDDL.currentText()\n        self.uiTermDDL.clear()\n        self.uiTermDDL.addItems(terms)\n        self.uiTermDDL.setCurrentIndex(self.uiTermDDL.findText(term))\n        self.applyRule()\n        self.uiTermDDL.blockSignals(False)", "response": "Sets the term options for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef updateEditor( self ):\n        \n        # assignt the rule operators to the choice list\n        rule        = self.currentRule()\n        operator    = self.currentOperator()\n        widget      = self.uiWidgetAREA.widget()\n        editorType  = None\n        text        = ''\n        \n        if ( rule ):\n            editorType = rule.editorType(operator)\n        \n        # no change in types\n        if ( widget and editorType and type(widget) == editorType ):\n            return\n            \n        elif ( widget ):\n            if ( type(widget) != QWidget ):\n                text = widget.text()\n            \n            widget.setParent(None)\n            widget.deleteLater()\n        \n        self.uiWidgetAREA.setWidget(None)\n        \n        # create the new editor\n        if ( editorType ):\n            widget = editorType(self)\n            \n            if ( isinstance(widget, QLineEdit) ):\n                terms  = rule.completionTerms()\n                if ( not terms ):\n                    qwidget = self.queryBuilderWidget()\n                    if ( qwidget ):\n                        terms = qwidget.completionTerms()\n                \n                if ( terms ):\n                    widget.setCompleter(XQueryCompleter(terms, widget))\n            \n            self.uiWidgetAREA.setWidget(widget)\n            \n            if ( type(widget) != QWidget ):\n                widget.setText(text)", "response": "Updates the editor based on the current selection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef currentSchema( self ):\r\n        index = self.currentIndex()\r\n        if ( 0 <= index and index < len(self._schemas) ):\r\n            return self._schemas[index]\r\n        return None", "response": "Returns the schema that is currently in the combo box or None if no schema is found."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emitCurrentChanged( self ):\r\n        if ( not self.signalsBlocked() ):\r\n            schema = self.currentSchema()\r\n            self.currentSchemaChanged.emit(schema)\r\n            if ( schema ):\r\n                self.currentTableChanged.emit(schema.model())\r\n            else:\r\n                self.currentTableChanged.emit(None)", "response": "Emits the current schema changed signal for this combobox provided \\\r\n        the signals aren t blocked."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef refresh( self ):\r\n        schemas         = self.schemas()\r\n        self.blockSignals(True)\r\n        self.clear()\r\n        self.addItems([schema.name() for schema in schemas])\r\n        self.blockSignals(False)", "response": "Refreshes the user interface to match the latest settings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCurrentSchema( self, schema ):\r\n        if ( not schema in self._schemas ):\r\n            return False\r\n        \r\n        index = self._schemas.index(schema)\r\n        self.setCurrentIndex(index)\r\n        return True", "response": "Sets the current index for this combobox to the inputed schema instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the current settings for the actions in the list and exits the widget.", "response": "def save( self ):\n        \"\"\"\n        Saves the current settings for the actions in the list and exits the\n        widget.\n        \"\"\"\n        if ( not self.updateShortcut() ):\n            return False\n            \n        for i in range(self.uiActionTREE.topLevelItemCount()):\n            item = self.uiActionTREE.topLevelItem(i)\n            action = item.action()\n            action.setShortcut( QKeySequence(item.text(1)) )\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updateShortcut( self ):\n        aitem = self.uiActionTREE.currentItem()\n        if ( not aitem ):\n            return True\n        \n        scut = self.uiShortcutTXT.text()\n        if ( not scut ):\n            aitem.setText(1, '')\n            return True\n            \n        for i in range(self.uiActionTREE.topLevelItemCount()):\n            item = self.uiActionTREE.topLevelItem(i)\n            if (item != aitem and item.text(1) == scut):\n                msg = '%s already is using the %s shortcut.' % (item.text(0),\n                                                                scut)\n                QMessageBox.critical( self,\n                                      'Duplicate Shortcut',\n                                      msg )\n                return False\n        \n        # update the item\n        aitem.setText(1, scut)\n        return True", "response": "Updates the current shortuct settings to the current item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the central widget for this button.", "response": "def setCentralWidget(self, widget):\r\n        \"\"\"\r\n        Sets the central widget for this button.\r\n        \r\n        :param      widget | <QWidget>\r\n        \"\"\"\r\n        self.setEnabled(widget is not None)\r\n        self._popupWidget.setCentralWidget(widget)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef showPopup(self):\r\n        as_dialog = QApplication.keyboardModifiers()\r\n        \r\n        anchor = self.defaultAnchor()\r\n        if anchor:\r\n            self.popupWidget().setAnchor(anchor)\r\n        else:\r\n            anchor = self.popupWidget().anchor()\r\n        \r\n        if ( anchor & (XPopupWidget.Anchor.BottomLeft |\r\n                       XPopupWidget.Anchor.BottomCenter |\r\n                       XPopupWidget.Anchor.BottomRight) ):\r\n            pos = QPoint(self.width() / 2, 0)\r\n        else:\r\n            pos = QPoint(self.width() / 2, self.height())\r\n        \r\n        pos = self.mapToGlobal(pos)\r\n        \r\n        if not self.signalsBlocked():\r\n            self.popupAboutToShow.emit()\r\n        self._popupWidget.popup(pos)\r\n        \r\n        if as_dialog:\r\n            self._popupWidget.setCurrentMode(XPopupWidget.Mode.Dialog)", "response": "Shows the popup for this button."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef togglePopup(self):\r\n        if not self._popupWidget.isVisible():\r\n            self.showPopup()\r\n        elif self._popupWidget.currentMode() != self._popupWidget.Mode.Dialog:\r\n            self._popupWidget.close()", "response": "Toggles whether or not the popup is visible."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef form_field(self):\n        \"Returns appropriate form field.\"\n        label = unicode(self)\n        defaults = dict(required=False, label=label, widget=self.widget)\n        defaults.update(self.extra)\n        return self.field_class(**defaults)", "response": "Returns appropriate form field."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef attr_name(self):\n        \"Returns attribute name for this facet\"\n        return self.schema.name if self.schema else self.field.name", "response": "Returns attribute name for this facet"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns field instance and lookup prefix for given attribute name.", "response": "def get_field_and_lookup(self, name):\n        \"\"\"\n        Returns field instance and lookup prefix for given attribute name.\n        Can be overloaded in subclasses to provide filtering across multiple models.\n        \"\"\"\n        name = self.get_queryset().model._meta.get_field(name)\n        lookup_prefix = ''\n        return name, lookup_prefix"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sort_by_attribute(self, qs, name):\n        fields   = self.get_queryset().model._meta.get_all_field_names()\n        schemata = self.sortable_names\n        direction = '-' if self.data.get('order_desc') else ''\n        if name in fields:\n            return qs.order_by('%s%s' % (direction, name))\n        elif name in schemata:\n            schema = self.get_schema(name)\n            value_lookup = 'attrs__value_%s' % schema.datatype\n            order_lookup = '%s%s' % (direction, value_lookup)\n            return qs.filter(attrs__schema__name=name).order_by(order_lookup)\n        else:\n            raise NameError('Cannot order items by attributes: unknown '\n                            'attribute \"%s\". Available fields: %s. '\n                            'Available schemata: %s.' % (name,\n                            ', '.join(fields), ', '.join(schemata)))", "response": "A wrapper around standard order_by method. Allows to sort by normal fields and EAV attributes without thinking about implementation details."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks to make sure that the view widget can be properly closed.", "response": "def closeEvent(self, event):\n        \"\"\"\n        Checks to make sure that the view widget can be properly closed.\n        \n        :param      event | <QCloseEvent>\n        \"\"\"\n        if not self.viewWidget().canClose():\n            event.ignore()\n        else:\n            super(XViewDialog, self).closeEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exportTree(self, tree, filename):\r\n        book = xlwt.Workbook()\r\n        \r\n        # determine the title for the sheet to export\r\n        title = nativestring(tree.windowTitle())\r\n        if not title:\r\n            title = nativestring(tree.objectName())\r\n        if not title:\r\n            title = 'Sheet 1'\r\n        \r\n        sheet = book.add_sheet(title)\r\n        \r\n        # determine visible columns to export\r\n        cols = [c for c in range(tree.columnCount()) \\\r\n                if not tree.isColumnHidden(c)]\r\n        \r\n        # export the column headers\r\n        hitem = tree.headerItem()\r\n        for c, col in enumerate(cols):\r\n            sheet.write(0, c, nativestring(hitem.text(col)))\r\n        \r\n        self._currrow = 1\r\n        for i in range(tree.topLevelItemCount()):\r\n            self.exportTreeItem(sheet, cols, tree.topLevelItem(i))\r\n        \r\n        book.save(filename)\r\n        return True", "response": "Exports the inputed tree object to the given excel file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexport the inputed item to the given Excel worksheet for the cols | [ <int >.. ]", "response": "def exportTreeItem(self, sheet, cols, item):\r\n        \"\"\"\r\n        Exports the inputed item to the given Excel worksheet for the\r\n        given visible columns.\r\n        \r\n        :param      sheet | <xlwt.WorkSheet>\r\n                    cols  | [<int>, ..]\r\n                    item  | <QTreeWidgetItem>\r\n        \"\"\"\r\n        # export item information\r\n        for c, col in enumerate(cols):\r\n            data = unwrapVariant(item.data(Qt.EditRole, col))\r\n            if data:\r\n                sheet.write(self._currrow, c, nativestring(data))\r\n            else:\r\n                sheet.write(self._currrow, c, nativestring(item.text(col)))\r\n        \r\n        self._currrow += 1\r\n        \r\n        # export children as rows\r\n        for c in range(item.childCount()):\r\n            self.exportTreeItem(sheet, cols, item.child(c))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef emit(self, record):\r\n        # if we've already processed this record, ignore it\r\n        if record in self._recordQueue:\r\n            return\r\n        \r\n        if self._activeLevels and not record.levelno in self._activeLevels:\r\n            return\r\n        \r\n        name = record.name\r\n        lvl = self.loggerLevel(name)\r\n        \r\n        # don't process this log\r\n        if lvl > record.levelno:\r\n            return\r\n        \r\n        self._recordQueue.insert(0, record)\r\n        self._recordQueue = self._recordQueue[:10]\r\n        \r\n        # emit the change\r\n        super(XLoggerWidgetHandler, self).emit(record)", "response": "Emits the given record."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndispatches metrics streamed by collector.", "response": "def StreamMetrics(self, request_iterator, context):\n        \"\"\"Dispatches metrics streamed by collector\"\"\"\n        LOG.debug(\"StreamMetrics called\")\n\n        # set up arguments\n        collect_args = (next(request_iterator))\n        max_metrics_buffer = 0\n        max_collect_duration = 0\n        cfg = Metric(pb=collect_args.Metrics_Arg.metrics[0])\n        try:\n            max_metrics_buffer = int(cfg.config[\"max-metrics-buffer\"])\n        except Exception as ex:\n            LOG.debug(\"Unable to get schedule parameters: {}\".format(ex))\n        try:\n            max_collect_duration = int(cfg.config[\"max-collect-duration\"])\n        except Exception as ex:\n            LOG.debug(\"Unable to get schedule parameters: {}\".format(ex))\n        if max_metrics_buffer > 0:\n            self.max_metrics_buffer = max_metrics_buffer\n        if max_collect_duration > 0:\n            self.max_collect_duration = max_collect_duration\n\n        # start collection thread\n        thread = threading.Thread(target=self._stream_wrapper, args=(collect_args,),)\n        thread.daemon = True\n        thread.start()\n\n        # stream metrics\n        metrics = []\n        metrics_to_stream = []\n        stream_timeout = self.max_collect_duration\n        while context.is_active():\n            try:\n                # wait for metrics until timeout is reached\n                t_start = time.time()\n                metrics = self.metrics_queue.get(block=True, timeout=stream_timeout)\n                elapsed = round(time.time() - t_start)\n                stream_timeout -= elapsed\n            except queue.Empty:\n                LOG.debug(\"Max collect duration exceeded. Streaming {} metrics\".format(len(metrics_to_stream)))\n                metrics_col = CollectReply(Metrics_Reply=MetricsReply(metrics=[m.pb for m in metrics_to_stream]))\n                metrics_to_stream = []\n                stream_timeout = self.max_collect_duration\n                yield metrics_col\n            else:\n                for metric in metrics:\n                    metrics_to_stream.append(metric)\n                    if len(metrics_to_stream) == self.max_metrics_buffer:\n                        LOG.debug(\"Max metrics buffer reached. Streaming {} metrics\".format(len(metrics_to_stream)))\n                        metrics_col = CollectReply(\n                            Metrics_Reply=MetricsReply(metrics=[m.pb for m in metrics_to_stream]))\n                        metrics_to_stream = []\n                        stream_timeout = self.max_collect_duration\n                        yield metrics_col\n                # stream metrics if max_metrics_buffer is 0 or enough metrics has been collected\n                if self.max_metrics_buffer == 0:\n                    LOG.debug(\"Max metrics buffer set to 0. Streaming {} metrics\".format(len(metrics_to_stream)))\n                    metrics_col = CollectReply(Metrics_Reply=MetricsReply(metrics=[m.pb for m in metrics_to_stream]))\n                    metrics_to_stream = []\n                    stream_timeout = self.max_collect_duration\n                    yield metrics_col\n\n        # sent notification if stream has been stopped\n        self.done_queue.put(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GetMetricTypes(self, request, context):\n        LOG.debug(\"GetMetricTypes called\")\n        try:\n            metrics = self.plugin.update_catalog(ConfigMap(pb=request.config))\n            return MetricsReply(metrics=[m.pb for m in metrics])\n        except Exception as err:\n            msg = \"message: {}\\n\\nstack trace: {}\".format(\n                err, traceback.format_exc())\n            return MetricsReply(metrics=[], error=msg)", "response": "Dispatches the request to the plugins update_catalog method and returns the list of metrics that were added to the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef command_publish(self, command, **kwargs):\n        mqttc = mqtt.Client()\n        mqttc.connect(\n            command['host'],\n            port=int(command['port']))\n\n        mqttc.loop_start()\n\n        try:\n            mqttc.publish(\n                command['endpoint'],\n                command['payload'])\n        finally:\n            mqttc.loop_stop(force=False)", "response": "Publish a MQTT message"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsubscribes to a topic or list of topics", "response": "def command_subscribe(self, command, **kwargs):\n        \"\"\" Subscribe to a topic or list of topics \"\"\"\n        topic = command['topic']\n        encoding = command.get('encoding', 'utf-8')\n        name = command['name']\n        if not hasattr(self.engine, '_mqtt'):\n            self.engine._mqtt = {}\n        self.engine.variables[name] = []\n\n        def on_message(client, userdata, msg):\n            userdata.append(msg.payload.decode(encoding))\n        self.engine._mqtt[name] = client = mqtt.Client(\n            userdata=self.engine.variables[name])\n        client.on_message = on_message\n        client.connect(\n            command['host'],\n            port=int(command['port'])\n        )\n        client.subscribe(topic)\n        client.loop_start()\n        self.engine.register_teardown_callback(\n            client.loop_stop)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def fetching_data(self, *_):\n\n        try:\n            with async_timeout.timeout(10):\n                resp = await self._websession.get(self._api_url, params=self._urlparams)\n            if resp.status != 200:\n                _LOGGER.error('%s returned %s', self._api_url, resp.status)\n                return False\n            text = await resp.text()\n        except (asyncio.TimeoutError, aiohttp.ClientError) as err:\n            _LOGGER.error('%s returned %s', self._api_url, err)\n            return False\n        try:\n            self.data = xmltodict.parse(text)['weatherdata']\n        except (ExpatError, IndexError) as err:\n            _LOGGER.error('%s returned %s', resp.url, err)\n            return False\n        return True", "response": "Get the latest data from met. no."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the forecast weather data from met. no.", "response": "def get_forecast(self, time_zone):\n        \"\"\"Get the forecast weather data from met.no.\"\"\"\n        if self.data is None:\n            return []\n\n        now = datetime.datetime.now(time_zone).replace(hour=12, minute=0,\n                                                       second=0, microsecond=0)\n        times = [now + datetime.timedelta(days=k) for k in range(1, 6)]\n        return [self.get_weather(_time) for _time in times]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_weather(self, time, max_hour=6):\n        if self.data is None:\n            return {}\n\n        ordered_entries = []\n        for time_entry in self.data['product']['time']:\n            valid_from = parse_datetime(time_entry['@from'])\n            valid_to = parse_datetime(time_entry['@to'])\n            if time > valid_to:\n                # Has already passed. Never select this.\n                continue\n\n            average_dist = (abs((valid_to - time).total_seconds()) +\n                            abs((valid_from - time).total_seconds()))\n\n            if average_dist > max_hour * 3600:\n                continue\n\n            ordered_entries.append((average_dist, time_entry))\n\n        if not ordered_entries:\n            return {}\n        ordered_entries.sort(key=lambda item: item[0])\n        res = dict()\n        res['datetime'] = time\n        res['temperature'] = get_data('temperature', ordered_entries)\n        res['condition'] = CONDITIONS.get(get_data('symbol', ordered_entries))\n        res['pressure'] = get_data('pressure', ordered_entries)\n        res['humidity'] = get_data('humidity', ordered_entries)\n        res['wind_speed'] = get_data('windSpeed', ordered_entries)\n        res['wind_bearing'] = get_data('windDirection', ordered_entries)\n        return res", "response": "Get the current weather data from met. no."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprepare node for catalog endpoint", "response": "def prepare_node(data):\n    \"\"\"Prepare node for catalog endpoint\n\n    Parameters:\n        data (Union[str, dict]): Node ID or node definition\n    Returns:\n        Tuple[str, dict]: where first is ID and second is node definition\n\n    Extract from /v1/health/service/<service>::\n\n        {\n            \"Node\": {\n                \"Node\": \"foobar\",\n                \"Address\": \"10.1.10.12\",\n                \"TaggedAddresses\": {\n                    \"lan\": \"10.1.10.12\",\n                    \"wan\": \"10.1.10.12\"\n                }\n            },\n            \"Service\": {...},\n            \"Checks\": [...]\n        }\n    \"\"\"\n    if not data:\n        return None, {}\n\n    if isinstance(data, str):\n        return data, {}\n\n    # from /v1/health/service/<service>\n    if all(field in data for field in (\"Node\", \"Service\", \"Checks\")):\n        return data[\"Node\"][\"Node\"], data[\"Node\"]\n\n    result = {}\n    if \"ID\" in data:\n        result[\"Node\"] = data[\"ID\"]\n    for k in (\"Datacenter\", \"Node\", \"Address\",\n              \"TaggedAddresses\", \"Service\",\n              \"Check\", \"Checks\"):\n        if k in data:\n            result[k] = data[k]\n    if list(result) == [\"Node\"]:\n        return result[\"Node\"], {}\n    return result.get(\"Node\"), result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares a service for catalog endpoint", "response": "def prepare_service(data):\n    \"\"\"Prepare service for catalog endpoint\n\n    Parameters:\n        data (Union[str, dict]): Service ID or service definition\n    Returns:\n        Tuple[str, dict]: str is ID and dict is service\n\n    Transform ``/v1/health/state/<state>``::\n\n        {\n            \"Node\": \"foobar\",\n            \"CheckID\": \"service:redis\",\n            \"Name\": \"Service 'redis' check\",\n            \"Status\": \"passing\",\n            \"Notes\": \"\",\n            \"Output\": \"\",\n            \"ServiceID\": \"redis1\",\n            \"ServiceName\": \"redis\"\n        }\n\n    to::\n\n        {\n            \"ID\": \"redis1\",\n            \"Service\": \"redis\"\n        }\n\n    Extract from /v1/health/service/<service>::\n\n        {\n            \"Node\": {...},\n            \"Service\": {\n                \"ID\": \"redis1\",\n                \"Service\": \"redis\",\n                \"Tags\": None,\n                \"Address\": \"10.1.10.12\",\n                \"Port\": 8000\n            },\n            \"Checks\": [...]\n        }\n\n    \"\"\"\n    if not data:\n        return None, {}\n\n    if isinstance(data, str):\n        return data, {}\n\n    # from /v1/health/service/<service>\n    if all(field in data for field in (\"Node\", \"Service\", \"Checks\")):\n        return data[\"Service\"][\"ID\"], data[\"Service\"]\n\n    # from /v1/health/checks/<service>\n    # from /v1/health/node/<node>\n    # from /v1/health/state/<state>\n    # from /v1/catalog/service/<service>\n    if all(field in data for field in (\"ServiceName\", \"ServiceID\")):\n        return data[\"ServiceID\"], {\n            \"ID\": data[\"ServiceID\"],\n            \"Service\": data[\"ServiceName\"],\n            \"Tags\": data.get(\"ServiceTags\"),\n            \"Address\": data.get(\"ServiceAddress\"),\n            \"Port\": data.get(\"ServicePort\"),\n        }\n\n    if list(data) == [\"ID\"]:\n        return data[\"ID\"], {}\n\n    result = {}\n    if \"Name\" in data:\n        result[\"Service\"] = data[\"Name\"]\n\n    for k in (\"Service\", \"ID\", \"Tags\", \"Address\", \"Port\"):\n        if k in data:\n            result[k] = data[k]\n    return result.get(\"ID\"), result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare_check(data):\n    if not data:\n        return None, {}\n\n    if isinstance(data, str):\n        return data, {}\n\n    result = {}\n    if \"ID\" in data:\n        result[\"CheckID\"] = data[\"ID\"]\n    for k in (\"Node\", \"CheckID\", \"Name\", \"Notes\", \"Status\", \"ServiceID\"):\n        if k in data:\n            result[k] = data[k]\n    if list(result) == [\"CheckID\"]:\n        return result[\"CheckID\"], {}\n    return result.get(\"CheckID\"), result", "response": "Prepare check for catalog endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef optimize_for_size(self):\n        '''\n        http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=90752\n\n        http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=69813\n        '''\n        self.optimization = 's'\n        self.relax = True\n        self.gc_sections = True\n        self.ffunction_sections = True\n        self.fdata_sections = True\n        self.fno_inline_small_functions = True", "response": "This method is used to set the optimization to s to optimize the size of the current cache entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef optimize_no(self):\n        ''' all options set to default\n        '''\n        self.optimization = 0\n        self.relax = False\n        self.gc_sections = False\n        self.ffunction_sections = False\n        self.fdata_sections = False\n        self.fno_inline_small_functions = False", "response": "set all options to default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef command_list(self, sources, _opt=False):\n        '''command line as list'''\n        def abspath(x):\n            x = Path(x).abspath()\n            if not x.exists():\n                raise ValueError('file not found! ' + x)\n            return x\n\n        self.f_cpu = int(self.f_cpu)\n\n        self.mcu = str(self.mcu)\n#        if not self.mcu  in self.targets:\n#            raise ValueError('invalid mcu:' + self.mcu)\n\n        if not _opt:\n            sources = [abspath(x) for x in sources]\n        includes = [abspath(x) for x in self.includes]\n\n        if not self.output:\n            self.output = tempfile.NamedTemporaryFile(\n                prefix='pyavrutils_', suffix='.elf', delete=0).name\n\n        defines = self.defines + ['F_CPU=' + str(self.f_cpu)]\n\n        cmd = [self.cc]\n        if not self.use_only_extra_options:\n            if not _opt:\n                cmd += sources\n            cmd += ['-D' + x for x in defines]\n            cmd += ['-I' + x for x in includes]\n            if not _opt:\n                cmd += ['-o', self.output]\n            cmd += ['-mmcu=' + self.mcu]\n            cmd += ['--std=' + self.std]\n            if self.relax:\n                cmd += ['-Wl,--relax']\n            if self.gc_sections:\n                cmd += ['-Wl,--gc-sections']\n            if self.ffunction_sections:\n                cmd += ['-ffunction-sections']\n            if self.fdata_sections:\n                cmd += ['-fdata-sections']\n            if self.fno_inline_small_functions:\n                cmd += ['-fno-inline-small-functions']\n            if self.optimization != 0:\n                cmd += ['-O' + str(self.optimization)]\n\n        cmd += self.options_extra\n        return cmd", "response": "command line as list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a new entry set", "response": "def build(self, sources=None, headers=None):\n        ''' sources can be file name or code:\n        sources=['x.c','int main(){}']\n        or\n        sources='int main(){}'\n        '''\n        tempdir = None\n        strings, files = separate_sources(sources)\n        if len(strings) or headers:\n            # TODO: remove tempdir\n            tempdir = tmpdir()\n\n        temp_list = [tmpfile(x, tempdir, '.c') for x in strings]\n\n        if headers:\n            for n, s in headers.items():\n                (Path(tempdir) / n).write_text(s)\n\n        cmd = self.command_list(files + temp_list)\n        if tempdir:\n            cmd += ['-I' + tempdir]\n        self.proc = Proc(cmd).call()\n#        for x in temp_list:\n#            os.remove(x)\n\n        if not self.ok:\n            raise AvrGccCompileError(cmd, sources, self.error_text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding the resource file and module for the given path.", "response": "def build(self, force=False):\r\n        \"\"\"\r\n        Generates the resource file and module for the given path.\r\n        \r\n        :param      force | <bool>\r\n        \"\"\"\r\n        basepath = self.resourcePath()\r\n        if basepath is None:\r\n            return\r\n        \r\n        outpath = self.pluginPath()\r\n        logger = self.logger()\r\n        \r\n        for rsc in os.listdir(basepath):\r\n            rscpath = os.path.join(basepath, rsc)\r\n            if os.path.isfile(rscpath):\r\n                continue\r\n\r\n            opts = (projexui.qt.QT_WRAPPER.lower(), rsc)\r\n            xml_file = os.path.join(basepath, '{1}.qrc'.format(*opts))\r\n            py_file = os.path.join(outpath, '{0}_{1}_rc.py'.format(*opts))\r\n            \r\n            # determine the update for the build system\r\n            if os.path.exists(py_file):\r\n                modtime = os.path.getmtime(py_file)\r\n                outdated = force\r\n            else:\r\n                modtime = None\r\n                outdated = True\r\n            \r\n            # generate the XML data for the filepath\r\n            basepath = os.path.normpath(os.path.abspath(basepath))\r\n            rscpath = os.path.join(basepath, rsc)\r\n            xroot = ElementTree.Element('RCC')\r\n            for root, folders, files in os.walk(rscpath):\r\n                if not files:\r\n                    continue\r\n                \r\n                xresource = ElementTree.SubElement(xroot, 'qresource')\r\n                opts = [rsc, root[len(rscpath)+1:].replace(os.path.sep, '/')]\r\n                xresource.set('prefix', '{0}/{1}'.format(*opts).strip('/'))\r\n                \r\n                # add the files to the resource file\r\n                for file in files:\r\n                    filename = os.path.join(root, file)\r\n                    if not outdated and modtime < os.path.getmtime(filename):\r\n                        outdated = True\r\n                    \r\n                    xfile = ElementTree.SubElement(xresource, 'file')\r\n                    xfile.set('alias', file)\r\n                    xfile.text = os.path.relpath(filename, basepath)\r\n            \r\n            # if the resource file is out dated, then save and generate it\r\n            if outdated and len(xroot):\r\n                logger.info('Generating {0} resource file..'.format(xml_file))\r\n                projex.text.xmlindent(xroot)\r\n                ElementTree.ElementTree(xroot).write(xml_file)\r\n                \r\n                projexui.buildResourceFile(xml_file, py_file)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking to see if the inputed path represents an existing file or directory.", "response": "def exists(self, relpath, rsc=None, useFilepath=None):\r\n        \"\"\"\r\n        Checks to see if the inputed path represents an existing file or directory.\r\n\r\n        :param      relpath     | <str>\r\n                    rsc         | <str>\r\n                    useFilepath | <bool> or None\r\n        \"\"\"\r\n        path = self.find(relpath, rsc, useFilepath)\r\n        if path.startswith(':'):\r\n            return QtCore.QResource(path).isValid()\r\n        else:\r\n            return os.path.exists(path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the path for the resource based on the inputed relative path.", "response": "def find(self, relpath, rsc=None, useFilepath=None):\r\n        \"\"\"\r\n        Looks up the path for the resource based on the inputed relative path.\r\n        \r\n        :param      relpath | <str>\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        self.init()\r\n        \r\n        # load the default resource information\r\n        if rsc is None:\r\n            try:\r\n                key = relpath.replace('\\\\', '/').split('/')[0]\r\n                rsc = self.default(key)\r\n            except IndexError:\r\n                return ''\r\n        \r\n        # determine the filepath location\r\n        relpath = os.path.normpath(nativestring(relpath))\r\n        rscpath = self.resourcePath()\r\n        \r\n        if useFilepath is None:\r\n            useFilepath = self.useFilepath()\r\n        \r\n        # return from the filesystem\r\n        if useFilepath and rscpath:\r\n            if rsc and isinstance(rsc, XResourceManager):\r\n                return rsc.find(relpath, useFilepath=useFilepath)\r\n            elif rsc:\r\n                filepath = os.path.join(rscpath, rsc, relpath)\r\n            else:\r\n                filepath = os.path.join(rscpath, relpath)\r\n            \r\n            if os.path.exists(filepath):\r\n                return filepath\r\n        \r\n        # return resource\r\n        if isinstance(rsc, XResourceManager):\r\n            return rsc.find(relpath, useFilepath=useFilepath)\r\n        elif rsc:\r\n            return ':{0}/{1}'.format(rsc, relpath.replace(os.path.sep, '/'))\r\n        else:\r\n            return ':{0}'.format(relpath.replace(os.path.sep, '/'))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of the files within a path.", "response": "def listdir(self, relpath, rsc=None):\r\n        \"\"\"\r\n        Returns a list of the files within a path.  When compiled, it will\r\n        list the files within a QResource, otherwise will list the files\r\n        within the directory.\r\n        \r\n        :param      relpath | <str>\r\n                    rsc     | <str> || None\r\n        \r\n        :return     [<str>, ..]\r\n        \"\"\"\r\n        filepath = self.find(relpath, rsc)\r\n        \r\n        # parse a resource object\r\n        if filepath.startswith(':'):\r\n            resource = QtCore.QResource(filepath)\r\n            \r\n            # load the resource\r\n            return map(str, resource.children())\r\n        \r\n        # parse a filepath\r\n        elif os.path.isdir(filepath):\r\n            return os.listdir(filepath)\r\n        \r\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init(self):\r\n        # import any compiled resource modules\r\n        if not self._initialized:\r\n            self._initialized = True\r\n            wrap = projexui.qt.QT_WRAPPER.lower()\r\n            ignore = lambda x: not x.split('.')[-1].startswith(wrap)\r\n            projex.importmodules(self.plugins(), ignore=ignore)", "response": "Initializes the plugins for this resource manager."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isdir(self, relpath, rsc=None):\r\n        filepath = self.find(relpath, rsc)\r\n        if filepath.startswith(':'):\r\n            resource = QtCore.QResource(filepath)\r\n            return not resource.isFile()\r\n        else:\r\n            return os.path.isdir(filepath)", "response": "Returns whether or not the resource is a directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a file like object for reading for the given relpath.", "response": "def load(self, relpath, rsc=None, mode='r', useFilepath=None):\r\n        \"\"\"\r\n        Opens a file like object for reading for the given relpath.\r\n        \r\n        :param      relpath | <str>\r\n        \r\n        :return     <File> || <QFile> || None\r\n        \"\"\"\r\n        filepath = self.find(relpath, rsc, useFilepath=useFilepath)\r\n        \r\n        # parse a resource object\r\n        if filepath.startswith(':'):\r\n            return QtCore.QFile(filepath)\r\n        \r\n        # parse a filepath\r\n        elif os.path.isfile(filepath):\r\n            return open(filepath, mode)\r\n        \r\n        # return an unknown object\r\n        else:\r\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the contents of a given relative filepath.", "response": "def read(self, relpath, rsc=None, mode='r', useFilepath=None):\r\n        \"\"\"\r\n        Reads the contents for a given relative filepath.  This will call\r\n        the load function and do a full read on the file contents.\r\n        \r\n        :param      relpath | <str>\r\n                    rsc     | <str> || None\r\n                    mode    | <str> | 'r' or 'rb'\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        f = self.load(relpath, rsc, mode, useFilepath=useFilepath)\r\n        if f is None:\r\n            return ''\r\n        \r\n        # use a QFile\r\n        if isinstance(f, QtCore.QFile):\r\n            if f.open(QtCore.QFile.ReadOnly):\r\n                data = nativestring(f.readAll())\r\n                f.close()\r\n            else:\r\n                data = ''\r\n        else:\r\n            data = f.read()\r\n            f.close()\r\n        \r\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walk(self, root):\r\n        files = []\r\n        folders = []\r\n        \r\n        for relpath in self.listdir(root):\r\n            if self.isfile(root + '/' + relpath):\r\n                files.append(relpath)\r\n            else:\r\n                folders.append(relpath)\r\n        \r\n        yield root, folders, files\r\n        \r\n        for folder in folders:\r\n            folderpath = root + '/' + folder\r\n            for sub_root, sub_folders, sub_files in self.walk(folderpath):\r\n                yield sub_root, sub_folders, sub_files", "response": "Walks the path for a returning the folders and roots for the\r\n            files found."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset up the resource manager as modular functions.", "response": "def setup(self, glbls):\r\n        \"\"\"\r\n        Sets up the resource manager as modular functions.\r\n        \r\n        :param      glbls | <dict>\r\n        \"\"\"\r\n        if not self.pluginPath() in sys.path:\r\n            log.debug(self.pluginPath())\r\n            sys.path.append(self.pluginPath())\r\n        \r\n        glbls['find'] = self.find\r\n        glbls['listdir'] = self.listdir\r\n        glbls['load'] = self.load\r\n        glbls['read'] = self.read\r\n        glbls['exists'] = self.exists\r\n        glbls['setdefault'] = self.setDefault\r\n        glbls['basePath'] = self.basePath\r\n        glbls['setBasePath'] = self.setBasePath\r\n        glbls['walk'] = self.walk\r\n        glbls['isdir'] = self.isdir\r\n        glbls['isfile'] = self.isfile\r\n        glbls['init'] = self.init\r\n        \r\n        # setup the build system\r\n        if 'python' in sys.executable and not self.useFilepath():\r\n            self.build()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the default value for a given key.", "response": "def setDefault(self, key, value):\r\n        \"\"\"\r\n        Sets the default for a given key to the value.\r\n        \r\n        :param      key | <str>\r\n                    value | <str> || <XResourceManager>\r\n        \"\"\"\r\n        if value is None:\r\n            self._defaults.pop(key, None)\r\n        else:\r\n            self._defaults[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef policies(self):\n        policies = [self._pb.integer_policy, self._pb.float_policy,\n                    self._pb.string_policy, self._pb.bool_policy]\n        key_types = [\"integer\", \"float\", \"string\", \"bool\"]\n        return zip(key_types, policies)", "response": "Return list of policies zipped with their respective data type"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a measurement to the submission buffer for eventual writing to InfluxDB.", "response": "def add_measurement(measurement):\n    \"\"\"Add measurement data to the submission buffer for eventual writing to\n    InfluxDB.\n\n    Example:\n\n    .. code:: python\n\n        import sprockets_influxdb as influxdb\n\n        measurement = influxdb.Measurement('example', 'measurement-name')\n        measurement.set_tag('foo', 'bar')\n        measurement.set_field('baz', 1.05)\n\n        influxdb.add_measurement(measurement)\n\n    :param :class:`~sprockets_influxdb.Measurement` measurement: The\n        measurement to add to the buffer for submission to InfluxDB.\n\n    \"\"\"\n    global _buffer_size\n\n    if not _enabled:\n        LOGGER.debug('Discarding measurement for %s while not enabled',\n                     measurement.database)\n        return\n\n    if _stopping:\n        LOGGER.warning('Discarding measurement for %s while stopping',\n                       measurement.database)\n        return\n\n    if _buffer_size > _max_buffer_size:\n        LOGGER.warning('Discarding measurement due to buffer size limit')\n        return\n\n    if not measurement.fields:\n        raise ValueError('Measurement does not contain a field')\n\n    if measurement.database not in _measurements:\n        _measurements[measurement.database] = []\n\n    value = measurement.marshall()\n    _measurements[measurement.database].append(value)\n\n    # Ensure that len(measurements) < _trigger_size are written\n    if not _timeout:\n        if (_batch_future and _batch_future.done()) or not _batch_future:\n            _start_timeout()\n\n    # Check to see if the batch should be triggered\n    _buffer_size = _pending_measurements()\n    if _buffer_size >= _trigger_size:\n        _trigger_batch_write()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flush():\n    flush_future = concurrent.Future()\n    if _batch_future and not _batch_future.done():\n        LOGGER.debug('Flush waiting on incomplete _batch_future')\n        _flush_wait(flush_future, _batch_future)\n    else:\n        LOGGER.info('Flushing buffer with %i measurements to InfluxDB',\n                    _pending_measurements())\n        _flush_wait(flush_future, _write_measurements())\n    return flush_future", "response": "Flush all pending measurements to InfluxDB."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls and sets up the InfluxDB client collector.", "response": "def install(url=None, auth_username=None, auth_password=None,\n            submission_interval=None, max_batch_size=None, max_clients=10,\n            base_tags=None, max_buffer_size=None, trigger_size=None,\n            sample_probability=1.0):\n    \"\"\"Call this to install/setup the InfluxDB client collector. All arguments\n    are optional.\n\n    :param str url: The InfluxDB API URL. If URL is not specified, the\n        ``INFLUXDB_SCHEME``, ``INFLUXDB_HOST`` and ``INFLUXDB_PORT``\n        environment variables will be used to construct the base URL. Default:\n        ``http://localhost:8086/write``\n    :param str auth_username: A username to use for InfluxDB authentication. If\n        not specified, the ``INFLUXDB_USER`` environment variable will\n        be used. Default: ``None``\n    :param str auth_password: A password to use for InfluxDB authentication. If\n        not specified, the ``INFLUXDB_PASSWORD`` environment variable will\n        be used. Default: ``None``\n    :param int submission_interval: The maximum number of milliseconds to wait\n        after the last batch submission before submitting a batch that is\n        smaller than ``trigger_size``. Default: ``60000``\n    :param int max_batch_size: The number of measurements to be submitted in a\n        single HTTP request. Default: ``10000``\n    :param int max_clients: The number of simultaneous batch submissions that\n        may be made at any given time. Default: ``10``\n    :param dict base_tags: Default tags that are to be submitted with each\n        measurement.  Default: ``None``\n    :param int max_buffer_size: The maximum number of pending measurements\n        in the buffer before new measurements are discarded.\n        Default: ``25000``\n    :param int trigger_size: The minimum number of measurements that\n        are in the buffer before a batch can be submitted. Default: ``5000``\n    :param float sample_probability: Value between 0 and 1.0 specifying the\n        probability that a batch will be submitted (0.25 == 25%)\n    :returns: :data:`True` if the client was installed by this call\n        and :data:`False` otherwise.\n\n    If ``INFLUXDB_PASSWORD`` is specified as an environment variable, it will\n    be masked in the Python process.\n\n    \"\"\"\n    global _base_tags, _base_url, _credentials, _enabled, _installed, \\\n        _max_batch_size, _max_buffer_size, _max_clients, \\\n        _sample_probability, _timeout, _timeout_interval, _trigger_size\n\n    _enabled = os.environ.get('INFLUXDB_ENABLED', 'true') == 'true'\n    if not _enabled:\n        LOGGER.warning('Disabling InfluxDB support')\n        return\n\n    if _installed:\n        LOGGER.warning('InfluxDB client already installed')\n        return False\n\n    _base_url = url or '{}://{}:{}/write'.format(\n        os.environ.get('INFLUXDB_SCHEME', 'http'),\n        os.environ.get('INFLUXDB_HOST', 'localhost'),\n        os.environ.get('INFLUXDB_PORT', 8086))\n\n    _credentials = (auth_username or os.environ.get('INFLUXDB_USER', None),\n                    auth_password or os.environ.get('INFLUXDB_PASSWORD', None))\n\n    # Don't leave the environment variable out there with the password\n    if os.environ.get('INFLUXDB_PASSWORD'):\n        os.environ['INFLUXDB_PASSWORD'] = \\\n            'X' * len(os.environ['INFLUXDB_PASSWORD'])\n\n    # Submission related values\n    _timeout_interval = submission_interval or \\\n        int(os.environ.get('INFLUXDB_INTERVAL', _timeout_interval))\n    _max_batch_size = max_batch_size or \\\n        int(os.environ.get('INFLUXDB_MAX_BATCH_SIZE', _max_batch_size))\n    _max_clients = max_clients\n    _max_buffer_size = max_buffer_size or \\\n        int(os.environ.get('INFLUXDB_MAX_BUFFER_SIZE', _max_buffer_size))\n    _sample_probability = sample_probability or \\\n        float(os.environ.get('INFLUXDB_SAMPLE_PROBABILITY',\n                             _sample_probability))\n    _trigger_size = trigger_size or \\\n        int(os.environ.get('INFLUXDB_TRIGGER_SIZE', _trigger_size))\n\n    # Set the base tags\n    if os.environ.get('INFLUXDB_TAG_HOSTNAME', 'true') == 'true':\n        _base_tags.setdefault('hostname', socket.gethostname())\n    if os.environ.get('ENVIRONMENT'):\n        _base_tags.setdefault('environment', os.environ['ENVIRONMENT'])\n    _base_tags.update(base_tags or {})\n\n    # Seed the random number generator for batch sampling\n    random.seed()\n\n    # Don't let this run multiple times\n    _installed = True\n\n    LOGGER.info('sprockets_influxdb v%s installed; %i measurements or %.2f '\n                'seconds will trigger batch submission', __version__,\n                _trigger_size, _timeout_interval / 1000.0)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_auth_credentials(username, password):\n    global _credentials, _dirty\n\n    LOGGER.debug('Setting authentication credentials')\n    _credentials = username, password\n    _dirty = True", "response": "Override the default authentication credentials obtained from the\n    environment variable configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_base_url(url):\n    global _base_url, _dirty\n\n    LOGGER.debug('Setting base URL to %s', url)\n    _base_url = url\n    _dirty = True", "response": "Override the default base URL value created from the environment\n    variable configuration."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_max_clients(limit):\n    global _dirty, _max_clients\n\n    LOGGER.debug('Setting maximum client limit to %i', limit)\n    _dirty = True\n    _max_clients = limit", "response": "Sets the maximum number of simultaneous batch submission that can execute\n    in parallel."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_sample_probability(probability):\n    global _sample_probability\n\n    if not 0.0 <= probability <= 1.0:\n        raise ValueError('Invalid probability value')\n\n    LOGGER.debug('Setting sample probability to %.2f', probability)\n    _sample_probability = float(probability)", "response": "Set the probability that a batch will be submitted to the InfluxDB server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\noverriding the maximum duration to wait for submitting measurements to InfluxDB.", "response": "def set_timeout(milliseconds):\n    \"\"\"Override the maximum duration to wait for submitting measurements to\n    InfluxDB.\n\n    :param int milliseconds: Maximum wait in milliseconds\n\n    \"\"\"\n    global _timeout, _timeout_interval\n\n    LOGGER.debug('Setting batch wait timeout to %i ms', milliseconds)\n    _timeout_interval = milliseconds\n    _maybe_stop_timeout()\n    _timeout = ioloop.IOLoop.current().add_timeout(milliseconds, _on_timeout)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_http_client():\n    global _http_client\n\n    defaults = {'user_agent': USER_AGENT}\n    auth_username, auth_password = _credentials\n    if auth_username and auth_password:\n        defaults['auth_username'] = auth_username\n        defaults['auth_password'] = auth_password\n\n    _http_client = httpclient.AsyncHTTPClient(\n        force_instance=True, defaults=defaults,\n        max_clients=_max_clients)", "response": "Create the HTTP client with authentication credentials if required."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npausing briefly allowing any pending metric writes to complete before the shutdown is complete.", "response": "def _flush_wait(flush_future, write_future):\n    \"\"\"Pause briefly allowing any pending metric writes to complete before\n    shutting down.\n\n    :param tornado.concurrent.Future flush_future: The future to resolve\n        when the shutdown is complete.\n    :param tornado.concurrent.Future write_future: The future that is for the\n        current batch write operation.\n\n    \"\"\"\n    if write_future.done():\n        if not _pending_measurements():\n            flush_future.set_result(True)\n            return\n        else:\n            write_future = _write_measurements()\n    ioloop.IOLoop.current().add_timeout(\n        ioloop.IOLoop.current().time() + 0.25,\n        _flush_wait, flush_future, write_future)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwait for all futures to be completed and returns a tornado. concurrent. Future that is ready to be returned.", "response": "def _futures_wait(wait_future, futures):\n    \"\"\"Waits for all futures to be completed. If the futures are not done,\n    wait 100ms and then invoke itself via the ioloop and check again. If\n    they are done, set a result on `wait_future` indicating the list of\n    futures are done.\n\n    :param wait_future: The future to complete when all `futures` are done\n    :type wait_future: tornado.concurrent.Future\n    :param list futures: The list of futures to watch for completion\n\n    \"\"\"\n    global _buffer_size, _writing\n\n    remaining = []\n    for (future, batch, database, measurements) in futures:\n\n        # If the future hasn't completed, add it to the remaining stack\n        if not future.done():\n            remaining.append((future, batch, database, measurements))\n            continue\n\n        # Get the result of the HTTP request, processing any errors\n        error = future.exception()\n        if isinstance(error, httpclient.HTTPError):\n            if error.code == 400:\n                _write_error_batch(batch, database, measurements)\n            elif error.code >= 500:\n                _on_5xx_error(batch, error, database, measurements)\n            else:\n                LOGGER.error('Error submitting %s batch %s to InfluxDB (%s): '\n                             '%s', database, batch, error.code,\n                             error.response.body)\n        elif isinstance(error, (TimeoutError, OSError, socket.error,\n                                select.error, ssl.socket_error)):\n            _on_5xx_error(batch, error, database, measurements)\n\n    # If there are futures that remain, try again in 100ms.\n    if remaining:\n        return ioloop.IOLoop.current().add_timeout(\n            ioloop.IOLoop.current().time() + 0.1,\n            _futures_wait, wait_future, remaining)\n    else:  # Start the next timeout or trigger the next batch\n        _buffer_size = _pending_measurements()\n        LOGGER.debug('Batch submitted, %i measurements remain', _buffer_size)\n        if _buffer_size >= _trigger_size:\n            ioloop.IOLoop.current().add_callback(_trigger_batch_write)\n        elif _buffer_size:\n            _start_timeout()\n\n    _writing = False\n    wait_future.set_result(True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _maybe_stop_timeout():\n    global _timeout\n\n    if _timeout is not None:\n        LOGGER.debug('Removing the pending timeout (%r)', _timeout)\n        ioloop.IOLoop.current().remove_timeout(_timeout)\n        _timeout = None", "response": "Stop the timeout if there is one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _maybe_warn_about_buffer_size():\n    global _last_warning\n\n    if not _last_warning:\n        _last_warning = time.time()\n\n    if _buffer_size > _warn_threshold and (time.time() - _last_warning) > 120:\n        LOGGER.warning('InfluxDB measurement buffer has %i entries',\n                       _buffer_size)", "response": "Check the buffer size and issue a warning if it s too large and\n    has not been issued for more than 60 seconds."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle a batch submission error logging the problem and adding the measurements back to the stack.", "response": "def _on_5xx_error(batch, error, database, measurements):\n    \"\"\"Handle a batch submission error, logging the problem and adding the\n    measurements back to the stack.\n\n    :param str batch: The batch ID\n    :param mixed error: The error that was returned\n    :param str database: The database the submission failed for\n    :param list measurements: The measurements to add back to the stack\n\n    \"\"\"\n    LOGGER.info('Appending %s measurements to stack due to batch %s %r',\n                database, batch, error)\n    _measurements[database] = _measurements[database] + measurements"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling periodically to ensure that metrics that have been collected have been submitted to InfluxDB.", "response": "def _on_timeout():\n    \"\"\"Invoked periodically to ensure that metrics that have been collected\n    are submitted to InfluxDB.\n\n    :rtype: tornado.concurrent.Future or None\n\n    \"\"\"\n    global _buffer_size\n\n    LOGGER.debug('No metrics submitted in the last %.2f seconds',\n                 _timeout_interval / 1000.0)\n    _buffer_size = _pending_measurements()\n    if _buffer_size:\n        return _trigger_batch_write()\n    _start_timeout()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine if a batch should be processed and pop off all of the pending metrics for that batch.", "response": "def _sample_batch():\n    \"\"\"Determine if a batch should be processed and if not, pop off all of\n    the pending metrics for that batch.\n\n    :rtype: bool\n\n    \"\"\"\n    if _sample_probability == 1.0 or random.random() < _sample_probability:\n        return True\n\n    # Pop off all the metrics for the batch\n    for database in _measurements:\n        _measurements[database] = _measurements[database][_max_batch_size:]\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _start_timeout():\n    global _timeout\n\n    LOGGER.debug('Adding a new timeout in %i ms', _timeout_interval)\n    _maybe_stop_timeout()\n    _timeout = ioloop.IOLoop.current().add_timeout(\n        ioloop.IOLoop.current().time() + _timeout_interval / 1000.0,\n        _on_timeout)", "response": "Start a new timeout if it s not already running."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop a timeout if it s running and then write the measurements.", "response": "def _trigger_batch_write():\n    \"\"\"Stop a timeout if it's running, and then write the measurements.\"\"\"\n    global _batch_future\n\n    LOGGER.debug('Batch write triggered (%r/%r)',\n                 _buffer_size, _trigger_size)\n    _maybe_stop_timeout()\n    _maybe_warn_about_buffer_size()\n    _batch_future = _write_measurements()\n    return _batch_future"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites out all of the metrics in each of the databases and return a future that will indicate all metrics have been written to the server.", "response": "def _write_measurements():\n    \"\"\"Write out all of the metrics in each of the databases,\n    returning a future that will indicate all metrics have been written\n    when that future is done.\n\n    :rtype: tornado.concurrent.Future\n\n    \"\"\"\n    global _timeout, _writing\n\n    future = concurrent.Future()\n\n    if _writing:\n        LOGGER.warning('Currently writing measurements, skipping write')\n        future.set_result(False)\n    elif not _pending_measurements():\n        future.set_result(True)\n    elif not _sample_batch():\n        LOGGER.debug('Skipping batch submission due to sampling')\n        future.set_result(True)\n\n    # Exit early if there's an error condition\n    if future.done():\n        return future\n\n    if not _http_client or _dirty:\n        _create_http_client()\n\n    # Keep track of the futures for each batch submission\n    futures = []\n\n    # Submit a batch for each database\n    for database in _measurements:\n        url = '{}?db={}&precision=ms'.format(_base_url, database)\n\n        # Get the measurements to submit\n        measurements = _measurements[database][:_max_batch_size]\n\n        # Pop them off the stack of pending measurements\n        _measurements[database] = _measurements[database][_max_batch_size:]\n\n        # Create the request future\n        LOGGER.debug('Submitting %r measurements to %r',\n                     len(measurements), url)\n        request = _http_client.fetch(\n            url, method='POST', body='\\n'.join(measurements).encode('utf-8'))\n\n        # Keep track of each request in our future stack\n        futures.append((request, str(uuid.uuid4()), database, measurements))\n\n    # Start the wait cycle for all the requests to complete\n    _writing = True\n    _futures_wait(future, futures)\n\n    return future"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninvokes when a batch submission fails this method will submit one measurement to InfluxDB and then wait for the result to be done.", "response": "def _write_error_batch(batch, database, measurements):\n    \"\"\"Invoked when a batch submission fails, this method will submit one\n    measurement to InfluxDB. It then adds a timeout to the IOLoop which will\n    invoke :meth:`_write_error_batch_wait` which will evaluate the result and\n    then determine what to do next.\n\n    :param str batch: The batch ID for correlation purposes\n    :param str database: The database name for the measurements\n    :param list measurements: The measurements that failed to write as a batch\n\n    \"\"\"\n    if not measurements:\n        LOGGER.info('All %s measurements from batch %s processed',\n                    database, batch)\n        return\n\n    LOGGER.debug('Processing batch %s for %s by measurement, %i left',\n                 batch, database, len(measurements))\n\n    url = '{}?db={}&precision=ms'.format(_base_url, database)\n\n    measurement = measurements.pop(0)\n\n    # Create the request future\n    future = _http_client.fetch(\n        url, method='POST', body=measurement.encode('utf-8'))\n\n    # Check in 25ms to see if it's done\n    ioloop.IOLoop.current().add_timeout(\n        ioloop.IOLoop.current().time() + 0.025,\n        _write_error_batch_wait, future, batch, database, measurement,\n        measurements)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninvoke by the IOLoop, this method checks if the HTTP request future created by :meth:`_write_error_batch` is done. If it's done it will evaluate the result, logging any error and moving on to the next measurement. If there are no measurements left in the `measurements` argument, it will consider the batch complete. :param tornado.concurrent.Future future: The AsyncHTTPClient request future :param str batch: The batch ID :param str database: The database name for the measurements :param str measurement: The measurement the future is for :param list measurements: The measurements that failed to write as a batch", "response": "def _write_error_batch_wait(future, batch, database, measurement,\n                            measurements):\n    \"\"\"Invoked by the IOLoop, this method checks if the HTTP request future\n    created by :meth:`_write_error_batch` is done. If it's done it will\n    evaluate the result, logging any error and moving on to the next\n    measurement. If there are no measurements left in the `measurements`\n    argument, it will consider the batch complete.\n\n\n    :param tornado.concurrent.Future future: The AsyncHTTPClient request future\n    :param str batch: The batch ID\n    :param str database: The database name for the measurements\n    :param str measurement: The measurement the future is for\n    :param list measurements: The measurements that failed to write as a batch\n\n    \"\"\"\n    if not future.done():\n        ioloop.IOLoop.current().add_timeout(\n            ioloop.IOLoop.current().time() + 0.025,\n            _write_error_batch_wait, future, batch, database, measurement,\n            measurements)\n        return\n\n    error = future.exception()\n    if isinstance(error, httpclient.HTTPError):\n        if error.code == 400:\n            LOGGER.error('Error writing %s measurement from batch %s to '\n                         'InfluxDB (%s): %s', database, batch, error.code,\n                         error.response.body)\n            LOGGER.info('Bad %s measurement from batch %s: %s',\n                        database, batch, measurement)\n        else:\n            LOGGER.error('Error submitting individual metric for %s from '\n                         'batch %s to InfluxDB (%s): %s',\n                         database, batch, error.code)\n            measurements = measurements + [measurement]\n    elif isinstance(error, (TimeoutError, OSError, socket.error,\n                            select.error, ssl.socket_error)):\n        LOGGER.error('Error submitting individual metric for %s from batch '\n                     '%s to InfluxDB (%s)', database, batch, error)\n        _write_error_batch(batch, database, measurements + [measurement])\n        measurements = measurements + [measurement]\n\n    if not measurements:\n        LOGGER.info('All %s measurements from batch %s processed',\n                    database, batch)\n        return\n\n    # Continue writing measurements\n    _write_error_batch(batch, database, measurements)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the path pattern used when routing a request. Tornado < 4. 5.", "response": "def _get_path_pattern_tornado4(self):\n        \"\"\"Return the path pattern used when routing a request. (Tornado<4.5)\n\n        :rtype: str\n        \"\"\"\n        for host, handlers in self.application.handlers:\n            if host.match(self.request.host):\n                for handler in handlers:\n                    if handler.regex.match(self.request.path):\n                        return handler.regex.pattern"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_path_pattern_tornado45(self, router=None):\n        if router is None:\n            router = self.application.default_router\n        for rule in router.rules:\n            if rule.matcher.match(self.request) is not None:\n                if isinstance(rule.matcher, routing.PathMatches):\n                    return rule.matcher.regex.pattern\n                elif isinstance(rule.target, routing.Router):\n                    return self._get_path_pattern_tornado45(rule.target)", "response": "Returns the path pattern used when routing a request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef duration(self, name):\n        start = time.time()\n        try:\n            yield\n        finally:\n            self.set_field(name, max(time.time(), start) - start)", "response": "Record the time spent inside of a context."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the measurement in the line protocol format.", "response": "def marshall(self):\n        \"\"\"Return the measurement in the line protocol format.\n\n        :rtype: str\n\n        \"\"\"\n        return '{},{} {} {}'.format(\n            self._escape(self.name),\n            ','.join(['{}={}'.format(self._escape(k), self._escape(v))\n                      for k, v in self.tags.items()]),\n            self._marshall_fields(),\n            int(self.timestamp * 1000))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value of a field in the measurement.", "response": "def set_field(self, name, value):\n        \"\"\"Set the value of a field in the measurement.\n\n        :param str name: The name of the field to set the value for\n        :param int|float|bool|str value: The value of the field\n        :raises: ValueError\n\n        \"\"\"\n        if not any([isinstance(value, t) for t in {int, float, bool, str}]):\n            LOGGER.debug('Invalid field value: %r', value)\n            raise ValueError('Value must be a str, bool, integer, or float')\n        self.fields[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_tags(self, tags):\n        for key, value in tags.items():\n            self.set_tag(key, value)", "response": "Set multiple tags for the measurement."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nescape a string for InfluxDB s line protocol.", "response": "def _escape(value):\n        \"\"\"Escape a string (key or value) for InfluxDB's line protocol.\n\n        :param str|int|float|bool value: The value to be escaped\n        :rtype: str\n\n        \"\"\"\n        value = str(value)\n        for char, escaped in {' ': '\\ ', ',': '\\,', '\"': '\\\"'}.items():\n            value = value.replace(char, escaped)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the field dict into a string segment of field key value pairs.", "response": "def _marshall_fields(self):\n        \"\"\"Convert the field dict into the string segment of field key/value\n        pairs.\n\n        :rtype: str\n\n        \"\"\"\n        values = {}\n        for key, value in self.fields.items():\n            if (isinstance(value, int) or\n                    (isinstance(value, str) and value.isdigit() and\n                     '.' not in value)):\n                values[key] = '{}i'.format(value)\n            elif isinstance(value, bool):\n                values[key] = self._escape(value)\n            elif isinstance(value, float):\n                values[key] = '{}'.format(value)\n            elif isinstance(value, str):\n                values[key] = '\"{}\"'.format(self._escape(value))\n        return ','.join(['{}={}'.format(self._escape(k), v)\n                         for k, v in values.items()])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refer(self, text):\n        data = self.reply(text)\n        data['refer_key'] = self['key']\n        return data", "response": "Refers current message and replies a new one"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get(self, path, **kwargs):\n        # clean kwargs (filter None and empty string)\n        clean_kwargs = clean_dict(kwargs)\n\n        data = urllib.parse.urlencode(clean_kwargs)\n        if len(data) > 0:\n            api = self._api('%s.json?%s' % (path, data))\n        else:\n            api = self._api('%s.json' % path)\n        req = request.Request(api, headers=self._headers, method='GET')\n\n        try:\n            resp = request.urlopen(req).read()\n        except urllib.error.HTTPError as e:\n            resp = e.fp.read()\n\n        return json.loads(resp.decode())", "response": "Get a dict from a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef increment(self):\r\n        if self._starttime is not None:\r\n            self._delta = datetime.datetime.now() - self._starttime\r\n        else:\r\n            self._delta = datetime.timedelta()\r\n        \r\n        self.refresh()\r\n        self.ticked.emit()", "response": "Increments the delta information and refreshes the interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef refresh(self):\r\n        delta = self.elapsed()\r\n        seconds = delta.seconds\r\n        limit = self.limit()\r\n        \r\n        options = {}\r\n        options['hours'] = self.hours()\r\n        options['minutes'] = self.minutes()\r\n        options['seconds'] = self.seconds()\r\n        \r\n        try:\r\n            text = self.format() % options\r\n        except ValueError:\r\n            text = '#ERROR'\r\n\r\n        self.setText(text)\r\n\r\n        if limit and limit <= seconds:\r\n            self.stop()\r\n            self.timeout.emit()", "response": "Updates the label display with the current timer information."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresets the timer to 0.", "response": "def reset(self):\r\n        \"\"\"\r\n        Stops the timer and resets its values to 0.\r\n        \"\"\"\r\n        self._elapsed = datetime.timedelta()\r\n        self._delta = datetime.timedelta()\r\n        self._starttime = datetime.datetime.now()\r\n        \r\n        self.refresh()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef seconds(self):\r\n        seconds = self.elapsed().seconds\r\n        if self.limit() and self.countdown():\r\n            seconds = (self.limit() - self.elapsed().seconds)\r\n        return (seconds % 3600) % 60", "response": "Returns the elapsed number of seconds that this timer has been running."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self):\r\n        if self._timer.isActive():\r\n            return\r\n\r\n        self._starttime = datetime.datetime.now()\r\n        self._timer.start()", "response": "Starts running the timer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stop(self):\r\n        if not self._timer.isActive():\r\n            return\r\n\r\n        self._elapsed += self._delta\r\n        self._timer.stop()", "response": "Stops the timer.  If the timer is not currently running, then\r\n        this method will do nothing."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the thread in its own event loop.", "response": "def start( self ):\n        \"\"\"\n        Starts the thread in its own event loop if the local and global thread\n        options are true, otherwise runs the thread logic in the main event\n        loop.\n        \"\"\"\n        if ( self.localThreadingEnabled() and self.globalThreadingEnabled() ):\n            super(XThread, self).start()\n        else:\n            self.run()\n            self.finished.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new editor for the given index parented to the inputed widget.", "response": "def createEditor( self, parent, option, index ):\r\n        \"\"\"\r\n        Creates a new editor for the given index parented to the inputed widget.\r\n        \r\n        :param      parent | <QWidget>\r\n                    option | <QStyleOption>\r\n                    index  | <QModelIndex>\r\n        \r\n        :return     <QWidget> || None\r\n        \"\"\"\r\n        # determine the editor to use for the inputed index based on the\r\n        # table column\r\n        item   = self.parent().itemFromIndex(index)\r\n        column = self.column(index)\r\n        \r\n        # edit based on column preferences\r\n        if column and \\\r\n           not column.isReadOnly() and \\\r\n           isinstance(item, XOrbRecordItem):\r\n            plugin = self.plugin(column)\r\n            if not plugin:\r\n                return None\r\n            \r\n            return plugin.createEditor(parent, item.record(), column)\r\n        \r\n        return super(XOrbTreeWidgetDelegate, self).createEditor(parent,\r\n                                                                option,\r\n                                                                index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart loading this item for the batch.", "response": "def startLoading(self):\r\n        \"\"\"\r\n        Starts loading this item for the batch.\r\n        \"\"\"\r\n        if super(XBatchItem, self).startLoading():\r\n            tree = self.treeWidget()\r\n            if not isinstance(tree, XOrbTreeWidget):\r\n                self.takeFromTree()\r\n                return\r\n            \r\n            next_batch = self.batch()\r\n            tree._loadBatch(self, next_batch)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _loadBatch(self, item, batch):\r\n        if self.isThreadEnabled() and batch.isThreadEnabled():\r\n            self.loadBatchRequested.emit(batch)\r\n            self._batchloaders.append(weakref.ref(item))\r\n        else:\r\n            QApplication.setOverrideCursor(Qt.WaitCursor)\r\n            self.worker().loadRecords(batch)\r\n            QApplication.restoreOverrideCursor()", "response": "Load the items for this tree based on the inputed batch item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _loadColumns(self, record, columnName, value):\r\n        value = unwrapNone(value)\r\n        item = self.findRecordItem(record)\r\n        if item:\r\n            item.updateColumnValue(record.schema().column(columnName),\r\n                                   value,\r\n                                   self.column(columnName))", "response": "Loads the column information for this tree widget for the given record."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _setCurrentRecord(self, item, record):\r\n        try:\r\n            is_record = item.record() == record\r\n        except:\r\n            is_record = False\r\n        \r\n        if is_record:\r\n            self.setCurrentItem(item)\r\n            return True\r\n        \r\n        for c in range(item.childCount()):\r\n            if self._setCurrentRecord(item.child(c), record):\r\n                return True\r\n        \r\n        return False", "response": "Sets the current record for this tree item to the inputed record."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the column values for the inputed column.", "response": "def _updateColumnValues(self, index, hidden):\r\n        \"\"\"\r\n        Updates the column values for the inputed column.\r\n        \r\n        :param      column | <int>\r\n                    state  | <bool>\r\n        \"\"\"\r\n        if hidden or not self.isVisible():\r\n            return\r\n        \r\n        column = self.columnOf(index)\r\n        if not column in self._loadedColumns:\r\n            self._loadedColumns.add(column)\r\n            \r\n            records = self.collectRecords()\r\n            self.loadColumnsRequested.emit(records, column)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addEntryText(self):\r\n        if self.tableType():\r\n            name = self.tableType().schema().displayName().lower()\r\n            return 'add new {0}...'.format(name)\r\n        return 'add new record...'", "response": "Returns the text to be used for the add new record item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nassigning the order names for this tree based on the name of the columns.", "response": "def assignOrderNames(self):\r\n        \"\"\"\r\n        Assigns the order names for this tree based on the name of the\r\n        columns.\r\n        \"\"\"\r\n        try:\r\n            schema = self.tableType().schema()\r\n        except AttributeError:\r\n            return\r\n        \r\n        for colname in self.columns():\r\n            column = schema.column(colname)\r\n            if column:\r\n                self.setColumnOrderName(colname, column.name())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef autoExpand(self, level=None):\r\n        return self._autoExpand.get(level, self._autoExpand.get(None, False))", "response": "Returns whether or not to expand for the inputed level."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclearing the tree and record information.", "response": "def clearAll(self):\r\n        \"\"\"\r\n        Clears the tree and record information.\r\n        \"\"\"\r\n        # clear the tree information\r\n        self.clear()\r\n        \r\n        # clear table information\r\n        self._tableTypeName  = ''\r\n        self._tableType      = None\r\n        \r\n        # clear the records information\r\n        self._recordSet         = None\r\n        self._currentRecordSet  = None\r\n        \r\n        # clear lookup information\r\n        self._query             = None\r\n        self._order             = None\r\n        self._groupBy           = None\r\n        \r\n        # clear paging information\r\n        \r\n        if not self.signalsBlocked():\r\n            self.recordsChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checkedRecords(self, column=0, parent=None, recurse=True):\r\n        output = []\r\n        for item in self.checkedItems(column, parent, recurse):\r\n            try:\r\n                record = item.record()\r\n                if record is not None:\r\n                    output.append(record)\r\n            except AttributeError:\r\n                continue\r\n        return output", "response": "Returns a list of the records that have been checked by the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncollect all the record instances from the tree.", "response": "def collectRecords(self, parent=None):\r\n        \"\"\"\r\n        Collects all the record instances from the tree.\r\n        \r\n        :return     [<orb.Table>\r\n        \"\"\"\r\n        out = []\r\n        if not parent:\r\n            for i in range(self.topLevelItemCount()):\r\n                item = self.topLevelItem(i)\r\n                try:\r\n                    out.append(item.record())\r\n                except AttributeError:\r\n                    pass\r\n                \r\n                out += self.collectRecords(item)\r\n        else:\r\n            for c in range(parent.childCount()):\r\n                item = parent.child(c)\r\n                try:\r\n                    out.append(item.record())\r\n                except AttributeERror:\r\n                    pass\r\n                \r\n                out += self.collectRecords(item)\r\n        \r\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncommits the changes for all the items in the tree.", "response": "def commit(self):\r\n        \"\"\"\r\n        Commits the changes for all the items in the tree.\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        remove_items = []\r\n        commit_items = []\r\n        \r\n        # remove all the items\r\n        commit_state = XOrbRecordItem.State.Modified | XOrbRecordItem.State.New\r\n        remove_state = XOrbRecordItem.State.Removed\r\n        for i in range(self.topLevelItemCount()):\r\n            item = self.topLevelItem(i)\r\n            \r\n            if isinstance(item, XOrbRecordItem) or\\\r\n                isinstance(item, XOrbGroupItem):\r\n                remove_items += item.findItemsByState(remove_state)\r\n                commit_items += item.findItemsByState(commit_state)\r\n        \r\n        # make sure we can remove the records\r\n        for item in remove_items:\r\n            record = item.record()\r\n            try:\r\n                record.remove(dryRun = True, throw=True)\r\n            except orb.errors.CannotRemoveError, err:\r\n                QMessageBox.information(self,\r\n                                        'Cannot Remove',\r\n                                        nativestring(err))\r\n                return False\r\n        \r\n        # remove the records\r\n        remove_set = RecordSet([item.record() for item in remove_items])\r\n        remove_set.remove()\r\n        \r\n        for item in remove_items:\r\n            item.record().remove()\r\n            parent = item.parent()\r\n            if parent:\r\n                index = parent.indexOfChild(item)\r\n                parent.takeChild(index)\r\n            else:\r\n                index = self.indexOfTopLevelItem(item)\r\n                self.takeTopLevelItem(index)\r\n        \r\n        # commit the new records\r\n        for item in commit_items:\r\n            self.aboutToSaveRecord.emit(item.record())\r\n            item.record().commit()\r\n            item.setRecordState(XOrbRecordItem.State.Normal)\r\n        \r\n        self.recordsCommitted.emit()\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef commitData(self, widget):\r\n        self._editColumn = self.currentColumn()\r\n        self.itemChanged.connect(self._commitToSelected)\r\n        super(XOrbTreeWidget, self).commitData(widget)\r\n        self.itemChanged.disconnect(self._commitToSelected)\r\n        self._editColumn = None", "response": "Commits the data from the widget to the model."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the default context menu options for the orb tree widget.", "response": "def contextMenuEvent(self, event):\r\n        \"\"\"\r\n        Handles the default menu options for the orb widget.\r\n        \r\n        :param      event | <QContextMenuEvent>\r\n        \"\"\"\r\n        if self.contextMenuPolicy() == Qt.DefaultContextMenu:\r\n            self.showMenu(event.pos())\r\n        else:\r\n            super(XOrbTreeWidget, self).contextMenuEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a record item instance for the given record.", "response": "def createRecordItem(self, record, parent=None):\r\n        \"\"\"\r\n        Creates the record item instance for the given record.\r\n        \r\n        :param      parent      | <QTreeWidgetItem> || <QTreeWidget>\r\n                    record      | <orb.Table>\r\n        \r\n        :return     <QTreeWidgetItem>\r\n        \"\"\"\r\n        if parent is None:\r\n            parent=self\r\n        \r\n        return self.recordItemClass(record)(parent, record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the record items for the given records.", "response": "def createRecordItems(self, records, parent=None):\r\n        \"\"\"\r\n        Creates the record item instance for the given record.\r\n        \r\n        :param      records     | [<orb.Table>, ..]\r\n                    parent      | <QTreeWidgetItem> || <QTreeWidget>\r\n        \r\n        :return     <QTreeWidgetItem>\r\n        \"\"\"\r\n        if parent is None:\r\n            parent=self\r\n            \r\n        blocked = self.signalsBlocked()\r\n        self.blockSignals(True)\r\n        self.setUpdatesEnabled(False)\r\n        for record in records:\r\n            self.recordItemClass(record)(parent, record)\r\n        \r\n        if not blocked:\r\n            self.blockSignals(False)\r\n            self.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef createGroupItem(self, grp, records, nextLevels=None, parent=None):\r\n        if parent is None:\r\n            parent = self\r\n        \r\n        item = self.recordGroupClass(type(grp))(parent,\r\n                                                grp,\r\n                                                records,\r\n                                                nextLevels)\r\n        \r\n        if parent == self and self.useGroupStyle():\r\n            item.initGroupStyle()\r\n        \r\n        level = 0\r\n        while parent and parent != self:\r\n            level += 1\r\n            parent = parent.parent()\r\n        \r\n        expand = self.autoExpand(level)\r\n        if expand:\r\n            try:\r\n                item.load()\r\n            except AttributeError:\r\n                pass\r\n            item.setExpanded(True)\r\n        \r\n        return item", "response": "Creates a new group item instance for the given group and records."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the current record from the tree view.", "response": "def currentRecord(self):\r\n        \"\"\"\r\n        Returns the current record from the tree view.\r\n        \r\n        :return     <orb.Table> || None\r\n        \"\"\"\r\n        item = self.currentItem()\r\n        if isinstance(item, XOrbRecordItem):\r\n            return item.record()\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef database(self):\r\n        if self._database:\r\n            return self._database\r\n        if self._recordSet is not None:\r\n            return self._recordSet.database()\r\n        else:\r\n            return Orb.instance().database()", "response": "Returns the database associated with this tree widget."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dragEnterEvent(self, event):\r\n        data = event.mimeData()\r\n        if data.hasFormat('application/x-orb-table') and \\\r\n           data.hasFormat('application/x-orb-query'):\r\n            tableName = self.tableTypeName()\r\n            if nativestring(data.data('application/x-orb-table')) == tableName:\r\n                event.acceptProposedAction()\r\n                return\r\n        \r\n        super(XOrbTreeWidget, self).dragEnterEvent(event)", "response": "Listens for query s being dragged and dropped onto this tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverriding this method to filter out the related objects.", "response": "def dropEvent(self, event):\r\n        \"\"\"\r\n        Listens for query's being dragged and dropped onto this tree.\r\n        \r\n        :param      event | <QDropEvent>\r\n        \"\"\"\r\n        # overload the current filtering options\r\n        data = event.mimeData()\r\n        if data.hasFormat('application/x-orb-table') and \\\r\n           data.hasFormat('application/x-orb-query'):\r\n            tableName = self.tableTypeName()\r\n            if nativestring(data.data('application/x-orb-table')) == tableName:\r\n                data = nativestring(data.data('application/x-orb-query'))\r\n                query = Q.fromXmlString(data)\r\n                self.setQuery(query)\r\n                return\r\n        \r\n        super(XOrbTreeWidget, self).dropEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassign the grouping to the current header index. Returns True if the grouping is active False otherwise.", "response": "def groupByHeaderIndex(self):\r\n        \"\"\"\r\n        Assigns the grouping to the current header index.\r\n        \"\"\"\r\n        index = self.headerMenuColumn()\r\n        columnTitle = self.columnOf(index)\r\n        tableType = self.tableType()\r\n        \r\n        if not tableType:\r\n            return\r\n        \r\n        column = tableType.schema().column(columnTitle)\r\n        if not column:\r\n            return\r\n        \r\n        self.setGroupBy(column.name())\r\n        self.setGroupingActive(True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first hierarchy entry for the inputed record.", "response": "def hierarchyLookup(self, record):\r\n        \"\"\"\r\n        Looks up additional hierarchy information for the inputed record.\r\n        \r\n        :param      record | <orb.Table>\r\n        \r\n        :return     (<subclass of orb.Table> || None, <str> column)\r\n        \"\"\"\r\n        def _get_lookup(cls):\r\n            if cls in self._hierarchyLookup:\r\n                return self._hierarchyLookup[cls]\r\n            \r\n            for base in cls.__bases__:\r\n                results = _get_lookup(base)\r\n                if results:\r\n                    return results\r\n            \r\n            return (None, None)\r\n        \r\n        tableType, column = _get_lookup(type(record))\r\n        \r\n        if tableType and column:\r\n            return (tableType, column)\r\n        \r\n        default = self._hierarchyLookup.get(None)\r\n        if default:\r\n            return default\r\n        return (None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef editRecord(self, record, pos=None):\r\n        \r\n        typ = type(record)\r\n        editor = self._recordEditors.get(typ)\r\n        if not editor:\r\n            return False\r\n        \r\n        if self.popupEditing():\r\n            popup = self.popupWidget()\r\n            edit = popup.centralWidget()\r\n            \r\n            # create a new editor if required\r\n            if type(edit) != editor:\r\n                if edit:\r\n                    edit.close()\r\n                    edit.deleteLater()\r\n                \r\n                edit = editor(popup)\r\n                edit.setAutoCommitOnSave(True)\r\n                popup.setCentralWidget(edit)\r\n                popup.accepted.connect(edit.save)\r\n                edit.aboutToSaveRecord.connect(self.recordUpdated)\r\n                edit.saved.connect(self.refresh)\r\n            \r\n            edit.setRecord(record)\r\n            popup.popup(pos)\r\n        \r\n        else:\r\n            if editor.edit(record, autoCommit=False):\r\n                self.recordUpdated.emit(record)\r\n                record.commit()\r\n                self.refresh()\r\n        \r\n        return True", "response": "Prompts the user to edit the specified record using a preset editor defined in the setRecordEditors method. Returns True if successful False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef emitCurrentRecordChanged(self, item):\r\n        if self.signalsBlocked():\r\n            return\r\n        \r\n        # emit that the record has been clicked\r\n        if isinstance(item, XOrbRecordItem):\r\n            self.currentRecordChanged.emit(item.record())\r\n        else:\r\n            self.currentRecordChanged.emit(None)", "response": "Emits the current record changed signal for the given item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nemitting the record clicked signal for the given item.", "response": "def emitRecordClicked(self, item):\r\n        \"\"\"\r\n        Emits the record clicked signal for the given item, provided the\r\n        signals are not currently blocked.\r\n        \r\n        :param      item | <QTreeWidgetItem>\r\n        \"\"\"\r\n        # load the next page\r\n        if isinstance(item, XBatchItem):\r\n            item.startLoading()\r\n            self.clearSelection()\r\n            \r\n        # emit that the record has been clicked\r\n        if isinstance(item, XOrbRecordItem) and not self.signalsBlocked():\r\n            self.recordClicked.emit(item.record())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nemit the record double clicked signal for the given item.", "response": "def emitRecordDoubleClicked(self, item):\r\n        \"\"\"\r\n        Emits the record clicked signal for the given item, provided the\r\n        signals are not currently blocked.\r\n        \r\n        :param      item | <QTreeWidgetItem>\r\n        \"\"\"\r\n        # emit that the record has been double clicked\r\n        if isinstance(item, XOrbRecordItem) and not self.signalsBlocked():\r\n            self.recordDoubleClicked.emit(item.record())\r\n        \r\n        # add a new blank entry if this tree supports it\r\n        elif isinstance(item, XAddRecordItem) and self.tableType():\r\n            self.blockSignals(True)\r\n            item_cls = self.recordItemClass()\r\n            new_item = item_cls(self, self.tableType()())\r\n            self.takeTopLevelItem(self.indexOfTopLevelItem(item))\r\n            self.addTopLevelItem(item)\r\n            self.setCurrentItem(item)\r\n            self.editItem(new_item, 0)\r\n            self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef emitRecordMiddleClicked(self, item):\r\n        # emit that the record has been double clicked\r\n        if isinstance(item, XOrbRecordItem) and not self.signalsBlocked():\r\n            self.recordMiddleClicked.emit(item.record())", "response": "Emits the record middle clicked signal for the given item."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef emitRecordMiddleDoubleClicked(self, item):\r\n        # emit that the record has been double clicked\r\n        if isinstance(item, XOrbRecordItem) and not self.signalsBlocked():\r\n            self.recordMiddleDoubleClicked.emit(item.record())", "response": "Emits the record middle double clicked signal for the given item."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the first record item in the tree hierarchy that matches the given record.", "response": "def findRecordItem(self, record, parent=None):\r\n        \"\"\"\r\n        Looks through the tree hierarchy for the given record.\r\n        \r\n        :param      record | <orb.Record>\r\n                    parent | <QTreeWidgetItem> || None\r\n        \r\n        :return     <XOrbRecordItem> || None\r\n        \"\"\"\r\n        try:\r\n            item = self._recordMapping[record]()\r\n        except KeyError:\r\n            return None\r\n        \r\n        if item is None:\r\n            self._recordMapping.pop(record)\r\n        \r\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef initializeColumns(self):\r\n        tableType = self.tableType()\r\n        if not tableType:\r\n            return\r\n        elif self._columnsInitialized or self.columnOf(0) != '1':\r\n            self.assignOrderNames()\r\n            return\r\n        \r\n        # set the table header information\r\n        tschema = tableType.schema()\r\n        columns = tschema.columns()\r\n        \r\n        names = [col.displayName() for col in columns if not col.isPrivate()]\r\n        self.setColumns(sorted(names))\r\n        self.assignOrderNames()\r\n        self.resizeToContents()", "response": "Initializes the columns that will be used for this tree widget based on the table type linked to it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef keyPressEvent(self, event):\r\n        # tag the item for deletion\r\n        if self.useDefaultKeystrokes() and self.isEditable():\r\n            if event.key() == Qt.Key_Delete:\r\n                for item in self.selectedItems():\r\n                    item.setRecordState(XOrbRecordItem.State.Removed)\r\n            \r\n            # save/commit to the database\r\n            elif event.key() == Qt.Key_S and\\\r\n                 event.modifiers() == Qt.ControlModifier:\r\n                self.commit()\r\n        \r\n        super(XOrbTreeWidget, self).keyPressEvent(event)", "response": "Handles the key press event for deletion and save the object state to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mimeData(self, items):\r\n        func = self.dataCollector()\r\n        if func:\r\n            return func(self, items)\r\n        \r\n        # extract the records from the items\r\n        record_items = []\r\n        for item in self.selectedItems():\r\n            if isinstance(item, XOrbRecordItem):\r\n                record_items.append(item)\r\n        \r\n        # create the mime data\r\n        data = QMimeData()\r\n        self.dataStoreRecords(data, record_items)\r\n        return data", "response": "Returns the mime data for dragging for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the popup widget for this editor.", "response": "def popupWidget(self):\r\n        \"\"\"\r\n        Returns the popup widget for this editor.\r\n        \r\n        :return     <skyline.gui.XPopupWidget>\r\n        \"\"\"\r\n        if not self._popup:\r\n            btns = QDialogButtonBox.Save | QDialogButtonBox.Cancel\r\n            self._popup = XPopupWidget(self, btns)\r\n            self._popup.setShowTitleBar(False)\r\n            self._popup.setAutoCalculateAnchor(True)\r\n            self._popup.setPositionLinkedTo(self)\r\n        return self._popup"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recordItemClass(self, record=None):\r\n        if record is not None:\r\n            key = type(record)\r\n        else:\r\n            key = None\r\n        \r\n        return self._recordItemClass.get(key, self._recordItemClass[None])", "response": "Returns the record item class instance linked with this tree widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the record editor for the given table type.", "response": "def recordEditor(self, tableType=None):\r\n        \"\"\"\r\n        Returns the record editor from the set for the given table type.\r\n        \r\n        :param      tableType | <subclass of orb.Table> || None\r\n        \r\n        :return     <subclass of XOrbRecordWidget> || None\r\n        \"\"\"\r\n        if tableType == None:\r\n            tableType = self.tableType()\r\n        \r\n        return self._recordEditors.get(tableType, None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reorder(self, index, direction):\r\n        columnTitle = self.columnOf(index)\r\n        columnName  = self.columnOrderName(columnTitle)\r\n        \r\n        if not columnName:\r\n            return\r\n        \r\n        # grab the table and ensure we have a valid column\r\n        table = self.tableType()\r\n        if not table:\r\n            return\r\n        \r\n        column = table.schema().column(columnName)\r\n        if not column:\r\n            return\r\n        \r\n        if direction == Qt.AscendingOrder:\r\n            db_dir = 'asc'\r\n        else:\r\n            db_dir = 'desc'\r\n        \r\n        order = [(columnName, db_dir)]\r\n        \r\n        # lookup reference column ordering\r\n        if column.isReference():\r\n            ref = column.referenceModel()\r\n            if ref:\r\n                ref_order = ref.schema().defaultOrder()\r\n                if ref_order:\r\n                    order = [(columnName + '.' + ref_order[0][0], db_dir)]\r\n                    order += ref_order[1:]\r\n        \r\n        # update the information\r\n        self.clear()\r\n        super(XOrbTreeWidget, self).sortByColumn(index, direction)\r\n        \r\n        self.setOrder(order)\r\n        self.refresh()", "response": "Reorders the data in this tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refresh(self, reloadData=False, force=False):\r\n        if not (self.isVisible() or force):\r\n            self._refreshTimer.start()\r\n            return\r\n        \r\n        if self.isLoading():\r\n            return\r\n        \r\n        if reloadData:\r\n            self.refreshQueryRecords()\r\n        \r\n        # cancel current work\r\n        self._refreshTimer.stop()\r\n        self.worker().cancel()\r\n        \r\n        if self._popup:\r\n            self._popup.close()\r\n        \r\n        # grab the record set\r\n        currset = self.currentRecordSet()\r\n        \r\n        self.worker().setBatched(self.isPaged())\r\n        self.worker().setBatchSize(self.pageSize())\r\n        \r\n        # group the information\r\n        if self._searchTerms:\r\n            currset.setGroupBy(None)\r\n            pageSize = 0\r\n        \r\n        # work with groups\r\n        elif self.groupBy() and self.isGroupingActive():\r\n            currset.setGroupBy(self.groupBy())\r\n        \r\n        # work with batching\r\n        else:\r\n            currset.setGroupBy(None)\r\n        \r\n        # order the information\r\n        if self.order():\r\n            currset.setOrdered(True)\r\n            currset.setOrder(self.order())\r\n        \r\n        # for larger queries, run it through the thread\r\n        if self.useLoader():\r\n            loader = XLoaderWidget.start(self)\r\n        \r\n        # specify the columns to load\r\n        if self.specifiedColumnsOnly():\r\n            currset.setColumns(map(lambda x: x.name(),\r\n                                   self.specifiedColumns()))\r\n        \r\n        self._loadedColumns = set(self.visibleColumns())\r\n        \r\n        if self.isThreadEnabled() and currset.isThreadEnabled():\r\n            self.worker().setPreloadColumns(self._preloadColumns)\r\n            self.loadRequested.emit(currset)\r\n        else:\r\n            QApplication.setOverrideCursor(Qt.WaitCursor)\r\n            self.worker().loadRecords(currset)\r\n            QApplication.restoreOverrideCursor()", "response": "Refreshes the record list for the tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrefreshing the query results based on the tree s query.", "response": "def refreshQueryRecords(self):\r\n        \"\"\"\r\n        Refreshes the query results based on the tree's query.\r\n        \"\"\"\r\n        if self._recordSet is not None:\r\n            records = RecordSet(self._recordSet)\r\n        elif self.tableType():\r\n            records = self.tableType().select()\r\n        else:\r\n            return\r\n        \r\n        records.setDatabase(self.database())\r\n        \r\n        # replace the base query with this widget\r\n        if self.queryAction() == XOrbTreeWidget.QueryAction.Replace:\r\n            if self.query():\r\n                records.setQuery(self.query())\r\n            else:\r\n                records.setQuery(None)\r\n        \r\n        # join together the query for this widget\r\n        elif self.queryAction() == XOrbTreeWidget.QueryAction.Join:\r\n            if records.query():\r\n                records.setQuery(self.query() & self.query())\r\n            elif self.query():\r\n                records.setQuery(self.query())\r\n            else:\r\n                records.setQuery(None)\r\n        \r\n        self._recordSet = records\r\n        \r\n        if not self.signalsBlocked():\r\n            self.queryChanged.emit()\r\n            self.recordsChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestoring data from the xml entry.", "response": "def restoreXml(self, xml):\r\n        \"\"\"\r\n        Restores data from the xml entry.\r\n        \r\n        :param      xml | <xml.etree.ElementTree.Element>\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        if xml is None:\r\n            return False\r\n        \r\n        # restore grouping\r\n        grps = xml.get('grouping')\r\n        if grps is not None:\r\n            self.setGroupingActive(True)\r\n            self.setGroupBy(grps.split(','))\r\n        \r\n        # restore grouping enabled\r\n        grp_enabled = xml.get('groupingActive')\r\n        if grp_enabled is not None:\r\n            self.setGroupingActive(grp_enabled == 'True', autoRefresh=False)\r\n        \r\n        # restore standard tree options\r\n        return super(XOrbTreeWidget, self).restoreXml(xml)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef saveXml(self, xml):\r\n        if xml is None:\r\n            return False\r\n        \r\n        # save the grouping enabled information\r\n        xml.set('groupingActive', nativestring(self.isGroupingActive()))\r\n        \r\n        # save the grouping information\r\n        if self.groupBy():\r\n            xml.set('grouping', ','.join(self.groupBy()))\r\n        \r\n        # save standard tree options\r\n        return super(XOrbTreeWidget, self).saveXml(xml)", "response": "Saves the tree to the inputed xml entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a search for the records in the specified search string.", "response": "def searchRecords(self, search):\r\n        \"\"\"\r\n        Creates a search for the inputed records by joining the search terms\r\n        and query from the inputed search string by using the \r\n        Orb.Query.fromSearch method.\r\n        \r\n        :param      search  | <str>\r\n                    refined | <orb.Query> || None\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        \r\n        # take the base record set\r\n        self._currentRecordSet  = None\r\n        self._searchTerms       = nativestring(search)\r\n        \r\n        # if we don't have a search, then go back to the default records\r\n        if not search:\r\n            if not self.signalsBlocked():\r\n                if self._recordSet is not None:\r\n                    self._recordSet.clear()\r\n                \r\n                self._searched = False\r\n                self.refresh()\r\n                self.recordsChanged.emit()\r\n                return False\r\n            return False\r\n        \r\n        self._searched=True\r\n        \r\n        # start from our default record set\r\n        rset = self.searchableRecords()\r\n        self._currentRecordSet = rset.search(search)\r\n        \r\n        # update widget and notify any listeners\r\n        if not self.signalsBlocked():\r\n            self.refresh()\r\n            self.recordsChanged.emit()\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef selectedRecords(self):\r\n        output = []\r\n        for item in self.selectedItems():\r\n            if ( isinstance(item, XOrbRecordItem) ):\r\n                output.append(item.record())\r\n        return output", "response": "Returns a list of all the selected records for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setCheckedRecords(self, records, column=0, parent=None):\r\n        if parent is None:\r\n            for i in range(self.topLevelItemCount()):\r\n                item = self.topLevelItem(i)\r\n                try:\r\n                    has_record = item.record() in records\r\n                except AttributeError:\r\n                    has_record = False\r\n                \r\n                if has_record:\r\n                    item.setCheckState(column, Qt.Checked)\r\n                \r\n                self.setCheckedRecords(records, column, item)\r\n        else:\r\n            for c in range(parent.childCount()):\r\n                item = parent.child(c)\r\n                try:\r\n                    has_record = item.record() in records\r\n                except AttributeError:\r\n                    has_record = False\r\n                \r\n                if has_record:\r\n                    item.setCheckState(column, Qt.Checked)\r\n                \r\n                self.setCheckedRecords(records, column, item)", "response": "Sets the checked items based on the inputed list of records."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setColumns(self, columns):\r\n        super(XOrbTreeWidget, self).setColumns(columns)\r\n        self.setFilteredColumns(range(len(columns)))\r\n        self.assignOrderNames()\r\n        self._columnsInitialized = True", "response": "Sets the columns for this widget and marks the system as having been initialized."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the mapper for the given column name to the callable.", "response": "def setColumnMapper(self, columnName, callable):\r\n        \"\"\"\r\n        Sets the mapper for the given column name to the callable.  The inputed\r\n        callable should accept a single argument for a record from the tree and\r\n        return the text that should be displayed in the column.\r\n        \r\n        :param      columnName | <str>\r\n                    callable   | <function> || <method> || <lambda>\r\n        \"\"\"\r\n        columnName = nativestring(columnName)\r\n        if ( callable is None and columnName in self._columnMappers ):\r\n            self._columnMappers.pop(columnName)\r\n            return\r\n        \r\n        self._columnMappers[nativestring(columnName)] = callable"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCurrentRecord(self, record):\r\n        if self.isLoading():\r\n            self._tempCurrentRecord = record\r\n            return\r\n        \r\n        for i in range(self.topLevelItemCount()):\r\n            if self._setCurrentRecord(self.topLevelItem(i), record):\r\n                return True\r\n        return False", "response": "Sets the current record for this tree to the inputed record. Returns True if the tree is loaded False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setGroupBy(self, groupBy):\r\n        if groupBy and not type(groupBy) in (list, tuple):\r\n            groupBy = [nativestring(groupBy)]\r\n        elif not groupBy:\r\n            groupBy = None\r\n        \r\n        self._groupBy = groupBy", "response": "Sets the grouping information for this tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setGroupingActive(self, state, autoRefresh=False):\r\n        self._groupingActive = state\r\n        \r\n        self.setRootIsDecorated(state)\r\n        \r\n        if autoRefresh:\r\n            self.refresh()", "response": "Sets whether or not grouping is enabled for this system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setColumnOrderName(self, columnName, orderName):\r\n        self._columnOrderNames[nativestring(columnName)] = nativestring(orderName)", "response": "Sets the database name to use when ordering this widget by the given column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the hierarchy lookup for the inputed table type and column.", "response": "def setHierarchyLookup(self, columnName, tableType=None):\r\n        \"\"\"\r\n        Sets the hierarchy lookup for the inputed table type and column.\r\n        \r\n        :param      columnName | <str>\r\n                    tableType  | <subclass of Table>\r\n        \"\"\"\r\n        if tableType:\r\n            tableType = self.tableType()\r\n        self._hierarchyLookup[tableType] = (tableType, columnName)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the page size for this widget.", "response": "def setPageSize(self, pageSize):\r\n        \"\"\"\r\n        Sets the page size for this widget.  If the page size is set to -1,\r\n        then there is no sizing and all records are displayed.\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        if pageSize == self._pageSize:\r\n            return\r\n        \r\n        self._pageSize = pageSize\r\n        self.setPaged(pageSize > 0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the query instance for this tree widget to the inputed query.", "response": "def setQuery(self, query, autoRefresh=False):\r\n        \"\"\"\r\n        Sets the query instance for this tree widget to the inputed query.\r\n        \r\n        :param      query | <orb.Query>\r\n        \"\"\"\r\n        self._query             = query\r\n        self._currentRecordSet  = None\r\n        \r\n        if autoRefresh:\r\n            self.refreshQueryRecords()\r\n            self.refresh()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setRecords(self, records):\r\n        self._searchTerms = ''\r\n        \r\n        if not isinstance(records, RecordSet):\r\n            records = RecordSet(records)\r\n        self.setRecordSet(records)", "response": "Sets the list of records that will be displayed in this tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setRecordEditor(self, editorClass, tableType=None):\r\n        if tableType is None:\r\n            tableType = editorClass.tableType()\r\n        \r\n        self._recordEditors[tableType] = editorClass", "response": "Sets the record editor for this tree based on the given table type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the record set that will be used to lookup the information for the specified tree.", "response": "def setRecordSet(self, recordSet):\r\n        \"\"\"\r\n        Defines the record set that will be used to lookup the information for\r\n        this tree.\r\n        \r\n        :param      records | [<Table>, ..] || None\r\n        \"\"\"\r\n        if not self.tableType():\r\n            self.setTableType(recordSet.table())\r\n        \r\n        self._currentRecordSet = None\r\n        self._recordSet = recordSet\r\n        \r\n        try:\r\n            self.setDatabase(recordSet.database())\r\n        except AttributeError:\r\n            pass\r\n        \r\n        if not self.signalsBlocked():\r\n            self.refresh()\r\n            self.recordsChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the record set based off of an external search.", "response": "def setSearchedRecords(self, records):\r\n        \"\"\"\r\n        Sets a record set based off of an external search.  Searched results\r\n        provide an overridden entry to the tree widget, by passing the\r\n        grouping mechanism.\r\n        \r\n        :param      records | <orb.RecordSet>\r\n        \r\n        :return     <bool> | records\r\n        \"\"\"\r\n        self._searchTerms = 'EXTERNAL_SEARCH'\r\n        self._currentRecordSet = records\r\n        \r\n        # update widget and notify any listeners\r\n        if not self.signalsBlocked():\r\n            self.refresh()\r\n            self.recordsChanged.emit()\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the type of the table that this tree will be displaying.", "response": "def setTableType(self, tableType):\r\n        \"\"\"\r\n        Defines the table class type that this tree will be displaying.\r\n        \r\n        :param      table | <subclass of orb.Table>\r\n        \"\"\"\r\n        if tableType == self._tableType:\r\n            return\r\n        \r\n        # clear all the information\r\n        blocked = self.signalsBlocked()\r\n        \r\n        self.blockAllSignals(True)\r\n        \r\n        # only clear if necessary\r\n        if self._tableType:\r\n            self.clearAll()\r\n        \r\n        # update the table type data\r\n        self._tableType = tableType\r\n        \r\n        if tableType:\r\n            self._tableTypeName = tableType.__name__\r\n        else:\r\n            self._tableTypeName = ''\r\n            \r\n        self.initializeColumns()\r\n        self.blockAllSignals(blocked)\r\n        \r\n        if not self.signalsBlocked():\r\n            self.tableTypeChanged.emit()\r\n            self.recordsChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the table type name that this tree will be displaying.", "response": "def setTableTypeName(self, tableTypeName):\r\n        \"\"\"\r\n        Defines the table type name that this tree will be displaying.\r\n        \r\n        :param      tableTypeName | <str>\r\n        \"\"\"\r\n        self._tableTypeName = tableTypeName\r\n        if ( not Orb ):\r\n            return\r\n        \r\n        self.setTableType(Orb.instance().model(nativestring(tableTypeName)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting whether or not the first group should draw with the grouping style or not.", "response": "def setUseGroupStyle(self, state):\r\n        \"\"\"\r\n        Sets whether or not the first group should draw with the\r\n        grouping style or not.\r\n        \r\n        :param     state | <bool>\r\n        \"\"\"\r\n        self._useGroupStyle = state\r\n        if state:\r\n            self.setRootIsDecorated(False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setupHeaderMenu(self, menu, index):\r\n        if not self.userGroupingEnabled():\r\n            return False\r\n        \r\n        first_action = menu.actions()[1]\r\n        column = self.columnOf(index)\r\n        \r\n        enable_action = QAction(menu)\r\n        enable_action.setText('Enable Grouping')\r\n        \r\n        disable_action = QAction(menu)\r\n        disable_action.setText('Disable Grouping')\r\n        \r\n        quick_action = QAction(menu)\r\n        quick_action.setText('Group by \"%s\"' % column)\r\n        \r\n#        adv_action = QAction(menu)\r\n#        adv_action.setText('More Grouping Options...')\r\n        \r\n        menu.insertSeparator(first_action)\r\n        menu.insertAction(first_action, enable_action)\r\n        menu.insertAction(first_action, disable_action)\r\n        menu.insertSeparator(first_action)\r\n        menu.insertAction(first_action, quick_action)\r\n#        menu.insertAction(first_action, adv_action)\r\n        \r\n        quick_action.triggered.connect(self.groupByHeaderIndex)\r\n#        adv_action.triggered.connect(self.showAdvancedGroupingOptions)\r\n        enable_action.triggered.connect(self.activateGrouping)\r\n        disable_action.triggered.connect(self.deactivateGrouping)\r\n        return True", "response": "Setup the header right - click menu."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef showMenu(self, pos):\r\n        glbl_pos = self.viewport().mapToGlobal(pos)\r\n        \r\n        # lookup the specific item at the given position\r\n        item = self.itemAt(pos)\r\n        selected = self.selectedRecords()\r\n        \r\n        if not self._recordEditors:\r\n            return\r\n        \r\n        if item and not isinstance(item, XOrbRecordItem):\r\n            return\r\n        \r\n        menu = QMenu(self)\r\n        acts = {}\r\n        \r\n        # modify a particular item\r\n        if item:\r\n            if self.editorFlags() & XOrbTreeWidget.EditorFlags.Edit:\r\n                record = item.record()\r\n                editor = self.recordEditor(type(record))\r\n                \r\n                if editor:\r\n                    name = record.schema().displayName()\r\n                    act = menu.addAction('Edit {}...'.format(name))\r\n                    act.setIcon(QIcon(resources.find('img/edit.png')))\r\n                    acts[act] = (editor, 'edit', record)\r\n        \r\n        # add items\r\n        if self.editorFlags() & XOrbTreeWidget.EditorFlags.Create:\r\n            menu.addSeparator()\r\n            \r\n            typs = self._recordEditors.keys()\r\n            typs.sort(key=lambda x: x.schema().displayName())\r\n            \r\n            for typ in typs:\r\n                name = typ.schema().displayName()\r\n                act  = menu.addAction('Add {}...'.format(name))\r\n                act.setIcon(QIcon(resources.find('img/add.png')))\r\n                acts[act] = (self._recordEditors[typ], 'create', None)\r\n        \r\n        # remove selected items\r\n        if selected and self.editorFlags() & XOrbTreeWidget.EditorFlags.Remove:\r\n            menu.addSeparator()\r\n            \r\n            act = menu.addAction('Remove Selected Records')\r\n            act.setIcon(QIcon(resources.find('img/remove.png')))\r\n            acts[act] =(None, 'remove', selected)\r\n        \r\n        if not acts:\r\n            return\r\n        \r\n        act = menu.exec_(glbl_pos)\r\n        \r\n        editor, action, record = acts.get(act, (None, None, None))\r\n        \r\n        # create a new record\r\n        if action == 'create':\r\n            record = editor.create(autoCommit=False)\r\n            if record:\r\n                self.recordCreated.emit(record)\r\n                record.commit()\r\n                self.refresh()\r\n        \r\n        # edit an existing record\r\n        elif action == 'edit':\r\n            self.editRecord(record, glbl_pos)\r\n        \r\n        # remove selected records\r\n        elif action == 'remove':\r\n            title = 'Remove Records'\r\n            msg = 'Are you sure you want to remove these records?'\r\n            btns = QMessageBox.Yes | QMessageBox.No\r\n            ans = QMessageBox.information(self.window(), title, msg, btns)\r\n            if ans == QMessageBox.Yes:\r\n                self.recordsRemoved.emit(selected)\r\n                if RecordSet(selected).remove():\r\n                    self.refresh()", "response": "Creates a new menu for this widget and displays it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting the data for this widget based on the inputed index & direction.", "response": "def sortByColumn(self, index, direction):\r\n        \"\"\"\r\n        Sorts the data for this widget based on the inputed index & direction.\r\n        \r\n        :param      index | <int>\r\n                    direction | <Qt.SortOrder\r\n        \"\"\"\r\n        if self.isPaged() and not self.isFullyLoaded():\r\n            self.reorder(index, direction)\r\n        else:\r\n            super(XOrbTreeWidget, self).sortByColumn(index, direction)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef toggleSelectedItemState(self, state):\r\n        items = self.selectedItems()\r\n        for item in items:\r\n            if ( item.hasRecordState(state) ):\r\n                item.removeRecordState(state)\r\n            else:\r\n                item.addRecordState(state)", "response": "Toggles the selection for the inputed state."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the items icon based on its state.", "response": "def updateItemIcon(self, item):\r\n        \"\"\"\r\n        Updates the items icon based on its state.\r\n        \r\n        :param      item | <QTreeWidgetItem>\r\n        \"\"\"\r\n        # update the column width\r\n        self.setUpdatesEnabled(False)\r\n        colwidth = self.columnWidth(0)\r\n        self.resizeColumnToContents(0)\r\n        new_colwidth = self.columnWidth(0)\r\n        \r\n        if new_colwidth < colwidth:\r\n            self.setColumnWidth(0, colwidth)\r\n        self.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef worker(self):\r\n        if self._worker is None:\r\n            self._worker = XOrbLookupWorker(self.isThreadEnabled())\r\n            \r\n            # create worker connections\r\n            self.loadRequested.connect(self._worker.loadRecords)\r\n            self.loadBatchRequested.connect(self._worker.loadBatch)\r\n            self.loadColumnsRequested.connect(self._worker.loadColumns)\r\n            \r\n            self._worker.loadingStarted.connect(self.markLoadingStarted)\r\n            self._worker.loadingFinished.connect(self.markLoadingFinished)\r\n            self._worker.loadedRecords[object].connect(self._loadRecords)\r\n            self._worker.loadedRecords[object, object].connect(self._loadRecords)\r\n            self._worker.loadedGroup.connect(self.createGroupItem)\r\n            self._worker.columnLoaded.connect(self._loadColumns)\r\n            self._worker.connectionLost.connect(self._connectionLost)\r\n            \r\n        return self._worker", "response": "Returns the worker associated with this tree widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of records from the given mime data.", "response": "def dataRestoreRecords(mimeData):\r\n        \"\"\"\r\n        Extracts the records from the inputed drag & drop mime data information.\r\n        This will lookup the models based on their primary key information and\r\n        generate the element class.\r\n        \r\n        :param      mimeData | <QMimeData>\r\n        \r\n        :return     [<orb.Table>, ..]\r\n        \"\"\"\r\n        if not mimeData.hasFormat('application/x-orb-records'):\r\n            return []\r\n        \r\n        from orb import Orb\r\n        \r\n        repros = nativestring(mimeData.data('application/x-orb-records'))\r\n        repros = repros.split(';')\r\n        \r\n        output =[]\r\n        for repro in repros:\r\n            cls, pkey = re.match('^(\\w+)\\((.*)\\)$', repro).groups()\r\n            pkey = eval(pkey)\r\n            \r\n            model = Orb.instance().model(cls)\r\n            if not model:\r\n                continue\r\n            \r\n            record = model(pkey)\r\n            if record.isRecord():\r\n                output.append(record)\r\n        \r\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dataStoreRecords(mimeData, record_items):\r\n        record_data = []\r\n        for record_item in record_items:\r\n            record = record_item.record()\r\n            if record is None:\r\n                continue\r\n            \r\n            repro = '%s(%s)' % (record.schema().name(), record.primaryKey())\r\n            record_data.append(repro)\r\n        \r\n        if not record_data:\r\n            return\r\n        \r\n        record_data = ';'.join(record_data)\r\n        mimeData.setData('application/x-orb-records', QByteArray(record_data))\r\n        \r\n        # store the associated mime data for the individual record\r\n        if len(record_items) == 1:\r\n            for format, value in record_items[0].dragData().items():\r\n                mimeData.setData(format, QByteArray(value))", "response": "Adds the records to the inputed mime data as a text representation of the records in the individual record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setChecked(self, state):\r\n        super(XLockButton, self).setChecked(state)\r\n        self.updateState()", "response": "Sets whether or not this button is in its locked state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updateState(self):\r\n        if self.isChecked():\r\n            self.setIcon(self.lockIcon())\r\n            self.setToolTip('Click to unlock')\r\n        else:\r\n            self.setIcon(self.unlockIcon())\r\n            self.setToolTip('Click to lock')", "response": "Updates the icon for this lock button based on its check state."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_change_form(self, request, context, **kwargs):\n        form = context['adminform'].form\n\n        # infer correct data from the form\n        fieldsets = [(None, {'fields': form.fields.keys()})]\n        adminform = helpers.AdminForm(form, fieldsets,\n                                      self.prepopulated_fields)\n        media = mark_safe(self.media + adminform.media)\n\n        context.update(adminform=adminform, media=media)\n\n        super_meth = super(BaseEntityAdmin, self).render_change_form\n        return super_meth(request, context, **kwargs)", "response": "Wrapper for ModelAdmin. render_change_form. Replaces standard static\n        AdminForm with an EAV - friendly one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gevent_run(app, port=5000, log=None, error_log=None, address='',\n               monkey_patch=True, start=True, **kwargs):  # pragma: no cover\n    \"\"\"Run your app in gevent.wsgi.WSGIServer\n\n    :param app: wsgi application, ex. Microservice instance\n    :param port: int, listen port, default 5000\n    :param address: str, listen address, default: \"\"\n    :param log: logger instance, default app.logger\n    :param error_log: logger instance, default app.logger\n    :param monkey_patch: boolean, use gevent.monkey.patch_all() for patching standard modules, default: True\n    :param start: boolean, if True, server will be start (server.serve_forever())\n    :param kwargs: other params for WSGIServer(**kwargs)\n    :return: server\n    \"\"\"\n    if log is None:\n        log = app.logger\n    if error_log is None:\n        error_log = app.logger\n    if monkey_patch:\n        from gevent import monkey\n\n        monkey.patch_all()\n\n    from gevent.wsgi import WSGIServer\n    http_server = WSGIServer((address, port), app, log=log, error_log=error_log,\n                             **kwargs)\n    if start:\n        http_server.serve_forever()\n    return http_server", "response": "Run your app in gevent. wsgi. WSGIServer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tornado_run(app, port=5000, address=\"\", use_gevent=False, start=True,\n                monkey_patch=None, Container=None,\n                Server=None, threadpool=None):  # pragma: no cover\n    \"\"\"Run your app in one tornado event loop process\n\n    :param app: wsgi application, Microservice instance\n    :param port: port for listen, int, default: 5000\n    :param address: address for listen, str, default: \"\"\n    :param use_gevent: if True, app.wsgi will be run in gevent.spawn\n    :param start: if True, will be call utils.tornado_start()\n    :param Container: your class, bases on tornado.wsgi.WSGIContainer, default: tornado.wsgi.WSGIContainer\n    :param monkey_patch: boolean, use gevent.monkey.patch_all() for patching standard modules, default: use_gevent\n    :param Server: your class, bases on tornado.httpserver.HTTPServer, default: tornado.httpserver.HTTPServer\n    :return: tornado server\n    \"\"\"\n    if Container is None:\n        from tornado.wsgi import WSGIContainer\n        Container = WSGIContainer\n\n    if Server is None:\n        from tornado.httpserver import HTTPServer\n        Server = HTTPServer\n\n    if monkey_patch is None:\n        monkey_patch = use_gevent\n\n    CustomWSGIContainer = Container\n\n    if use_gevent:\n        if monkey_patch:\n            from gevent import monkey\n            monkey.patch_all()\n\n        import gevent\n\n        class GeventWSGIContainer(Container):\n            def __call__(self, *args, **kwargs):\n                def async_task():\n                    super(GeventWSGIContainer, self).__call__(*args, **kwargs)\n\n                gevent.spawn(async_task)\n\n        CustomWSGIContainer = GeventWSGIContainer\n\n    if threadpool is not None:\n        from multiprocessing.pool import ThreadPool\n\n        if not isinstance(threadpool, ThreadPool):\n            threadpool = ThreadPool(threadpool)\n\n        class ThreadPoolWSGIContainer(Container):\n            def __call__(self, *args, **kwargs):\n                def async_task():\n                    super(ThreadPoolWSGIContainer, self).__call__(*args, **kwargs)\n\n                threadpool.apply_async(async_task)\n\n        CustomWSGIContainer = ThreadPoolWSGIContainer\n\n    http_server = Server(CustomWSGIContainer(app))\n    http_server.listen(port, address)\n    if start:\n        tornado_start()\n    return http_server", "response": "Run your app in one tornado event loop"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tornado_combiner(configs, use_gevent=False, start=True, monkey_patch=None,\n                     Container=None, Server=None, threadpool=None):  # pragma: no cover\n    \"\"\"Combine servers in one tornado event loop process\n\n    :param configs: [\n        {\n            'app': Microservice Application or another wsgi application, required\n            'port': int, default: 5000\n            'address': str, default: \"\"\n        },\n        { ... }\n    ]\n    :param use_gevent: if True, app.wsgi will be run in gevent.spawn\n    :param start: if True, will be call utils.tornado_start()\n    :param Container: your class, bases on tornado.wsgi.WSGIContainer, default: tornado.wsgi.WSGIContainer\n    :param Server: your class, bases on tornado.httpserver.HTTPServer, default: tornado.httpserver.HTTPServer\n    :param monkey_patch: boolean, use gevent.monkey.patch_all() for patching standard modules, default: use_gevent\n    :return: list of tornado servers\n    \"\"\"\n    servers = []\n    if monkey_patch is None:\n        monkey_patch = use_gevent\n\n    if use_gevent:\n        if monkey_patch:\n            from gevent import monkey\n            monkey.patch_all()\n\n    if threadpool is not None:\n        from multiprocessing.pool import ThreadPool\n\n        if not isinstance(threadpool, ThreadPool):\n            threadpool = ThreadPool(threadpool)\n\n    for config in configs:\n        app = config['app']\n        port = config.get('port', 5000)\n        address = config.get('address', '')\n        server = tornado_run(app, use_gevent=use_gevent, port=port,\n                             monkey_patch=False, address=address, start=False,\n                             Container=Container,\n                             Server=Server, threadpool=threadpool)\n        servers.append(server)\n    if start:\n        tornado_start()\n    return servers", "response": "Combine servers in one tornado event loop."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_fax(self, fax_id, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.delete_fax_with_http_info(fax_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.delete_fax_with_http_info(fax_id, **kwargs)  # noqa: E501\n            return data", "response": "Delete a specific fax record by providing its id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a specific fax record", "response": "def get_fax(self, fax_id, **kwargs):  # noqa: E501\n        \"\"\"Get a fax record  # noqa: E501\n\n        Get a specific fax record details like duration, pages etc.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.get_fax(fax_id, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str fax_id: (required)\n        :return: Fax\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_fax_with_http_info(fax_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.get_fax_with_http_info(fax_id, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist all the fax records for a user.", "response": "def list_faxes(self, user_id, **kwargs):  # noqa: E501\n        \"\"\"Get fax records  # noqa: E501\n\n        With this API call you will be able to retrieve a collection of faxes (either sent or received or spam based on the category selected). If you want to filter your archive please provide the `category` parameter  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.list_faxes(user_id, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str user_id: 'self' or user id of a corporate member (required)\n        :param str category: Category parameter can be one of these values: **inbox**, **sent**, **spam**\n        :param str after: Start date to get records from that date\n        :param str before: End date to get records before that date\n        :param int limit: Limit of fax records you want to get per request\n        :return: ResponseArchive\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.list_faxes_with_http_info(user_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.list_faxes_with_http_info(user_id, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating a specific fax record.", "response": "def update_fax(self, fax_id, payload_fax_modification, **kwargs):  # noqa: E501\n        \"\"\"Modify fax record  # noqa: E501\n\n        You can modify a fax record's comment or mark it as read  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.update_fax(fax_id, payload_fax_modification, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str fax_id: (required)\n        :param PayloadFaxModification payload_fax_modification: (required)\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.update_fax_with_http_info(fax_id, payload_fax_modification, **kwargs)  # noqa: E501\n        else:\n            (data) = self.update_fax_with_http_info(fax_id, payload_fax_modification, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ReadDictionary(self, file):\n\n        fil = dictfile.DictFile(file)\n\n        state = {}\n        state['vendor'] = ''\n\n        self.defer_parse = []\n        for line in fil:\n            state['file'] = fil.File()\n            state['line'] = fil.Line()\n            line = line.split('#', 1)[0].strip()\n\n            tokens = line.split()\n            if not tokens:\n                continue\n\n            key = tokens[0].upper()\n            if key == 'ATTRIBUTE':\n                self.__ParseAttribute(state, tokens)\n            elif key == 'VALUE':\n                self.__ParseValue(state, tokens, True)\n            elif key == 'VENDOR':\n                self.__ParseVendor(state, tokens)\n            elif key == 'BEGIN-VENDOR':\n                self.__ParseBeginVendor(state, tokens)\n            elif key == 'END-VENDOR':\n                self.__ParseEndVendor(state, tokens)\n\n        for state, tokens in self.defer_parse:\n            key = tokens[0].upper()\n            if key == 'VALUE':\n                self.__ParseValue(state, tokens, False)\n        self.defer_parse = []", "response": "Reads a RADIUS dictionary file and merges its contents into a single object containing the class instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chartItems(self):\r\n        from projexui.widgets.xchartwidget import XChartWidgetItem\r\n        return filter(lambda x: isinstance(x, XChartWidgetItem), self.items())", "response": "Returns a list of all chart items that are in this scene."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw the background for the different chart types.", "response": "def drawBackground( self, painter, rect ):\r\n        \"\"\"\r\n        Draws the backgrounds for the different chart types.\r\n        \r\n        :param      painter | <QPainter>\r\n                    rect    | <QRect>\r\n        \"\"\"\r\n        if ( self._dirty ):\r\n            self.rebuild()\r\n        \r\n        if ( self.showGrid() ):\r\n            self.drawGrid(painter)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing the grid for this scene.", "response": "def drawGrid( self, painter ):\r\n        \"\"\"\r\n        Draws the rulers for this scene.\r\n        \r\n        :param      painter | <QPainter>\r\n        \"\"\"\r\n        # draw the minor grid lines\r\n        pen = QPen(self.borderColor())\r\n        painter.setPen(pen)\r\n        painter.setBrush(self.baseColor())\r\n        \r\n        # draw the grid data\r\n        painter.drawRect(self._buildData['grid_rect'])\r\n        \r\n        painter.setBrush(self.alternateColor())\r\n        painter.setPen(Qt.NoPen)\r\n        \r\n        if ( self.alternatingRowColors() ):\r\n            for alt_rect in self._buildData['grid_h_alt']:\r\n                painter.drawRect(alt_rect)\r\n        \r\n        if ( self.alternatingColumnColors() ):\r\n            for alt_rect in self._buildData['grid_v_alt']:\r\n                painter.drawRect(alt_rect)\r\n        \r\n        if ( self.showGrid() ):\r\n            painter.setPen(pen)\r\n            \r\n            grid = []\r\n            if ( self.showRows() ):\r\n                grid += self._buildData['grid_h_lines']\r\n            \r\n            if ( self.showColumns() ):\r\n                grid += self._buildData['grid_v_lines']\r\n            \r\n            painter.drawLines(grid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing the axis for this system.", "response": "def drawAxis( self, painter ):\r\n        \"\"\"\r\n        Draws the axis for this system.\r\n        \"\"\"\r\n        # draw the axis lines\r\n        pen = QPen(self.axisColor())\r\n        pen.setWidth(4)\r\n        painter.setPen(pen)\r\n        painter.drawLines(self._buildData['axis_lines'])\r\n        \r\n        # draw the notches\r\n        for rect, text in self._buildData['grid_h_notches']:\r\n            painter.drawText(rect, Qt.AlignTop | Qt.AlignRight, text)\r\n        \r\n        for rect, text in self._buildData['grid_v_notches']:\r\n            painter.drawText(rect, Qt.AlignCenter, text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntoggling the display for the tracker item.", "response": "def enterEvent( self, event ):\r\n        \"\"\"\r\n        Toggles the display for the tracker item.\r\n        \"\"\"\r\n        item = self.trackerItem()\r\n        if ( item ):\r\n            item.setVisible(True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the object and event are modified.", "response": "def eventFilter( self, object, event ):\r\n        \"\"\"\r\n        Filters the chart widget for the resize event to modify this scenes\r\n        rect.\r\n        \r\n        :param      object | <QObject>\r\n                    event | <QEvent>\r\n        \"\"\"\r\n        if ( event.type() != event.Resize ):\r\n            return False\r\n        \r\n        size     = event.size()\r\n        w        = size.width()\r\n        h        = size.height()\r\n        hpolicy  = Qt.ScrollBarAlwaysOff\r\n        vpolicy  = Qt.ScrollBarAlwaysOff\r\n        \r\n        if ( self._minimumHeight != -1 and h < self._minimumHeight ):\r\n            h      = self._minimumHeight\r\n            vpolicy = Qt.ScrollBarAsNeeded\r\n            \r\n        if ( self._maximumHeight != -1 and self._maximumHeight < h ):\r\n            h      = self._maximumHeight\r\n            vpolicy = Qt.ScrollBarAsNeeded\r\n        \r\n        if ( self._minimumWidth != -1 and w < self._minimumWidth ):\r\n            w      = self._minimumWidth\r\n            hpolicy = Qt.ScrollBarAsNeeded\r\n            \r\n        if ( self._maximumWidth != -1 and self._maximumWidth < w ):\r\n            w      = self._maximumWidth\r\n            hpolicy = Qt.ScrollBarAsNeeded\r\n        \r\n        hruler = self.horizontalRuler()\r\n        vruler = self.verticalRuler()\r\n        \r\n        hlen = hruler.minLength(Qt.Horizontal)\r\n        vlen = hruler.minLength(Qt.Vertical)\r\n        \r\n        offset_w = 0\r\n        offset_h = 0\r\n        \r\n#        if ( hlen > w ):\r\n#            w        = hlen\r\n#            hpolicy  = Qt.ScrollBarAlwaysOn\r\n#            offset_h = 25\r\n#        \r\n#        if ( vlen > h ):\r\n#            h        = vlen\r\n#            vpolicy  = Qt.ScrollBarAlwaysOn\r\n#            offset_w = 25\r\n        \r\n        self.setSceneRect(0, 0, w - offset_w, h - offset_h)\r\n        object.setVerticalScrollBarPolicy(vpolicy)\r\n        object.setHorizontalScrollBarPolicy(hpolicy)\r\n        \r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef leaveEvent( self, event ):\r\n        item = self.trackerItem()\r\n        if ( item ):\r\n            item.setVisible(False)", "response": "Toggles the display for the tracker item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmapping a chart point to a pixel position within the grid.", "response": "def mapFromChart( self, x, y ):\r\n        \"\"\"\r\n        Maps a chart point to a pixel position within the grid based on the\r\n        rulers.\r\n        \r\n        :param      x | <variant>\r\n                    y | <variant>\r\n        \r\n        :return     <QPointF>\r\n        \"\"\"\r\n        grid      = self.gridRect()\r\n        hruler    = self.horizontalRuler()\r\n        vruler    = self.verticalRuler()\r\n        \r\n        xperc     = hruler.percentAt(x)\r\n        yperc     = vruler.percentAt(y)\r\n        \r\n        xoffset   = grid.width() * xperc\r\n        yoffset   = grid.height() * yperc\r\n        \r\n        xpos      = grid.left() + xoffset\r\n        ypos      = grid.bottom() - yoffset\r\n        \r\n        return QPointF(xpos, ypos)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the current position of the item in the tracker.", "response": "def mouseMoveEvent( self, event ):\r\n        \"\"\"\r\n        Overloads the moving event to move the tracker item.\r\n        \r\n        :param      event | <QEvent>\r\n        \"\"\"\r\n        super(XChartScene, self).mouseMoveEvent(event)\r\n        \r\n        self.updateTrackerItem(event.scenePos())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rebuild( self ):\r\n        global XChartWidgetItem\r\n        if ( XChartWidgetItem is None ):\r\n            from projexui.widgets.xchartwidget.xchartwidgetitem \\\r\n            import XChartWidgetItem\r\n        \r\n        self._buildData = {}\r\n        \r\n        # build the grid location\r\n        x      = 8\r\n        y      = 8\r\n        w      = self.sceneRect().width()\r\n        h      = self.sceneRect().height()\r\n        hpad   = self.horizontalPadding()\r\n        vpad   = self.verticalPadding()\r\n        hmax   = self.horizontalRuler().maxNotchSize(Qt.Horizontal)\r\n        \r\n        left_offset   = hpad + self.verticalRuler().maxNotchSize(Qt.Vertical)\r\n        right_offset  = left_offset + hpad\r\n        top_offset    = vpad\r\n        bottom_offset = top_offset + vpad + hmax\r\n        \r\n        left    = x + left_offset\r\n        right   = w - right_offset\r\n        top     = y + top_offset\r\n        bottom  = h - bottom_offset\r\n        \r\n        rect = QRectF()\r\n        rect.setLeft(left)\r\n        rect.setRight(right)\r\n        rect.setBottom(bottom)\r\n        rect.setTop(top)\r\n        \r\n        self._buildData['grid_rect'] = rect\r\n        \r\n        # rebuild the ruler data\r\n        self.rebuildGrid()\r\n        self._dirty = False\r\n        \r\n        # rebuild all the items\r\n        padding  = self.horizontalPadding() + self.verticalPadding()\r\n        grid     = self.sceneRect()\r\n        filt     = lambda x: isinstance(x, XChartWidgetItem)\r\n        items    = filter(filt, self.items())\r\n        height   = float(grid.height())\r\n        if height == 0:\r\n            ratio = 1\r\n        else:\r\n            ratio = grid.width() / height\r\n        count    = len(items)\r\n        \r\n        if ( not count ):\r\n            return\r\n        \r\n        if ( ratio >= 1 ):\r\n            radius   = (grid.height() - padding * 2) / 2.0\r\n            x        = rect.center().x()\r\n            y        = rect.center().y()\r\n            dx       = radius * 2.5\r\n            dy       = 0\r\n        else:\r\n            radius   = (grid.width() - padding * 2) / 2.0\r\n            x        = rect.center().x()\r\n            y        = rect.center().y()\r\n            dx       = 0\r\n            dy       = radius * 2.5\r\n        \r\n        for item in items:\r\n            item.setPieCenter(QPointF(x, y))\r\n            item.setRadius(radius)\r\n            item.rebuild()\r\n            \r\n            x += dx\r\n            y += dy\r\n        \r\n        if ( self._trackerItem and self._trackerItem() ):\r\n            self._trackerItem().rebuild(self._buildData['grid_rect'])", "response": "Rebuilds the data for this scene."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrebuilds the grid data.", "response": "def rebuildGrid( self ):\r\n        \"\"\"\r\n        Rebuilds the ruler data.\r\n        \"\"\"\r\n        vruler = self.verticalRuler()\r\n        hruler = self.horizontalRuler()\r\n        \r\n        rect   = self._buildData['grid_rect']\r\n        \r\n        # process the vertical ruler\r\n        h_lines     = []\r\n        h_alt       = []\r\n        h_notches   = []\r\n        \r\n        vpstart  = vruler.padStart()\r\n        vnotches = vruler.notches()\r\n        vpend    = vruler.padEnd()\r\n        vcount   = len(vnotches) + vpstart + vpend\r\n        deltay   = rect.height() / max((vcount - 1), 1)\r\n        y        = rect.bottom()\r\n        alt      = False\r\n        \r\n        for i in range(vcount):\r\n            h_lines.append(QLineF(rect.left(), y, rect.right(), y))\r\n            \r\n            # store alternate color\r\n            if ( alt ):\r\n                alt_rect = QRectF(rect.left(), y, rect.width(), deltay)\r\n                h_alt.append(alt_rect)\r\n            \r\n            # store notch information\r\n            nidx = i - vpstart\r\n            if ( 0 <= nidx and nidx < len(vnotches) ):\r\n                notch = vnotches[nidx]\r\n                notch_rect = QRectF(0, y - 3, rect.left() - 3, deltay)\r\n                h_notches.append((notch_rect, notch))\r\n            \r\n            y -= deltay\r\n            alt = not alt\r\n        \r\n        self._buildData['grid_h_lines']     = h_lines\r\n        self._buildData['grid_h_alt']       = h_alt\r\n        self._buildData['grid_h_notches']   = h_notches\r\n        \r\n        # process the horizontal ruler\r\n        v_lines     = []\r\n        v_alt       = []\r\n        v_notches   = []\r\n        \r\n        hpstart     = hruler.padStart()\r\n        hnotches    = hruler.notches()\r\n        hpend       = hruler.padEnd()\r\n        hcount      = len(hnotches) + hpstart + hpend\r\n        deltax      = rect.width() / max((hcount - 1), 1)\r\n        x           = rect.left()\r\n        alt         = False\r\n        \r\n        for i in range(hcount):\r\n            v_lines.append(QLineF(x, rect.top(), x, rect.bottom()))\r\n            \r\n            # store alternate info\r\n            if ( alt ):\r\n                alt_rect = QRectF(x - deltax, rect.top(), deltax, rect.height())\r\n                v_alt.append(alt_rect)\r\n            \r\n            # store notch information\r\n            nidx = i - hpstart\r\n            if ( 0 <= nidx and nidx < len(hnotches) ):\r\n                notch = hnotches[nidx]\r\n                notch_rect = QRectF(x - (deltax / 2.0), \r\n                                    rect.bottom() + 3, \r\n                                    deltax, \r\n                                    13)\r\n                v_notches.append((notch_rect, notch))\r\n            \r\n            x += deltax\r\n            alt = not alt\r\n        \r\n        self._buildData['grid_v_lines']     = v_lines\r\n        self._buildData['grid_v_alt']       = v_alt\r\n        self._buildData['grid_v_notches']   = v_notches\r\n        \r\n        # draw the axis lines\r\n        axis_lines = []\r\n        axis_lines.append(QLineF(rect.left(), \r\n                                 rect.top(), \r\n                                 rect.left(), \r\n                                 rect.bottom()))\r\n                                 \r\n        axis_lines.append(QLineF(rect.left(), \r\n                                 rect.bottom(), \r\n                                 rect.right(), \r\n                                 rect.bottom()))\r\n        \r\n        self._buildData['axis_lines'] = axis_lines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the chart type for this scene.", "response": "def setChartType( self, chartType ):\r\n        \"\"\"\r\n        Sets the chart type for this scene to the inputed type.\r\n        \r\n        :param      chartType | <XChartScene.Type>\r\n        \"\"\"\r\n        self._chartType = chartType\r\n        self.setDirty()\r\n        \r\n        # setup default options\r\n        if ( chartType == XChartScene.Type.Pie ):\r\n            self.setShowGrid(False)\r\n            \r\n            self.horizontalRuler().setPadStart(0)\r\n            self.horizontalRuler().setPadEnd(0)\r\n            \r\n        elif ( chartType == XChartScene.Type.Bar ):\r\n            self.setShowGrid(True)\r\n            self.setShowColumns(False)\r\n            self.setShowRows(True)\r\n            \r\n            self.horizontalRuler().setPadStart(1)\r\n            self.horizontalRuler().setPadEnd(1)\r\n            \r\n        else:\r\n            self.setShowGrid(True)\r\n            self.setShowColumns(True)\r\n            self.setShowRows(True)\r\n            \r\n            self.horizontalRuler().setPadStart(0)\r\n            self.horizontalRuler().setPadEnd(0)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.chartTypeChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setSceneRect( self, *args ):\r\n        super(XChartScene, self).setSceneRect(*args)\r\n        self._dirty = True", "response": "Sets the rect of the current scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trackerItem( self ):\r\n        # check for the tracking enabled state\r\n        if not self.isTrackingEnabled():\r\n            return None\r\n        \r\n        # generate a new tracker item\r\n        if not (self._trackerItem and self._trackerItem()):\r\n            item = XChartTrackerItem()\r\n            self.addItem(item)\r\n            self._trackerItem = weakref.ref(item)\r\n        \r\n        return self._trackerItem()", "response": "Returns the first tracker item for this chart or None if there is no tracker item for this chart."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef updateTrackerItem( self, point = None ):\r\n        item = self.trackerItem()\r\n        if not item:\r\n            return\r\n        \r\n        gridRect = self._buildData.get('grid_rect')\r\n        \r\n        if ( not (gridRect and gridRect.isValid()) ):\r\n            item.setVisible(False)\r\n            return\r\n        \r\n        if ( point is not None ):\r\n            item.setPos(point.x(), gridRect.top())\r\n        \r\n        if ( not gridRect.contains(item.pos()) ):\r\n            item.setVisible(False)\r\n            return\r\n        \r\n        if ( self.chartType() != self.Type.Line ):\r\n            item.setVisible(False)\r\n            return\r\n        \r\n        if ( not self.isTrackingEnabled() ):\r\n            item.setVisible(False)\r\n            return\r\n        \r\n        item.rebuild(gridRect)", "response": "Updates the tracker item information."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the value at the given point.", "response": "def valueAt( self, point ):\r\n        \"\"\"\r\n        Returns the X, Y value for the given point.\r\n        \r\n        :param      point | <QPoint>\r\n        \r\n        :return     (<variant> x, <variant> y)\r\n        \"\"\"\r\n        x = point.x()\r\n        y = point.y()\r\n        \r\n        hruler = self.horizontalRuler()\r\n        vruler = self.verticalRuler()\r\n        \r\n        grid   = self._buildData.get('grid_rect')\r\n        if ( not grid ):\r\n            return (None, None)\r\n        \r\n        x_perc = 1 - ((grid.right() - x) / grid.width())\r\n        y_perc = ((grid.bottom() - y) / grid.height())\r\n        \r\n        return (hruler.valueAt(x_perc), vruler.valueAt(y_perc))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initialize( self ):\n        if ( self._initialized ):\n            return True\n        \n        self._initialized = True\n        \n        # load the item's children\n        model = self.model()\n        signalsBlocked = False\n        if ( model ):\n            signalsBlocked = model.signalsBlocked()\n            model.blockSignals(True)\n            \n        state = self.loadContext()\n        \n        if ( model ):\n            model.blockSignals(signalsBlocked)\n        \n        return state", "response": "Initializes the item data for each tree level."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the path for the inputed item based on its hierarchy.", "response": "def itemPath( self, item ):\n        \"\"\"\n        Returns the path for the inputed item based on its hierarchy.\n        \n        :return     <str>\n        \"\"\"\n        path = []\n        while ( item ):\n            path.insert(0, nativestring(item.text()))\n            item = item.parent()\n        \n        sep = self.separator()\n        return sep + sep.join(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef itemByPath( self, path, includeRoot = False ):\n        sep     = self.separator()\n        path    = nativestring(path).strip(sep)\n        if ( not path ):\n            if ( includeRoot ):\n                return self.invisibleRootItem()\n            else:\n                return None\n            \n        splt    = path.split(sep)\n        item    = self.invisibleRootItem()\n        for part in splt:\n            next_item = None\n            for row in range(item.rowCount()):\n                child = item.child(row)\n                if ( child.text() == part ):\n                    next_item = child\n                    break\n            \n            if ( not next_item ):\n                item = None\n                break\n                \n            item = next_item\n            item.initialize()\n        \n        return item", "response": "Loads the items for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the root items for this model to the inputed items.", "response": "def setTopLevelItems( self, items ):\n        \"\"\"\n        Sets the root item for this model to the inputed item.\n        \n        :param      item | <XNavigationItem>\n        \"\"\"\n        self.blockSignals(True)\n        \n        root = self.invisibleRootItem()\n        for row in range(root.rowCount()):\n            root.takeRow(row)\n        \n        for item in items:\n            root.appendRow(item)\n            \n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the full path from the inputed index on.", "response": "def pathFromIndex( self, index ):\n        \"\"\"\n        Returns the full path from the inputed index on.\n        \n        :param      index | <QModelIndex>\n        \n        :return     <str>\n        \"\"\"\n        item = self.model().itemFromIndex(index)\n        return self.model().itemPath(item)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsplit the path into its components.", "response": "def splitPath( self, path ):\n        \"\"\"\n        Splits the path into its components.\n        \n        :param      path | <str>\n        \n        :return     [<str>, ..]\n        \"\"\"\n        sep = self.model().separator()\n        splt = nativestring(path).lstrip(sep).split(sep)\n        \n        if ( splt and not splt[-1] ):\n            self.model().itemByPath(path)\n            \n        return splt"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef acceptEdit( self ):\n        \n        if ( self._partsWidget.isVisible() ):\n            return False\n        \n        use_completion = self.completer().popup().isVisible()\n        completion     = self.completer().currentCompletion()\n        \n        self._completerTree.hide()\n        self.completer().popup().hide()\n        \n        if ( use_completion ):\n            self.setText(completion)\n        else:\n            self.rebuild()\n            \n        return True", "response": "Accepts the current text and rebuilds the parts widget. Returns True if the text is accepted False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cancelEdit( self ):\n        \n        if ( self._partsWidget.isVisible() ):\n            return False\n            \n        self._completerTree.hide()\n        self.completer().popup().hide()\n        \n        self.setText(self._originalText)\n        return True", "response": "Cancels the current edit and shows the parts widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef currentItem( self ):\n        model = self.navigationModel()\n        if ( not model ):\n            return None\n        \n        return model.itemByPath(self.text())", "response": "Returns the current item from the current path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter the events for the inputed object through this edit.", "response": "def eventFilter( self, object, event ):\n        \"\"\"\n        Filters the events for the inputed object through this edit.\n        \n        :param      object | <QObject>\n                    event  | <QEvent>\n        \n        :return     <bool> | consumed\n        \"\"\"\n        if ( event.type() == event.KeyPress ):\n            if ( event.key() == Qt.Key_Escape ):\n                self._completerTree.hide()\n                self.completer().popup().hide()\n                \n                self.cancelEdit()\n                \n            elif ( event.key() in (Qt.Key_Return, Qt.Key_Enter) ):\n                self.acceptEdit()\n                return True\n                \n            elif ( event.key() == Qt.Key_Tab ):\n                if ( self.completer().popup().isVisible() ):\n                    text   = nativestring(self.completer().currentCompletion())\n                    super(XNavigationEdit, self).setText(text)\n                    return True\n                else:\n                    self.acceptEdit()\n                    return False\n            \n        elif ( event.type() == event.MouseButtonPress ):\n            if ( not self._completerTree.rect().contains(event.pos()) ):\n                self._completerTree.hide()\n                self.completer().popup().hide()\n                \n                self.cancelEdit()\n        \n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef focusOutEvent( self, event ):\n        super(XNavigationEdit, self).focusOutEvent(event)\n        \n        self.cancelEdit()", "response": "Cancel editing when the focus out event is pressed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handleButtonClick( self, button ):\n        path            = button.property('path')\n        is_completer    = button.property('is_completer')\n        \n        # popup a completion menu\n        if ( unwrapVariant(is_completer) ):\n            model = self.navigationModel()\n            if ( not model ):\n                return\n            \n            sep  = self.separator()\n            path = nativestring(unwrapVariant(path))\n            item = model.itemByPath(path, includeRoot = True)\n            if ( not item ):\n                return\n            \n            curr_path = nativestring(self.text()).strip(self.separator())\n            curr_path = curr_path.replace(path, '').strip(self.separator())\n            \n            child_name = ''\n            if ( curr_path ):\n                child_name = curr_path.split(self.separator())[0]\n            \n            index = model.indexFromItem(item)\n            \n            self._completerTree.move(QCursor.pos())\n            self._completerTree.setRootIndex(index)\n            self._completerTree.verticalScrollBar().setValue(0)\n            \n            if ( child_name ):\n                child_item = None\n                for i in range(item.rowCount()):\n                    child = item.child(i)\n                    if ( child.text() == child_name ):\n                        child_item = child\n                        break\n                \n                if ( child_item ):\n                    child_index = model.indexFromItem(child_item)\n                    self._completerTree.setCurrentIndex(child_index)\n                    self._completerTree.scrollTo(child_index)\n            \n            self._completerTree.show()\n            self._completerTree.setUpdatesEnabled(True)\n        else:\n            self.setText(unwrapVariant(path))", "response": "Handles the event when a user clicks on one of the part buttons."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling the key press event for the current item.", "response": "def keyPressEvent( self, event ):\n        \"\"\"\n        Overloads the key press event to listen for escape calls to cancel the\n        parts editing.\n        \n        :param      event | <QKeyPressEvent>\n        \"\"\"\n        if ( self.scrollWidget().isHidden() ):\n            if ( event.key() == Qt.Key_Escape ):\n                self.cancelEdit()\n                return\n                \n            elif ( event.key() in (Qt.Key_Return, Qt.Key_Enter) ):\n                self.acceptEdit()\n                return\n            \n        elif ( event.key() == Qt.Key_A and \n               event.modifiers() == Qt.ControlModifier ):\n            self.startEdit()\n        \n        super(XNavigationEdit, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nenables editing when a user double clicks on the navigation.", "response": "def mouseDoubleClickEvent( self, event ):\n        \"\"\"\n        Overloads the system to enable editing when a user double clicks.\n        \n        :param      event | <QMouseEvent>\n        \"\"\"\n        super(XNavigationEdit, self).mouseDoubleClickEvent(event)\n        \n        self.startEdit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnavigating to the inputed action s path.", "response": "def navigateToIndex( self, index ):\n        \"\"\"\n        Navigates to the inputed action's path.\n        \n        :param      action | <QAction>\n        \"\"\"\n        self._completerTree.hide()\n        item = self._navigationModel.itemFromIndex(index)\n        self.setText(self._navigationModel.itemPath(item))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parts( self ):\n        path = nativestring(self.text()).strip(self.separator())\n        if ( not path ):\n            return []\n        return path.split(self.separator())", "response": "Returns the parts that are used for this system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrebuilds the pathing based on the parts of the text and selects the parts.", "response": "def startEdit( self ):\n        \"\"\"\n        Rebuilds the pathing based on the parts.\n        \"\"\"\n        self._originalText = self.text()\n        self.scrollWidget().hide()\n        self.setFocus()\n        self.selectAll()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrebuilding the parts widget with the latest text.", "response": "def rebuild( self ):\n        \"\"\"\n        Rebuilds the parts widget with the latest text.\n        \"\"\"\n        navitem = self.currentItem()\n        if ( navitem ):\n            navitem.initialize()\n            \n        self.setUpdatesEnabled(False)\n        self.scrollWidget().show()\n        self._originalText = ''\n        \n        partsw = self.partsWidget()\n        for button in self._buttonGroup.buttons():\n            self._buttonGroup.removeButton(button)\n            button.close()\n            button.setParent(None)\n            button.deleteLater()\n        \n        # create the root button\n        layout = partsw.layout()\n        parts  = self.parts()\n        \n        button = QToolButton(partsw)\n        button.setAutoRaise(True)\n        button.setMaximumWidth(12)\n        button.setArrowType(Qt.RightArrow)\n        \n        button.setProperty('path',          wrapVariant(''))\n        button.setProperty('is_completer',  wrapVariant(True))\n        last_button = button\n            \n        self._buttonGroup.addButton(button)\n        layout.insertWidget(0, button)\n        \n        # check to see if we have a navigation model setup\n        if ( self._navigationModel ):\n            last_item = self._navigationModel.itemByPath(self.text())\n            show_last =  last_item and last_item.rowCount() > 0\n        else:\n            show_last = False\n        \n        # load the navigation system\n        count = len(parts)\n        for i, part in enumerate(parts):\n            path = self.separator().join(parts[:i+1])\n            \n            button = QToolButton(partsw)\n            button.setAutoRaise(True)\n            button.setText(part)\n            \n            if ( self._navigationModel ):\n                item = self._navigationModel.itemByPath(path)\n                if ( item ):\n                    button.setIcon(item.icon())\n                    button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)\n            \n            button.setProperty('path',         wrapVariant(path))\n            button.setProperty('is_completer', wrapVariant(False))\n            \n            self._buttonGroup.addButton(button)\n            layout.insertWidget((i * 2) + 1, button)\n            \n            # determine if we should show the final button\n            if ( show_last or i < (count - 1) ):\n                button = QToolButton(partsw)\n                button.setAutoRaise(True)\n                button.setMaximumWidth(12)\n                button.setArrowType(Qt.RightArrow)\n                \n                button.setProperty('path',          wrapVariant(path))\n                button.setProperty('is_completer',  wrapVariant(True))\n            \n                self._buttonGroup.addButton(button)\n                layout.insertWidget((i * 2) + 2, button)\n                \n                last_button = button\n        \n        if ( self.scrollWidget().width() < partsw.width() ):\n            self.scrollParts(partsw.width() - self.scrollWidget().width())\n            \n        self.setUpdatesEnabled(True)\n        self.navigationChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resizeEvent( self, event ):\n        super(XNavigationEdit, self).resizeEvent(event)\n        \n        w = self.width()\n        h = self.height()\n        \n        self._scrollWidget.resize(w - 4, h - 4)\n        \n        if ( self._scrollWidget.width() < self._partsWidget.width() ):\n           self.scrollParts( self._partsWidget.width() - self._scrollWidget.width() )", "response": "Resizes the current widget and its parts widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scrollParts( self, amount ):\n        change = self._scrollAmount - amount\n        self._partsWidget.scroll(change, 0)\n        self._scrollAmount = amount", "response": "Scrolls the parts to the specified amount."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the top level items of the navigation system.", "response": "def setTopLevelItems( self, items ):\n        \"\"\"\n        Initializes the navigation system to start with the inputed root \\\n        item.\n        \n        :param      item | <XNavigationItem>\n        \"\"\"\n        if ( not self._navigationModel ):\n            self.setNavigationModel(XNavigationModel(self))\n        \n        self._navigationModel.setTopLevelItems(items)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setNavigationModel( self, model ):\n        self._navigationModel = model\n        self._completerTree.setModel(model)\n        \n        if ( model ):\n            model.setSeparator(self.separator())\n            completer = XNavigationCompleter(model, self)\n            self.setCompleter(completer)\n            completer.popup().installEventFilter(self)\n        else:\n            self.setCompleter(None)\n        \n        self.rebuild()", "response": "Sets the navigation model for this edit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the path for this edit widget by providing the parts to the path.", "response": "def setParts( self, parts ):\n        \"\"\"\n        Sets the path for this edit widget by providing the parts to the path.\n        \n        :param      parts | [<str>, ..]\n        \"\"\"\n        self.setText(self.separator().join(map(str, parts)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setSeparator( self, separator ):\n        self._separator = separator\n        if ( self._navigationModel ):\n            self._navigationModel.setSeparator(separator)\n        self.rebuild()", "response": "Sets the separator to the inputed character."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setText( self, text ):\n        super(XNavigationEdit, self).setText(text)\n        \n        self.scrollWidget().show()\n        if ( text == '' or self._originalText != text ):\n            self.rebuild()", "response": "Sets the text for this edit to the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new instance of query_cls.", "response": "def query(self):\n        \"\"\"Return a new instance of query_cls.\"\"\"\n\n        if not hasattr(self, '_decoded_query'):\n            self._decoded_query = list(urls._url_decode_impl(\n                self.querystr.split('&'), 'utf-8', False, True, 'strict'))\n        return self.query_cls(self._decoded_query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, requirement):\n        if isinstance(requirement, basestring):\n            requirement = Requirement.parse(requirement)\n        return sorted(p for p in self.packages\n                      if requirement.name == p.name and requirement.match(p))", "response": "Find packages matching requirement."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds packages matching requirement.", "response": "def get(self, requirement):\n        \"\"\"Find packages matching ``requirement``.\n\n        :param requirement: Requirement to get from all underlying \\\n        repositories.\n        :type requirement: `str` or :class:`.Requirement`\n        :returns: :func:`list` of matching :class:`.Package` objects.\n\n        \"\"\"\n        if isinstance(requirement, basestring):\n            requirement = Requirement.parse(requirement)\n        packages = set()\n        for repository in self.repositories:\n            packages |= set(repository.get(requirement))\n        return sorted(packages)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the TransformRef to the child of this tag.", "response": "def add_child_ref(self, transform_ref):\n        \"\"\"\n        Adds the TransformRef if it is not already added.\n        :param transform_ref:\n        :return:\n        \"\"\"\n        if not isinstance(transform_ref, TransformRef):\n            raise ValueError(\"transform_ref must be of type TransformRef\")\n\n        for child in self.children:\n            if child is transform_ref:\n                return\n\n        transform_ref.parent = self\n        self.children.append(transform_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_child_ref(self, transform_path, child_id=None):\n        transform_ref = TransformRef(transform_path, child_id)\n        self.add_child_ref(transform_ref)\n        return transform_ref", "response": "Creates a new child TransformRef with transform_path specified."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a rendered transform path that is calculated from all parents.", "response": "def get_rendered_transform_path(self):\n        \"\"\"\n        Generates a rendered transform path\n        that is calculated from all parents.\n        :return:\n        \"\"\"\n        path = self.transform_path\n        parent = self.parent\n\n        while parent is not None:\n            path = \"{0}/{1}\".format(parent.transform_path, path)\n            parent = parent.parent\n\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a rendered transform path relative to the parent s transform path.", "response": "def get_rendered_transform_path_relative(self, relative_transform_ref):\n        \"\"\"\n        Generates a rendered transform path relative to\n        parent.\n        :param relative_transform_ref:\n        :return:\n        \"\"\"\n        path = self.transform_path\n        parent = self.parent\n\n        while parent is not None and parent is not relative_transform_ref:\n            path = \"{0}/{1}\".format(parent.transform_path, path)\n            parent = parent.parent\n\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrefreshes the ui for the current plugin.", "response": "def refreshUi( self ):\n        \"\"\"\n        Load the plugin information to the interface.\n        \"\"\"\n        dataSet = self.dataSet()\n        if not dataSet:\n            return False\n            \n        # lookup widgets based on the data set information\n        for widget in self.findChildren(QWidget):\n            prop = unwrapVariant(widget.property('dataName'))\n            if prop is None:\n                continue\n            \n            # update the data for the widget\n            prop_name = nativestring(prop)\n            if prop_name in dataSet:\n                value = dataSet.value(prop_name)\n                projexui.setWidgetValue(widget, value)\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reset( self ):\n        if not self.plugin():\n            return False\n        \n        self.plugin().reset()\n        self.refreshUi()\n        \n        return True", "response": "Resets the ui information to the default data for the widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the ui information to the data for this widget s data set.", "response": "def save( self ):\n        \"\"\"\n        Saves the ui information to the data for this widget's data set.\n        \n        :return     <bool> saved\n        \"\"\"\n        dataSet = self.dataSet()\n        if ( not dataSet ):\n            return True\n        \n        # lookup widgets based on the data set information\n        for widget in self.findChildren(QWidget):\n            prop = unwrapVariant(widget.property('dataName'))\n            if prop is None:\n                continue\n            \n            # update the data for the dataset\n            value, success = projexui.widgetValue(widget)\n            if not success:\n                continue\n                \n            dataSet.setValue(prop, value)\n        \n        return self.plugin().save()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef c2ln(c,l1,l2,n):\n    \"char[n] to two unsigned long???\"\n    c = c + n\n    l1, l2 = U32(0), U32(0)\n\n    f = 0\n    if n == 8:\n        l2 = l2 | (U32(c[7]) << 24)\n        f = 1\n    if f or (n == 7):\n        l2 = l2 | (U32(c[6]) << 16)\n        f = 1\n    if f or (n == 6):\n        l2 = l2 | (U32(c[5]) << 8)\n        f = 1\n    if f or (n == 5):\n        l2 = l2 | U32(c[4])\n        f = 1\n    if f or (n == 4):\n        l1 = l1 | (U32(c[3]) << 24)\n        f = 1\n    if f or (n == 3):\n        l1 = l1 | (U32(c[2]) << 16)\n        f = 1\n    if f or (n == 2):\n        l1 = l1 | (U32(c[1]) << 8)\n        f = 1\n    if f or (n == 1):\n        l1 = l1 | U32(c[0])\n    return (l1, l2)", "response": "char n to two unsigned long??"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef n2l(c, l):\n    \"network to host long\"\n    l = U32(c[0] << 24)\n    l = l | (U32(c[1]) << 16)\n    l = l | (U32(c[2]) << 8)\n    l = l | (U32(c[3]))\n    return l", "response": "network to host long"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhosting to network long", "response": "def l2n(l, c):\n    \"host to network long\"\n    c = []\n    c.append(int((l >> 24) & U32(0xFF)))\n    c.append(int((l >> 16) & U32(0xFF)))\n    c.append(int((l >>  8) & U32(0xFF)))\n    c.append(int((l      ) & U32(0xFF)))\n    return c"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        resp = self.post('start')\n\n        if resp.is_fail():\n            return None\n        if 'result' not in resp.data:\n            return None\n\n        result = resp.data['result']\n        return {\n            'user': result['user'],\n            'ws_host': result['ws_host'],\n        }", "response": "Gets the rtm ws_host and user information\n            Returns None if request failed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do(self,\n           resource,\n           method,\n           params=None,\n           data=None,\n           json=None,\n           headers=None):\n        \"\"\"Does the request job\n\n        Args:\n            resource(str): resource uri(relative path)\n            method(str): HTTP method\n            params(dict): uri queries\n            data(dict): HTTP body(form)\n            json(dict): HTTP body(json)\n            headers(dict): HTTP headers\n\n        Returns:\n            RTMResponse\n        \"\"\"\n        uri = \"{0}/{1}\".format(self._api_base, resource)\n        if not params:\n            params = {}\n        params.update({'token': self._token})\n\n        req = Request(\n            method=method,\n            url=uri,\n            params=params,\n            headers=headers,\n            data=data,\n            json=json)\n        s = Session()\n        prepped = s.prepare_request(req)\n        resp = s.send(prepped)\n\n        return RTMResponse(resp)", "response": "Does the request job\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, resource, params=None, headers=None):\n        return self.do(resource, 'GET', params=params, headers=headers)", "response": "Sends a GET request to obtain a specific resource from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post(self, resource, data=None, json=None):\n        return self.do(resource, 'POST', data=data, json=json)", "response": "Sends a POST request to the resource specified in the data parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef CollectMetrics(self, request, context):\n        LOG.debug(\"CollectMetrics called\")\n        try:\n            metrics_to_collect = []\n            for metric in request.metrics:\n                metrics_to_collect.append(Metric(pb=metric))\n            metrics_collected = self.plugin.collect(metrics_to_collect)\n            return MetricsReply(metrics=[m.pb for m in metrics_collected])\n        except Exception as err:\n            msg = \"message: {}\\n\\nstack trace: {}\".format(\n                err, traceback.format_exc())\n            return MetricsReply(metrics=[], error=msg)", "response": "Dispatches the request to the plugins collect method"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndispatches the request to the plugins get_config_policy method and returns the object that represents the current config policy.", "response": "def GetConfigPolicy(self, request, context):\n        \"\"\"Dispatches the request to the plugins get_config_policy method\"\"\"\n        try:\n            policy = self.plugin.get_config_policy()\n            return policy._pb\n        except Exception as err:\n            msg = \"message: {}\\n\\nstack trace: {}\".format(\n                err.message, traceback.format_exc())\n            return GetConfigPolicyReply(error=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_message(self, text, chat_id, reply_to_message_id=None, disable_web_page_preview=False, reply_markup=None):\n        self.logger.info('sending message \"%s\"', format(text.replace('\\n', '\\\\n')))\n        payload = dict(text=text,\n                       chat_id=chat_id,\n                       reply_to_message_id=reply_to_message_id,\n                       disable_web_page_preview=disable_web_page_preview,\n                       reply_markup=reply_markup)\n        return Message.from_api(self, **self._get('sendMessage', payload))", "response": "Use this method to send text messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef forward_message(self, chat_id, from_chat_id, message_id):\n        self.logger.info('forwarding message %s from %s to %s', message_id, from_chat_id, chat_id)\n        payload = dict(chat_id=chat_id,\n                       from_chat_id=from_chat_id,\n                       message_id=message_id)\n        return Message.from_api(self, **self._get('forwardMessage', payload))", "response": "Use this method to forward a message from one chat to another."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse this method to send photos. You must be an administrator in the chat for this to work and must have the appropriate admin rights.", "response": "def send_photo(self, chat_id, photo, caption=None, reply_to_message_id=None, reply_markup=None):\n        \"\"\"\n            Use this method to send photos. On success, the sent Message is returned.\n        \"\"\"\n        self.logger.info('send photo %s', photo)\n        payload = dict(chat_id=chat_id,\n                       caption=caption,\n                       reply_to_message_id=reply_to_message_id,\n                       reply_markup=reply_markup)\n        files = dict(photo=open(photo, 'rb'))\n        return Message.from_api(self, **self._post('sendPhoto', payload, files))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_audio(self, chat_id, audio, duration=None, performer=None, title=None, reply_to_message_id=None, reply_markup=None):\n        self.logger.info('sending audio payload %s', audio)\n        payload = dict(chat_id=chat_id,\n                       duration=duration,\n                       performer=performer,\n                       title=title,\n                       reply_to_message_id=reply_to_message_id,\n                       reply_markup=reply_markup)\n        files = dict(audio=open(audio, 'rb'))\n        return Message.from_api(self, **self._post('sendAudio', payload, files))", "response": "Use this method to send audio files. You can use this method to send audio files in a Telegram chat. You can use the audio file to send a message. You can use the send_voice method to send voice messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_document(self, chat_id=None, document=None, reply_to_message_id=None, reply_markup=None):\n        payload = dict(chat_id=chat_id,\n                       reply_to_message_id=reply_to_message_id,\n                       reply_markup=reply_markup)\n        files = dict(video=open(document, 'rb'))\n        return Message.from_api(api, **self._post('sendDocument', payload, files))", "response": "Use this method to send a document to a chat."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_sticker(self, chat_id=None, sticker=None, reply_to_message_id=None, reply_markup=None):\n        payload = dict(chat_id=chat_id,\n                       reply_to_message_id=reply_to_message_id,\n                       reply_markup=reply_markup)\n        files = dict(sticker=open(sticker, 'rb'))\n        return Message.from_api(api, **self._post('sendSticker', payload, files))", "response": "Use this method to send a. webp sticker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_video(self, chat_id, video, duration=None, caption=None, reply_to_message_id=None, reply_markup=None):\n        payload = dict(chat_id=chat_id,\n                       duration=duration,\n                       caption=caption,\n                       reply_to_message_id=reply_to_message_id,\n                       reply_markup=reply_markup)\n        files = dict(video=open(video, 'rb'))\n        return Message.from_api(api, **self._post('sendVideo', payload, files))", "response": "Use this method to send video files. You must be an administrator in the chat for this to work and must have the appropriate admin rights."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a location to a specific user.", "response": "def send_location(self, loc, to, reply=None):\n        \"\"\"\n            Use this method to send point on the map. On success, the sent Message is returned.\n        \"\"\"\n        lat, lon = loc\n        payload = dict(chat_id=to, reply_to_message_id=reply,\n                       latitude=lat, longitude=lon)\n        return Message.from_api(api, **self._get('sendLocation', payload))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a chat action to a specific user.", "response": "def send_chat_action(self, action, to):\n        \"\"\"\n            Use this method when you need to tell the user that something is happening on the bot's side.\n            The status is set for 5 seconds or less (when a message arrives from your bot,\n            Telegram clients clear its typing status).\n        \"\"\"\n        payload = dict(chat_id=to, action=action)\n        return self._get('sendChatAction', payload)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_updates(self, offset=None, limit=None, timeout=None):\n        payload = dict(offset=offset, limit=limit, timeout=timeout)\n        return self._get('getUpdates', payload)", "response": "Get updates from the specified region."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_web_hook(self, url=None, certificate=None):\n        payload = dict(url=url, certificate=certificate)\n        return self._get('setWebHook', payload)", "response": "This method will send an outgoing webhook to the specified url and receive incoming updates via an outgoing webhook."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new child item to this item.", "response": "def addChild(self, item):\r\n        \"\"\"\r\n        Adds a new child item to this item.\r\n        \r\n        :param      item | <XGanttWidgetItem>\r\n        \"\"\"\r\n        super(XGanttWidgetItem, self).addChild(item)\r\n        \r\n        item.sync()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addDependency(self, item):\r\n        if item in self._dependencies:\r\n            return\r\n        \r\n        viewItem = XGanttDepItem(self, item)\r\n        \r\n        self._dependencies[item]        = viewItem\r\n        item._reverseDependencies[self] = viewItem\r\n        \r\n        self.syncDependencies()", "response": "Adds a dependency for this item to the next item."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef adjustChildren(self, delta, secs=False):\r\n        if self.adjustmentsBlocked('children'):\r\n            return\r\n            \r\n        if self.itemStyle() != self.ItemStyle.Group:\r\n            return\r\n        \r\n        if not delta:\r\n            return\r\n        \r\n        for c in range(self.childCount()):\r\n            child = self.child(c)\r\n            child.blockAdjustments('range', True)\r\n            if secs:\r\n                dstart = child.dateTimeStart()\r\n                dstart = dstart.addSecs(delta)\r\n                child.setDateStart(dstart.date())\r\n                child.setTimeStart(dstart.time())\r\n            else:\r\n                child.setDateStart(child.dateStart().addDays(delta))\r\n            child.blockAdjustments('range', False)", "response": "Adjusts the children of this item by the inputed number of days."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef adjustRange(self, recursive=True):\r\n        if ( self.adjustmentsBlocked('range') ):\r\n            return\r\n        \r\n        if ( self.itemStyle() == self.ItemStyle.Group ):\r\n            dateStart = self.dateStart()\r\n            dateEnd   = self.dateEnd()\r\n            first     = True\r\n            \r\n            for c in range(self.childCount()):\r\n                child       = self.child(c)\r\n                \r\n                if ( first ):\r\n                    dateStart = child.dateStart()\r\n                    dateEnd   = child.dateEnd()\r\n                    first     = False\r\n                else:\r\n                    dateStart   = min(child.dateStart(), dateStart)\r\n                    dateEnd     = max(child.dateEnd(), dateEnd)\r\n            \r\n            self._dateStart = dateStart\r\n            self._dateEnd   = dateEnd\r\n            \r\n            self.sync()\r\n        \r\n        if ( self.parent() and recursive ):\r\n            self.parent().adjustRange(True)", "response": "Adjusts the start and end ranges for this item based on the limits from its children."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the first ancestor of the tree widget that this item is linked to or None if the item is not linked to a gantt widget.", "response": "def ganttWidget(self):\r\n        \"\"\"\r\n        Returns the gantt widget that this item is linked to.\r\n        \r\n        :return     <XGanttWidget> || None\r\n        \"\"\"\r\n        tree = self.treeWidget()\r\n        if ( not tree ):\r\n            return None\r\n        \r\n        from projexui.widgets.xganttwidget import XGanttWidget\r\n        return projexui.ancestor(tree, XGanttWidget)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new item to the given index.", "response": "def insertChild(self, index, item):\r\n        \"\"\"\r\n        Inserts a new item in the given index.\r\n        \r\n        :param      index | <int>\r\n                    item  | <XGanttWidgetItem>\r\n        \"\"\"\r\n        super(XGanttWidgetItem, self).insertChild(index, item)\r\n        item.sync()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the item style information for this item.", "response": "def itemStyle(self):\r\n        \"\"\"\r\n        Returns the item style information for this item.\r\n        \r\n        :return     <XGanttWidgetItem.ItemStyle>\r\n        \"\"\"\r\n        if ( self.useGroupStyleWithChildren() and self.childCount() ):\r\n            return XGanttWidgetItem.ItemStyle.Group\r\n        \r\n        return self._itemStyle"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the custom data that is stored on this object.", "response": "def property(self, key, default=None):\r\n        \"\"\"\r\n        Returns the custom data that is stored on this object.\r\n        \r\n        :param      key     | <str>\r\n                    default | <variant>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        if key == 'Name':\r\n            return self.name()\r\n        elif key == 'Start':\r\n            return self.dateStart()\r\n        elif key == 'End':\r\n            return self.dateEnd()\r\n        elif key == 'Calendar Days':\r\n            return self.duration()\r\n        elif key == 'Work Days':\r\n            return self.weekdays()\r\n        elif key == 'Time Start':\r\n            return self.timeStart()\r\n        elif key == 'Time End':\r\n            return self.timeEnd()\r\n        elif key == 'All Day':\r\n            return self.isAllDay()\r\n        else:\r\n            return self._properties.get(nativestring(key), default)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removeFromScene(self):\r\n        gantt = self.ganttWidget()\r\n        if not gantt:\r\n            return\r\n        \r\n        scene = gantt.viewWidget().scene()\r\n        \r\n        scene.removeItem(self.viewItem())\r\n        for target, viewItem in self._dependencies.items():\r\n            target._reverseDependencies.pop(self)\r\n            scene.removeItem(viewItem)", "response": "Removes this item from the view scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the endiing date time for this gantt chart.", "response": "def setDateTimeEnd(self, dtime):\r\n        \"\"\"\r\n        Sets the endiing date time for this gantt chart.\r\n        \r\n        :param      dtime | <QDateTime>\r\n        \"\"\"\r\n        self._dateEnd = dtime.date()\r\n        self._timeEnd = dtime.time()\r\n        self._allDay = False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setDateTimeStart(self, dtime):\r\n        self._dateStart = dtime.date()\r\n        self._timeStart = dtime.time()\r\n        self._allDay = False", "response": "Sets the starting date time for this gantt chart."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the duration for this item to the inputed duration.", "response": "def setDuration(self, duration):\r\n        \"\"\"\r\n        Sets the duration for this item to the inputed duration.\r\n        \r\n        :param      duration | <int>\r\n        \"\"\"\r\n        if duration < 1:\r\n            return False\r\n        \r\n        self.setDateEnd(self.dateStart().addDays(duration - 1))\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the item style that will be used for this item.", "response": "def setItemStyle(self, itemStyle):\r\n        \"\"\"\r\n        Sets the item style that will be used for this widget.  If you are\r\n        trying to set a style on an item that has children, make sure to turn \r\n        off the useGroupStyleWithChildren option, or it will always display as\r\n        a group.\r\n        \r\n        :param      itemStyle | <XGanttWidgetItem.ItemStyle>\r\n        \"\"\"\r\n        self._itemStyle = itemStyle\r\n        \r\n        # initialize the group icon for group style\r\n        if itemStyle == XGanttWidgetItem.ItemStyle.Group and \\\r\n           self.icon(0).isNull():\r\n            ico = projexui.resources.find('img/folder_close.png')\r\n            expand_ico = projexui.resources.find('img/folder_open.png')\r\n            self.setIcon(0, QIcon(ico))\r\n            self.setExpandedIcon(0, QIcon(expand_ico))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the name of this item to the inputed name.", "response": "def setName(self, name):\r\n        \"\"\"\r\n        Sets the name of this widget item to the inputed name.\r\n        \r\n        :param      name | <str>\r\n        \"\"\"\r\n        self._name = name\r\n        \r\n        tree = self.treeWidget()\r\n        if tree:\r\n            col = tree.column('Name')\r\n            if col != -1:\r\n                self.setData(col, Qt.EditRole, wrapVariant(name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the custom property for this item based on the inputed key and value.", "response": "def setProperty(self, key, value):\r\n        \"\"\"\r\n        Sets the custom property for this item's key to the inputed value.  If\r\n        the widget has a column that matches the inputed key, then the value \r\n        will be added to the tree widget as well.\r\n        \r\n        :param      key     | <str>\r\n                    value   | <variant>\r\n        \"\"\"\r\n        if key == 'Name':\r\n            self.setName(value)\r\n        elif key == 'Start':\r\n            self.setDateStart(value)\r\n        elif key == 'End':\r\n            self.setDateEnd(value)\r\n        elif key == 'Calendar Days':\r\n            self.setDuration(value)\r\n        elif key == 'Time Start':\r\n            self.setTimeStart(value)\r\n        elif key == 'Time End':\r\n            self.setTimeEnd(value)\r\n        elif key == 'All Day':\r\n            self.setAllDay(value)\r\n        elif key == 'Workadys':\r\n            pass\r\n        else:\r\n            self._properties[nativestring(key)] = value\r\n            \r\n            tree = self.treeWidget()\r\n            if tree:\r\n                col = tree.column(key)\r\n                if col != -1:\r\n                    self.setData(col, Qt.EditRole, wrapVariant(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sync(self, recursive=False):\r\n        self.syncTree(recursive=recursive)\r\n        self.syncView(recursive=recursive)", "response": "Syncs the information from this item to the tree and view."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef syncTree(self, recursive=False, blockSignals=True):\r\n        tree = self.treeWidget()\r\n        \r\n        # sync the tree information\r\n        if not tree:\r\n            return\r\n        \r\n        items = [self]\r\n        if recursive:\r\n            items += list(self.children(recursive=True))\r\n        \r\n        if blockSignals and not tree.signalsBlocked():\r\n            blocked = True\r\n            tree.blockSignals(True)\r\n        else:\r\n            blocked = False\r\n        \r\n        date_format = self.ganttWidget().dateFormat()\r\n        \r\n        for item in items:\r\n            for c, col in enumerate(tree.columns()):\r\n                value = item.property(col, '')\r\n                item.setData(c, Qt.EditRole, wrapVariant(value))\r\n        \r\n        if blocked:\r\n            tree.blockSignals(False)", "response": "Syncs the information from this item to the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef syncView(self, recursive=False):\r\n        # update the view widget\r\n        gantt = self.ganttWidget()\r\n        tree = self.treeWidget()\r\n        \r\n        if not gantt:\r\n            return\r\n        \r\n        vwidget = gantt.viewWidget()\r\n        scene = vwidget.scene()\r\n        cell_w = gantt.cellWidth()\r\n        \r\n        tree_offset_y  = tree.header().height() + 1\r\n        tree_offset_y += tree.verticalScrollBar().value()\r\n        \r\n        # collect the items to work on\r\n        items = [self]\r\n        if recursive:\r\n            items += list(self.children(recursive=True))\r\n        \r\n        for item in items:\r\n            # grab the view item from the gantt item\r\n            vitem = item.viewItem()\r\n            if not vitem.scene():\r\n                scene.addItem(vitem)\r\n            \r\n            # make sure the item should be visible\r\n            if item.isHidden() or not tree:\r\n                vitem.hide()\r\n                continue\r\n            \r\n            vitem.show()\r\n            tree_rect = tree.visualItemRect(item)\r\n            \r\n            tree_y  = tree_rect.y() + tree_offset_y\r\n            tree_h  = tree_rect.height()\r\n            \r\n            # check to see if this item is hidden\r\n            if tree_rect.height() == 0:\r\n                vitem.hide()\r\n                continue\r\n            \r\n            if gantt.timescale() in (gantt.Timescale.Minute,\r\n                                     gantt.Timescale.Hour, \r\n                                     gantt.Timescale.Day):\r\n                dstart = item.dateTimeStart()\r\n                dend   = item.dateTimeEnd()\r\n                view_x = scene.datetimeXPos(dstart)\r\n                view_r = scene.datetimeXPos(dend)\r\n                view_w = view_r - view_x\r\n            else:\r\n                view_x = scene.dateXPos(item.dateStart())\r\n                view_w = item.duration() * cell_w\r\n            \r\n                # determine the % off from the length based on this items time\r\n                if not item.isAllDay():\r\n                    full_day = 24 * 60 * 60 # full days worth of seconds\r\n                    \r\n                    # determine the start offset\r\n                    start      = item.timeStart()\r\n                    start_day  = (start.hour() * 60 * 60) \r\n                    start_day += (start.minute() * 60) \r\n                    start_day += (start.second())\r\n                    \r\n                    offset_start = (start_day / float(full_day)) * cell_w\r\n                    \r\n                    # determine the end offset\r\n                    end         = item.timeEnd()\r\n                    end_day     = (end.hour() * 60 * 60)\r\n                    end_day    += (start.minute() * 60)\r\n                    end_day    += (start.second() + 1) # forces at least 1 sec\r\n                    \r\n                    offset_end  = ((full_day - end_day) / float(full_day))\r\n                    offset_end *= cell_w\r\n                    \r\n                    # update the xpos and widths\r\n                    view_x += offset_start\r\n                    view_w -= (offset_start + offset_end)\r\n            \r\n            view_w = max(view_w, 5)\r\n            \r\n            vitem.setSyncing(True)\r\n            vitem.setPos(view_x, tree_y)\r\n            vitem.setRect(0, 0, view_w, tree_h)\r\n            vitem.setSyncing(False)\r\n            \r\n            # setup standard properties\r\n            flags  = vitem.ItemIsSelectable \r\n            flags |= vitem.ItemIsFocusable\r\n            \r\n            if item.flags() & Qt.ItemIsEditable:\r\n                flags |= vitem.ItemIsMovable\r\n            \r\n            vitem.setFlags(flags)\r\n            item.syncDependencies()", "response": "Updates the view with the information from this item to the view."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the child at the given index from this item.", "response": "def takeChild(self, index):\r\n        \"\"\"\r\n        Removes the child at the given index from this item.\r\n        \r\n        :param      index | <int>\r\n        \"\"\"\r\n        item = super(XGanttWidgetItem, self).takeChild(index)\r\n        \r\n        if item:\r\n            item.removeFromScene()\r\n            \r\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the dependency between this item and the inputed target.", "response": "def takeDependency(self, item):\r\n        \"\"\"\r\n        Removes the dependency between the this item and the inputed target.\r\n        \r\n        :param      item | <XGanttWidgetItem>\r\n        \"\"\"\r\n        if ( not item in self._dependencies ):\r\n            return\r\n        \r\n        item._reverseDependencies.pop(self)\r\n        viewItem = self._dependencies.pop(item)\r\n        \r\n        scene    = viewItem.scene()\r\n        if ( scene ):\r\n            scene.removeItem(viewItem)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when the view item is changed by the user.", "response": "def viewChanged(self, start, end):\r\n        \"\"\"\r\n        Called when the view item is changed by the user.\r\n        \r\n        :param      start | <QDate> || <QDateTime>\r\n                    end   | <QDate> || <QDateTime>\r\n        \"\"\"\r\n        if type(start) == QDate:\r\n            delta           = self._dateStart.daysTo(start)\r\n            self._dateStart = start\r\n            self._dateEnd   = end\r\n            self.adjustChildren(delta)\r\n\r\n        else:\r\n            delta = self._dateStart.secsTo(start)\r\n            self._dateStart = start.date()\r\n            self._timeStart = start.time()\r\n            \r\n            self._dateEnd = end.date()\r\n            self._timeEnd = end.time()\r\n            \r\n            self.adjustChildren(delta, secs=True)\r\n        \r\n        self.adjustRange()\r\n        \r\n        self.syncDependencies()\r\n        self.syncTree()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the view item that is linked with this item.", "response": "def viewItem(self):\r\n        \"\"\"\r\n        Returns the view item that is linked with this item.\r\n        \r\n        :return     <XGanttViewItem>\r\n        \"\"\"\r\n        if type(self._viewItem).__name__ == 'weakref':\r\n            return self._viewItem()\r\n        return self._viewItem"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef weekdays(self):\r\n        if self.itemStyle() == self.ItemStyle.Group:\r\n            out = 0\r\n            for i in range(self.childCount()):\r\n                out += self.child(i).weekdays()\r\n            return out\r\n        else:\r\n            dstart = self.dateStart().toPyDate()\r\n            dend   = self.dateEnd().toPyDate()\r\n            \r\n            return projex.dates.weekdays(dstart, dend)", "response": "Returns the number of weekdays this item has."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match(self, package):\n        if isinstance(package, basestring):\n            from .packages import Package\n            package = Package.parse(package)\n\n        if self.name != package.name:\n            return False\n\n        if self.version_constraints and \\\n                package.version not in self.version_constraints:\n            return False\n\n        if self.build_options:\n            if package.build_options:\n                if self.build_options - package.build_options:\n                    return False\n                else:\n                    return True\n            else:\n                return False\n        else:\n            return True", "response": "Match the given package with the requirement."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a requirement_expression into a : class:`Requirement object.", "response": "def parse(cls, requirement_expression):\n        \"\"\"Parses a :ref:`requirement_expression <requirement-expressions>`\n        into a :class:`Requirement` object.\n\n        :param requirement_expression: A package requirement expression.\n        :type requirement_expression: \\\n        :ref:`requirement_expression <requirement-expressions>`\n        :rtype: :class:`Requirement`\n\n        \"\"\"\n        match = RE.match(requirement_expression)\n\n        if match:\n            name, build_metadata, version_constraints_str = match.groups()\n\n            if version_constraints_str:\n                version_constraints = \\\n                    Constraints.parse(version_constraints_str)\n            else:\n                version_constraints = None\n\n            if build_metadata:\n                build_options = \\\n                    set(o.strip() for o in build_metadata.split(','))\n            else:\n                build_options = None\n\n            return cls(name, version_constraints, build_options)\n\n        else:\n            raise InvalidRequirementExpression(requirement_expression)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a delta based on this widget s information.", "response": "def delta(self):\r\n        \"\"\"\r\n        Returns a delta based on this widget's information.\r\n        \r\n        :return     <datetime.timedelta>\r\n        \"\"\"\r\n        number      = self._numberSpinner.value()\r\n        unit        = self._unitCombo.currentText()\r\n        direction   = self._directionCombo.currentText()\r\n        \r\n        # use past tense\r\n        if direction == 'ago':\r\n            number = -number\r\n        \r\n        if unit == 'year(s)':\r\n            return datetime.timedelta(number * 365)\r\n        elif unit == 'month(s)':\r\n            return datetime.timedelta(number * 30)\r\n        elif unit == 'week(s)':\r\n            return datetime.timedelta(number * 7)\r\n        elif unit == 'day(s)':\r\n            return datetime.timedelta(number)\r\n        elif unit == 'hour(s)':\r\n            return datetime.timedelta(0, number * 3600)\r\n        elif unit == 'minute(s)':\r\n            return datetime.timedelta(0, number * 60)\r\n        else:\r\n            return datetime.timedelta(0, number)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setDelta(self, delta):\r\n        days = int(delta.days)\r\n        secs = int(delta.total_seconds())\r\n        \r\n        direction = 'from now'\r\n        if secs < 0:\r\n            direction = 'ago'\r\n        \r\n        if days and days % 365 == 0:\r\n            number = days / 365\r\n            unit = 'year(s)'\r\n        elif days and days % 30 == 0:\r\n            number = days / 30\r\n            unit = 'month(s)'\r\n        elif days and days % 7 == 0:\r\n            number = days / 7\r\n            unit = 'week(s)'\r\n        elif days:\r\n            number = days\r\n            unit = 'day(s)'\r\n        elif secs % 3600 == 0:\r\n            number = secs / 3600\r\n            unit = 'hour(s)'\r\n        elif secs % 60 == 0:\r\n            number = secs / 60\r\n            unit = 'minute(s)'\r\n        else:\r\n            number = secs\r\n            unit = 'second(s)'\r\n        \r\n        self._numberSpinner.setValue(abs(int(number)))\r\n        self._unitCombo.setCurrentIndex(self._unitCombo.findText(unit))\r\n        index = self._directionCombo.findText(direction)\r\n        self._directionCombo.setCurrentIndex(index)", "response": "Sets the time delta for this widget to the inputed delta."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def leader(self):\n        response = await self._api.get(\"/v1/status/leader\")\n        if response.status == 200:\n            return response.body", "response": "Returns the current Raft leader"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def peers(self):\n        response = await self._api.get(\"/v1/status/peers\")\n        if response.status == 200:\n            return set(response.body)", "response": "Returns the current Raft peer set for this agent."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing a regex pattern to use with the clean method.", "response": "def get_pattern(echo_tags, start_tags, end_tags):\n    \"\"\"Constructs a pattern to use with the method clean().\n\n    The priority of the tags is echo_tags, then start_tags and finally end_tags.\n    That means that in some cases a negative lookahead may be required, as the\n    first match from left to right will be reported.\n\n    See clean() for the meaning of each group.\n\n    Args:\n      echo_tags: list of re strings. These are tags that may output something.\n      start_tags: list of re strings. Tags that typically do not output\n        anything, like control structures.\n      end_tags: list of re strings. All the closing tags.\n\n    Returns:\n      a RegexObject.\n    \"\"\"\n    return re.compile(\n        '|'.join((\n            LEADING_SPACES,\n            NEW_LINE,\n            r'(?P<echo>%s)' % '|'.join(echo_tags),\n            r'(?P<start>%s)' % '|'.join(start_tags),\n            r'(?P<end>%s)' % '|'.join(end_tags))),\n        flags=re.MULTILINE)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncollapsing this splitter handle before or after other widgets based on the inputed CollapseDirection.", "response": "def collapse( self, direction ):\n        \"\"\"\n        Collapses this splitter handle before or after other widgets based on \\\n        the inputed CollapseDirection.\n        \n        :param      direction | <XSplitterHandle.CollapseDirection>\n        \n        :return     <bool> | success\n        \"\"\"\n        if ( self.isCollapsed() ):\n            return False\n        \n        splitter = self.parent()\n        if ( not splitter ):\n            return False\n        \n        sizes   = splitter.sizes()\n        handles = [splitter.handle(i) for i in range(len(sizes))]\n        index   = handles.index(self)\n        \n        self.markCollapsed(direction, sizes)\n        \n        # determine the sizes to use based on the direction\n        if ( direction == XSplitterHandle.CollapseDirection.Before ):\n            sizes = [0 for i in range(i)] + sizes[i+1:]\n        else:\n            sizes = sizes[:i] + [0 for i in range(i, len(sizes))]\n        \n        splitter.setSizes(sizes)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncollapse the splitter before the inputed handle.", "response": "def collapseBefore( self, handle ):\n        \"\"\"\n        Collapses the splitter before the inputed handle.\n        \n        :param      handle | <XSplitterHandle>\n        \"\"\"\n        self.setUpdatesEnabled(False)\n        \n        # collapse all items after the current handle\n        if ( handle.isCollapsed() ):\n            self.setSizes(handle.restoreSizes())\n            \n        # collapse all items before the current handle\n        found = False\n        sizes = self.sizes()\n        \n        handle.storeSizes(sizes)\n        \n        for c in range(self.count()):\n            if ( self.handle(c) == handle ):\n                break\n            \n            sizes[c] = 0\n        \n        self.setSizes(sizes)\n        self.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef markCollapsed( self, direction, sizes ):\n        self._collapsed = True\n        self._storedSizes = sizes[:]\n        \n        if ( direction == XSplitterHandle.CollapseDirection.Before ):\n            if ( self.orientation() == Qt.Horizontal ):\n                self._collapseAfter.setArrowType( Qt.RightArrow )\n                self._collapseBefore.setArrowType( Qt.RightArrow )\n            else:\n                self._collapseAfter.setArrowType( Qt.DownArrow )\n                self._collapseBefore.setArrowType( Qt.DownArrow )\n        else:\n            if ( self.orientation() == Qt.Horizontal ):\n                self._collapseAfter.setArrowType( Qt.LeftArrow )\n                self._collapseBefore.setArrowType( Qt.LeftArrow )\n            else:\n                self._collapseAfter.setArrowType( Qt.UpArrow )\n                self._collapseAfter.setArrowType( Qt.UpArrow )", "response": "Updates the interface to reflect that the splitter is collapsed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef paintEvent( self, event ):\n        lines = []\n        count = 20\n        \n        # calculate the lines\n        if ( self.orientation() == Qt.Vertical ):\n            x = self._resizeGrip.pos().x()\n            h = self.height()\n            spacing = int(float(self._resizeGrip.width()) / count)\n            \n            for i in range(count):\n                lines.append(QLine(x, 0, x, h))\n                x += spacing\n        else:\n            y = self._resizeGrip.pos().y()\n            w = self.width()\n            spacing = int(float(self._resizeGrip.height()) / count)\n            \n            for i in range(count):\n                lines.append(QLine(0, y, w, y))\n                y += spacing\n            \n        # draw the lines\n        with XPainter(self) as painter:\n            pal = self.palette()\n            painter.setPen(pal.color(pal.Window).darker(120))\n            painter.drawLines(lines)", "response": "Overloads the paint event to handle drawing the splitter lines."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setOrientation( self, orientation ):\n        super(XSplitterHandle, self).setOrientation(orientation)\n        \n        if ( orientation == Qt.Vertical ):\n            self.layout().setDirection( QBoxLayout.LeftToRight )\n            \n            # update the widgets\n            self._collapseBefore.setFixedSize(30, 10)\n            self._collapseAfter.setFixedSize(30, 10)\n            self._resizeGrip.setFixedSize(60, 10)\n            \n            self._collapseBefore.setArrowType(Qt.UpArrow)\n            self._collapseAfter.setArrowType(Qt.DownArrow)\n            \n        elif ( orientation == Qt.Horizontal ):\n            self.layout().setDirection( QBoxLayout.TopToBottom )\n            \n            # update the widgets\n            self._collapseBefore.setFixedSize(10, 30)\n            self._collapseAfter.setFixedSize(10, 30)\n            self._resizeGrip.setFixedSize(10, 60)\n            \n            self._collapseBefore.setArrowType(Qt.LeftArrow)\n            self._collapseAfter.setArrowType(Qt.RightArrow)", "response": "Sets the orientation for this handle and updates the widgets linked with it."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef uncollapse( self ):\n        if ( not self.isCollapsed() ):\n            return False\n        \n        self.parent().setSizes(self._storedSizes)\n        self.unmarkCollapsed()\n        \n        return True", "response": "Uncollapses the splitter this handle is associated with by restoring the sizes from before the collapse occurred."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unmarkCollapsed( self ):\n        if ( not self.isCollapsed() ):\n            return\n        \n        self._collapsed     = False\n        self._storedSizes   = None\n        \n        if ( self.orientation() == Qt.Vertical ):\n            self._collapseBefore.setArrowType( Qt.UpArrow )\n            self._collapseAfter.setArrowType(  Qt.DownArrow )\n        else:\n            self._collapseBefore.setArrowType( Qt.LeftArrow )\n            self._collapseAfter.setArrowType(  Qt.RightArrow )", "response": "Unmarks this splitter as being in a collapsed state clearing any \\\n collapsed information."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncollapses the splitter after this handle.", "response": "def toggleCollapseAfter( self ):\n        \"\"\"\n        Collapses the splitter after this handle.\n        \"\"\"\n        if ( self.isCollapsed() ):\n            self.uncollapse()\n        else:\n            self.collapse( XSplitterHandle.CollapseDirection.After )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef toggleCollapseBefore( self ):\n        if ( self.isCollapsed() ):\n            self.uncollapse()\n        else:\n            self.collapse( XSplitterHandle.CollapseDirection.Before )", "response": "Collapses the splitter before this handle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreset the colors to the default settings.", "response": "def reset( self ):\n        \"\"\"\n        Resets the colors to the default settings.\n        \"\"\"\n        dataSet = self.dataSet()\n        if ( not dataSet ):\n            dataSet = XScheme()\n        \n        dataSet.reset()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn whether or not this layer is enabled and can be set as the current layer.", "response": "def isEnabled(self):\n        \"\"\"\n        Return whether or not this layer is enabled and can be set as the \\\n        current layer.\n        \n        :sa     linkEnabledToCurrent\n        \n        :return     <bool>\n        \"\"\"\n        \n        if self._linkEnabledToCurrent:\n            addtl = self.isCurrent()\n        else:\n            addtl = True\n        \n        return self._enabled and addtl"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn whether or not this layer is visible.", "response": "def isVisible(self):\n        \"\"\"\n        Returns whether or not this layer is visible.  If the inheritVisibility\n        value is set to True, then this will look up its parent hierarchy to \\\n        ensure it is visible.\n        \n        :return     <bool>\n        \"\"\"\n        if self._visible and self._inheritVisibility and self._parent:\n            return self._parent.isVisible()\n        \n        return self._visible"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ensureVisible(self):\n        # make sure all parents are visible\n        if self._parent and self._inheritVisibility:\n            self._parent.ensureVisible()\n        \n        self._visible = True\n        self.sync()", "response": "Ensures that this layer is visible by turning on all parent layers and then setting the visible flag."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef items(self):\n        from projexui.widgets.xnodewidget import XNode, XNodeConnection\n        \n        output = []\n        for item in self.scene().items():\n            if not (isinstance(item, XNode) or \n                    isinstance(item, XNodeConnection)):\n                continue\n                \n            if item.layer() == self:\n                output.append(item)\n        \n        return output", "response": "Returns a list of the items that are linked to this layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary of information about this item", "response": "def layerData(self):\n        \"\"\"\n        Returns a dictionary of information about this layer that an item \\\n        can use to sync with.\n        \n        :return     <dict>\n        \"\"\"\n        output = {}\n        \n        output['visible'] = self.isVisible()\n        output['zValue']  = self.zValue()\n        output['current'] = self.isCurrent()\n        \n        return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self, removeItems=False):\n        # makes sure this can be removed\n        if not self.prepareToRemove():\n            return False\n        \n        items = self.items()\n        \n        # grabs the next layer\n        if self._scene._layers:\n            new_layer = self._scene._layers[0]\n        else:\n            new_layer = None\n        \n        # removes the items from the scene if flagged\n        if removeItems:\n            self.scene().removeItems(items)\n        \n        # otherwise assign to the next layer\n        else:\n            for item in items:\n                item.setLayer(new_layer)\n        \n        # remove the layer from the scenes reference\n        if self in self._scene._layers:\n            self._scene._layers.remove(self)\n        \n        if new_layer:\n            new_layer.setCurrent()\n        \n        self._scene.setModified()\n        \n        return True", "response": "Removes this layer from the scene."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets whether or not this node layer inherits visibility settings from \\ its parents.", "response": "def setInheritVisibility(self, state):\n        \"\"\"\n        Sets whether or not this node layer inherits visibility settings from \\\n        its parents.\n        \n        :param      state | <bool>\n        \n        :return     <bool> changed\n        \"\"\"\n        if self._inheritVisibility == state:\n            return False\n            \n        self._inheritVisibility = state\n        self.sync()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the parent for this layer to the inputed layer.", "response": "def setParent(self, other):\n        \"\"\"\n        Sets the parent for this layer to the inputed layer.\n        \n        :param      other | <XNodeLayer> || None\n        \n        :return     <bool> changed\n        \"\"\"\n        if self._parent == other:\n            return False\n        \n        # remove this layer from its parent\n        if self._parent and self in self._parent._children:\n            self._parent._children.remove(self)\n        \n        self._parent = other\n        \n        # add this layer to its parent's list of children\n        if self._parent and not self in self._children:\n            self._parent._children.append(self)\n        \n        self.sync()\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setVisible(self, state):\n        # store the current state\n        currvis = self.isVisible()\r\n        \r\n        # update the local property\n        self._visible = state\n        \n        # check the new state\n        newvis = self.isVisible()\n        \n        # check to see if the state has changed\n        if newvis == currvis:\n            return False\n        \n        # update the item visibility\n        self.sync()\n        return True", "response": "Sets whether or not this particular layer is visible."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setZValue(self, zValue):\n        if zValue == self._zValue:\n            return False\n        \n        self._zValue = zValue\n        self.sync()\n        return True", "response": "Sets the z - value for this layer to the inputed value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync(self):\n        layerData = self.layerData()\n        for item in self.scene().items():\r\n            try:\r\n                if item._layer == self:\r\n                    item.syncLayerData(layerData)\r\n            except AttributeError:\r\n                continue", "response": "Syncs the items on this layer with the current layer settings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _safe_urlsplit(s):\n    rv = urlparse.urlsplit(s)\n    # we have to check rv[2] here and not rv[1] as rv[1] will be\n    # an empty bytestring in case no domain was given.\n    if type(rv[2]) is not type(s):\n        assert hasattr(urlparse, 'clear_cache')\n        urlparse.clear_cache()\n        rv = urlparse.urlsplit(s)\n        assert type(rv[2]) is type(s)\n    return rv", "response": "safe urlsplit for urllib2. urlsplit"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsplit up an URI or IRI.", "response": "def _uri_split(uri):\n    \"\"\"Splits up an URI or IRI.\"\"\"\n    scheme, netloc, path, query, fragment = _safe_urlsplit(uri)\n\n    auth = None\n    port = None\n\n    if '@' in netloc:\n        auth, netloc = netloc.split('@', 1)\n\n    if netloc.startswith('['):\n        host, port_part = netloc[1:].split(']', 1)\n        if port_part.startswith(':'):\n            port = port_part[1:]\n    elif ':' in netloc:\n        host, port = netloc.split(':', 1)\n    else:\n        host = netloc\n    return scheme, auth, host, port, path, query, fragment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iri_to_uri(iri, charset='utf-8'):\n    iri = unicode(iri)\n    scheme, auth, hostname, port, path, query, fragment = _uri_split(iri)\n\n    scheme = scheme.encode('ascii')\n    hostname = hostname.encode('idna')\n\n    if ':' in hostname:\n        hostname = '[' + hostname + ']'\n\n    if auth:\n        if ':' in auth:\n            auth, password = auth.split(':', 1)\n        else:\n            password = None\n        auth = _quote(auth.encode(charset))\n        if password:\n            auth += ':' + _quote(password.encode(charset))\n        hostname = auth + '@' + hostname\n    if port:\n        hostname += ':' + port\n\n    path = _quote(path.encode(charset), safe=\"/:~+%\")\n    query = _quote(query.encode(charset), safe=\"=%&[]:;$()+,!?*/\")\n\n    # this absolutely always must return a string.  Otherwise some parts of\n    # the system might perform double quoting (#61)\n    return str(urlparse.urlunsplit([scheme, hostname, path, query, fragment]))", "response": "r Converts any unicode based IRI to an acceptable ASCII URI."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef url_decode(s, charset='utf-8', decode_keys=False, include_empty=True,\n               errors='replace', separator='&', cls=None):\n    \"\"\"Parse a querystring and return it as :class:`MultiDict`.  Per default\n    only values are decoded into unicode strings.  If `decode_keys` is set to\n    `True` the same will happen for keys.\n\n    Per default a missing value for a key will default to an empty key.  If\n    you don't want that behavior you can set `include_empty` to `False`.\n\n    Per default encoding errors are ignored.  If you want a different behavior\n    you can set `errors` to ``'replace'`` or ``'strict'``.  In strict mode a\n    `HTTPUnicodeError` is raised.\n\n    .. versionchanged:: 0.5\n       In previous versions \";\" and \"&\" could be used for url decoding.\n       This changed in 0.5 where only \"&\" is supported.  If you want to\n       use \";\" instead a different `separator` can be provided.\n\n       The `cls` parameter was added.\n\n    :param s: a string with the query string to decode.\n    :param charset: the charset of the query string.\n    :param decode_keys: set to `True` if you want the keys to be decoded\n                        as well.\n    :param include_empty: Set to `False` if you don't want empty values to\n                          appear in the dict.\n    :param errors: the decoding error behavior.\n    :param separator: the pair separator to be used, defaults to ``&``\n    :param cls: an optional dict class to use.  If this is not specified\n                       or `None` the default :class:`MultiDict` is used.\n    \"\"\"\n    if cls is None:\n        cls = MultiDict\n    return cls(_url_decode_impl(str(s).split(separator), charset, decode_keys,\n                                include_empty, errors))", "response": "Parse a querystring and return it as a MultiDict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef url_decode_stream(stream, charset='utf-8', decode_keys=False,\n                      include_empty=True, errors='replace', separator='&',\n                      cls=None, limit=None, return_iterator=False):\n    \"\"\"Works like :func:`url_decode` but decodes a stream.  The behavior\n    of stream and limit follows functions like\n    :func:`~werkzeug.wsgi.make_line_iter`.  The generator of pairs is\n    directly fed to the `cls` so you can consume the data while it's\n    parsed.\n\n    .. versionadded:: 0.8\n\n    :param stream: a stream with the encoded querystring\n    :param charset: the charset of the query string.\n    :param decode_keys: set to `True` if you want the keys to be decoded\n                        as well.\n    :param include_empty: Set to `False` if you don't want empty values to\n                          appear in the dict.\n    :param errors: the decoding error behavior.\n    :param separator: the pair separator to be used, defaults to ``&``\n    :param cls: an optional dict class to use.  If this is not specified\n                       or `None` the default :class:`MultiDict` is used.\n    :param limit: the content length of the URL data.  Not necessary if\n                  a limited stream is provided.\n    :param return_iterator: if set to `True` the `cls` argument is ignored\n                            and an iterator over all decoded pairs is\n                            returned\n    \"\"\"\n    if return_iterator:\n        cls = lambda x: x\n    elif cls is None:\n        cls = MultiDict\n    pair_iter = make_chunk_iter(stream, separator, limit)\n    return cls(_url_decode_impl(pair_iter, charset, decode_keys,\n                                include_empty, errors))", "response": "This function decodes a URL string into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef url_encode_stream(obj, stream=None, charset='utf-8', encode_keys=False,\n                      sort=False, key=None, separator='&'):\n    \"\"\"Like :meth:`url_encode` but writes the results to a stream\n    object.  If the stream is `None` a generator over all encoded\n    pairs is returned.\n\n    .. versionadded:: 0.8\n\n    :param obj: the object to encode into a query string.\n    :param stream: a stream to write the encoded object into or `None` if\n                   an iterator over the encoded pairs should be returned.  In\n                   that case the separator argument is ignored.\n    :param charset: the charset of the query string.\n    :param encode_keys: set to `True` if you have unicode keys.\n    :param sort: set to `True` if you want parameters to be sorted by `key`.\n    :param separator: the separator to be used for the pairs.\n    :param key: an optional function to be used for sorting.  For more details\n                check out the :func:`sorted` documentation.\n    \"\"\"\n    gen = _url_encode_impl(obj, charset, encode_keys, sort, key)\n    if stream is None:\n        return gen\n    for idx, chunk in enumerate(gen):\n        if idx:\n            stream.write(separator)\n        stream.write(chunk)", "response": "Like url_encode but writes the results into a stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the URL of a user that just isn t a real URL.", "response": "def url_fix(s, charset='utf-8'):\n    r\"\"\"Sometimes you get an URL by a user that just isn't a real URL because\n    it contains unsafe characters like ' ' and so on.  This function can fix\n    some of the problems in a similar way browsers handle data entered by the\n    user:\n\n    >>> url_fix(u'http://de.wikipedia.org/wiki/Elf (Begriffskl\\xe4rung)')\n    'http://de.wikipedia.org/wiki/Elf%20%28Begriffskl%C3%A4rung%29'\n\n    :param s: the string with the URL to fix.\n    :param charset: The target charset for the URL if the url was given as\n                    unicode string.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(charset, 'replace')\n    scheme, netloc, path, qs, anchor = _safe_urlsplit(s)\n    path = _quote(path, '/%')\n    qs = _quote_plus(qs, ':&%=')\n    return urlparse.urlunsplit((scheme, netloc, path, qs, anchor))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new internal logging handler.", "response": "def addHandler(self, handler):\n        \"\"\"\n        Setups a new internal logging handler. For fastlog loggers,\n        handlers are kept track of in the self._handlers list\n        \"\"\"\n        self._handlers.append(handler)\n        self.inner.addHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadjust the output format of messages based on the style name provided by the user.", "response": "def setStyle(self, stylename):\n        \"\"\"\n        Adjusts the output format of messages based on the style name provided\n\n        Styles are loaded like python modules, so you can import styles from your own modules or use the ones in fastlog.styles\n\n        Available styles can be found under /fastlog/styles/\n\n        The default style is 'fastlog.styles.pwntools'\n        \"\"\"\n        self.style = importlib.import_module(stylename)\n        newHandler = Handler()\n        newHandler.setFormatter(Formatter(self.style))\n        self.addHandler(newHandler)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint a separator to the log.", "response": "def separator(self, *args, **kwargs):\n        \"\"\"\n        Prints a separator to the log. This can be used to separate blocks of log messages.\n\n        The separator will default its log level to the level of the last message printed unless\n        specified with the level= kwarg.\n\n        The length and type of the separator string is determined\n        by the current style. See ``setStyle``\n        \"\"\"\n        levelOverride = kwargs.get('level') or self._lastlevel\n        self._log(levelOverride, '', 'separator', args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new block that is indented.", "response": "def indent(self):\n        \"\"\"\n        Begins an indented block. Must be used in a 'with' code block.\n        All calls to the logger inside of the block will be indented.\n        \"\"\"\n        blk = IndentBlock(self, self._indent)\n        self._indent += 1\n        return blk"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef newline(self, *args, **kwargs):\n        levelOverride = kwargs.get('level') or self._lastlevel\n        self._log(levelOverride, '', 'newline', args, kwargs)", "response": "Print an empty line to the log."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint a colorful hexdump of the first argument.", "response": "def hexdump(self, s, *args, **kwargs):\n        \"\"\"\n        Outputs a colorful hexdump of the first argument. \n\n        This function will attempt to 'flatten' iterable data passed to it until all remaining elements\n        are binary representable.\n\n        In python2, objects should be of type 'str', in python3, 'bytes' or 'bytearray' will work.\n\n        The level of the last message printed is used unless specified otherwise with the level= kwarg\n\n        Arguments to pass to hexdump:\n            width(int): The number of characters per line\n            skip(bool): Set to True, if repeated lines should be replaced by a \"*\"\n            hexii(bool): Set to True, if a hexii-dump should be returned instead of a hexdump.\n            begin(int):  Offset of the first byte to print in the left column\n            highlight(iterable): Byte values to highlight.\n        \"\"\"\n        levelOverride = kwargs.get('level') or self._lastlevel\n        hexdmp = hexdump.hexdump(self, s, **kwargs)\n        self._log(levelOverride, hexdmp, 'indented', args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file(self, fax_id, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_file_with_http_info(fax_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.get_file_with_http_info(fax_id, **kwargs)  # noqa: E501\n            return data", "response": "Get a file using it s id."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload a file to a specific key.", "response": "def upload_file(self, fax_file, **kwargs):  # noqa: E501\n        \"\"\"upload a file  # noqa: E501\n\n        Before sending a fax you need to upload your files using this API. In order to upload your fax file, you have to send a `multipart/form-data` request with your file. If the upload was successful you would receive a `file_path` which you can use to send your fax.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.upload_file(fax_file, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param file fax_file: (required)\n        :param str format: can be 'pdf' or 'tiff'\n        :return: File\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.upload_file_with_http_info(fax_file, **kwargs)  # noqa: E501\n        else:\n            (data) = self.upload_file_with_http_info(fax_file, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef checkablePopup( self ):\n        if not self._checkablePopup and self.isCheckable():\n            popup = QListView(self)\n            popup.setSelectionMode(QListView.NoSelection)\n            popup.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n            popup.setWindowFlags(Qt.Popup)\n            popup.installEventFilter(self)\n            popup.doubleClicked.connect(self.checkModelIndex)\n            self._checkablePopup = popup\n        \n        return self._checkablePopup", "response": "Returns the popup if this widget is checkable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the current index as the checked index.", "response": "def checkModelIndex( self, modelIndex ):\n        \"\"\"\n        Sets the current index as the checked index.\n        \n        :param      modelIndex | <QModelIndex>\n        \"\"\"\n        self.checkablePopup().hide()\n        \n        if not self.isCheckable():\n            return\n        \n        self.setCheckedIndexes([modelIndex.row()])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef currentText(self):\n        lineEdit = self.lineEdit()\n        if lineEdit:\n            return lineEdit.currentText()\n        text = nativestring(super(XComboBox, self).currentText())\n        if not text:\n            return self._hint\n        return text", "response": "Returns the current text for this combobox including the hint option \\\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of checked indexes for this combobox.", "response": "def checkedIndexes( self ):\n        \"\"\"\n        Returns a list of checked indexes for this combobox.\n        \n        :return     [<int>, ..]\n        \"\"\"\n        if ( not self.isCheckable() ):\n            return []\n        \n        model  = self.model()\n        return [i for i in range(self.count()) if model.item(i).checkState()]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the items that are checked for this combobox.", "response": "def checkedItems( self ):\n        \"\"\"\n        Returns the checked items for this combobox.\n        \n        :return     [<str>, ..]\n        \"\"\"\n        if not self.isCheckable():\n            return []\n        \n        return [nativestring(self.itemText(i)) for i in self.checkedIndexes()]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiltering events for the popup widget.", "response": "def eventFilter(self, object, event):\n        \"\"\"\n        Filters events for the popup widget.\n        \n        :param      object | <QObject>\n                    event  | <QEvent>\n        \"\"\"\n        # popup the editor when clicking in the line edit for a checkable state\n        if object == self.lineEdit() and self.isEnabled():\n            if not self.isCheckable():\n                return super(XComboBox, self).eventFilter(object, event)\n            \n            # show the popup when the user clicks on it\n            elif event.type() == event.MouseButtonPress:\n                self.showPopup()\n            \n            # eat the wheel event when the user is scrolling\n            elif event.type() == event.Wheel:\n                return True\n            \n        # make sure we're looking for the checkable popup\n        elif object == self._checkablePopup:\n            if event.type() == event.KeyPress and \\\n                 event.key() in (Qt.Key_Escape, Qt.Key_Return, Qt.Key_Enter):\n                object.close()\n            \n            elif event.type() == event.MouseButtonPress:\n                if not object.geometry().contains(event.pos()):\n                    object.close()\n        \n        return super(XComboBox, self).eventFilter(object, event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the hint color for this combo box provided its line edit is an XLineEdit instance.", "response": "def hintColor(self):\n        \"\"\"\n        Returns the hint color for this combo box provided its line edit is\n        an XLineEdit instance.\n        \n        :return     <QColor>\n        \"\"\"\n        lineEdit = self.lineEdit()\n        if isinstance(lineEdit, XLineEdit):\n            return lineEdit.hintColor()\n        return QColor()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the line editor associated with this combobox.", "response": "def lineEdit(self):\n        \"\"\"\n        Returns the line editor associated with this combobox.  This will\n        return the object stored at the reference for the editor since\n        sometimes the internal Qt process will raise a RuntimeError that\n        the C/C++ object has been deleted.\n        \n        :return     <XLineEdit> || None\n        \"\"\"\n        try:\n            edit = self._lineEdit()\n        except TypeError:\n            edit = None\n\n        if edit is None:\n            self._edit = None\n        return edit"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npaint this combobox based on whether or not it is visible.", "response": "def paintEvent(self, event):\n        \"\"\"\n        Paints this combobox based on whether or not it is visible.\n        \n        :param      event | <QPaintEvent>\n        \"\"\"\n        if not self.autoRaise() or (self._hovered and self.isEnabled()):\n            super(XComboBox, self).paintEvent(event)\n            \n            text = QComboBox.currentText(self)\n            if not text and self._hint and not self.lineEdit():\n                text = self._hint\n                palette = self.palette()\n                with XPainter(self) as painter:\n                    painter.setPen(palette.color(palette.Disabled, palette.Text))\n                    painter.drawText(5, 0, self.width(), self.height(),\n                                     Qt.AlignLeft | Qt.AlignVCenter,\n                                     self.currentText())\n            \n        else:\n            palette = self.palette()\n            \n            with XPainter(self) as painter:\n                text = QComboBox.currentText(self)\n                if not text:\n                    text = self.hint()\n                    painter.setPen(palette.color(palette.Disabled,\n                                                 palette.WindowText))\n                \n                painter.drawText(5, 0, self.width(), self.height(),\n                                 Qt.AlignLeft | Qt.AlignVCenter, text)\n                \n                x = self.width() - 15\n                y = 4\n                pixmap = QPixmap(resources.find('img/treeview/triangle_down.png'))\n                painter.drawPixmap(x, y, pixmap)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setAutoRaise(self, state):\n        self._autoRaise = state\n        self.setMouseTracking(state)\n        try:\n            self.lineEdit().setVisible(not state)\n        except AttributeError:\n            pass", "response": "Sets whether or not this combo box should automatically raise up."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCheckedIndexes(self, indexes):\n        if not self.isCheckable():\n            return\n        \n        model = self.model()\n        model.blockSignals(True)\n        for i in range(self.count()):\n            if not self.itemText(i):\n                continue\n            \n            item = model.item(i)\n            \n            if i in indexes:\n                state = Qt.Checked\n            else:\n                state = Qt.Unchecked\n                \n            item.setCheckState(state)\n        model.blockSignals(False)\n        self.updateCheckedText()", "response": "Sets a list of checked indexes for this combobox."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the items for this combobox to the inputed items.", "response": "def setCheckedItems(self, items):\n        \"\"\"\n        Returns the checked items for this combobox.\n        \n        :return     items | [<str>, ..]\n        \"\"\"\n        if not self.isCheckable():\n            return\n        \n        model = self.model()\n        for i in range(self.count()):\n            item_text = self.itemText(i)\n            if not item_text:\n                continue\n            \n            if nativestring(item_text) in items:\n                state = Qt.Checked\n            else:\n                state = Qt.Unchecked\n            \n            model.item(i).setCheckState(state)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets whether or not this combobox stores checkable items.", "response": "def setCheckable( self, state ):\n        \"\"\"\n        Sets whether or not this combobox stores checkable items.\n        \n        :param      state | <bool>\n        \"\"\"\n        self._checkable = state\n        \n        # need to be editable to be checkable\n        edit = self.lineEdit()\n        if state:\n            self.setEditable(True)\n            edit.setReadOnly(True)\n            \n            # create connections\n            model = self.model()\n            model.rowsInserted.connect(self.adjustCheckState)\n            model.dataChanged.connect(self.updateCheckedText)\n        \n        elif edit:\n            edit.setReadOnly(False)\n        \n        self.updateCheckState()\n        self.updateCheckedText()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setEditable( self, state ):\n        super(XComboBox, self).setEditable(state)\n        \n        if state:\n            edit = self.lineEdit()\n            if edit and isinstance(edit, XLineEdit):\n                return\n            elif edit:\n                edit.setParent(None)\n                edit.deleteLater()\n            \n            edit = XLineEdit(self)\n            edit.setHint(self.hint())\n            self.setLineEdit(edit)", "response": "Sets whether or not this combobox will be editable updating its \\\nalid line edit to an XLineEdit instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setLineEdit(self, edit):\n        if edit and not isinstance(edit, XLineEdit):\n            edit.setParent(None)\n            edit.deleteLater()\n            \n            edit = XLineEdit(self)\n        \n        if edit is not None:\n            edit.installEventFilter(self)\n            self._lineEdit = weakref.ref(edit)\n        else:\n            self._lineEdit = None\n        \n        super(XComboBox, self).setLineEdit(edit)", "response": "Sets the line edit for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the hint for this line edit that will be displayed when in editable mode.", "response": "def setHint( self, hint ):\n        \"\"\"\n        Sets the hint for this line edit that will be displayed when in \\\n        editable mode.\n        \n        :param      hint | <str>\n        \"\"\"\n        self._hint = hint\n        \n        lineEdit   = self.lineEdit()\n        if isinstance(lineEdit, XLineEdit):\n            lineEdit.setHint(hint)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the hint color for this combo box provided its line edit is an instance of XLineEdit.", "response": "def setHintColor(self, color):\n        \"\"\"\n        Sets the hint color for this combo box provided its line edit is\n        an XLineEdit instance.\n        \n        :param      color | <QColor>\n        \"\"\"\n        lineEdit = self.lineEdit()\n        if isinstance(lineEdit, XLineEdit):\n            lineEdit.setHintColor(color)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows a custom popup widget for this system.", "response": "def showPopup( self ):\n        \"\"\"\n        Displays a custom popup widget for this system if a checkable state \\\n        is setup.\n        \"\"\"\n        if not self.isCheckable():\n            return super(XComboBox, self).showPopup()\n        \n        if not self.isVisible():\n            return\n        \n        # update the checkable widget popup\n        point = self.mapToGlobal(QPoint(0, self.height() - 1))\n        popup = self.checkablePopup()\n        popup.setModel(self.model())\n        popup.move(point)\n        popup.setFixedWidth(self.width())\n        \n        height = (self.count() * 19) + 2\n        if height > 400:\n            height = 400\n            popup.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)\n        else:\n            popup.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        \n        popup.setFixedHeight(height)\n        popup.show()\n        popup.raise_()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updateCheckState( self ):\n        checkable = self.isCheckable()\n        model     = self.model()\n        flags     = Qt.ItemIsSelectable | Qt.ItemIsEnabled\n        \n        for i in range(self.count()):\n            item = model.item(i)\n            \n            if not (checkable and item.text()):\n                item.setCheckable(False)\n                item.setFlags(flags)\n            \n            # only allow checking for items with text\n            else:\n                item.setCheckable(True)\n                item.setFlags(flags | Qt.ItemIsUserCheckable)", "response": "Updates the check state of the items in the model to reflect the current check state system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the text in the editor to reflect the latest state of the items in the checked items.", "response": "def updateCheckedText(self):\n        \"\"\"\n        Updates the text in the editor to reflect the latest state.\n        \"\"\"\n        if not self.isCheckable():\n            return\n        \n        indexes = self.checkedIndexes()\n        items = self.checkedItems()\n\n        if len(items) < 2 or self.separator():\n            self.lineEdit().setText(self.separator().join(items))\n        else:\n            self.lineEdit().setText('{0} items selected'.format(len(items)))\n        \n        if not self.signalsBlocked():\n            self.checkedItemsChanged.emit(items)\n            self.checkedIndexesChanged.emit(indexes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef toggleModelIndex(self, modelIndex):\n        if not self.isCheckable():\n            return\n            \n        item = self.model().item(modelIndex.row())\n        if item.checkState() == Qt.Checked:\n            state = Qt.Unchecked\n        else:\n            state = Qt.Checked\n        \n        item.setCheckState(state)", "response": "Toggles the check state of the index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process(self, metrics, config):\n        LOG.debug(\"Process called\")\n        for metric in metrics:\n            metric.tags[\"instance-id\"] = config[\"instance-id\"]\n        return metrics", "response": "Processes metrics.\n\n        This method is called by the Snap deamon during the process phase\n        of the execution of a Snap workflow.  Examples of processing metrics\n        include applying filtering, max, min, average functions as well as\n        adding additional context to the metrics to name just a few.\n\n        In this example we are adding a tag called 'context' to every metric.\n\n        Args:\n            metrics (obj:`list` of `snap_plugin.v1.Metric`):\n                List of metrics to be processed.\n\n        Returns:\n            :obj:`list` of `snap_plugin.v1.Metric`:\n                List of processed metrics."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blink(self, state=True):\r\n        if self._blinking == state:\r\n            return True\r\n        elif not self.graphicsEffect():\r\n            return False\r\n        else:\r\n            self._blinking = state\r\n            if state:\r\n                self.startTimer(self.blinkInterval())", "response": "Starts or stops the blinking state for this toolbutton."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverloading the paint even to render this button.", "response": "def paintEvent(self, event):\r\n        \"\"\"\r\n        Overloads the paint even to render this button.\r\n        \"\"\"\r\n        if self.isHoverable() and self.icon().isNull():\r\n            return\r\n\r\n        # initialize the painter\r\n        painter = QtGui.QStylePainter()\r\n        painter.begin(self)\r\n        try:\r\n            option = QtGui.QStyleOptionToolButton()\r\n            self.initStyleOption(option)\r\n\r\n            # generate the scaling and rotating factors\r\n            x_scale = 1\r\n            y_scale = 1\r\n\r\n            if self.flipHorizontal():\r\n                x_scale = -1\r\n            if self.flipVertical():\r\n                y_scale = -1\r\n\r\n            center = self.rect().center()\r\n            painter.translate(center.x(), center.y())\r\n            painter.rotate(self.angle())\r\n            painter.scale(x_scale, y_scale)\r\n            painter.translate(-center.x(), -center.y())\r\n\r\n            painter.drawComplexControl(QtGui.QStyle.CC_ToolButton, option)\r\n        finally:\r\n            painter.end()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset whether or not this button is a hoverable button.", "response": "def setHoverable(self, state):\r\n        \"\"\"\r\n        Sets whether or not this is a hoverable button.  When in a hoverable state, the icon will only\r\n        be visible when the button is hovered on.\r\n\r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._hoverable = state\r\n        self._hoverIcon = self.icon()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setEnabled(self, state):\r\n        super(XToolButton, self).setEnabled(state)\r\n        \r\n        self.updateUi()", "response": "Updates the drop shadow effect for this widget on enable or disable change."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setMovie(self, movie):\r\n        if self._movie is not None:\r\n            self._movie.frameChanged.disconnect(self._updateFrame)\r\n        \r\n        self._movie = movie\r\n        \r\n        if movie is not None:\r\n            self._updateFrame()\r\n            self._movie.frameChanged.connect(self._updateFrame)\r\n            self.destroyed.connect(self.cleanup)", "response": "Sets the movie instance for this button."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setPalette(self, palette):\r\n        super(XToolButton, self).setPalette(palette)\r\n        self.updateUi()", "response": "Sets the palette for this button to the inputed palette."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the text for this item and resizes it to fit the text and the remove button.", "response": "def setText( self, text ):\r\n        \"\"\"\r\n        Sets the text for this item and resizes it to fit the text and the\r\n        remove button.\r\n        \r\n        :param      text | <str>\r\n        \"\"\"\r\n        super(XMultiTagItem, self).setText(text)\r\n        \r\n        metrics = QFontMetrics(self.font())\r\n        \r\n        hint = QSize(metrics.width(text) + 24, 18)\r\n        self.setSizeHint(hint)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an editor for this item.", "response": "def createEditor( self, parent, option, index ):\r\n        \"\"\"\r\n        Overloads the create editor method to assign the parent's completer to\r\n        any line edit created.\r\n        \r\n        :param      parent | <QWidget>\r\n                    option | <QStyleOption>\r\n                    index  | <QModelIndex>\r\n        \r\n        :return     <QWidget> || None\r\n        \"\"\"\r\n        multi_tag = projexui.ancestor(self, XMultiTagEdit)\r\n        \r\n        edit = QLineEdit(parent)\r\n        edit.setFrame(False)\r\n        edit.setCompleter(multi_tag.completer())\r\n        edit.installEventFilter(multi_tag)\r\n        \r\n        return edit"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling the display drawing for this delegate.", "response": "def drawDisplay( self, painter, option, rect, text ):\n        \"\"\"\n        Handles the display drawing for this delegate.\n        \n        :param      painter | <QPainter>\n                    option  | <QStyleOption>\n                    rect    | <QRect>\n                    text    | <str>\n        \"\"\"\n        painter.setBrush(Qt.NoBrush)\n        painter.drawText(rect.left() + 3,\n                         rect.top(),\n                         rect.width() - 3,\n                         rect.height(), \n                         option.displayAlignment, \n                         text)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverride this method to draw the background and border of the related items.", "response": "def paint( self, painter, option, index ):\r\n        \"\"\"\r\n        Overloads the paint method from Qt to perform some additional painting\r\n        on items.\r\n        \r\n        :param      painter | <QPainter>\r\n                    option  | <QStyleOption>\r\n                    index   | <QModelIndex>\r\n        \"\"\"\r\n        # draw the background\n        edit = self.parent()\r\n        item = edit.item(index.row())\r\n        if ( not isinstance(item, XMultiTagCreateItem) ):\n            if ( item.isSelected() ):\n                painter.setBrush(edit.highlightColor())\n            else:\r\n                painter.setBrush(edit.tagColor())\n            \r\n            painter.drawRect(option.rect)\n        \n        painter.setBrush(Qt.NoBrush)\n        painter.setPen(item.foreground().color())\n        \r\n        super(XMultiTagDelegate, self).paint(painter, option, index)\r\n        \r\n        # draw the border\r\n        item = self.parent().item(index.row())\r\n        if ( not isinstance(item, XMultiTagCreateItem) ):\r\n            painter.setPen(edit.borderColor())\r\n            painter.setBrush(Qt.NoBrush)\r\n            painter.drawRect(option.rect)\n            painter.drawText(option.rect.right() - 14,\n                             option.rect.top() + 1,\n                             16,\n                             16,\n                             Qt.AlignCenter,\n                             'x')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new tag to the edit. Returns True if the edit was successfully added False otherwise.", "response": "def addTag( self, tag ):\r\n        \"\"\"\r\n        Adds a new tag to the edit.\r\n        \r\n        :param      tag | <str>\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        if ( not (tag and self.isTagValid(tag)) ):\r\n            return False\r\n        \r\n        self.blockSignals(True)\r\n        create_item = self.createItem()\r\n        if create_item:\r\n            self.insertItem(self.row(create_item), XMultiTagItem(tag, self))\r\n            create_item.setText('')\r\n        else:\r\n            self.addItem(XMultiTagItem(tag, self))\r\n        self.blockSignals(False)\r\n        \r\n        if ( not self.signalsBlocked() ):\r\n            self.tagCreated.emit(tag)\r\n        \r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy( self ):\n        text = []\n        for item in self.selectedItems():\n            text.append(nativestring(item.text()))\n        \n        QApplication.clipboard().setText(','.join(text))", "response": "Copies the selected items to the clipboard."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a reference to the create item that is used for this edit.", "response": "def createItem( self ):\r\n        \"\"\"\r\n        Returns a reference to the create item that is used for this edit.\r\n        \r\n        :return     <XMultiTagCreateItem>\r\n        \"\"\"\r\n        if not self.isEditable():\r\n            return None\r\n        \r\n        if self._createItem is None:\r\n            self.blockSignals(True)\r\n            \r\n            self._createItem = XMultiTagCreateItem(self)\r\n            self.addItem(self._createItem)\r\n            \r\n            self.blockSignals(False)\r\n        \r\n        return self._createItem"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the drag move event.", "response": "def dragMoveEvent( self, event ):\r\n        \"\"\"\r\n        Handles the drag move event.\r\n        \r\n        :param      event | <QDragEvent>\r\n        \"\"\"\r\n        tags = nativestring(event.mimeData().text())\n        \n        if ( event.source() == self ):\n            event.acceptProposedAction()\n        elif ( tags ):\r\n            event.acceptProposedAction()\n        else:\n            super(XMultiTagEdit, self).dragMoveEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dropEvent( self, event ):\r\n        tags = nativestring(event.mimeData().text())\r\n        \n        # handle an internal move\n        if event.source() == self:\n            curr_item = self.selectedItems()[0]\r\n            create_item = self.createItem()\n            \n            # don't allow moving of the creation item\n            if curr_item == create_item:\n                return\n            \n            targ_item = self.itemAt(event.pos())\n            if not targ_item:\n                targ_item = create_item\n            \n            curr_idx  = self.row(curr_item)\n            targ_idx  = self.row(targ_item)\n            if ( targ_idx == self.count() - 1 ):\n                targ_idx -= 1\n            \n            # don't bother moving the same item\n            if ( curr_idx == targ_idx ):\n                return\n            \n            self.takeItem(self.row(curr_item))\n            self.insertItem(targ_idx, curr_item)\n            self.setCurrentItem(curr_item)\n        \n        elif ( tags ):\n            for tag in tags.split(','):\n                tag = tag.strip()\n                if ( self.isTagValid(tag) ):\n                    self.addTag(tag)\n            \n        else:\n            event.accept()", "response": "Handles the drop event."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfiltering the event for the object and event.", "response": "def eventFilter(self, object, event):\r\n        \"\"\"\r\n        Filters the key press event on the editor object to look for backspace\r\n        key strokes on blank editors to remove previous tags.\r\n        \r\n        :param      object | <QObject>\r\n                    event | <QEvent>\r\n        \r\n        :return     <bool> | consumed\r\n        \"\"\"\r\n        if event.type() == event.KeyPress:\r\n            if event.key() == Qt.Key_Backspace:\r\n                is_line_edit = isinstance(object, QLineEdit)\r\n                if not (is_line_edit and object.text()):\r\n                    if self.count() > 1:\r\n                        self.takeItem(self.count() - 2)\r\n                        object.setFocus()\r\n            \r\n            elif event.key() in (Qt.Key_Return, Qt.Key_Enter):\r\n                self.finishEditing(object.text())\r\n                return True\r\n        \r\n            \r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef finishEditing(self, tag):\r\n        curr_item = self.currentItem()\r\n        create_item = self.createItem()\r\n        self.closePersistentEditor(curr_item)\r\n        \r\n        if curr_item == create_item:\r\n            self.addTag(tag)\r\n        \r\n        elif self.isTagValid(tag):\r\n            curr_item.setText(tag)", "response": "Finishes editing the current item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handleTagChange( self, item ):\r\n        # :note PySide == operator not defined for QListWidgetItem.  In this\r\n        #       in this case, we're just checking if the object is the exact\r\n        #       same, so 'is' works just fine.\r\n        create_item = self.createItem()\r\n        if item is create_item:\r\n            self.addTag(create_item.text())\r\n        \r\n        elif self.isTagValid(item.text()):\r\n            item.setText(item.text())", "response": "Handles the tag change information for this object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck to see if the tag is valid or not.", "response": "def isTagValid( self, tag ):\r\n        \"\"\"\r\n        Checks to see if the inputed tag is valid or not.\r\n        \r\n        :param      tag | <str>\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        if ( self._options is not None and \\\r\n             not nativestring(tag) in self._options \\\r\n             and not self.isInsertAllowed() ):\r\n            return False\r\n        \n        elif ( self.isUnique() and self.hasTag(tag) ):\n            return False\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the item assigned to the given tag.", "response": "def itemFromTag( self, tag ):\r\n        \"\"\"\r\n        Returns the item assigned to the given tag.\r\n        \r\n        :param      tag | <str>\r\n        \r\n        :return     <XMultiTagItem> || None\r\n        \"\"\"\r\n        for row in range(self.count() - 1):\r\n            item = self.item(row)\r\n            if ( item and item.text() == tag ):\r\n                return item\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling the Ctrl + C and Ctrl + V events for copy & paste.", "response": "def keyPressEvent( self, event ):\n        \"\"\"\n        Handles the Ctrl+C/Ctrl+V events for copy & paste.\n        \n        :param      event | <QKeyEvent>\n        \"\"\"\n        if ( event.key() == Qt.Key_C and \\\n             event.modifiers() == Qt.ControlModifier ):\n            self.copy()\n            event.accept()\n            return\n            \n        elif ( event.key() == Qt.Key_V and \\\n             event.modifiers() == Qt.ControlModifier ):\n            self.paste()\n            event.accept()\n            return\n        \n        elif ( event.key() == Qt.Key_Delete ):\n            indexes = map(self.row, self.selectedItems())\n            for index in reversed(sorted(indexes)):\n                self.takeItem(index)\n            \n            event.accept()\n            return\n        \r\n        elif event.key() == Qt.Key_Backspace:\r\n            if self.count() > 1:\r\n                self.takeItem(self.count() - 2)\r\n                self.setFocus()\r\n        \n        super(XMultiTagEdit, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mimeData( self, items ):\n        text = []\n        for item in items:\n            text.append(nativestring(item.text()))\n        \n        data = QMimeData()\n        data.setText(','.join(text))\n        return data", "response": "Creates the mime data for the different items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mousePressEvent( self, event ):\r\n        item = self.itemAt(event.pos())\r\n        \r\n        # set the tag creation item as active\r\n        if item is None:\r\n            create_item = self.createItem()\r\n            if create_item:\r\n                self.setCurrentItem(create_item)\r\n                self.editItem(create_item)\r\n        \r\n        # check to see if we're removing a tag\r\n        else:\r\n            rect = self.visualItemRect(item)\r\n            if ( rect.right() - 14 < event.pos().x()  ):\r\n                # make sure the item is allowed to be removed via the widget\r\n                if ( self.itemsRemovable() ):\r\n                    self.takeItem(self.row(item))\r\n                \r\n                # emit the removed signal\r\n                if ( not self.signalsBlocked() ):\r\n                    self.tagRemoved.emit(item.text())\r\n                \r\n                event.ignore()\r\n                return\r\n        \r\n        super(XMultiTagEdit, self).mousePressEvent(event)", "response": "Handles the mouse press event."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npastes text from the clipboard.", "response": "def paste( self ):\n        \"\"\"\n        Pastes text from the clipboard.\n        \"\"\"\n        text = nativestring(QApplication.clipboard().text())\n        for tag in text.split(','):\n            tag = tag.strip()\n            if ( self.isTagValid(tag) ):\n                self.addTag(tag)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resizeEvent(self, event):\r\n        curr_item = self.currentItem()\r\n        self.closePersistentEditor(curr_item)\r\n        \r\n        super(XMultiTagEdit, self).resizeEvent(event)", "response": "Overloads the resize event to control if we are still editing."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the text completer for this tag widget to the inputed completer.", "response": "def setCompleter( self, completer ):\r\n        \"\"\"\r\n        Sets the text completer for this tag widget to the inputed completer.\r\n        \r\n        :param      completer | <QCompleter>\r\n        \"\"\"\r\n        if ( self._completer == completer ):\r\n            return\r\n        elif ( self._completer ):\r\n            self._completer.activated.disconnect(self.finishEditing)\r\n        \r\n        self._completer = completer\r\n        \r\n        if ( completer ):\r\n            completer.activated.connect(self.finishEditing)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setEditable(self, state):\r\n        self._editable = state\r\n        if state:\r\n            self.setEditTriggers(self.AllEditTriggers)\r\n        else:\r\n            self.setEditTriggers(self.NoEditTriggers)", "response": "Sets whether or not the user can edit the items in the list by changing the editTriggers of the items in the list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the list of options for this widget.", "response": "def setOptions( self, options ):\r\n        \"\"\"\r\n        Sets the tag option list for this widget.  If used, tags need to be\r\n        found within the list of options when added.\r\n        \r\n        :param      options | [<str>, ..]\r\n        \"\"\"\r\n        self._options = map(str, options)\r\n        \r\n        if ( options ):\n            completer = QCompleter(options, self)\n            completer.setCompletionMode(QCompleter.InlineCompletion)\r\n            self.setCompleter(completer)\r\n        else:\r\n            self.setCompleter(None)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setTags( self, tags ):\r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        \r\n        self.clear()\r\n        for tag in tags:\r\n            self.addItem(XMultiTagItem(tag, self))\r\n        \r\n        self.blockSignals(False)\r\n        self.setUpdatesEnabled(True)", "response": "Sets the tags assigned to this item to the inputed list of tags."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the view mode for this widget to the inputed mode.", "response": "def setViewMode( self, viewMode ):\n        \"\"\"\n        Sets the view mode for this widget to the inputed mode.\n        \n        :param      viewMode | <QListWidget.ViewMode>\n        \"\"\"\n        ddrop_mode = self.dragDropMode()\n        super(XMultiTagEdit, self).setViewMode(viewMode)\n        self.setDragDropMode(ddrop_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all the tags assigned to this widget.", "response": "def tags( self ):\r\n        \"\"\"\r\n        Returns a list of all the tags assigned to this widget.\r\n        \r\n        :return     [<str>, ..]\r\n        \"\"\"\r\n        item  = self.item(self.count() - 1)\r\n        count = self.count()\r\n        if ( item is self._createItem ):\r\n            count -= 1\r\n        \r\n        return [nativestring(self.item(row).text()) for row in range(count)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef takeTag( self, tag ):\r\n        for row in range(self.count() - 1):\r\n            item = self.item(row)\r\n            if ( item and item.text() == tag ):\r\n                self.takeItem(row)\r\n                if ( not self.signalsBlocked() ):\r\n                    self.tagRemoved.emit(tag)\r\n                return item\r\n        return None", "response": "Removes the specified tag from the system. Returns the item that was removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Publish(self, request, context):\n        LOG.debug(\"Publish called\")\n        try:\n            self.plugin.publish(\n                [Metric(pb=m) for m in request.Metrics],\n                ConfigMap(pb=request.Config)\n            )\n            return ErrReply()\n        except Exception as err:\n            msg = \"message: {}\\n\\nstack trace: {}\".format(\n                err, traceback.format_exc())\n            return ErrReply(error=msg)", "response": "Dispatches the request to the plugins publish method"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef allLocales(self):\r\n        if self._allLocales:\r\n            return self._allLocales\r\n        \r\n        expr = re.compile('[a-z]+_[A-Z]+')\r\n        locales = babel.core.localedata.locale_identifiers()\r\n        babel_locales = {}\r\n        for locale in locales:\r\n            if expr.match(locale):\r\n                babel_locale = babel.Locale.parse(locale)\r\n                if babel_locale.territory and babel_locale.language:\r\n                    babel_locales[babel_locale.territory] = babel_locale\r\n        \r\n        babel_locales = babel_locales.values()\r\n        babel_locales.sort(key=str)\r\n        self._allLocales = babel_locales\r\n        return self._allLocales", "response": "Returns all the available locales in the language table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current locale for this box or None if no locale is set.", "response": "def currentLocale(self):\r\n        \"\"\"\r\n        Returns the current locale for this box.\r\n        \r\n        :return     <babel.Locale> || None\r\n        \"\"\"\r\n        try:\r\n            return babel.Locale.parse(self.itemData(self.currentIndex()))\r\n        except ImportError, err:\r\n            log.error('babel is not installed.')\r\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrefresh the contents of the current box based on the parameters.", "response": "def refresh(self):\r\n        \"\"\"\r\n        Reloads the contents for this box based on the parameters.\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        self.setDirty(False)\r\n        self.blockSignals(True)\r\n        self.setUpdatesEnabled(False)\r\n        self.clear()\r\n        \r\n        locales = self._availableLocales\r\n        if not locales:\r\n            locales = self.allLocales()\r\n        \r\n        if not self.showLanguage():\r\n            if self.isTranslated():\r\n                sorter = lambda x: x.get_territory_name(base)\r\n            else:\r\n                sorter = lambda x: x.get_territory_name()\r\n        else:\r\n            if self.isTranslated():\r\n                sorter = lambda x: x.get_language_name(base)\r\n            else:\r\n                sorter = lambda x: x.get_language_name()\r\n        \r\n        locales = sorted(locales, key=sorter)\r\n        index = 0\r\n        for i, locale in enumerate(locales):\r\n            babel_locale = babel.Locale.parse(locale)\r\n            code = '{0}_{1}'.format(babel_locale.language,\r\n                                    babel_locale.territory)\r\n            keys = {}\r\n            if self.isTranslated():\r\n                keys['lang'] = babel_locale.get_language_name(base)\r\n                keys['territory'] = babel_locale.get_territory_name(base)\r\n                keys['script'] = babel_locale.get_script_name(base)\r\n            else:\r\n                keys['lang'] = babel_locale.get_language_name()\r\n                keys['territory'] = babel_locale.get_territory_name()\r\n                keys['script'] = babel_locale.get_script_name()\r\n            \r\n            if self.showLanguage():\r\n                opts = ''\r\n                if self.showScriptName() and keys['script']:\r\n                    opts += keys['script']\r\n                if self.showTerritory() and keys['territory']:\r\n                    if opts:\r\n                        opts += ', '\r\n                    opts += keys['territory']\r\n                if opts:\r\n                    opts = ' (' + opts + ')'\r\n                \r\n                label = keys['lang'] + opts\r\n                \r\n            elif self.showTerritory():\r\n                label = keys['territory']\r\n            else:\r\n                label = code\r\n            \r\n            self.addItem(label)\r\n            self.setItemData(i, wrapVariant(str(code)))\r\n            \r\n            name = babel_locale.territory.lower()\r\n            ico = 'img/flags/{0}.png'.format(name)\r\n            flag = QtGui.QIcon(resources.find(ico))\r\n            if flag.isNull():\r\n                ico = 'img/flags/_United Nations.png'\r\n                flag = QtGui.QIcon(resources.find(ico))\r\n            \r\n            self.setItemIcon(i, flag)\r\n            if code == self.baseLocale():\r\n                index = i\r\n        \r\n        self.setCurrentIndex(index)\r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setAvailableLocales(self, locales):\r\n        try:\r\n            expr = re.compile('[a-z]+_[A-Z]+')\r\n            babel_locales = []\r\n            for locale in locales:\r\n                if not expr.match(locale):\r\n                    continue\r\n                \r\n                try:\r\n                    babel_locale = babel.Locale.parse(str(locale))\r\n                except (babel.UnknownLocaleError, StandardError):\r\n                    continue\r\n                \r\n                if babel_locale.territory and babel_locale.language:\r\n                    babel_locales.append(babel_locale)\r\n            \r\n            babel_locales.sort(key=str)\r\n        except ImportError:\r\n            babel_locales = []\r\n        \r\n        self._availableLocales = babel_locales\r\n        self.setDirty()", "response": "Sets the list of available locales for displaying the given locale information for the given list of locales."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the base locale that is used with this widget.", "response": "def setBaseLocale(self, locale):\r\n        \"\"\"\r\n        Sets the base locale that is used with in this widget.  All displayed\r\n        information will be translated to this locale.\r\n        \r\n        :param      locale | <str>\r\n        \"\"\"\r\n        locale = str(locale)\r\n        if self._baseLocale == locale:\r\n            return\r\n        \r\n        try:\r\n            babel.Locale.parse(locale)\r\n        except (babel.UnknownLocaleError, StandardError):\r\n            return False\r\n        \r\n        self._baseLocale = locale\r\n        self.setCurrentLocale(locale)\r\n        self.setDirty()\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCurrentLocale(self, locale):\r\n        locale = str(locale)\r\n        for i in xrange(self.count()):\r\n            if self.itemData(i) == locale:\r\n                self.setCurrentIndex(i)\r\n                return True\r\n        return False", "response": "Sets the current locale for this box to the inputed locale."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setShowLanguage(self, state):\r\n        if state == self._showLanguage:\r\n            return\r\n        \r\n        self._showLanguage = state\r\n        self.setDirty()", "response": "Sets the display mode for this widget to the inputed mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setShowScriptName(self, state):\r\n        if state == self._showScriptName:\r\n            return\r\n        \r\n        self._showScriptName = state\r\n        self.setDirty()", "response": "Sets the display mode for this widget to the inputed mode."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setShowTerritory(self, state):\r\n        if state == self._showTerritory:\r\n            return\r\n        \r\n        self._showTerritory = state\r\n        self.setDirty()", "response": "Sets the display mode for this widget to the inputed mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n\n    # Wrap sys stdout for python 2, so print can understand unicode.\n    if sys.version_info[0] < 3:\n        sys.stdout = codecs.getwriter(\"utf-8\")(sys.stdout)\n\n    options = docopt.docopt(__doc__,\n                            help=True,\n                            version='template_remover v%s' % __VERSION__)\n\n    print(template_remover.clean(io.open(options['FILENAME']).read()))\n\n    return 0", "response": "Entry point for remove_template."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate given value against schema. TYPE_RANGE data type. Raises TypeError ValueError if something is wrong. Returns None if everything is OK.", "response": "def validate_range_value(value):\n    \"\"\"\n    Validates given value against `Schema.TYPE_RANGE` data type. Raises\n    TypeError or ValueError if something is wrong. Returns None if everything\n    is OK.\n    \"\"\"\n    if value == (None, None):\n        return\n\n    if not hasattr(value, '__iter__'):\n        raise TypeError('Range value must be an iterable, got \"%s\".' % value)\n    if not 2 == len(value):\n        raise ValueError('Range value must consist of two elements, got %d.' %\n                         len(value))\n    if not all(isinstance(x, (int,float)) for x in value):\n        raise TypeError('Range value must consist of two numbers, got \"%s\" '\n                        'and \"%s\" instead.' % value)\n    if not value[0] <= value[1]:\n        raise ValueError('Range must consist of min and max values (min <= '\n                         'max) but got \"%s\" and \"%s\" instead.' % value)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving given EAV attribute with given value for given entity.", "response": "def save_attr(self, entity, value):\n        \"\"\"\n        Saves given EAV attribute with given value for given entity.\n\n        If schema is not many-to-one, the value is saved to the corresponding\n        Attr instance (which is created or updated).\n\n        If schema is many-to-one, the value is processed thusly:\n\n        * if value is iterable, all Attr instances for corresponding managed m2m\n          schemata are updated (those with names from the value list are set to\n          True, others to False). If a list item is not in available choices,\n          ValueError is raised;\n        * if the value is None, all corresponding Attr instances are reset to False;\n        * if the value is neither a list nor None, it is wrapped into a list and\n          processed as above (i.e. \"foo\" --> [\"foo\"]).\n        \"\"\"\n\n        if self.datatype == self.TYPE_MANY:\n            self._save_m2m_attr(entity, value)\n        else:\n            self._save_single_attr(entity, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave a single attribute for given entity.", "response": "def _save_single_attr(self, entity, value=None, schema=None,\n                          create_nulls=False, extra={}):\n        \"\"\"\n        Creates or updates an EAV attribute for given entity with given value.\n\n        :param schema: schema for attribute. Default it current schema instance.\n        :param create_nulls: boolean: if True, even attributes with value=None\n            are created (by default they are skipped).\n        :param extra: dict: additional data for Attr instance (e.g. title).\n        \"\"\"\n        # If schema is not many-to-one, the value is saved to the corresponding\n        # Attr instance (which is created or updated).\n\n        schema = schema or self\n        lookups = dict(get_entity_lookups(entity), schema=schema, **extra)\n        try:\n            attr = self.attrs.get(**lookups)\n        except self.attrs.model.DoesNotExist:\n            attr = self.attrs.model(**lookups)\n        if create_nulls or value != attr.value:\n            attr.value = value\n            for k,v in extra.items():\n                setattr(attr, k, v)\n            attr.save()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self, force_eav=False, **kwargs):\n        # save entity\n        super(BaseEntity, self).save(**kwargs)\n\n        # TODO: think about use cases; are we doing it right?\n        #if not self.check_eav_allowed():\n        #    import warnings\n        #    warnings.warn('EAV attributes are going to be saved along with entity'\n        #                  ' despite %s.check_eav_allowed() returned False.'\n        #                  % type(self), RuntimeWarning)\n\n\n        # create/update EAV attributes\n        for schema in self.get_schemata():\n            value = getattr(self, schema.name, None)\n            schema.save_attr(self, value)", "response": "Saves the entity instance and creates or updates related attribute instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pickColor( self ):\n        color = QColorDialog.getColor( self.color(), self )\n        \n        if ( color.isValid() ):\n            self.setColor(color)", "response": "Prompts the user to select a color for this button."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setColor( self, color ):\n        self._color = color\n        palette     = self.palette()\n        palette.setColor(palette.Button, color)\n        self.setPalette(palette)\n        \n        if ( not self.signalsBlocked() ):\n            self.colorChanged.emit(color)", "response": "Sets the color value for this button to the given color."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrency( self, currency ):\r\n        self._currency = currency\r\n        self.setValue(self.value())", "response": "Sets the currency for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value for this widgets text.", "response": "def valueFromText( self, text ):\r\n        \"\"\"\r\n        Returns the value for this widgets text.\r\n        \r\n        :param      text | <str>\r\n        \r\n        :return     <float>\r\n        \"\"\"\r\n        value, currency = projex.money.fromString(text)\r\n        \r\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new region to the zone at the given row and column.", "response": "def addRegion(self, name, text, row, column):\r\n        \"\"\"\r\n        Adds a new region for this zone at the given row and column.\r\n        \r\n        :param      name   | <str>\r\n                    text   | <str>\r\n                    row    | <int>\r\n                    column | <int>\r\n        \"\"\"\r\n        region = XDropZoneRegion(self)\r\n        region.setObjectName(name)\r\n        region.setText(text)\r\n        region.hide()\r\n        self.layout().addWidget(region, row, column)\r\n        return region"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef currentRegion(self):\r\n        pos = QtGui.QCursor.pos()\r\n        pos = self.mapFromGlobal(pos)\r\n        for region in self.regions():\r\n            if region.testHovered(pos):\r\n                return region\r\n        return None", "response": "Returns the current region based on the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setMovie( self, movie ):\n        if ( self._movie ):\n            self._movie.frameChanged.disconnect(self.updateIcon)\n            \n        self._movie = movie\n        \n        if ( self._movie ):\n            self._movie.frameChanged.connect(self.updateIcon)", "response": "Sets the movie for this icon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget adapter data by its id.", "response": "def by_id(self, id):\n        \"\"\"get adapter data by its id.\"\"\"\n        path = partial(_path, self.adapter)\n        path = path(id)\n        return self._get(path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting adapter data by name.", "response": "def by_name(self, name, archived=False, limit=None, page=None):\n        \"\"\"get adapter data by name.\"\"\"\n        if not archived:\n            path = _path(self.adapter)\n        else:\n            path = _path(self.adapter, 'archived')\n        return self._get(path, name=name, limit=limit, page=page)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(self, archived=False, limit=None, page=None):\n        path = partial(_path, self.adapter)\n        if not archived:\n            path = _path(self.adapter)\n        else:\n            path = _path(self.adapter, 'archived')\n        return self._get(path, limit=limit, page=page)", "response": "get all adapter data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef by_name(self, name, archived=False, limit=None, page=None):\n        # this only works with the exact name\n        return super(Projects, self).by_name(name, archived=archived,\n                                             limit=limit, page=page)", "response": "return a project by it s name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query(self, **kwargs):\n        path = partial(_path, self.adapter)\n        path = _path(self.adapter)\n        return self._get(path, **kwargs)", "response": "a free query for the object category"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new entry in the cache.", "response": "def create(self, date_at=None, minutes=0, note='', user_id=None,\n               project_id=None, service_id=None):\n        \"\"\" date_at - date of time entry. Format YYYY-MM-DD. default: today\n            minutes - default: 0\n            note - default: '' (empty string)\n            user_id - default: actual user id (only admin users can edit this)\n            project_id - default: None\n            service_id - default: None\n        \"\"\"\n        keywords = {\n            'date_at': date_at,\n            'minutes': minutes,\n            'note': note,\n            'user_id': user_id,\n            'project_id': project_id,\n            'service_id': service_id,\n        }\n        foo = dict()\n        foo['time_entry'] = keywords\n        path = partial(_path, self.adapter)\n        path = _path(self.adapter)\n        return self._post(path, **foo)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, id):\n        path = partial(_path, self.adapter)\n        path = path(id)\n        return self._delete(path)", "response": "delete a time entry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef at(self, year, month, day):\n        path = partial(_path, self.adapter)\n        path = partial(path, int(year))\n        path = partial(path, int(month))\n        path = path(int(day))\n        return self._get(path)", "response": "Get the time entries by year month and day."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self, id):\n        path = partial(_path, self.adapter)\n        path = path(id)\n        return self._put(path)", "response": "start a specific tracker."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(cls, string):\n        if string in STR_TO_OP_FUNC:\n            return cls(STR_TO_OP_FUNC[string], string)\n        else:\n            raise InvalidOperatorExpression(string)", "response": "Parses a string and returns an instance of Operator object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverloads the paint event to draw rounded edges on this widget.", "response": "def paintEvent( self, event ):\n        \"\"\"\n        Overloads the paint event to draw rounded edges on this widget.\n        \n        :param      event | <QPaintEvent>\n        \"\"\"\n        super(XRolloutItem, self).paintEvent(event)\n        \r\n        with XPainter(self) as painter:\n            w = self.width() - 3\n            h = self.height() - 3\n            \n            color = self.palette().color(QPalette.Midlight)\n            color = color.darker(180)\n            pen = QPen(color)\n            pen.setWidthF(0.5)\n            \n            painter.setPen(pen)\n            painter.setBrush(self.palette().color(QPalette.Midlight))\n            painter.setRenderHint(XPainter.Antialiasing)\n            painter.drawRoundedRect(1, 1, w, h, 10, 10)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset whether or not this rollout is in the expanded state.", "response": "def setExpanded( self, state ):\n        \"\"\"\n        Sets whether or not this rollout is in the expanded state.\n        \n        :param      state | <bool>\n        \"\"\"\n        self._expanded = state\n        self._widget.setVisible(state)\n        \n        if ( state ):\n            ico = projexui.resources.find('img/treeview/triangle_down.png')\n        else:\n            ico = projexui.resources.find('img/treeview/triangle_right.png')\n        \n        self._titleButton.setIcon(QIcon(ico))\n        \n        # emit the signals for this widget\n        rollout = self.rolloutWidget()\n        if ( not rollout.signalsBlocked() ):\n            index = rollout.widget().layout().indexOf(self)\n            \n            rollout.itemCollapsed.emit(index)\n            rollout.itemExpanded.emit(index)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear out all of the rollout items from the widget.", "response": "def clear( self ):\n        \"\"\"\n        Clears out all of the rollout items from the widget.\n        \"\"\"\n        self.blockSignals(True)\n        self.setUpdatesEnabled(False)\n        for child in self.findChildren(XRolloutItem):\n            child.setParent(None)\n            child.deleteLater()\n        self.setUpdatesEnabled(True)\n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new widget to the rollout system.", "response": "def addRollout( self, widget, title, expanded = False ):\n        \"\"\"\n        Adds a new widget to the rollout system.\n        \n        :param      widget      | <QWidget>\n                    title       | <str>\n                    expanded    | <bool>\n        \n        :return     <XRolloutItem>\n        \"\"\"\n        layout = self.widget().layout()\n        item = XRolloutItem(self, widget, title, expanded)\n        layout.insertWidget(layout.count() - 1, item)\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef itemAt( self, index ):\n        layout = self.widget().layout()\n        if ( 0 <= index and index < (layout.count() - 1) ):\n            return layout.itemAt(index).widget()\n        return None", "response": "Returns the rollout item at the inputed index."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef items( self ):\n        layout = self.widget().layout()\n        return [layout.itemAt(i).widget() for i in range(layout.count()-1)]", "response": "Returns all the rollout items for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the widget from the rollout at the inputed index.", "response": "def takeAt( self, index ):\n        \"\"\"\n        Removes the widget from the rollout at the inputed index.\n        \n        :param      index | <int>\n        \n        :return     <QWidget> || None\n        \"\"\"\n        layout = self.widget().layout()\n        item = layout.takeAt(index)\n        if ( not item ):\n            return None\n        \n        return item.widget().widget()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the range of values for this axis based on the dataset value amount.", "response": "def calculateRange(self, values):\r\n        \"\"\"\r\n        Calculates the range of values for this axis based on the dataset\r\n        value amount.\r\n        \r\n        :param      values | [<variant>, ..]\r\n        \"\"\"\r\n        self.reset()\r\n        self._values = list(set(values))\r\n        self._values.sort(key=lambda x: values.index(x))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef labels(self):\r\n        if self._labels is None:\r\n            self._labels = map(self.labelFormat().format, self.values())\r\n        return self._labels", "response": "Returns the list of labels that will be used to represent\r\n        this axis s information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef labelCount(self):\r\n        if self._labels is None:\r\n            count = self.maximumLabelCount()\r\n            if count is None:\r\n                return 1\r\n            else:\r\n                return count\r\n        \r\n        return len(self._labels)", "response": "Returns the number of labels for this axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the minimum width required on this renderers font size.", "response": "def minimumLabelWidth(self):\r\n        \"\"\"\r\n        Returns the minimum label width required on this renderers font size.\r\n        \r\n        :param      labels | [<str>, ..]\r\n        \"\"\"\r\n        min_w = 0\r\n        metrics = QFontMetrics(self.labelFont())\r\n        for label in self.labels():\r\n            min_w = max(min_w, metrics.width(label))\r\n        \r\n        return max(self._minimumLabelWidth,\r\n                   min_w + self.horizontalLabelPadding())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef minimumLabelHeight(self):\r\n        metrics = QFontMetrics(self.labelFont())\r\n        return max(self._minimumLabelHeight,\r\n                   metrics.height() + self.verticalLabelPadding())", "response": "Returns the minimum height that will be required based on this font size and the labels list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef percentAt(self, value):\r\n        if value is None:\r\n            return 0.0\r\n        \r\n        values = self.values()\r\n        \r\n        try:\r\n            return float(values.index(value)) / (len(values) - 1)\r\n        except ValueError:\r\n            return 0.0\r\n        except ZeroDivisionError:\r\n            return 1.0", "response": "Returns the percentage of the given value lies between the given minimum and maximum values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the percentage of total time the inputed value is in relation to the list of other values.", "response": "def percentOfTotal(self, value, values):\r\n        \"\"\"\r\n        Calculates the percent the inputed value is in relation to the\r\n        list of other values.\r\n        \r\n        :param      value  | <variant>\r\n                    values | [<variant>, ..]\r\n        \r\n        :return     <float> 0.0 - 1.0\r\n        \"\"\"\r\n        try:\r\n            return float(values.index(value) + 1) / len(values)\r\n        except (ZeroDivisionError, ValueError):\r\n            return 0.0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the title for this axis.", "response": "def title(self):\r\n        \"\"\"\r\n        Returns the title for this axis.\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        if not self._title:\r\n            return projex.text.pretty(self.name())\r\n        return self._title"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the values for this axis.", "response": "def values(self):\r\n        \"\"\"\r\n        Returns the values for this axis.\r\n        \r\n        :return     [<variant>, ..]\r\n        \"\"\"\r\n        if self._values is None:\r\n            self._values = self.calculateValues()\r\n        return self._values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the value at the inputed percent.", "response": "def valueAt(self, percent):\r\n        \"\"\"\r\n        Returns the value at the inputed percent.\r\n        \r\n        :param     percent | <float>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        values = self.values()\r\n        if percent < 0:\r\n            index = 0\r\n        elif percent > 1:\r\n            index = -1\r\n        else:\r\n            index = percent * (len(values) - 1)\r\n        \r\n        # allow some floating point errors for the index (30% left or right)\r\n        remain = index % 1\r\n        if remain < 0.3 or 0.7 < remain:\r\n            try:\r\n                return values[int(round(index))]\r\n            except IndexError:\r\n                return None\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the text of the current edit.", "response": "def acceptEdit(self):\r\n        \"\"\"\r\n        Accepts the current edit for this label.\r\n        \"\"\"\r\n        if not self._lineEdit:\r\n            return\r\n        \r\n        self.setText(self._lineEdit.text())\r\n        self._lineEdit.hide()\r\n        \r\n        if not self.signalsBlocked():\r\n            self.editingFinished.emit(self._lineEdit.text())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef beginEdit(self):\r\n        if not self._lineEdit:\r\n            return\r\n        \r\n        self.aboutToEdit.emit()\r\n        \r\n        self._lineEdit.setText(self.editText())\r\n        self._lineEdit.show()\r\n        self._lineEdit.selectAll()\r\n        self._lineEdit.setFocus()", "response": "Starts editing for the label."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the event should be handled for the object and False otherwise.", "response": "def eventFilter( self, object, event ):\r\n        \"\"\"\r\n        Filters the event for the inputed object looking for escape keys.\r\n        \r\n        :param      object | <QObject>\r\n                    event  | <QEvent>\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        if event.type() == event.KeyPress:\r\n            if event.key() == Qt.Key_Escape:\r\n                self.rejectEdit()\r\n                return True\r\n            \r\n            elif event.key() in (Qt.Key_Return, Qt.Key_Enter):\r\n                self.acceptEdit()\r\n                return True\r\n        \r\n        elif event.type() == event.FocusOut:\r\n            self.acceptEdit()\r\n        \r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprompting the editing process if the label is editable.", "response": "def mouseDoubleClickEvent(self, event):\r\n        \"\"\"\r\n        Prompts the editing process if the label is editable.\r\n        \r\n        :param      event | <QMouseDoubleClickEvent>\r\n        \"\"\"\r\n        if self.isEditable():\r\n            self.beginEdit()\r\n        \r\n        super(XLabel, self).mouseDoubleClickEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncancels the edit for this label.", "response": "def rejectEdit(self):\r\n        \"\"\"\r\n        Cancels the edit for this label.\r\n        \"\"\"\r\n        if self._lineEdit:\r\n            self._lineEdit.hide()\r\n            self.editingCancelled.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setEditable(self, state):\r\n        self._editable = state\r\n        \r\n        if state and not self._lineEdit:\r\n            self.setLineEdit(XLineEdit(self))\r\n        \r\n        elif not state and self._lineEdit:\r\n            self._lineEdit.close()\r\n            self._lineEdit.setParent(None)\r\n            self._lineEdit.deleteLater()\r\n            self._lineEdit = None", "response": "Sets whether or not this label should be editable or not."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setLineEdit(self, lineEdit):\r\n        self._lineEdit = lineEdit\r\n        if lineEdit:\r\n            lineEdit.setFont(self.font())\r\n            lineEdit.installEventFilter(self)\r\n            lineEdit.resize(self.size())\r\n            lineEdit.hide()", "response": "Sets the line edit instance for this label."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef buildData(self, key, default=None):\r\n        return self._buildData.get(nativestring(key), default)", "response": "Returns the build information for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the grid data before rendering.", "response": "def calculate(self, scene, xaxis, yaxis):\r\n        \"\"\"\r\n        Calculates the grid data before rendering.\r\n        \r\n        :param      scene       | <XChartScene>\r\n                    xaxis       | <XChartAxis>\r\n                    yaxis       | <XChartAxis>\r\n        \"\"\"\r\n        # build the grid location\r\n        sceneRect = scene.sceneRect()\r\n        \r\n        # process axis information\r\n        h_lines  = []\r\n        h_alt    = []\r\n        h_labels = []\r\n        v_lines  = []\r\n        v_alt    = []\r\n        v_labels = []\r\n        \r\n        xlabels   = []\r\n        xcount    = 1\r\n        xsections = 1\r\n        xdelta    = 0\r\n        xdeltamin = 0\r\n        \r\n        ylabels   = []\r\n        ycount    = 1\r\n        ysections = 1\r\n        ydeltamin = 0\r\n        ydelta    = 0\r\n        \r\n        axis_lft  = 0\r\n        axis_rht  = 0\r\n        axis_bot  = 0\r\n        axis_top  = 0\r\n        \r\n        # precalculate xaxis information for width changes\r\n        if xaxis and self.showXAxis():\r\n            size = sceneRect.width()\r\n            xdeltamin = xaxis.minimumLabelWidth()\r\n            result = self.calculateAxis(xaxis, size, xdeltamin)\r\n            \r\n            xlabels, xcount, xsections, newWidth, xdelta = result\r\n            if newWidth != size:\r\n                sceneRect.setWidth(newWidth)\r\n        \r\n        # precalculate yaxis information for height changes\r\n        if yaxis and self.showYAxis():\r\n            size = sceneRect.height()\r\n            ydeltamin = yaxis.minimumLabelHeight()\r\n            result = self.calculateAxis(yaxis, size, ydeltamin)\r\n            \r\n            ylabels, ycount, ysections, newHeight, ydelta = result\r\n            if newHeight != size:\r\n                sceneRect.setHeight(newHeight)\r\n        \r\n        # generate the xaxis\r\n        if xaxis and self.showXAxis():\r\n            x        = sceneRect.left() + xdeltamin / 2\r\n            axis_lft = x\r\n            axis_rht = x\r\n            alt      = False\r\n            \r\n            for i in range(xcount):\r\n                v_lines.append(QLineF(x, sceneRect.top(),\r\n                                      x, sceneRect.bottom()))\r\n                \r\n                # store alternate info\r\n                if alt:\r\n                    alt_rect = QRectF(x - xdelta, sceneRect.top(),\r\n                                      xdelta, sceneRect.height())\r\n                    v_alt.append(alt_rect)\r\n                \r\n                # store label information\r\n                v_labels.append((x, xdelta, xlabels[i]))\r\n                axis_rht = x\r\n                \r\n                x += xdelta\r\n                alt = not alt\r\n        \r\n        # generate the yaxis\r\n        if yaxis and self.showYAxis():\r\n            y        = sceneRect.bottom() - ydeltamin / 2\r\n            axis_bot = y\r\n            axis_top = y\r\n            alt      = False\r\n            \r\n            for i in range(ycount):\r\n                h_lines.append(QLineF(sceneRect.left(), y,\r\n                                      sceneRect.right(), y))\r\n                \r\n                # store alternate color\r\n                if alt:\r\n                    alt_rect = QRectF(sceneRect.left(), y,\r\n                                      sceneRect.width(), ydelta)\r\n                    h_alt.append(alt_rect)\r\n                \r\n                # store the vertical information\r\n                h_labels.append((y, ydelta, ylabels[i]))\r\n                axis_top = y\r\n                \r\n                y -= ydelta\r\n                alt = not alt\r\n        \r\n        # assign the build data\r\n        self._buildData['grid_h_lines']  = h_lines\r\n        self._buildData['grid_h_alt']    = h_alt\r\n        self._buildData['grid_h_labels'] = h_labels\r\n        self._buildData['grid_v_lines']  = v_lines\r\n        self._buildData['grid_v_alt']    = v_alt\r\n        self._buildData['grid_v_labels'] = v_labels\r\n        self._buildData['grid_rect']     = sceneRect\r\n        self._buildData['axis_rect']     = QRectF(axis_lft, axis_top,\r\n                                                  axis_rht - axis_lft,\r\n                                                  axis_bot - axis_top)\r\n        \r\n        scene.setSceneRect(sceneRect)\r\n        return sceneRect"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the rendering information for the given axis based on the current size and the minimum required delta.", "response": "def calculateAxis(self, axis, size, minDelta):\r\n        \"\"\"\r\n        Calculates the rendering information for the given axis based on\r\n        the current size and the minimum required delta.\r\n        \r\n        :param      axis     | <XChartAxis>\r\n                    size     | <int>\r\n                    minDelta | <int>\r\n        \r\n        :return     ([<str>, ..] labels, \\\r\n                     <int> count, \\\r\n                     <int> sections, \\\r\n                     <int> newSize, \\\r\n                     <int> delta)\r\n        \"\"\"\r\n        labels   = axis.labels()\r\n        count    = len(labels)\r\n        sections = max((count - 1), 1)\r\n        newSize  = size\r\n        delta    = (size - minDelta) / sections\r\n        \r\n        # ensure the sizes fit within our specs\r\n        if labels and delta < minDelta and axis.isDynamicScalingEnabled():\r\n            orig = labels[:]\r\n            total = count - count % 2 # make sure we at least get a 2\r\n            step_range = range(2, total / 2 + 1)\r\n            steps = [i for i in step_range if not (total / float(i)) % 1]\r\n            \r\n            for step in steps:\r\n                labels = orig[::step]\r\n                if not orig[-1] in labels:\r\n                    labels.append(orig[-1])\r\n                count = len(labels)\r\n                sections = max((count - 1), 1)\r\n                delta = (size - minDelta) / sections\r\n                \r\n                if minDelta < delta:\r\n                    break\r\n            \r\n            if delta < minDelta:\r\n                labels = [orig[0], orig[-1]]\r\n                count = 2\r\n                sections = 1\r\n                delta = (size - minDelta) / sections\r\n        \r\n        if delta < minDelta:\r\n            newSize = (minDelta * sections) + minDelta\r\n            delta = minDelta\r\n        \r\n        return (labels, count, sections, newSize, delta)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculateDatasetItems(self, scene, datasets):\r\n        dataitems = scene.datasetItems()\r\n        olditems = set(dataitems.keys()).difference(datasets)\r\n        newitems = set(datasets).difference(dataitems.keys())\r\n        \r\n        for dataset in olditems:\r\n            scene.removeItem(dataitems[dataset])\r\n        \r\n        for dataset in newitems:\r\n            dataitems[dataset] = scene.addDataset(dataset)\r\n        \r\n        return dataitems", "response": "Updates the given datasets together with the given scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drawAxis(self, painter, rect, axis):\r\n        if not axis:\r\n            return\r\n        \r\n        # draw the axis lines\r\n        painter.save()\r\n        pen = QPen(self.axisColor())\r\n        pen.setWidth(3)\r\n        painter.setPen(pen)\r\n        \r\n        # draw the vertical line\r\n        if axis.orientation() == Qt.Vertical:\r\n            line = QLineF(rect.right(), rect.top(),\r\n                          rect.right(), rect.bottom())\r\n            \r\n            painter.drawLine(line)\r\n            painter.setFont(axis.labelFont())\r\n            for y, height, label in self._buildData.get('grid_h_labels', []):\r\n                painter.drawText(0, y - height / 2.0, rect.width() - 3, height,\r\n                                 Qt.AlignRight | Qt.AlignVCenter, label)\r\n            \r\n            painter.translate(0, rect.center().y())\r\n            painter.rotate(-90)\r\n            \r\n            painter.setFont(axis.titleFont())\r\n            painter.drawText(-rect.height()/2, 0, rect.height(), rect.width(),\r\n                             Qt.AlignHCenter | Qt.AlignTop, axis.title())\r\n            \r\n        # draw the horizontal line\r\n        else:\r\n            line = QLineF(rect.left(), rect.top(),\r\n                          rect.right(), rect.top())\r\n            \r\n            painter.setFont(axis.titleFont())\r\n            painter.drawText(rect,\r\n                             Qt.AlignHCenter | Qt.AlignBottom,\r\n                             axis.title())\r\n            \r\n            painter.drawLine(line)\r\n            painter.setFont(axis.labelFont())\r\n            for x, width, label in self._buildData.get('grid_v_labels', []):\r\n                painter.drawText(x - width / 2.0, 3, width, rect.height() - 6,\r\n                                 Qt.AlignHCenter | Qt.AlignTop, label)\r\n        painter.restore()", "response": "Draws the horizontal or vertical axis for the given axis."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef drawGrid(self, painter, rect, showGrid, showColumns, showRows):\r\n        if not (self.showGrid() and showGrid):\r\n            return\r\n        \r\n        # saves the painter state before continuing\r\n        painter.save()\r\n        \r\n        # draw the grid data\r\n        painter.setBrush(self.alternateColor())\r\n        painter.setPen(Qt.NoPen)\r\n        \r\n        # draw alternating rows\r\n        if self.alternatingRowColors():\r\n            painter.drawRects(self._buildData.get('grid_h_alt', []))\r\n        \r\n        # draw alternating columns\r\n        if self.alternatingColumnColors():\r\n            painter.drawRects(self._buildData.get('grid_v_alt', []))\r\n        \r\n        # draws the grid lines\r\n        painter.setPen(QPen(self.axisColor()))\r\n        grid = []\r\n        if self.showRows() and showRows:\r\n            grid += self._buildData.get('grid_h_lines', [])\r\n        if self.showColumns() and showColumns:\r\n            grid += self._buildData.get('grid_v_lines', [])\r\n        \r\n        if grid:\r\n            painter.drawLines(grid)\r\n        \r\n        # restores the painter when finished\r\n        painter.restore()", "response": "Draws the grid on the inputed painter"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pointAt(self, axes, axis_values):\r\n        point = QPointF()\r\n        \r\n        rect = self._buildData.get('axis_rect')\r\n        if not rect:\r\n            return point\r\n        \r\n        x_range = rect.right() - rect.left()\r\n        y_range = rect.bottom() - rect.top()\r\n        \r\n        for axis in axes:\r\n            if not axis.name() in axis_values:\r\n                continue\r\n            \r\n            perc = axis.percentAt(axis_values[axis.name()])\r\n            if axis.orientation() == Qt.Vertical:\r\n                point.setY(rect.bottom() - perc * y_range)\r\n            else:\r\n                point.setX(rect.left() + perc * x_range)\r\n        \r\n        return point", "response": "Returns the point that best represents this graph information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef valueAt(self, axes, point):\r\n        rect = self._buildData.get('axis_rect')\r\n        if not rect:\r\n            return dict([(axis.name(), None) for axis in axes])\r\n            \r\n        try:\r\n            x_perc = (point.x() - rect.left()) / (rect.right() - rect.left())\r\n        except ZeroDivisionError:\r\n            x_perc = 0.0\r\n        \r\n        try:\r\n            y_perc = (rect.bottom() - point.y()) / (rect.bottom() - rect.top())\r\n        except ZeroDivisionError:\r\n            y_perc = 0.0\r\n        \r\n        out = {}\r\n        for axis in axes:\r\n            if axis.orientation() == Qt.Vertical:\r\n                out[axis.name()] = axis.valueAt(y_perc)\r\n            else:\r\n                out[axis.name()] = axis.valueAt(x_perc)\r\n        \r\n        return out", "response": "Returns the values for each axis at the given point within this renderer s axis rectangle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the first renderer with the given name or None if no such renderer exists.", "response": "def plugin(name):\r\n        \"\"\"\r\n        Returns the plugin renderer based on the inputed name.\r\n        \r\n        :param      name | <str>\r\n        \r\n        :return     <XChartRenderer> || None\r\n        \"\"\"\r\n        cls = XChartRenderer._plugins.get(name)\r\n        if cls:\r\n            renderer = cls()\r\n            renderer.setName(name)\r\n            return renderer\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cardClass( self, record ):\r\n        return self._cardClasses.get(type(record), self._cardClasses[None])", "response": "Returns the class that should be used by the createCard method to generate a new card for the given record."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of records for the inputed column.", "response": "def collectRecords( self, column ):\r\n        \"\"\"\r\n        Collects records for the inputed column to choose from.\r\n        \r\n        :param      column | <orb.Column>\r\n        \r\n        :return     [<orb.Table>, ..]\r\n        \"\"\"\r\n        model   = column.referenceModel()\r\n        if ( not model ):\r\n            return []\r\n        \r\n        records = model.select()\r\n        records.sort()\r\n        return records"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the column options for the inputed table type.", "response": "def columnOptions( self, tableType ):\r\n        \"\"\"\r\n        Returns the column options for the inputed table type.\r\n        \r\n        :param      tableType | <subclass of orb.Table>\r\n        \r\n        :return     [<str>, ..]\r\n        \"\"\"\r\n        if ( not tableType ):\r\n            return []\r\n        \r\n        schema = tableType.schema()\r\n        return map(lambda x: x.name(), schema.columns())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createCard( self, parent, record ):\r\n        cls = self.cardClass(record)\r\n        if ( cls ):\r\n            card = cls(parent)\r\n            card.setRecord(record)\r\n            return card\r\n        return None", "response": "Creates a new widget that will represent the card view for the inpued\r\n                    record. Returns None if no card is created."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an editor for the inputed table type based on the inputed column and operator types.", "response": "def createEditor( self, parent, schema, columnName, operatorType ):\r\n        \"\"\"\r\n        Returns an editor for the inputed table type, based on the column and\r\n        operator types.\r\n        \r\n        :param      schema          | <orb.TableSchema>\r\n                    columnName      | <str>\r\n                    operatorType    | <orb.Query.Op>\r\n        \r\n        :return     <QWidget>\r\n        \"\"\"\r\n        column = schema.column(columnName)\r\n        if ( not column ):\r\n            return None\r\n        \r\n        ctype  = column.columnType()\r\n        \r\n        # based on the column and operator type, the editor may change\r\n        if ( ctype == ColumnType.String ):\r\n            if ( operatorType in (Q.Op.IsIn, Q.Op.IsNotIn) ):\r\n                widget = XMultiTagEdit(parent)\r\n            else:\r\n                widget = QLineEdit(parent)\r\n        \r\n        elif ( ctype == ColumnType.Bool ):\r\n            widget = QComboBox(parent)\r\n            widget.addItems(['True', 'False'])\r\n            widget.setEditable(True)\r\n            widget.setInsertPolicy(QComboBox.NoInsert)\r\n        \r\n        elif ( ctype == ColumnType.ForeignKey ):\r\n            widget = XOrbRecordBox(parent)\r\n            widget.setRecords(self.collectRecords(column))\r\n        \r\n        else:\r\n            widget = None\r\n        \r\n        return widget"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef editorData( self, editor ):\r\n        # set the information from a multi-tag edit\r\n        if ( isinstance(editor, XMultiTagEdit) ):\r\n            return editor.tags()\r\n        \r\n        # set the information from a combo box\r\n        elif ( isinstance(editor, QComboBox) ):\r\n            return nativestring(editor.currentText())\r\n        \r\n        # set the information from a line edit\r\n        elif ( isinstance(editor, QLineEdit) ):\r\n            return nativestring(editor.text())\r\n        \r\n        return None", "response": "Gets the value from the inputed editor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value for the given editor to the inputed value.", "response": "def setEditorData( self, editor, value ):\r\n        \"\"\"\r\n        Sets the value for the given editor to the inputed value.\r\n        \r\n        :param      editor | <QWidget>\r\n                    value  | <variant>\r\n        \"\"\"\r\n        \r\n        # set the data for a multitagedit\r\n        if ( isinstance(editor, XMultiTagEdit) ):\r\n            if ( not isinstance(value, list) ):\r\n                value = [nativestring(value)]\r\n            else:\r\n                value = map(nativestring, value)\r\n            \r\n            editor.setTags(value)\r\n            editor.setCurrentItem(editor.createItem())\r\n            \r\n        # set the data for a combobox\r\n        elif ( isinstance(editor, QComboBox) ):\r\n            i = editor.findText(nativestring(value))\r\n            editor.setCurrentIndex(i)\r\n            editor.lineEdit().selectAll()\r\n        \r\n        # set the data for a line edit\r\n        elif ( isinstance(editor, QLineEdit) ):\r\n            editor.setText(nativestring(value))\r\n            editor.selectAll()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configmap_install_id_plugin(scout, app, map_name=None, namespace=\"default\"):\n\n        plugin_response = None\n\n        if not map_name:\n            map_name = \"scout.config.{0}\".format(app)\n\n        kube_host = os.environ.get('KUBERNETES_SERVICE_HOST', None)\n\n        try:\n            kube_port = int(os.environ.get('KUBERNETES_SERVICE_PORT', 443))\n        except ValueError:\n            scout.logger.debug(\"Scout: KUBERNETES_SERVICE_PORT isn't numeric, defaulting to 443\")\n            kube_port = 443\n\n        kube_proto = \"https\" if (kube_port == 443) else \"http\"\n\n        kube_token = os.environ.get('KUBERNETES_ACCESS_TOKEN', None)\n\n        if not kube_host:\n            # We're not running in Kubernetes. Fall back to the usual filesystem stuff.\n            scout.logger.debug(\"Scout: no KUBERNETES_SERVICE_HOST, not running in Kubernetes\")\n            return None\n\n        if not kube_token:\n            try:\n                kube_token = open(\"/var/run/secrets/kubernetes.io/serviceaccount/token\", \"r\").read()\n            except OSError:\n                pass\n\n        if not kube_token:\n            # We're not running in Kubernetes. Fall back to the usual filesystem stuff.\n            scout.logger.debug(\"Scout: not running in Kubernetes\")\n            return None\n\n        # OK, we're in a cluster. Load our map.\n\n        base_url = \"%s://%s:%s\" % (kube_proto, kube_host, kube_port)\n        url_path = \"api/v1/namespaces/%s/configmaps\" % namespace\n        auth_headers = { \"Authorization\": \"Bearer \" + kube_token }\n        install_id = None\n\n        cm_url = \"%s/%s\" % (base_url, url_path)\n        fetch_url = \"%s/%s\" % (cm_url, map_name)\n\n        scout.logger.debug(\"Scout: trying %s\" % fetch_url)\n\n        try:\n            r = requests.get(fetch_url, headers=auth_headers, verify=False)\n\n            if r.status_code == 200:\n                # OK, the map is present. What do we see?\n                map_data = r.json()\n\n                if \"data\" not in map_data:\n                    # This is \"impossible\".\n                    scout.logger.error(\"Scout: no map data in returned map???\")\n                else:\n                    map_data = map_data.get(\"data\", {})\n                    scout.logger.debug(\"Scout: configmap has map data %s\" % json.dumps(map_data))\n\n                    install_id = map_data.get(\"install_id\", None)\n\n                    if install_id:\n                        scout.logger.debug(\"Scout: got install_id %s from map\" % install_id)\n                        plugin_response = { \"install_id\": install_id }\n        except OSError as e:\n            scout.logger.debug(\"Scout: could not read configmap (map %s, namespace %s): %s\" % \n                               (map_name, namespace, e))\n\n        if not install_id:\n            # No extant install_id. Try to create a new one.\n            install_id = str(uuid4())\n\n            cm = {\n                \"apiVersion\":\"v1\",\n                \"kind\":\"ConfigMap\",\n                \"metadata\":{\n                    \"name\": map_name,\n                    \"namespace\": namespace,\n                },\n                \"data\": {\n                    \"install_id\": install_id\n                }\n            }\n\n            scout.logger.debug(\"Scout: saving new install_id %s\" % install_id)\n\n            saved = False\n            try:\n                r = requests.post(cm_url, headers=auth_headers, verify=False, json=cm)\n\n                if r.status_code == 201:\n                    saved = True\n                    scout.logger.debug(\"Scout: saved install_id %s\" % install_id)\n\n                    plugin_response = {\n                        \"install_id\": install_id,\n                        \"new_install\": True\n                    }\n                else:\n                    scout.logger.error(\"Scout: could not save install_id: {0}, {1}\".format(r.status_code, r.text))\n            except OSError as e:\n                logging.debug(\"Scout: could not write configmap (map %s, namespace %s): %s\" % \n                              (map_name, namespace, e))\n\n        scout.logger.debug(\"Scout: plugin_response %s\" % json.dumps(plugin_response))\n        return plugin_response", "response": "This function returns the install ID of a plugin that uses a Kubernetes configmap to store the install ID of the application."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef typeseq(types):\n    ret = \"\"\n    for t in types:\n        ret += termcap.get(fmttypes[t])\n    \n    return ret", "response": "Returns an escape for a terminal text formatting type or a list of types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a color code number given the color name.", "response": "def nametonum(name):\n    \"\"\"\n    Returns a color code number given the color name.\n    \"\"\"\n    code = colorcodes.get(name)\n    if code is None:\n        raise ValueError(\"%s is not a valid color name.\" % name)\n    else:\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the terminal escape sequence for the given color code number or color name.", "response": "def fgseq(code):\n    \"\"\"\n    Returns the forground color terminal escape sequence for the given color code number or color name.\n    \"\"\"\n    if isinstance(code, str):\n        code = nametonum(code)\n    \n    if code == -1:\n        return \"\"\n    \n    s = termcap.get('setaf', code) or termcap.get('setf', code)\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bgseq(code):\n    if isinstance(code, str):\n        code = nametonum(code)\n\n    if code == -1:\n        return \"\"\n\n    s = termcap.get('setab', code) or termcap.get('setb', code)\n    return s", "response": "Returns the background color terminal escape sequence for the given color code number."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the text styling of a single entry in the log file.", "response": "def parse(self, descriptor):\n        \"\"\"\n        Creates a text styling from a descriptor\n\n        A descriptor is a dictionary containing any of the following keys:\n            * fg: The foreground color (name or int)\n                    See `bgseq`\n            * bg: The background color (name or int)\n                    See `fgseq`\n            * fmt: The types of special text formatting (any combination of 'b', 'u', 'i', and 'r')\n                    See `typeseq`\n        \"\"\"\n        fg = descriptor.get('fg')\n        bg = descriptor.get('bg')\n        types = descriptor.get('fmt')\n        ret = \"\"\n        if fg:\n            ret += fgseq(fg)\n        if bg:\n            ret += bgseq(bg)\n        if types:\n            t = typeseq(types)\n            if t:\n                ret += t\n        \n        # wew, strings and bytes, what's a guy to do!\n        reset = resetseq()\n        if not isinstance(reset, six.text_type):\n            reset = reset.decode('utf-8')\n        \n        def ret_func(msg):\n            if not isinstance(msg, six.text_type):\n                msg = msg.decode('utf-8')\n            return ret + msg + reset\n\n        self.decorator = ret_func"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccepting the dialog and returns the user s information.", "response": "def accept( self ):\r\n        \"\"\"\r\n        Saves the data to the profile before closing.\r\n        \"\"\"\r\n        if ( not self.uiNameTXT.text() ):\r\n            QMessageBox.information(self,\r\n                                   'Invalid Name',\r\n                                   'You need to supply a name for your layout.')\r\n            return\r\n        \r\n        prof = self.profile()\r\n        if ( not prof ):\r\n            prof = XViewProfile()\r\n        \r\n        prof.setName(nativestring(self.uiNameTXT.text()))\r\n        prof.setVersion(self.uiVersionSPN.value())\r\n        prof.setDescription(nativestring(self.uiDescriptionTXT.toPlainText()))\r\n        prof.setIcon(self.uiIconBTN.filepath())\r\n        \r\n        super(XViewProfileDialog, self).accept()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setProfile( self, profile ):\r\n        self._profile = profile\r\n        \r\n        if not profile:\r\n            self.uiNameTXT.setText('')\r\n            self.uiVersionSPN.setValue(1.0)\r\n            self.uiDescriptionTXT.setText('')\r\n            self.uiIconBTN.setFilepath(resources.find('img/profile_48.png'))\r\n        else:\r\n            self.uiNameTXT.setText(profile.name())\r\n            self.uiVersionSPN.setValue(profile.version())\r\n            self.uiDescriptionTXT.setText(profile.description())\r\n            \r\n            filepath = profile.icon()\r\n            if ( not filepath ):\r\n                filepath = resources.find('img/profile_48.png')\r\n            self.uiIconBTN.setFilepath(filepath)", "response": "Sets the profile for this dialog to the inputed profile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the visibility of the dialog.", "response": "def setVisible( self, state ):\r\n        \"\"\"\r\n        Handles the visibility operation for this dialog.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        super(XViewProfileDialog, self).setVisible(state)\r\n        \r\n        if ( state ):\r\n            self.activateWindow()\r\n            self.uiNameTXT.setFocus()\r\n            self.uiNameTXT.selectAll()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nediting the given profile.", "response": "def edit(parent, profile):\r\n        \"\"\"\r\n        Edits the given profile.\r\n        \r\n        :param      parent  | <QWidget>\r\n                    profile | <projexui.widgets.xviewwidget.XViewProfile>\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        dlg = XViewProfileDialog(parent)\r\n        dlg.setProfile(profile)\r\n        if ( dlg.exec_() ):\r\n            return True\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef blockSignals( self, state ):\r\n        super(XLocationWidget, self).blockSignals(state)\r\n        self._locationEdit.blockSignals(state)\r\n        self._locationButton.blockSignals(state)", "response": "Blocks the signals for this widget and its sub - parts."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef browseMaps( self ):\r\n        url    = self.urlTemplate()\r\n        params = urllib.urlencode({self.urlQueryKey(): self.location()})\r\n        \r\n        url    = url % {'params': params}\r\n        webbrowser.open(url)", "response": "Browse the Google maps."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes chrome driver in headless mode", "response": "def _initialize_chrome_driver(self):\n        \"\"\"Initializes chrome in headless mode\"\"\"\n\n        try:\n\n            print(colored('\\nInitializing Headless Chrome...\\n', 'yellow'))\n            self._initialize_chrome_options()\n            self._chromeDriver = webdriver.Chrome(\n                chrome_options=self._chromeOptions)\n\n            self._chromeDriver.maximize_window()\n            print(colored('\\nHeadless Chrome Initialized.', 'green'))\n\n        except Exception as exception:\n            print(colored('Error - Driver Initialization: ' + format(exception)), 'red')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initialize_arg_parser():\n\n        GoogleImageExtractor.__argParser = ArgumentParser(\n            description='Utility to search and download images from google')\n\n        # Add the required arguments\n        requiredArguments = GoogleImageExtractor.__argParser.add_argument_group(\n            'required arguments')\n        requiredArguments.add_argument('-q', '--image-query', dest='imageQuery',\n                                       type=str, required=True, help='Image Search Query',\n                                       metavar='<image_query>')\n\n        # Add the optional arguments\n        optionalArguments = GoogleImageExtractor.__argParser.add_argument_group(\n            'optional arguments')\n        optionalArguments.add_argument('-f', '--destination-folder', dest='destinationFolder',\n                                       type=str, help='Download Destination Folder, default is the current folder',\n                                       metavar='<destination_folder>', default=\"./\")\n\n        optionalArguments.add_argument('-n', '--image-count', dest='imageCount',\n                                       type=int, help='Count of images that neeed to be extracted',\n                                       metavar='<image_count>', default=100)\n\n        optionalArguments.add_argument('-t', '--thread-count', dest='threadCount',\n                                       type=int, help='Count of threads, to parallelize download of images',\n                                       metavar='<thread_count>', default=4)", "response": "Initializes the argument parser with the options that are required by the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_images(self, imageQuery, imageCount=100, destinationFolder='./', threadCount=4):\n\n        # Initialize the chrome driver\n        self._initialize_chrome_driver()\n\n        # Initialize the image download parameters\n        self._imageQuery = imageQuery\n        self._imageCount = imageCount\n        self._destinationFolder = destinationFolder\n        self._threadCount = threadCount\n\n        self._get_image_urls()\n        self._create_storage_folder()\n        self._download_images()\n\n        # Print the final message specifying the total count of images downloaded\n        print(colored('\\n\\nImages Downloaded: ' +\n                      str(self._imageCounter) + ' of ' + str(self._imageCount) + ' in ' +\n                      format_timespan(self._downloadProgressBar.data()['total_seconds_elapsed']) + '\\n', 'green'))\n\n        # Terminate the chrome instance\n        self._chromeDriver.close()\n        self._reset_helper_variables()", "response": "This function downloads the specified number of images from Google Image Search with the specified image query and downloads the specified count of images from Google Image Search with the specified image query and saves the specified count of images to the specified destination folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_image_urls(self):\n\n        print(colored('\\nRetrieving Image URLs...', 'yellow'))\n\n        _imageQuery = self._imageQuery.replace(' ', '+')\n\n        self._chromeDriver.get('https://www.google.co.in/search?q=' + _imageQuery +\n                               '&newwindow=1&source=lnms&tbm=isch')\n\n        while self._imageURLsExtractedCount <= self._imageCount:\n            self._extract_image_urls()\n            self._page_scroll_down()\n\n        # Slice the list of image URLs to contain the exact number of image\n        # URLs that have been requested\n        # self._imageURLs = self._imageURLs[:self._imageCount]\n\n        print(colored('Image URLs retrieved.', 'green'))", "response": "Retrieves the image URLs corresponding to the image query"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves image URLs from the current page", "response": "def _extract_image_urls(self):\n        \"\"\"Retrieves image URLs from the current page\"\"\"\n\n        resultsPage = self._chromeDriver.page_source\n\n        resultsPageSoup = BeautifulSoup(resultsPage, 'html.parser')\n        images = resultsPageSoup.find_all('div', class_='rg_meta')\n        images = [json.loads(image.contents[0]) for image in images]\n\n        [self._imageURLs.append(image['ou']) for image in images]\n\n        self._imageURLsExtractedCount += len(images)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _page_scroll_down(self):\n\n        # Scroll down to request the next set of images\n        self._chromeDriver.execute_script(\n            'window.scroll(0, document.body.clientHeight)')\n\n        # Wait for the images to load completely\n        time.sleep(self.WAIT_TIME)\n\n        # Check if the button - 'Show More Results' is visible\n        # If yes, click it and request more messages\n        # This step helps is avoiding duplicate image URLS from being captured\n        try:\n            self._chromeDriver.find_element_by_id('smb').click()\n        except ElementNotVisibleException as error:\n            pass", "response": "Scrolls down to get the next set of images"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _download_images(self):\n\n        print('\\nDownloading Images for the Query: ' + self._imageQuery)\n\n        try:\n            self._initialize_progress_bar()\n\n            # Initialize and assign work to the threads in the threadpool\n            threadPool = Pool(self._threadCount)\n            threadPool.map(self._download_image, self._imageURLs)\n\n            threadPool.close()\n            threadPool.join()\n\n            # Download each image individually\n            # [self._download_image(imageURL) for imageURL in self._imageURLs]\n\n            self._downloadProgressBar.finish()\n\n        except Exception as exception:\n            print('Error - Image Download: ' + format(exception))", "response": "Downloads the images from the retrieved image URLs and stores them in the specified destination folder."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _initialize_progress_bar(self):\n\n        widgets = ['Download: ', Percentage(), ' ', Bar(),\n                   ' ', AdaptiveETA(), ' ', FileTransferSpeed()]\n\n        self._downloadProgressBar = ProgressBar(\n            widgets=widgets, max_value=self._imageCount).start()", "response": "Initializes the progress bar"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _download_image(self, imageURL):\n\n        # If the required count of images have been download,\n        # refrain from downloading the remainder of the images\n        if(self._imageCounter >= self._imageCount):\n            return\n\n        try:\n            imageResponse = requests.get(imageURL)\n\n            # Generate image file name as <_imageQuery>_<_imageCounter>.<extension>\n            imageType, imageEncoding = mimetypes.guess_type(imageURL)\n\n            if imageType is not None:\n                imageExtension = mimetypes.guess_extension(imageType)\n            else:\n                imageExtension = mimetypes.guess_extension(\n                    imageResponse.headers['Content-Type'])\n\n            imageFileName = self._imageQuery.replace(\n                ' ', '_') + '_' + str(self._imageCounter) + imageExtension\n\n            imageFileName = os.path.join(self._storageFolder, imageFileName)\n\n            image = Image.open(BytesIO(imageResponse.content))\n            image.save(imageFileName)\n\n            self._imageCounter += 1\n            self._downloadProgressBar.update(self._imageCounter)\n\n        except Exception as exception:\n            pass", "response": "Downloads an image file from the given image URL and saves it to the given storage folder."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a storage folder using the query name.", "response": "def _create_storage_folder(self):\n        '''\n            Creates a storage folder using the query name by replacing\n            spaces in the query with '_' (underscore)\n        '''\n\n        try:\n            print(colored('\\nCreating Storage Folder...', 'yellow'))\n            self._storageFolder = os.path.join(\n                self._destinationFolder, self._imageQuery.replace(' ', '_'))\n\n            os.makedirs(self._storageFolder)\n\n            print(colored('Storage Folder - ' +\n                          self._storageFolder + ' created.', 'green'))\n        except FileExistsError:\n            print(colored('Storage Folder - ' +\n                          self._storageFolder + ' already exists.', 'yellow'))\n        except Exception as exception:\n            raise exception"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef byFileType( fileType ):\n        XLanguage.load()\n        \n        for lang in XLanguage._plugins.values():\n            if ( fileType in lang.fileTypes() ):\n                return lang\n        return None", "response": "Returns the language plugin by the inputed file type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlooks up the language plugin by the lexer class.", "response": "def byLexer( lexer ):\n        \"\"\"\n        Looks up the language plugin by the lexer class of the inputed lexer.\n        \n        :param      lexer | <QsciLexer>\n        \n        :return     <XLanguage> || None\n        \"\"\"\n        XLanguage.load()\n        \n        lexerType = type(lexer)\n        for lang in XLanguage._plugins.values():\n            if ( lang.lexerType() == lexerType ):\n                return lang\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nincrementing the main progress bar by amount.", "response": "def increment(self, amount=1):\n        \"\"\"\n        Increments the main progress bar by amount.\n        \"\"\"\n        self._primaryProgressBar.setValue(self.value() + amount)\r\n        QApplication.instance().processEvents()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef incrementSub(self, amount=1):\n        self._subProgressBar.setValue(self.subValue() + amount)\r\n        QApplication.instance().processEvents()", "response": "Increments the sub - progress bar by amount."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resize(self, size):\r\n        super(XLoaderWidget, self).resize(size)\r\n        \r\n        # show small loader\r\n        if size.width() < self._loaderFrame.width() or \\\r\n           size.height() < self._loaderFrame.height():\r\n            self._loaderFrame.hide()\r\n            self._smallMovieLabel.show()\r\n        \r\n        # show regular loader\r\n        else:\r\n            self._loaderFrame.show()\r\n            self._smallMovieLabel.hide()", "response": "Resize the loader frame."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrentMode( self, mode ):\n        if ( mode == self._currentMode ):\n            return\n            \n        self._currentMode = mode\n        \n        ajax = mode == XLoaderWidget.Mode.Spinner\n        self._movieLabel.setVisible(ajax)\n        self._primaryProgressBar.setVisible(not ajax)\n        self._subProgressBar.setVisible(not ajax and self._showSubProgress)", "response": "Sets the current mode of the loader."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setMovie( self, movie ):\r\n        self._movieLabel.setMovie(movie)\r\n        self._smallMovieLabel.setMovie(movie)", "response": "Sets the movie for this loader to the inputed movie."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the total amount for the main progress bar.", "response": "def setTotal( self, amount ):\n        \"\"\"\n        Sets the total amount for the main progress bar.\n        \n        :param      amount | <int>\n        \"\"\"\n        self._primaryProgressBar.setValue(0)\n        self._primaryProgressBar.setMaximum(amount)\n        \n        if amount:\n            self.setCurrentMode(XLoaderWidget.Mode.Progress)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the total value for the sub progress bar.", "response": "def setSubTotal( self, amount ):\n        \"\"\"\n        Sets the total value for the sub progress bar.\n        \n        :param      amount | <int>\n        \"\"\"\n        self._subProgressBar.setValue(0)\n        self._subProgressBar.setMaximum(amount)\n        if amount:\n            self.setShowSubProgress(True)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setShowSubProgress( self, state ):\n        ajax = self.currentMode() == XLoaderWidget.Mode.Spinner\n        self._showSubProgress = state\n        self._subProgressBar.setVisible(not ajax and state)", "response": "Sets whether or not the sub progress bar should be visible."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getMovie():\n        if not XLoaderWidget.MOVIE:\n            filename = projexui.resources.find('img/ajax_loader.gif')\n            XLoaderWidget.MOVIE = QMovie()\n            XLoaderWidget.MOVIE.setFileName(filename)\n            XLoaderWidget.MOVIE.start()\n        \n        return XLoaderWidget.MOVIE", "response": "Returns the movie instance for the loader widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts a new loader widget on the inputed widget.", "response": "def start(widget, processEvents=True, style=None, movie=None):\n        \"\"\"\n        Starts a loader widget on the inputed widget.\n        \n        :param      widget          | <QWidget>\n        \n        :return     <XLoaderWidget>\n        \"\"\"\r\n        if style is None:\r\n            style = os.environ.get('PROJEXUI_LOADER_STYLE', 'gray')\r\n        \r\n        # there is a bug with the way the loader is handled in a splitter,\r\n        # so bypass it\r\n        parent = widget.parent()\r\n        while isinstance(parent, QSplitter):\r\n            parent = parent.parent()\r\n        \r\n        # retrieve the loader widget\r\n        loader = getattr(widget, '_private_xloader_widget', None)\n        if not loader:\n            loader = XLoaderWidget(parent, style)\r\n            \r\n            # make sure that if the widget is destroyed, the loader closes\r\n            widget.destroyed.connect(loader.deleteLater)\r\n            \r\n            setattr(widget, '_private_xloader_widget', loader)\r\n            setattr(widget, '_private_xloader_count', 0)\r\n            \n            loader.move(widget.pos())\r\n            if widget.isVisible():\r\n                loader.show()\r\n            \r\n            if movie:\r\n                loader.setMovie(movie)\r\n            \n            widget.installEventFilter(loader)\r\n        else:\r\n            count = getattr(widget, '_private_xloader_count', 0)\r\n            setattr(widget, '_private_xloader_count', count + 1)\r\n        \n        loader.resize(widget.size())\n        return loader"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop a loader widget on the inputed widget.", "response": "def stop(widget, force=False):\n        \"\"\"\n        Stops a loader widget on the inputed widget.\n        \n        :param      widget | <QWidget>\n        \"\"\"\r\n        # make sure we have a widget to stop\r\n        loader = getattr(widget, '_private_xloader_widget', None)\r\n        if not loader:\r\n            return\r\n        \r\n        # decrement the number of times this loader was created for the widget\r\n        # to allow for stacked closure\r\n        count = getattr(widget, '_private_xloader_count', 0)\r\n        if force or count <= 1:\r\n            # close out the loader widget\r\n            setattr(widget, '_private_xloader_count', 0)\r\n            setattr(widget, '_private_xloader_widget', None)\r\n            \r\n            loader.close()\r\n            loader.setParent(None)\r\n            loader.deleteLater()\r\n        else:\r\n            setattr(widget, '_private_xloader_count', count - 1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstop all loader widgets from this parent down cleaning out the memory for them.", "response": "def stopAll(widget):\n        \"\"\"\n        Stops all loader widgets from this parent down, cleaning out the \\\n        memory for them.\n        \n        :param      widget  | <QWidget>\n        \"\"\"\n        for loader in widget.findChildren(XLoaderWidget):\n            loader.setParent(None)\n            loader.deleteLater()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _addDatasetAction(self, dataset):\r\n        # create the toolbar action\r\n        action = QAction(dataset.name(), self)\r\n        action.setIcon(XColorIcon(dataset.color()))\r\n        action.setCheckable(True)\r\n        action.setChecked(True)\r\n        action.setData(wrapVariant(dataset))\r\n        action.toggled.connect(self.toggleDataset)\r\n        \r\n        self.uiDatasetTBAR.addAction(action)", "response": "Adds an action for the inputed dataset to the toolbar."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _drawBackground(self, scene, painter, rect):\r\n        rect = scene.sceneRect()\r\n        if scene == self.uiChartVIEW.scene():\r\n            self.renderer().drawGrid(painter,\r\n                                     rect,\r\n                                     self.showGrid(),\r\n                                     self.showColumns(),\r\n                                     self.showRows())\r\n        elif scene == self.uiXAxisVIEW.scene():\r\n            self.renderer().drawAxis(painter, rect, self.horizontalAxis())\r\n        elif scene == self.uiYAxisVIEW.scene():\r\n            self.renderer().drawAxis(painter, rect, self.verticalAxis())", "response": "Draw the background for a particular scene."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _drawForeground(self, scene, painter, rect):\r\n        rect = scene.sceneRect()\r\n        if scene == self.uiChartVIEW.scene():\r\n            self.renderer().drawForeground(painter,\r\n                                           rect,\r\n                                           self.showGrid(),\r\n                                           self.showColumns(),\r\n                                           self.showRows())", "response": "Draw the foreground for a particular scene within the charts."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the given dataset to this chart widget.", "response": "def addDataset(self, dataset):\r\n        \"\"\"\r\n        Adds the given data set to this chart widget.\r\n        \r\n        :param      dataSet | <XChartDataset>\r\n        \"\"\"\r\n        self._datasets.append(dataset)\r\n        self._dataChanged = True\r\n        self._addDatasetAction(dataset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nassign the renderer for this chart to the current selected one", "response": "def assignRenderer(self, action):\r\n        \"\"\"\r\n        Assigns the renderer for this chart to the current selected\r\n        renderer.\r\n        \"\"\"\r\n        name = nativestring(action.text()).split(' ')[0]\r\n        self._renderer = XChartRenderer.plugin(name)\r\n        self.uiTypeBTN.setDefaultAction(action)\r\n        self.recalculate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all the axes that have been defined for this chart.", "response": "def axes(self):\r\n        \"\"\"\r\n        Returns all the axes that have been defined for this chart.\r\n        \r\n        :return     [<projexui.widgets.xchart.XChartAxis>, ..]\r\n        \"\"\"\r\n        out = self._axes[:]\r\n        if self._horizontalAxis:\r\n            out.append(self._horizontalAxis)\r\n        if self._verticalAxis:\r\n            out.append(self._verticalAxis)\r\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the axis with the given name or None if no axis exists.", "response": "def axis(self, name):\r\n        \"\"\"\r\n        Looks up an axis for this chart by the given name.\r\n        \r\n        :return     <projexui.widgets.xchart.XChartAxis> || None\r\n        \"\"\"\r\n        for axis in self.axes():\r\n            if axis.name() == name:\r\n                return axis\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compareValues(self, a, b):\r\n        values = self.values()\r\n        try:\r\n            return cmp(values.index(a), values.index(b))\r\n        except ValueError:\r\n            return cmp(a, b)", "response": "Compares two values based on their values for this axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef datasets(self, visible=True):\r\n        if visible is not None:\r\n            return filter(lambda x: x.isVisible(), self._datasets)\r\n        return self._datasets[:]", "response": "Returns a list of all the data sets assigned with this chart widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the point on the chart where the inputed values are located.", "response": "def pointAt(self, **axis_values):\r\n        \"\"\"\r\n        Returns the point on the chart where the inputed values are located.\r\n        \r\n        :return     <QPointF>\r\n        \"\"\"\r\n        scene_point = self.renderer().pointAt(self.axes(), axis_values)\r\n        chart_point = self.uiChartVIEW.mapFromScene(scene_point)\r\n        return self.uiChartVIEW.mapToParent(chart_point)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef recalculate(self):\r\n        if not (self.isVisible() and self.renderer()):\r\n            return\r\n        \r\n        # update dynamic range\r\n        if self._dataChanged:\r\n            for axis in self.axes():\r\n                if axis.useDynamicRange():\r\n                    axis.calculateRange(self.values(axis.name()))\r\n            \r\n            self._dataChanged = False\r\n        \r\n        # recalculate the main grid\r\n        xaxis = self.horizontalAxis()\r\n        yaxis = self.verticalAxis()\r\n        renderer = self.renderer()\r\n        \r\n        xvisible = xaxis is not None and self.showXAxis() and renderer.showXAxis()\r\n        yvisible = yaxis is not None and self.showYAxis() and renderer.showYAxis()\r\n        \r\n        self.uiXAxisVIEW.setVisible(xvisible)\r\n        self.uiYAxisVIEW.setVisible(yvisible)\r\n        \r\n        # calculate the main view\r\n        view = self.uiChartVIEW\r\n        chart_scene = view.scene()\r\n        chart_scene.setSceneRect(0, 0, view.width() - 2, view.height() - 2)\r\n        rect = renderer.calculate(chart_scene, xaxis, yaxis)\r\n        \r\n        # recalculate the xaxis\r\n        if xaxis and self.showXAxis() and renderer.showXAxis():\r\n            view = self.uiXAxisVIEW\r\n            scene = view.scene()\r\n            scene.setSceneRect(0, 0, rect.width(), view.height())\r\n            scene.invalidate()\r\n        \r\n        # render the yaxis\r\n        if yaxis and self.showYAxis() and renderer.showYAxis():\r\n            view = self.uiYAxisVIEW\r\n            scene = view.scene()\r\n            scene.setSceneRect(0, 0, view.width(), rect.height())\r\n            scene.invalidate()\r\n        \r\n        # recalculate the items\r\n        renderer.calculateDatasets(chart_scene,\r\n                                   self.axes(),\r\n                                   self.datasets())\r\n        \r\n        chart_scene.invalidate()", "response": "Recalculates the information for this chart."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves an axis from this chart either by direct reference or by name.", "response": "def removeAxis(self, axis):\r\n        \"\"\"\r\n        Removes an axis from this chart either by direct reference or by\r\n        name.\r\n        \r\n        :param      axis | <projexui.widgets.XChartAxis> || <str>\r\n        \"\"\"\r\n        if not isinstance(axis, XChartAxis):\r\n            axis = self.axis(nativestring(axis))\r\n        \r\n        try:\r\n            self._axes.remove(axis)\r\n        except ValueError:\r\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resizeEvent(self, event):\r\n        super(XChart, self).resizeEvent(event)\r\n        \r\n        if self.isVisible():\r\n            self.recalculate()", "response": "Recalculates the chart information when the widget resizes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the current renderer associated with this plot.", "response": "def setRenderer(self, renderer):\r\n        \"\"\"\r\n        Sets the current renderer associated with this plot.\r\n        \r\n        :param      renderer | <XChartRenderer> || <str>\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        if not isinstance(renderer, XChartRenderer):\r\n            renderer = XChartRenderer.plugin(nativestring(renderer))\r\n        \r\n        if renderer is None:\r\n            return False\r\n        \r\n        self._renderer = renderer\r\n        \r\n        for act in self.uiTypeBTN.actions():\r\n            if act.text() == '%s Chart' % renderer.name():\r\n                self.uiTypeBTN.setDefaultAction(act)\r\n                break\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setDatasets(self, datasets):\r\n        self.clearDatasets()\r\n        self._datasets = datasets\r\n        \r\n        for dataset in datasets:\r\n            self._addDatasetAction(dataset)\r\n        \r\n        self._dataChanged = True\r\n        self.recalculate()", "response": "Sets the dataset list for this chart to the inputed data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setHorizontalAxis(self, axis):\r\n        self._horizontalAxis = axis\r\n        if axis:\r\n            axis.setOrientation(Qt.Horizontal)\r\n            self.uiXAxisVIEW.setFixedHeight(axis.minimumLabelHeight() + 5)\r\n        \r\n        self.uiXAxisVIEW.setVisible(axis is not None)", "response": "Sets the horizontal axis for this chart."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setVerticalAxis(self, axis):\r\n        self._verticalAxis = axis\r\n        if axis:\r\n            axis.setOrientation(Qt.Vertical)\r\n            self.uiYAxisVIEW.setFixedWidth(axis.minimumLabelWidth() + 15)\r\n        \r\n        self.uiYAxisVIEW.setVisible(axis is not None)", "response": "Sets the vertical axis for this chart."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setShowDatasetToolbar(self, state):\r\n        self._showDatasetToolbar = state\r\n        if not state:\r\n            self.uiDatasetTBAR.hide()\r\n        else:\r\n            self.uiDatasetTBAR.show()", "response": "Sets whether or not the dataset toolbar is visible."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting whether or not the type button is visible.", "response": "def setShowTypeButton(self, state):\r\n        \"\"\"\r\n        Sets whether or not the type button is visible.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._showTypeButton = state\r\n        if not state:\r\n            self.uiTypeBTN.hide()\r\n        else:\r\n            self.uiTypeBTN.show()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the scrollbars of the current chart with the new ones.", "response": "def syncScrollbars(self):\r\n        \"\"\"\r\n        Synchronizes the various scrollbars within this chart.\r\n        \"\"\"\r\n        chart_hbar = self.uiChartVIEW.horizontalScrollBar()\r\n        chart_vbar = self.uiChartVIEW.verticalScrollBar()\r\n        \r\n        x_hbar = self.uiXAxisVIEW.horizontalScrollBar()\r\n        x_vbar = self.uiXAxisVIEW.verticalScrollBar()\r\n        \r\n        y_hbar = self.uiYAxisVIEW.horizontalScrollBar()\r\n        y_vbar = self.uiYAxisVIEW.verticalScrollBar()\r\n        \r\n        x_hbar.setRange(chart_hbar.minimum(), chart_hbar.maximum())\r\n        x_hbar.setValue(chart_hbar.value())\r\n        x_vbar.setValue(0)\r\n        \r\n        chart_vbar.setRange(y_vbar.minimum(), y_vbar.maximum())\r\n        chart_vbar.setValue(y_vbar.value())\r\n        \r\n        y_hbar.setValue(4)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntoggling the dataset based on the given action or dataset.", "response": "def toggleDataset(self, state, dataset=None):\r\n        \"\"\"\r\n        Toggles the dataset based on the given action or dataset.\r\n        \r\n        :param      state | <bool>\r\n                    dataset | <XChartDataset>\r\n        \"\"\"\r\n        if dataset is None and self.sender():\r\n            dataset = unwrapVariant(self.sender().data())\r\n        \r\n        dataset.setVisible(state)\r\n        self._dataChanged = True\r\n        self.recalculate()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the value at the given point.", "response": "def valueAt(self, point):\r\n        \"\"\"\r\n        Returns the value within the chart for the given point.\r\n        \r\n        :param      point | <QPoint>\r\n        \r\n        :return     {<str> axis name: <variant> value, ..}\r\n        \"\"\"\r\n        chart_point = self.uiChartVIEW.mapFromParent(point)\r\n        scene_point = self.uiChartVIEW.mapToScene(chart_point)\r\n        return self.renderer().valueAt(self.axes(), scene_point)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef values(self, axis):\r\n        output = []\r\n        for dataset in self.datasets():\r\n            output += dataset.values(axis)\r\n        \r\n        return output", "response": "Returns the values of the given axis from all the datasets within the given axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setWidgetValue( widget, value ):\r\n    for wtype in reversed(_widgetValueTypes):\r\n        if isinstance(widget, wtype[0]):\r\n            try:\r\n                wtype[2](widget, value)\r\n            except:\r\n                return False\r\n            return True\r\n    return False", "response": "Sets the value for the given widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the value for the given widget based on its type.", "response": "def widgetValue( widget ):\r\n    \"\"\"\r\n    Returns the value for the inputed widget based on its type.\r\n    \r\n    :param      widget | <QWidget>\r\n    \r\n    :return     (<variant> value, <bool> success)\r\n    \"\"\"\r\n    for wtype in reversed(_widgetValueTypes):\r\n        if isinstance(widget, wtype[0]):\r\n            try:\r\n                return (wtype[1](widget), True)\r\n            except:\r\n                return (None, False)\r\n    return (None, False)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the value of the current item in the combo", "response": "def getComboValue(combo):\r\n    \"\"\"\r\n    Checks to see if there is a dataType custom property set to determine \r\n    whether to return an integer or a string.\r\n    \r\n    :param      combo | <QComboBox>\r\n    \r\n    :return     <int> || <str>\r\n    \"\"\"\r\n    dataType = unwrapVariant(combo.property('dataType'))\r\n    \r\n    if dataType == 'string':\r\n        return combo.currentText()\r\n    elif dataType == 'data':\r\n        return unwrapVariant(combo.itemData(combo.currentIndex()))\r\n    return combo.currentIndex()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setComboValue(combo, value):\r\n    dataType = unwrapVariant(combo.property('dataType'))\r\n    \r\n    if dataType == 'string':\r\n        return combo.setCurrentIndex(combo.findText(value))\r\n    elif dataType == 'data':\r\n        for i in range(combo.count()):\r\n            if unwrapVariant(combo.itemData(i)) == value:\r\n                return combo.setCurrentIndex(i)\r\n        return combo.setCurrentIndex(-1)\r\n    return combo.setCurrentIndex(value)", "response": "Sets the value of the item in the combo."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _construct(self, strings_collection):\n        \n        # 0. Add a unique character to each string in the collection,\n        #    to preserve simplicity while building the tree\n        strings_collection = utils.make_unique_endings(strings_collection)\n        \n        root = ast.AnnotatedSuffixTree.Node()\n        root.strings_collection = strings_collection\n        \n        # For each string in the collection...\n        for string_ind in xrange(len(strings_collection)):\n            string = strings_collection[string_ind]\n            # For each suffix of that string...\n            # (do not handle unique last characters as suffixes)\n            for suffix_start in xrange(len(string)-1):\n                suffix = string[suffix_start:]\n                # ... first try to find maximal matching path\n                node = root\n                child_node = node.chose_arc(suffix)\n                while child_node:\n                    (str_ind, substr_start, substr_end) = child_node.arc()\n                    match = utils.match_strings(\n                                suffix, strings_collection[str_ind][substr_start:substr_end])\n                    if match == substr_end-substr_start:\n                        # matched the arc, proceed with child node\n                        suffix = suffix[match:]\n                        suffix_start += match\n                        node = child_node\n                        node.weight += 1\n                        child_node = node.chose_arc(suffix)\n                    else:\n                        # ... then, where the matching path ends;\n                        # create new inner node\n                        # (that's the only possible alternative\n                        #  since we have unique string endings)\n                        node.remove_child(child_node)\n                        new_node = node.add_new_child(string_ind, suffix_start,\n                                                      suffix_start+match)\n                        new_leaf = new_node.add_new_child(string_ind, suffix_start+match,\n                                                          len(string))\n                        (osi, oss, ose) = child_node._arc\n                        child_node._arc = (osi, oss+match, ose)\n                        new_node.add_child(child_node)\n                        new_leaf.weight = 1\n                        new_node.weight = 1 + child_node.weight\n                        suffix = ''\n                        break\n                        \n                # ... or create new leaf if there was no appropriate arc to proceed\n                if suffix:\n                    new_leaf = node.add_new_child(string_ind, suffix_start, len(string))\n                    new_leaf.weight = 1\n                    \n        # Root will also be annotated by the weight of its children,\n        # to preserve simplicity while calculating string matching\n        for k in root.children:\n            root.weight += root.children[k].weight\n        \n        return root", "response": "This method is used to construct the tree from the given collection of strings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a new node service or check with the agent.", "response": "async def register(self, node, *,\n                       check=None, service=None, write_token=None):\n        \"\"\"Registers a new node, service or check\n\n        Parameters:\n            node (Object): Node definition\n            check (Object): Check definition\n            service (Object or ObjectID): Service\n            write_token (ObjectID): Token ID\n        Returns:\n            bool: ``True`` on success\n\n        .. note:: it is usually preferrable instead to use the agent\n                  endpoints for registration as they are simpler and\n                  perform anti-entropy.\n\n        **Node** body must look something like::\n\n            {\n                \"Datacenter\": \"dc1\",\n                \"Node\": \"foobar\",\n                \"Address\": \"192.168.10.10\",\n                \"TaggedAddresses\": {\n                    \"lan\": \"192.168.10.10\",\n                    \"wan\": \"10.0.10.10\"\n                }\n            }\n\n        **Service** body must look something like::\n\n            {\n                \"ID\": \"redis1\",\n                \"Service\": \"redis\",\n                \"Tags\": [\n                    \"master\",\n                    \"v1\"\n                ],\n                \"Address\": \"127.0.0.1\",\n                \"Port\": 8000\n            }\n\n        **Check** body must look something like::\n\n            {\n                \"Node\": \"foobar\",\n                \"CheckID\": \"service:redis1\",\n                \"Name\": \"Redis health check\",\n                \"Notes\": \"Script based health check\",\n                \"Status\": \"passing\",\n                \"ServiceID\": \"redis1\"\n            }\n\n        The behavior of the endpoint depends on what parameters are provided.\n\n        **Node** and **Address** fields are required, while\n        **Datacenter** will be defaulted to match that of the agent.\n        If only those are provided, the endpoint will register the\n        node with the catalog.\n        **TaggedAddresses** can be used in conjunction with the\n        translate_wan_addrs configuration option and the \"wan\" address.\n\n        If the **Service** key is provided, the service will also be\n        registered. If **ID** is not provided, it will be defaulted to the\n        value of the **Service.Service** property. Only one service with a\n        given **ID** may be present per node. The service **Tags**,\n        **Address**, and **Port** fields are all optional.\n\n        If the **Check** key is provided, a health check will also be\n        registered.\n\n        .. note:: This register API manipulates the health check entry in\n                  the Catalog, but it does not setup the script, **TTL**,\n                  or **HTTP** check to monitor the node's health. To truly\n                  enable a new health check, the check must either be provided\n                  in agent configuration or set via the agent endpoint.\n\n        The **CheckID** can be omitted and will default to the value of\n        **Name**. As with **Service.ID**, the **CheckID** must be unique on\n        this node. **Notes** is an opaque field that is meant to hold\n        human-readable text. If a **ServiceID** is provided that matches the\n        **ID** of a service on that node, the check is treated as a service\n        level health check, instead of a node level health check. The\n        **Status** must be one of ``passing``, ``warning``, or ``critical``.\n\n        Multiple checks can be provided by replacing **Check** with **Checks**\n        and sending a list of Check objects.\n\n        It is important to note that **Check** does not have to be provided\n        with **Service** and vice versa. A catalog entry can have either,\n        neither, or both.\n\n        An optional ACL token may be provided to perform the registration by\n        including a **WriteRequest** block in the query, like this::\n\n            {\n                \"WriteRequest\": {\n                    \"Token\": \"foo\"\n                }\n            }\n        \"\"\"\n        node_id, node = prepare_node(node)\n        service_id, service = prepare_service(service)\n        _, check = prepare_check(check)\n        if check and node_id:\n            check[\"Node\"] = node_id\n        if check and service_id:\n            check[\"ServiceID\"] = service_id\n        token = extract_attr(write_token, keys=[\"ID\"])\n        entry = node\n        if service:\n            entry[\"Service\"] = service\n        if check:\n            entry[\"Check\"] = check\n        if token:\n            entry[\"WriteRequest\"] = {\n                \"Token\": token\n            }\n        response = await self._api.put(\"/v1/catalog/register\", data=entry)\n        return response.status == 200"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists the nodes in a given DC.", "response": "async def nodes(self, *,\n                    dc=None, near=None, watch=None, consistency=None):\n        \"\"\"Lists nodes in a given DC\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            near (str): Sort the node list in ascending order based on the\n                        estimated round trip time from that node.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            CollectionMeta: where value is a list\n\n        It returns a body like this::\n\n            [\n              {\n                \"Node\": \"baz\",\n                \"Address\": \"10.1.10.11\",\n                \"TaggedAddresses\": {\n                  \"lan\": \"10.1.10.11\",\n                  \"wan\": \"10.1.10.11\"\n                }\n              },\n              {\n                \"Node\": \"foobar\",\n                \"Address\": \"10.1.10.12\",\n                \"TaggedAddresses\": {\n                  \"lan\": \"10.1.10.11\",\n                  \"wan\": \"10.1.10.12\"\n                }\n              }\n            ]\n        \"\"\"\n        params = {\"dc\": dc, \"near\": near}\n        response = await self._api.get(\"/v1/catalog/nodes\",\n                                       params=params,\n                                       watch=watch,\n                                       consistency=consistency)\n        return consul(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists services in a given DC", "response": "async def services(self, *, dc=None, watch=None, consistency=None):\n        \"\"\"Lists services in a given DC\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            ObjectMeta: where value is a dict\n\n        It returns a JSON body like this::\n\n            {\n              \"consul\": [],\n              \"redis\": [],\n              \"postgresql\": [\n                \"master\",\n                \"slave\"\n              ]\n            }\n\n        The keys are the service names, and the array values provide all known\n        tags for a given service.\n        \"\"\"\n        params = {\"dc\": dc}\n        response = await self._api.get(\"/v1/catalog/services\",\n                                       params=params,\n                                       watch=watch,\n                                       consistency=consistency)\n        return consul(response)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart the internal timer.", "response": "def _startTimer(self, interval):\r\n        \"\"\"\r\n        Starts the internal timer.\r\n        \r\n        :param      interval | <int>\r\n        \"\"\"\r\n        if not self.__timer:\r\n            self.__timer = QtCore.QTimer(self)\r\n            self.__timer.setSingleShot(self.__singleShot)\r\n            self.__timer.setInterval(interval)\r\n            self.__timer.timeout.connect(self.timeout)\r\n            self.__timer.destroyed.connect(self._clearTimer)\r\n\r\n            # ensure to stop this timer when the app quits\r\n            QtCore.QCoreApplication.instance().aboutToQuit.connect(self.__timer.stop, QtCore.Qt.QueuedConnection)\r\n        \r\n        self.__timer.start(interval)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setInterval(self, msecs):\r\n        with QtCore.QWriteLocker(self.__lock):\r\n            self.__interval = msecs\r\n            self._intervalChanged.emit(msecs)", "response": "Sets the interval in milliseconds for this timer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting whether or not this timer is setup for a single entry or not.", "response": "def setSingleShot(self, state):\r\n        \"\"\"\r\n        Sets whether or not this timer is setup for a single entry or not.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        with QtCore.QWriteLocker(self.__lock):\r\n            self.__singleShot = state\r\n            self._singleShotChanged.emit(state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nemitting the start requested signal for this timer effectively starting it s internal timer.", "response": "def start(self, interval=None):\r\n        \"\"\"\r\n        Emits the start requested signal for this timer, effectively starting\r\n        its internal timer.\r\n        \r\n        :param      interval | <int>\r\n        \"\"\"\r\n        # update the interval value\r\n        with QtCore.QReadLocker(self.__lock):\r\n            if interval is None:\r\n                interval = self.__interval\r\n            else:\r\n                self.__interval = interval\r\n        \r\n        # request the timer to start\r\n        self._startRequested.emit(interval)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the profile linked with this action.", "response": "def setProfile(self, profile):\r\n        \"\"\"\r\n        Sets the profile linked with this action.\r\n        \r\n        :param      profile | <projexui.widgets.xviewwidget.XViewProfile>\r\n        \"\"\"\r\n        self._profile = profile\r\n        \r\n        # update the interface\r\n        self.setIcon(profile.icon())\r\n        self.setText(profile.name())\r\n        self.setToolTip(profile.description())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the inputed profile as an action to the toolbar.", "response": "def addProfile(self, profile):\r\n        \"\"\"\r\n        Adds the inputed profile as an action to the toolbar.\r\n        \r\n        :param      profile | <projexui.widgets.xviewwidget.XViewProfile>\r\n        \"\"\"\r\n        # use the existing version\r\n        for exist in self.profiles():\r\n            if exist.name() == profile.name():\r\n                if exist.version() < profile.version():\r\n                    exist.setProfile(profile)\r\n                \r\n                return\r\n        \r\n        # otherwise create a new profile \r\n        act = XViewProfileAction(profile, self)\r\n        self._profileGroup.addAction(act)\r\n        self.addAction(act)\r\n        return act"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef createProfile(self, profile=None, clearLayout=True):\r\n        if profile:\r\n            prof = profile\r\n        elif not self.viewWidget() or clearLayout:\r\n            prof = XViewProfile()\r\n        else:\r\n            prof = self.viewWidget().saveProfile()\r\n        \r\n        blocked = self.signalsBlocked()\r\n        self.blockSignals(False)\r\n        changed = self.editProfile(prof)\r\n        self.blockSignals(blocked)\r\n        \r\n        if not changed:\r\n            return\r\n        \r\n        act = self.addProfile(prof)\r\n        act.setChecked(True)\r\n        \r\n        # update the interface\r\n        if self.viewWidget() and (profile or clearLayout):\r\n            self.viewWidget().restoreProfile(prof)\r\n        \r\n        if not self.signalsBlocked():\r\n            self.profileCreated.emit(prof)\r\n            self.profilesChanged.emit()", "response": "Prompts the user to create a new profile."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef editProfile(self, profile):\r\n        mod = XViewProfileDialog.edit(self.window(), profile)\r\n        if not mod:\r\n            return False\r\n        \r\n        # update the action interface\r\n        for act in self._profileGroup.actions():\r\n            if act.profile() == profile:\r\n                act.setProfile(profile)\r\n                break\r\n        \r\n        # signal the change\r\n        if not self.signalsBlocked():\r\n            self.profileChanged.emit(profile)\r\n            self.profilesChanged.emit()\r\n        \r\n        return True", "response": "Prompts the user to edit the given profile. Returns True if the user has changed the profile otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exportProfile(self, profile, filename=None):\r\n        if not filename:\r\n            filename = QFileDialog.getSaveFileName(self,\r\n                                                   'Export Profile',\r\n                                                   '',\r\n                                                   'XML Files (*.xml)')\r\n            if type(filename) == tuple:\r\n                filename = nativestring(filename[0])\r\n        \r\n        if not filename:\r\n            return False\r\n        \r\n        profile.save(filename)\r\n        return True", "response": "Exports this toolbar to the given filename."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle the action triggered by the user.", "response": "def handleActionTrigger(self, action):\r\n        \"\"\"\r\n        Handles when an action has been triggered.  If the inputed action is a \r\n        XViewProfileAction, then the currentProfileChanged signal will emit.\r\n        \r\n        :param      action | <QAction>\r\n        \"\"\"\r\n        # trigger a particular profile\r\n        if isinstance(action, XViewProfileAction):\r\n            # if the user CTRL+Clicks on the action, then attempt\r\n            # to load it in a new window\r\n            if QApplication.keyboardModifiers() == Qt.ControlModifier:\r\n                self.newWindowProfileRequested.emit(action.profile())\r\n                self.setCurrentProfile(self.currentProfile())\r\n                return\r\n            else:\r\n                self.setCurrentProfile(action.profile())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef importProfile(self, filename=None):\r\n        if not filename:\r\n            filename = QFileDialog.getOpenFileName( self,\r\n                                                    'Import Perspective',\r\n                                                    '',\r\n                                                    'XML Files (*.xml)')\r\n            \r\n            if type(filename) == tuple:\r\n                filename = nativestring(filename[0])\r\n            \r\n        if not (filename and os.path.exists(filename)):\r\n            return False\r\n        \r\n        prof = XViewProfile.load(filename)\r\n        if prof:\r\n            self.addProfile(prof)", "response": "Imports the profiles from the given file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the information for this toolbar from the inputed string.", "response": "def loadString(self, profilestr, merge=False, loadProfile=True):\r\n        \"\"\"\r\n        Loads the information for this toolbar from the inputed string.\r\n        \r\n        :param      profilestr | <str>\r\n        \"\"\"\r\n        try:\r\n            xtoolbar = ElementTree.fromstring(nativestring(profilestr))\r\n        except ExpatError, e:\r\n            return\r\n        \r\n        if not merge:\r\n            self.clear()\r\n        \r\n        self.blockSignals(True)\r\n        for xprofile in xtoolbar:\r\n            prof = XViewProfile.fromXml(xprofile)\r\n            \r\n            if merge:\r\n                self.removeProfile(prof.name(), silent=True)\r\n            \r\n            self.addProfile(prof)\r\n\r\n        self.setCurrentProfile(xtoolbar.get('current'))\r\n        \r\n        self.blockSignals(False)\r\n        self.profilesChanged.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of profiles for this toolbar.", "response": "def profiles(self):\r\n        \"\"\"\r\n        Returns a list of profiles for this toolbar.\r\n        \r\n        :return     <projexui.widgets.xviewwidget.XViewProfile>\r\n        \"\"\"\r\n        output = []\r\n        for act in self.actions():\r\n            if ( isinstance(act, XViewProfileAction) ):\r\n                output.append(act.profile())\r\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restoreSettings(self, settings, merge=False, loadProfile=True):\r\n        value = unwrapVariant(settings.value('profile_toolbar'))\r\n        if not value:\r\n            return\r\n        \r\n        self.loadString(value, merge, loadProfile=loadProfile)", "response": "Restores this profile from settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removeProfile(self, profile, silent=False):\r\n        if not profile:\r\n            return\r\n        \r\n        if not silent:\r\n            title = 'Remove {0}'.format(self.profileText())\r\n            opts  = QMessageBox.Yes | QMessageBox.No\r\n            quest = 'Are you sure you want to remove \"%s\" from the toolbar?'\r\n            quest %= profile.name() if isinstance(profile, XViewProfile) else profile\r\n            answer = QMessageBox.question(self.window(), title, quest, opts)\r\n        else:\r\n            answer = QMessageBox.Yes\r\n        \r\n        if answer == QMessageBox.Yes:\r\n            reset = profile == self.currentProfile()\r\n            if not reset:\r\n                try:\r\n                    reset = profile == self.currentProfile().name()\r\n                except AttributeError:\r\n                    reset = False\r\n            \r\n            if reset and self.viewWidget():\r\n                self.viewWidget().reset(True)\r\n            \r\n            # remove the actions from this toolbar\r\n            removed = []\r\n            for act in self.actions():\r\n                if not isinstance(act, XViewProfileAction):\r\n                    continue\r\n                if not profile in (act.profile(), act.text()):\r\n                    continue\r\n                \r\n                removed.append(act.profile())\r\n                self.removeAction(act)\r\n                self._profileGroup.removeAction(act)\r\n                act.deleteLater()\r\n            \r\n            if not self.signalsBlocked() and removed:\r\n                for prof in removed:\r\n                    self.profileRemoved.emit(prof)\r\n                self.profilesChanged.emit()", "response": "Removes the given profile from the toolbar."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the view widget linked with this toolbar.", "response": "def setViewWidget(self, viewWidget):\r\n        \"\"\"\r\n        Sets the view widget linked with this toolbar.\r\n        \r\n        :param      viewWidget | <XViewWidget>\r\n        \"\"\"\r\n        self._viewWidget = viewWidget\r\n        if viewWidget:\r\n            viewWidget.resetFinished.connect(self.clearActive)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef saveProfileLayout(self, profile):\r\n        if not self.viewWidget():\r\n            text = self.profileText()\r\n            QMessageBox.information(self.window(), \r\n                                    'Could Not Save {0}'.format(text),\r\n                                    'Error saving layout, '\\\r\n                                    'No View Widget Assigned')\r\n            return\r\n        \r\n        # save the profile from the view widget\r\n        prof = self.viewWidget().saveProfile()\r\n        profile.setXmlElement(prof.xmlElement())\r\n        \r\n        if not self.signalsBlocked():\r\n            self.profileChanged.emit(profile)", "response": "Saves the profile layout to the inputed profile."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setCurrentProfile(self, prof):\r\n        if prof is None:\r\n            self.clearActive()\r\n            return\r\n        \r\n        # loop through the profiles looking for a match\r\n        profile = None\r\n        blocked = self.signalsBlocked()\r\n        self.blockSignals(True)\r\n        for act in self._profileGroup.actions():\r\n            if prof in (act.profile(), act.profile().name()):\r\n                act.setChecked(True)\r\n                profile = act.profile()\r\n            else:\r\n                act.setChecked(False)\r\n        self.blockSignals(blocked)\r\n        \r\n        # update the current profile\r\n        if profile == self._currentProfile and not self._viewWidget.isEmpty():\r\n            return\r\n        \r\n        self._currentProfile = profile\r\n        if self._viewWidget and profile and not blocked:\r\n            self._viewWidget.restoreProfile(profile)\r\n        \r\n        if not blocked:\r\n            self.loadProfileFinished.emit(profile)\r\n            self.currentProfileChanged.emit(profile)", "response": "Sets the current profile for this toolbar to the inputed profile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing the user for the profile menu options.", "response": "def showProfileMenu(self, point):\r\n        \"\"\"\r\n        Prompts the user for profile menu options.  Editing needs to be enabled\r\n        for this to work.\r\n        \"\"\"\r\n        if not self.isEditingEnabled():\r\n            return\r\n        \r\n        trigger = self.actionAt(point)\r\n        if (isinstance(trigger, XViewProfileAction)):\r\n            prof = trigger.profile()\r\n        else:\r\n            prof = None\r\n        \r\n        # define the menu\r\n        menu = QMenu(self)\r\n        acts = {}\r\n        text = self.profileText()\r\n        \r\n        # user right clicked on a profile\r\n        if prof:\r\n            acts['edit'] = menu.addAction('Edit {0}...'.format(text))\r\n            acts['save'] = menu.addAction('Save Layout')\r\n            \r\n            menu.addSeparator()\r\n            \r\n            acts['copy'] = menu.addAction('Copy {0}'.format(text))\r\n            acts['export'] = menu.addAction('Export {0}...'.format(text))\r\n            \r\n            menu.addSeparator()\r\n            \r\n            acts['remove'] = menu.addAction('Delete {0}'.format(text))\r\n        \r\n        # show toolbar options\r\n        else:\r\n            acts['new'] = menu.addAction('New Layout'.format(text))\r\n            \r\n            menu.addSeparator()\r\n            \r\n            acts['save_as'] = menu.addAction('Save Layout as...')\r\n            \r\n            if QApplication.clipboard().text():\r\n                acts['paste'] = menu.addAction('Paste {0}'.format(text))\r\n            acts['import'] = menu.addAction('Import {0}...'.format(text))\r\n        \r\n        for key, act in acts.items():\r\n            act.setIcon(QIcon(resources.find('img/{0}.png'.format(key))))\r\n        \r\n        # run the menu\r\n        act = menu.exec_(QCursor.pos())\r\n        \r\n        # create a new profile\r\n        if act is None:\r\n            return\r\n        \r\n        elif act == acts.get('new'):\r\n            self.clearActive()\r\n        \r\n        # create a new clear profile\r\n        elif act == acts.get('save_as'):\r\n            self.saveProfileAs()\r\n        \r\n        # edit an existing profile\r\n        elif act == acts.get('edit'):\r\n            self.editProfile(prof)\r\n        \r\n        # save or create a new profile\r\n        elif act == acts.get('save'):\r\n            self.saveProfileLayout(prof)\r\n            \r\n        # copy profile\r\n        elif act == acts.get('copy'):\r\n            QApplication.clipboard().setText(prof.toString())\r\n        \r\n        # export\r\n        elif act == acts.get('export'):\r\n            self.exportProfile(prof)\r\n        \r\n        # export\r\n        elif act == acts.get('import'):\r\n            self.importProfile()\r\n        \r\n        # paste profile\r\n        elif act == acts.get('paste'):\r\n            text = QApplication.clipboard().text()\r\n            try:\r\n                prof = XViewProfile.fromString(text)\r\n            except:\r\n                prof = None\r\n                QMessageBox.information(self.window(),\r\n                                        'Invalid {0}'.format(text),\r\n                                        'The clipboard text does not contain '\\\r\n                                        'a properly formated {0}'.format(text))\r\n                \r\n            if prof and not prof.isEmpty():\r\n                self.createProfile(profile=prof)\r\n        \r\n        # paste as profile\r\n        elif act == acts.get('paste_as'):\r\n            text = QApplication.clipboard().text()\r\n            prof = XViewProfile.fromString(text)\r\n            if not prof.isEmpty():\r\n                if XViewProfileDialog.edit(self, prof):\r\n                    self.createProfile(profile=prof)\r\n        \r\n        # remove the profile\r\n        elif act == acts.get('remove'):\r\n            self.removeProfile(prof)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef toXml(self):\r\n        xtoolbar = ElementTree.Element('toolbar')\r\n        \r\n        prof = self._currentProfile\r\n        if prof is not None:\r\n            xtoolbar.set('current', prof.name())\r\n        \r\n        for profile in self.profiles():\r\n            profile.toXml(xtoolbar)\r\n        \r\n        return xtoolbar", "response": "Returns a new XML element tree with the current profile toolbar as its XML information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninserting a new subclass with filename at index mockup __module__.", "response": "def insert(self, index, filename):\n        \"\"\"Insert a new subclass with filename at index, mockup __module__.\"\"\"\n        base = self._base\n        dct = {'__module__': base.__module__, 'filename': filename, '_stack': self}\n        cls = type(base.__name__, (base,), dct)\n\n        self._map[cls.filename] = cls\n        self._classes.insert(index, cls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addLineWidget( self, query = None ):\n        widget = XQueryLineWidget(self)\n        widget.setTerms(sorted(self._rules.keys()))\n        widget.setQuery(query)\n        \n        index = self._container.layout().count() - 1\n        self._container.layout().insertWidget(index, widget)\n        \n        widget.addRequested.connect(     self.addLineWidget )\n        widget.removeRequested.connect(  self.removeLineWidget )\n        \n        # update the remove enabled options for these widgets\n        self.updateRemoveEnabled()", "response": "Adds a new line widget to the system with the given values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a rule to the system.", "response": "def addRule( self, rule ):\n        \"\"\"\n        Adds a rule to the system.\n        \n        :param      rule | <XQueryRule>\n        \"\"\"\n        self._rules[rule.term()] = rule\n        self.updateRules()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the current query string for this widget.", "response": "def currentQuery( self ):\n        \"\"\"\n        Returns the current query string for this widget.\n        \n        :return     [(<str> term, <str> operator, <str> value), ..]\n        \"\"\"\n        widgets = self.lineWidgets()\n        output = []\n        for widget in widgets:\n            output.append(widget.query())\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nemit the save requested signal for this builder for when the enter key is clicked.", "response": "def keyPressEvent( self, event ):\n        \"\"\"\n        Emits the save requested signal for this builder for when the enter\n        or return press is clicked.\n        \n        :param      event | <QKeyEvent>\n        \"\"\"\n        if ( event.key() in (Qt.Key_Enter, Qt.Key_Return) ):\n            self.emitSaveRequested()\n        \n        super(XQueryBuilderWidget, self).keyPressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrentQuery( self, query ):\n        self.clear()\n        \n        for entry in query:\n            self.addLineWidget(entry)\n        \n        # make sure we have the minimum number of widgets\n        for i in range(self.minimumCount() - len(query)):\n            self.addLineWidget()", "response": "Sets the current query for this system to the inputed query."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setRules( self, rules ):\n        if ( type(rules) in (list, tuple) ):\n            self._rules = dict([(x.term(), x) for x in rules])\n            self.updateRules()\n            return True\n            \n        elif ( type(rules) == dict ):\n            self._rules = rules.copy()\n            self.updateRules()\n            return True\n            \n        else:\n            return False", "response": "Sets all the rules for this builder."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setTerms( self, terms ):\n        return self.setRules([XQueryRule(term = term) for term in terms])", "response": "Sets a simple rule list by accepting a list of strings for terms."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the remove enabled baesd on the current number of line widgets.", "response": "def updateRemoveEnabled( self ):\n        \"\"\"\n        Updates the remove enabled baesd on the current number of line widgets.\n        \"\"\"\n        lineWidgets = self.lineWidgets()\n        count       = len(lineWidgets)\n        state       = self.minimumCount() < count\n        \n        for widget in lineWidgets:\n            widget.setRemoveEnabled(state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updateRules( self ):\n        terms = sorted(self._rules.keys())\n        for child in self.lineWidgets():\n            child.setTerms(terms)", "response": "Updates the query line items to match the latest rule options."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the inputed profile to the system.", "response": "def addProfile(self, profile):\n        \"\"\"\n        Adds the inputed profile to the system.\n        \n        :param      profile | <XViewProfile>\n        \"\"\"\n        if ( profile in self._profiles ):\n            return\n        \n        self._profiles.append(profile)\n        self._profileCombo.blockSignals(True)\n        self._profileCombo.addItem(profile.name())\n        self._profileCombo.setCurrentIndex(self._profileCombo.count()-1)\n        self._profileCombo.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef currentProfile(self):\n        index = self._profileCombo.currentIndex()\n        \n        if 0 <= index and index < len(self._profiles):\n            return self._profiles[index]\n        return None", "response": "Returns the currently selected profile from the system."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handleProfileChange(self):\n        # restore the profile settings\n        prof    = self.currentProfile()\n        vwidget = self.viewWidget()\n        if vwidget:\n            prof.restore(vwidget)\n        \n        if not self.signalsBlocked():\n            self.currentProfileChanged.emit(self.currentProfile())", "response": "Emits that the current profile has changed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the inputed profile from the system.", "response": "def removeProfile(self, profile):\n        \"\"\"\n        Adds the inputed profile to the system.\n        \n        :param      profile | <XViewProfile>\n        \"\"\"\n        if not profile in self._profiles:\n            return\n        \n        index = self._profiles.index(profile)\n        self._profiles.remove(profile)\n        self._profileCombo.blockSignals(True)\n        self._profileCombo.takeItem(index)\n        self._profileCombo.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef restoreSettings(self, settings):\n        settings.beginGroup(self.objectName())\n        \n        curr_prof = None\n        curr_name = unwrapVariant(settings.value('current'))\n        \n        profiles = []\n        for prof_name in settings.childGroups():\n            settings.beginGroup(prof_name)\n            \n            prof_str = unwrapVariant(settings.value('profile'))\n            profile  = XViewProfile.fromString(prof_str)\n            profile.setName(prof_name)\n            \n            if prof_name == curr_name:\n                curr_prof = profile\n            \n            profiles.append(profile)\n            \n            settings.endGroup()\n        \n        self.blockSignals(True)\n        self._profileCombo.blockSignals(True)\n        self.setProfiles(profiles)\n        \n        if curr_prof:\n            self.setCurrentProfile(curr_prof)\n        \n        self._profileCombo.blockSignals(False)\n        self.blockSignals(False)\n        \n        settings.endGroup()", "response": "Restores the current settings from the application."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef saveSettings(self, settings):\n        settings.beginGroup(self.objectName())\n        \n        curr_prof = self.currentProfile()\n        if curr_prof:\n            settings.setValue('current', curr_prof.name())\n        \n        for profile in self.profiles():\n            settings.beginGroup(profile.name())\n            settings.setValue('profile', wrapVariant(profile.toString()))\n            settings.endGroup()\n        \n        settings.endGroup()", "response": "Saves the current settings for this widget to the application s internal settings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the current profile to the inputed profile.", "response": "def setCurrentProfile(self, profile):\n        \"\"\"\n        Sets the current profile to the inputed profile.\n        \n        :param      profile | <XViewProfile>\n        \"\"\"\n        try:\n            index = self._profiles.index(profile)\n        except ValueError:\n            index = -1\n        \n        self._profileCombo.setCurrentIndex(index)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setProfiles(self, profiles):\n        self.blockSignals(True)\n        self._profileCombo.blockSignals(True)\n        \n        self._profiles = profiles[:]\n        self._profileCombo.clear()\n        self._profileCombo.addItems(map(lambda x: x.name(), profiles))\n        \n        self._profileCombo.blockSignals(False)\n        self.blockSignals(False)", "response": "Sets the list of profiles to be the options for the manager."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay the options menu.", "response": "def showOptionsMenu(self):\n        \"\"\"\n        Displays the options menu.  If the option menu policy is set to \n        CustomContextMenu, then the optionMenuRequested signal will be emitted,\n        otherwise the default context menu will be displayed.\n        \"\"\"\n        point        = QPoint(0, self._optionsButton.height())\n        global_point = self._optionsButton.mapToGlobal(point)\n        \n        # prompt the custom context menu\n        if self.optionsMenuPolicy() == Qt.CustomContextMenu:\n            if not self.signalsBlocked():\n                self.optionsMenuRequested.emit(global_point)\n            return\n        \n        # use the default context menu\n        menu = XViewProfileManagerMenu(self)\n        menu.exec_(global_point)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_outbox_fax(self, outbox_fax_id, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.delete_outbox_fax_with_http_info(outbox_fax_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.delete_outbox_fax_with_http_info(outbox_fax_id, **kwargs)  # noqa: E501\n            return data", "response": "Delete a fax from an existing outbox."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an outbox fax record", "response": "def get_outbox_fax(self, outbox_fax_id, **kwargs):  # noqa: E501\n        \"\"\"Get an outbox record  # noqa: E501\n\n        Get an outbox fax record information  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.get_outbox_fax(outbox_fax_id, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str outbox_fax_id: (required)\n        :return: Outbox\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_outbox_fax_with_http_info(outbox_fax_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.get_outbox_fax_with_http_info(outbox_fax_id, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all outbox fax records.", "response": "def list_outbox_faxes(self, **kwargs):  # noqa: E501\n        \"\"\"Get outbox records  # noqa: E501\n\n        Get outbox fax records information  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.list_outbox_faxes(async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :return: ResponseOutboxList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.list_outbox_faxes_with_http_info(**kwargs)  # noqa: E501\n        else:\n            (data) = self.list_outbox_faxes_with_http_info(**kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_fax(self, payload_outbox, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.send_fax_with_http_info(payload_outbox, **kwargs)  # noqa: E501\n        else:\n            (data) = self.send_fax_with_http_info(payload_outbox, **kwargs)  # noqa: E501\n            return data", "response": "Send a fax to one or more destinations."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates an existing fax record in an existing outbox.", "response": "def update_outbox_fax(self, outbox_fax_id, payload_outbox_modification, **kwargs):  # noqa: E501\n        \"\"\"Modify a fax record in outbox  # noqa: E501\n\n        Modify outbox record's comment  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.update_outbox_fax(outbox_fax_id, payload_outbox_modification, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str outbox_fax_id: (required)\n        :param PayloadOutboxModification payload_outbox_modification: (required)\n        :return: object\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.update_outbox_fax_with_http_info(outbox_fax_id, payload_outbox_modification, **kwargs)  # noqa: E501\n        else:\n            (data) = self.update_outbox_fax_with_http_info(outbox_fax_id, payload_outbox_modification, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprompts the user for the filepath to save and then saves the image.", "response": "def accept(self):\r\n        \"\"\"\r\n        Prompts the user for the filepath to save and then saves the image.\r\n        \"\"\"\r\n        filetypes = 'PNG Files (*.png);;JPG Files (*.jpg);;All Files (*.*)'\r\n        filename = QFileDialog.getSaveFileName(None,\r\n                                               'Save Snapshot',\r\n                                               self.filepath(),\r\n                                               filetypes)\r\n        \r\n        if type(filename) == tuple:\r\n            filename = filename[0]\r\n        \r\n        filename = nativestring(filename)\r\n        if not filename:\r\n            self.reject()\r\n        else:\r\n            self.setFilepath(filename)\r\n            self.save()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef keyPressEvent(self, event):\r\n        # reject on a cancel\r\n        if event.key() == Qt.Key_Escape:\r\n            self.reject()\r\n        \r\n        super(XSnapshotWidget, self).keyPressEvent(event)", "response": "Cancels the current snapshot when the escape key is pressed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the selection process for this widget and snapshot area.", "response": "def mousePressEvent(self, event):\r\n        \"\"\"\r\n        Starts the selection process for this widget and snapshot area.\r\n        \r\n        :param      event | <QMousePressEvent>\r\n        \"\"\"\r\n        self._region.setX(event.pos().x())\r\n        self._region.setY(event.pos().y())\r\n        super(XSnapshotWidget, self).mousePressEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mouseMoveEvent(self, event):\r\n        w = event.pos().x() - self._region.x()\r\n        h = event.pos().y() - self._region.y()\r\n        \r\n        self._region.setWidth(w)\r\n        self._region.setHeight(h)\r\n        self.repaint()\r\n        \r\n        super(XSnapshotWidget, self).mouseMoveEvent(event)", "response": "Adjust the width and height of the region for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling the mouse release event.", "response": "def mouseReleaseEvent(self, event):\r\n        \"\"\"\r\n        Finishes the selection event.\r\n        \r\n        :param      event | <QMouseReleaseEvent>\r\n        \"\"\"\r\n        self.accept()\r\n        super(XSnapshotWidget, self).mouseReleaseEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef paintEvent(self, event):\r\n        pen = QPen(Qt.DashLine)\r\n        pen.setColor(QColor('red'))\r\n        with XPainter(self) as painter:\r\n            painter.setPen(pen)\r\n            clr = QColor('black')\r\n            clr.setAlpha(100)\r\n            painter.setBrush(clr)\r\n            \r\n            painter.drawRect(self._region)", "response": "Handles the drawing for this widget and its selection region."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reject(self):\r\n        if self.hideWindow():\r\n            self.hideWindow().show()\r\n            \r\n        self.close()\r\n        self.deleteLater()", "response": "Rejects the snapshot and closes the widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\r\n        # close down the snapshot widget\r\n        if self.hideWindow():\r\n            self.hideWindow().hide()\r\n        \r\n        self.hide()\r\n        QApplication.processEvents()\r\n        time.sleep(1)\r\n        \r\n        # create the pixmap to save\r\n        wid = QApplication.desktop().winId()\r\n        \r\n        if not self._region.isNull():\r\n            x = self._region.x()\r\n            y = self._region.y()\r\n            w = self._region.width()\r\n            h = self._region.height()\r\n        else:\r\n            x = self.x()\r\n            y = self.y()\r\n            w = self.width()\r\n            h = self.height()\r\n        \r\n        pixmap = QPixmap.grabWindow(wid, x, y, w, h)\r\n        pixmap.save(self.filepath())\r\n        \r\n        self.close()\r\n        self.deleteLater()\r\n        if self.hideWindow():\r\n            self.hideWindow().show()", "response": "Saves the current region to the current snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing this widget and hides the specified window if necessary.", "response": "def show(self):\r\n        \"\"\"\r\n        Shows this widget and hides the specified window if necessary.\r\n        \"\"\"\r\n        super(XSnapshotWidget, self).show()\r\n        \r\n        if self.hideWindow():\r\n            self.hideWindow().hide()\r\n            QApplication.processEvents()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprompt the user to capture the screen.", "response": "def capture(rect=None, filepath='', prompt=True, hideWindow=None):\r\n        \"\"\"\r\n        Prompts the user to capture the screen.\r\n        \r\n        :param      rect     | <QRect>\r\n                    filepath | <str>\r\n                    prompt   | <bool>\r\n        \r\n        :return     (<str> filepath, <bool> accepted)\r\n        \"\"\"\r\n        widget = XSnapshotWidget(QApplication.desktop())\r\n        widget.setRegion(rect)\r\n        widget.setHideWindow(hideWindow)\r\n        widget.setFilepath(filepath)\r\n        widget.move(1, 1)\r\n        widget.resize(QApplication.desktop().size())\r\n        \r\n        if prompt or not filepath:\r\n            widget.show()\r\n        else:\r\n            widget.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a keyphrases table containing their matching scores in a set of texts.", "response": "def keyphrases_table(keyphrases, texts, similarity_measure=None, synonimizer=None,\n                     language=consts.Language.ENGLISH):\n    \"\"\"\n    Constructs the keyphrases table, containing their matching scores in a set of texts.\n\n    The resulting table is stored as a dictionary of dictionaries,\n    where the entry table[\"keyphrase\"][\"text\"] corresponds\n    to the matching score (0 <= score <= 1) of keyphrase \"keyphrase\"\n    in the text named \"text\".\n    \n    :param keyphrases: list of strings\n    :param texts: dictionary of form {text_name: text}\n    :param similarity_measure: similarity measure to use\n    :param synonimizer: SynonymExtractor object to be used\n    :param language: Language of the text collection / keyphrases\n\n    :returns: dictionary of dictionaries, having keyphrases on its first level and texts\n              on the second level.\n    \"\"\"\n\n    similarity_measure = similarity_measure or relevance.ASTRelevanceMeasure()\n\n    text_titles = texts.keys()\n    text_collection = texts.values()\n    similarity_measure.set_text_collection(text_collection, language)\n\n    i = 0\n    keyphrases_prepared = {keyphrase: utils.prepare_text(keyphrase)\n                           for keyphrase in keyphrases}\n    total_keyphrases = len(keyphrases)\n    total_scores = len(text_collection) * total_keyphrases\n    res = {}\n    for keyphrase in keyphrases:\n        if not keyphrase:\n            continue\n        res[keyphrase] = {}\n        for j in xrange(len(text_collection)):\n            i += 1\n            logging.progress(\"Calculating matching scores\", i, total_scores)\n            res[keyphrase][text_titles[j]] = similarity_measure.relevance(\n                                                        keyphrases_prepared[keyphrase],\n                                                        text=j, synonimizer=synonimizer)\n\n    logging.clear()\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keyphrases_graph(keyphrases, texts, referral_confidence=0.6, relevance_threshold=0.25,\n                     support_threshold=1, similarity_measure=None, synonimizer=None,\n                     language=consts.Language.ENGLISH):\n    \"\"\"\n    Constructs the keyphrases relation graph based on the given texts corpus.\n\n    The graph construction algorithm is based on the analysis of co-occurrences of key phrases\n    in the text corpus. A key phrase is considered to imply another one if that second phrase\n    occurs frequently enough in the same texts as the first one (that frequency is controlled\n    by the referral_confidence). A keyphrase counts as occuring in a text if its matching score\n    for that text ecxeeds some threshold (Mirkin, Chernyak, & Chugunova, 2012).\n\n    :param keyphrases: list of unicode strings\n    :param texts: dictionary of form {text_name: text}\n    :param referral_confidence: significance level of the graph in [0; 1], 0.6 by default\n    :param relevance_threshold: threshold for the matching score in [0; 1] where a keyphrase starts\n                                to be considered as occuring in the corresponding text;\n                                the defaul value is 0.25\n    :param support_threshold: threshold for the support of a node (the number of documents\n                              containing the corresponding keyphrase) such that it can be included\n                              into the graph\n    :param similarity_measure: Similarity measure to use\n    :param synonimizer: SynonymExtractor object to be used\n    :param language: Language of the text collection / keyphrases\n\n    :returns: graph dictionary in a the following format:\n                {\n                    \"nodes\": [\n                        {\n                            \"id\": <id>,\n                            \"label\": \"keyphrase\",\n                            \"support\": <# of documents containing the keyphrase>\n                        },\n                        ...\n                    ]\n                    \"edges\": [\n                        {\n                            \"source\": \"node_id\",\n                            \"target\": \"node_id\",\n                            \"confidence\": <confidence_level>\n                        },\n                        ...\n                    ]\n                }\n    \"\"\"\n\n    similarity_measure = similarity_measure or relevance.ASTRelevanceMeasure()\n\n    # Keyphrases table\n    table = keyphrases_table(keyphrases, texts, similarity_measure, synonimizer, language)\n    \n    # Dictionary { \"keyphrase\" => set(names of texts containing \"keyphrase\") }\n    keyphrase_texts = {keyphrase: set([text for text in texts\n                                       if table[keyphrase][text] >= relevance_threshold])\n                       for keyphrase in keyphrases}\n\n    # Initializing the graph object with nodes\n    graph = {\n        \"nodes\": [\n            {\n                \"id\": i,\n                \"label\": keyphrase,\n                \"support\": len(keyphrase_texts[keyphrase])\n            } for i, keyphrase in enumerate(keyphrases)\n        ],\n        \"edges\": [],\n        \"referral_confidence\": referral_confidence,\n        \"relevance_threshold\": relevance_threshold,\n        \"support_threshold\": support_threshold\n    }\n\n    # Removing nodes with small support after we've numbered all nodes\n    graph[\"nodes\"] = [n for n in graph[\"nodes\"]\n                      if len(keyphrase_texts[n[\"label\"]]) >= support_threshold]\n    \n    # Creating edges\n    # NOTE(msdubov): permutations(), unlike combinations(), treats (1,2) and (2,1) as different\n    for i1, i2 in itertools.permutations(range(len(graph[\"nodes\"])), 2):\n        node1 = graph[\"nodes\"][i1]\n        node2 = graph[\"nodes\"][i2]\n        confidence = (float(len(keyphrase_texts[node1[\"label\"]] &\n                                keyphrase_texts[node2[\"label\"]])) /\n                      max(len(keyphrase_texts[node1[\"label\"]]), 1))\n        if confidence >= referral_confidence:\n            graph[\"edges\"].append({\n                \"source\": node1[\"id\"],\n                \"target\": node2[\"id\"],\n                \"confidence\": confidence\n            })\n            \n    return graph", "response": "Constructs a keyphrases relation graph based on the given texts corpus."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _decode_unicode(value, charset, errors):\n    fallback = None\n    if errors.startswith('fallback:'):\n        fallback = errors[9:]\n        errors = 'strict'\n    try:\n        return value.decode(charset, errors)\n    except UnicodeError, e:\n        if fallback is not None:\n            return value.decode(fallback, 'replace')\n        from werkzeug.exceptions import HTTPUnicodeError\n        raise HTTPUnicodeError(str(e))", "response": "Like the regular decode function but this one raises an HTTPUnicodeError."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles a drop event.", "response": "def dropEvent( self, event ):\r\n        \"\"\"\r\n        Handles a drop event.\r\n        \"\"\"\r\n        url  = event.mimeData().urls()[0]\r\n        url_path = nativestring(url.toString())\r\n        \r\n        # download an icon from the web\r\n        if ( not url_path.startswith('file:') ):\r\n            filename = os.path.basename(url_path)\r\n            temp_path = os.path.join(nativestring(QDir.tempPath()), filename)\r\n            \r\n            try:\r\n                urllib.urlretrieve(url_path, temp_path)\r\n            except IOError:\r\n                return\r\n            \r\n            self.setFilepath(temp_path)\r\n        else:\r\n            self.setFilepath(url_path.replace('file://', ''))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pickFilepath( self ):\n        filepath = QFileDialog.getOpenFileName( self,\n                                                'Select Image File',\n                                                QDir.currentPath(),\n                                                self.fileTypes())\n        \r\n        if type(filepath) == tuple:\r\n            filepath = nativestring(filepath[0])\r\n        \n        if ( filepath ):\n            self.setFilepath(filepath)", "response": "Picks the image file to use for this icon path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setFilepath( self, filepath ):\n        self._filepath = nativestring(filepath)\n        self.setIcon(QIcon(filepath))\n        if ( not self.signalsBlocked() ):\n            self.filepathChanged.emit(filepath)", "response": "Sets the filepath for this button to the inputed path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef buildIcon(icon):\r\n        if icon is None:\r\n            return QIcon()\r\n        \r\n        if type(icon) == buffer:\r\n            try:\r\n                icon = QIcon(projexui.generatePixmap(icon))\r\n            except:\r\n                icon = QIcon()\r\n        else:\r\n            try:\r\n                icon = QIcon(icon)\r\n            except:\r\n                icon = QIcon()\r\n        \r\n        return icon", "response": "Builds an icon from the inputed information."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def fire(self, name, payload=None, *,\n                   dc=None, node=None, service=None, tag=None):\n        \"\"\"Fires a new event\n\n        Parameters:\n            name (str): Event name\n            payload (Payload): Opaque data\n            node (Filter): Regular expression to filter by node name\n            service (Filter): Regular expression to filter by service\n            tag (Filter): Regular expression to filter by service tags\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n        Returns:\n            Object: where value is event ID\n\n        The return body is like::\n\n            {\n                \"ID\": \"b54fe110-7af5-cafc-d1fb-afc8ba432b1c\",\n                \"Name\": \"deploy\",\n                \"Payload\": None,\n                \"NodeFilter\": re.compile(\"node-\\d+\"),\n                \"ServiceFilter\": \"\",\n                \"TagFilter\": \"\",\n                \"Version\": 1,\n                \"LTime\": 0\n            }\n\n        The **ID** field uniquely identifies the newly fired event.\n        \"\"\"\n        params = {\n            \"dc\": dc,\n            \"node\": extract_pattern(node),\n            \"service\": extract_pattern(service),\n            \"tag\": extract_pattern(tag)\n        }\n        payload = encode_value(payload) if payload else None\n        response = await self._api.put(\n            \"/v1/event/fire\", name,\n            data=payload,\n            params=params,\n            headers={\"Content-Type\": \"application/octet-stream\"})\n        result = format_event(response.body)\n        return result", "response": "Fires a new event and returns the ID of the event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def items(self, name=None, *, watch=None):\n        path = \"/v1/event/list\"\n        params = {\"name\": name}\n        response = await self._api.get(path, params=params, watch=watch)\n        results = [format_event(data) for data in response.body]\n        return consul(results, meta=extract_meta(response.headers))", "response": "Lists the most recent events an agent has seen."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new widget for this plugin for the inputed parent.", "response": "def createWidget( self, parent ):\n        \"\"\"\n        Creates a new widget for this plugin for the inputed parent.\n        \n        :param      parent | <QWidget>\n        \n        :return     <QWidget>\n        \"\"\"\n        widget = self.widgetClass()(parent, self.uiFile())\n        widget.setPlugin(self)\n        return widget"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef restoreSettings( self, settings ):\n        dataSet = self.dataSet()\n        if ( not dataSet ):\n            return False\n        \n        projexui.restoreDataSet( settings,\n                                 self.uniqueName(),\n                                 dataSet )\n        \n        if ( not self.signalsBlocked() ):\n            self.restoreFinished.emit()\n        \n        return True", "response": "Restores the settings from the inputed settings instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the plugin data to the inputed settings system.", "response": "def saveSettings( self, settings ):\n        \"\"\"\n        Saves the plugin data to the inputed settings system.\n        \n        :param      settings | <QSettings>\n        \n        :return     <bool> success\n        \"\"\"\n        dataSet = self.dataSet()\n        if ( not dataSet ):\n            return False\n        \n        projexui.saveDataSet( settings, \n                              self.uniqueName(),\n                              dataSet )\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the inputed record state to the set for this item.", "response": "def addRecordState( self, state ):\r\n        \"\"\"\r\n        Adds the inputed record state to the set for this item.\r\n        \r\n        :param      state | <XOrbRecordItem.State>\r\n        \"\"\"\r\n        curr_state = self.recordState()\r\n        self.setRecordState(curr_state | state)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef childRecords(self):\r\n        if self._childRecords is not None:\r\n            return self._childRecords\r\n        \r\n        tree = self.treeWidget()\r\n        try:\r\n            table, column = tree.hierarchyLookup(self.record())\r\n        except AttributeError:\r\n            table = None\r\n            column = ''\r\n        \r\n        # returns the children for this information\r\n        if table and column:\r\n            return table.select(where=Q(column) == self.record())\r\n        \r\n        # returns a blank record set if no other records can be found\r\n        return RecordSet()", "response": "Returns a record set of children for this information item based on the record set hierarchyColumn value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findItemsByState( self, state ):\r\n        out = []\r\n        if ( self.hasRecordState(state) ):\r\n            out.append(self)\r\n        \r\n        for c in range(self.childCount()):\r\n            out += self.child(c).findItemsByState(state)\r\n        \r\n        return out", "response": "Returns a list of items in this record based on the state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning whether or not this record has children.", "response": "def hasRecords(self):\r\n        \"\"\"\r\n        Returns whether or not this record has children.\r\n        \r\n        :return     <bool>\r\n        \"\"\"\r\n        records = self.childRecords()\r\n        if records and len(records) > 0:\r\n            return True\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self):\r\n        if self.__loaded:\r\n            return False\r\n        \r\n        self.__loaded = True\r\n        self.setChildIndicatorPolicy(self.DontShowIndicatorWhenChildless)\r\n        \r\n        # loads the children for this widget\r\n        tree = self.treeWidget()\r\n        if tree.groupBy():\r\n            grps = self.childRecords().grouped(tree.groupBy())\r\n            for grp, records in grps.items():\r\n                tree.createGroupItem(grp, records, self)\r\n        else:\r\n            for record in self.childRecords():\r\n                tree.createRecordItem(record, self)\r\n        \r\n        return True", "response": "Loads the children for this record item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef removeRecordState( self, state ):\r\n        curr_state = self.recordState()\r\n        if curr_state & state:\r\n            self.setRecordState(curr_state ^ state)", "response": "Removes the state from this item."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setDragTable(self, table):\r\n        if table and table.schema():\r\n            self.setDragData('application/x-orb-table', table.schema().name())\r\n        else:\r\n            self.setDragData('application/x-orb-table', None)", "response": "Sets the table that will be dragged from the tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setDragQuery(self, query):\r\n        if query is not None:\r\n            self.setDragData('application/x-orb-query', query.toXmlString())\r\n        else:\r\n            self.setDragData('application/x-orb-query', None)", "response": "Sets the query that should be used when this record is dragged."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the record state for this item based on the inputed state.", "response": "def setRecordState( self, recordState ):\r\n        \"\"\"\r\n        Sets the record state for this item to the inputed state.\r\n        \r\n        :param      recordState | <XOrbRecordItem.State>\r\n        \"\"\"\r\n        self._recordState = recordState\r\n        \r\n        try:\r\n            is_colored = self.treeWidget().isColored()\r\n        except AttributeError:\r\n            return\r\n        \r\n        if not is_colored:\r\n            return\r\n        \r\n        # determine the color for the item based on the state\r\n        if recordState & XOrbRecordItem.State.Removed:\r\n            clr = self.treeWidget().colorSet().color('RecordRemoved')\r\n        elif recordState & XOrbRecordItem.State.New:\r\n            clr = self.treeWidget().colorSet().color('RecordNew')\r\n        elif recordState & XOrbRecordItem.State.Modified:\r\n            clr = self.treeWidget().colorSet().color('RecordModified')\r\n        else:\r\n            clr = None\r\n        \r\n        # set the color based on the record state\r\n        if clr is not None:\r\n            clr = QColor(clr)\r\n            clr.setAlpha(40)\r\n            brush = QBrush(clr)\r\n        else:\r\n            brush = QBrush()\r\n        \r\n        for c in range(self.treeWidget().columnCount()):\r\n            self.setBackground(c, brush)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef updateRecordValues(self):\r\n        record = self.record()\r\n        if not record:\r\n            return\r\n        \r\n        # update the record information\r\n        tree = self.treeWidget()\r\n        if not isinstance(tree, XTreeWidget):\r\n            return\r\n        \r\n        for column in record.schema().columns():\r\n            c = tree.column(column.displayName())\r\n            if c == -1:\r\n                continue\r\n            \r\n            elif tree.isColumnHidden(c):\r\n                continue\r\n            \r\n            else:\r\n                val = record.recordValue(column.name())\r\n                self.updateColumnValue(column, val, c)\r\n        \r\n        # update the record state information\r\n        if not record.isRecord():\r\n            self.addRecordState(XOrbRecordItem.State.New)\r\n        \r\n        elif record.isModified():\r\n            self.addRecordState(XOrbRecordItem.State.Modified)", "response": "Updates the ui to show the latest record values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the value of the given column in the current record.", "response": "def updateColumnValue(self, column, value, index=None):\r\n        \"\"\"\r\n        Assigns the value for the column of this record to the inputed value.\r\n        \r\n        :param      index | <int>\r\n                    value | <variant>\r\n        \"\"\"\r\n        if index is None:\r\n            index = self.treeWidget().column(column.name())\r\n        \r\n        if type(value) == datetime.date:\r\n            self.setData(index, Qt.EditRole, wrapVariant(value))\r\n        elif type(value) == datetime.time:\r\n            self.setData(index, Qt.EditRole, wrapVariant(value))\r\n        elif type(value) == datetime.datetime:\r\n            self.setData(index, Qt.EditRole, wrapVariant(value))\r\n        elif type(value) in (float, int):\r\n            if column.enum():\r\n                self.setText(index, column.enum().displayText(value))\r\n            else:\r\n                self.setData(index, Qt.EditRole, wrapVariant(value))\r\n        elif value is not None:\r\n            self.setText(index, nativestring(value))\r\n        else:\r\n            self.setText(index, '')\r\n        \r\n        self.setSortData(index, value)\r\n        \r\n        # map default value information\r\n        try:\r\n            mapper = self.treeWidget().columnMappers().get(column.columnName())\r\n        except AttributeError:\r\n            mapper = None\r\n        \r\n        if mapper is None:\r\n            form = column.stringFormat()\r\n            if form:\r\n                mapper = form.format\r\n        \r\n        if mapper:\r\n            self.setText(index, mapper(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nforms a message payload including CRC", "response": "def _hm_form_message(\r\n            self,\r\n            thermostat_id,\r\n            protocol,\r\n            source,\r\n            function,\r\n            start,\r\n            payload\r\n    ):\r\n        \"\"\"Forms a message payload, excluding CRC\"\"\"\r\n        if protocol == constants.HMV3_ID:\r\n            start_low = (start & constants.BYTEMASK)\r\n            start_high = (start >> 8) & constants.BYTEMASK\r\n            if function == constants.FUNC_READ:\r\n                payload_length = 0\r\n                length_low = (constants.RW_LENGTH_ALL & constants.BYTEMASK)\r\n                length_high = (constants.RW_LENGTH_ALL\r\n                               >> 8) & constants.BYTEMASK\r\n            else:\r\n                payload_length = len(payload)\r\n                length_low = (payload_length & constants.BYTEMASK)\r\n                length_high = (payload_length >> 8) & constants.BYTEMASK\r\n            msg = [\r\n                thermostat_id,\r\n                10 + payload_length,\r\n                source,\r\n                function,\r\n                start_low,\r\n                start_high,\r\n                length_low,\r\n                length_high\r\n            ]\r\n            if function == constants.FUNC_WRITE:\r\n                msg = msg + payload\r\n                type(msg)\r\n            return msg\r\n        else:\r\n            assert 0, \"Un-supported protocol found %s\" % protocol"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nform a message payload including CRC", "response": "def _hm_form_message_crc(\r\n            self,\r\n            thermostat_id,\r\n            protocol,\r\n            source,\r\n            function,\r\n            start,\r\n            payload\r\n    ):\r\n        \"\"\"Forms a message payload, including CRC\"\"\"\r\n        data = self._hm_form_message(\r\n            thermostat_id, protocol, source, function, start, payload)\r\n        crc = CRC16()\r\n        data = data + crc.run(data)\r\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _hm_verify_message_crc_uk(\r\n            self,\r\n            thermostat_id,\r\n            protocol,\r\n            source,\r\n            expectedFunction,\r\n            expectedLength,\r\n            datal\r\n    ):\r\n        \"\"\"Verifies message appears legal\"\"\"\r\n        # expectedLength only used for read msgs as always 7 for write\r\n        badresponse = 0\r\n        if protocol == constants.HMV3_ID:\r\n            checksum = datal[len(datal) - 2:]\r\n            rxmsg = datal[:len(datal) - 2]\r\n            crc = CRC16()   # Initialises the CRC\r\n            expectedchecksum = crc.run(rxmsg)\r\n            if expectedchecksum == checksum:\r\n                logging.info(\"CRC is correct\")\r\n            else:\r\n                logging.error(\"CRC is INCORRECT\")\r\n                serror = \"Incorrect CRC\"\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n            dest_addr = datal[0]\r\n            frame_len_l = datal[1]\r\n            frame_len_h = datal[2]\r\n            frame_len = (frame_len_h << 8) | frame_len_l\r\n            source_addr = datal[3]\r\n            func_code = datal[4]\r\n\r\n            if (dest_addr != 129 and dest_addr != 160):\r\n                logging.info(\"dest_addr is ILLEGAL\")\r\n                serror = \"Illegal Dest Addr: %s\\n\" % (dest_addr)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if dest_addr != thermostat_id:\r\n                logging.info(\"dest_addr is INCORRECT\")\r\n                serror = \"Incorrect Dest Addr: %s\\n\" % (dest_addr)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if (source_addr < 1 or source_addr > 32):\r\n                logging.info(\"source_addr is ILLEGAL\")\r\n                serror = \"Illegal Src Addr: %s\\n\" % (source_addr)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if source_addr != source:\r\n                logging.info(\"source addr is INCORRECT\")\r\n                serror = \"Incorrect Src Addr: %s\\n\" % (source_addr)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if (\r\n                func_code != constants.FUNC_WRITE\r\n                and func_code != constants.FUNC_READ\r\n            ):\r\n                logging.info(\"Func Code is UNKNWON\")\r\n                serror = \"Unknown Func Code: %s\\n\" % (func_code)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if func_code != expectedFunction:\r\n                logging.info(\"Func Code is UNEXPECTED\")\r\n                serror = \"Unexpected Func Code: %s\\n\" % (func_code)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if (\r\n                    func_code == constants.FUNC_WRITE and frame_len != 7\r\n            ):\r\n                # Reply to Write is always 7 long\r\n                logging.info(\"response length is INCORRECT\")\r\n                serror = \"Incorrect length: %s\\n\" % (frame_len)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            if len(datal) != frame_len:\r\n                logging.info(\"response length MISMATCHES header\")\r\n                serror = \"Mismatch length: %s %s\\n\" % (len(datal), frame_len)\r\n                sys.stderr.write(serror)\r\n                badresponse += 1\r\n\r\n            # if (func_code == constants.FUNC_READ and\r\n            #   expectedLength !=len(datal) ):\r\n            #   # Read response length is wrong\r\n            #   logging.info(\"response length\r\n            #    not EXPECTED value\")\r\n            #   logging.info(\"Got %s when expecting %s\",\r\n            #   len(datal), expectedLength)\r\n            #   logging.info(\"Data is:\\n %s\", datal)\r\n            #   s = \"Incorrect length: %s\\n\" % (frame_len)\r\n            #   sys.stderr.write(s)\r\n            #   badresponse += 1\r\n\r\n            if (badresponse == 0):\r\n                return True\r\n            else:\r\n                return False\r\n\r\n        else:\r\n            assert 0, \"Un-supported protocol found %s\" % protocol", "response": "Verifies that a message is legal and that the CRC is correct."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _hm_send_msg(self, message):\r\n        try:\r\n            serial_message = message\r\n            self.conn.write(serial_message)   # Write a string\r\n        except serial.SerialTimeoutException:\r\n            serror = \"Write timeout error: \\n\"\r\n            sys.stderr.write(serror)\r\n        # Now wait for reply\r\n        byteread = self.conn.read(159)\r\n        # NB max return is 75 in 5/2 mode or 159 in 7day mode\r\n        datal = list(byteread)\r\n        return datal", "response": "Send a message to the HM."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread from the DCB and maps to yaml config file.", "response": "def _hm_read_address(self):\r\n        \"\"\"Reads from the DCB and maps to yaml config file.\"\"\"\r\n        response = self._hm_send_address(self.address, 0, 0, 0)\r\n        lookup = self.config['keys']\r\n        offset = self.config['offset']\r\n        keydata = {}\r\n        for i in lookup:\r\n            try:\r\n                kdata = lookup[i]\r\n                ddata = response[i + offset]\r\n                keydata[i] = {\r\n                    'label': kdata,\r\n                    'value': ddata\r\n                }\r\n            except IndexError:\r\n                logging.info(\"Finished processing at %d\", i)\r\n        return keydata"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the full DCB only use for non read - only operations", "response": "def read_dcb(self):\r\n        \"\"\"\r\n        Returns the full DCB, only use for non read-only operations\r\n        Use self.dcb for read-only operations.\r\n        \"\"\"\r\n        logging.info(\"Getting latest data from DCB....\")\r\n        self.dcb = self._hm_read_address()\r\n        return self.dcb"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_target_temp(self, temperature):\r\n        if 35 < temperature < 5:\r\n            logging.info(\"Refusing to set temp outside of allowed range\")\r\n            return False\r\n        else:\r\n            self._hm_send_address(self.address, 18, temperature, 1)\r\n            return True", "response": "Sets the target temperature to the requested temperature."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the health info of a node.", "response": "async def node(self, node, *, dc=None, watch=None, consistency=None):\n        \"\"\"Returns the health info of a node.\n\n        Parameters:\n            node (ObjectID): Node ID\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            CollectionMeta: where value is a list of checks\n\n        returns the checks specific of a node.\n\n        It returns a body like this::\n\n            [\n              {\n                \"Node\": \"foobar\",\n                \"CheckID\": \"serfHealth\",\n                \"Name\": \"Serf Health Status\",\n                \"Status\": \"passing\",\n                \"Notes\": \"\",\n                \"Output\": \"\",\n                \"ServiceID\": \"\",\n                \"ServiceName\": \"\"\n              },\n              {\n                \"Node\": \"foobar\",\n                \"CheckID\": \"service:redis\",\n                \"Name\": \"Service 'redis' check\",\n                \"Status\": \"passing\",\n                \"Notes\": \"\",\n                \"Output\": \"\",\n                \"ServiceID\": \"redis\",\n                \"ServiceName\": \"redis\"\n              }\n            ]\n\n        In this case, we can see there is a system level check (that is, a\n        check with no associated ``ServiceID``) as well as a service check for\n        Redis. The \"serfHealth\" check is special in that it is automatically\n        present on every node. When a node joins the Consul cluster, it is\n        part of a distributed failure detection provided by Serf. If a node\n        fails, it is detected and the status is automatically changed to\n        ``critical``.\n        \"\"\"\n        node_id = extract_attr(node, keys=[\"Node\", \"ID\"])\n        params = {\"dc\": dc}\n        response = await self._api.get(\"/v1/health/node\", node_id,\n                                       params=params,\n                                       watch=watch,\n                                       consistency=consistency)\n        return consul(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def checks(self, service, *,\n                     dc=None, near=None, watch=None, consistency=None):\n        \"\"\"Returns the checks of a service\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n            near (str): With a node name will sort the node list in ascending\n                        order based on the estimated round trip time from that\n                        node\n            watch (Blocking): Do a blocking query\n            consistency (Consistency): Force consistency\n        Returns:\n            CollectionMeta: where value is a list of checks\n        \"\"\"\n        service_id = extract_attr(service, keys=[\"ServiceID\", \"ID\"])\n        params = {\"dc\": dc, \"near\": near}\n        response = await self._api.get(\"/v1/health/checks\", service_id,\n                                       params=params,\n                                       watch=watch,\n                                       consistency=consistency)\n        return consul(response)", "response": "Returns the checks of a service"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the current progress value for this widget.", "response": "def setProgress(self, value):\r\n        \"\"\"\r\n        Sets the progress value for this widget to the inputed value.\r\n        \r\n        :param      value | <int>\r\n        \"\"\"\r\n        if value == 0:\r\n            self.uiFeedbackLBL.setText('')\r\n            self.uiLoggerEDIT.clear()\r\n        \r\n        self.uiProgressBAR.setValue(value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset whether or not to display the secondary progress bar.", "response": "def setShowSecondaryProgress(self, state):\r\n        \"\"\"\r\n        Sets whether or not to display the secondary progress widget.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._showSecondary = state\r\n        self.uiSecondaryProgressBAR.setVisible(state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing the inputed message for the given level.", "response": "def showMessage(self, level, message):\r\n        \"\"\"\r\n        Logs the inputed message for the given level.  This will update\r\n        both the feedback label and the details widget.\r\n        \r\n        :param      level   | <int>\r\n                    message | <str>\r\n        \"\"\"\r\n        self.uiFeedbackLBL.setText(message)\r\n        self.uiLoggerEDIT.log(level, message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a stream limited.", "response": "def make_limited_stream(stream, limit):\n    \"\"\"Makes a stream limited.\"\"\"\n    if not isinstance(stream, LimitedStream):\n        if limit is None:\n            raise TypeError('stream not limited and no limit provided.')\n        stream = LimitedStream(stream, limit)\n    return stream"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_chunk_iter(stream, separator, limit=None, buffer_size=10 * 1024):\n    _read = make_chunk_iter_func(stream, limit, buffer_size)\n    _split = re.compile(r'(%s)' % re.escape(separator)).split\n    buffer = []\n    while 1:\n        new_data = _read()\n        if not new_data:\n            break\n        chunks = _split(new_data)\n        new_buf = []\n        for item in chain(buffer, chunks):\n            if item == separator:\n                yield ''.join(new_buf)\n                new_buf = []\n            else:\n                new_buf.append(item)\n        buffer = new_buf\n    if buffer:\n        yield ''.join(buffer)", "response": "A generator function that returns a chunk of content from a stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef exhaust(self, chunk_size=1024 * 16):\n        to_read = self.limit - self._pos\n        chunk = chunk_size\n        while to_read > 0:\n            chunk = min(to_read, chunk)\n            self.read(chunk)\n            to_read -= chunk", "response": "This method exhausts the stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(self, size=None):\n        if self._pos >= self.limit:\n            return self.on_exhausted()\n        if size is None or size == -1:  # -1 is for consistence with file\n            size = self.limit\n        to_read = min(self.limit - self._pos, size)\n        try:\n            read = self._read(to_read)\n        except (IOError, ValueError):\n            return self.on_disconnect()\n        if to_read and len(read) != to_read:\n            return self.on_disconnect()\n        self._pos += len(read)\n        return read", "response": "Read size bytes or return None if there are no more data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readline(self, size=None):\n        if self._pos >= self.limit:\n            return self.on_exhausted()\n        if size is None:\n            size = self.limit - self._pos\n        else:\n            size = min(size, self.limit - self._pos)\n        try:\n            line = self._readline(size)\n        except (ValueError, IOError):\n            return self.on_disconnect()\n        if size and not line:\n            return self.on_disconnect()\n        self._pos += len(line)\n        return line", "response": "Reads one line from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readlines(self, size=None):\n        last_pos = self._pos\n        result = []\n        if size is not None:\n            end = min(self.limit, last_pos + size)\n        else:\n            end = self.limit\n        while 1:\n            if size is not None:\n                size -= last_pos - self._pos\n            if self._pos >= end:\n                break\n            result.append(self.readline(size))\n            if size is not None:\n                last_pos = self._pos\n        return result", "response": "Reads a file into a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef markForRebuild( self, state = True ):\r\n        self._rebuildRequired = state\r\n        if ( state ):\r\n            self.show()\r\n            self.update()", "response": "Sets the rebuild state for this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npaints this item on the painter.", "response": "def paint( self, painter, option, widget ):\r\n        \"\"\"\r\n        Paints this item on the painter.\r\n        \r\n        :param      painter | <QPainter>\r\n                    option  | <QStyleOptionGraphicsItem>\r\n                    widget  | <QWidget>\r\n        \"\"\"\r\n        if ( self._rebuildRequired ):\r\n            self.rebuild()\r\n        \r\n        # set the coloring options\r\n        painter.setPen(self.borderColor())\r\n        \r\n        if ( self.isSelected() ):\r\n            painter.setBrush(self.highlightColor())\r\n        else:\r\n            painter.setBrush(self.fillColor())\r\n        \r\n        hints = painter.renderHints()\r\n        if ( not self.isAllDay() ):\r\n            painter.setRenderHint(painter.Antialiasing)\r\n            pen = painter.pen()\r\n            pen.setWidthF(0.25)\r\n            painter.setPen(pen)\r\n        \r\n        painter.drawPath(self.path())\r\n        \r\n        # draw the text in the different rect locations\r\n        title = self.title()\r\n        painter.setPen(self.textColor())\r\n        for data in self._textData:\r\n            painter.drawText(*data)\r\n        \r\n        painter.setRenderHints(hints)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrebuilds the current item in the scene.", "response": "def rebuild( self ):\r\n        \"\"\"\r\n        Rebuilds the current item in the scene.\r\n        \"\"\"\r\n        self.markForRebuild(False)\r\n        \r\n        self._textData = []\r\n        \r\n        if ( self.rebuildBlocked() ):\r\n            return\r\n        \r\n        scene = self.scene()\r\n        if ( not scene ):\r\n            return\r\n        \r\n        # rebuild a month look\r\n        if ( scene.currentMode() == scene.Mode.Month ):\r\n            self.rebuildMonth()\r\n        elif ( scene.currentMode() in (scene.Mode.Day, scene.Mode.Week) ):\r\n            self.rebuildDay()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrebuilding the current item in day mode.", "response": "def rebuildDay( self ):\r\n        \"\"\"\r\n        Rebuilds the current item in day mode.\r\n        \"\"\"\r\n        scene = self.scene()\r\n        if ( not scene ):\r\n            return\r\n        \r\n        # calculate the base information\r\n        start_date = self.dateStart()\r\n        end_date   = self.dateEnd()\r\n        min_date   = scene.minimumDate()\r\n        max_date   = scene.maximumDate()\r\n        \r\n        # make sure our item is visible\r\n        if ( not (min_date <= end_date and start_date <= max_date)):\r\n            self.hide()\r\n            self.setPath(QPainterPath())\r\n            return\r\n        \r\n        # make sure we have valid range information\r\n        if ( start_date < min_date ):\r\n            start_date    = min_date\r\n            start_inrange = False\r\n        else:\r\n            start_inrange = True\r\n        \r\n        if ( max_date < end_date ):\r\n            end_date     = max_date\r\n            end_inrange  = False\r\n        else:\r\n            end_inrange  = True\r\n        \r\n        # rebuild the path\r\n        path = QPainterPath()\r\n        self.setPos(0, 0)\r\n        \r\n        pad         = 2\r\n        offset      = 18\r\n        height      = 16\r\n        \r\n        # rebuild a timed item\r\n        if ( not self.isAllDay() ):\r\n            start_dtime = QDateTime(self.dateStart(), self.timeStart())\r\n            end_dtime   = QDateTime(self.dateStart(), \r\n                                    self.timeEnd().addSecs(-30*60))\r\n            \r\n            start_rect  = scene.dateTimeRect(start_dtime)\r\n            end_rect    = scene.dateTimeRect(end_dtime)\r\n            \r\n            left   = start_rect.left() + pad\r\n            top    = start_rect.top() + pad\r\n            right  = start_rect.right() - pad\r\n            bottom = end_rect.bottom() - pad\r\n            \r\n            path.moveTo(left, top)\r\n            path.lineTo(right, top)\r\n            path.lineTo(right, bottom)\r\n            path.lineTo(left, bottom)\r\n            path.lineTo(left, top)\r\n            \r\n            data = (left + 6, \r\n                    top + 6, \r\n                    right - left - 12, \r\n                    bottom - top - 12,\r\n                    Qt.AlignTop | Qt.AlignLeft,\r\n                    '%s - %s\\n(%s)' % (self.timeStart().toString('h:mmap')[:-1],\r\n                                       self.timeEnd().toString('h:mmap'),\r\n                                       self.title()))\r\n            \r\n            self._textData.append(data)\r\n        \r\n        self.setPath(path)\r\n        self.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rebuildMonth( self ):\r\n        scene = self.scene()\r\n        if ( not scene ):\r\n            return\r\n        \r\n        start_date  = self.dateStart()\r\n        end_date    = self.dateEnd()\r\n        min_date    = scene.minimumDate()\r\n        max_date    = scene.maximumDate()\r\n        \r\n        # make sure our item is visible\r\n        if ( not (min_date <= end_date and start_date <= max_date)):\r\n            self.hide()\r\n            self.setPath(QPainterPath())\r\n            return\r\n        \r\n        # make sure we have valid range information\r\n        if ( start_date < min_date ):\r\n            start_date    = min_date\r\n            start_inrange = False\r\n        else:\r\n            start_inrange = True\r\n        \r\n        if ( max_date < end_date ):\r\n            end_date     = max_date\r\n            end_inrange  = False\r\n        else:\r\n            end_inrange  = True\r\n        \r\n        start_rect = scene.dateRect(start_date)\r\n        end_rect   = scene.dateRect(end_date)\r\n        \r\n        if ( not (start_rect.isValid() and end_rect.isValid()) ):\r\n            self.hide()\r\n            return\r\n        \r\n        # rebuild an all day path\r\n        path = QPainterPath()\r\n        self.setPos(0, 0)\r\n        \r\n        pad         = 2\r\n        offset      = 18\r\n        height      = 16\r\n        \r\n        min_left    = 10\r\n        max_right   = scene.width() - 16\r\n        delta_h     = start_rect.height()\r\n        \r\n        # draw the all day event\r\n        if ( self.isAllDay() ):\r\n            top   = start_rect.top()\r\n            left  = start_rect.left() + 3\r\n            first = start_inrange\r\n            \r\n            while ( top <= end_rect.top() ):\r\n                sub_path  = QPainterPath()\r\n                \r\n                # calculate the end position\r\n                if ( end_rect.top() - 2 <= top and end_inrange ):\r\n                    at_end = True\r\n                    right = end_rect.right() - pad\r\n                else:\r\n                    at_end = False\r\n                    right = max_right\r\n                \r\n                if ( first ):\r\n                    sub_path.moveTo(left, top + offset)\r\n                    text_left = left + 4\r\n                else:\r\n                    sub_path.moveTo(left + height / 2, top + offset)\r\n                    text_left = left + height / 2 + 2\r\n                \r\n                if ( at_end ):\r\n                    sub_path.lineTo(right, top + offset)\r\n                    sub_path.lineTo(right, top + offset + height)\r\n                else:\r\n                    sub_path.lineTo(right - height / 2, top + offset)\r\n                    sub_path.lineTo(right, top + offset + height / 2)\r\n                    sub_path.lineTo(right - height / 2, top + offset + height)\r\n                \r\n                if ( first ):\r\n                    sub_path.lineTo(left, top + offset + height)\r\n                    sub_path.lineTo(left, top + offset)\r\n                else:\r\n                    sub_path.lineTo(left + height / 2, top + offset + height)\r\n                    sub_path.lineTo(left, top + offset + height / 2)\r\n                    sub_path.lineTo(left + height / 2, top + offset)\r\n                \r\n                path.addPath(sub_path)\r\n                \r\n                data = (text_left,\r\n                        top + offset + 1,\r\n                        right,\r\n                        height,\r\n                        Qt.AlignLeft | Qt.AlignVCenter,\r\n                        self.title())\r\n                \r\n                self._textData.append(data)\r\n                \r\n                left = min_left\r\n                top += delta_h\r\n                first = False\r\n        else:\r\n            text = '%s: (%s)' % (self.timeStart().toString('h:mm ap'), \r\n                                 self.title())\r\n            \r\n            font   = scene.font()\r\n            left   = start_rect.left() + 2 * pad\r\n            top    = start_rect.top() + offset\r\n            \r\n            path.addText(left, top + height / 2, font, text)\r\n        \r\n        # setup the path for this item\r\n        self.setPath(path)\r\n        self.show()\r\n        \r\n        # make sure there are no collisions\r\n        while ( self.collidingItems() ):\r\n            self.setPos(self.pos().x(), self.pos().y() + height + 2)\r\n            \r\n            # hide the item if out of the visible scope\r\n            if ( delta_h - offset <= self.pos().y() + height ):\r\n                self.hide()\r\n                break", "response": "Rebuilds the current item in month mode."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the color of the message based on the inputed color.", "response": "def setColor( self, color ):\r\n        \"\"\"\r\n        Convenience method to set the border, fill and highlight colors based\r\n        on the inputed color.\r\n        \r\n        :param      color | <QColor>\r\n        \"\"\"\r\n        # sets the border color as the full value\r\n        self.setBorderColor(color)\r\n        \r\n        # set the highlight color as the color with a 140 % alpha\r\n        clr = QColor(color)\r\n        clr.setAlpha(150)\r\n        self.setHighlightColor(clr)\r\n        \r\n        # set the fill color as the color with a 50 % alpha\r\n        clr = QColor(color)\r\n        clr.setAlpha(80)\r\n        self.setFillColor(clr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the start date for this item.", "response": "def setDateStart( self, dateStart ):\r\n        \"\"\"\r\n        Sets the start date for this item.  This will automatically push the\r\n        end date to match the duration for this item.  So if the item starts\r\n        on 1/1/12 and ends on 1/2/12, and the start date is changed to 2/1/12,\r\n        the end date will change to 2/2/12.  To affect the duration of the \r\n        item, use either setDuration, or setDateEnd.\r\n        \r\n        :param      dateStart | <QDate>\r\n        \"\"\"\r\n        dateStart = QDate(dateStart)\r\n        \r\n        duration = self.duration()\r\n        self._dateStart = dateStart\r\n        self._dateEnd   = dateStart.addDays(duration - 1)\r\n        self.markForRebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the end date for this item.", "response": "def setDateEnd( self, dateEnd ):\r\n        \"\"\"\r\n        Sets the end date for this item.  This method will only affect the \r\n        start date if the end date is set to occur before its start, in which\r\n        case it will set the start date as the same date.  (1 day duration)\r\n        Otherwise, this method will scale the duration of the event.\r\n        \r\n        :param      dateEnd | <QDate>\r\n        \"\"\"\r\n        dateEnd = QDate(dateEnd)\r\n        \r\n        if ( dateEnd < self._dateStart ):\r\n            self._dateStart = dateEnd\r\n        self._dateEnd = dateEnd\r\n        self.markForRebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the duration of the item.", "response": "def setDuration( self, duration ):\r\n        \"\"\"\r\n        Changes the number of days that this item represents.  This will move\r\n        the end date the appropriate number of days away from the start date.\r\n        The duration is calculated as the 1 plus the number of days from start\r\n        to end, so a duration of 1 will have the same start and end date.  The\r\n        duration needs to be a value greater than 0.\r\n        \r\n        :param      duration | <int>\r\n        \"\"\"\r\n        if ( duration <= 0 ):\r\n            return\r\n        \r\n        self._dateEnd = self._dateStart.addDays(duration - 1)\r\n        self.markForRebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the length of the time between the start and end times.", "response": "def setLength( self, length ):\r\n        \"\"\"\r\n        Sets the length of time between the start and end times.  The inputed\r\n        number should represent the number of minutes in between them, and\r\n        will be automatically rounded to the nearest 15 minutes.\r\n        \r\n        :param      length | <int>\r\n        \"\"\"\r\n        self._timeEnd = self._timeStart.addSecs((length - length % 15) * 60)\r\n        self.markForRebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the end time for this item.", "response": "def setTimeEnd( self, timeEnd ):\r\n        \"\"\"\r\n        Sets the end time for this item.  This method will only affect the \r\n        start time if the end time is set to occur before its start, in which\r\n        case it will set the start time as 60 minutes before.\r\n        Otherwise, this method will scale the duration of the event.\r\n        \r\n        :param      timeEnd | <QTime>\r\n        \"\"\"\r\n        timeEnd = QTime(timeEnd)\r\n        \r\n        if ( timeEnd < self._timeStart ):\r\n            self._timeStart = timeEnd.addSecs(-60 * 60)\r\n        self._timeEnd = timeEnd\r\n        self.markForRebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the start time for this item.", "response": "def setTimeStart( self, timeStart ):\r\n        \"\"\"\r\n        Sets the start time for this item.  This will automatically push the\r\n        end time to match the length for this item.  So if the item starts\r\n        at 11a and ends on 1p, and the start time is changed to 12p\r\n        the end time will change to 2p.  To affect the length of the \r\n        item, use either setLength, or setTimeEnd.\r\n        \r\n        :param      timeStart | <QDate>\r\n        \"\"\"\r\n        timeStart = QTime(timeStart)\r\n        \r\n        length = self.length() # in minutes\r\n        self._timeStart = timeStart\r\n        self._timeEnd   = timeStart.addSecs(length * 60)\r\n        self.markForRebuild()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef propertyWidgetMap(self):\r\n        out = {}\r\n        scaffold = self.scaffold()\r\n        \r\n        # initialize the scaffold properties\r\n        for widget in self.findChildren(QtGui.QWidget):\r\n            propname = unwrapVariant(widget.property('propertyName'))\r\n            if not propname: continue\r\n            \r\n            prop = scaffold.property(propname)\r\n            if not prop: continue\r\n            \r\n            out[prop] = widget\r\n\r\n        return out", "response": "Returns the mapping between the widgets and their scaffold properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the page against the scaffold information setting the ecords values along the way.", "response": "def validatePage(self):\r\n        \"\"\"\r\n        Validates the page against the scaffold information, setting the\r\n        values along the way.\r\n        \"\"\"\r\n        widgets = self.propertyWidgetMap()\r\n        failed = ''\r\n        for prop, widget in widgets.items():\r\n            val, success = projexui.widgetValue(widget)\r\n            \r\n            if success:\r\n                # ensure we have the required values\r\n                if not val and not (prop.type == 'bool' and val is False):\r\n                    if prop.default:\r\n                        val = prop.default\r\n                    elif prop.required:\r\n                        msg = '{0} is a required value'.format(prop.label)\r\n                        failed = msg\r\n                        break\r\n                \r\n                # ensure the values match the required expression\r\n                elif prop.regex and not re.match(prop.regex, nativestring(val)):\r\n                    msg = '{0} needs to be in the format {1}'.format(prop.label,\r\n                                                                 prop.regex)\r\n                    failed = msg\r\n                    break\r\n                \r\n                prop.value = val\r\n            else:\r\n                msg = 'Failed to get a proper value for {0}'.format(prop.label)\r\n                failed = msg\r\n                break\r\n        \r\n        if failed:\r\n            QtGui.QMessageBox.warning(None, 'Properties Failed', failed)\r\n            return False\r\n\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the state of this item to the scaffold.", "response": "def save(self):\r\n        \"\"\"\r\n        Saves the state for this item to the scaffold.\r\n        \"\"\"\r\n        enabled = self.checkState(0) == QtCore.Qt.Checked\r\n        self._element.set('name', nativestring(self.text(0)))\r\n        self._element.set('enabled', nativestring(enabled))\r\n        \r\n        for child in self.children():\r\n            child.save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate this item based on the interface.", "response": "def update(self, enabled=None):\r\n        \"\"\"\r\n        Updates this item based on the interface.\r\n        \"\"\"\r\n        if enabled is None:\r\n            enabled = self.checkState(0) == QtCore.Qt.Checked\r\n        elif not enabled or self._element.get('enabled', 'True') != 'True':\r\n            self.setCheckState(0, QtCore.Qt.Unchecked)\r\n        else:\r\n            self.setCheckState(0, QtCore.Qt.Checked)\r\n        \r\n        if enabled:\r\n            self.setForeground(0, QtGui.QBrush())\r\n        else:\r\n            self.setForeground(0, QtGui.QBrush(QtGui.QColor('lightGray')))\r\n\r\n        for child in self.children():\r\n            child.update(enabled)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the page based on the current structure information.", "response": "def initializePage(self):\r\n        \"\"\"\r\n        Initializes the page based on the current structure information.\r\n        \"\"\"\r\n        tree = self.uiStructureTREE\r\n        tree.blockSignals(True)\r\n        tree.setUpdatesEnabled(False)\r\n        self.uiStructureTREE.clear()\r\n        xstruct = self.scaffold().structure()\r\n        \r\n        self._structure = xstruct\r\n        for xentry in xstruct:\r\n            XScaffoldElementItem(tree, xentry)\r\n        \r\n        tree.blockSignals(False)\r\n        tree.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the structure information for this wizard by building the scaffold.", "response": "def validatePage(self):\r\n        \"\"\"\r\n        Finishes up the structure information for this wizard by building\r\n        the scaffold.\r\n        \"\"\"\r\n        path = self.uiOutputPATH.filepath()\r\n        \r\n        for item in self.uiStructureTREE.topLevelItems():\r\n            item.save()\r\n        \r\n        try:\r\n            self.scaffold().build(path, self._structure)\r\n        except Exception, err:\r\n            QtGui.QMessageBox.critical(None, 'Error Occurred', nativestring(err))\r\n            return False\r\n\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nseconding resource * POST: return [test, two, request data] * GET: return [test, two]", "response": "def second_params_two(test, two):\n    \"\"\"Second resource\n\n    * POST: return [test, two, request data]\n    * GET: return [test, two]\n    \"\"\"\n    if request.method == 'POST':\n        return [test, two, request.data]\n    return {'result': [test, two]}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef label( self ):\n        if ( self._editor and hasattr(self._editor, 'label') ):\n            return self._editor.label()\n        return ''", "response": "Returns the label for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isReadOnly( self ):\n        if ( self._editor and hasattr(self._editor, 'isReadOnly') ):\n            return self._editor.isReadOnly()\n        return False", "response": "Returns whether this widget is read only."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rebuild( self ):\r\n        plugins.init()\r\n        \r\n        self.blockSignals(True)\r\n        self.setUpdatesEnabled(False)\r\n        \r\n        # clear the old editor\r\n        if ( self._editor ):\r\n            self._editor.close()\r\n            self._editor.setParent(None)\r\n            self._editor.deleteLater()\r\n            self._editor = None\r\n        \r\n        # create a new widget\r\n        plugin_class = plugins.widgets.get(self._columnType)\r\n        if ( plugin_class ):\r\n            self._editor = plugin_class(self)\r\n            self.layout().addWidget(self._editor)\r\n        \r\n        self.blockSignals(False)\r\n        self.setUpdatesEnabled(True)", "response": "Rebuilds the widget with the most appropriate properties for this edit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setColumn( self, column ):\r\n        if ( not column ):\n            return\n        \n        self._columnName = column.name()\n        \r\n        if ( column.columnType() != ColumnType.ForeignKey ):\r\n            return\r\n        \r\n        if ( self._editor ):\r\n            self._editor.setTableType(column.referenceModel())\r\n            self._editor.setRequired(column.required())", "response": "Sets the column instance for this edit to the given column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the column type for this widget to the inputed type value.", "response": "def setColumnType( self, columnType ):\r\n        \"\"\"\r\n        Sets the column type for this widget to the inputed type value.\r\n        This will reset the widget to use one of the plugins for editing the\r\n        value of the column.\r\n        \r\n        :param      columnType | <orb.ColumnType>\r\n        \"\"\"\r\n        if ( columnType == self._columnType ):\r\n            return False\r\n        \r\n        self._columnType = columnType\r\n        self.rebuild()\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the column type for this widget based on the inputed text.", "response": "def setColumnTypeText( self, columnTypeText ):\r\n        \"\"\"\r\n        Sets the column type for this widget based on the inputed text.\r\n        \r\n        :param      columnTypeText | <str>\r\n        \"\"\"\r\n        if ( not ColumnType ):\r\n            return False\r\n        \r\n        try:\r\n            columnType = ColumnType[nativestring(columnTypeText)]\r\n        except KeyError:\r\n            return False\r\n        \r\n        return self.setColumnType(columnType)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setLabel( self, text ):\n        if ( self._editor and hasattr(self._editor, 'setLabel') ):\n            self._editor.setLabel(text)\n            return True\n        return False", "response": "Sets the label for this widget to the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the read only for this widget to the inputed state.", "response": "def setReadOnly( self, state ):\n        \"\"\"\n        Sets the read only for this widget to the inputed state.  \n        Differs per type, not all types support read only.\n        \n        :param      text | <str>\n        \"\"\"\n        if ( self._editor and hasattr(self._editor, 'setReadOnly') ):\n            self._editor.setReadOnly(state)\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the value for this edit to the inputed value.", "response": "def setValue( self, value ):\r\n        \"\"\"\r\n        Sets the value for this edit to the inputed value.\r\n        \r\n        :param      value | <variant>\r\n        \"\"\"\r\n        if ( self._editor ):\r\n            self._editor.setValue(value)\r\n            return True\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addContentsWidget( self ):\r\n        curr_widget = self.currentContentsWidget()\r\n        widget = QWebView(self)\r\n        page = widget.page()\r\n        page.setLinkDelegationPolicy(page.DelegateAllLinks)\n            \n        self.uiContentsTAB.blockSignals(True)\n        self.uiContentsTAB.addTab(widget, 'Documentation')\n        self.uiContentsTAB.setCurrentIndex(self.uiContentsTAB.count() - 1)\n        self.uiContentsTAB.blockSignals(False)\n        \n        self._currentContentsIndex = self.uiContentsTAB.count() - 1\r\n        \r\n        if curr_widget:\r\n            widget.setUrl(curr_widget.url())\n        \r\n        widget.titleChanged.connect(self.refreshUi)\r\n        widget.linkClicked.connect(self.__gotoUrl)\r\n        \r\n        return widget", "response": "Adds a new contents widget into the contents tab. Returns the newly added widget."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef closeContentsWidget( self ):\r\n        widget = self.currentContentsWidget()\r\n        if ( not widget ):\r\n            return\r\n            \r\n        widget.close()\r\n        widget.setParent(None)\r\n        widget.deleteLater()", "response": "Closes the current contents widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncopies the selected text to the clipboard.", "response": "def copyText( self ):\r\n        \"\"\"\r\n        Copies the selected text to the clipboard.\r\n        \"\"\"\r\n        view = self.currentWebView()\r\n        QApplication.clipboard().setText(view.page().selectedText())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the current contents widget based on the cached index.", "response": "def currentContentsWidget( self, autoadd = False ):\r\n        \"\"\"\r\n        Returns the current contents widget based on the cached index.  If \\\r\n        no widget is specified and autoadd is True, then a new widget will \\\r\n        be added to the tab.\r\n        \r\n        :param      autoadd | <bool>\r\n        \r\n        :return     <QWebView>\r\n        \"\"\"\r\n        widget = self.uiContentsTAB.widget(self.currentContentsIndex())\n        if ( not isinstance(widget, QWebView) ):\r\n            widget = None\r\n        \r\n        if ( not widget and autoadd ):\n            widget = self.addContentsWidget()\r\n        \r\n        return widget"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef findPrev( self ):\r\n        text = self.uiFindTXT.text()\r\n        view = self.currentWebView()\r\n        \r\n        options =  QWebPage.FindWrapsAroundDocument\r\n        options |= QWebPage.FindBackward\r\n        \r\n        if ( self.uiCaseSensitiveCHK.isChecked() ):\r\n            options |= QWebPage.FindCaseSensitively\r\n        \r\n        view.page().findText(text, options)", "response": "Looks for the previous occurance of the current search text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching up the xdk item based on the current name.", "response": "def findXdk( self, name ):\n        \"\"\"\n        Looks up the xdk item based on the current name.\n        \n        :param      name | <str>\n        \n        :return     <XdkItem> || None\n        \"\"\"\n        for i in range(self.uiContentsTREE.topLevelItemCount()):\n            item = self.uiContentsTREE.topLevelItem(i)\n            if ( item.text(0) == name ):\n                return item\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngoing to a particular path within the XDK.", "response": "def gotoItem(self, path):\r\n        \"\"\"\r\n        Goes to a particular path within the XDK.\r\n        \r\n        :param      path | <str>\r\n        \"\"\"\r\n        if not path:\r\n            return\r\n        \r\n        sections = nativestring(path).split('/')\r\n        check = projex.text.underscore(sections[0])\r\n        \r\n        for i in range(self.uiContentsTREE.topLevelItemCount()):\r\n            item = self.uiContentsTREE.topLevelItem(i)\r\n            if check in (projex.text.underscore(item.text(0)), item.text(1)):\r\n                item.gotoItem('/'.join(sections[1:]))\r\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef loadedFilenames( self ):\n        output = []\n        for i in range(self.uiContentsTREE.topLevelItemCount()):\n            item = self.uiContentsTREE.topLevelItem(i)\n            output.append(nativestring(item.filepath()))\n        return output", "response": "Returns a list of all the xdk files that are currently loaded."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadFilename( self, filename = '' ):\n        if ( not (filename and isinstance(filename, basestring)) ):\n            filename = QFileDialog.getOpenFileName( self,\n                                                    'Open XDK File',\n                                                    QDir.currentPath(),\n                                                    'XDK Files (*.xdk)' )\n            \r\n            if type(filename) == tuple:\r\n                filename = nativestring(filename[0])\r\n            \n            if not filename:\n                return False\n        \n        if not (filename and os.path.exists(filename)):\n            return False\n        \n        elif filename in self.loadedFilenames():\n            return False\n        \r\n        self.loadFileRequested.emit(filename)\r\n        self.setCursor(Qt.WaitCursor)\r\n        \n        return True", "response": "Loads a new XDK file into the system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refreshFromIndex( self ):\r\n        item = self.uiIndexTREE.currentItem()\r\n        if ( not item ):\r\n            return\r\n        \r\n        self.gotoUrl(item.toolTip(0))", "response": "Refreshes the documentation from the selected index item."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrefreshes the contents tab with the latest selection from the browser.", "response": "def refreshContents( self ):\n        \"\"\"\n        Refreshes the contents tab with the latest selection from the browser.\n        \"\"\"\n        item = self.uiContentsTREE.currentItem()\n        if not isinstance(item, XdkEntryItem):\r\n           return\r\n        \r\n        item.load()\r\n        url = item.url()\r\n        if url:\r\n            self.gotoUrl(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refreshUi( self ):\n        widget      = self.uiContentsTAB.currentWidget()\n        is_content  = isinstance(widget, QWebView)\n        \n        if is_content:\n            self._currentContentsIndex = self.uiContentsTAB.currentIndex()\r\n            history = widget.page().history()\r\n        else:\r\n            history = None\n        \n        self.uiBackACT.setEnabled(is_content and history.canGoBack())\n        self.uiForwardACT.setEnabled(is_content and history.canGoForward())\n        self.uiHomeACT.setEnabled(is_content)\n        self.uiNewTabACT.setEnabled(is_content)\r\n        self.uiCopyTextACT.setEnabled(is_content)\n        self.uiCloseTabACT.setEnabled(is_content and\n                                      self.uiContentsTAB.count() > 2)\n        \n        for i in range(1, self.uiContentsTAB.count()):\n            widget = self.uiContentsTAB.widget(i)\n            self.uiContentsTAB.setTabText(i, widget.title())", "response": "Refreshes the interface based on the current settings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search( self ):\r\n        QApplication.instance().setOverrideCursor(Qt.WaitCursor)\n        \r\n        terms = nativestring(self.uiSearchTXT.text())\r\n        \r\n        html = []\r\n        \r\n        entry_html = '<a href=\"%(url)s\">%(title)s</a><br/>'\\\r\n                     '<small>%(url)s</small>'\r\n        \r\n        for i in range(self.uiContentsTREE.topLevelItemCount()):\r\n            item = self.uiContentsTREE.topLevelItem(i)\r\n            \r\n            results = item.search(terms)\n            results.sort(lambda x, y: cmp(y['strength'], x['strength']))\r\n            for item in results:\r\n                html.append( entry_html % item )\r\n        \r\n        if ( not html ):\r\n            html.append('<b>No results were found for %s</b>' % terms)\r\n        \r\n        self.uiSearchWEB.setHtml(SEARCH_HTML % '<br/><br/>'.join(html))\n        \n        QApplication.instance().restoreOverrideCursor()", "response": "Search the current set of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef browse( parent, filename = '' ):\n        dlg = XdkWindow(parent)\n        dlg.show()\n        \n        if ( filename ):\n            dlg.loadFilename(filename)", "response": "Browsing an XDK file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear(self):\n        \"Removes all entries from the config map\"\n        self._pb.IntMap.clear()\n        self._pb.StringMap.clear()\n        self._pb.FloatMap.clear()\n        self._pb.BoolMap.clear()", "response": "Removes all entries from the config map"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, *args, **kwargs):\n        for k, v in args:\n            self[k] = v\n        for k, v in kwargs.items():\n            self[k] = v", "response": "Update the ConfigMap from mapping and iterable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of ConfigMap keys.", "response": "def keys(self):\n        \"Returns a list of ConfigMap keys.\"\n        return (list(self._pb.IntMap.keys()) + list(self._pb.StringMap.keys()) +\n                list(self._pb.FloatMap.keys()) + list(self._pb.BoolMap.keys()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of ConfigMap values.", "response": "def values(self):\n        \"Returns a list of ConfigMap values.\"\n        return (list(self._pb.IntMap.values()) + list(self._pb.StringMap.values()) +\n                list(self._pb.FloatMap.values()) + list(self._pb.BoolMap.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iteritems(self):\n        \"Returns an iterator over the items of ConfigMap.\"\n        return chain(self._pb.StringMap.items(),\n                     self._pb.IntMap.items(),\n                     self._pb.FloatMap.items(),\n                     self._pb.BoolMap.items())", "response": "Returns an iterator over the items of ConfigMap."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef itervalues(self):\n        \"Returns an iterator over the values of ConfigMap.\"\n        return chain(self._pb.StringMap.values(),\n                     self._pb.IntMap.values(),\n                     self._pb.FloatMap.values(),\n                     self._pb.BoolMap.values())", "response": "Returns an iterator over the values of ConfigMap."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iterkeys(self):\n        \"Returns an iterator over the keys of ConfigMap.\"\n        return chain(self._pb.StringMap.keys(),\n                     self._pb.IntMap.keys(),\n                     self._pb.FloatMap.keys(),\n                     self._pb.BoolMap.keys())", "response": "Returns an iterator over the keys of ConfigMap."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of ( key value ) pairs as 2 - tuples.", "response": "def items(self):\n        \"Returns a list of (key, value) pairs as 2-tuples.\"\n        return (list(self._pb.IntMap.items()) + list(self._pb.StringMap.items()) +\n                list(self._pb.FloatMap.items()) + list(self._pb.BoolMap.items()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pop(self, key, default=None):\n        if key not in self:\n            if default is not None:\n                return default\n            raise KeyError(key)\n        for map in [self._pb.IntMap, self._pb.FloatMap, self._pb.StringMap,\n                    self._pb.BoolMap]:\n            if key in map.keys():\n                return map.pop(key)", "response": "Removes specified key and return the corresponding value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninterrupting the current database from processing.", "response": "def interrupt(self):\r\n        \"\"\"\r\n        Interrupts the current database from processing.\r\n        \"\"\"\r\n        if self._database and self._databaseThreadId:\r\n            # support Orb 2 interruption capabilities\r\n            try:\r\n                self._database.interrupt(self._databaseThreadId)\r\n            except AttributeError:\r\n                pass\r\n        \r\n        self._database = None\r\n        self._databaseThreadId = 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the database associated with this thread to the inputed database.", "response": "def setDatabase(self, database):\r\n        \"\"\"\r\n        Sets the database associated with this thread to the inputed database.\r\n        \r\n        :param      database | <orb.Database>\r\n        \"\"\"\r\n        self._database = database\r\n        if self.thread():\r\n            tid = threading.current_thread().ident\r\n            self._databaseThreadId = tid"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting until the main thread is finished.", "response": "def waitUntilFinished(self):\r\n        \"\"\"\r\n        Processes the main thread until the loading process has finished.  This\r\n        is a way to force the main thread to be synchronous in its execution.\r\n        \"\"\"\r\n        QtCore.QCoreApplication.processEvents()\r\n        while self.isLoading():\r\n            QtCore.QCoreApplication.processEvents()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assignAlignment(self, action):\r\n        if self._actions['align_left'] == action:\r\n            self.setAlignment(Qt.AlignLeft)\r\n        elif self._actions['align_right'] == action:\r\n            self.setAlignment(Qt.AlignRight)\r\n        elif self._actions['align_center'] == action:\r\n            self.setAlignment(Qt.AlignHCenter)\r\n        else:\r\n            self.setAlignment(Qt.AlignJustify)", "response": "Assigns the alignment for the given action to the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassigning the font family and point size settings from the font picker widget.", "response": "def assignFont(self):\r\n        \"\"\"\r\n        Assigns the font family and point size settings from the font picker\r\n        widget.\r\n        \"\"\"\r\n        font = self.currentFont()\r\n        font.setFamily(self._fontPickerWidget.currentFamily())\r\n        font.setPointSize(self._fontPickerWidget.pointSize())\r\n        self.setCurrentFont(font)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef blockSignals(self, state):\r\n        super(XRichTextEdit, self).blockSignals(state)\r\n        self.uiEditTXT.blockSignals(state)", "response": "Sets the state of the block signals for this editor down to the text\r\n        \r\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef eventFilter(self, object, event):\r\n        if event.type() != event.KeyPress:\r\n            return super(XRichTextEdit, self).eventFilter(object, event)\r\n        \r\n        cursor    = object.textCursor()\r\n        curr_list = cursor.currentList()\r\n        \r\n        # make sure we're in a current list\r\n        if not curr_list:\r\n            return super(XRichTextEdit, self).eventFilter(object, event)\r\n        \r\n        # unindent for Backtab (Shift+Tab)\r\n        if event.key() == Qt.Key_Backtab:\r\n            delta = -1\r\n        \r\n        # indent for Tab\r\n        elif event.key() == Qt.Key_Tab:\r\n            delta = 1\r\n        \r\n        # otherwise, don't bother calculating\r\n        else:\r\n            return super(XRichTextEdit, self).eventFilter(object, event)\r\n        \r\n        # look for the proper list to move to\r\n        curr_block      = cursor.block()\r\n        curr_indent     = curr_list.format().indent()\r\n        curr_style      = curr_list.format().style()\r\n        prev_block      = curr_block\r\n        next_block      = curr_block\r\n        add_to_list     = None\r\n        add_to_indent   = curr_indent + delta\r\n        \r\n        while prev_block or next_block:\r\n            if prev_block:\r\n                prev_block = prev_block.previous()\r\n                prev_list  = prev_block.textList()\r\n                \r\n                if not prev_list:\r\n                    prev_block = None\r\n                \r\n                else:\r\n                    prev_indent = prev_list.format().indent()\r\n                    \r\n                    if prev_indent == add_to_indent:\r\n                        add_to_list = prev_list\r\n                        break\r\n                    \r\n            if next_block:\r\n                next_block = next_block.next()\r\n                next_list  = next_block.textList()\r\n                \r\n                if not next_list:\r\n                    next_block = None\r\n                \r\n                else:\r\n                    next_indent = next_list.format().indent()\r\n                    \r\n                    if next_indent == add_to_indent:\r\n                        add_to_list = next_list\r\n                        break\r\n        \r\n        if add_to_list is None and 0 < delta:\r\n            if curr_style in (QTextListFormat.ListCircle,\r\n                              QTextListFormat.ListDisc,\r\n                              QTextListFormat.ListSquare):\r\n                self.insertUnorderedList()\r\n            else:\r\n                self.insertOrderedList()\r\n        \r\n        elif add_to_list:\r\n            add_to_list.add(curr_block)\r\n        \r\n        return True", "response": "Returns True if event should be handled by the appropriate eventFilter method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insertOrderedList(self):\r\n        cursor = self.editor().textCursor()\r\n        currlist = cursor.currentList()\r\n        new_style = QTextListFormat.ListDecimal\r\n        indent = 1\r\n        \r\n        if currlist:\r\n            format = currlist.format()\r\n            indent = format.indent() + 1\r\n            style  = format.style()\r\n            \r\n            if style == QTextListFormat.ListDecimal:\r\n                new_style = QTextListFormat.ListLowerRoman\r\n            elif style == QTextListFormat.ListLowerRoman:\r\n                new_style = QTextListFormat.ListUpperAlpha\r\n            elif style == QTextListFormat.ListUpperAlpha:\r\n                new_style = QTextListFormat.ListLowerAlpha\r\n        \r\n        new_format = QTextListFormat()\r\n        new_format.setStyle(new_style)\r\n        new_format.setIndent(indent)\r\n        new_list = cursor.createList(new_format)\r\n        \r\n        self.editor().setFocus()\r\n        \r\n        return new_list", "response": "Inserts an ordered list into the editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts an unordered list into the editor.", "response": "def insertUnorderedList(self):\r\n        \"\"\"\r\n        Inserts an ordered list into the editor.\r\n        \"\"\"\r\n        cursor = self.editor().textCursor()\r\n        currlist = cursor.currentList()\r\n        new_style = QTextListFormat.ListDisc\r\n        indent = 1\r\n        \r\n        if currlist:\r\n            format = currlist.format()\r\n            indent = format.indent() + 1\r\n            style  = format.style()\r\n            \r\n            if style == QTextListFormat.ListDisc:\r\n                new_style = QTextListFormat.ListCircle\r\n            elif style == QTextListFormat.ListCircle:\r\n                new_style = QTextListFormat.ListSquare\r\n        \r\n        new_format = QTextListFormat()\r\n        new_format.setStyle(new_style)\r\n        new_format.setIndent(indent)\r\n        new_list = cursor.createList(new_format)\r\n        \r\n        self.editor().setFocus()\r\n        \r\n        return new_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprompts the user to select a text color.", "response": "def pickTextBackgroundColor(self):\r\n        \"\"\"\r\n        Prompts the user to select a text color.\r\n        \"\"\"\r\n        clr = QColorDialog.getColor(self.textBackgroundColor(),\r\n                                    self.window(),\r\n                                    'Pick Background Color')\r\n        \r\n        if clr.isValid():\r\n            self.setTextBackgroundColor(clr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprompt the user to select a text color.", "response": "def pickTextColor(self):\r\n        \"\"\"\r\n        Prompts the user to select a text color.\r\n        \"\"\"\r\n        clr = QColorDialog.getColor(self.textColor(),\r\n                                    self.window(),\r\n                                    'Pick Text Color')\r\n        \r\n        if clr.isValid():\r\n            self.setTextColor(clr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef refreshUi(self):\r\n        font = self.currentFont()\r\n        \r\n        for name in ('underline', 'bold', 'italic', 'strikeOut'):\r\n            getter = getattr(font, name)\r\n            act = self._actions[name]\r\n            act.blockSignals(True)\r\n            act.setChecked(getter())\r\n            act.blockSignals(False)", "response": "Refreshes the UI for the current cursor positioning."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef refreshAlignmentUi(self):\r\n        align = self.alignment()\r\n        for name, value in (('align_left', Qt.AlignLeft),\r\n                            ('align_right', Qt.AlignRight),\r\n                            ('align_center', Qt.AlignHCenter),\r\n                            ('align_justify', Qt.AlignJustify)):\r\n            \r\n            act = self._actions[name]\r\n            act.blockSignals(True)\r\n            act.setChecked(value == align)\r\n            act.blockSignals(False)", "response": "Refreshes the alignment UI information."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the current alignment for this editor.", "response": "def setAlignment(self, align):\r\n        \"\"\"\r\n        Sets the current alignment for this editor.\r\n        \r\n        :param      align | <Qt.Align>\r\n        \"\"\"\r\n        self.blockSignals(True)\r\n        self.editor().setAlignment(align)\r\n        self.blockSignals(False)\r\n        self.refreshAlignmentUi()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current font for the editor.", "response": "def setCurrentFont(self, font):\r\n        \"\"\"\r\n        Sets the current font for the editor to the inputed font.\r\n        \r\n        :param      font | <QFont>\r\n        \"\"\"\r\n        self.blockSignals(True)\r\n        self.editor().setCurrentFont(font)\r\n        self.blockSignals(False)\r\n        self.refreshUi()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setFontBold(self, state):\r\n        if state:\r\n            weight = QFont.Bold\r\n        else:\r\n            weight = QFont.Normal\r\n        \r\n        self.setFontWeight(weight)", "response": "Sets the font bold for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the current font family to the inputed family.", "response": "def setFontFamily(self, family):\r\n        \"\"\"\r\n        Sets the current font family to the inputed family.\r\n        \r\n        :param      family | <str>\r\n        \"\"\"\r\n        self.blockSignals(True)\r\n        self.editor().setFontFamily(family)\r\n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setFontItalic(self, state):\r\n        font = self.currentFont()\r\n        font.setItalic(state)\r\n        self.setCurrentFont(font)", "response": "Sets the font italic or not."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setFontPointSize(self, size):\r\n        self.blockSignals(True)\r\n        self.editor().setFontPointSize(size)\r\n        self.blockSignals(False)", "response": "Sets the point size of the current font."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setFontStrikeOut(self, strikeOut):\r\n        font = self.currentFont()\r\n        font.setStrikeOut(strikeOut)\r\n        self.setCurrentFont(font)", "response": "Sets whether or not this editor is currently striking out the text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setFontUnderline(self, state):\r\n        font = self.currentFont()\r\n        font.setUnderline(state)\r\n        self.setCurrentFont(font)", "response": "Sets whether or not this editor is currently underlined."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the font weight for this editor to the inputed weight.", "response": "def setFontWeight(self, weight):\r\n        \"\"\"\r\n        Sets the font weight for this editor to the inputed weight.\r\n        \r\n        :param      weight | <QFont.Weight>\r\n        \"\"\"\r\n        font = self.currentFont()\r\n        font.setWeight(weight)\r\n        self.setCurrentFont(font)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef toDiv(self, style='document'):\r\n        if not self.editor().toPlainText():\r\n            return ''\r\n        \r\n        html = self.editor().document().toHtml(self.encoding())\r\n        html = projex.text.encoded(html, self.encoding())\r\n        html = html.replace('style=\"-qt-paragraph-type:empty',\r\n                     'class=\"paragraph_empty\" style=\"-qt-paragraph-type:empty')\r\n        \r\n        # strip out any existing style's because we want to control this\r\n        # via style sheets\r\n        results = re.findall(r'\\<(\\w+)\\s+(style=\"[^\"]*\")', html)\r\n        for tag, tag_style in results:\r\n            # keep any span stylings as these are inline additions\r\n            if tag == 'span':\r\n                continue\r\n            \r\n            html = html.replace(tag_style, '')\r\n        \r\n        start = '<body '\r\n        end = '</body>'\r\n        \r\n        start_i = html.find(start)\r\n        end_i = html.find(end)\r\n        \r\n        stripped = html[start_i+len(start):end_i]\r\n        \r\n        return '<div class=\"%s\" %s</div>' % (style, stripped)", "response": "Returns the text as paragaphed HTML vs. a full HTML document page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the font picker widget to the current font settings.", "response": "def updateFontPicker(self):\r\n        \"\"\"\r\n        Updates the font picker widget to the current font settings.\r\n        \"\"\"\r\n        font = self.currentFont()\r\n        self._fontPickerWidget.setPointSize(font.pointSize())\r\n        self._fontPickerWidget.setCurrentFamily(font.family())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns the main application for this instance and returns the success value.", "response": "def exec_(self):\r\n        \"\"\"\r\n        Runs the main application for this instance and returns the\r\n        success value.\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        # create the tray icon\r\n        if self.autoCreateTrayIcon() and not self.trayIcon():\r\n            try:\r\n                window = self.topLevelWindows()[0]\r\n            except IndexError:\r\n                pass\r\n            else:\r\n                # create the menu\r\n                menu = QtGui.QMenu(window)\r\n                \r\n                if self.applicationName():\r\n                    act = menu.addAction('Quit {0}'.format(self.applicationName()))\r\n                else:\r\n                    act = menu.addAction('Quit')\r\n                \r\n                act.triggered.connect(self.quit)\r\n                \r\n                # create the tray icon\r\n                icon = QtGui.QSystemTrayIcon()\r\n                icon.setIcon(self.windowIcon())\r\n                icon.setObjectName('trayIcon')\r\n                icon.setContextMenu(menu)\r\n                icon.setToolTip(self.applicationName())\r\n                icon.show()\r\n                \r\n                self._trayIcon = icon\r\n        \r\n        result = super(XApplication, self).exec_()\r\n        \r\n        # save the settings before exiting\r\n        self.saveSettings()\r\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first walkthrough with the given name or None if no walkthrough exists.", "response": "def findWalkthrough(self, name):\r\n        \"\"\"\r\n        Looks up the walkthrough based on the given name.\r\n        \r\n        :param      name | <str>\r\n        \"\"\"\r\n        for walkthrough in self._walkthroughs:\r\n            if walkthrough.name() == name:\r\n                return walkthrough\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef registerTopLevelWindow(self, window):\r\n        # set the main window for this instance\r\n        if not self._topLevelWindows:\r\n            self.setPalette(window.palette())\r\n            self.setWindowIcon(window.windowIcon())\r\n            \r\n            if self.splash():\r\n                self.splash().finish(window)\r\n        \r\n        self._topLevelWindows.append(weakref.ref(window))", "response": "Registers a top level window for this application."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef registerWalkthrough(self, walkthrough):\r\n        if not walkthrough in self._walkthroughs:\r\n            self._walkthroughs.append(walkthrough)", "response": "Registers the inputed walkthrough to the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets up a splash screen for the application for the given pixmap.", "response": "def setupSplash(self, pixmap, align=None, color='white', cls=None):\r\n        \"\"\"\r\n        Sets up a splash screen for the application for the given pixmap.\r\n        \r\n        :param      pixmap | <QtGui.QPixmap>\r\n                    align  | <QtCore.Qt.Alignment>\r\n                    color  | <QtGui.QColor>\r\n                    cls    | <subclass of QtGui.QSplashScreen>\r\n        \r\n        :return     <QtGui.QSplashScreen>\r\n        \"\"\"\r\n        if cls is None:\r\n            cls = XLoggerSplashScreen\r\n        if align is None:\r\n            align = QtCore.Qt.AlignLeft | QtCore.Qt.AlignBottom\r\n        \r\n        color = QtGui.QColor('white')\r\n        pixmap = QtGui.QPixmap(pixmap)\r\n        screen = cls(splash)\r\n        screen.setTextColor(color)\r\n        screen.setTextAlignment(align)\r\n        screen.show()\r\n        self.processEvents()\r\n        self._splash = screen\r\n        return screen"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setStoragePath(self, location, path):\r\n        if not path:\r\n            self._storagePaths.pop(location, None)\r\n        else:\r\n            self._storagePaths[location] = path", "response": "Sets the path associated with this application and user for the\r\n            given location."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef showMessage(self,\r\n                    title,\r\n                    message,\r\n                    icon=QtGui.QSystemTrayIcon.Information,\r\n                    timeout=10000):\r\n        \"\"\"\r\n        Displays a message to the user via the tray icon.\r\n        \r\n        :param      title   | <str>\r\n                    message | <str>\r\n                    icon    | <QtGui.QSystemTrayIcon.MessageIcon>\r\n                    timeout | <int>\r\n        \"\"\"\r\n        tray = self.trayIcon()\r\n        if tray:\r\n            tray.showMessage(title, message, icon, timeout)", "response": "Show a message to the user via the tray icon."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef showWalkthrough(self, walkthrough, force=False):\r\n        if type(walkthrough) in (str, unicode):\r\n            walkthrough = self.findWalkthrough(walkthrough)\r\n\r\n        if walkthrough:\r\n            self.walkthroughRequested.emit(walkthrough, force)", "response": "Emits the walkthroughRequested signal to display the given walkthrough information."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the path associated with this application and user for the given location.", "response": "def storagePath(self, location):\r\n        \"\"\"\r\n        Returns the path associated with this application and user for the\r\n        given location.\r\n        \r\n        :param      location | <QtGui.QDesktopServices.StandardLocation>\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        default = nativestring(QtGui.QDesktopServices.storageLocation(location))\r\n        return self._storagePaths.get(location, default)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef systemSettings(self):\r\n        if not self._systemSettings:\r\n            if self.isCompiled():\r\n                settings = QtCore.QSettings(XSettings.IniFormat,\r\n                                            XSettings.SystemScope,\r\n                                            self.organizationName(),\r\n                                            self.applicationName())\r\n                rootpath = os.path.dirname(settings.fileName())\r\n            else:\r\n                rootpath = os.path.abspath('.')\r\n\r\n            name = self.applicationName()\r\n            filename = os.path.join(rootpath, '{0}.yaml'.format(name))\r\n\r\n            self._systemSettings = XSettings(XSettings.YamlFormat,\r\n                                             XSettings.SystemScope,\r\n                                             self.organizationName(),\r\n                                             self.applicationName(),\r\n                                             filename=filename)\r\n\r\n        return self._systemSettings", "response": "Returns the system settings for this application for all users."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all top level windows for this application.", "response": "def topLevelWindows(self):\r\n        \"\"\"\r\n        Returns a list of the top level windows for this application.\r\n        \r\n        :return     [<QtGui.QMainWindow>, ..]\r\n        \"\"\"\r\n        out = []\r\n        clean = []\r\n        for ref in self._topLevelWindows:\r\n            window = ref()\r\n            if window is not None:\r\n                clean.append(ref)\r\n                out.append(window)\r\n\r\n        self._topLevelWindows = clean\r\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef userSettings(self):\r\n        if not self._userSettings:\r\n            name = self.applicationName()\r\n            if not self.isCompiled():\r\n                name + '.dev'\r\n            \r\n            self._userSettings = XSettings(XSettings.YamlFormat,\r\n                                           XSettings.UserScope,\r\n                                           self.organizationName(),\r\n                                           name)\r\n\r\n        return self._userSettings", "response": "Returns the settings associated with this application per user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new chart point to this item.", "response": "def addPoint( self, x, y ):\r\n        \"\"\"\r\n        Adds a new chart point to this item.\r\n        \r\n        :param      x | <variant>\r\n                    y | <variant>\r\n        \"\"\"\r\n        self._points.append((x, y))\r\n        self._dirty = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef chartType( self ):\r\n        if ( self._chartType ):\r\n            return self._chartType\r\n        \r\n        scene = self.scene()\r\n        if ( not scene ):\r\n            return 0\r\n        \r\n        return scene.chartType()", "response": "Returns the chart type for this item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning any drag information that will be used from this chart item.", "response": "def dragData(self, x=None, y=None):\r\n        \"\"\"\r\n        Returns any drag information that will be used from this chart item.\r\n        \r\n        :return     <QMimeData> || None\r\n        \"\"\"\r\n        # look for specific drag information for this item\r\n        first  = (x, y)\r\n        second = (x, None)\r\n        third  = (None, y)\r\n        fourth = (None, None)\r\n        \r\n        for key in (first, second, third, fourth):\r\n            data = self._dragData.get(key)\r\n            if data:\r\n                return data\r\n        \r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the tooltip of the currently hovered item.", "response": "def hoverMoveEvent( self, event ):\r\n        \"\"\"\r\n        Tracks whether or not this item is being hovered.\r\n        \r\n        :param      event | <QEvent>\r\n        \"\"\"\r\n        point = event.pos()\r\n        \r\n        found_key = ''\r\n        found = None\r\n        for key, value, subpath in self._subpaths:\r\n            if subpath.contains(point):\r\n                found = subpath\r\n                found_key = key\r\n                break\r\n        \r\n        if found:\r\n            # update the tooltip\r\n            tip    = self.keyToolTip(found_key)\r\n            if ( tip ):\r\n                widget = self.scene().chartWidget()\r\n                anchor = XPopupWidget.Anchor.RightCenter\r\n                \r\n                # show the popup widget\r\n                XPopupWidget.showToolTip(tip, \r\n                                         anchor = anchor,\r\n                                         parent = widget,\r\n                                         foreground = self.color().darker(120),\r\n                                         background = self.alternateColor())\r\n            \r\n            if ( found != self._hoveredPath ):\r\n                self._hoveredPath = found\r\n                self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the hovered path if the item is being hovered.", "response": "def hoverLeaveEvent( self, event ):\r\n        \"\"\"\r\n        Tracks whether or not this item is being hovered.\r\n        \r\n        :param      event | <QEvent>\r\n        \"\"\"\r\n        super(XChartWidgetItem, self).hoverEnterEvent(event)\r\n        \r\n        self._hoveredPath = None\r\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keyColor( self, key ):\r\n        self._keyColors.setdefault(nativestring(key), self.color())\r\n        return self._keyColors[nativestring(key)]", "response": "Returns a color for the inputed key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mousePressEvent(self, event):\r\n        near_x, near_y = self.nearestPoint(event.pos())\r\n        \r\n        data = self.dragData(x=near_x, y=near_y)\r\n        self.startDrag(data)\r\n        \r\n        super(XChartWidgetItem, self).mousePressEvent(event)", "response": "Create the drag event for this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nearestPoint(self, pos):\r\n        # lookup subpaths\r\n        for x, y, path in self._subpaths:\r\n            if path.contains(pos):\r\n                return (x, y)\r\n        \r\n        return (None, None)", "response": "Returns the nearest point for this item based on the inputed graph position."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws the items in the current scene.", "response": "def paint( self, painter, option, widget ):\r\n        \"\"\"\r\n        Draws this item with the inputed painter.\r\n        \r\n        :param      painter | <QPainter>\r\n                    rect    | <QRect>\r\n        \"\"\"\r\n        if self._dirty:\r\n            self.rebuild()\r\n        \r\n        scene   = self.scene()\r\n        if not scene:\r\n            return\r\n        \r\n        grid    = scene.gridRect()\r\n        typ     = self.chartType()\r\n        \r\n        # draw the line chart\r\n        if typ == XChartScene.Type.Line:\r\n            painter.setRenderHint(painter.Antialiasing)\r\n            \r\n            # draw the path area\r\n            area = self._buildData.get('path_area')\r\n            if area and self.isShaded():\r\n                clr   = QColor(self.color())\r\n                \r\n                clr.setAlpha(120)\r\n                painter.setPen(Qt.NoPen)\r\n                painter.setBrush(clr)\r\n                \r\n                painter.drawPath(area)\r\n            \r\n            # draw the line data\r\n            pen = QPen(self.color())\r\n            pen.setWidth(2)\r\n            \r\n            painter.setPen(pen)\r\n            painter.setBrush(Qt.NoBrush)\r\n            \r\n            painter.drawPath(self.path())\r\n            \r\n            if ( self.showPointsInLine() ):\r\n                palette = QApplication.palette()\r\n                pen = QPen(palette.color(palette.Base))\r\n                pen.setWidth(2)\r\n                \r\n                painter.setBrush(self.color())\r\n                painter.setPen(pen)\r\n                \r\n                for point in self._ellipses:\r\n                    painter.drawEllipse(point, \r\n                                        self.pointRadius(), \r\n                                        self.pointRadius())\r\n        \r\n        # draw a bar chart\r\n        elif typ == XChartScene.Type.Bar:\r\n            painter.setRenderHint(painter.Antialiasing)\r\n            \r\n            pen = QPen(self.color())\r\n            pen.setWidth(1)\r\n            painter.setPen(pen)\r\n            \r\n            for key, value, sub_path in self._subpaths:\r\n                gradient = QLinearGradient()\r\n                \r\n                clr = QColor(self.color())\r\n                \r\n                if ( sub_path != self._hoveredPath ):\r\n                    clr.setAlpha(130)\r\n                \r\n                gradient.setColorAt(0.0,  clr.lighter(140))\r\n                gradient.setColorAt(0.1,  clr.lighter(120))\r\n                gradient.setColorAt(0.25, clr.lighter(110))\r\n                gradient.setColorAt(1.0,  clr.lighter(105))\r\n                \r\n                if ( self.orientation() == Qt.Horizontal ):\r\n                    gradient.setStart(0, sub_path.boundingRect().top())\r\n                    gradient.setFinalStop(0, sub_path.boundingRect().bottom())\r\n                else:\r\n                    gradient.setStart(sub_path.boundingRect().left(), 0)\r\n                    gradient.setFinalStop(sub_path.boundingRect().right(), 0)\r\n                \r\n                painter.setBrush(gradient)\r\n                painter.drawPath(sub_path)\r\n        \r\n        # draw a simple pie chart (calculated by scene)\r\n        elif typ == XChartScene.Type.Pie:\r\n            painter.setRenderHint(painter.Antialiasing)\r\n            \r\n            center   = self.pieCenter()\r\n            radius   = self.radius()\r\n            \r\n            for key, value, sub_path in self._subpaths:\r\n                clr = self.keyColor(key)\r\n                \r\n                gradient = QRadialGradient(QPointF(0, 0), radius)\r\n                \r\n                a = QColor(clr.lighter(140))\r\n                b = QColor(clr.lighter(110))\r\n                \r\n                a.setAlpha(40)\r\n                b.setAlpha(80)\r\n                \r\n                # look for mouse over\r\n                if ( sub_path == self._hoveredPath ):\r\n                    a.setAlpha(100)\r\n                    b.setAlpha(200)\r\n                \r\n                gradient.setColorAt(0, a)\r\n                gradient.setColorAt(1, b)\r\n                \r\n                pen = QPen(clr)\r\n                pen.setWidth(1)\r\n                \r\n                painter.setBrush(gradient)\r\n                painter.setPen(pen)\r\n                \r\n                painter.drawPath(sub_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a random color.", "response": "def randomColor( self ):\r\n        \"\"\"\r\n        Generates a random color.\r\n        \r\n        :return     <QColor>\r\n        \"\"\"\r\n        r = random.randint(120, 180)\r\n        g = random.randint(120, 180)\r\n        b = random.randint(120, 180)\r\n        \r\n        return QColor(r, g, b)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rebuild( self ):\r\n        scene       = self.scene()\r\n        if not scene:\r\n            return\r\n        \r\n        self._subpaths = []\r\n        \r\n        grid        = scene.gridRect()\r\n        typ         = self.chartType()\r\n        \r\n        hruler      = scene.horizontalRuler()\r\n        vruler      = scene.verticalRuler()\r\n        \r\n        path        = QPainterPath()\r\n        area        = QPainterPath()\r\n        \r\n        self._buildData.clear()\r\n        self._buildData['path_area'] = area\r\n        \r\n        self.setPos(0, 0)\r\n        \r\n        # draw a line item\r\n        if typ == XChartScene.Type.Line:\r\n            first = True\r\n            pos   = None\r\n            home  = None\r\n            self._ellipses = []\r\n            \r\n            points = self.points()\r\n            if ( self.orientation() == Qt.Horizontal ):\r\n                points.sort(hruler.compareValues, key = lambda x: x[0])\r\n            else:\r\n                points.sort(vruler.compareValues, key = lambda y: y[1])\r\n                points.reverse()\r\n            \r\n            for x, y in self.points():\r\n                pos = scene.mapFromChart(x, y)\r\n                if first:\r\n                    home = QPointF(pos.x(), grid.bottom())\r\n                    area.moveTo(home)\r\n                    area.lineTo(pos)\r\n                    path.moveTo(pos)\r\n                    \r\n                    self._ellipses.append(pos)\r\n                    \r\n                    first = False\r\n                else:\r\n                    path.lineTo(pos)\r\n                    area.lineTo(pos)\r\n                    \r\n                    self._ellipses.append(pos)\r\n            \r\n            if pos and home:\r\n                area.lineTo(pos.x(), grid.bottom())\r\n                area.lineTo(home)\r\n        \r\n        # draw a bar item\r\n        elif typ == XChartScene.Type.Bar:\r\n            barsize = self.barSize()\r\n            horiz   = self.orientation() == Qt.Horizontal\r\n            \r\n            for x, y in self.points():\r\n                pos = scene.mapFromChart(x, y)\r\n                subpath = QPainterPath()\r\n                if horiz:\r\n                    r = min(grid.bottom() - pos.y(), 8)\r\n                    \r\n                    subpath.moveTo(pos.x() - barsize / 2.0, grid.bottom())\r\n                    subpath.lineTo(pos.x() - barsize / 2.0, pos.y() + r)\r\n                    subpath.quadTo(pos.x() - barsize / 2.0, pos.y(),\r\n                                   pos.x() - barsize / 2.0 + r, pos.y())\r\n                    \r\n                    subpath.lineTo(pos.x() + barsize / 2.0 - r, pos.y())\r\n                    subpath.quadTo(pos.x() + barsize / 2.0, pos.y(),\r\n                                   pos.x() + barsize / 2.0, pos.y() + r)\r\n                    \r\n                    subpath.lineTo(pos.x() + barsize / 2.0, grid.bottom())\r\n                    subpath.lineTo(pos.x() - barsize / 2.0, grid.bottom())\r\n                else:\r\n                    subpath.moveTo(grid.left(), pos.y() - barsize / 2.0)\r\n                    subpath.lineTo(pos.x(),     pos.y() - barsize / 2.0)\r\n                    subpath.lineTo(pos.x(),     pos.y() + barsize / 2.0)\r\n                    subpath.lineTo(grid.left(), pos.y() + barsize / 2.0)\r\n                    subpath.lineTo(grid.left(), pos.y() - barsize / 2.0)\r\n                \r\n                path.addPath(subpath)\r\n                self._subpaths.append((x, y, subpath))\r\n        \r\n        # draw a pie chart\r\n        elif typ == XChartScene.Type.Pie:\r\n            if self.orientation() == Qt.Horizontal:\r\n                key_index   = 0\r\n                value_index = 1\r\n                value_ruler = self.verticalRuler()\r\n            else:\r\n                key_index   = 1\r\n                value_index = 0\r\n                value_ruler = self.horizontalRuler()\r\n        \r\n            pie_values = {}\r\n            \r\n            for point in self.points():\r\n                key     = point[key_index]\r\n                value   = point[value_index]\r\n                \r\n                pie_values.setdefault(key, [])\r\n                pie_values[key].append(value)\r\n        \r\n            for key, values in pie_values.items():\r\n                pie_values[key] = value_ruler.calcTotal(values)\r\n            \r\n            total = max(1, value_ruler.calcTotal(pie_values.values()))\r\n            \r\n            # calculate drawing parameters\r\n            center   = self.pieCenter()\r\n            radius   = self.radius()\r\n            diameter = radius * 2\r\n            angle    = 0\r\n            bound    = QRectF(-radius, -radius, diameter, diameter)\r\n            \r\n            for key, value in sorted(pie_values.items(), key = lambda x: x[1]):\r\n                # calculate the percentage\r\n                perc  = float(value) / total\r\n                \r\n                # calculate the angle as the perc * 360\r\n                item_angle = perc * 360\r\n                self.setPos(center)\r\n                \r\n                sub_path = QPainterPath()\r\n                sub_path.arcTo(bound, angle, item_angle)\r\n                sub_path.lineTo(0, 0)\r\n                \r\n                path.addPath(sub_path)\r\n                self._subpaths.append((key, value, sub_path))\r\n                \r\n                angle += item_angle\r\n                \r\n        self.setPath(path)\r\n        self._dirty = False", "response": "Rebuilds the item based on the current points and the current orientation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setColor( self, color ):\r\n        self._color = QColor(color)\r\n        self.setAlternateColor(self._color.lighter(140))", "response": "Sets the color for this widget to the inputed color."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the drag data for this chart item.", "response": "def setDragData(self, data, x=None, y=None):\r\n        \"\"\"\r\n        Sets the drag data for this chart item to the inputed data.\r\n        \r\n        :param      data | <QMimeData> || None\r\n        \"\"\"\r\n        self._dragData[(x, y)] = data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setKeyColor( self, key, color ):\r\n        self._keyColors[nativestring(key)] = QColor(color)", "response": "Sets the color used when rendering pie charts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef startDrag(self, data):\r\n        if not data:\r\n            return\r\n        \r\n        widget = self.scene().chartWidget()\r\n        drag = QDrag(widget)\r\n        drag.setMimeData(data)\r\n        drag.exec_()", "response": "Starts dragging information from this item based on the mime data provided."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadjusting the margins to incorporate enough room for the title and sub - title.", "response": "def adjustMargins(self):\n        \"\"\"\n        Adjusts the margins to incorporate enough room for the widget's title and sub-title.\n        \"\"\"\n        y = 0\n        height = 0\n        if self._titleLabel.text():\n            height += self._titleLabel.height() + 3\n            y += height\n\n        if self._subTitleLabel.text():\n            self._subTitleLabel.move(0, y)\n            height += self._subTitleLabel.height() + 3\n\n        self.setContentsMargins(0, height, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nextId(self):\n        if self._nextId is not None:\n            return self._nextId\n\n        wizard = self.wizard()\n        curr_id = wizard.currentId()\n        all_ids = wizard.pageIds()\n        try:\n            return all_ids[all_ids.index(curr_id)+1]\n        except IndexError:\n            return -1", "response": "Returns the next id for this page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setSubTitle(self, title):\n        self._subTitleLabel.setText(title)\n        self._subTitleLabel.adjustSize()\n        self.adjustMargins()", "response": "Sets the sub - title for this page to the inputed title."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setTitle(self, title):\n        self._titleLabel.setText(title)\n        self._titleLabel.adjustSize()\n        self.adjustMargins()", "response": "Sets the title for this page to the inputed title."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadjusting the size of this wizard and its page contents to the inputed size.", "response": "def adjustSize(self):\n        \"\"\"\n        Adjusts the size of this wizard and its page contents to the inputed size.\n\n        :param      size | <QtCore.QSize>\n        \"\"\"\n        super(XOverlayWizard, self).adjustSize()\n\n        # adjust the page size\n        page_size = self.pageSize()\n\n        # resize the current page to the inputed size\n        x = (self.width() - page_size.width()) / 2\n        y = (self.height() - page_size.height()) / 2\n        btn_height = max([btn.height() for btn in self._buttons.values()])\n\n        curr_page = self.currentPage()\n        for page in self._pages.values():\n            page.resize(page_size.width(), page_size.height() - btn_height - 6)\n            if page == curr_page:\n                page.move(x, y)\n            else:\n                page.move(self.width(), y)\n\n        # move the left most buttons\n        y += page_size.height() - btn_height\n        left_btns = (self._buttons[self.WizardButton.HelpButton], self._buttons[self.WizardButton.BackButton])\n        for btn in left_btns:\n            if btn.isVisible():\n                btn.move(x, y)\n                btn.raise_()\n                x += btn.width() + 6\n\n        # move the right buttons\n        x = self.width() - (self.width() - page_size.width()) / 2\n        for key in reversed(sorted(self._buttons.keys())):\n            btn = self._buttons[key]\n            if not btn.isVisible() or btn in left_btns:\n                continue\n\n            btn.move(x - btn.width(), y)\n            btn.raise_()\n            x -= btn.width() + 6"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef back(self):\n        try:\n            pageId = self._navigation[-2]\n            last_page = self.page(pageId)\n        except IndexError:\n            return\n\n        curr_page = self.page(self._navigation.pop())\n        if not (last_page and curr_page):\n            return\n\n        self._currentId = pageId\n\n        y = curr_page.y()\n        last_page.move(-last_page.width(), y)\n        last_page.show()\n\n        # animate the last page in\n        anim_in = QtCore.QPropertyAnimation(self)\n        anim_in.setTargetObject(last_page)\n        anim_in.setPropertyName('pos')\n        anim_in.setStartValue(last_page.pos())\n        anim_in.setEndValue(curr_page.pos())\n        anim_in.setDuration(self.animationSpeed())\n        anim_in.setEasingCurve(QtCore.QEasingCurve.Linear)\n\n        # animate the current page out\n        anim_out = QtCore.QPropertyAnimation(self)\n        anim_out.setTargetObject(curr_page)\n        anim_out.setPropertyName('pos')\n        anim_out.setStartValue(curr_page.pos())\n        anim_out.setEndValue(QtCore.QPoint(self.width()+curr_page.width(), y))\n        anim_out.setDuration(self.animationSpeed())\n        anim_out.setEasingCurve(QtCore.QEasingCurve.Linear)\n\n        # create the anim group\n        anim_grp = QtCore.QParallelAnimationGroup(self)\n        anim_grp.addAnimation(anim_in)\n        anim_grp.addAnimation(anim_out)\n        anim_grp.finished.connect(curr_page.hide)\n        anim_grp.finished.connect(anim_grp.deleteLater)\n\n        # update the button states\n        self._buttons[self.WizardButton.BackButton].setVisible(self.canGoBack())\n        self._buttons[self.WizardButton.NextButton].setVisible(True)\n        self._buttons[self.WizardButton.RetryButton].setVisible(self.canRetry())\n        self._buttons[self.WizardButton.CommitButton].setVisible(last_page.isCommitPage())\n        self._buttons[self.WizardButton.FinishButton].setVisible(last_page.isFinalPage())\n\n        self.adjustSize()\n        self.currentIdChanged.emit(pageId)\n        anim_grp.start()", "response": "Goes to the previous page for this wizard."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning whether or not this wizard can move forward.", "response": "def canGoBack(self):\n        \"\"\"\n        Returns whether or not this wizard can move forward.\n\n        :return     <bool>\n        \"\"\"\n        try:\n            backId = self._navigation.index(self.currentId())-1\n            if backId >= 0:\n                self._navigation[backId]\n            else:\n                return False\n        except StandardError:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef next(self):\n        curr_page = self.currentPage()\n        if not curr_page:\n            return\n        elif not curr_page.validatePage():\n            return\n\n        pageId = curr_page.nextId()\n        try:\n            next_page = self._pages[pageId]\n        except KeyError:\n            return\n\n        self._currentId = pageId\n        self._navigation.append(pageId)\n\n        y = curr_page.y()\n        next_page.move(self.width(), y)\n\n        # animate the last page in\n        anim_in = QtCore.QPropertyAnimation(self)\n        anim_in.setTargetObject(curr_page)\n        anim_in.setPropertyName('pos')\n        anim_in.setStartValue(curr_page.pos())\n        anim_in.setEndValue(QtCore.QPoint(-curr_page.width(), y))\n        anim_in.setDuration(self.animationSpeed())\n        anim_in.setEasingCurve(QtCore.QEasingCurve.Linear)\n\n        # animate the current page out\n        anim_out = QtCore.QPropertyAnimation(self)\n        anim_out.setTargetObject(next_page)\n        anim_out.setPropertyName('pos')\n        anim_out.setStartValue(next_page.pos())\n        anim_out.setEndValue(curr_page.pos())\n        anim_out.setDuration(self.animationSpeed())\n        anim_out.setEasingCurve(QtCore.QEasingCurve.Linear)\n\n        # create the anim group\n        anim_grp = QtCore.QParallelAnimationGroup(self)\n        anim_grp.addAnimation(anim_in)\n        anim_grp.addAnimation(anim_out)\n        anim_grp.finished.connect(curr_page.hide)\n        anim_grp.finished.connect(anim_grp.deleteLater)\n\n        next_page.show()\n\n        # update the button states\n        self._buttons[self.WizardButton.BackButton].setVisible(True)\n        self._buttons[self.WizardButton.NextButton].setVisible(self.canGoForward())\n        self._buttons[self.WizardButton.RetryButton].setVisible(self.canRetry())\n        self._buttons[self.WizardButton.CommitButton].setVisible(next_page.isCommitPage())\n        self._buttons[self.WizardButton.FinishButton].setVisible(next_page.isFinalPage())\n        self.adjustSize()\n\n        # initialize the new page\n        self.currentIdChanged.emit(pageId)\n        next_page.initializePage()\n        anim_grp.start()", "response": "Goes to the next page for this wizard."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pageSize(self):\n\n        # update the size based on the new size\n        page_size = self.fixedPageSize()\n        if page_size.isEmpty():\n            w = self.width() - 80\n            h = self.height() - 80\n\n            min_w = self.minimumPageSize().width()\n            min_h = self.minimumPageSize().height()\n            max_w = self.maximumPageSize().width()\n            max_h = self.maximumPageSize().height()\n\n            page_size = QtCore.QSize(min(max(min_w, w), max_w), min(max(min_h, h), max_h))\n        return page_size", "response": "Returns the current page size for this wizard."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef restart(self):\n        # hide all of the pages\n        for page in self._pages.values():\n            page.hide()\n\n        pageId = self.startId()\n        try:\n            first_page = self._pages[pageId]\n        except KeyError:\n            return\n\n        self._currentId = pageId\n        self._navigation = [pageId]\n\n        page_size = self.pageSize()\n        x = (self.width() - page_size.width()) / 2\n        y = (self.height() - page_size.height()) / 2\n\n        first_page.move(self.width()+first_page.width(), y)\n        first_page.show()\n\n        # animate the current page out\n        anim_out = QtCore.QPropertyAnimation(self)\n        anim_out.setTargetObject(first_page)\n        anim_out.setPropertyName('pos')\n        anim_out.setStartValue(first_page.pos())\n        anim_out.setEndValue(QtCore.QPoint(x, y))\n        anim_out.setDuration(self.animationSpeed())\n        anim_out.setEasingCurve(QtCore.QEasingCurve.Linear)\n        anim_out.finished.connect(anim_out.deleteLater)\n\n        # update the button states\n        self._buttons[self.WizardButton.BackButton].setVisible(False)\n        self._buttons[self.WizardButton.NextButton].setVisible(self.canGoForward())\n        self._buttons[self.WizardButton.CommitButton].setVisible(first_page.isCommitPage())\n        self._buttons[self.WizardButton.FinishButton].setVisible(first_page.isFinalPage())\n        self.adjustSize()\n\n        first_page.initializePage()\n        self.currentIdChanged.emit(pageId)\n        anim_out.start()", "response": "Restarts the whole wizard from the beginning."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removePage(self, pageId):\n        try:\n            self._pages[pageId].deleteLater()\n            del self._pages[pageId]\n        except KeyError:\n            pass", "response": "Removes the inputed page from this wizard."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setButton(self, which, button):\n        try:\n            self._buttons[which].deleteLater()\n        except KeyError:\n            pass\n\n        button.setParent(self)\n        self._buttons[which] = button", "response": "Sets the button for this wizard for the inputed type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the display text for the inputed button to the given text.", "response": "def setButtonText(self, which, text):\n        \"\"\"\n        Sets the display text for the inputed button to the given text.\n\n        :param      which | <XOverlayWizard.WizardButton>\n                    text  | <str>\n        \"\"\"\n        try:\n            self._buttons[which].setText(text)\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the page and id for the given page.", "response": "def setPage(self, pageId, page):\n        \"\"\"\n        Sets the page and id for the given page vs. auto-constructing it.  This will allow the\n        developer to create a custom order for IDs.\n\n        :param      pageId | <int>\n                    page   | <projexui.widgets.xoverlaywizard.XOverlayWizardPage>\n        \"\"\"\n        page.setParent(self)\n\n        if self.property(\"useShadow\") is not False:\n            # create the drop shadow effect\n            effect = QtGui.QGraphicsDropShadowEffect(page)\n            effect.setColor(QtGui.QColor('black'))\n            effect.setBlurRadius(50)\n            effect.setOffset(0, 0)\n\n            page.setGraphicsEffect(effect)\n\n        self._pages[pageId] = page\n        if self._startId == -1:\n            self._startId = pageId"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_options(self):\n        if self.version.build_metadata:\n            return set(self.version.build_metadata.split('.'))\n        else:\n            return set()", "response": "The package build options."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a package_expression into a : class : Package object.", "response": "def parse(self, package_expression):\n        \"\"\"Parse a ``package_expression`` into a :class:`Package` object.\n        \"\"\"\n        parts = re.split(r'\\s*;\\s*', package_expression)\n        name_ver_str = parts[0]\n        infos = parts[1:]\n        dependencies = set()\n\n        name_ver_match = RE.match(name_ver_str)\n        if not name_ver_match:\n            raise InvalidPackageExpression(name_ver_str)\n\n        name, version_str = name_ver_match.groups()\n        version = Version.parse(version_str)\n\n        for info in infos:\n            if info.startswith('depends '):\n                dependency_str = info.split(' ', 1)[1]\n                dependency = Requirement.parse(dependency_str)\n                dependencies.add(dependency)\n            else:\n                raise InvalidPackageInfo(info)\n\n        return Package(name, version, dependencies)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the score of the string using the GAST using the Chernyak algorithm described in Section 1. 3 & 1. 4.", "response": "def score(self, query, normalized=True, synonimizer=None, return_suffix_scores=False):\n        \"\"\"\n        Matches the string against the GAST using\n        the algorithm described in [Chernyak, sections 1.3 & 1.4].\n        \n        Expects the input string to consist of\n        alphabet letters only (no whitespaces etc.)\n        \n        Returns the score (a float in [0, 1]).\n        \n        query -- Unicode\n        \n        \"\"\"\n        \n        query = query.replace(\" \", \"\")\n        result = 0\n        suffix_scores = {}\n    \n        # For each suffix of the string:\n        for suffix_start in xrange(len(query)):\n            \n            suffix = query[suffix_start:]\n            suffix_score = 0\n            suffix_result = 0\n            matched_chars = 0\n            nodes_matched = 0\n            \n            child_node = self.root.chose_arc(suffix)\n            while child_node:\n                nodes_matched += 1\n                (str_ind, substr_start, substr_end) = child_node.arc()\n                match = utils.match_strings(\n                            suffix, self.strings_collection[str_ind][substr_start:substr_end])\n                suffix_score += child_node.conditional_probability()\n                matched_chars += match\n                suffix = suffix[match:]\n                if suffix and match == substr_end - substr_start:\n                    child_node = child_node.chose_arc(suffix)\n                else:\n                    break\n            \n            if matched_chars:\n                suffix_result = (suffix_score + matched_chars - nodes_matched)\n                if normalized:\n                    suffix_result /= matched_chars\n                result += suffix_result\n\n            suffix_scores[query[suffix_start:]] = suffix_result\n                    \n        result /= len(query)\n\n        if return_suffix_scores:\n            result = result, suffix_scores\n        \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the selected text for this edit.", "response": "def clearSelection(self):\r\n        \"\"\"\r\n        Clears the selected text for this edit.\r\n        \"\"\"\r\n        first = None\r\n        editors = self.editors()\r\n        for editor in editors:\r\n            if not editor.selectedText():\r\n               continue\r\n            \r\n            first = first or editor\r\n            editor.backspace()\r\n        \r\n        for editor in editors:\r\n            editor.setFocus()\r\n        \r\n        if first:\r\n            first.setFocus()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncut the text from the serial to the clipboard.", "response": "def cut(self):\r\n        \"\"\"\r\n        Cuts the text from the serial to the clipboard.\r\n        \"\"\"\r\n        text = self.selectedText()\r\n        for editor in self.editors():\r\n            editor.cut()\r\n        \r\n        QtGui.QApplication.clipboard().setText(text)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of editors that are associated with this edit.", "response": "def editors(self):\r\n        \"\"\"\r\n        Returns the editors that are associated with this edit.\r\n        \r\n        :return     [<XLineEdit>, ..]\r\n        \"\"\"\r\n        lay = self.layout()\r\n        return [lay.itemAt(i).widget() for i in range(lay.count())]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn true if the object is in the list and False otherwise.", "response": "def eventFilter(self, object, event):\r\n        \"\"\"\r\n        Filters the events for the editors to control how the cursor\r\n        flows between them.\r\n        \r\n        :param      object | <QtCore.QObject>\r\n                    event  | <QtCore.QEvent>\r\n\r\n        :return     <bool> | consumed\r\n        \"\"\"\r\n        index = self.indexOf(object)\r\n        pressed = event.type() == event.KeyPress\r\n        released = event.type() == event.KeyRelease\r\n        \r\n        if index == -1 or \\\r\n           not (pressed or released) or \\\r\n           self.isEditorHandlingBlocked():\r\n            return super(XSerialEdit, self).eventFilter(object, event)\r\n        \r\n        text = nativestring(event.text()).strip()\r\n        \r\n        # handle Ctrl+C (copy)\r\n        if event.key() == QtCore.Qt.Key_C and \\\r\n           event.modifiers() == QtCore.Qt.ControlModifier and \\\r\n           pressed:\r\n            self.copy()\r\n            return True\r\n        \r\n        # handle Ctrl+X (cut)\r\n        elif event.key() == QtCore.Qt.Key_X and \\\r\n             event.modifiers() == QtCore.Qt.ControlModifier and \\\r\n             pressed:\r\n            if not self.isReadOnly():\r\n                self.cut()\r\n            return True\r\n        \r\n        # handle Ctrl+A (select all)\r\n        elif event.key() == QtCore.Qt.Key_A and \\\r\n             event.modifiers() == QtCore.Qt.ControlModifier and \\\r\n             pressed:\r\n            self.selectAll()\r\n            return True\r\n        \r\n        # handle Ctrl+V (paste)\r\n        elif event.key() == QtCore.Qt.Key_V and \\\r\n             event.modifiers() == QtCore.Qt.ControlModifier and \\\r\n             pressed:\r\n            if not self.isReadOnly():\r\n                self.paste()\r\n            return True\r\n        \r\n        # ignore tab movements\r\n        elif event.key() in (QtCore.Qt.Key_Tab, QtCore.Qt.Key_Backtab):\r\n            pass\r\n        \r\n        # delete all selected text\r\n        elif event.key() == QtCore.Qt.Key_Backspace:\r\n            sel_text = self.selectedText()\r\n            if sel_text and not self.isReadOnly():\r\n                self.clearSelection()\r\n                return True\r\n        \r\n        # ignore modified keys\r\n        elif not released:\r\n            return super(XSerialEdit, self).eventFilter(object, event)\r\n        \r\n        # move to the previous editor\r\n        elif object.cursorPosition() == 0:\r\n            if event.key() in (QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Left):\r\n                self.goBack()\r\n        \r\n        # move to next editor\r\n        elif object.cursorPosition() == object.maxLength():\r\n            valid_chars = string.ascii_letters + string.digits\r\n            valid_text = text != '' and text in valid_chars\r\n            \r\n            if valid_text or event.key() == QtCore.Qt.Key_Right:\r\n                self.goForward()\r\n        \r\n        return super(XSerialEdit, self).eventFilter(object, event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef goBack(self):\r\n        index = self.indexOf(self.currentEditor())\r\n        if index == -1:\r\n            return\r\n        \r\n        previous = self.editorAt(index - 1)\r\n        if previous:\r\n            previous.setFocus()\r\n            previous.setCursorPosition(self.sectionLength())", "response": "Moves the cursor to the end of the previous editor"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmoving the cursor to the beginning of the next editor.", "response": "def goForward(self):\r\n        \"\"\"\r\n        Moves the cursor to the beginning of the next editor.\r\n        \"\"\"\r\n        index = self.indexOf(self.currentEditor())\r\n        if index == -1:\r\n            return\r\n        \r\n        next = self.editorAt(index + 1)\r\n        if next:\r\n            next.setFocus()\r\n            next.setCursorPosition(0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the index of the inputed editor in the list of items in the current tree.", "response": "def indexOf(self, editor):\r\n        \"\"\"\r\n        Returns the index of the inputed editor, or -1 if not found.\r\n        \r\n        :param      editor | <QtGui.QWidget>\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        lay = self.layout()\r\n        for i in range(lay.count()):\r\n            if lay.itemAt(i).widget() == editor:\r\n                return i\r\n        return -1"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the selected text from the editors.", "response": "def selectedText(self):\r\n        \"\"\"\r\n        Returns the selected text from the editors.\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        texts = []\r\n        for editor in self.editors():\r\n            text = editor.selectedText()\r\n            if text:\r\n                texts.append(nativestring(text))\r\n        \r\n        return ' '.join(texts)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef selectAll(self):\r\n        self.blockEditorHandling(True)\r\n        for editor in self.editors():\r\n            editor.selectAll()\r\n        self.blockEditorHandling(False)", "response": "Selects the text within all the editors."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the hint to the inputed text. The same hint will be used for all editors in this widget.", "response": "def setHint(self, text):\r\n        \"\"\"\r\n        Sets the hint to the inputed text.   The same hint will be used for\r\n        all editors in this widget.\r\n        \r\n        :param      text | <str>\r\n        \"\"\"\r\n        texts = nativestring(text).split(' ')\r\n        \r\n        for i, text in enumerate(texts):\r\n            editor = self.editorAt(i)\r\n            if not editor:\r\n                break\r\n            \r\n            editor.setHint(text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset whether or not this edit is read only.", "response": "def setReadOnly(self, state):\r\n        \"\"\"\r\n        Sets whether or not this edit is read only.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self._readOnly = state\r\n        \r\n        for editor in self.editors():\r\n            editor.setReadOnly(state)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setSectionCount(self, count):\r\n        # cap the sections at 10\r\n        count = max(1, min(count, 10))\r\n        \r\n        # create additional editors\r\n        while self.layout().count() < count:\r\n            editor = XLineEdit(self)\r\n            editor.setFont(self.font())\r\n            editor.setReadOnly(self.isReadOnly())\r\n            editor.setHint(self.hint())\r\n            editor.setAlignment(QtCore.Qt.AlignCenter)\r\n            editor.installEventFilter(self)\r\n            editor.setSizePolicy(QtGui.QSizePolicy.Expanding,\r\n                                 QtGui.QSizePolicy.Expanding)\r\n            editor.setMaxLength(self.sectionLength())\r\n            editor.returnPressed.connect(self.returnPressed)\r\n            self.layout().addWidget(editor)\r\n        \r\n        # remove unnecessary editors\r\n        while count < self.layout().count():\r\n            widget = self.layout().itemAt(0).widget()\r\n            widget.close()\r\n            widget.setParent(None)\r\n            widget.deleteLater()", "response": "Sets the number of editors that the serial widget should have at least count lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setSectionLength(self, length):\r\n        self._sectionLength = length\r\n        for editor in self.editors():\r\n            editor.setMaxLength(length)", "response": "Sets the number of characters per section that are allowed."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nenters maintenance mode for a specific user.", "response": "async def disable(self, reason=None):\n        \"\"\"Enters maintenance mode\n\n        Parameters:\n            reason (str): Reason of disabling\n        Returns:\n            bool: ``True`` on success\n        \"\"\"\n        params = {\"enable\": True, \"reason\": reason}\n        response = await self._api.put(\"/v1/agent/maintenance\", params=params)\n        return response.status == 200"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresume normal operation on the current resource.", "response": "async def enable(self, reason=None):\n        \"\"\"Resumes normal operation\n\n        Parameters:\n            reason (str): Reason of enabling\n        Returns:\n            bool: ``True`` on success\n        \"\"\"\n        params = {\"enable\": False, \"reason\": reason}\n        response = await self._api.put(\"/v1/agent/maintenance\", params=params)\n        return response.status == 200"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_datetime(dt):\n    '''Parse an ISO datetime, which Python does buggily.'''\n    d = datetime.strptime(dt[:-1], ISOFORMAT)\n\n    if dt[-1:] == 'Z':\n        return timezone('utc').localize(d)\n    else:\n        return d", "response": "Parse an ISO datetime which Python does buggily."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef currentGrouping( self ):\r\n        groupBy = self.groupBy()\r\n        if ( groupBy == XOrbBrowserWidget.GroupByAdvancedKey ):\r\n            return self.advancedGrouping()\r\n        else:\r\n            table = self.tableType()\r\n            if ( not table ):\r\n                return []\r\n            \r\n            for column in table.schema().columns():\r\n                if ( column.displayName() == groupBy ):\r\n                    return [column.name()]\r\n            \r\n            return []", "response": "Returns the current grouping for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef currentRecord( self ):\r\n        if ( self.currentMode() == XOrbBrowserWidget.Mode.Detail ):\r\n            return self.detailWidget().currentRecord()\r\n        \r\n        elif ( self.currentMode() == XOrbBrowserWidget.Mode.Thumbnail ):\r\n            item = self.thumbnailWidget().currentItem()\r\n            if ( isinstance(item, RecordListWidgetItem) ):\r\n                return item.record()\r\n            return None\r\n        \r\n        else:\r\n            item = self.uiCardTREE.currentItem()\r\n            widget = self.uiCardTREE.itemWidget(item, 0)\r\n            if ( isinstance(widget, XAbstractCardWidget) ):\r\n                return widget.record()\r\n            \r\n            return None", "response": "Returns the current record from this browser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef currentMode( self ):\r\n        if ( self.uiCardACT.isChecked() ):\r\n            return XOrbBrowserWidget.Mode.Card\r\n        elif ( self.uiDetailsACT.isChecked() ):\r\n            return XOrbBrowserWidget.Mode.Detail\r\n        else:\r\n            return XOrbBrowserWidget.Mode.Thumbnail", "response": "Returns the current mode for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enabledModes( self ):\r\n        output = 0\r\n        for i, action in enumerate((self.uiDetailsACT,\r\n                                    self.uiCardACT,\r\n                                    self.uiThumbnailACT)):\r\n            if ( action.isEnabled() ):\r\n                output |= int(math.pow(2, i))\r\n        return output", "response": "Returns the binary value of the enabled modes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eventFilter( self, object, event ):\r\n        if ( event.type() == event.Resize and \\\r\n             self.currentMode() == XOrbBrowserWidget.Mode.Thumbnail and \\\r\n             self.isGroupingActive() ):\r\n            size = QSize(event.size().width() - 20, 22)\r\n            for row in range(object.count()):\r\n                item = object.item(row)\r\n                if ( isinstance(item, GroupListWidgetItem) ):\r\n                    item.setSizeHint(size)\r\n        return False", "response": "Updates the size of the items in the group list widget based on the event type."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles when a card item is double clicked on.", "response": "def handleCardDblClick( self, item ):\r\n        \"\"\"\r\n        Handles when a card item is double clicked on.\r\n        \r\n        :param      item | <QTreeWidgetItem>\r\n        \"\"\"\r\n        widget = self.uiCardTREE.itemWidget(item, 0)\r\n        if ( isinstance(widget, XAbstractCardWidget) ):\r\n            self.emitRecordDoubleClicked(widget.record())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling when a detail item is double clicked on.", "response": "def handleDetailDblClick( self, item ):\r\n        \"\"\"\r\n        Handles when a detail item is double clicked on.\r\n        \r\n        :param      item | <QTreeWidgetItem>\r\n        \"\"\"\r\n        if ( isinstance(item, XOrbRecordItem) ):\r\n            self.emitRecordDoubleClicked(item.record())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles when a thumbnail item is double clicked on.", "response": "def handleThumbDblClick( self, item ):\r\n        \"\"\"\r\n        Handles when a thumbnail item is double clicked on.\r\n        \r\n        :param      item | <QListWidgetItem>\r\n        \"\"\"\r\n        if ( isinstance(item, RecordListWidgetItem) ):\r\n            self.emitRecordDoubleClicked(item.record())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of records for this browser.", "response": "def records( self ):\r\n        \"\"\"\r\n        Returns the record set for the current settings of this browser.\r\n        \r\n        :return     <orb.RecordSet>\r\n        \"\"\"\r\n        if ( self.isGroupingActive() ):\r\n            self._records.setGroupBy(self.currentGrouping())\r\n        else:\r\n            self._records.setGroupBy(None)\r\n        return self._records"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refreshRecords( self ):\r\n        table_type = self.tableType()\r\n        if ( not table_type ):\r\n            self._records = RecordSet()\r\n            return False\r\n        \r\n        search = nativestring(self.uiSearchTXT.text())\r\n        \r\n        query = self.query().copy()\r\n        terms, search_query = Q.fromSearch(search)\r\n        \r\n        if ( search_query ):\r\n            query &= search_query\r\n        \r\n        self._records = table_type.select(where = query).search(terms)\r\n        return True", "response": "Refreshes the records being loaded by this browser."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef refreshResults( self ):\r\n        if ( self.currentMode() == XOrbBrowserWidget.Mode.Detail ):\r\n            self.refreshDetails()\r\n        elif ( self.currentMode() == XOrbBrowserWidget.Mode.Card ):\r\n            self.refreshCards()\r\n        else:\r\n            self.refreshThumbnails()", "response": "Refreshes the results of the current browser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefreshing the card view of the browser.", "response": "def refreshCards( self ):\r\n        \"\"\"\r\n        Refreshes the results for the cards view of the browser.\r\n        \"\"\"\r\n        cards = self.cardWidget()\r\n        factory = self.factory()\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        \r\n        cards.setUpdatesEnabled(False)\r\n        cards.blockSignals(True)\r\n        \r\n        cards.clear()\r\n        QApplication.instance().processEvents()\r\n        \r\n        if ( self.isGroupingActive() ):\r\n            grouping = self.records().grouped()\r\n            for groupName, records in sorted(grouping.items()):\r\n                self._loadCardGroup(groupName, records, cards)\r\n            \r\n        else:\r\n            for record in self.records():\r\n                widget = factory.createCard(cards, record)\r\n                if ( not widget ):\r\n                    continue\r\n                \r\n                widget.adjustSize()\r\n                \r\n                # create the card item\r\n                item = QTreeWidgetItem(cards)\r\n                item.setSizeHint(0, QSize(0, widget.height()))\r\n                cards.setItemWidget(item, 0, widget)\r\n        \r\n        cards.setUpdatesEnabled(True)\r\n        cards.blockSignals(False)\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef refreshDetails( self ):\r\n        # start off by filtering based on the group selection\r\n        tree = self.uiRecordsTREE\r\n        tree.blockSignals(True)\r\n        tree.setRecordSet(self.records())\r\n        tree.blockSignals(False)", "response": "Refreshes the details view of the browser"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refreshThumbnails( self ):\r\n        # clear existing items\r\n        widget = self.thumbnailWidget()\r\n        widget.setUpdatesEnabled(False)\r\n        widget.blockSignals(True)\r\n        \r\n        widget.clear()\r\n        widget.setIconSize(self.thumbnailSize())\r\n        \r\n        factory = self.factory()\r\n        \r\n        # load grouped thumbnails (only allow 1 level of grouping)\r\n        if ( self.isGroupingActive() ):\r\n            grouping = self.records().grouped()\r\n            for groupName, records in sorted(grouping.items()):\r\n                self._loadThumbnailGroup(groupName, records)\r\n        \r\n        # load ungrouped thumbnails\r\n        else:\r\n            # load the records into the thumbnail\r\n            for record in self.records():\r\n                thumbnail = factory.thumbnail(record)\r\n                text      = factory.thumbnailText(record)\r\n                RecordListWidgetItem(thumbnail, text, record, widget)\r\n        \r\n        widget.setUpdatesEnabled(True)\r\n        widget.blockSignals(False)", "response": "Refreshes the thumbnails of the browser."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCurrentMode( self, mode ):\r\n        if ( not self.isModeEnabled(mode) ):\r\n            return False\r\n        \r\n        if ( mode == XOrbBrowserWidget.Mode.Detail ):\r\n            self.uiModeSTACK.setCurrentIndex(0)\r\n            self.uiDetailsACT.setChecked(True)\r\n        elif ( mode == XOrbBrowserWidget.Mode.Card ):\r\n            self.uiModeSTACK.setCurrentIndex(1)\r\n            self.uiCardACT.setChecked(True)\r\n        else:\r\n            self.uiModeSTACK.setCurrentIndex(2)\r\n            self.uiThumbnailACT.setChecked(True)\r\n        \r\n        self.refreshResults()\r\n        \r\n        return True", "response": "Sets the current mode for this browser widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the current record for this browser to the inputed record.", "response": "def setCurrentRecord( self, record ):\r\n        \"\"\"\r\n        Sets the current record for this browser to the inputed record.\r\n        \r\n        :param      record | <orb.Table> || None\r\n        \"\"\"\r\n        mode = self.currentMode()\r\n        if ( mode == XOrbBrowserWidget.Mode.Detail ):\r\n            self.detailWidget().setCurrentRecord(record)\r\n        \r\n        elif ( mode == XOrbBrowserWidget.Mode.Thumbnail ):\r\n            thumbs = self.thumbnailWidget()\r\n            for row in range(thumbs.count()):\r\n                item = thumbs.item(row)\r\n                if ( isinstance(item, RecordListWidgetItem) and \\\r\n                     item.record() == item ):\r\n                    thumbs.setCurrentItem(item)\r\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setFactory( self, factory ):\r\n        self._factory = factory\r\n        self._queryWidget.setFactory(factory)", "response": "Sets the factory for this query widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setHint( self, hint ):\r\n        self._hint = hint\r\n        self.detailWidget().setHint(hint)", "response": "Sets the hint for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setModeEnabled( self, mode, state ):\r\n        if ( mode == XOrbBrowserWidget.Mode.Detail ):\r\n            self.uiDetailsACT.setEnabled(state)\r\n        elif ( mode == XOrbBrowserWidget.Mode.Card ):\r\n            self.uiCardACT.setEnabled(state)\r\n        else:\r\n            self.uiThumbnailACT.setEnabled(state)", "response": "Sets whether or not the mode should be enabled."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the fixed lookup query for this widget.", "response": "def setQuery( self, query ):\r\n        \"\"\"\r\n        Sets the fixed lookup query for this widget to the inputed query.\r\n        \r\n        :param      query | <orb.Query>\r\n        \"\"\"\r\n        self._query = query\r\n        if ( not self.signalsBlocked() ):\r\n            self.queryChanged.emit(query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setTableType( self, tableType ):\r\n        self.detailWidget().setTableType(tableType)\r\n        self.queryWidget().setTableType(tableType)", "response": "Sets the table type for this widget to the inputed type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows the group menu for modification.", "response": "def showGroupMenu( self ):\r\n        \"\"\"\r\n        Displays the group menu to the user for modification.\r\n        \"\"\"\r\n        group_active = self.isGroupingActive()\r\n        group_by     = self.groupBy()\r\n        \r\n        menu = XMenu(self)\r\n        menu.setTitle('Grouping Options')\r\n        menu.setShowTitle(True)\r\n        menu.addAction('Edit Advanced Grouping')\r\n        \r\n        menu.addSeparator()\r\n        \r\n        action = menu.addAction('No Grouping')\r\n        action.setCheckable(True)\r\n        action.setChecked(not group_active)\r\n        \r\n        action = menu.addAction('Advanced')\r\n        action.setCheckable(True)\r\n        action.setChecked(group_by == self.GroupByAdvancedKey and group_active)\r\n        if ( group_by == self.GroupByAdvancedKey ):\r\n            font = action.font()\r\n            font.setBold(True)\r\n            action.setFont(font)\r\n        \r\n        menu.addSeparator()\r\n        \r\n        # add dynamic options from the table schema\r\n        tableType = self.tableType()\r\n        if ( tableType ):\r\n            columns = tableType.schema().columns()\r\n            columns.sort(key = lambda x: x.displayName())\r\n            for column in columns:\r\n                action = menu.addAction(column.displayName())\r\n                action.setCheckable(True)\r\n                action.setChecked(group_by == column.displayName() and\r\n                                  group_active)\r\n                \r\n                if ( column.displayName() == group_by ):\r\n                    font = action.font()\r\n                    font.setBold(True)\r\n                    action.setFont(font)\r\n        \r\n        point = QPoint(0, self.uiGroupOptionsBTN.height())\r\n        action = menu.exec_(self.uiGroupOptionsBTN.mapToGlobal(point))\r\n        \r\n        if ( not action ):\r\n            return\r\n        elif ( action.text() == 'Edit Advanced Grouping' ):\r\n            print 'edit advanced grouping options'\r\n        elif ( action.text() == 'No Grouping' ):\r\n            self.setGroupingActive(False)\r\n            \r\n        elif ( action.text() == 'Advanced' ):\r\n            self.uiGroupBTN.blockSignals(True)\r\n            self.setGroupBy(self.GroupByAdvancedKey)\r\n            self.setGroupingActive(True)\r\n            self.uiGroupBTN.blockSignals(False)\r\n            \r\n            self.refreshResults()\r\n        \r\n        else:\r\n            self.uiGroupBTN.blockSignals(True)\r\n            self.setGroupBy(nativestring(action.text()))\r\n            self.setGroupingActive(True)\r\n            self.uiGroupBTN.blockSignals(False)\r\n            \r\n            self.refreshResults()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_settings():\n    s = getattr(settings, 'CLAMAV_UPLOAD', {})\n    s = {\n            'CONTENT_TYPE_CHECK_ENABLED': s.get('CONTENT_TYPE_CHECK_ENABLED', False),\n            # LAST_HANDLER is not a user configurable option; we return\n            # it with the settings dict simply because it's convenient.\n            'LAST_HANDLER': getattr(settings, 'FILE_UPLOAD_HANDLERS')[-1]\n        }\n    return s", "response": "This function returns a dict containing default settings"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef beginGroup(self, prefix):\r\n        curr = self._xstack[-1]\r\n        next = curr.find(prefix)\r\n        if next is None:\r\n            next = ElementTree.SubElement(curr, prefix)\r\n        self._xstack.append(next)", "response": "Starts a new group for the given prefix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear(self):\r\n        self._xroot = ElementTree.Element('settings')\r\n        self._xroot.set('version', '1.0')\r\n        self._xstack = [self._xroot]", "response": "Clears the XML format settings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, filename):\r\n        try:\r\n            self._xroot = ElementTree.parse(filename).getroot()\r\n            self._xstack = [self._xroot]\r\n        except ExpatError:\r\n            self.clear()\r\n        \r\n        return self._xroot is not None", "response": "Loads the settings from the inputed file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestores the value of the inptued instance to the given xml element.", "response": "def restoreValue(self, xelem):\r\n        \"\"\"\r\n        Stores the value for the inptued instance to the given xml element.\r\n        \r\n        :param      xelem | <xml.etree.Element>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        typ = xelem.get('type')\r\n        \r\n        if typ == 'color':\r\n            return QtGui.QColor(xelem.text)\r\n        \r\n        elif typ == 'point':\r\n            return QtCore.QPoint(*map(int, xelem.text.split(',')))\r\n        \r\n        elif typ == 'pointf':\r\n            return QtCore.QPointF(*map(float, xelem.text.split(',')))\r\n        \r\n        elif typ == 'rect':\r\n            return QtCore.QRectF(*map(int, xelem.text.split(',')))\r\n        \r\n        elif typ == 'rectf':\r\n            return QtCore.QRectF(*map(float, xelem.text.split(',')))\r\n        \r\n        elif typ == 'bytea':\r\n            return QtCore.QByteArray(cPickle.loads(xelem.text))\r\n        \r\n        elif typ == 'pickle':\r\n            return cPickle.loads(xelem.text)\r\n        \r\n        elif typ == 'xml':\r\n            return xelem[0]\r\n        \r\n        elif typ in ('str', 'unicode'):\r\n            return xelem.text\r\n        \r\n        else:\r\n            try:\r\n                return eval('{0}({1})'.format(typ, xelem.text))\r\n            except:\r\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the current settings to the inputed filename.", "response": "def save(self, filename):\r\n        \"\"\"\r\n        Saves the settings to the inputed filename.\r\n        \r\n        :param      filename | <str>\r\n        \"\"\"\r\n        dirname = os.path.dirname(filename)\r\n        if not os.path.exists(dirname):\r\n            os.makedirs(dirname)\r\n        \r\n        projex.text.xmlindent(self._xroot)\r\n        xtree = ElementTree.ElementTree(self._xroot)\r\n        xtree.write(filename, encoding=self.encoding(), xml_declaration=True)\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the inputed key to the inputed value.", "response": "def setValue(self, key, value):\r\n        \"\"\"\r\n        Saves the inputed key to the inputed value.\r\n        \r\n        :param      key | <str>\r\n                    value | <variant>\r\n        \"\"\"\r\n        parts = nativestring(key).split('/')\r\n        curr = self._xstack[-1]\r\n        for part in parts[:-1]:\r\n            next = curr.find(part)\r\n            if next is None:\r\n                next = ElementTree.SubElement(curr, part)\r\n            curr = next\r\n        \r\n        xval = curr.find(parts[-1])\r\n        if xval is None:\r\n            xval = ElementTree.SubElement(curr, parts[-1])\r\n        \r\n        self.storeValue(xval, value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef storeValue(self, xelem, value):\r\n        typ = type(value)\r\n        \r\n        if typ == QtGui.QColor:\r\n            xelem.set('type', 'color')\r\n            xelem.text = nativestring(value.name())\r\n        \r\n        elif typ == QtCore.QPoint:\r\n            xelem.set('type', 'point')\r\n            xelem.text = '{0},{1}'.format(value.x(), value.y())\r\n        \r\n        elif typ == QtCore.QPointF:\r\n            xelem.set('type', 'pointf')\r\n            xelem.text = '{0},{1}'.format(value.x(), value.y())\r\n        \r\n        elif typ == QtCore.QRect:\r\n            xelem.set('type', 'rect')\r\n            xelem.text = '{0},{1},{2},{3}'.format(value.x(),\r\n                                                  value.y(),\r\n                                                  value.width(),\r\n                                                  value.height())\r\n        \r\n        elif typ == QtCore.QRectF:\r\n            xelem.set('type', 'rectf')\r\n            xelem.text = '{0},{1},{2},{3}'.format(value.x(),\r\n                                                  value.y(),\r\n                                                  value.width(),\r\n                                                  value.height())\r\n        \r\n        elif typ == QtCore.QByteArray:\r\n            xelem.set('type', 'bytea')\r\n            xelem.text = cPickle.dumps(nativestring(value))\r\n        \r\n        elif typ == ElementTree.Element:\r\n            xelem.set('type', 'xml')\r\n            xelem.append(value)\r\n        \r\n        elif typ in (list, tuple, dict):\r\n            xelem.set('type', 'pickle')\r\n            xelem.text = cPickle.dumps(value)\r\n        \r\n        else:\r\n            if not typ in (str, unicode):\r\n                value_text = nativestring(value)\r\n            else:\r\n                value_text = value\r\n            \r\n            xelem.set('type', typ.__name__)\r\n            xelem.text = value_text", "response": "Stores the value for the inptued instance to the given xml element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef value(self, key, default=None):\r\n        parts = nativestring(key).split('/')\r\n        curr = self._xstack[-1]\r\n        for part in parts[:-1]:\r\n            next = curr.find(part)\r\n            if next is None:\r\n                next = ElementTree.SubElement(curr, part)\r\n            curr = next\r\n        \r\n        xval = curr.find(parts[-1])\r\n        if xval is None:\r\n            return default\r\n        \r\n        return self.restoreValue(xval)", "response": "Returns the value of the inputed key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef beginGroup(self, prefix):\r\n        curr = self._stack[-1]\r\n        next = curr.get(prefix, {})\r\n        curr.setdefault(prefix, next)\r\n        self._stack.append(next)", "response": "Starts a new group for the given prefix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the settings from the inputed file.", "response": "def load(self, filename):\r\n        \"\"\"\r\n        Loads the settings from the inputed filename.\r\n        \r\n        :param      filename | <str>\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        if not os.path.exists(filename):\r\n            return False\r\n        \r\n        data = None\r\n        with open(filename, 'r') as f:\r\n            data = f.read()\r\n        \r\n        try:\r\n            root = yaml.load(data)\r\n        except StandardError:\r\n            root = None\r\n        \r\n        if root is None:\r\n            root = {}\r\n        \r\n        self._root = root\r\n        self._stack = [self._root]\r\n        \r\n        return len(self._root) != 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value for the specified key to the inputed value.", "response": "def setValue(self, key, value):\r\n        \"\"\"\r\n        Sets the value for this settings key to the inputed value.\r\n        \r\n        :param      key     | <str>\r\n                    value   | <variant>\r\n        \"\"\"\r\n        curr = self._stack[-1]\r\n        curr[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave the settings instance to a file.", "response": "def save(self, filename):\r\n        \"\"\"\r\n        Saves the data for this settings instance to the given filename.\r\n        \r\n        :param      filename | <str>\r\n        \"\"\"\r\n        dirname = os.path.dirname(filename)\r\n        if not os.path.exists(dirname):\r\n            os.makedirs(dirname)\r\n        \r\n        try:\r\n            f = open(filename, 'w')\r\n        except StandardError:\r\n            log.error('Failed to access file: {0}'.format(filename))\r\n            return False\r\n        \r\n        try:\r\n            f.write(yaml.dump(self._root, default_flow_style=False))\r\n        except StandardError:\r\n            log.error('Failed to save settings: {0}'.format(filename))\r\n            return False\r\n        finally:\r\n            f.close()\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the value of the given key from the current settings.", "response": "def value(self, key, default=None):\r\n        \"\"\"\r\n        Returns the value from the current settings.\r\n        \r\n        :param      key     | <str>\r\n                    default | <variant>\r\n        \r\n        :return     <variant>\r\n        \"\"\"\r\n        curr = self._stack[-1]\r\n        return curr.get(key, default)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all the keys for this settings instance.", "response": "def allKeys(self):\r\n        \"\"\"\r\n        Returns a list of all the keys for this settings instance.\r\n        \r\n        :return     [<str>, ..]\r\n        \"\"\"\r\n        if self._customFormat:\r\n            return self._customFormat.allKeys()\r\n        else:\r\n            return super(XSettings, self).allKeys()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of child keys for this settings instance.", "response": "def childKeys(self):\r\n        \"\"\"\r\n        Returns the list of child keys for this settings instance.\r\n        \r\n        :return     [<str>, ..]\r\n        \"\"\"\r\n        if self._customFormat:\r\n            return self._customFormat.childKeys()\r\n        else:\r\n            return super(XSettings, self).childKeys()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing out all the settings for this instance.", "response": "def clear(self):\r\n        \"\"\"\r\n        Clears out all the settings for this instance.\r\n        \"\"\"\r\n        if self._customFormat:\r\n            self._customFormat.clear()\r\n        else:\r\n            super(XSettings, self).clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbegins a new group for the given prefix.", "response": "def beginGroup(self, prefix):\r\n        \"\"\"\r\n        Begins a new group for this settings instance for the given\r\n        settings.\r\n        \r\n        :param      prefix | <str>\r\n        \"\"\"\r\n        if self._customFormat:\r\n            self._customFormat.beginGroup(prefix)\r\n        else:\r\n            super(XSettings, self).beginGroup(prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef endGroup(self):\r\n        if self._customFormat:\r\n            self._customFormat.endGroup()\r\n        else:\r\n            super(XSettings, self).endGroup()", "response": "Ends the current group of xml data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self):\r\n        # load the custom format\r\n        if self._customFormat and os.path.exists(self.fileName()):\r\n            self._customFormat.load(self.fileName())", "response": "Loads the settings from disk for this object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the filename of the current object.", "response": "def fileName(self):\r\n        \"\"\"\r\n        Returns the filename.\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        if self._filename:\r\n            return self._filename\r\n        \r\n        filename = nativestring(super(XSettings, self).fileName())\r\n        if self._customFormat:\r\n            filename, ext = os.path.splitext(filename)\r\n            filename += '.' + self._customFormat.extension()\r\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the value for the given key to the inputed value.", "response": "def setValue(self, key, value):\r\n        \"\"\"\r\n        Sets the value for the given key to the inputed value.\r\n        \r\n        :param      key | <str>\r\n                    value | <variant>\r\n        \"\"\"\r\n        if self._customFormat:\r\n            self._customFormat.setValue(key, value)\r\n        else:\r\n            super(XSettings, self).setValue(key, wrapVariant(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sync(self):\r\n        if self._customFormat:\r\n            self._customFormat.save(self.fileName())\r\n        else:\r\n            super(XSettings, self).sync()", "response": "Syncs the information for this settings out to the file system."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef value(self, key, default=None):\r\n        if self._customFormat:\r\n            return self._customFormat.value(key, default)\r\n        else:\r\n            return unwrapVariant(super(XSettings, self).value(key))", "response": "Returns the value for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear out the widgets for this query builder.", "response": "def clear(self):\r\n        \"\"\"\r\n        Clears out the widgets for this query builder.\r\n        \"\"\"\r\n        layout = self._entryWidget.layout()\r\n        for i in range(layout.count() - 1):\r\n            widget = layout.itemAt(i).widget()\r\n            widget.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new compound query from the checked entries.", "response": "def createCompoundFromChecked(self):\r\n        \"\"\"\r\n        Creates a new compound query from the checked entry list.\r\n        \r\n        :return     <orb.QueryCompound>\r\n        \"\"\"\r\n        checked_entries = self.checkedEntries()\r\n        \r\n        if len(checked_entries) <= 1:\r\n            return QueryCompound()\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        joiner = self.currentJoiner()\r\n        query = Query()\r\n        for entry in checked_entries:\r\n            if joiner == QueryCompound.Op.And:\r\n                query &= entry.query()\r\n            else:\r\n                query |= entry.query()\r\n        \r\n        # clear out the existing containers\r\n        first = checked_entries[0]\r\n        first.setQuery(query)\r\n        first.setChecked(False)\r\n        \r\n        layout = self._entryWidget.layout()\r\n        for i in range(len(checked_entries) - 1, 0, -1):\r\n            w = checked_entries[i]\r\n            layout.takeAt(layout.indexOf(w))\r\n            w.close()\r\n        \r\n        self.refreshEntries()\r\n        self.setUpdatesEnabled(True)\r\n        \r\n        if not self.signalsBlocked():\r\n            self.enterCompound(first, query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef entries(self):\r\n        layout = self._entryWidget.layout()\r\n        output = []\r\n        for i in range(layout.count() - 1):\r\n            widget = layout.itemAt(i).widget()\r\n            if not isinstance(widget, XOrbQueryEntryWidget):\r\n                continue\r\n            output.append(widget)\r\n        return output", "response": "Returns the entries for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving the current query down one entry.", "response": "def moveDown(self, entry):\r\n        \"\"\"\r\n        Moves the current query down one entry.\r\n        \"\"\"\r\n        if not entry:\r\n            return\r\n        \r\n        entries = self.entries()\r\n        next = entries[entries.index(entry) + 1]\r\n        \r\n        entry_q = entry.query()\r\n        next_q  = next.query()\r\n        \r\n        next.setQuery(entry_q)\r\n        entry.setQuery(next_q)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query(self):\r\n        joiner = self.currentJoiner()\r\n        \r\n        query = Query()\r\n        for entry in self.entries():\r\n            if joiner == QueryCompound.Op.And:\r\n                query &= entry.query()\r\n            else:\r\n                query |= entry.query()\r\n        \r\n        query.setName(self.uiNameTXT.text())\r\n        return query", "response": "Returns the query that is defined by this current panel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the query for this item to the inputed query instance.", "response": "def setQuery(self, query):\r\n        \"\"\"\r\n        Sets the query for this wigdet to the inputed query instance.\r\n        \r\n        :param      query | <orb.Query> || <orb.QueryCompound>\r\n        \"\"\"\r\n        if not self.isNull() and hash(query) == hash(self.query()):\r\n            return\r\n        \r\n        # add entries\r\n        table = self.tableType()\r\n        \r\n        self.setUpdatesEnabled(False)\r\n        self.blockSignals(True)\r\n        self.clear()\r\n        \r\n        if query is None or table is None:\r\n            self.setEnabled(False)\r\n            self.setUpdatesEnabled(True)\r\n            self.blockSignals(False)\r\n            return\r\n        else:\r\n            self.setEnabled(True)\r\n        \r\n        # load the queries for this item\r\n        if QueryCompound.typecheck(query):\r\n            queries = query.queries()\r\n            self.setCurrentJoiner(query.operatorType())\r\n        else:\r\n            queries = [query]\r\n        \r\n        self.uiNameTXT.setText(query.name())\r\n        \r\n        layout = self._entryWidget.layout()\r\n        for index, query in enumerate(queries):\r\n            widget = self.addEntry(query)\r\n            widget.setFirst(index == 0)\r\n            widget.setLast(index == (len(queries) - 1))\r\n            widget.setJoiner(self.currentJoiner())\r\n        \r\n        self.setUpdatesEnabled(True)\r\n        self.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _scrollTree( self, value ):\r\n        if self._scrolling:\r\n            return\r\n        \r\n        tree_bar = self.uiGanttTREE.verticalScrollBar()\r\n        self._scrolling = True\r\n        tree_bar.setValue(value)\r\n        self._scrolling = False", "response": "Updates the tree view scrolling to the inputed value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the gantt view scrolling to the inputed value.", "response": "def _scrollView( self, value ):\r\n        \"\"\"\r\n        Updates the gantt view scrolling to the inputed value.\r\n        \r\n        :param      value | <int>\r\n        \"\"\"\r\n        if self._scrolling:\r\n            return\r\n        \r\n        view_bar = self.uiGanttVIEW.verticalScrollBar()\r\n        self._scrolling = True\r\n        view_bar.setValue(value)\r\n        self._scrolling = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nselect the tree items in the view.", "response": "def _selectTree( self ):\r\n        \"\"\"\r\n        Matches the tree selection to the views selection.\r\n        \"\"\"\r\n        self.uiGanttTREE.blockSignals(True)\r\n        self.uiGanttTREE.clearSelection()\r\n        for item in self.uiGanttVIEW.scene().selectedItems():\r\n            item.treeItem().setSelected(True)\r\n        self.uiGanttTREE.blockSignals(False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _selectView( self ):\r\n        scene = self.uiGanttVIEW.scene()\r\n        scene.blockSignals(True)\r\n        scene.clearSelection()\r\n        for item in self.uiGanttTREE.selectedItems():\r\n            item.viewItem().setSelected(True)\r\n        scene.blockSignals(False)\r\n        \r\n        curr_item = self.uiGanttTREE.currentItem()\r\n        vitem = curr_item.viewItem()\r\n        \r\n        if vitem:\r\n            self.uiGanttVIEW.centerOn(vitem)", "response": "Select the view from the tree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _updateViewRect( self ):\r\n        if not self.updatesEnabled():\r\n            return\r\n        \r\n        header_h    = self._cellHeight * 2\r\n        rect        = self.uiGanttVIEW.scene().sceneRect()\r\n        sbar_max    = self.uiGanttTREE.verticalScrollBar().maximum()\r\n        sbar_max   += self.uiGanttTREE.viewport().height() + header_h\r\n        widget_max  = self.uiGanttVIEW.height()\r\n        widget_max -= (self.uiGanttVIEW.horizontalScrollBar().height() + 10)\r\n        \r\n        rect.setHeight(max(widget_max, sbar_max))\r\n        self.uiGanttVIEW.scene().setSceneRect(rect)", "response": "Updates the view rect to match the current tree value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the inputed item to the gantt widget.", "response": "def addTopLevelItem(self, item):\r\n        \"\"\"\r\n        Adds the inputed item to the gantt widget.\r\n        \r\n        :param      item | <XGanttWidgetItem>\r\n        \"\"\"\r\n        vitem = item.viewItem()\r\n        \r\n        self.treeWidget().addTopLevelItem(item)\r\n        self.viewWidget().scene().addItem(vitem)\r\n        \r\n        item._viewItem = weakref.ref(vitem)\r\n        \r\n        if self.updatesEnabled():\r\n            try:\r\n                item.sync(recursive=True)\r\n            except AttributeError:\r\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blockSignals(self, state):\r\n        super(XGanttWidget, self).blockSignals(state)\r\n        self.treeWidget().blockSignals(state)\r\n        self.viewWidget().blockSignals(state)", "response": "Sets whether or not updates will be enabled."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncenters the view on a given datetime for the gantt widget.", "response": "def centerOnDateTime(self, dtime):\r\n        \"\"\"\r\n        Centers the view on a given datetime for the gantt widget.\r\n        \r\n        :param      dtime | <QDateTime>\r\n        \"\"\"\r\n        view = self.uiGanttVIEW\r\n        scene = view.scene()\r\n        point = view.mapToScene(0, 0)\r\n        x = scene.datetimeXPos(dtime)\r\n        y = point.y()\r\n        view.centerOn(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the current date time for this widget.", "response": "def currentDateTime(self):\r\n        \"\"\"\r\n        Returns the current date time for this widget.\r\n        \r\n        :return     <datetime.datetime>\r\n        \"\"\"\r\n        view = self.uiGanttVIEW\r\n        scene = view.scene()\r\n        point = view.mapToScene(0, 0)\r\n        return scene.datetimeAt(point.x())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insertTopLevelItem( self, index, item ):\r\n        self.treeWidget().insertTopLevelItem(index, item)\r\n        \r\n        if self.updatesEnabled():\r\n            try:\r\n                item.sync(recursive = True)\r\n            except AttributeError:\r\n                pass", "response": "Adds the given item at the given index in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef requestTreeMenu(self, point):\r\n        item = self.uiGanttTREE.itemAt(point)\r\n        if item:\r\n            glbl_pos = self.uiGanttTREE.viewport().mapToGlobal(point)\r\n            self.treeMenuRequested.emit(item, glbl_pos)\r\n            self.itemMenuRequested.emit(item, glbl_pos)", "response": "Emits the itemMenuRequested and treeMenuRequested signals for the given item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nemit the itemMenuRequested and viewMenuRequested signals the given itemMenuRequested and viewMenuRequested signals the given itemMenuRequested and viewMenuRequested signals the given itemMenuRequested and viewMenuRequested signals the given point.", "response": "def requestViewMenu(self, point):\r\n        \"\"\"\r\n        Emits the itemMenuRequested and viewMenuRequested signals\r\n        for the given item.\r\n        \r\n        :param      point | <QPoint>\r\n        \"\"\"\r\n        vitem = self.uiGanttVIEW.itemAt(point)\r\n        if vitem:\r\n            glbl_pos = self.uiGanttVIEW.mapToGlobal(point)\r\n            item = vitem.treeItem()\r\n            self.viewMenuRequested.emit(vitem, glbl_pos)\r\n            self.itemMenuRequested.emit(item, glbl_pos)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setAlternatingRowColors( self, state ):\r\n        self._alternatingRowColors = state\r\n        \r\n        self.treeWidget().setAlternatingRowColors(state)", "response": "Sets the state of the alternating row colors for this tree item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the columns for this gantt widget s tree to the inputed list of columns.", "response": "def setColumns( self, columns ):\r\n        \"\"\"\r\n        Sets the columns for this gantt widget's tree to the inputed list of\r\n        columns.\r\n        \r\n        :param      columns | {<str>, ..]\r\n        \"\"\"\r\n        self.treeWidget().setColumns(columns)\r\n        item = self.treeWidget().headerItem()\r\n        for i in range(item.columnCount()):\r\n            item.setTextAlignment(i, Qt.AlignBottom | Qt.AlignHCenter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setDateTimeEnd(self, dtime):\r\n        self._dateEnd = dtime.date()\r\n        \r\n        if self.timescale() in (self.Timescale.Minute, self.Timescale.Hour):\r\n            self._timeEnd = dtime.time()\r\n        else:\r\n            self._timeEnd = QTime(23, 59, 59)", "response": "Sets the endiing date time for this gantt chart."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setDateTimeStart(self, dtime):\r\n        self._dateStart = dtime.date()\r\n        if self.timescale() in (self.Timescale.Minute, self.Timescale.Hour):\r\n            self._timeStart = dtime.time()\r\n        else:\r\n            self._timeStart = QTime(0, 0, 0)", "response": "Sets the starting date time for this gantt chart."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setCurrentDateTime(self, dtime):\r\n        view = self.uiGanttVIEW\r\n        scene = view.scene()\r\n        point = view.mapToScene(0, 0)\r\n        x = scene.datetimeXPos(dtime)\r\n        y = point.y()\r\n        view.ensureVisible(x, y, 1, 1)", "response": "Sets the current date time for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the timescale of the current instance.", "response": "def setTimescale( self, timescale ):\r\n        \"\"\"\r\n        Sets the timescale value for this widget to the inputed value.\r\n        \r\n        :param      timescale | <XGanttWidget.Timescale>\r\n        \"\"\"\r\n        self._timescale = timescale\r\n        \r\n        # show hour/minute scale\r\n        if timescale == XGanttWidget.Timescale.Minute:\r\n            self._cellWidth = 60 # (60 seconds)\r\n            self._dateStart = QDate.currentDate()\r\n            self._timeStart = QTime(0, 0, 0)\r\n            \r\n            self._dateEnd = QDate.currentDate()\r\n            self._timeEnd = QTime(23, 59, 59)\r\n            \r\n        elif timescale == XGanttWidget.Timescale.Hour:\r\n            self._cellWidth = 30 # (60 seconds / 2.0)\r\n            \r\n            self._dateStart = QDate.currentDate()\r\n            self._timeStart = QTime(0, 0, 0)\r\n            \r\n            self._dateEnd = QDate.currentDate()\r\n            self._timeEnd = QTime(23, 59, 59)\r\n        \r\n        # show day/hour scale\r\n        elif timescale == XGanttWidget.Timescale.Day:\r\n            self._cellWidth = 30 # (60 minutes / 2.0)\r\n            \r\n            self._dateStart = QDate.currentDate().addDays(-7)\r\n            self._timeStart = QTime(0, 0, 0)\r\n            \r\n            self._dateEnd = QDate.currentDate().addDays(7)\r\n            self._timeEnd = QTime(23, 59, 59)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setUpdatesEnabled(self, state):\r\n        super(XGanttWidget, self).setUpdatesEnabled(state)\r\n        self.treeWidget().setUpdatesEnabled(state)\r\n        self.viewWidget().setUpdatesEnabled(state)\r\n        \r\n        if state:\r\n            self._updateViewRect()\r\n            for i in range(self.topLevelItemCount()):\r\n                item = self.topLevelItem(i)\r\n                try:\r\n                    item.sync(recursive=True)\r\n                except AttributeError:\r\n                    continue", "response": "Sets whether or not updates will be enabled."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef syncView(self):\r\n        if not self.updatesEnabled():\r\n            return\r\n        \r\n        for item in self.topLevelItems():\r\n            try:\r\n                item.syncView(recursive=True)\r\n            except AttributeError:\r\n                continue", "response": "Syncs all the items to the view."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef takeTopLevelItem( self, index ):\r\n        item = self.topLevelItem(index)\r\n        if item:\r\n            self.viewWidget().scene().removeItem(item.viewItem())\r\n            self.treeWidget().takeTopLevelItem(index)\r\n            \r\n            return item\r\n        return None", "response": "Removes the top level item at the inputed index from the tree widget. Returns the item that was removed or None if no such item exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef updateItemData(self, item, index):\r\n        from projexui.widgets.xganttwidget.xganttwidgetitem import XGanttWidgetItem\r\n        if not isinstance(item, XGanttWidgetItem):\r\n            return\r\n        \r\n        value = unwrapVariant(item.data(index, Qt.EditRole))\r\n        \r\n        if type(value) == QDateTime:\r\n            value = value.date()\r\n            item.setData(index, Qt.EditRole, wrapVariant(value))\r\n        \r\n        if type(value) == QDate:\r\n            value = value.toPython()\r\n        \r\n        columnName = self.treeWidget().columnOf(index)\r\n        item.setProperty(columnName, value)\r\n        item.sync()", "response": "Updates the item data with the information from the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the full file path of a resource of a package.", "response": "def get_data_path(package, resource):\n    # type: (str, str) -> str\n    \"\"\"Return the full file path of a resource of a package.\"\"\"\n    loader = pkgutil.get_loader(package)\n    if loader is None or not hasattr(loader, 'get_data'):\n        raise PackageResourceError(\"Failed to load package: '{0}'\".format(\n            package))\n    mod = sys.modules.get(package) or loader.load_module(package)\n    if mod is None or not hasattr(mod, '__file__'):\n        raise PackageResourceError(\"Failed to load module: '{0}'\".format(\n            package))\n    parts = resource.split('/')\n    parts.insert(0, os.path.dirname(mod.__file__))\n    resource_name = os.path.join(*parts)\n    return resource_name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef color(self, key):\r\n        if type(key) == int:\r\n            key = self.LoggingMap.get(key, ('NotSet', ''))[0]\r\n        name = nativestring(key).capitalize()\r\n        return self._colorSet.color(name)", "response": "Returns the color value for the given key for this console."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlog the inputed message with the given level.", "response": "def log(self, level, msg):\r\n        \"\"\"\r\n        Logs the inputed message with the given level.\r\n        \r\n        :param      level | <int> | logging level value\r\n                    msg   | <unicode>\r\n        \r\n        :return     <bool> success\r\n        \"\"\"\r\n        if self.isDestroyed():\r\n            return\r\n        \r\n        locker = QtCore.QMutexLocker(self._mutex)\r\n        try:\r\n            msg = projex.text.nativestring(msg)\r\n            self.moveCursor(QtGui.QTextCursor.End)\r\n            self.setCurrentMode(level)\r\n            if self.textCursor().block().text():\r\n                self.insertPlainText('\\n')\r\n            self.insertPlainText(msg.lstrip('\\n\\r'))\r\n            self.scrollToEnd()\r\n        except RuntimeError:\r\n            return\r\n        \r\n        if not self.signalsBlocked():\r\n            self.messageLogged.emit(level, msg)\r\n        \r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loggerLevel(self, logger='root'):\r\n        if isinstance(logger, logging.Logger):\r\n            logger = logger.name\r\n        \r\n        return self.handler().loggerLevel(logger)", "response": "Returns the logging level for the given logger."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrestoring the settings for this logger from the inputed settings.", "response": "def restoreSettings(self, settings):\r\n        \"\"\"\r\n        Restores the settings for this logger from the inputed settings.\r\n        \r\n        :param      <QtCore.QSettings>\r\n        \"\"\"\r\n        val = unwrapVariant(settings.value('format'))\r\n        if val:\r\n            self.setFormatText(val)\r\n        \r\n        levels = unwrapVariant(settings.value('levels'))\r\n        if levels:\r\n            self.setActiveLevels(map(int, levels.split(',')))\r\n        \r\n        logger_levels = unwrapVariant(settings.value('loggerLevels'))\r\n        if logger_levels:\r\n            for key in logger_levels.split(','):\r\n                logger, lvl = key.split(':')\r\n                lvl = int(lvl)\r\n                self.setLoggerLevel(logger, lvl)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the logging settings for this widget to the inputed settings.", "response": "def saveSettings(self, settings):\r\n        \"\"\"\r\n        Saves the logging settings for this widget to the inputed settings.\r\n        \r\n        :param      <QtCore.QSettings>\r\n        \"\"\"\r\n        lvls = []\r\n        for logger, level in self.loggerLevels().items():\r\n            lvls.append('{0}:{1}'.format(logger, level))\r\n        \r\n        settings.setValue('format', wrapVariant(self.formatText()))\r\n        settings.setValue('levels', ','.join(map(str, self.activeLevels())))\r\n        settings.setValue('loggerLevels', ','.join(lvls))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef scrollToEnd(self):\r\n        vsbar = self.verticalScrollBar()\r\n        vsbar.setValue(vsbar.maximum())\r\n        \r\n        hbar = self.horizontalScrollBar()\r\n        hbar.setValue(0)", "response": "Scrolls to the end for this console edit."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setColor(self, key, value):\r\n        key = nativestring(key).capitalize()\r\n        self._colorSet.setColor(key, value)\r\n        \r\n        # update the palette information\r\n        if ( key == 'Background' ):\r\n            palette = self.palette()\r\n            palette.setColor( palette.Base, value )\r\n            self.setPalette(palette)", "response": "Sets the color for the inputed color."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the colors for this console to the inputed collection.", "response": "def setColorSet(self, colorSet):\r\n        \"\"\"\r\n        Sets the colors for this console to the inputed collection.\r\n        \r\n        :param      colors | <XLoggerColorSet>\r\n        \"\"\"\r\n        self._colorSet = colorSet\r\n        \r\n        # update the palette information\r\n        palette = self.palette()\r\n        palette.setColor( palette.Text, colorSet.color('Standard') )\r\n        palette.setColor( palette.Base, colorSet.color('Background') )\r\n        self.setPalette(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setConfigurable(self, state):\r\n        self._configurable = state\r\n        self._configButton.setVisible(state)", "response": "Sets whether or not this logger widget is configurable."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the current color mode for this console.", "response": "def setCurrentMode(self, mode):\r\n        \"\"\"\r\n        Sets the current color mode for this console to the inputed value.\r\n        \r\n        :param      mode | <unicode>\r\n        \"\"\"\r\n        if type(mode) == int:\r\n            mode = self.LoggingMap.get(mode, ('standard', ''))[0]\r\n            \r\n        if mode == self._currentMode:\r\n            return\r\n            \r\n        self._currentMode = mode\r\n        color = self.color(mode)\r\n        if not color.isValid():\r\n            return\r\n            \r\n        format = QtGui.QTextCharFormat()\r\n        format.setForeground(color)\r\n        self.setCurrentCharFormat(format)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path to the icon file that is linked to this plugin.", "response": "def iconFile( self ):\n        \"\"\"\n        Returns the icon file that is linked that to this plugin.\n        \n        :return     <str>\n        \"\"\"\r\n        if not os.path.isfile(self._iconFile):\r\n            return projexui.resources.find(self._iconFile)\n        return self._iconFile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the icon for the inputed group name.", "response": "def groupIcon( cls, groupName, default = None ):\r\n        \"\"\"\r\n        Returns the icon for the inputed group name.\r\n        \r\n        :param      groupName | <str>\r\n                    default   | <str> || None\r\n        \r\n        :return     <str>\r\n        \"\"\"\r\n        if ( cls._groupIcons is None ):\r\n            cls._groupIcons = {}\r\n            \r\n        if ( not default ):\r\n            default = projexui.resources.find('img/settings_32.png')\r\n        \r\n        return cls._groupIcons.get(nativestring(groupName), default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the wizard plugin based on its name.", "response": "def find( cls, name ):\n        \"\"\"\n        Finds a particular wizard plugin based on its name.\n        \n        :param      name | <str> || None\n        \"\"\"\r\n        if ( cls._plugins is None ):\r\n            cls._plugins = {}\r\n            \n        return cls._plugins.get(nativestring(name))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the group icon for the wizard plugin to the inputed icon.", "response": "def setGroupIcon( cls, groupName, icon ):\r\n        \"\"\"\r\n        Sets the group icon for the wizard plugin to the inputed icon.\r\n        \r\n        :param      groupName | <str>\r\n                    icon      | <str>\r\n        \"\"\"\r\n        if ( cls._groupIcons is None ):\r\n            cls._groupIcons = {}\r\n            \r\n        cls._groupIcons[nativestring(groupName)] = icon"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a particular plugin to the global system at the given name.", "response": "def register( cls, plugin ):\n        \"\"\"\n        Registers a particular plugin to the global system at the given name.\n        \n        :param      plugin  | <XWizardPlugin>\n        \"\"\"\r\n        if ( not plugin ):\r\n            return\r\n            \r\n        if ( cls._plugins is None ):\r\n            cls._plugins = {}\r\n            \n        cls._plugins[plugin.uniqueName()] = plugin"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the wizard instance for this plugin.", "response": "def runWizard(self, parent):\r\n        \"\"\"\r\n        Runs the wizard instance for this plugin.\r\n        \r\n        :param      parent | <QWidget>\r\n        \r\n        :return     <bool> | success\r\n        \"\"\"\r\n        wizard = XScaffoldWizard(self._scaffold, parent)\r\n        return wizard.exec_()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addWidget(self, widget, align=Qt.AlignLeft, before=None):\r\n        # self.uiToolbarLAYOUT points to a deleted C/C++ object in PySide...\r\n        layout = self.findChild(QHBoxLayout, 'uiToolbarLAYOUT')\r\n        \r\n        if before is not None:\r\n            index = None\r\n            for i in range(layout.count()):\r\n                if layout.itemAt(i).widget() == before:\r\n                    index = i\r\n                    break\r\n            \r\n            if index is not None:\r\n                layout.insertWidget(index, widget)\r\n            else:\r\n                layout.addWidget(widget)\r\n            \r\n        if align == Qt.AlignLeft:\r\n            layout.insertWidget(0, widget)\r\n        else:\r\n            layout.addWidget(widget)", "response": "Adds a widget to the grid edit s toolbar with the given alignment."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassigns the query from the query widget to the edit.", "response": "def assignQuery(self):\r\n        \"\"\"\r\n        Assigns the query from the query widget to the edit.\r\n        \"\"\"\r\n        self.uiRecordTREE.setQuery(self._queryWidget.query(), autoRefresh=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrefresh the table with the current information from the database.", "response": "def refresh(self):\r\n        \"\"\"\r\n        Commits changes stored in the interface to the database.\r\n        \"\"\"\r\n        table = self.tableType()\r\n        if table:\r\n            table.markTableCacheExpired()\r\n        \r\n        self.uiRecordTREE.searchRecords(self.uiSearchTXT.text())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrestore the settings for this edit from xml.", "response": "def restoreXml(self, xml):\r\n        \"\"\"\r\n        Restores the settings for this edit from xml.\r\n        \r\n        :param      xml | <xml.etree.ElementTree>\r\n        \"\"\"\r\n        self.uiRecordTREE.restoreXml(xml.find('tree'))\r\n        \r\n        # restore the query\r\n        xquery = xml.find('query')\r\n        if xquery is not None:\r\n            self.setQuery(Q.fromXml(xquery[0]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the settings for this edit to the xml parent.", "response": "def saveXml(self, xml):\r\n        \"\"\"\r\n        Saves the settings for this edit to the xml parent.\r\n        \r\n        :param      xparent | <xml.etree.ElementTree>\r\n        \"\"\"\r\n        # save grouping\r\n        xtree = ElementTree.SubElement(xml, 'tree')\r\n        self.uiRecordTREE.saveXml(xtree)\r\n        \r\n        # save the query\r\n        query = self.query()\r\n        if query:\r\n            query.toXml(ElementTree.SubElement(xml, 'query'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the editable state for this grid widget.", "response": "def setEditable(self, state):\r\n        \"\"\"\r\n        Sets the editable state for this grid widget.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        self.uiRecordTREE.setEditable(state)\r\n        self.uiSaveBTN.setVisible(state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the query for this edit to the inputed query.", "response": "def setQuery(self, query, autoRefresh=True):\r\n        \"\"\"\r\n        Sets the query for this edit to the inputed query.\r\n        \r\n        :param      query | <orb.Query>\r\n        \"\"\"\r\n        self.uiRecordTREE.setQuery(query, autoRefresh=autoRefresh)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the table type associated with this edit.", "response": "def setTableType(self, tableType, autoRefresh=True):\r\n        \"\"\"\r\n        Sets the table type associated with this edit.\r\n        \r\n        :param      tableType | <subclass of orb.Table>\r\n        \"\"\"\r\n        self.uiRecordTREE.setTableType(tableType)\r\n        self._queryWidget.setTableType(tableType)\r\n        \r\n        if autoRefresh:\r\n            self.setQuery(Q())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a mapping from the nodes to the other nodes.", "response": "def connectionMap(self, scene, nodes):\r\n        \"\"\"\r\n        Generates a mapping for the nodes to each other based on their\r\n        connections.\r\n        \r\n        :param      nodes | [<XNode>, ..]\r\n        \r\n        :return     {<XNode>: ([<XNode> input, ..], [<XNode> output, ..]), ..}\r\n        \"\"\"\r\n        output = {}\r\n        connections = scene.connections()\r\n        \r\n        for node in nodes:\r\n            inputs = []\r\n            outputs = []\r\n            \r\n            for connection in connections:\r\n                in_node = connection.inputNode()\r\n                out_node = connection.outputNode()\r\n                \r\n                if node == in_node:\r\n                    inputs.append(out_node)\r\n                elif node == out_node:\r\n                    outputs.append(in_node)\r\n                \r\n            output[node] = (inputs, outputs)\r\n        \r\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generateLayers(self, scene, nodes, connections):\r\n        depth = {}\r\n        for node in nodes:\r\n            depth[node] = (self.calculateDepth(node, connections),\r\n                           len(connections[node][0]))\r\n        \r\n        ordered = depth.keys()\r\n        ordered.sort(key=lambda x: depth[x])\r\n        \r\n        layers = {}\r\n        processed = []\r\n        for node in ordered:\r\n            self.collectLayer(node, connections, layers, recurse=processed)\r\n        \r\n        return [v for _, v in sorted(layers.items())]", "response": "Generates the layers for the given nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef layout(self,\r\n               scene,\r\n               nodes,\r\n               center=None,\r\n               padX=None,\r\n               padY=None,\r\n               direction=None,\r\n               animationGroup=None):\r\n        \"\"\"\r\n        Lays out the nodes for this scene based on a block layering algorithm.\r\n        \r\n        :param      scene          | <XNodeScene>\r\n                    nodes          | [<XNode>, ..]\r\n                    center         | <QPointF> || None\r\n                    padX           | <int> || None\r\n                    padY           | <int> || None\r\n                    direction      | <Qt.Direction>\r\n                    animationGroup | <QAnimationGroup> || None\r\n        \r\n        :return     {<XNode>: <QRectF>, ..} | new rects per affected node\r\n        \"\"\"\r\n        nodes = filter(lambda x: x is not None and x.isVisible(), nodes)\r\n        \r\n        # make sure we have at least 1 node, otherwise, it is already laid out\r\n        if not nodes or len(nodes) == 1:\r\n            return {}\r\n        \r\n        # calculate the default padding based on the scene\r\n        if padX == None:\r\n            if direction == Qt.Vertical:\r\n                padX = 2 * scene.cellWidth()\r\n            else:\r\n                padX = 4 * scene.cellWidth()\r\n            \r\n        if padY == None:\r\n            if direction == Qt.Vertical:\r\n                padY = 4 * scene.cellHeight()\r\n            else:\r\n                padY = 2 * scene.cellWidth()\r\n        \r\n        # step 1: create a mapping of the connections\r\n        connection_map = self.connectionMap(scene, nodes)\r\n        \r\n        # step 2: organize the nodes into layers based on their connection chain\r\n        layers = self.generateLayers(scene, nodes, connection_map)\r\n        \r\n        # step 3: calculate the total dimensions for the layout\r\n        bounds = QRectF()\r\n        \r\n        # step 3.1: compare the nodes together that have common connections\r\n        layer_widths = []\r\n        layer_heights = []\r\n        node_heights = {}\r\n        node_widths = {}\r\n        \r\n        for layer_index, layer in enumerate(layers):\r\n            layer_w = 0\r\n            layer_h = 0\r\n            \r\n            layer_node_w = []\r\n            layer_node_h = []\r\n            \r\n            for node in layer:\r\n                rect = node.rect()\r\n                \r\n                layer_node_w.append(rect.width())\r\n                layer_node_h.append(rect.height())\r\n                \r\n                if direction == Qt.Vertical:\r\n                    layer_w += rect.width()\r\n                    layer_h = max(rect.height(), layer_h)\r\n                else:\r\n                    layer_w = max(rect.width(), layer_w)\r\n                    layer_h += rect.height()\r\n            \r\n            # update the bounding area\r\n            if direction == Qt.Vertical:\r\n                layer_w += padX * 1 - len(layer)\r\n                bounds.setWidth(max(layer_w, bounds.width()))\r\n                bounds.setHeight(bounds.height() + layer_h)\r\n            else:\r\n                layer_h += padY * 1 - len(layer)\r\n                bounds.setWidth(bounds.width() + layer_w)\r\n                bounds.setHeight(max(layer_h, bounds.height()))\r\n            \r\n            node_widths[layer_index] = layer_node_w\r\n            node_heights[layer_index] = layer_node_h\r\n            \r\n            layer_widths.append(layer_w)\r\n            layer_heights.append(layer_h)\r\n            \r\n        if not center:\r\n            center = scene.sceneRect().center()\r\n        \r\n        w = bounds.width()\r\n        h = bounds.height()\r\n        bounds.setX(center.x() - bounds.width() / 2.0)\r\n        bounds.setY(center.y() - bounds.height() / 2.0)\r\n        bounds.setWidth(w)\r\n        bounds.setHeight(h)\r\n        \r\n        # step 4: assign positions for each node by layer\r\n        processed_nodes = {}\r\n        layer_grps = [(i, layer) for i, layer in enumerate(layers)]\r\n        layer_grps.sort(key=lambda x: len(x[1]))\r\n        \r\n        used_rects = [n.sceneRect() for n in scene.nodes() if not n in nodes]\r\n        \r\n        for layer_index, layer in reversed(layer_grps):\r\n            layer_width  = layer_widths[layer_index]\r\n            layer_height = layer_heights[layer_index]\r\n            \r\n            # determine the starting point for this layer\r\n            if direction == Qt.Vertical:\r\n                offset = layer_index * padY + sum(layer_heights[:layer_index])\r\n                point = QPointF(bounds.x(), offset + bounds.y())\r\n            else:\r\n                offset = layer_index * padX + sum(layer_widths[:layer_index])\r\n                point = QPointF(offset + bounds.x(), bounds.y())\r\n            \r\n            # assign node positions based on existing connections\r\n            for node_index, node in enumerate(layer):\r\n                max_, min_ = (None, None)\r\n                inputs, outputs = connection_map[node]\r\n                for connected_node in inputs + outputs:\r\n                    if not connected_node in processed_nodes:\r\n                        continue\r\n                    \r\n                    npos  = processed_nodes[connected_node]\r\n                    nrect = connected_node.rect()\r\n                    rect  = QRectF(npos.x(), \r\n                                   npos.y(), \r\n                                   nrect.width(), \r\n                                   nrect.height())\r\n                    \r\n                    if direction == Qt.Vertical:\r\n                        if min_ is None:\r\n                            min_ = rect.left()\r\n                        min_ = min(rect.left(), min_)\r\n                        max_ = max(rect.right(), max_)\r\n                    else:\r\n                        if min_ is None:\r\n                            min_ = rect.top()\r\n                        min_ = min(rect.top(), min_)\r\n                        max_ = max(rect.bottom(), max_)\r\n                \r\n                if direction == Qt.Vertical:\r\n                    off_x = 0\r\n                    off_y = (layer_height - node.rect().height()) / 2.0\r\n                    start_x = (bounds.width() - layer_width)\r\n                    start_y = 0\r\n                else:\r\n                    off_x = (layer_width - node.rect().width()) / 2.0\r\n                    off_y = 0\r\n                    start_x = 0\r\n                    start_y = (bounds.height() - layer_height)\r\n                \r\n                # align against existing nodes\r\n                point_x = -1\r\n                point_y = -1\r\n                offset = 0\r\n                before = True\r\n                found_point = True\r\n                new_rect = QRectF()\r\n                \r\n                while found_point:\r\n                    if not None in (min_, max_):\r\n                        if direction == Qt.Vertical:\r\n                            off_x = (max_ - min_)/2.0 - node.rect().width()/2.0\r\n                            \r\n                            if before:\r\n                                off_x -= offset\r\n                                offset += node.rect().width() + padX\r\n                            else:\r\n                                off_x += offset\r\n                            \r\n                            point_x = min_ + off_x\r\n                            point_y = point.y() + off_y\r\n                        else:\r\n                            off_y = (max_ - min_)/2.0 - node.rect().height()/2.0\r\n                            \r\n                            if before:\r\n                                off_y -= offset\r\n                                offset += node.rect().height() + padY\r\n                            else:\r\n                                off_y += offset\r\n                            \r\n                            point_x = point.x() + off_x\r\n                            point_y = min_ + off_y\r\n                        \r\n                    # otherwise, align based on its position in the layer\r\n                    else:\r\n                        if direction == Qt.Vertical:\r\n                            off_x  = sum(node_widths[layer_index][:node_index])\r\n                            off_x += node_index * padX\r\n                            off_x += start_x\r\n                            \r\n                            if before:\r\n                                off_x -= offset\r\n                                offset += node.rect().width() + padX\r\n                            else:\r\n                                off_x += offset\r\n                            \r\n                            point_x = point.x() + off_x\r\n                            point_y = point.y() + off_y\r\n                        else:\r\n                            off_y  = sum(node_heights[layer_index][:node_index])\r\n                            off_y += node_index * padY\r\n                            off_y += start_y\r\n                            \r\n                            if before:\r\n                                off_y -= offset\r\n                                offset += node.rect().height() + padY\r\n                            else:\r\n                                off_y += offset\r\n                            \r\n                            point_x = point.x() + off_x\r\n                            point_y = point.y() + off_y\r\n                    \r\n                    # determine if we've already used this point before\r\n                    before = not before\r\n                    found_point = False\r\n                    orect = node.rect()\r\n                    new_rect = QRectF(point_x, point_y,\r\n                                      orect.width(), orect.height())\r\n                    for used_rect in used_rects:\r\n                        if used_rect.intersects(new_rect):\r\n                            found_point = True\r\n                            break\r\n                \r\n                used_rects.append(new_rect)\r\n                \r\n                if not animationGroup:\r\n                    node.setPos(point_x, point_y)\r\n                else:\r\n                    anim = XNodeAnimation(node, 'setPos')\r\n                    anim.setStartValue(node.pos())\r\n                    anim.setEndValue(QPointF(point_x, point_y))\r\n                    animationGroup.addAnimation(anim)\r\n                    \r\n                processed_nodes[node] = QPointF(point_x, point_y)\r\n                \r\n                if self._testing:\r\n                    QApplication.processEvents()\r\n                    time.sleep(0.5)\r\n        \r\n        return processed_nodes", "response": "This method creates a new layout for the given scene and nodes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, url):\n        parsed_url = urlparse.urlparse(url)\n        try:\n            default_config = self.CONFIG[parsed_url.scheme]\n        except KeyError:\n            raise ValueError(\n                'unrecognised URL scheme for {}: {}'.format(\n                    self.__class__.__name__, url))\n        handler = self.get_handler_for_scheme(parsed_url.scheme)\n        config = copy.deepcopy(default_config)\n        return handler(parsed_url, config)", "response": "Parse a URL into a configuration dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the auto_config URL for the current node.", "response": "def get_auto_config(self):\n        \"\"\"\n        Walk over all available auto_config methods, passing them the current\n        environment and seeing if they return a configuration URL\n        \"\"\"\n        methods = [m for m in dir(self) if m.startswith('auto_config_')]\n        for method_name in sorted(methods):\n            auto_config_method = getattr(self, method_name)\n            url = auto_config_method(self.env)\n            if url:\n                return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndispatches the request to the plugins process method", "response": "def Process(self, request, context):\n        \"\"\"Dispatches the request to the plugins process method\"\"\"\n        LOG.debug(\"Process called\")\n        try:\n            metrics = self.plugin.process(\n                [Metric(pb=m) for m in request.Metrics],\n                ConfigMap(pb=request.Config)\n            )\n            return MetricsReply(metrics=[m.pb for m in metrics])\n        except Exception as err:\n            msg = \"message: {}\\n\\nstack trace: {}\".format(\n                err, traceback.format_exc())\n            return MetricsReply(metrics=[], error=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the members as seen by the local serf agent", "response": "async def items(self, *, wan=None):\n        \"\"\"Returns the members as seen by the local serf agent\n\n        Parameters:\n            wan (bool): List of WAN members instead of the LAN members\n        Returns:\n            Collection: List of cluster's members\n\n        This endpoint returns an object like::\n\n            [\n                {\n                    \"Name\": \"foobar\",\n                    \"Addr\": \"10.1.10.12\",\n                    \"Port\": 8301,\n                    \"Tags\": {\n                        \"bootstrap\": \"1\",\n                        \"dc\": \"dc1\",\n                        \"port\": \"8300\",\n                        \"role\": \"consul\"\n                    },\n                    \"Status\": 1,\n                    \"ProtocolMin\": 1,\n                    \"ProtocolMax\": 2,\n                    \"ProtocolCur\": 2,\n                    \"DelegateMin\": 1,\n                    \"DelegateMax\": 3,\n                    \"DelegateCur\": 3\n                }\n            ]\n        \"\"\"\n        response = await self._api.get(\"/v1/agent/members\",\n                                       params={\"wan\": wan})\n        return response.body"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattempt to join a node with a given WAN pool.", "response": "async def join(self, address, *, wan=None):\n        \"\"\"Triggers the local agent to join a node\n\n        Parameters:\n            address (str): Address of node\n            wan (bool): Attempt to join using the WAN pool\n        Returns:\n            bool: ``True`` on success\n\n        This endpoint is used to instruct the agent to attempt to connect to\n        a given address. For agents running in server mode, providing ``wan``\n        parameter causes the agent to attempt to join using the WAN pool.\n        \"\"\"\n        response = await self._api.get(\"/v1/agent/join\", address,\n                                       params={\"wan\": wan})\n        return response.status == 200"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nforce removal of a node s old notonical cache entries.", "response": "async def force_leave(self, node):\n        \"\"\"Forces removal of a node\n\n        Parameters:\n            node (ObjectID): Node name\n        Returns:\n            bool: ``True`` on success\n\n        This endpoint is used to instruct the agent to force a node into the\n        ``left`` state. If a node fails unexpectedly, then it will be in a\n        ``failed`` state. Once in the ``failed`` state, Consul will attempt to\n        reconnect, and the services and checks belonging to that node will not\n        be cleaned up. Forcing a node into the ``left`` state allows its old\n        entries to be removed.\n        \"\"\"\n        node_id = extract_attr(node, keys=[\"Node\", \"ID\"])\n        response = await self._get(\"/v1/agent/force-leave\", node_id)\n        return response.status == 200"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assignGroup(self, action):\n        grp  = unwrapVariant(action.data())\n        view = self._currentPanel.currentView()\n        view.setViewingGroup(grp)", "response": "Assigns the group for the given action to the current view."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetaches the current panel as a floating window.", "response": "def detachPanel(self):\n        \"\"\"\n        Detaches the current panel as a floating window.\n        \"\"\"\n        from projexui.widgets.xviewwidget import XViewDialog\n        \n        dlg = XViewDialog(self._viewWidget, self._viewWidget.viewTypes())\n        size = self._currentPanel.size()\n        dlg.viewWidget().currentPanel().snagViewFromPanel(self._currentPanel)\n        dlg.resize(size)\n        dlg.show()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetach the current panel as a floating window.", "response": "def detachPanelCopy(self):\n        \"\"\"\n        Detaches the current panel as a floating window.\n        \"\"\"\n        from projexui.widgets.xviewwidget import XViewDialog\n        \n        dlg = XViewDialog(self._viewWidget, self._viewWidget.viewTypes())\n        size = self._currentPanel.size()\n        view = self._currentPanel.currentView()\n        \n        # duplicate the current view\n        if view:\n            new_view = view.duplicate(dlg.viewWidget().currentPanel())\n            view_widget = dlg.viewWidget()\n            view_panel = view_widget.currentPanel()\n            view_panel.addTab(new_view, new_view.windowTitle())\n            \n        dlg.resize(size)\n        dlg.show()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gotoNext(self):\n        index = self._currentPanel.currentIndex() + 1\n        if ( self._currentPanel.count() == index ):\n            index = 0\n            \n        self._currentPanel.setCurrentIndex(index)", "response": "Goes to the next panel tab."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngoing to the previous panel tab.", "response": "def gotoPrevious(self):\n        \"\"\"\n        Goes to the previous panel tab.\n        \"\"\"\n        index = self._currentPanel.currentIndex() - 1\n        if index < 0:\n            index = self._currentPanel.count() - 1\n        \n        self._currentPanel.setCurrentIndex(index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef newPanelTab(self):\n        view = self._currentPanel.currentView()\n        \n        # duplicate the current view\n        if view:\n            new_view = view.duplicate(self._currentPanel)\n            self._currentPanel.addTab(new_view, new_view.windowTitle())", "response": "Creates a new panel with a copy of the current widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef renamePanel(self):\n        index = self._currentPanel.currentIndex()\n        title = self._currentPanel.tabText(index)\n        \n        new_title, accepted = QInputDialog.getText( self,\n                                                    'Rename Tab',\n                                                    'Name:',\n                                                    QLineEdit.Normal,\n                                                    title )\n        \n        if accepted:\n            widget = self._currentPanel.currentView()\n            widget.setWindowTitle(new_title)\n            self._currentPanel.setTabText(index, new_title)", "response": "Prompts the user for a custom name for the current panel tab."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nswap the current tab view for the inputed action s type.", "response": "def swapTabType(self, action):\n        \"\"\"\n        Swaps the current tab view for the inputed action's type.\n        \n        :param      action | <QAction>\n        \"\"\"\n        # for a new tab, use the add tab slot\n        if not self._currentPanel.count():\n            self.addView(action)\n            return\n        \n        # make sure we're not trying to switch to the same type\n        viewType = self._viewWidget.viewType(action.text())\n        view = self._currentPanel.currentView()\n        if type(view) == viewType:\n            return\n        \n        # create a new view and close the old one\r\n        self._viewWidget.setUpdatesEnabled(False)\r\n        self._currentPanel.blockSignals(True)\n        \n        # create the new view\r\n        view.close()\r\n        \r\n        index       = self._currentPanel.currentIndex()\n        new_view    = viewType.createInstance(self._viewWidget,\r\n                                              self._viewWidget)\r\n        \n        # add the new view\n        self._currentPanel.insertTab(index,\n                                     new_view, \n                                     new_view.windowTitle())\n        \r\n        self._currentPanel.blockSignals(False)\r\n        self._currentPanel.setCurrentIndex(index)\r\n        self._viewWidget.setUpdatesEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the data field of the object as a tuple.", "response": "def data(self):\n        \"\"\"Metric data\n\n        Args:\n            value (:obj:`bool` or :obj:`int` or :obj:`long` or :obj:`float`\n                or :obj:`basestring` or :obj:`bytes`)\n\n        Returns:\n            value\n\n        Raises:\n            :obj:`TypeError`\n\n        \"\"\"\n        if self._data_type == int:\n            if self._pb.HasField(\"int64_data\"):\n                return self._pb.int64_data\n            if self._pb.HasField(\"int32_data\"):\n                return self._pb.int32_data\n            if self._pb.HasField(\"uint64_data\"):\n                return self._pb.uint64_data\n            if self._pb.HasField(\"uint32_data\"):\n                return self._pb.uint32_data\n        elif self._data_type == float:\n            if self._pb.HasField(\"float32_data\"):\n                return self._pb.float32_data\n            if self._pb.HasField(\"float64_data\"):\n                return self._pb.float64_data\n        elif self._data_type == str:\n            return self._pb.string_data\n        elif self._data_type == bool:\n            return self._pb.bool_data\n        elif self._data_type == bytes:\n            return self._pb.bytes_data\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall all the dependencies of the current virtualenv.", "response": "def install_deps(self, virtualenv, skip_cached=True, always_exit=False, exit_if_failed=True,\n                     stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):\n        \"\"\"\n        :type virtualenv: VirtualEnv\n        \"\"\"\n        config = self.registered_venvs[virtualenv.venv_name]\n        configed_deps = config['deps']\n        for dep in configed_deps:\n            if dep.startswith(FILE_PREFIX):\n                dep = self._full_relative_path(dep.replace(FILE_PREFIX, ''))\n                virtualenv.install_requirements_file(dep, skip_cached=skip_cached,\n                                                     always_exit=always_exit,\n                                                     exit_if_failed=exit_if_failed, stdin=stdin,\n                                                     stdout=stdout, stderr=stderr)\n            else:\n                virtualenv.install_deps([dep], skip_cached=skip_cached, always_exit=always_exit,\n                                        exit_if_failed=exit_if_failed, stdin=stdin,\n                                        stdout=stdout, stderr=stderr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the current value for the current item in the list.", "response": "def currentValue(self):\r\n        \"\"\"\r\n        Returns the current value for the widget.  If this widget is checkable\r\n        then the bitor value for all checked items is returned, otherwise, the\r\n        selected value is returned.\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        enum  = self.enum()\r\n        if ( self.isCheckable() ):\r\n            value = 0\r\n            for i in self.checkedIndexes():\r\n                value |= enum[nativestring(self.itemText(i))]\r\n            return value\r\n        else:\r\n            try:\r\n                return enum[nativestring(self.itemText(self.currentIndex()))]\r\n            except KeyError:\r\n                return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreloads the contents of the object.", "response": "def reload(self):\r\n        \"\"\"\r\n        Reloads the contents for this box.\r\n        \"\"\"\r\n        enum = self._enum\r\n        if not enum:\r\n            return\r\n        \r\n        self.clear()\r\n        \r\n        if not self.isRequired():\r\n            self.addItem('')\r\n        \r\n        if self.sortByKey():\r\n            self.addItems(sorted(enum.keys()))\r\n        else:\r\n            items = enum.items()\r\n            items.sort(key = lambda x: x[1])\r\n            \r\n            self.addItems(map(lambda x: x[0], items))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the value for the combobox to the inputed value.", "response": "def setCurrentValue(self, value):\r\n        \"\"\"\r\n        Sets the value for the combobox to the inputed value.  If the combobox \r\n        is in a checkable state, then the values will be checked, otherwise,\r\n        the value will be selected.\r\n        \r\n        :param      value | <int>\r\n        \"\"\"\r\n        enum = self.enum()\r\n        if not enum:\r\n            return\r\n        \r\n        if self.isCheckable():\r\n            indexes = []\r\n            for i in range(self.count()):\r\n                try:\r\n                    check_value = enum[nativestring(self.itemText(i))]\r\n                except KeyError:\r\n                    continue\r\n                \r\n                if check_value & value:\r\n                    indexes.append(i)\r\n            self.setCheckedIndexes(indexes)\r\n        else:\r\n            try:\r\n                text = enum[value]\r\n            except (AttributeError, KeyError):\r\n                return\r\n            \r\n            self.setCurrentIndex(self.findText(text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the pixmap to the list for this slider.", "response": "def addPixmap(self, pixmap):\r\n        \"\"\"\r\n        Adds the pixmap to the list for this slider.\r\n        \r\n        :param      pixmap | <QPixmap> || <str>\r\n        \"\"\"\r\n        scene = self.scene()\r\n        scene.addItem(XImageItem(pixmap))\r\n        self.recalculate()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculateSceneWidth(self):\r\n        widths = []\r\n        \r\n        w = self.width() / 2.0\r\n        h = self.height() / 2.0\r\n        \r\n        for item in self.scene().items():\r\n            pixmap = item.basePixmap()\r\n            thumb = pixmap.scaled(pixmap.width(), h, Qt.KeepAspectRatio)\r\n            widths.append(thumb.width())\r\n            item.setPixmap(thumb)\r\n        \r\n        return sum(widths) + self.spacing() * (self.count() - 1) + w", "response": "Calculates the total width for all the pixmaps for this widget and returns the total width for all the pixmaps for all the items in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef recalculate(self):\r\n        # recalculate the scene geometry\r\n        scene = self.scene()\r\n        w = self.calculateSceneWidth()\r\n        scene.setSceneRect(0, 0, w, self.height())\r\n        \r\n        # recalculate the item layout\r\n        spacing = self.spacing()\r\n        x = self.width() / 4.0\r\n        y = self.height() / 2.0\r\n        for item in self.items():\r\n            pmap = item.pixmap()\r\n            item.setPos(x, y - pmap.height() / 1.5)\r\n            x += pmap.size().width() + spacing", "response": "Recalculates the slider scene for this widget and the items for this widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the pixmap from this widgets list of pixmaps.", "response": "def removePixmap(self, pixmap):\r\n        \"\"\"\r\n        Removes the pixmap from this widgets list of pixmaps.\r\n        \r\n        :param      pixmap | <QPixmap>\r\n        \"\"\"\r\n        scene = self.scene()\r\n        for item in self.items():\r\n            if item.basePixmap() == pixmap:\r\n                scene.removeItem(item)\r\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhooks into the resize event for the slider widget.", "response": "def resizeEvent(self, event):\r\n        \"\"\"\r\n        Hooks into the resize event for the slider widget to update the scene\r\n        with the latest witdth.\r\n        \r\n        :param      event | <QResizeEvent>\r\n        \"\"\"\r\n        super(XImageSlider, self).resizeEvent(event)\r\n        \r\n        self.recalculate()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the pixmaps for this widget to the inputed list of images.", "response": "def setPixmaps(self, pixmaps):\r\n        \"\"\"\r\n        Sets the pixmaps for this widget to the inputed list of images.\r\n        \r\n        :param      pixmaps | [<QPixmap>, ..]\r\n        \"\"\"\r\n        self.clear()\r\n        scene = self.scene()\r\n        \r\n        for pmap in pixmaps:\r\n            scene.addItem(XImageItem(pmap))\r\n        \r\n        self.recalculate()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if token is expired and set auth header.", "response": "def _check_token(self):\n        \"\"\" Simple Mercedes me API.\n\n        \"\"\"\n        need_token = (self._token_info is None or\n                      self.auth_handler.is_token_expired(self._token_info))\n        if need_token:\n            new_token = \\\n                self.auth_handler.refresh_access_token(\n                    self._token_info['refresh_token'])\n            # skip when refresh failed\n            if new_token is None:\n                return\n\n            self._token_info = new_token\n            self._auth_header = {\"content-type\": \"application/json\",\n                                 \"Authorization\": \"Bearer {}\".format(\n                                     self._token_info.get('access_token'))}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_location(self, car_id):\n        _LOGGER.debug(\"get_location for %s called\", car_id)\n\n        api_result = self._retrieve_api_result(car_id, API_LOCATION)\n\n        _LOGGER.debug(\"get_location result: %s\", api_result)\n\n        location = Location()\n\n        for loc_option in LOCATION_OPTIONS:\n            curr_loc_option = api_result.get(loc_option)\n            value = CarAttribute(\n                curr_loc_option.get(\"value\"),\n                curr_loc_option.get(\"retrievalstatus\"),\n                curr_loc_option.get(\"timestamp\"))\n\n            setattr(location, loc_option, value)\n\n        return location", "response": "get refreshed location information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new token with a given specification.", "response": "async def create(self, token):\n        \"\"\"Creates a new token with a given policy\n\n        Parameters:\n            token (Object): Token specification\n        Returns:\n            Object: token ID\n\n        The create endpoint is used to make a new token.\n        A token has a name, a type, and a set of ACL rules.\n\n        The request body may take the form::\n\n            {\n                \"Name\": \"my-app-token\",\n                \"Type\": \"client\",\n                \"Rules\": \"\"\n            }\n\n        None of the fields are mandatory. The **Name** and **Rules** fields\n        default to being blank, and the **Type** defaults to \"client\".\n\n        **Name** is opaque to Consul. To aid human operators, it should\n        be a meaningful indicator of the ACL's purpose.\n\n        **Type** is either **client** or **management**. A management token\n        is comparable to a root user and has the ability to perform any action\n        including creating, modifying and deleting ACLs.\n\n        **ID** field may be provided, and if omitted a random UUID will be\n        generated.\n\n        The format of **Rules** is\n        `documented here <https://www.consul.io/docs/internals/acl.html>`_.\n\n        A successful response body will return the **ID** of the newly\n        created ACL, like so::\n\n            {\n                \"ID\": \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\"\n            }\n        \"\"\"\n        token = encode_token(token)\n        response = await self._api.put(\"/v1/acl/create\", data=token)\n        return response.body"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def destroy(self, token):\n        token_id = extract_attr(token, keys=[\"ID\"])\n        response = await self._api.put(\"/v1/acl/destroy\", token_id)\n        return response.body", "response": "Destroys a given token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def info(self, token):\n        token_id = extract_attr(token, keys=[\"ID\"])\n        response = await self._api.get(\"/v1/acl/info\", token_id)\n        meta = extract_meta(response.headers)\n        try:\n            result = decode_token(response.body[0])\n        except IndexError:\n            raise NotFound(response.body, meta=meta)\n        return consul(result, meta=meta)", "response": "Queries the policy of a given token."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new token by cloning an existing token", "response": "async def clone(self, token):\n        \"\"\"Creates a new token by cloning an existing token\n\n        Parameters:\n            token (ObjectID): Token ID\n        Returns:\n            ObjectMeta: where value is token ID\n\n        This allows a token to serve as a template for others, making it\n        simple to generate new tokens without complex rule management.\n\n        As with create, a successful response body will return the ID of the\n        newly created ACL, like so::\n\n            {\n                \"ID\": \"adf4238a-882b-9ddc-4a9d-5b6758e4159e\"\n            }\n        \"\"\"\n        token_id = extract_attr(token, keys=[\"ID\"])\n        response = await self._api.put(\"/v1/acl/clone\", token_id)\n        return consul(response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def items(self):\n        response = await self._api.get(\"/v1/acl/list\")\n        results = [decode_token(r) for r in response.body]\n        return consul(results, meta=extract_meta(response.headers))", "response": "Lists all the active tokens\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks the status of an ACL replication process in a datacenter.", "response": "async def replication(self, *, dc=None):\n        \"\"\"Checks status of ACL replication\n\n        Parameters:\n            dc (str): Specify datacenter that will be used.\n                      Defaults to the agent's local datacenter.\n        Returns:\n            Object: Replication information\n\n        Returns the status of the ACL replication process in the datacenter.\n        This is intended to be used by operators, or by automation checking\n        the health of ACL replication.\n\n        By default, the datacenter of the agent is queried; however, the dc\n        can be provided using the \"dc\" parameter.\n\n        It returns a body like this::\n\n            {\n                \"Enabled\": True,\n                \"Running\": True,\n                \"SourceDatacenter\": \"dc1\",\n                \"ReplicatedIndex\": 1976,\n                \"LastSuccess\": datetime(2016, 8, 5, 6, 28, 58, tzinfo=tzutc()),\n                \"LastError\": datetime(2016, 8, 5, 6, 28, 58, tzinfo=tzutc())\n            }\n\n        **Enabled** reports whether ACL replication is enabled for the\n        datacenter.\n\n        **Running** reports whether the ACL replication process is running.\n        The process may take approximately 60 seconds to begin running after\n        a leader election occurs.\n\n        **SourceDatacenter** is the authoritative ACL datacenter that ACLs\n        are being replicated from, and will match the acl_datacenter\n        configuration.\n\n        **ReplicatedIndex** is the last index that was successfully replicated.\n        You can compare this to the Index meta returned by the items() endpoint\n        to determine if the replication process has gotten all available ACLs.\n        Note that replication runs as a background process approximately every\n        30 seconds, and that local updates are rate limited to 100\n        updates/second, so so it may take several minutes to perform the\n        initial sync of a large set of ACLs. After the initial sync, replica\n        lag should be on the order of about 30 seconds.\n\n        **LastSuccess** is the UTC time of the last successful sync operation.\n        Note that since ACL replication is done with a blocking query, this\n        may not update for up to 5 minutes if there have been no ACL changes\n        to replicate. A zero value of \"0001-01-01T00:00:00Z\" will be present\n        if no sync has been successful.\n\n        **LastError** is the UTC time of the last error encountered during a\n        sync operation. If this time is later than LastSuccess, you can assume\n        the replication process is not in a good state. A zero value of\n        \"0001-01-01T00:00:00Z\" will be present if no sync has resulted in an\n        error.\n        \"\"\"\n        params = {\"dc\": dc}\n        response = await self._api.get(\"/v1/acl/replication\", params=params)\n        return response.body"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match_strings(str1, str2):\n    i = 0\n    min_len = len(str1) if len(str1) < len(str2) else len(str2)\n    while i < min_len and str1[i] == str2[i]: i += 1\n    return i", "response": "Returns the index of the first occurrence of str1 in str2."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_unique_endings(strings_collection):\n    res = []\n    for i in range(len(strings_collection)):\n        # NOTE(msdubov): a trick to handle 'narrow' python installation issues.\n        hex_code = hex(consts.String.UNICODE_SPECIAL_SYMBOLS_START+i)\n        hex_code = r\"\\U\" + \"0\" * (8 - len(hex_code) + 2) + hex_code[2:]\n        res.append(strings_collection[i] + hex_code.decode(\"unicode-escape\"))\n    return res", "response": "Make each string in the collection end with a unique character."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of values for the maximum and minimum values for the current axis.", "response": "def calculateValues(self):\r\n        \"\"\"\r\n        Overloads the calculate values method to calculate the values for\r\n        this axis based on the minimum and maximum values, and the number\r\n        of steps desired.\r\n        \r\n        :return     [<variant>, ..]\r\n        \"\"\"\r\n        if self.maximum() <= self.minimum():\r\n            return []\r\n        \r\n        max_labels = self.maximumLabelCount()\r\n        seconds = (self.maximum() - self.minimum()).total_seconds()\r\n        step = datetime.timedelta(0, int(round(float(seconds) / max_labels)))\r\n        \r\n        values = []\r\n        value = self.minimum()\r\n        while value <= self.maximum():\r\n            values.append(value)\r\n            value += step\r\n        \r\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the percentage of value represents between the minimum and maximum for this axis.", "response": "def percentAt(self, value):\r\n        \"\"\"\r\n        Returns the percentage the value represents between the minimum and\r\n        maximum for this axis.\r\n        \r\n        :param      value | <int> || <float>\r\n        \r\n        :return     <float>\r\n        \"\"\"\r\n        min_val = self.minimum()\r\n        max_val = self.maximum()\r\n        \r\n        # round the max value to sync with the values in the grid\r\n        total_seconds = (max_val - min_val).total_seconds()\r\n        value_seconds = (value - min_val).total_seconds()\r\n        \r\n        if value < min_val:\r\n            return 0.0\r\n        elif max_val < value:\r\n            return 1.0\r\n        \r\n        try:\r\n            perc = value_seconds / float(total_seconds)\r\n        except ZeroDivisionError:\r\n            perc = 0.0\r\n        \r\n        return perc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the total amount of time for the given list of time items.", "response": "def sum(self, values):\r\n        \"\"\"\r\n        Calculates the total values for the inputed values.\r\n        \r\n        :return     <int>\r\n        \"\"\"\r\n        values = sorted(values)\r\n        try:\r\n            return (values[-1] - values[0]).total_seconds()\r\n        except IndexError, TypeError:\r\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the value at the given percent representing the minimum and maximum for this axis.", "response": "def valueAt(self, percent):\r\n        \"\"\"\r\n        Returns the value the percent represents between the minimum and\r\n        maximum for this axis.\r\n        \r\n        :param      value | <int> || <float>\r\n        \r\n        :return     <float>\r\n        \"\"\"\r\n        min_val = self.minimum()\r\n        max_val = self.maximum()\r\n        \r\n        if percent < 0:\r\n            return min_val\r\n        elif 1 < percent:\r\n            return max_val\r\n        \r\n        # round the max value to sync with the values in the grid\r\n        total_seconds = (max_val - min_val).total_seconds()\r\n        perc_seconds = max(min(percent, 1.0), 0.0) * total_seconds\r\n        \r\n        return max_val + datetime.timedelta(0, perc_seconds)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery for WAN network coordinates of Consul servers organized by DCs.", "response": "async def datacenters(self):\n        \"\"\"Queries for WAN coordinates of Consul servers\n\n        Returns:\n            Mapping: WAN network coordinates for all Consul\n                     servers, organized by DCs.\n\n        It returns a body like this::\n\n            {\n                \"dc1\": {\n                    \"Datacenter\": \"dc1\",\n                    \"Coordinates\": [\n                        {\n                            \"Node\": \"agent-one\",\n                            \"Coord\": {\n                                \"Adjustment\": 0,\n                                \"Error\": 1.5,\n                                \"Height\": 0,\n                                \"Vec\": [0,0,0,0,0,0,0,0]\n                            }\n                        }\n                    ]\n                }\n            }\n\n        This endpoint serves data out of the server's local Serf data about\n        the WAN, so its results may vary as requests are handled by different\n        servers in the cluster.\n\n        Also, it does not support blocking queries or any consistency modes.\n        \"\"\"\n        response = await self._api.get(\"/v1/coordinate/datacenters\")\n        return {data[\"Datacenter\"]: data for data in response.body}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the frame for the given sender.", "response": "def _updateFrame(self):\r\n        \"\"\"\r\n        Updates the frame for the given sender.\r\n        \"\"\"\r\n        mov = self.movie()\r\n        if mov:\r\n            self.setIcon(QtGui.QIcon(mov.currentPixmap()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filterData(self, key):\n        if key == 'text':\r\n            default = nativestring(self.text())\r\n        else:\r\n            default = ''\n        return self._filterData.get(key, default)", "response": "Returns the filter data for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the filtering information for the given key to the inputed value.", "response": "def setFilterData(self, key, value):\n        \"\"\"\n        Sets the filtering information for the given key to the inputed value.\n        \n        :param      key | <str>\n                    value | <str>\n        \"\"\"\n        self._filterData[nativestring(key)] = nativestring(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setMovie(self, movie):\r\n        mov = self.movie()\r\n        if mov is not None:\r\n            mov.frameChanged.disconnect(self._updateFrame)\r\n        \r\n        if movie is not None:\r\n            self._movie = movie\r\n            self.setIcon(QtGui.QIcon(movie.currentPixmap()))\r\n            \r\n            movie.frameChanged.connect(self._updateFrame)\r\n            \r\n            widget = self.listWidget()\r\n            widget.destroyed.connect(self.cleanup)\r\n        else:\r\n            self._movie = None", "response": "Sets the movie that will play for the given column."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef children(self):\r\n        new_refs = set()\r\n        output = []\r\n        for ref in self._children:\r\n            item = ref()\r\n            if item is not None:\r\n                output.append(item)\r\n                new_refs.add(ref)\r\n        \r\n        self._children = new_refs\r\n        return output", "response": "Returns the children of this group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef foreground(self):\r\n        widget = self.widget()\r\n        if widget:\r\n            palette = widget.palette()\r\n            return palette.color(palette.WindowText)\r\n        else:\r\n            return QtGui.QColor()", "response": "Returns the foreground color for this group item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setExpanded(self, state):\r\n        if state == self._expanded:\r\n            return\r\n        \r\n        self._expanded = state\r\n        \r\n        # update the button\r\n        btn = self.widget()\r\n        if btn:\r\n            if state:\r\n                ico = 'img/treeview/triangle_down.png'\r\n            else:\r\n                ico = 'img/treeview/triangle_right.png'\r\n            btn.setIcon(QtGui.QIcon(resources.find(ico)))\r\n        \r\n        # update the children\r\n        for child in self.children():\r\n            child.setHidden(not state)", "response": "Updates the expanded state of the group item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setHidden(self, state):\r\n        super(XListGroupItem, self).setHidden(state)\r\n        \r\n        for child in self.children():\r\n            child.setHidden(state or not self.isExpanded())", "response": "Sets the hidden state of this item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the foreground color for this group item.", "response": "def setForeground(self, color):\r\n        \"\"\"\r\n        Sets the foreground color for this group item to the inputed color.\r\n        \r\n        :param      color | <QtGui.QColor>\r\n        \"\"\"\r\n        btn = self.widget()\r\n        if btn:\r\n            palette = btn.palette()\r\n            palette.setColor(palette.WindowText, color)\r\n            btn.setPalette(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setText(self, text):\r\n        self._text = text\r\n        \r\n        # update the label\r\n        btn = self.widget()\r\n        if btn:\r\n            btn.setText(text)", "response": "Sets the text for this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters the items in this tree based on the inputed keywords.", "response": "def __filterItems(self, \n                      terms, \n                      caseSensitive=False):\n        \"\"\"\n        Filters the items in this tree based on the inputed keywords.\n        \n        :param      terms           | {<str> dataType: [<str> term, ..], ..}\n                    caseSensitive   | <bool>\n        \n        :return     <bool> | found\n        \"\"\"\n        found = False\n        items = []\n        \n        # collect the items to process\n        for i in range(self.count()):\n            items.append(self.item(i))\n        \n        for item in items:\r\n            if not isinstance(item, XListWidgetItem):\r\n                continue\r\n            \n            # if there is no filter keywords, then all items will be visible\n            if not any(terms.values()):\n                found = True\n                item.setHidden(False)\n            \n            else:\n                # match all generic keywords\n                generic         = terms.get('*', [])\n                generic_found   = dict((key, False) for key in generic)\n                \n                # match all specific keywords\n                dtype_found  = dict((col, False) for col in terms if col != '*')\n                \n                # look for any matches for any data type\n                mfound = False\n                \n                for dataType in self._filteredDataTypes:\n                    # determine the check text based on case sensitivity\n                    if caseSensitive:\n                        check = nativestring(item.filterData(dataType))\n                    else:\n                        check = nativestring(item.filterData(dataType)).lower()\n                    \n                    specific = terms.get(dataType, [])\n                    \n                    # make sure all the keywords match\n                    for key in generic + specific:\n                        if not key:\n                            continue\n                        \n                        # look for exact keywords\n                        elif key.startswith('\"') and key.endswith('\"'):\n                            if key.strip('\"') == check:\n                                if key in generic:\n                                    generic_found[key] = True\n                                \n                                if key in specific:\n                                    dtype_found[dataType] = True\n                        \n                        # look for ending keywords\n                        elif key.startswith('*') and not key.endswith('*'):\n                            if check.endswith(key.strip('*')):\n                                if key in generic:\n                                    generic_found[key] = True\n                                if key in specific:\n                                    dtype_found[dataType] = True\n                        \n                        # look for starting keywords\n                        elif key.endswith('*') and not key.startswith('*'):\n                            if check.startswith(key.strip('*')):\n                                if key in generic:\n                                    generic_found[key] = True\n                                if key in specific:\n                                    dtype_found[dataType] = True\n                        \n                        # look for generic keywords\n                        elif key.strip('*') in check:\n                            if key in generic:\n                                generic_found[key] = True\n                            if key in specific:\n                                dtype_found[dataType] = True\n                    \n                    mfound = all(dtype_found.values()) and \\\n                             all(generic_found.values())\n                    if mfound:\n                        break\n                \n                item.setHidden(not mfound)\n                \n                if mfound:\n                    found = True\n        \n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filterItems(self, \n                    terms, \n                    caseSensitive=False):\n        \"\"\"\n        Filters the items in this tree based on the inputed text.\n        \n        :param      terms           | <str> || {<str> datatype: [<str> opt, ..]}\n                    caseSensitive   | <bool>\n        \"\"\"\n        # create a dictionary of options\n        if type(terms) != dict:\n            terms = {'*': nativestring(terms)}\n        \n        # validate the \"all search\"\n        if '*' in terms and type(terms['*']) != list:\n            sterms = nativestring(terms['*'])\n            \n            if not sterms.strip():\n                terms.pop('*')\n            else:\n                dtype_matches = DATATYPE_FILTER_EXPR.findall(sterms)\n                \n                # generate the filter for each data type\n                for match, dtype, values in dtype_matches:\n                    sterms = sterms.replace(match, '')\n                    terms.setdefault(dtype, [])\n                    terms[dtype] += values.split(',')\n                \n                keywords = sterms.replace(',', '').split()\n                while '' in keywords:\n                    keywords.remove('')\n                \n                terms['*'] = keywords\n        \n        # filter out any data types that are not being searched\n        filtered_dtypes = self.filteredDataTypes()\n        filter_terms = {}\n        for dtype, keywords in terms.items():\n            if dtype != '*' and not dtype in filtered_dtypes:\n                continue\n            \n            if not caseSensitive:\n                keywords = [nativestring(keyword).lower() for keyword in keywords]\n            else:\n                keywords = map(nativestring, keywords)\n            \n            filter_terms[dtype] = keywords\n        \n        self.__filterItems(filter_terms, caseSensitive)", "response": "Filter the items in this tree based on the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverload the paint event to support rendering of hints if there are no items in the tree.", "response": "def paintEvent(self, event):\r\n        \"\"\"\r\n        Overloads the paint event to support rendering of hints if there are\r\n        no items in the tree.\r\n        \r\n        :param      event | <QPaintEvent>\r\n        \"\"\"\r\n        super(XListWidget, self).paintEvent(event)\r\n        \r\n        if not self.visibleCount() and self.hint():\r\n            text    = self.hint()\r\n            rect    = self.rect()\r\n            \r\n            # modify the padding on the rect\r\n            w = min(250, rect.width() - 30)\r\n            x = (rect.width() - w) / 2\r\n            \r\n            rect.setX(x)\r\n            rect.setY(rect.y() + 15)\r\n            rect.setWidth(w)\r\n            rect.setHeight(rect.height() - 30)\r\n            \r\n            align = int(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignTop)\r\n            \r\n            # setup the coloring options\r\n            clr     = self.hintColor()\r\n            \r\n            # paint the hint\r\n            with XPainter(self.viewport()) as painter:\r\n                painter.setPen(clr)\r\n                painter.drawText(rect, align | QtCore.Qt.TextWordWrap, text)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setAutoResizeToContents(self, state):\r\n        self._autoResizeToContents = state\r\n        \r\n        if state:\r\n            self.resizeToContents()\r\n            self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n            self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        else:\r\n            self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\r\n            self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)", "response": "Sets whether or not this widget should automatically resize its height based on its contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef visibleCount(self):\r\n        return sum(int(not self.item(i).isHidden()) for i in range(self.count()))", "response": "Returns the number of items in this list that are not hidden."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprompts the user for more advanced text input.", "response": "def getPlainText( parent, title, caption, text = '' ):\n        \"\"\"\n        Prompts the user for more advanced text input.\n        \n        :param      parent  | <QWidget> || None\n                    title   | <str>\n                    caption | <str>\n                    text    | <str>\n        \n        :return     (<str>, <bool> accepted)\n        \"\"\"\n        dlg = QDialog(parent)\n        dlg.setWindowTitle(title)\n        \n        label = QLabel(dlg)\n        label.setText(caption)\n        \n        edit = QTextEdit(dlg)\n        edit.setText(text)\n        edit.selectAll()\n        \n        opts = QDialogButtonBox.Ok | QDialogButtonBox.Cancel\n        btns = QDialogButtonBox(opts, Qt.Horizontal, dlg)\n        \n        btns.accepted.connect(dlg.accept)\n        btns.rejected.connect(dlg.reject)\n        \n        layout = QVBoxLayout()\n        layout.addWidget(label)\n        layout.addWidget(edit)\n        layout.addWidget(btns)\n        \n        dlg.setLayout(layout)\n        dlg.adjustSize()\n        \n        if ( dlg.exec_() ):\n            return (edit.toPlainText(), True)\n        return ('', False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_status_file(status_file,nas_addr):\n    ''' parse openvpn status log\n    '''\n    session_users = {}\n    flag1 = False\n    flag2 = False\n    with open(status_file) as stlines:\n        for line in stlines:\n\n            if line.startswith(\"Common Name\"):\n                flag1 = True\n                continue\n\n            if line.startswith(\"ROUTING TABLE\"):\n                flag1 = False\n                continue\n\n            if line.startswith(\"Virtual Address\"):\n                flag2 = True\n                continue\n\n            if line.startswith(\"GLOBAL STATS\"):\n                flag2 = False\n                continue\n\n            if flag1:\n                try:\n                    username,realaddr,inbytes,outbytes,_ = line.split(',')\n                    realip,realport = realaddr.split(':')\n                    session_id = md5(nas_addr + realip + realport).hexdigest()\n                    session_users.setdefault(session_id, {}).update(dict(\n                        session_id=session_id,\n                        username=username,\n                        realip=realip,\n                        realport=realport,\n                        inbytes=inbytes,\n                        outbytes=outbytes\n                    ))\n                except:\n                    traceback.print_exc()\n\n            if flag2:\n                try:\n                    userip,username,realaddr,_ = line.split(',')\n                    realip,realport = realaddr.split(':')\n                    session_id = md5(nas_addr + realip + realport).hexdigest()\n                    session_users.setdefault(session_id, {}).update(dict(\n                        session_id=session_id,\n                        username=username,\n                        realip=realip,\n                        realport=realport,\n                        userip=userip,\n                    ))\n                except:\n                    traceback.print_exc()\n\n    return session_users", "response": "parse openvpn status log"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emit(self, record):\r\n        disp = self.dispatch()\r\n        if disp is None:\r\n            return\r\n        \r\n        msg = self.format(record)\r\n        \r\n        # emit the dispatch signals\r\n        disp.recordLogged.emit(record)\r\n        disp.messageLogged.emit(record.levelno, msg)\r\n        \r\n        if record.levelno == logging.DEBUG:\r\n            disp.debugLogged.emit(msg)\r\n        elif record.levelno == logging.INFO:\r\n            disp.infoLogged.emit(msg)\r\n        elif record.levelno == logging.WARN:\r\n            disp.warningLogged.emit(msg)\r\n        elif record.levelno == logging.ERROR:\r\n            disp.errorLogged.emit(msg)\r\n        elif record.levelno == logging.CRITICAL:\r\n            disp.criticalLogged.emit(msg)", "response": "Emits the message for this record through the dispatch signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _construct(self, strings_collection):\n        \n        # 1. Add a unique character to each string in the collection\n        strings_collection = utils.make_unique_endings(strings_collection)\n    \n        ############################################################\n        # 2. Build the GST using modified Ukkonnen's algorithm     #\n        ############################################################\n        \n        root = ast.AnnotatedSuffixTree.Node()\n        root.strings_collection = strings_collection\n        # To preserve simplicity\n        root.suffix_link = root\n        root._arc = (0,-1,0)\n        # For constant updating of all leafs, see [Gusfield {RUS}, p. 139]\n        root._e = [0 for _ in xrange(len(strings_collection))]\n        \n        \n        def _ukkonen_first_phases(string_ind):\n            \"\"\"\n            Looks for the part of the string which is already encoded.\n            Returns a tuple of form\n            ([length of already encoded string preffix],\n             [tree node to start the first explicit phase with],\n             [path to go down at the beginning of the first explicit phase]).\n            \n            \"\"\"\n            already_in_tree = 0\n            suffix = strings_collection[string_ind]\n            starting_path = (0, 0, 0)\n            starting_node = root\n            child_node = starting_node.chose_arc(suffix)\n            while child_node:\n                (str_ind, substr_start, substr_end) = child_node.arc()\n                match = utils.match_strings(\n                            suffix, strings_collection[str_ind][substr_start:substr_end])\n                already_in_tree += match\n                if match == substr_end-substr_start:\n                    # matched the arc, proceed with child node\n                    suffix = suffix[match:]\n                    starting_node = child_node\n                    child_node = starting_node.chose_arc(suffix)\n                else:\n                    # otherwise we will have to proceed certain path at the beginning\n                    # of the first explicit phase\n                    starting_path = (str_ind, substr_start, substr_start+match)\n                    break\n            # For constant updating of all leafs, see [Gusfield {RUS}, p. 139]\n            root._e[string_ind] = already_in_tree\n                \n            return (already_in_tree, starting_node, starting_path)\n        \n        def _ukkonen_phase(string_ind, phase, starting_node, starting_path, starting_continuation):\n            \"\"\"\n            Ukkonen's algorithm single phase.\n            Returns a tuple of form:\n            ([tree node to start the next phase with],\n             [path to go down at the beginning of the next phase],\n             [starting continuation for the next phase]).\n            \n            \"\"\"\n            current_suffix_end = starting_node\n            suffix_link_source_node = None\n            path_str_ind, path_substr_start, path_substr_end = starting_path\n            # Continuations [starting_continuation..(i+1)]\n            for continuation in xrange(starting_continuation, phase+1):\n                # Go up to the first node with suffix link [no more than 1 pass]\n                if continuation > starting_continuation:\n                    path_str_ind, path_substr_start, path_substr_end = 0, 0, 0\n                    if not current_suffix_end.suffix_link:\n                        (path_str_ind, path_substr_start, path_substr_end) = current_suffix_end.arc()\n                        current_suffix_end = current_suffix_end.parent\n                    if current_suffix_end.is_root():\n                        path_str_ind = string_ind\n                        path_substr_start = continuation\n                        path_substr_end = phase\n                    else:\n                        # Go through the suffix link\n                        current_suffix_end = current_suffix_end.suffix_link\n                        \n                # Go down the path (str_ind, substr_start, substr_end)\n                # NB: using Skip/Count trick,\n                # see [Gusfield {RUS} p.134] for details\n                g = path_substr_end - path_substr_start\n                if g > 0:\n                    current_suffix_end = current_suffix_end.chose_arc(strings_collection\n                                         [path_str_ind][path_substr_start])\n                (_, cs_ss_start, cs_ss_end) = current_suffix_end.arc()\n                g_ = cs_ss_end - cs_ss_start\n                while g >= g_:\n                    path_substr_start += g_\n                    g -= g_\n                    if g > 0:\n                        current_suffix_end = current_suffix_end.chose_arc(strings_collection\n                                             [path_str_ind][path_substr_start])\n                    (_, cs_ss_start, cs_ss_end) = current_suffix_end.arc()\n                    g_ = cs_ss_end - cs_ss_start\n                    \n                # Perform continuation by one of three rules,\n                # see [Gusfield {RUS} p. 129] for details\n                if g == 0:\n                    # Rule 1\n                    if current_suffix_end.is_leaf():\n                        pass\n                    # Rule 2a\n                    elif not current_suffix_end.chose_arc(strings_collection[string_ind][phase]):\n                        if suffix_link_source_node:\n                            suffix_link_source_node.suffix_link = current_suffix_end\n                        new_leaf = current_suffix_end.add_new_child(string_ind, phase, -1)\n                        new_leaf.weight = 1\n                        if continuation == starting_continuation:\n                            starting_node = new_leaf\n                            starting_path = (0, 0, 0)\n                    # Rule 3a\n                    else:\n                        if suffix_link_source_node:\n                            suffix_link_source_node.suffix_link = current_suffix_end\n                        starting_continuation = continuation\n                        starting_node = current_suffix_end\n                        starting_path = (string_ind, phase, phase+1)\n                        break\n                    suffix_link_source_node = None\n                else:\n                    (si, ss, se) = current_suffix_end._arc\n                    # Rule 2b\n                    if strings_collection[si][ss + g] != strings_collection[string_ind][phase]:\n                        parent = current_suffix_end.parent\n                        parent.remove_child(current_suffix_end)\n                        current_suffix_end._arc = (si, ss+g, se)\n                        new_node = parent.add_new_child(si, ss, ss + g)\n                        new_leaf = new_node.add_new_child(string_ind, phase, -1)\n                        new_leaf.weight = 1\n                        if continuation == starting_continuation:\n                            starting_node = new_leaf\n                            starting_path = (0, 0, 0)\n                        new_node.add_child(current_suffix_end)\n                        if suffix_link_source_node:\n                            # Define new suffix link\n                            suffix_link_source_node.suffix_link = new_node\n                        suffix_link_source_node = new_node\n                        current_suffix_end = new_node\n                    # Rule 3b\n                    else:\n                        suffix_link_source_node = None\n                        starting_continuation = continuation\n                        starting_node = current_suffix_end.parent\n                        starting_path = (si, ss, ss+g+1)\n                        break\n            \n            # Constant updating of all leafs, see [Gusfield {RUS}, p. 139]\n            starting_node._e[string_ind] += 1\n            \n            return starting_node, starting_path, starting_continuation\n                        \n        for m in xrange(len(strings_collection)):\n            # Check for phases 1..x that are already in tree\n            starting_phase, starting_node, starting_path = _ukkonen_first_phases(m)\n            starting_continuation = 0\n            # Perform phases (x+1)..n explicitly\n            for phase in xrange(starting_phase, len(strings_collection[m])):\n                starting_node, starting_path, starting_continuation = \\\n                    _ukkonen_phase(m, phase, starting_node, starting_path, starting_continuation)\n                    \n        \n        ############################################################\n        ############################################################\n        ############################################################\n        \n        # 3. Delete degenerate first-level children\n        for k in root.children.keys():\n            (ss, si, se) = root.children[k].arc()\n            if (se - si == 1 and\n                ord(strings_collection[ss][si]) >= consts.String.UNICODE_SPECIAL_SYMBOLS_START):\n                del root.children[k]\n        \n        # 4. Make a depth-first bottom-up traversal and annotate\n        #    each node by the sum of its children;\n        #    each leaf is already annotated with '1'.\n        def _annotate(node):\n            weight = 0\n            for k in node.children:\n                if node.children[k].weight > 0:\n                    weight += node.children[k].weight\n                else:\n                    weight += _annotate(node.children[k])\n            node.weight = weight\n            return weight\n        _annotate(root)\n        \n        return root", "response": "This method is used to construct the GST from a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _filter_by_simple_schema(self, qs, lookup, sublookup, value, schema):\n        value_lookup = 'attrs__value_%s' % schema.datatype\n        if sublookup:\n            value_lookup = '%s__%s' % (value_lookup, sublookup)\n        return {\n            'attrs__schema': schema,\n            str(value_lookup): value\n        }", "response": "Filters given entity queryset by a simple schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfiltering given entity queryset by an attribute which is linked to given range schema.", "response": "def _filter_by_range_schema(self, qs, lookup, sublookup, value, schema):\n        \"\"\"\n        Filters given entity queryset by an attribute which is linked to given\n        range schema. Lookups `between` yields items that lie not completely\n        within given range but have intersection with it. For example, and item\n        with x=(2,5) will match q=(3,None) or q=(0,3). See tests for details.\n\n            qs.filter(weight_range__overlaps=(1,3))\n            qs.filter(weight_range__overlaps=(1,None))\n\n        \"\"\"\n        # This code was written with a single use case in mind. That use case\n        # required searching for objects whose ranges *intersect* with given\n        # one. I did not invest time in supporting other use cases (such as\n        # checking whether the ranges are exactly the same or how they are\n        # different). However, such lookups *can* be added later without\n        # breaking existing client code. Patches are welcome.\n        sublookup = sublookup or RANGE_INTERSECTION_LOOKUP\n        if not sublookup == RANGE_INTERSECTION_LOOKUP:\n            raise ValueError('Range schema only supports lookup \"%s\".' %\n                             RANGE_INTERSECTION_LOOKUP)\n        try:\n            _, _ = value\n        except ValueError:\n            raise ValueError('Range schema value must be a tuple of min and '\n                             'max values; one of them may be None.')\n        except TypeError:\n            raise TypeError('Expected a two-tuple, got \"%s\"' % value)\n\n        value_lookups = zip((\n            'attrs__value_range_max__gte',\n            'attrs__value_range_min__lte',\n        ), value)\n        conditions = dict((k,v) for k,v in value_lookups if v is not None)\n        conditions.update({\n            'attrs__schema': schema,\n        })\n        return conditions"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters given entity queryset by an attribute which is linked to given model.", "response": "def _filter_by_m2m_schema(self, qs, lookup, sublookup, value, schema, model=None):\n        \"\"\"\n        Filters given entity queryset by an attribute which is linked to given\n        many-to-many schema.\n        \"\"\"\n        model = model or self.model\n        schemata = dict((s.name, s) for s in model.get_schemata_for_model())   # TODO cache this dict, see above too\n        try:\n            schema = schemata[lookup]\n        except KeyError:\n            # TODO: smarter error message, i.e. how could this happen and what to do\n            raise ValueError(u'Could not find schema for lookup \"%s\"' % lookup)\n        sublookup = '__%s'%sublookup if sublookup else ''\n        return {\n            'attrs__schema': schema,\n            'attrs__choice%s'%sublookup: value,  # TODO: can we filter by id, not name?\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, **kwargs):\n\n        fields = self.model._meta.get_all_field_names()\n        schemata = dict((s.name, s) for s in self.model.get_schemata_for_model())\n\n        # check if all attributes are known\n        possible_names = set(fields) | set(schemata.keys())\n        wrong_names = set(kwargs.keys()) - possible_names\n        if wrong_names:\n            raise NameError('Cannot create %s: unknown attribute(s) \"%s\". '\n                            'Available fields: (%s). Available schemata: (%s).'\n                            % (self.model._meta.object_name, '\", \"'.join(wrong_names),\n                               ', '.join(fields), ', '.join(schemata)))\n\n        # init entity with fields\n        instance = self.model(**dict((k,v) for k,v in kwargs.items() if k in fields))\n\n        # set attributes; instance will check schemata on save\n        for name, value in kwargs.items():\n            setattr(instance, name, value)\n\n        # save instance and EAV attributes\n        instance.save(force_insert=True)\n\n        return instance", "response": "Creates an entity instance and related Attr instances."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connectSignals(self, node):\n        from projexui.widgets.xnodewidget.xnode import XNode\n\n        # make sure we're connecting to a valid node\n        if not isinstance(node, XNode):\n            return False\n\n        node.dispatch.geometryChanged.connect(self.setDirty)\n        node.dispatch.visibilityChanged.connect(self.setDirty)\n        node.dispatch.removed.connect(self.forceRemove)\n        return True", "response": "Connects the signals of the inputed node to the signals of the inputed node."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate the control points for this path.", "response": "def controlPoints(self):\n        \"\"\"\n        :remarks    Generates the control points for this path\n        \n        :return     <list> [ <tuple> ( <float> x, <float> y), .. ]\n        \"\"\"\n        # define input variables\n        in_point = self.inputPoint()\n        in_rect = self.inputRect()\n\n        in_x = in_point.x()\n        in_y = in_point.y()\n\n        in_cx = in_rect.center().x()\n        in_cy = in_rect.center().y()\n        in_left = in_rect.left()\n        in_right = in_rect.right()\n        in_top = in_rect.top()\n        in_bot = in_rect.bottom()\n        in_loc = self.inputLocation()\n\n        # define output variables\n        out_point = self.outputPoint()\n        out_rect = self.outputRect()\n\n        out_x = out_point.x()\n        out_y = out_point.y()\n\n        out_cx = out_rect.center().x()\n        out_cy = out_rect.center().y()\n        out_left = out_rect.left()\n        out_right = out_rect.right()\n        out_top = out_rect.top()\n        out_bot = out_rect.bottom()\n        out_loc = self.outputLocation()\n\n        # define global variables\n        pad = self.squashThreshold()\n        loc_left = XConnectionLocation.Left\n        loc_right = XConnectionLocation.Right\n        loc_top = XConnectionLocation.Top\n        loc_bot = XConnectionLocation.Bottom\n\n        # calculate deltas\n        delta_x = abs(in_x - out_x)\n        delta_y = abs(in_y - out_y)\n        buffer = 2\n\n        # calculate point scenarios\n\n        # right -> left\n        if (out_loc & loc_right) and (in_loc & loc_left) and out_right < in_left:\n            # no y change, bounding rects don't overlap\n            if delta_y < buffer:\n                return [(out_x, out_y), (in_x, in_y)]\n\n            # y change, padding deltas don't overlap\n            elif out_right + pad < in_left - pad:\n                return [(out_x, out_y),\n                        (out_x + delta_x / 2.0, out_y),\n                        (out_x + delta_x / 2.0, in_y),\n                        (in_x, in_y)]\n\n        # left -> right\n        if (out_loc & loc_left) and (in_loc & loc_right) and in_right < out_left:\n            # no y change, bounding rects don't overlap\n            if delta_y < buffer and in_x < out_x:\n                return [(out_x, out_y), (in_x, in_y)]\n\n            # y change, padding deltas don't overlap\n            elif in_left + pad < out_right - pad:\n                return [(out_x, out_y),\n                        (out_x - delta_x / 2.0, out_y),\n                        (out_x - delta_x / 2.0, in_y),\n                        (in_x, in_y)]\n\n        # bottom -> top\n        if (out_loc & loc_bot) and (in_loc & loc_top) and out_bot < in_top:\n            # no x change, bounding rects don't overlap\n            if delta_x < buffer and out_y < in_y:\n                return [(out_x, out_y), (in_x, in_y)]\n\n            # x change, pading delta's don't overlap\n            elif out_bot + pad < in_top - pad:\n                return [(out_x, out_y),\n                        (out_x, out_y + delta_y / 2.0),\n                        (in_x, out_y + delta_y / 2.0),\n                        (in_x, in_y)]\n\n        # top -> bottom\n        if (out_loc & loc_top) and (in_loc & loc_bot) and in_bot < out_top:\n            # no x change, bounding rects don't overlap\n            if delta_x < buffer and in_y < out_y:\n                return [(out_x, out_y), (in_x, in_y)]\n\n            # y change, padding deltas don't overlap\n            elif in_bot + pad < out_top - pad:\n                return [(out_x, out_y),\n                        (out_x, out_y - delta_y / 2.0),\n                        (in_x, out_y - delta_y / 2.0),\n                        (in_x, in_y)]\n\n        # bottom -> left\n        if (out_loc & loc_bot) and (in_loc & loc_left):\n            if out_y + pad < in_y and out_x + pad < in_x:\n                return [(out_x, out_y),\n                        (out_x, in_y),\n                        (in_x, in_y)]\n\n        # bottom -> right\n        if (out_loc & loc_bot) and (in_loc & loc_right):\n            if out_y + pad < in_y and out_x - pad > in_x:\n                return [(out_x, out_y),\n                        (out_x, in_y),\n                        (in_x, in_y)]\n\n        # top -> left\n        if (out_loc & loc_top) and (in_loc & loc_left):\n            if in_y + pad < out_y and out_x + pad < in_x:\n                return [(out_x, out_y),\n                        (out_x, in_y),\n                        (in_x, in_y)]\n\n        # top -> right\n        if (out_loc & loc_top) and (in_loc & loc_right):\n            if in_y + pad < out_y and out_x - pad > in_x:\n                return [(out_x, out_y),\n                        (out_x, in_y),\n                        (in_x, in_y)]\n\n        # right -> top\n        if (out_loc & loc_right) and (in_loc & loc_top):\n            if out_x + pad < in_x and out_y - pad < in_y:\n                return [(out_x, out_y),\n                        (in_x, out_y),\n                        (in_x, in_y)]\n\n        # right -> bottom\n        if (out_loc & loc_right) and (in_loc & loc_bot):\n            if out_x + pad < in_x and out_y + pad > in_y:\n                return [(out_x, out_y),\n                        (in_x, out_y),\n                        (in_x, in_y)]\n\n        # left -> top\n        if (out_loc & loc_left) and (in_loc & loc_top):\n            if in_x + pad < out_x and out_y - pad < in_y:\n                return [(out_x, out_y),\n                        (in_x, out_y),\n                        (in_x, in_y)]\n\n        # left -> bottom\n        if (out_loc & loc_left) and (in_loc & loc_bot):\n            if in_x + pad < out_x and out_y + pad > in_y:\n                return [(out_x, out_y),\n                        (in_x, out_y),\n                        (in_x, in_y)]\n\n        # right -> right\n        if (out_loc & loc_right) and (in_loc & loc_right):\n            max_x = max(out_right + 2 * pad, in_right + 2 * pad)\n            if out_cx <= in_cx or not (out_loc & loc_left and in_loc & loc_left):\n                return [(out_x, out_y),\n                        (max_x, out_y),\n                        (max_x, in_y),\n                        (in_x, in_y)]\n\n        # left -> left\n        if (out_loc & loc_left) and (in_loc & loc_left):\n            min_x = min(out_left - 2 * pad, in_left - 2 * pad)\n            return [(out_x, out_y),\n                    (min_x, out_y),\n                    (min_x, in_y),\n                    (in_x, in_y)]\n\n        # top -> top\n        if (out_loc & loc_top) and (in_loc & loc_top):\n            if out_cy <= in_cy or not (out_loc & loc_bot and in_loc & loc_bot):\n                min_y = min(out_top - 2 * pad, in_top - 2 * pad)\n                return [(out_x, out_y),\n                        (out_x, min_y),\n                        (in_x, min_y),\n                        (in_x, in_y)]\n\n        # bottom -> bottom\n        if (out_loc & loc_bot) and (in_loc & loc_bot):\n            max_y = max(out_y + 2 * pad, out_y + 2 * pad)\n            return [(out_x, out_y),\n                    (out_x, max_y),\n                    (in_x, max_y),\n                    (in_x, in_y)]\n\n        # right -> left with center squash\n        if (out_loc & loc_right) and (in_loc & loc_left):\n            if out_bot < in_top:\n                mid_y = out_bot + (in_top - out_bot) / 2.0\n            elif in_bot < out_top:\n                mid_y = in_bot + (out_top - in_bot) / 2.0\n            else:\n                mid_y = None\n\n            if mid_y:\n                return [(out_x, out_y),\n                        (out_x + 2 * pad, out_y),\n                        (out_x + 2 * pad, mid_y),\n                        (in_x - 2 * pad, mid_y),\n                        (in_x - 2 * pad, in_y),\n                        (in_x, in_y)]\n\n        # left -> right with center squash\n        if (out_loc & loc_left) and (in_loc & loc_right):\n            if out_bot < in_top:\n                mid_y = in_top + (in_top - out_bot) / 2.0\n            elif in_bot < out_top:\n                mid_y = out_top - (out_top - in_bot) / 2.0\n            else:\n                mid_y = None\n\n            if mid_y:\n                return [(out_x, out_y),\n                        (out_x - 2 * pad, out_y),\n                        (out_x - 2 * pad, mid_y),\n                        (in_x + 2 * pad, mid_y),\n                        (in_x + 2 * pad, in_y),\n                        (in_x, in_y)]\n\n        # bottom -> top with center squash\n        if (out_loc & loc_bot) and (in_loc & loc_top):\n            if out_right < in_left:\n                mid_x = out_right + (in_left - out_right) / 2.0\n            elif in_right < out_left:\n                mid_x = in_right + (out_left - in_right) / 2.0\n            else:\n                mid_x = None\n\n            if mid_x:\n                return [(out_x, out_y),\n                        (out_x, out_y + 2 * pad),\n                        (mid_x, out_y + 2 * pad),\n                        (mid_x, in_y - 2 * pad),\n                        (in_x, in_y - 2 * pad),\n                        (in_x, in_y)]\n\n        # top -> bottom with center squash\n        if (out_loc & loc_top) and (in_loc & loc_bot):\n            if out_right < in_left:\n                mid_x = in_left + (in_left - out_right) / 2.0\n            elif in_right < out_left:\n                mid_x = out_left - (out_left - in_right) / 2.0\n            else:\n                mid_x = None\n\n            if mid_x:\n                return [(out_x, out_y),\n                        (out_x, out_y - 2 * pad),\n                        (mid_x, out_y - 2 * pad),\n                        (mid_x, in_y + 2 * pad),\n                        (in_x, in_y + 2 * pad),\n                        (in_x, in_y)]\n\n        # right -> left with looping\n        if (out_loc & loc_right) and (in_loc & loc_left):\n            max_y = max(out_bot + 2 * pad, in_bot + 2 * pad)\n            return [(out_x, out_y),\n                    (out_x + 2 * pad, out_y),\n                    (out_x + 2 * pad, max_y),\n                    (in_x - 2 * pad, max_y),\n                    (in_x - 2 * pad, in_y),\n                    (in_x, in_y)]\n\n        # left -> right with looping\n        if (out_loc & loc_left) and (in_loc & loc_right):\n            max_y = max(out_bot + 2 * pad, in_bot + 2 * pad)\n            return [(out_x, out_y),\n                    (out_x - 2 * pad, out_y),\n                    (out_x - 2 * pad, max_y),\n                    (in_x + 2 * pad, max_y),\n                    (in_x + 2 * pad, in_y),\n                    (in_x, in_y)]\n\n        # bottom -> top with looping\n        if (out_loc & loc_bot) and (in_loc & loc_top):\n            max_x = max(out_right + 2 * pad, in_right + 2 * pad)\n            return [(out_x, out_y),\n                    (out_x, out_y + 2 * pad),\n                    (max_x, out_y + 2 * pad),\n                    (max_x, in_y - 2 * pad),\n                    (in_x, in_y - 2 * pad),\n                    (in_x, in_y)]\n\n        # top -> bottom with looping\n        if (out_loc & loc_top) and (in_loc & loc_bot):\n            max_x = max(out_right + 2 * pad, in_right + 2 * pad)\n            return [(out_x, out_y),\n                    (out_x, out_y - 2 * pad),\n                    (max_x, out_y - 2 * pad),\n                    (max_x, in_y + 2 * pad),\n                    (in_x, in_y + 2 * pad),\n                    (in_x, in_y)]\n\n        # right -> right with looping\n        if (out_loc & loc_right) and (in_loc & loc_right):\n            max_y = max(out_bot + 2 * pad, in_bot + 2 * pad)\n            mid_x = out_left - abs(out_left - in_right) / 2.0\n            return [(out_x, out_y),\n                    (out_x + 2 * pad, out_y),\n                    (out_x + 2 * pad, max_y),\n                    (mid_x, max_y),\n                    (mid_x, in_y),\n                    (in_x, in_y)]\n\n        # left -> left with looping\n        if (out_loc & loc_left) and (in_loc & loc_left):\n            max_y = max(out_bot + 2 * pad, in_bot + 2 * pad)\n            mid_x = in_left - abs(in_left - out_right) / 2.0\n            return [(out_x, out_y),\n                    (out_x - 2 * pad, out_y),\n                    (out_x - 2 * pad, max_y),\n                    (mid_x, max_y),\n                    (mid_x, in_y),\n                    (in_x, in_y)]\n\n        # unknown, return a direct route\n        return [(out_x, out_y), (in_x, in_y)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef disconnectSignals(self, node):\n        from projexui.widgets.xnodewidget.xnode import XNode\n\n        # make sure we're disconnecting from a valid node\n        if not isinstance(node, XNode):\n            return False\n\n        node.dispatch.geometryChanged.disconnect(self.setDirty)\n        node.dispatch.removed.disconnect(self.forceRemove)\n        return True", "response": "Disconnects from signals of the inputed node."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the bounding rectangle for the input node associated with this ArcGIS connection.", "response": "def inputRect(self):\n        \"\"\"\n        Returns the bounding rectangle for the input node associated with this\n        connection.  If only a point is provided, then a 0 width rect will be\n        used.\n        \n        :return     <QRectF>\n        \"\"\"\n        try:\n            return self._inputNode.sceneRect()\n        except AttributeError:\n            point = self.inputPoint()\n            return QRectF(point.x(), point.y(), 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inputPoint(self):\n        node = self.inputNode()\n\n        # return the set point\n        if not node:\n            return self._inputPoint\n\n        # test for the hotspot\n        hotspot = self.inputHotspot()\n\n        # otherwise, calculate the point based on location and fixed info\n        ilocation = self.inputLocation()\n        ifixedx = self.inputFixedX()\n        ifixedy = self.inputFixedY()\n\n        loc_left = XNodeConnection.Location.Left\n        loc_right = XNodeConnection.Location.Right\n        loc_top = XNodeConnection.Location.Top\n        loc_bot = XNodeConnection.Location.Bottom\n\n        irect = self.inputRect()\n        orect = self.outputRect()\n\n        # return the left location\n        if ilocation & loc_left and orect.right() < irect.left():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().left(),\n                                               hotspot.rect().center().y()))\n            else:\n                return node.positionAt(loc_left, ifixedx, ifixedy)\n\n        # return the right location\n        elif ilocation & loc_right and irect.left() < orect.right():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().right(),\n                                               hotspot.rect().center().y()))\n            else:\n                return node.positionAt(loc_right, ifixedx, ifixedy)\n\n        # return the top location\n        elif ilocation & loc_top and orect.bottom() < irect.top():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().center().x(),\n                                               hotspot.rect().top()))\n            else:\n                return node.positionAt(loc_top, ifixedx, ifixedy)\n\n        # return the bottom location\n        elif ilocation & loc_bot and irect.bottom() < orect.top():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().center().x(),\n                                               hotspot.rect().bottom()))\n            else:\n                return node.positionAt(loc_bot, ifixedx, ifixedy)\n\n        # return the center location\n        else:\n            if hotspot:\n                return node.mapToScene(hotspot.rect().center())\n            else:\n                return node.positionAt(ilocation, ifixedx, ifixedy)", "response": "Returns the input point for the current connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks to see if the output and input locations match the settings \\ apikey.", "response": "def isDirection(self, outputLocation, inputLocation):\n        \"\"\"\n        Checks to see if the output and input locations match the settings \\\n        for this item.\n        \n        :param      outputLocation      | <XConnectionLocation>\n        :param      inputLocation       | <XConnectionLocation>\n        \n        :return     <bool>\n        \"\"\"\n        return (self.isOutputLocation(outputLocation) and\n                self.isInputLocation(inputLocation))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isEnabled(self):\n        if self._disableWithLayer and self._layer:\n            lenabled = self._layer.isEnabled()\n        elif self._inputNode and self._outputNode:\n            lenabled = self._inputNode.isEnabled() and self._outputNode.isEnabled()\n        else:\n            lenabled = True\n\n        return self._enabled and lenabled", "response": "Returns whether or not this connection is enabled."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef isVisible(self):\n        in_node = self.inputNode()\n        out_node = self.outputNode()\n\n        if in_node and not in_node.isVisible():\n            return False\n\n        if out_node and not out_node.isVisible():\n            return False\n\n        return self._visible", "response": "Returns whether or not this connection is visible."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mappedPolygon(self, polygon, path=None, percent=0.5):\n        translatePerc = percent\n        anglePerc = percent\n\n        # we don't want to allow the angle percentage greater than 0.85\n        # or less than 0.05 or we won't get a good rotation angle\n        if 0.95 <= anglePerc:\n            anglePerc = 0.98\n        elif anglePerc <= 0.05:\n            anglePerc = 0.05\n\n        if not path:\n            path = self.path()\n        if not (path and path.length()):\n            return QPolygonF()\n\n        # transform the polygon to the path\n        point = path.pointAtPercent(translatePerc)\n        angle = path.angleAtPercent(anglePerc)\n\n        # rotate about the 0 axis\n        transform = QTransform().rotate(-angle)\n        polygon = transform.map(polygon)\n\n        # move to the translation point\n        transform = QTransform().translate(point.x(), point.y())\n\n        # create the rotated polygon\n        mapped_poly = transform.map(polygon)\n        self._polygons.append(mapped_poly)\n\n        return mapped_poly", "response": "Maps the inputed polygon to the inputed path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mousePressEvent(self, event):\n        # ignore events when the scene is in view mode\n        scene = self.scene()\n        if scene and scene.inViewMode():\n            event.ignore()\n            return\n\n        # block the selection signals\n        if scene:\n            scene.blockSelectionSignals(True)\n\n            # clear the selection\n            if ( not (self.isSelected() or\n                              event.modifiers() == Qt.ControlModifier) ):\n                for item in scene.selectedItems():\n                    if item != self:\n                        item.setSelected(False)\n\n        # try to start the connection\n        super(XNodeConnection, self).mousePressEvent(event)", "response": "Handles the mouse press event for this node and returns the related class name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\noverloading the mouse move event to ignore the event when the scene is in view mode.", "response": "def mouseMoveEvent(self, event):\n        \"\"\"\n        Overloads the mouse move event to ignore the event when \\\n        the scene is in view mode.\n        \n        :param      event   <QMouseMoveEvent>\n        \"\"\"\n        # ignore events when the scene is in view mode\n        scene = self.scene()\n        if scene and (scene.inViewMode() or scene.isConnecting()):\n            event.ignore()\n            return\n\n        # call the base method\n        super(XNodeConnection, self).mouseMoveEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mouseReleaseEvent(self, event):\n        # ignore events when the scene is in view mode\n        scene = self.scene()\n        if scene and (scene.inViewMode() or scene.isConnecting()):\n            event.ignore()\n            return\n\n        # emit the scene's connection menu requested signal if\n        # the button was a right mouse button\n        if event.button() == Qt.RightButton and scene:\n            scene.emitConnectionMenuRequested(self)\n            event.accept()\n        else:\n            super(XNodeConnection, self).mouseReleaseEvent(event)\n\n        # unblock the selection signals\n        if scene:\n            scene.blockSelectionSignals(False)", "response": "Overloads the mouse release event to ignore the event when the scene is in view mode and release the selection block signal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the opacity amount for this connection.", "response": "def opacity(self):\n        \"\"\"\n        Returns the opacity amount for this connection.\n        \n        :return     <float>\n        \"\"\"\n        in_node = self.inputNode()\n        out_node = self.outputNode()\n\n        if ( in_node and out_node and \\\n                     (in_node.isIsolateHidden() or out_node.isIsolateHidden()) ):\n            return 0.1\n\n        opacity = super(XNodeConnection, self).opacity()\n        layer = self.layer()\n        if layer:\n            return layer.opacity() * opacity\n\n        return opacity"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef outputPoint(self):\n        node = self.outputNode()\n\n        # return the set point\n        if not node:\n            return self._outputPoint\n\n        # test for the hotspot\n        hotspot = self.outputHotspot()\n\n        # otherwise, calculate the point based on location and fixed positions\n        olocation = self.outputLocation()\n        ofixedx = self.outputFixedX()\n        ofixedy = self.outputFixedY()\n\n        loc_left = XNodeConnection.Location.Left\n        loc_right = XNodeConnection.Location.Right\n        loc_top = XNodeConnection.Location.Top\n        loc_bot = XNodeConnection.Location.Bottom\n\n        irect = self.inputRect()\n        orect = self.outputRect()\n\n        # return the right location\n        if olocation & loc_right and orect.right() < irect.left():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().right(),\n                                               hotspot.rect().center().y()))\n            else:\n                return node.positionAt(loc_right, ofixedx, ofixedy)\n\n        # return the left location\n        elif olocation & loc_left and irect.right() < orect.left():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().left(),\n                                               hotspot.rect().center().y()))\n            else:\n                return node.positionAt(loc_left, ofixedx, ofixedy)\n\n        # return the bottom location\n        elif olocation & loc_bot and orect.bottom() < irect.top():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().center().x(),\n                                               hotspot.rect().bottom()))\n            else:\n                return node.positionAt(loc_bot, ofixedx, ofixedy)\n\n        # return the top location\n        elif olocation & loc_top and irect.bottom() < orect.top():\n            if hotspot:\n                return node.mapToScene(QPointF(hotspot.rect().center().x(),\n                                               hotspot.rect().top()))\n            else:\n                return node.positionAt(loc_top, ofixedx, ofixedy)\n\n        # return the center point\n        else:\n            if hotspot:\n                return node.mapToScene(hotspot.rect().center())\n            else:\n                return node.positionAt(olocation, ofixedx, ofixedy)", "response": "Returns the scene space point that the connection will draw to as its output source."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the bounding rectangle for the output node associated with this ArcGIS connection.", "response": "def outputRect(self):\n        \"\"\"\n        Returns the bounding rectangle for the output node associated with this\n        connection.  If only a point is provided, then a 0 width rect will be\n        used.\n        \n        :return     <QRectF>\n        \"\"\"\n        try:\n            return self._outputNode.sceneRect()\n        except AttributeError:\n            point = self.outputPoint()\n            return QRectF(point.x(), point.y(), 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverload the paint method from QGraphicsPathItem to \\ handle custom drawing of the path using this items \\ pens and polygons. :param painter <QPainter> :param option <QGraphicsItemStyleOption> :param widget <QWidget>", "response": "def paint(self, painter, option, widget):\n        \"\"\"\n        Overloads the paint method from QGraphicsPathItem to \\\n        handle custom drawing of the path using this items \\\n        pens and polygons.\n        \n        :param      painter     <QPainter>\n        :param      option      <QGraphicsItemStyleOption>\n        :param      widget      <QWidget>\n        \"\"\"\n        # following the arguments required by Qt\n        # pylint: disable-msg=W0613\n\n        painter.setOpacity(self.opacity())\n\n        # show the connection selected\n        if not self.isEnabled():\n            pen = QPen(self.disabledPen())\n        elif self.isSelected():\n            pen = QPen(self.highlightPen())\n        else:\n            pen = QPen(self.pen())\n\n        if self._textItem:\n            self._textItem.setOpacity(self.opacity())\n            self._textItem.setDefaultTextColor(pen.color().darker(110))\n\n        # rebuild first if necessary\n        if self.isDirty():\n            self.setPath(self.rebuild())\n\n        # store the initial hint\n        hint = painter.renderHints()\n        painter.setRenderHint(painter.Antialiasing)\n\n        pen.setWidthF(1.25)\n        painter.setPen(pen)\n        painter.drawPath(self.path())\n\n        # redraw the polys to force-fill them\n        for poly in self._polygons:\n            if not poly.isClosed():\n                continue\n\n            painter.setBrush(pen.color())\n            painter.drawPolygon(poly)\n\n        # restore the render hints\n        painter.setRenderHints(hint)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprepare any code that needs to run to cleanup the connection before it gets removed from the scene.", "response": "def prepareToRemove(self):\n        \"\"\"\n        Handles any code that needs to run to cleanup the connection \\\n        before it gets removed from the scene.\n        \n        :return     <bool> success\n        \"\"\"\n        # disconnect the signals from the input and output nodes\n        for node in (self._outputNode, self._inputNode):\n            self.disconnectSignals(node)\n\n        # clear the pointers to the nodes\n        self._inputNode = None\n        self._outputNode = None\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrebuilds the path for this connection based on the given connection \\ AttributeNames style parameters that have been set.", "response": "def rebuild(self):\n        \"\"\"\n        Rebuilds the path for this connection based on the given connection \\\n        style parameters that have been set.\n        \n        :return     <QPainterPath>\n        \"\"\"\n        # create the path\n        path = self.rebuildPath()\n        self._polygons = self.rebuildPolygons(path)\n\n        if self._textItem:\n            point = path.pointAtPercent(0.5)\n            metrics = QFontMetrics(self._textItem.font())\n\n            point.setY(point.y() - metrics.height() / 2.0)\n\n            self._textItem.setPos(point)\n\n        # create the path for the item\n        for poly in self._polygons:\n            path.addPolygon(poly)\n\n        # unmark as dirty\n        self.setDirty(False)\n\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rebuildPath(self):\n        # rebuild linear style\n        if self.isStyle(XConnectionStyle.Linear):\n            return self.rebuildLinear()\n\n        # rebuild block style\n        elif self.isStyle(XConnectionStyle.Block):\n            return self.rebuildBlock()\n\n        # rebuild smooth style\n        elif self.isStyle(XConnectionStyle.Smooth):\n            return self.rebuildSmooth()\n\n        # otherwise, we have an invalid style, or a style\n        # defined by a subclass\n        else:\n            return QPainterPath()", "response": "Rebuilds the path for the given style options based on the currently \\\n        set parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rebuildPolygons(self, path):\n        output = []\n\n        # create the input arrow\n        if self.showInputArrow():\n            if self.inputArrowStyle() & self.ArrowStyle.Inverted:\n                a = QPointF(0, -4)\n                b = QPointF(-10, 0)\n                c = QPointF(0, 4)\n            else:\n                a = QPointF(-10, -4)\n                b = QPointF(0, 0)\n                c = QPointF(-10, 4)\n\n            if self.inputArrowStyle() & self.ArrowStyle.Filled:\n                poly = QPolygonF([a, b, c, a])\n            else:\n                poly = QPolygonF([a, b, c])\n\n            mpoly = self.mappedPolygon(poly, path, 1.0)\n            output.append(mpoly)\n\n        # create the direction arrow\n        if self.showDirectionArrow():\n            a = QPointF(-5, -4)\n            b = QPointF(5, 0)\n            c = QPointF(-5, 4)\n\n            mpoly = self.mappedPolygon(QPolygonF([a, b, c, a]), path, 0.5)\n            output.append(mpoly)\n\n        # create the output arrow\n        if self.showOutputArrow():\n            if self.outputArrowStyle() & self.ArrowStyle.Inverted:\n                a = QPointF(0, -4)\n                b = QPointF(10, 0)\n                c = QPointF(0, 4)\n            else:\n                a = QPointF(10, -4)\n                b = QPointF(0, 0)\n                c = QPointF(10, 4)\n\n            if self.outputArrowStyle() & self.ArrowStyle.Filled:\n                poly = QPolygonF([a, b, c, a])\n            else:\n                poly = QPolygonF([a, b, c])\n\n            mpoly = self.mappedPolygon(poly, path, 0)\n            output.append(mpoly)\n\n        return output", "response": "Rebuilds the polygons that will be used on this path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrebuilding a linear path from the output to input points.", "response": "def rebuildLinear(self):\n        \"\"\" \n        Rebuilds a linear path from the output to input points.\n        \n        :return     <QPainterPath>\n        \"\"\"\n\n        points = self.controlPoints()\n\n        # create a simple line between the output and input points\n        path = QPainterPath()\n        path.moveTo(*points[0])\n        path.lineTo(*points[-1])\n\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rebuildBlock(self):\n        # collect the control points\n        points = self.controlPoints()\n\n        curve = 12\n\n        path = QPainterPath()\n        if len(points) == 2:\n            path.moveTo(*points[0])\n            path.lineTo(*points[1])\n        else:\n            for i in range(len(points) - 2):\n                a = points[i]\n                b = points[i + 1]\n                c = points[i + 2]\n\n                delta_ab_x = b[0] - a[0]\n                delta_ab_y = b[1] - a[1]\n\n                delta_bc_x = b[0] - c[0]\n                delta_bc_y = b[1] - c[1]\n\n                # calculate ctrl_ab\n                if delta_ab_y == 0:\n                    mult = delta_ab_x / max(abs(delta_ab_x), 1)\n                    off_x = min(curve, abs(delta_ab_x * 0.5))\n                    ctrl_ab = (b[0] - (off_x * mult), b[1])\n                else:\n                    mult = delta_ab_y / max(abs(delta_ab_y), 1)\n                    off_y = min(curve, abs(delta_ab_y * 0.5))\n                    ctrl_ab = (b[0], b[1] - (off_y * mult))\n\n                # calculate ctrl_bc\n                if delta_bc_y == 0:\n                    mult = delta_bc_x / max(abs(delta_bc_x), 1)\n                    off_x = min(curve, abs(delta_bc_x * 0.5))\n                    ctrl_bc = (b[0] - (off_x * mult), b[1])\n                else:\n                    mult = delta_bc_y / max(abs(delta_bc_y), 1)\n                    off_y = min(curve, abs(delta_bc_y * 0.5))\n                    ctrl_bc = (b[0], b[1] - (off_y * mult))\n\n                if not i:\n                    path.moveTo(*a)\n\n                path.lineTo(*ctrl_ab)\n                path.quadTo(*(list(b) + list(ctrl_bc)))\n\n            path.lineTo(*points[-1])\n\n        return path", "response": "Rebuilds a blocked path from the output to input points."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rebuildSmooth(self):\n        # collect the control points\n        points = self.controlPoints()\n\n        # create the path\n        path = QPainterPath()\n\n        if len(points) == 3:\n            x0, y0 = points[0]\n            x1, y1 = points[1]\n            xN, yN = points[2]\n\n            path.moveTo(x0, y0)\n            path.quadTo(x1, y1, xN, yN)\n\n        elif len(points) == 4:\n            x0, y0 = points[0]\n            x1, y1 = points[1]\n            x2, y2 = points[2]\n            xN, yN = points[3]\n\n            path.moveTo(x0, y0)\n            path.cubicTo(x1, y1, x2, y2, xN, yN)\n\n        elif len(points) == 6:\n            x0, y0 = points[0]\n            x1, y1 = points[1]\n            x2, y2 = points[2]\n            x3, y3 = points[3]\n            x4, y4 = points[4]\n            xN, yN = points[5]\n\n            xC = (x2 + x3) / 2.0\n            yC = (y2 + y3) / 2.0\n\n            path.moveTo(x0, y0)\n            path.cubicTo(x1, y1, x2, y2, xC, yC)\n            path.cubicTo(x3, y3, x4, y4, xN, yN)\n\n        else:\n            x0, y0 = points[0]\n            xN, yN = points[-1]\n\n            path.moveTo(x0, y0)\n            path.lineTo(xN, yN)\n\n        return path", "response": "Rebuilds a smooth path based on the inputed points and set \\\nAttributeNames to the item s control points and returns the path object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setDirection(self, outputLocation, inputLocation):\n        self.setOutputLocation(outputLocation)\n        self.setInputLocation(inputLocation)", "response": "Sets the output - to - input direction by setting both the locations \\\n         outputLocation and \\\nAttrs inputLocation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setDirty(self, state=True):\n        self._dirty = state\n\n        # set if this connection should be visible\n        if self._inputNode and self._outputNode:\n            vis = self._inputNode.isVisible() and self._outputNode.isVisible()\n            self.setVisible(vis)", "response": "Sets the dirty flag for this connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setInputNode(self, node):\n        # if the node already matches the current input node, ignore\n        if self._inputNode == node:\n            return\n\n        # disconnect from the existing node\n        self.disconnectSignals(self._inputNode)\n\n        # store the node\n        self._inputNode = node\n\n        # connect to the new node\n        self.connectSignals(self._inputNode)\n\n        # force the rebuilding of the path\n        self.setPath(self.rebuild())", "response": "Sets the node that will be recieving this connection as an input."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setInputPoint(self, point):\n        self._inputPoint = point\n        self.setPath(self.rebuild())", "response": "Sets the scene level input point position to draw the connection to."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the layer that this node is associated with to the given layer.", "response": "def setLayer(self, layer):\n        \"\"\"\n        Sets the layer that this node is associated with to the given layer.\n        \n        :param      layer       | <XNodeLayer> || None\n        \n        :return     <bool> changed\n        \"\"\"\n        if layer == self._layer:\n            return False\n\n        self._layer = layer\n        self.syncLayerData()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setOutputNode(self, node):\n        # if the output node matches the current, ignore\n        if node == self._outputNode:\n            return\n\n        # disconnect from an existing node\n        self.disconnectSignals(self._outputNode)\n\n        # set the current node\n        self._outputNode = node\n        self.connectSignals(self._outputNode)\n\n        # force the rebuilding of the path\n        self.setPath(self.rebuild())", "response": "Sets the node that will be generated the output information for this connection."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setOutputPoint(self, point):\n        self._outputPoint = point\n        self.setPath(self.rebuild())", "response": "Sets the scene space point for where this connection should draw its output from."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the style of the connection that will be used.", "response": "def setStyle(self, style):\n        \"\"\"\n        :remarks    Sets the style of the connection that will be used.\n        \n        :param      style       <XConnectionStyle>\n        \"\"\"\n        self._style = style\n        self.setDirty()\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setVisible(self, state):\n        self._visible = state\n\n        super(XNodeConnection, self).setVisible(self.isVisible())", "response": "Sets whether or not this connection s local visibility should be on."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the z value for this connection.", "response": "def setZValue(self, value):\n        \"\"\"\n        Sets the z value for this connection, also updating the text item to \n        match the value if one is defined.\n        \n        :param      value | <int>\n        \"\"\"\n        super(XNodeConnection, self).setZValue(value)\n\n        if self._textItem:\n            self._textItem.setZValue(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setText(self, text):\n        self._text = text\n\n        if text:\n            if self._textItem is None:\n                self._textItem = QGraphicsTextItem()\n                self._textItem.setParentItem(self)\n\n            self._textItem.setPlainText(text)\n\n        elif self._textItem:\n            self.scene().removeItem(self._textItem)\n            self._textItem = None", "response": "Sets the text for this connection to the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nblocking the signals for this widget and its sub - parts.", "response": "def blockSignals( self, state ):\r\n        \"\"\"\r\n        Blocks the signals for this widget and its sub-parts.\r\n        \r\n        :param      state | <bool>\r\n        \"\"\"\r\n        super(XUrlWidget, self).blockSignals(state)\r\n        self._urlEdit.blockSignals(state)\r\n        self._urlButton.blockSignals(state)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef removeProfile( self ):\n        manager  = self.parent()\n        prof     = manager.currentProfile()\n        opts     = QMessageBox.Yes | QMessageBox.No\n        question = 'Are you sure you want to remove \"%s\"?' % prof.name()\n        answer   = QMessageBox.question( self, 'Remove Profile', question, opts)\n        \n        if ( answer == QMessageBox.Yes ):\n            manager.removeProfile(prof)", "response": "Removes the current profile from the system."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef saveProfile( self ):\n        manager = self.parent()\n        prof    = manager.currentProfile()\n        \n        # save the current profile\n        save_prof = manager.viewWidget().saveProfile()\n        prof.setXmlElement(save_prof.xmlElement())", "response": "Saves the current profile to the current settings from the view widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the current profile as a new profile to the manager.", "response": "def saveProfileAs( self ):\n        \"\"\"\n        Saves the current profile as a new profile to the manager.\n        \"\"\"\n        name, ok = QInputDialog.getText(self, 'Create Profile', 'Name:')\n        if ( not name ):\n            return\n        \n        manager = self.parent()\n        prof    = manager.viewWidget().saveProfile()\n        prof.setName(nativestring(name))\n        self.parent().addProfile(prof)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hexdump_iter(logger, fd, width=16, skip=True, hexii=False, begin=0, highlight=None):\n    style     = logger.style.hexdump.copy()\n    highlight = highlight or []\n\n    for b in highlight:\n        if isinstance(b, str):\n            b = ord(b)\n        style['%02x' % b] = style['highlight']\n\n    _style = style\n\n    skipping    = False\n    lines       = []\n    last_unique = ''\n    byte_width  = len('00 ')\n    column_sep  = '  '\n    line_fmt    = '%%(offset)08x  %%(hexbytes)-%is \u2502%%(printable)s\u2502' % (len(column_sep)+(width*byte_width))\n    spacer      = ' '\n    marker      = (style.get('marker') or (lambda s:s))('\u2502')\n\n    if hexii:\n        column_sep = ''\n        line_fmt   = '%%(offset)08x  %%(hexbytes)-%is\u2502' % (len(column_sep)+(width*byte_width))\n    else:\n        def style_byte(b):\n            hbyte = '%02x' % ord(b)\n            abyte = b if isprint(b) else '\u00b7'\n            if hbyte in style:\n                st = style[hbyte]\n            elif isprint(b):\n                st = style.get('printable')\n            else:\n                st = style.get('nonprintable')\n            if st:\n                hbyte = st(hbyte)\n                abyte = st(abyte)\n            return hbyte, abyte\n        cache = [style_byte(chr(b)) for b in range(256)]\n\n    numb = 0\n    while True:\n        offset = begin + numb\n\n        # If a tube is passed in as fd, it will raise EOFError when it runs\n        # out of data, unlike a file or StringIO object, which return an empty\n        # string.\n        try:\n            chunk = fd.read(width)\n        except EOFError:\n            chunk = ''\n\n        # We have run out of data, exit the loop\n        if chunk == '':\n            break\n\n        # Advance the cursor by the number of bytes we actually read\n        numb += len(chunk)\n\n        # If this chunk is the same as the last unique chunk,\n        # use a '*' instead.\n        if skip and last_unique:\n            same_as_last_line = (last_unique == chunk)\n            lines_are_sequential = False\n            last_unique = chunk\n\n            if same_as_last_line or lines_are_sequential:\n\n                # If we have not already printed a \"*\", do so\n                if not skipping:\n                    yield '*'\n                    skipping = True\n\n                # Move on to the next chunk\n                continue\n\n        # Chunk is unique, no longer skipping\n        skipping = False\n        last_unique = chunk\n\n        # Generate contents for line\n        hexbytes = ''\n        printable = ''\n        for i, b in enumerate(chunk):\n            if not hexii:\n                hbyte, abyte = cache[ord(b)]\n            else:\n                hbyte, abyte = _hexiichar(b), ''\n\n            if i % 4 == 3 and i < width - 1:\n                hbyte += spacer\n                abyte += marker\n\n            hexbytes += hbyte + ' '\n            printable += abyte\n\n        if i + 1 < width:\n            delta = width - i - 1\n\n            # How many hex-bytes would we have printed?\n            count = byte_width * delta\n\n            # How many dividers do we need to fill out the line?\n            dividers_per_line = (width // 4) - (1 if width % 4 == 0 else 0)\n            dividers_printed = (i // 4) + (1 if i % 4 == 3 else 0)\n            count += dividers_per_line - dividers_printed\n\n            hexbytes += ' ' * count\n\n        # Python2 -> 3 wew\n        if isinstance(line_fmt, six.binary_type):\n            line_fmt = line_fmt.decode('utf-8')\n        if isinstance(offset, six.binary_type):\n            offset = printable.decode('utf-8')\n        \n        line = line_fmt % {'offset': offset, 'hexbytes': hexbytes, 'printable': printable}\n        yield line\n\n    line = \"%08x\" % (begin + numb)\n    yield line", "response": "r Returns a generator of lines of a string in a hexdump - dump format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef adjustText(self):\n        pos = self.cursorPosition()\r\n        self.blockSignals(True)\r\n        super(XLineEdit, self).setText(self.formatText(self.text()))\r\n        self.setCursorPosition(pos)\r\n        self.blockSignals(False)", "response": "Adjusts the text based on the current format options."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addButton(self, button, alignment=None):\n        if alignment == None:\r\n            if button.pos().x() < self.pos().x():\r\n                alignment = Qt.AlignLeft\r\n            else:\r\n                alignment = Qt.AlignRight\r\n        \n        all_buttons = self.buttons()\n        if button in all_buttons:\n            return False\n        \n        # move the button to this edit\r\n        button.setParent(self)\n        button.setAutoRaise(True)\n        button.setIconSize(self.iconSize())\n        button.setCursor(Qt.ArrowCursor)\r\n        button.setFixedSize(QSize(self.height() - 2, self.height() - 2))\n        \n        self._buttons.setdefault(alignment, [])\n        self._buttons[alignment].append(button)\n        self.adjustButtons()\n        return True", "response": "Adds a button to the edit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef adjustButtons( self ):\n        y = 1\n        \r\n        for btn in self.buttons():\r\n            btn.setIconSize(self.iconSize())\r\n            btn.setFixedSize(QSize(self.height() - 2, self.height() - 2))\r\n        \n        # adjust the location for the left buttons\n        left_buttons = self._buttons.get(Qt.AlignLeft, [])\n        x = (self.cornerRadius() / 2.0) + 2\n        \n        for btn in left_buttons:\n            btn.move(x, y)\n            x += btn.width()\n        \n        # adjust the location for the right buttons\n        right_buttons = self._buttons.get(Qt.AlignRight, [])\n        \n        w       = self.width()\n        bwidth  = sum([btn.width() for btn in right_buttons])\n        bwidth  += (self.cornerRadius() / 2.0) + 1\n        \n        for btn in right_buttons:\n            btn.move(w - bwidth, y)\n            bwidth -= btn.width()\n        \r\n        self._buttonWidth = sum([btn.width() for btn in self.buttons()])\n        self.adjustTextMargins()", "response": "Adjusts the placement of the buttons for this line edit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef adjustTextMargins( self ):\n        left_buttons = self._buttons.get(Qt.AlignLeft, [])\n        \n        if left_buttons:\n            bwidth = left_buttons[-1].pos().x() + left_buttons[-1].width() - 4\n        else:\n            bwidth = 0 + (max(8, self.cornerRadius()) - 8)\n        \r\n        ico = self.icon()\r\n        if ico and not ico.isNull():\r\n            bwidth += self.iconSize().width()\r\n        \n        self.setTextMargins(bwidth, 0, 0, 0)", "response": "Adjusts the margins for the text based on the contents of the current item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef adjustStyleSheet( self ):\r\n        radius  = self.cornerRadius()\r\n        icon    = self.icon()\r\n        \r\n        if not self.objectName():\r\n            self.setStyleSheet('')\r\n        elif not (radius or icon):\r\n            self.setStyleSheet('')\r\n        else:\r\n            palette = self.palette()\r\n            \r\n            options = {}\r\n            options['corner_radius']    = radius\r\n            options['padding']          = 5\r\n            options['objectName']       = self.objectName()\r\n            \r\n            if icon and not icon.isNull():\r\n                options['padding'] += self.iconSize().width() + 2\r\n            \r\n            self.setStyleSheet(LINEEDIT_STYLE % options)", "response": "Adjusts the stylesheet for this widget based on whether it has a corner radius and icon."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef buttons(self):\r\n        all_buttons = []\r\n        for buttons in self._buttons.values():\r\n            all_buttons += buttons\r\n        return all_buttons", "response": "Returns all the buttons linked to this edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear(self):\r\n        super(XLineEdit, self).clear()\r\n        \r\n        self.textEntered.emit('')\r\n        self.textChanged.emit('')\r\n        self.textEdited.emit('')", "response": "Clears the text from the edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the current text that is available currently.", "response": "def currentText( self ):\n        \"\"\"\n        Returns the text that is available currently, \\\n        if the user has set standard text, then that \\\n        is returned, otherwise the hint is returned.\n        \n        :return     <str>\n        \"\"\"\n        text = nativestring(self.text())\n        if text or not self.useHintValue():\n            return text\n        return self.hint()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef focusInEvent(self, event):\r\n        super(XLineEdit, self).focusInEvent(event)\r\n        \r\n        self._focusedIn = True", "response": "Updates the focus in state for this edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the focus in state for this edit.", "response": "def focusOutEvent(self, event):\r\n        \"\"\"\r\n        Updates the focus in state for this edit.\r\n        \r\n        :param      event | <QFocusEvent>\r\n        \"\"\"\r\n        super(XLineEdit, self).focusOutEvent(event)\r\n        \r\n        self._focusedIn = False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef formatText(self, text):\r\n        format = self.inputFormat()\r\n        if format == XLineEdit.InputFormat.Normal:\r\n            return text\r\n        \r\n        text = projex.text.nativestring(text)\r\n        if format == XLineEdit.InputFormat.CamelHump:\r\n            return projex.text.camelHump(text)\r\n        \r\n        elif format == XLineEdit.InputFormat.Pretty:\r\n            return projex.text.pretty(text)\r\n        \r\n        elif format == XLineEdit.InputFormat.Underscore:\r\n            return projex.text.underscore(text)\r\n        \r\n        elif format == XLineEdit.InputFormat.Dash:\r\n            return projex.text.dashed(text)\r\n        \r\n        elif format == XLineEdit.InputFormat.ClassName:\r\n            return projex.text.classname(text)\r\n        \r\n        elif format == XLineEdit.InputFormat.NoSpaces:\r\n            return projex.text.joinWords(text, self.spacer())\r\n        \r\n        elif format == XLineEdit.InputFormat.Capitalize:\r\n            return text.capitalize()\r\n        \r\n        elif format == XLineEdit.InputFormat.Uppercase:\r\n            return text.upper()\r\n        \r\n        elif format == XLineEdit.InputFormat.Lowercase:\r\n            return text.lower()\r\n        \r\n        elif format == XLineEdit.InputFormat.Package:\r\n            return '.'.join(map(lambda x: x.lower(),\r\n                            map(projex.text.classname, text.split('.'))))\r\n        \r\n        return text", "response": "Formats the input text according to the input format assigned to this line edit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hint(self):\n        parts = (self._hintPrefix, self._hint, self._hintSuffix)\n        return ''.join(map(projex.text.nativestring, parts))", "response": "Returns the hint value for this line edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mousePressEvent(self, event):\r\n        super(XLineEdit, self).mousePressEvent(event)\r\n        \r\n        if self._focusedIn and self.selectAllOnFocus():\r\n            self.selectAll()\r\n            self._focusedIn = False", "response": "Select all the text if the property is set after this widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverload the paint event to paint additional \\ ntext information if no text is set on the line edit.", "response": "def paintEvent(self, event):\n        \"\"\"\n        Overloads the paint event to paint additional \\\n        hint information if no text is set on the \\\n        editor.\n        \n        :param      event      | <QPaintEvent>\n        \"\"\"\n        super(XLineEdit, self).paintEvent(event)\n        \n        # paint the hint text if not text is set\n        if self.text() and not (self.icon() and not self.icon().isNull()):\n            return\n        \n        # paint the hint text\n        with XPainter(self) as painter:\n            painter.setPen(self.hintColor())\n            \r\n            icon = self.icon()\r\n            left, top, right, bottom = self.getTextMargins()\r\n            \n            w = self.width()\n            h = self.height() - 2\r\n            \r\n            w -= (right + left)\r\n            h -= (bottom + top)\r\n            \r\n            if icon and not icon.isNull():\r\n                size = icon.actualSize(self.iconSize())\r\n                x    = self.cornerRadius() + 2\r\n                y    = (self.height() - size.height()) / 2.0\r\n                \r\n                painter.drawPixmap(x, y, icon.pixmap(size.width(), size.height()))\r\n                \r\n                w -= size.width() - 2\r\n            else:\r\n                x = 6 + left\r\n            \r\n            w -= self._buttonWidth\r\n            y = 2 + top\r\n            \n            # create the elided hint\r\n            if not self.text() and self.hint():\r\n                rect    = self.cursorRect()\n                metrics = QFontMetrics(self.font())\n                hint    = metrics.elidedText(self.hint(), Qt.ElideRight, w)\r\n                align   = self.alignment()\r\n                \r\n                if align & Qt.AlignHCenter:\r\n                    x = 0\r\n                else:\r\n                    x = rect.center().x()\r\n                \n                painter.drawText(x, y, w, h, align, hint)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resizeEvent( self, event ):\n        super(XLineEdit, self).resizeEvent(event)\n        self.adjustButtons()", "response": "Overloads the resize event to handle updating of buttons."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the current state for this edit.", "response": "def setCurrentState(self, state):\r\n        \"\"\"\r\n        Sets the current state for this edit to the inputed state.\r\n        \r\n        :param      state | <XLineEdit.State>\r\n        \"\"\"\r\n        self._currentState = state\r\n        \r\n        palette = self.palette()\r\n        if state == XLineEdit.State.Normal:\r\n            palette = QApplication.instance().palette()\r\n        \r\n        elif state == XLineEdit.State.Failed:\r\n            palette.setColor(palette.Base, QColor('#ffc9bc'))\r\n            palette.setColor(palette.Text, QColor('#aa2200'))\r\n            palette.setColor(palette.Disabled, palette.Text, QColor('#e58570'))\r\n        \r\n        elif state == XLineEdit.State.Passed:\r\n            palette.setColor(palette.Base, QColor('#d1ffd1'))\r\n            palette.setColor(palette.Text, QColor('#00aa00'))\r\n            palette.setColor(palette.Disabled, palette.Text, QColor('#75e575'))\r\n        \r\n        self._hintColor = palette.color(palette.Disabled, palette.Text)\r\n        self.setPalette(palette)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setHint(self, hint):\r\n        self._hint = self.formatText(hint)\r\n        self.update()\r\n        self.hintChanged.emit(self.hint())", "response": "Sets the hint text for the current item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the input format text for this widget to the given value.", "response": "def setInputFormatText( self, text ):\n        \"\"\"\n        Sets the input format text for this widget to the given value.\n        \n        :param      text | <str>\n        \"\"\"\n        try:\n            self._inputFormat = XLineEdit.InputFormat[nativestring(text)]\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setObjectName( self, objectName ):\r\n        super(XLineEdit, self).setObjectName(objectName)\r\n        self.adjustStyleSheet()", "response": "Updates the style sheet for this line edit when the name changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setText( self, text ):\r\n        if text is None:\r\n            text = ''\r\n        \r\n        super(XLineEdit, self).setText(projex.text.encoded(self.formatText(text), self.encoding()))", "response": "Sets the text for this widget to the inputed text."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setVisible(self, state):\r\n        super(XLineEdit, self).setVisible(state)\r\n        \r\n        self.adjustStyleSheet()\r\n        self.adjustTextMargins()", "response": "Sets the visible state for this line edit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_accounts(self, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_accounts_with_http_info(**kwargs)  # noqa: E501\n        else:\n            (data) = self.get_accounts_with_http_info(**kwargs)  # noqa: E501\n            return data", "response": "Get all accounts of all members of your corporate account"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets account information of all members of your corporate account # noqa: E501 Only admin account can send request to this endpoint which returns accounts of all members # noqa: E501 This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async=True >>> thread = api.get_accounts_with_http_info(async=True) >>> result = thread.get() :param async bool :return: ResponseAccountList If the method is called asynchronously, returns the request thread.", "response": "def get_accounts_with_http_info(self, **kwargs):  # noqa: E501\n        \"\"\"Get account information of all members of your corporate account  # noqa: E501\n\n        Only admin account can send request to this endpoint which returns accounts of all members  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.get_accounts_with_http_info(async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :return: ResponseAccountList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n\n        all_params = []  # noqa: E501\n        all_params.append('async')\n        all_params.append('_return_http_data_only')\n        all_params.append('_preload_content')\n        all_params.append('_request_timeout')\n\n        params = locals()\n        for key, val in six.iteritems(params['kwargs']):\n            if key not in all_params:\n                raise TypeError(\n                    \"Got an unexpected keyword argument '%s'\"\n                    \" to method get_accounts\" % key\n                )\n            params[key] = val\n        del params['kwargs']\n\n        collection_formats = {}\n\n        path_params = {}\n\n        query_params = []\n\n        header_params = {}\n\n        form_params = []\n        local_var_files = {}\n\n        body_params = None\n        # HTTP header `Accept`\n        header_params['Accept'] = self.api_client.select_header_accept(\n            ['application/json'])  # noqa: E501\n\n        # HTTP header `Content-Type`\n        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501\n            ['application/json'])  # noqa: E501\n\n        # Authentication setting\n        auth_settings = ['fax_oauth']  # noqa: E501\n\n        return self.api_client.call_api(\n            '/accounts', 'GET',\n            path_params,\n            query_params,\n            header_params,\n            body=body_params,\n            post_params=form_params,\n            files=local_var_files,\n            response_type='ResponseAccountList',  # noqa: E501\n            auth_settings=auth_settings,\n            async=params.get('async'),\n            _return_http_data_only=params.get('_return_http_data_only'),\n            _preload_content=params.get('_preload_content', True),\n            _request_timeout=params.get('_request_timeout'),\n            collection_formats=collection_formats)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting member details # noqa: E501 Get your member details (quota and role) # noqa: E501 This method makes a synchronous HTTP request by default. To make an asynchronous HTTP request, please pass async=True >>> thread = api.get_member_details(member_id, async=True) >>> result = thread.get() :param async bool :param str member_id: (required) :return: MemberDetail If the method is called asynchronously, returns the request thread.", "response": "def get_member_details(self, member_id, **kwargs):  # noqa: E501\n        \"\"\"Get member details  # noqa: E501\n\n        Get your member details (quota and role)  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.get_member_details(member_id, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str member_id: (required)\n        :return: MemberDetail\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_member_details_with_http_info(member_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.get_member_details_with_http_info(member_id, **kwargs)  # noqa: E501\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user(self, user_id, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501\n            return data", "response": "Get account information for admin or member  # noqa: E501\n\n        Get account information. For members user_id can only be self. form admin it can be user_id of any <br />**In case you want to get your own account information please use *`self`* as an alias for your user_id.**  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.get_user(user_id, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str user_id: (required)\n        :return: Account\n                 If the method is called asynchronously,\n                 returns the request thread."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_member_details(self, member_id, payload_member_detail, **kwargs):  # noqa: E501\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async'):\n            return self.update_member_details_with_http_info(member_id, payload_member_detail, **kwargs)  # noqa: E501\n        else:\n            (data) = self.update_member_details_with_http_info(member_id, payload_member_detail, **kwargs)  # noqa: E501\n            return data", "response": "Modify member details  # noqa: E501\n\n        One of the paramters below is needed to modify member information  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async=True\n        >>> thread = api.update_member_details(member_id, payload_member_detail, async=True)\n        >>> result = thread.get()\n\n        :param async bool\n        :param str member_id: (required)\n        :param MemberDetail payload_member_detail: (required)\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(cap, *args, **kwargs):\n    # Hack for readthedocs.org\n    if 'READTHEDOCS' in os.environ:\n        return ''\n\n    if kwargs != {}:\n        raise TypeError(\"get(): No such argument %r\" % kwargs.popitem()[0])\n\n    if _cache == {}:\n        # Fix for BPython\n        try:\n            curses.setupterm()\n        except:\n            pass\n    \n    s = _cache.get(cap)\n    if not s:\n        s = curses.tigetstr(cap)\n        if s == None:\n            s = curses.tigetnum(cap)\n            if s == -2:\n                s = curses.tigetflag(cap)\n                if s == -1:\n                    # default to empty string so tparm doesn't fail\n                    s = ''\n                else:\n                    s = bool(s)\n        _cache[cap] = s\n\n    # if 's' is not set 'curses.tparm' will throw an error if given arguments\n    if args and s:\n        r = curses.tparm(s, *args)\n        return r.decode('utf-8')\n    else:\n        if isinstance(s, bytes):\n            return s.decode('utf-8')\n        else:\n            return s", "response": "Get a terminal capability exposes through the curses module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters a thermostat with the UH1", "response": "def registerThermostat(self, thermostat):\n        \"\"\"Registers a thermostat with the UH1\"\"\"\n        try:\n            type(thermostat) == heatmiser.HeatmiserThermostat\n            if thermostat.address in self.thermostats.keys():\n                raise ValueError(\"Key already present\")\n            else:\n                self.thermostats[thermostat.address] = thermostat\n        except ValueError:\n            pass\n        except Exception as e:\n            logging.info(\"You're not adding a HeatmiiserThermostat Object\")\n            logging.info(e.message)\n        return self._serport"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addFilename( self, filename ):\n        filename = os.path.normpath(nativestring(filename))\n        \n        if filename in self._filenames:\n            self._filenames.remove(filename)\n        \n        self._filenames.insert(0, filename)\n        self._filenames = self._filenames[:self.maximumLength()]\n        \n        self.refresh()", "response": "Adds a new filename to the top of the list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef emitFileTriggered( self, action ):\n        if not self.signalsBlocked():\n            filename = nativestring(unwrapVariant(action.data()))\n            self.fileTriggered.emit(filename)", "response": "Emits that the filename has been triggered for the inputed action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrefreshing the menu with the current files.", "response": "def refresh( self ):\n        \"\"\"\n        Clears out the actions for this menu and then loads the files.\n        \"\"\"\n        self.clear()\n        \n        for i, filename in enumerate(self.filenames()):\n            name   = '%i. %s' % (i+1, os.path.basename(filename))\n            action = self.addAction(name)\n            action.setData(wrapVariant(filename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef restoreSettings(self, settings):\n        value = unwrapVariant(settings.value('recent_files'))\n        if value:\n            self.setFilenames(value.split(os.path.pathsep))", "response": "Restores the files for this menu from the settings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the files for this menu to the settings.", "response": "def saveSettings(self, settings):\n        \"\"\"\n        Saves the files for this menu to the settings.\n        \n        :param      settings | <QSettings>\n        \"\"\"\n        value = wrapVariant(os.path.pathsep.join(self.filenames()))\n        settings.setValue('recent_files', value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setFilenames( self, filenames ):\n        mapped = []\n        for filename in filenames:\n            filename = nativestring(filename)\n            if ( not filename ):\n                continue\n            \n            mapped.append(filename)\n            if ( len(mapped) == self.maximumLength() ):\n                break\n        \n        self._filenames = mapped\n        self.refresh()", "response": "Sets the list of filenames that will be used for this menu to the \\\n        inputed list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setMaximumLength( self, length ):\n        self._maximumLength = length\n        self._filenames = self._filenames[:length]\n        self.refresh()", "response": "Sets the maximum number of files to be cached when loading."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the current value of the object.", "response": "def updateCurrentValue(self, value):\r\n        \"\"\"\r\n        Implementation of QAbstractAnimation's abstract method, called when\r\n        the value is changed internally and is supposed to update the \r\n        python object's value.\r\n        \r\n        :param      value | <QVariant> || <variant>\r\n        \"\"\"\r\n        try:\r\n            method = getattr(self._targetObject, self._setter)\r\n        except AttributeError:\r\n            return\r\n        \r\n        try:\r\n            method(unwrapVariant(value))\r\n        except:\r\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef createEditor(self, parent, option, index):\r\n        if index.column() in self._disabledEditingColumns:\r\n            return None\r\n        \r\n        editor = super(XTreeWidgetDelegate, self).createEditor(parent,\r\n                                                               option,\r\n                                                               index)\r\n        \r\n        if isinstance(editor, QtGui.QDateTimeEdit):\r\n            editor.setCalendarPopup(True)\r\n        \r\n        return editor", "response": "Create a new editor for the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndraws the background for the current item.", "response": "def drawBackground( self, painter, opt, rect, brush ):\r\n        \"\"\"\r\n        Make sure the background extends to 0 for the first item.\r\n        \r\n        :param      painter | <QtGui.QPainter>\r\n                    rect    | <QtCore.QRect>\r\n                    brush   | <QtGui.QBrush>\r\n        \"\"\"\r\n        if not brush:\r\n            return\r\n        \r\n        painter.setPen(QtCore.Qt.NoPen)\r\n        painter.setBrush(brush)\r\n        painter.drawRect(rect)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrendering a check indicator within the rectangle.", "response": "def drawCheck( self, painter, option, rect, state ):\r\n        \"\"\"\r\n        Renders a check indicator within the rectangle based on the inputed \\\r\n        check state.\r\n        \r\n        :param      painter | <QtGui.QPainter>\r\n                    option  | <QtGui.QStyleOptionViewItem>\r\n                    rect    | <QtGui.QRect>\r\n                    state   | <QtCore.Qt.CheckState>\r\n        \"\"\"\r\n        if not self.useCheckMaps():\r\n            return super(XTreeWidgetDelegate, self).drawCheck(painter,\r\n                                                              option,\r\n                                                              rect,\r\n                                                              state)\r\n        \r\n        pixmap = None\r\n        if state == QtCore.Qt.Checked:\r\n            pixmap = self.checkOnMap()\r\n        elif state == QtCore.Qt.PartiallyChecked:\r\n            pixmap = self.checkPartialMap()\r\n        elif state == QtCore.Qt.Unchecked:\r\n            pixmap = self.checkOffMap()\r\n        \r\n        if type(pixmap) in (str, unicode):\r\n            pixmap = QtGui.QPixmap(pixmap)\r\n        \r\n        if not pixmap:\r\n            return\r\n        \r\n        x = rect.x() + (rect.width() - 16) / 2.0\r\n        y = rect.y() + (rect.height() - 16) / 2.0\r\n        \r\n        painter.drawPixmap(int(x), int(y), pixmap)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef drawDisplay(self, painter, option, rect, text):\r\n        if self.showRichText():\r\n            # create the document\r\n            doc = QtGui.QTextDocument()\r\n            doc.setTextWidth(float(rect.width()))\r\n            doc.setHtml(text)\r\n            \r\n            # draw the contents\r\n            painter.translate(rect.x(), rect.y())\r\n            doc.drawContents(painter, QtCore.QRectF(0, \r\n                                                    0, \r\n                                                    float(rect.width()), \r\n                                                    float(rect.height())))\r\n                                             \r\n            painter.translate(-rect.x(), -rect.y())\r\n        else:\r\n            if type(text).__name__ not in ('str', 'unicode', 'QString'):\r\n                text = nativestring(text)\r\n            \r\n            metrics = QtGui.QFontMetrics(option.font)\r\n            text = metrics.elidedText(text,\r\n                                      QtCore.Qt.TextElideMode(option.textElideMode),\r\n                                      rect.width())\r\n            \r\n            painter.setFont(option.font)\r\n            painter.drawText(rect, int(option.displayAlignment), text)", "response": "Overloads the drawDisplay method to render the text for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drawOverlay(self, painter, option, rect, icon):\r\n        if icon and not icon.isNull():\r\n            painter.drawPixmap(rect, icon.pixmap(rect.width(), rect.height()))", "response": "Draws the overlay for this item."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws the grid for this delegate.", "response": "def drawGrid(self, painter, opt, rect, index):\r\n        \"\"\"\r\n        Draws the grid lines for this delegate.\r\n        \r\n        :param      painter | <QtGui.QPainter>\r\n                    opt     | <QtGui.QStyleOptionItem>\r\n                    rect    | <QtCore.QRect>\r\n                    index   | <QtGui.QModelIndex>\r\n        \"\"\"\r\n        if not self.showGrid():\r\n            return\r\n        \r\n        painter.setBrush(QtCore.Qt.NoBrush)\r\n        painter.setPen(self.gridPen())\r\n        \r\n        size = self.gridPen().width() + 1\r\n        \r\n        # draw the lines\r\n        lines = []\r\n        \r\n        # add the column line\r\n        if self.showGridColumns():\r\n            lines.append(QtCore.QLine(rect.width() - size, \r\n                                      0, \r\n                                      rect.width() - size, \r\n                                      rect.height() - size))\r\n        \r\n        # add the row line\r\n        if (self.showGridRows()):\r\n            lines.append(QtCore.QLine(0, \r\n                                      rect.height() - size, \r\n                                      rect.width() - size, \r\n                                      rect.height() - size))\r\n        \r\n        painter.drawLines(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef paint(self, painter, opt, index):\r\n        # prepare the painter\r\n        painter.save()\r\n        painter.resetTransform()\r\n        \r\n        # extract data from the tree\r\n        tree         = self.parent()\r\n        column       = index.column()\r\n        item         = tree.itemFromIndex(index)\r\n        is_xtreeitem = isinstance(item, XTreeWidgetItem)\r\n        hovered      = False\r\n        font         = item.font(index.column())\r\n        opt.font     = font\r\n        palette      = tree.palette()\r\n        \r\n        painter.translate(opt.rect.x(), opt.rect.y())\r\n        rect_w = opt.rect.width()\r\n        rect_h = opt.rect.height()\r\n        \r\n        painter.setClipRect(0, 0, rect_w, rect_h)\r\n        \r\n        # grab the check information\r\n        checkState = None\r\n        size       = opt.decorationSize\r\n        value      = unwrapVariant(index.data(QtCore.Qt.CheckStateRole))\r\n        \r\n        if value is not None:\r\n            checkState = item.checkState(index.column())\r\n            check_size = min(size.width(), size.height())\r\n            check_size = min(14, check_size)\r\n            checkRect  = QtCore.QRect(2, \r\n                                     (rect_h - check_size) / 2.0, \r\n                                      check_size, \r\n                                      check_size)\r\n        else:\r\n            checkRect = QtCore.QRect()\r\n        \r\n        # determine hovering options\r\n        if tree.hoverMode() != xtreewidget.XTreeWidget.HoverMode.NoHover and \\\r\n           item.flags() & XTreeWidgetItem.ItemIsHoverable:\r\n            \r\n            # hover particular columns\r\n            if tree.hoverMode() == xtreewidget.XTreeWidget.HoverMode.HoverItems and \\\r\n               item == tree.hoveredItem() and \\\r\n               column == tree.hoveredColumn():\r\n                hovered = True\r\n            \r\n            # hover particular items\r\n            elif tree.hoverMode() == xtreewidget.XTreeWidget.HoverMode.HoverRows and \\\r\n                 id(item) == id(tree.hoveredItem()):\r\n                hovered = True\r\n        \r\n        # setup the decoration information\r\n        if item.isExpanded() and is_xtreeitem and item.expandedIcon(column):\r\n            icon = item.expandedIcon(column)\r\n        \r\n        elif hovered and tree.hoveredColumn() == column and \\\r\n             is_xtreeitem and \\\r\n             item.hoverIcon(column):\r\n            icon = item.hoverIcon(column)\r\n        \r\n        else:\r\n            icon = item.icon(column)\r\n        \r\n        if icon and not icon.isNull():\r\n            size    = icon.actualSize(opt.decorationSize)\r\n            pixmap  = icon.pixmap(size)\r\n            \r\n            if checkRect:\r\n                x = checkRect.right() + 2\r\n            else:\r\n                x = 0\r\n            \r\n            y = 0\r\n            w = opt.decorationSize.width()\r\n            h = opt.decorationSize.height()\r\n            \r\n            x += 2\r\n            y += (rect_h - size.height()) / 2.0\r\n            \r\n            decorationRect  = QtCore.QRect(x, y, w, h)\r\n        else:\r\n            pixmap          = QtGui.QPixmap()\r\n            overlay         = QtGui.QIcon()\r\n            decorationRect  = QtCore.QRect()\r\n        \r\n        if is_xtreeitem:\r\n            overlay = item.iconOverlay(column)\r\n            dec_w = decorationRect.width()\r\n            dec_h = decorationRect.height()\r\n            over_w = int(dec_w / 1.7)\r\n            over_h = int(dec_h / 1.7)\r\n            overlayRect = QtCore.QRect(decorationRect.right() - over_w,\r\n                                       decorationRect.bottom() - over_h,\r\n                                       over_w,\r\n                                       over_h)\r\n        else:\r\n            overlay = QtGui.QPixmap()\r\n            overlayRect = QtCore.QRect()\r\n        \r\n        # setup the coloring information\r\n        bg = None\r\n        fg = None\r\n        \r\n        if self.showHighlights() and tree.selectionModel().isSelected(index):\r\n            palette = tree.palette()\r\n            bg = QtGui.QBrush(palette.color(palette.Highlight))\r\n            fg = QtGui.QBrush(palette.color(palette.HighlightedText))\r\n        \r\n        elif hovered:\r\n            bg = tree.hoverBackground()\r\n            fg = tree.hoverForeground()\r\n            \r\n            if is_xtreeitem:\r\n                bg = item.hoverBackground(column, bg)\r\n                fg = item.hoverForeground(column, fg)\r\n        \r\n        if not bg:\r\n            bg_role = unwrapVariant(item.data(column, QtCore.Qt.BackgroundRole))\r\n            if bg_role is not None:\r\n                bg = item.background(column)\r\n            else:\r\n                bg = self.background(column)\r\n        \r\n        if not fg:\r\n            fg_role = unwrapVariant(item.data(column, QtCore.Qt.ForegroundRole))\r\n            if fg_role is not None:\r\n                fg = item.foreground(column)\r\n            else:\r\n                fg = self.foreground(column)\r\n        \r\n        if not fg:\r\n            fg = QtGui.QBrush(palette.color(palette.Text))\r\n        \r\n        # draw custom text\r\n        mapper = self.displayMapper(column)\r\n        if mapper:\r\n            text = mapper(unwrapVariant(index.data(), ''))\r\n        \r\n        # draw specific type text\r\n        else:\r\n            data = unwrapVariant(index.data(QtCore.Qt.EditRole), None)\r\n            \r\n            # map the data to python\r\n            if type(data) in (QtCore.QDate, QtCore.QDateTime, QtCore.QTime):\r\n                data = data.toPython()\r\n            \r\n            # render a standard date format\r\n            if type(data) == datetime.date:\r\n                text = data.strftime(self.dateFormat())\r\n            \r\n            # render a standard datetime format\r\n            elif type(data) == datetime.time:\r\n                text = data.strftime(self.timeFormat())\r\n            \r\n            # render a standard datetime format\r\n            elif type(data) == datetime.datetime:\r\n                text = data.strftime(self.datetimeFormat())\r\n            \r\n            # draw standard text\r\n            else:\r\n                text = unwrapVariant(index.data(QtCore.Qt.DisplayRole), '')\r\n        \r\n        # display hint information\r\n        if not text:\r\n            hint = unwrapVariant(index.data(XTreeWidgetItem.HintRole))\r\n            if hint:\r\n                text = hint\r\n                fg = QtGui.QBrush(palette.color(palette.Disabled, palette.Text))\r\n        \r\n        opt.displayAlignment = QtCore.Qt.Alignment(item.textAlignment(index.column()))\r\n        if not opt.displayAlignment & (QtCore.Qt.AlignVCenter | \\\r\n                                       QtCore.Qt.AlignTop | QtCore.Qt.AlignBottom):\r\n            opt.displayAlignment |= QtCore.Qt.AlignVCenter\r\n        \r\n        if decorationRect:\r\n            x = decorationRect.right() + 5\r\n        elif checkRect:\r\n            x = checkRect.right() + 5\r\n        else:\r\n            x = 5\r\n        \r\n        w = rect_w - x - 5\r\n        h = rect_h\r\n        \r\n        displayRect = QtCore.QRect(x, 0, w, h)\r\n        \r\n        # create the background rect\r\n        backgroundRect = QtCore.QRect(0, 0, opt.rect.width(), opt.rect.height())\r\n        \r\n        # draw the item\r\n        self.drawBackground(painter, opt, backgroundRect, bg)\r\n        \r\n        painter.setBrush(QtCore.Qt.NoBrush)\r\n        painter.setPen(fg.color())\r\n        \r\n        self.drawCheck(painter, opt, checkRect, checkState)\r\n        self.drawDecoration( painter, opt, decorationRect, pixmap)\r\n        self.drawOverlay(painter, opt, overlayRect, overlay)\r\n        self.drawDisplay(painter, opt, displayRect, text)\r\n        self.drawGrid(painter, opt, backgroundRect, index)\r\n        \r\n        painter.restore()", "response": "Returns the contents of the item in the tree that corresponds to the item at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the default item foreground brush for the given column.", "response": "def setBackground(self, column, brush):\r\n        \"\"\"\r\n        Sets the default item foreground brush.\r\n        \r\n        :param      column | <int>\r\n                    brush  | <QtGui.QBrush> || None\r\n        \"\"\"\r\n        if brush:\r\n            self._background[column] = QtGui.QBrush(brush)\r\n        elif column in self._background:\r\n            self._background.pop(column)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the default item foreground brush.", "response": "def setForeground(self, column, brush):\r\n        \"\"\"\r\n        Sets the default item foreground brush.\r\n        \r\n        :param      brush | <QtGui.QBrush> || None\r\n        \"\"\"\r\n        if brush:\r\n            self._foreground[column] = QtGui.QBrush(brush)\r\n        elif column in self._background:\r\n            self._foreground.pop(column)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the size hint for the inputed index.", "response": "def sizeHint(self, option, index):\r\n        \"\"\"\r\n        Returns the size hint for the inputed index.\r\n        \r\n        :param      option  | <QStyleOptionViewItem>\r\n                    index   | <QModelIndex>\r\n        \r\n        :return     <QtCore.QSize>\r\n        \"\"\"\r\n        size = super(XTreeWidgetDelegate, self).sizeHint(option, index)\r\n        \r\n        tree = self.parent()\r\n        item = tree.itemFromIndex(index)\r\n        \r\n        try:\r\n            fixed_height = item.fixedHeight()\r\n        except:\r\n            fixed_height = 0\r\n        \r\n        if fixed_height:\r\n            size.setHeight(fixed_height)\r\n        \r\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new sub window for this widget.", "response": "def addSubWindow(self, widget, windowFlags=0):\r\n        \"\"\"\r\n        Creates a new sub window for this widget, specifically\r\n        creating an XMdiSubWindow class.\r\n        \r\n        :param      widget      | <QtGui.QWidget>\r\n                    windowFlags | <QtCore.Qt.WindowFlags>\r\n        \r\n        :return     <XMdiSubWindow>\r\n        \"\"\"\r\n        if not widget:\r\n            return 0\r\n        \r\n        childFocus = widget.focusWidget()\r\n        \r\n        # child is already a sub window\r\n        if not isinstance(widget, QtGui.QMdiSubWindow):\r\n            child = XMdiSubWindow(self.viewport(), windowFlags)\r\n            child.setAttribute(QtCore.Qt.WA_DeleteOnClose)\r\n            child.setWidget(widget)\r\n        else:\r\n            child = widget\r\n        \r\n        if childFocus:\r\n            childFocus.setFocus()\r\n        \r\n        return super(XMdiArea, self).addSubWindow(child)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadjusts the minimum width of the icon based on the size of the pixmaps and the maximum.", "response": "def adjustMinimumWidth( self ):\r\n        \"\"\"\r\n        Modifies the minimum width to factor in the size of the pixmaps and the\r\n        number for the maximum.\r\n        \"\"\"\r\n        pw = self.pixmapSize().width()\r\n        \r\n        # allow 1 pixel space between the icons\r\n        self.setMinimumWidth(pw * self.maximum() + 3 * self.maximum())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the value for the slider at the given mouse event position.", "response": "def mousePressEvent( self, event ):\r\n        \"\"\"\r\n        Sets the value for the slider at the event position.\r\n        \r\n        :param      event | <QMouseEvent>\r\n        \"\"\"\r\n        self.setValue(self.valueAt(event.pos().x()))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value for the slider at the event position.", "response": "def mouseMoveEvent( self, event ):\r\n        \"\"\"\r\n        Sets the value for the slider at the event position.\r\n        \r\n        :param      event | <QMouseEvent>\r\n        \"\"\"\r\n        self.setValue(self.valueAt(event.pos().x()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef paintEvent(self, event):\r\n        with XPainter(self) as painter:\r\n            count   = self.maximum() - self.minimum()\r\n            value   = self.value()\r\n            \r\n            w       = self.pixmapSize().width()\r\n            h       = self.pixmapSize().height()\r\n            x       = 2\r\n            y       = (self.height() - h) / 2\r\n            delta_x = (self.width() - 4 - (w * count - 1)) / (count - 1)\r\n            \r\n            full_pixmap  = self.fullPixmap().scaled(w, h)\r\n            empty_pixmap = self.emptyPixmap().scaled(w, h)\r\n            \r\n            for i in range(count):\r\n                if ( i < value ):\r\n                    painter.drawPixmap(x, y, full_pixmap)\r\n                else:\r\n                    painter.drawPixmap(x, y, empty_pixmap)\r\n                \r\n                x += w + delta_x", "response": "Paints the widget based on its values"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the maximum value for this slider.", "response": "def setMaximum( self, value ):\r\n        \"\"\"\r\n        Sets the maximum value for this slider - this will also adjust the\r\n        minimum size value to match the width of the icons by the number for\r\n        the maximu.\r\n        \r\n        :param      value | <int>\r\n        \"\"\"\r\n        super(XRatingSlider, self).setMaximum(value)\r\n        \r\n        self.adjustMinimumWidth()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the pixmap size.", "response": "def setPixmapSize( self, size ):\r\n        \"\"\"\r\n        Sets the pixmap size to the inputed value.\r\n        \r\n        :param      size | <QSize>\r\n        \"\"\"\r\n        self._pixmapSize = size\r\n        self.setMinimumHeight(size.height())\r\n        self.adjustMinimumWidth()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef valueAt( self, pos ):\r\n        if ( self.orientation() == Qt.Horizontal ):\r\n            perc = (self.width() - 4 - pos) / float(self.width())\r\n        else:\r\n            perc = (self.height() - 4 - pos) / float(self.height())\r\n        \r\n        start = self.minimum()\r\n        end   = self.maximum()\r\n        \r\n        return round((end - start) * (1 - perc))", "response": "Returns the value of the slider at the inputed position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef canClose(self):\n        for view in self.findChildren(XView):\n            if not view.canClose():\n                return False\n        return True", "response": "Checks to see if the view widget can be closed by checking all of its sub - views to make sure they are ok to close."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef createMenu(self, parent):\n        menu = QtGui.QMenu(parent)\n        menu.setTitle('&View')\n\n        act = menu.addAction('&Lock/Unlock Layout')\n        act.setIcon(QtGui.QIcon(projexui.resources.find('img/view/lock.png')))\n        act.triggered.connect(self.toggleLocked)\n        \n        menu.addSeparator()\n        act = menu.addAction('&Export Layout as...')\n        act.setIcon(QtGui.QIcon(projexui.resources.find('img/view/export.png')))\n        act.triggered.connect(self.exportProfile)\n        \n        act = menu.addAction('&Import Layout from...')\n        act.setIcon(QtGui.QIcon(projexui.resources.find('img/view/import.png')))\n        act.triggered.connect(self.importProfile)\n\n        menu.addSeparator()\n\n        act = menu.addAction('&Clear Layout')\n        act.setIcon(QtGui.QIcon(projexui.resources.find('img/view/remove.png')))\n        act.triggered.connect(self.resetForced)\n\n        return menu", "response": "Creates a new menu for the inputed parent item."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef currentPanel(self):\n        focus_widget = QtGui.QApplication.instance().focusWidget()\n        focus_panel = projexui.ancestor(focus_widget, XViewPanel)\n\n        panels = self.panels()\n        if focus_panel in panels:\n            return focus_panel\n        try:\n            return panels[0]\n        except IndexError:\n            return None", "response": "Returns the currently active panel based on whether or not the current panel is the focus."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef exportProfile(self, filename=''):\n        if not (filename and isinstance(filename, basestring)):\n            filename = QtGui.QFileDialog.getSaveFileName(self,\n                                                         'Export Layout as...',\n                                                         QtCore.QDir.currentPath(),\n                                                         'XView (*.xview)')\n            \n            if type(filename) == tuple:\n                filename = filename[0]\n        \n        filename = nativestring(filename)\n        if not filename:\n            return\n        \n        if not filename.endswith('.xview'):\n            filename += '.xview'\n        \n        profile = self.saveProfile()\n        profile.save(filename)", "response": "Exports the current profile to a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef findViewType(self, viewTypeName):\n        for viewType in self._viewTypes:\n            if ( viewType.viewTypeName() == viewTypeName ):\n                return viewType\n        return None", "response": "Returns the view type object for the given view type name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimport the current profile to a file.", "response": "def importProfile(self, filename=''):\n        \"\"\"\n        Exports the current profile to a file.\n        \n        :param      filename | <str>\n        \"\"\"\n        if not (filename and isinstance(filename, basestring)):\n            filename = QtGui.QFileDialog.getOpenFileName(self,\n                                                         'Import Layout from...',\n                                                         QtCore.QDir.currentPath(),\n                                                         'XView (*.xview)')\n            \n            if type(filename) == tuple:\n                filename = nativestring(filename[0])\n        \n        filename = nativestring(filename)\n        if not filename:\n            return\n        \n        if not filename.endswith('.xview'):\n            filename += '.xview'\n        \n        profile = XViewProfile.load(filename)\n        if not profile:\n            return\n            \n        profile.restore(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all panels that are assigned to this view widget.", "response": "def panels(self):\n        \"\"\"\n        Returns a lis of the panels that are assigned to this view widget.\n        \n        :return     [<XViewPanel>, ..]\n        \"\"\"\n        return [panel for panel in self.findChildren(XViewPanel) if panel.viewWidget() == self]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef registerViewType(self, cls, window=None):\n        if ( not cls in self._viewTypes ):\n            self._viewTypes.append(cls)\n            \n            if ( window ):\n                cls.registerToWindow(window)", "response": "Registers the given widget class as a potential view class."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrestores the current structure of the view widget from the inputed \\ QSettings instance.", "response": "def restoreSettings(self, settings):\n        \"\"\"\n        Restores the current structure of the view widget from the inputed \\\n        settings instance.\n        \n        :param      settings | <QSettings>\n        \"\"\"\n        key     = self.objectName()\n        value   = unwrapVariant(settings.value('%s/profile' % key))\n        \n        if not value:\n            self.reset(force = True)\n            return False\n            \n        profile = value\n        \n        # restore the view type settings\n        for viewType in self.viewTypes():\n            viewType.restoreGlobalSettings(settings)\n        \n        # restore the profile\n        self.restoreProfile(XViewProfile.fromString(profile))\n        \n        if not self.views():\n            self.reset(force = True)\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting the system and the widget to a blank version of the system.", "response": "def reset(self, force=False):\n        \"\"\"\n        Clears out all the views and panels and resets the widget to a blank \\\n        parent.\n        \n        :return     <bool>\n        \"\"\"\n        answer = QtGui.QMessageBox.Yes\n        opts = QtGui.QMessageBox.Yes | QtGui.QMessageBox.No\n        \n        if not force:\n            answer = QtGui.QMessageBox.question(self,\n                                                'Reset Layout',\n                                                'Are you sure you want to reset?',\n                                                opts)\n        \n        if answer == QtGui.QMessageBox.No:\n            return\n        \n        widget = self.widget()\n        \n        # we should always have a widget, but double check\n        if not widget:\n            return False\n        \n        # make sure we can close the current view\n        if not widget.close():\n            return False\n        \n        # reset the system\n        self.takeWidget()\n        \n        # restore a default profile\n        prof = self.defaultProfile()\n        if prof:\n            return prof.restore(self)\n        \n        # otherwise create a new panel\n        else:\n            self.setLocked(False)\n            self.setWidget(XViewPanel(self, False))\n\n        self.resetFinished.emit()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the current structure of the view widget to the inputed \\ QSettings instance.", "response": "def saveSettings(self, settings):\n        \"\"\"\n        Records the current structure of the view widget to the inputed \\\n        settings instance.\n        \n        :param      settings | <QSettings>\n        \"\"\"\n        # record the profile\n        profile = self.saveProfile()\n        key     = self.objectName()\n        \n        settings.setValue('%s/profile' % key, wrapVariant(profile.toString()))\n        \n        # record the view type settings\n        for viewType in self.viewTypes():\n            viewType.saveGlobalSettings(settings)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the locked state for this view widget.", "response": "def setLocked(self, state):\n        \"\"\"\n        Sets the locked state for this view widget.  When locked, a user no \\\n        longer has control over editing views and layouts.  A view panel with \\\n        a single entry will hide its tab bar, and if it has multiple views, it \\\n        will simply hide the editing buttons.\n        \n        :param      state | <bool>\n        \"\"\"\n        changed = state != self._locked\n        self._locked = state\n        \n        for panel in self.panels():\n            panel.setLocked(state)\n        \n        if changed and not self.signalsBlocked():\n            self.lockToggled.emit(state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the view types that can be used for this widget.", "response": "def setViewTypes(self, viewTypes, window=None):\n        \"\"\"\n        Sets the view types that can be used for this widget.  If the optional \\\n        window member is supplied, then the registerToWindow method will be \\\n        called for each view.\n        \n        :param      viewTypes | [<sublcass of XView>, ..]\n                    window    | <QMainWindow> || <QDialog> || None\n        \"\"\"\n        if window:\n            for viewType in self._viewTypes:\n                viewType.unregisterFromWindow(window)\n        \n        self._viewTypes = viewTypes[:]\n        self._panelMenu = None\n        self._pluginMenu = None\n        \n        if window:\n            for viewType in viewTypes:\n                viewType.registerToWindow(window)"}
