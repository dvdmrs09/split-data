{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomparing two sets of class attributes using a constant time algorithm to avoid timing attacks.", "response": "def is_signature_equal(cls, sig_a, sig_b):\n        \"\"\"Compares two signatures using a constant time algorithm to avoid timing attacks.\"\"\"\n        if len(sig_a) != len(sig_b):\n            return False\n\n        invalid_chars = 0\n        for char_a, char_b in zip(sig_a, sig_b):\n            if char_a != char_b:\n                invalid_chars += 1\n        return invalid_chars == 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndecodes a cookie value and returns the sid if value or None if invalid.", "response": "def decode_sid(cls, secret, cookie_value):\n        \"\"\"Decodes a cookie value and returns the sid if value or None if invalid.\"\"\"\n        if len(cookie_value) > SIG_LENGTH + SID_LENGTH:\n            logging.warn(\"cookie value is incorrect length\")\n            return None\n\n        cookie_sig = cookie_value[:SIG_LENGTH]\n        cookie_sid = cookie_value[SIG_LENGTH:]\n\n        secret_bytes = secret.encode(\"utf-8\")\n        cookie_sid_bytes = cookie_sid.encode(\"utf-8\")\n\n        actual_sig = hmac.new(secret_bytes, cookie_sid_bytes, hashlib.sha512).hexdigest()\n\n        if not Session.is_signature_equal(cookie_sig, actual_sig):\n            return None\n\n        return cookie_sid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nterminating an active session", "response": "def terminate(self):\n        \"\"\"Terminates an active session\"\"\"\n        self._backend_client.clear()\n        self._needs_save = False\n        self._started = False\n        self._expire_cookie = True\n        self._send_cookie = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, key):\n        self._started = self._backend_client.load()\n        self._needs_save = True\n\n        return self._backend_client.get(key)", "response": "Retrieve a value from the session dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cors_wrapper(func):\n    def _setdefault(obj, key, value):\n        if value == None:\n            return\n        obj.setdefault(key, value)\n\n    def output(*args, **kwargs):\n        response = func(*args, **kwargs)\n        headers = response.headers\n        _setdefault(headers, \"Access-Control-Allow-Origin\", \"*\")\n        _setdefault(headers, \"Access-Control-Allow-Headers\", flask.request.headers.get(\"Access-Control-Request-Headers\"))\n        _setdefault(headers, \"Access-Control-Allow-Methods\", flask.request.headers.get(\"Access-Control-Request-Methods\"))\n        _setdefault(headers, \"Content-Type\", \"application/json\")\n        _setdefault(headers, \"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains; preload\")\n        return response\n\n    output.provide_automatic_options = False\n    output.__name__ = func.__name__\n    return output", "response": "Decorator for CORS\n    :param func:  Flask method that handles requests and returns a response\n    :return: Same, but with permissive CORS headers set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dockerflow(flask_app, backend_check):\n    global VERSION_JSON\n\n    try:\n        VERSION_JSON = File(\"version.json\").read_bytes()\n\n        @cors_wrapper\n        def version():\n            return Response(\n                VERSION_JSON,\n                status=200,\n                headers={\n                    \"Content-Type\": \"application/json\"\n                }\n            )\n\n        @cors_wrapper\n        def heartbeat():\n            try:\n                backend_check()\n                return Response(status=200)\n            except Exception as e:\n                Log.warning(\"heartbeat failure\", cause=e)\n                return Response(\n                    unicode2utf8(value2json(e)),\n                    status=500,\n                    headers={\n                        \"Content-Type\": \"application/json\"\n                    }\n                )\n\n        @cors_wrapper\n        def lbheartbeat():\n            return Response(status=200)\n\n        flask_app.add_url_rule(str('/__version__'), None, version, defaults={}, methods=[str('GET'), str('POST')])\n        flask_app.add_url_rule(str('/__heartbeat__'), None, heartbeat, defaults={}, methods=[str('GET'), str('POST')])\n        flask_app.add_url_rule(str('/__lbheartbeat__'), None, lbheartbeat, defaults={}, methods=[str('GET'), str('POST')])\n    except Exception as e:\n        Log.error(\"Problem setting up listeners for dockerflow\", cause=e)", "response": "A wrapper for the Dockerflow app that handles the containerized app requirements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new percolator associated with the new collection.", "response": "def new_collection_percolator(target):\n    \"\"\"Create new percolator associated with the new collection.\n\n    :param target: Collection where the percolator will be atached.\n    \"\"\"\n    query = IQ(target.dbquery)\n    for name in current_search.mappings.keys():\n        if target.name and target.dbquery:\n            current_search.client.index(\n                index=name,\n                doc_type='.percolator',\n                id='collection-{}'.format(target.name),\n                body={'query': query.to_dict()}\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_collection_percolator(target):\n    for name in current_search.mappings.keys():\n        if target.name and target.dbquery:\n            current_search.client.delete(\n                index=name,\n                doc_type='.percolator',\n                id='collection-{}'.format(target.name),\n                ignore=[404]\n            )", "response": "Delete percolator associated with the new collection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate percolator when collection is created.", "response": "def collection_updated_percolator(mapper, connection, target):\n    \"\"\"Create percolator when collection is created.\n\n    :param mapper: Not used. It keeps the function signature.\n    :param connection: Not used. It keeps the function signature.\n    :param target: Collection where the percolator should be updated.\n    \"\"\"\n    delete_collection_percolator(target)\n    if target.dbquery is not None:\n        new_collection_percolator(target)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind matching collections with percolator engine.", "response": "def _find_matching_collections_externally(collections, record):\n    \"\"\"Find matching collections with percolator engine.\n\n    :param collections: set of collections where search\n    :param record: record to match\n    \"\"\"\n    index, doc_type = RecordIndexer().record_to_index(record)\n    body = {\"doc\": record.dumps()}\n    results = current_search_client.percolate(\n        index=index,\n        doc_type=doc_type,\n        allow_no_indices=True,\n        ignore_unavailable=True,\n        body=body\n    )\n    prefix_len = len('collection-')\n    for match in results['matches']:\n        collection_name = match['_id']\n        if collection_name.startswith('collection-'):\n            name = collection_name[prefix_len:]\n            if name in collections:\n                yield collections[name]['ancestors']\n    raise StopIteration"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn A list of all LEAVES IN THE dictionary", "response": "def leaves(value, prefix=None):\n    \"\"\"\n    LIKE items() BUT RECURSIVE, AND ONLY FOR THE LEAVES (non dict) VALUES\n    SEE wrap_leaves FOR THE INVERSE\n\n    :param value: THE Mapping TO TRAVERSE\n    :param prefix:  OPTIONAL PREFIX GIVEN TO EACH KEY\n    :return: Data, WHICH EACH KEY BEING A PATH INTO value TREE\n    \"\"\"\n    prefix = coalesce(prefix, \"\")\n    output = []\n    for k, v in value.items():\n        try:\n            if _get(v, CLASS) in data_types:\n                output.extend(leaves(v, prefix=prefix + literal_field(k) + \".\"))\n            else:\n                output.append((prefix + literal_field(k), unwrap(v)))\n        except Exception as e:\n            get_logger().error(\"Do not know how to handle\", cause=e)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _str(value, depth):\n    output = []\n    if depth >0 and _get(value, CLASS) in data_types:\n        for k, v in value.items():\n            output.append(str(k) + \"=\" + _str(v, depth - 1))\n        return \"{\" + \",\\n\".join(output) + \"}\"\n    elif depth >0 and is_list(value):\n        for v in value:\n            output.append(_str(v, depth-1))\n        return \"[\" + \",\\n\".join(output) + \"]\"\n    else:\n        return str(type(value))", "response": "Returns a string representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn A list of all LEAVES IN THE ENTRY", "response": "def leaves(self, prefix=None):\n        \"\"\"\n        LIKE items() BUT RECURSIVE, AND ONLY FOR THE LEAVES (non dict) VALUES\n        \"\"\"\n        prefix = coalesce(prefix, \"\")\n        output = []\n        for k, v in self.items():\n            if _get(v, CLASS) in data_types:\n                output.extend(wrap(v).leaves(prefix=prefix + literal_field(k) + \".\"))\n            else:\n                output.append((prefix + literal_field(k), v))\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a value ensure that it is serialized properly", "response": "def serialize_value(self, value):\n        \"\"\"\n        Given a value, ensure that it is serialized properly\n        :param value:\n        :return:\n        \"\"\"\n        # Create a list of serialize methods to run the value through\n        serialize_methods = [\n            self.serialize_model,\n            self.serialize_json_string,\n            self.serialize_list,\n            self.serialize_dict\n        ]\n\n        # Run all of our serialize methods over our value\n        for serialize_method in serialize_methods:\n            value = serialize_method(value)\n\n        # Return the serialized context value\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialize_model(self, value):\n\n        # Check if the context value is a model\n        if not isinstance(value, models.Model):\n            return value\n\n        # Serialize the model\n        serialized_model = model_to_dict(value)\n\n        # Check the model for cached foreign keys\n        for model_field, model_value in serialized_model.items():\n            model_state = value._state\n\n            # Django >= 2\n            if hasattr(model_state, 'fields_cache'):  # pragma: no cover\n                if model_state.fields_cache.get(model_field):\n                    serialized_model[model_field] = model_state.fields_cache.get(model_field)\n            else:  # pragma: no cover\n                # Django < 2\n                cache_field = '_{0}_cache'.format(model_field)\n                if hasattr(value, cache_field):\n                    serialized_model[model_field] = getattr(value, cache_field)\n\n        # Return the serialized model\n        return self.serialize_value(serialized_model)", "response": "Serializes a model and all of its prefetched foreign keys\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serialize_json_string(self, value):\n\n        # Check if the value might be a json string\n        if not isinstance(value, six.string_types):\n            return value\n\n        # Make sure it starts with a brace\n        if not value.startswith('{') or value.startswith('['):\n            return value\n\n        # Try to load the string\n        try:\n            return json.loads(value)\n        except:\n            return value", "response": "Tries to load an encoded json string into an object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize a list of values", "response": "def serialize_list(self, value):\n        \"\"\"\n        Ensure that all values of a list or tuple are serialized\n        :return:\n        \"\"\"\n\n        # Check if this is a list or a tuple\n        if not isinstance(value, (list, tuple)):\n            return value\n\n        # Loop over all the values and serialize the values\n        return [\n            self.serialize_value(list_value)\n            for list_value in value\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serialize_dict(self, value):\n\n        # Check if this is a dict\n        if not isinstance(value, dict):\n            return value\n\n        # Loop over all the values and serialize them\n        return {\n            dict_key: self.serialize_value(dict_value)\n            for dict_key, dict_value in value.items()\n        }", "response": "Ensure that all values of a dictionary are properly serialized"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cache(self):\n        cache = self._cache or self.app.config.get('COLLECTIONS_CACHE')\n        return import_string(cache) if isinstance(cache, six.string_types) \\\n            else cache", "response": "Return a cache instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting list of collections.", "response": "def collections(self):\n        \"\"\"Get list of collections.\"\"\"\n        # if cache server is configured, load collection from there\n        if self.cache:\n            return self.cache.get(\n                self.app.config['COLLECTIONS_CACHE_KEY'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collections(self, values):\n        # if cache server is configured, save collection list\n        if self.cache:\n            self.cache.set(\n                self.app.config['COLLECTIONS_CACHE_KEY'], values)", "response": "Set list of collections."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering signals to update record and collection.", "response": "def register_signals(self):\n        \"\"\"Register signals.\"\"\"\n        from .models import Collection\n        from .receivers import CollectionUpdater\n\n        if self.app.config['COLLECTIONS_USE_PERCOLATOR']:\n            from .percolator import collection_inserted_percolator, \\\n                collection_removed_percolator, \\\n                collection_updated_percolator\n            # Register collection signals to update percolators\n            listen(Collection, 'after_insert',\n                   collection_inserted_percolator)\n            listen(Collection, 'after_update',\n                   collection_updated_percolator)\n            listen(Collection, 'after_delete',\n                   collection_removed_percolator)\n        # Register Record signals to update record['_collections']\n        self.update_function = CollectionUpdater(app=self.app)\n        signals.before_record_insert.connect(self.update_function,\n                                             weak=False)\n        signals.before_record_update.connect(self.update_function,\n                                             weak=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _post_vote(user_bingo_board, field, vote):\n\n    if field.board != user_bingo_board:\n        raise VoteException(\n            \"the voted field does not belong to the user's BingoBoard\")\n\n    if vote == \"0\":\n        field.vote = 0\n    elif vote == \"+\":\n        field.vote = +1\n    elif vote == \"-\":\n        field.vote = -1\n    field.save()\n\n    # update last_used with current timestamp\n    game = user_bingo_board.game\n    Game.objects.filter(id=game.id).update(\n        last_used=times.now())\n\n    # invalidate vote cache\n    vote_counts_cachename = 'vote_counts_game={0:d}'.format(\n        field.board.game.id)\n    cache.delete(vote_counts_cachename)\n\n    # publish the new vote counts for server-sent events\n    if USE_SSE:\n        try:\n            votes = field.num_votes()\n            redis.publish(\"word_votes\", json.dumps({\n                'site_id': game.site.id,\n                'word_id': field.word.id,\n                'vote_count': votes,\n            }))\n            redis.publish(\"field_vote\", json.dumps({\n                'site_id': game.site.id,\n                'field_id': field.id,\n                'vote': vote,\n            }))\n        except RedisConnectionError:\n            # redis server not available?\n            pass", "response": "Post a vote on a BingoField."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef translate_exception(exc_info, initial_skip=0):\n    tb = exc_info[2]\n    frames = []\n\n    # skip some internal frames if wanted\n    for x in range(initial_skip):\n        if tb is not None:\n            tb = tb.tb_next\n    initial_tb = tb\n\n    while tb is not None:\n        # skip frames decorated with @internalcode.  These are internal\n        # calls we can't avoid and that are useless in template debugging\n        # output.\n        if tb.tb_frame.f_code in internal_code:\n            tb = tb.tb_next\n            continue\n\n        # save a reference to the next frame if we override the current\n        # one with a faked one.\n        next = tb.tb_next\n\n        # fake template exceptions\n        template = tb.tb_frame.f_globals.get('__TK_template_info__')\n        if template is not None:\n            lineno = template.get_corresponding_lineno(tb.tb_lineno)\n            tb = fake_exc_info(exc_info[:2] + (tb,), template.filename,\n                               lineno)[2]\n\n        frames.append(make_frame_proxy(tb))\n        tb = next\n\n    # if we don't have any exceptions in the frames left, we have to reraise it unchanged. XXX: can we backup here?  when could this happen?\n    if not frames:\n        reraise(exc_info[0], exc_info[1], exc_info[2])\n\n    return ProcessedTraceback(exc_info[0], exc_info[1], frames)", "response": "Translate an exception into a new exception tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split_qs(string, delimiter='&'):\n\n    open_list = '[<{('\n    close_list = ']>})'\n    quote_chars = '\"\\''\n\n    level = index = last_index = 0\n    quoted = False\n    result = []\n\n    for index, letter in enumerate(string):\n        if letter in quote_chars:\n            if not quoted:\n                quoted = True\n                level += 1\n            else:\n                quoted = False\n                level -= 1\n        elif letter in open_list:\n            level += 1\n        elif letter in close_list:\n                level -= 1\n        elif letter == delimiter and level == 0:\n            # Split here\n            element = string[last_index: index]\n            if element:\n                result.append(element)\n            last_index = index + 1\n\n    if index:\n        element = string[last_index: index + 1]\n        if element:\n            result.append(element)\n\n    return result", "response": "Split a string by the specified unquoted not enclosed delimiter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_qs(string):\n    result = {}\n\n    for item in split_qs(string):\n        # Split the query string by unquotes ampersants ('&')\n        try:\n            # Split the item by unquotes equal signs\n            key, value = split_qs(item, delimiter='=')\n        except ValueError:\n            # Single value without equals sign\n            result[item] = ''\n        else:\n            result[key] = value\n\n    return result", "response": "Intelligently parse the query string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrounding TO GIVEN NUMBER OF DIGITS OR GIVEN NUMBER OF DECIMAL PLACES OR GIVEN NUMBER OF DECIMAL PLACES AFTER DECIMAL POINT", "response": "def round(value, decimal=7, digits=None):\n    \"\"\"\n    ROUND TO GIVEN NUMBER OF DIGITS, OR GIVEN NUMBER OF DECIMAL PLACES\n    decimal - NUMBER OF DIGITS AFTER DECIMAL POINT (NEGATIVE IS VALID)\n    digits - NUMBER OF SIGNIFICANT DIGITS (LESS THAN 1 IS INVALID)\n    \"\"\"\n    if value == None:\n        return None\n    else:\n        value = float(value)\n\n    if digits != None:\n        if digits <= 0:\n            if value == 0:\n                return int(_round(value, digits))\n            try:\n                m = pow(10, math_ceil(math_log10(abs(value))))\n                return int(_round(value / m, digits) * m)\n            except Exception as e:\n                from mo_logs import Log\n\n                Log.error(\"not expected\", e)\n        else:\n            if value == 0:\n                return _round(value, digits)\n            try:\n                m = pow(10, math_ceil(math_log10(abs(value))))\n                return _round(value / m, digits) * m\n            except Exception as e:\n                from mo_logs import Log\n                Log.error(\"not expected\", e)\n    elif decimal <= 0:\n        return int(_round(value, decimal))\n    else:\n        return _round(value, decimal)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfloor value to mod.", "response": "def floor(value, mod=1):\n    \"\"\"\n    x == floor(x, a) + mod(x, a)  FOR ALL a, x\n    RETURN None WHEN GIVEN INVALID ARGUMENTS\n    \"\"\"\n    if value == None:\n        return None\n    elif mod <= 0:\n        return None\n    elif mod == 1:\n        return int(math_floor(value))\n    elif is_integer(mod):\n        return int(math_floor(value / mod)) * mod\n    else:\n        return math_floor(value / mod) * mod"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mod(value, mod=1):\n    if value == None:\n        return None\n    elif mod <= 0:\n        return None\n    elif value < 0:\n        return (value % mod + mod) % mod\n    else:\n        return value % mod", "response": "Returns the value in the alphabetical order mod."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning SMALLEST INTEGER GREATER THAN value", "response": "def ceiling(value, mod=1):\n    \"\"\"\n    RETURN SMALLEST INTEGER GREATER THAN value\n    \"\"\"\n    if value == None:\n        return None\n    mod = int(mod)\n\n    v = int(math_floor(value + mod))\n    return v - (v % mod)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef MAX(values, *others):\n\n    if others:\n        from mo_logs import Log\n        Log.warning(\"Calling wrong\")\n        return MAX([values] + list(others))\n\n    output = Null\n    for v in values:\n        if v == None:\n            continue\n        elif output == None or v > output:\n            output = v\n        else:\n            pass\n    return output", "response": "MAX - function that returns the maximum value of a list of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef DataLookup(fieldVal, db, lookupType, fieldName, histObj={}):\n\n    if lookupType == 'genericLookup':\n        lookup_dict = {\"find\": _DataClean_(fieldVal)}\n    elif lookupType in ['fieldSpecificLookup', 'normLookup']:\n        lookup_dict = {\"fieldName\": fieldName, \"find\": _DataClean_(fieldVal)}\n    else:\n        raise ValueError(\"Invalid lookupType\")\n\n    field_val_new = fieldVal\n\n    coll = db[lookupType]\n\n    l_val = coll.find_one(lookup_dict, ['replace'])\n\n    if l_val:\n        field_val_new = l_val['replace'] if 'replace' in l_val else ''\n\n    change = _CollectHistory_(lookupType=lookupType, fromVal=fieldVal,\n                              toVal=field_val_new)\n\n    hist_obj_upd = _CollectHistoryAgg_(contactHist=histObj,\n                                       fieldHistObj=change,\n                                       fieldName=fieldName)\n\n    return field_val_new, hist_obj_upd", "response": "Perform single - value lookup against MongoDB."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn new field value based on whether or not original value includes AND excludes all words in a comma - delimited list queried from MongoDB", "response": "def IncludesLookup(fieldVal, lookupType, db, fieldName, deriveFieldName='',\n                   deriveInput={}, histObj={}, overwrite=False,\n                   blankIfNoMatch=False):\n    \"\"\"\n    Return new field value based on whether or not original value includes AND\n    excludes all words in a comma-delimited list queried from MongoDB\n\n    :param string fieldVal: input value to lookup\n    :param string lookupType: Type of lookup to perform/MongoDB collection name.\n           One of 'normIncludes', 'deriveIncludes'\n    :param MongoClient db: MongoClient instance connected to MongoDB\n    :param string fieldName: Field name to query against\n    :param string deriveFieldName: Field name from which to derive value\n    :param dict deriveInput: Values to perform lookup against:\n           {\"deriveFieldName\": \"deriveVal1\"}\n    :param dict histObj: History object to which changes should be appended\n    :param bool overwrite: Should an existing field value be replaced\n    :param bool blankIfNoMatch: Should field value be set to blank if\n           no match is found\n    \"\"\"\n\n    lookup_dict = {\n        'fieldName': fieldName\n    }\n\n    if lookupType == 'normIncludes':\n        field_val_clean = _DataClean_(fieldVal)\n\n    elif lookupType == 'deriveIncludes':\n\n        if deriveFieldName == '' or deriveInput == {}:\n            raise ValueError(\"for 'deriveIncludes' must specify both \\\n                              'deriveFieldName' and 'deriveInput'\")\n\n        lookup_dict['deriveFieldName'] = deriveFieldName\n        field_val_clean = _DataClean_(deriveInput[list(deriveInput.keys())[0]])\n    else:\n        raise ValueError(\"Invalid lookupType\")\n\n    field_val_new = fieldVal\n    check_match = False\n    using = {}\n\n    coll = db[lookupType]\n\n    inc_val = coll.find(lookup_dict, ['includes', 'excludes', 'begins', 'ends',\n                                      'replace'])\n\n    if inc_val and (lookupType == 'normIncludes' or\n                    (lookupType == 'deriveIncludes' and\n                     (overwrite or fieldVal == ''))):\n\n        for row in inc_val:\n\n            try:\n\n                if (row['includes'] != '' or\n                        row['excludes'] != '' or\n                        row['begins'] != '' or\n                        row['ends'] != ''):\n\n                    if all((a in field_val_clean)\n                           for a in row['includes'].split(\",\")):\n\n                        if all((b not in field_val_clean)\n                               for b in row['excludes'].split(\",\")) \\\n                                or row['excludes'] == '':\n\n                            if field_val_clean.startswith(row['begins']):\n\n                                if field_val_clean.endswith(row['ends']):\n\n                                    field_val_new = row['replace']\n\n                                    if lookupType == 'deriveIncludes':\n                                        using[deriveFieldName] = deriveInput\n\n                                    using['includes'] = row['includes']\n                                    using['excludes'] = row['excludes']\n                                    using['begins'] = row['begins']\n                                    using['ends'] = row['ends']\n\n                                    check_match = True\n\n                                    break\n\n            except KeyError as Key_error_obj:\n                warnings.warn('schema error', Key_error_obj)\n\n        if inc_val:\n            inc_val.close()\n\n    if (field_val_new == fieldVal and blankIfNoMatch and\n            lookupType == 'deriveIncludes'):\n        field_val_new = ''\n        using['blankIfNoMatch'] = 'no match found'\n\n    change = _CollectHistory_(lookupType=lookupType, fromVal=fieldVal,\n                              toVal=field_val_new, using=using)\n\n    histObjUpd = _CollectHistoryAgg_(contactHist=histObj, fieldHistObj=change,\n                                     fieldName=fieldName)\n\n    return field_val_new, histObjUpd, check_match"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new field value based on match against regex queried from MongoDB :param string fieldVal: input value to lookup :param MongoClient db: MongoClient instance connected to MongoDB :param string lookupType: Type of lookup to perform/MongoDB collection name. One of 'genericRegex', 'fieldSpecificRegex', 'normRegex' :param string fieldName: Field name to query against :param dict histObj: History object to which changes should be appended", "response": "def RegexLookup(fieldVal, db, fieldName, lookupType, histObj={}):\n    \"\"\"\n    Return a new field value based on match against regex queried from MongoDB\n\n    :param string fieldVal: input value to lookup\n    :param MongoClient db: MongoClient instance connected to MongoDB\n    :param string lookupType: Type of lookup to perform/MongoDB collection name.\n            One of 'genericRegex', 'fieldSpecificRegex', 'normRegex'\n    :param string fieldName: Field name to query against\n    :param dict histObj: History object to which changes should be appended\n    \"\"\"\n\n    if lookupType == 'genericRegex':\n        lookup_dict = {}\n    elif lookupType in ['fieldSpecificRegex', 'normRegex']:\n        lookup_dict = {\"fieldName\": fieldName}\n    else:\n        raise ValueError(\"Invalid type\")\n\n    field_val_new = fieldVal\n    pattern = ''\n\n    coll = db[lookupType]\n\n    re_val = coll.find(lookup_dict, ['pattern', 'replace'])\n\n    for row in re_val:\n\n        try:\n            match = re.match(row['pattern'], _DataClean_(field_val_new),\n                             flags=re.IGNORECASE)\n\n            if match:\n\n                if 'replace' in row:\n                    field_val_new = re.sub(row['pattern'], row['replace'],\n                                           _DataClean_(field_val_new),\n                                           flags=re.IGNORECASE)\n                else:\n                    field_val_new = re.sub(row['pattern'], '',\n                                           _DataClean_(field_val_new),\n                                           flags=re.IGNORECASE)\n\n                pattern = row['pattern']\n                break\n\n        except KeyError as Key_error_obj:\n            warnings.warn('schema error', Key_error_obj)\n\n    if re_val:\n        re_val.close()\n\n    change = _CollectHistory_(lookupType=lookupType, fromVal=fieldVal,\n                              toVal=field_val_new, pattern=pattern)\n\n    histObjUpd = _CollectHistoryAgg_(contactHist=histObj, fieldHistObj=change,\n                                     fieldName=fieldName)\n\n    return field_val_new, histObjUpd"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nderiving a value from a single or multi - value field.", "response": "def DeriveDataLookup(fieldName, db, deriveInput, overwrite=True, fieldVal='',\n                     histObj={}, blankIfNoMatch=False):\n    \"\"\"\n    Return new field value based on single or multi-value lookup against MongoDB\n\n    :param string fieldName: Field name to query against\n    :param MongoClient db: MongoClient instance connected to MongoDB\n    :param dict deriveInput: Values to perform lookup against:\n           {\"lookupField1\": \"lookupVal1\", \"lookupField2\": \"lookupVal2\"}\n    :param bool overwrite: Should an existing field value be replaced\n    :param string fieldVal: Current field value\n    :param dict histObj: History object to which changes should be appended\n    :param bool blankIfNoMatch: Should field value be set to blank\n           if no match is found\n    \"\"\"\n\n    lookup_vals = OrderedDict()\n\n    for val in sorted(deriveInput.keys()):\n        lookup_vals[val] = _DataClean_(deriveInput[val])\n\n    lookup_dict = {\n        'fieldName': fieldName,\n        'lookupVals': lookup_vals\n    }\n\n    coll = db['deriveValue']\n\n    l_val = coll.find_one(lookup_dict, ['value'])\n\n    field_val_new = fieldVal\n\n    derive_using = deriveInput\n\n    # If match found return True else False\n    check_match = True if l_val else False\n\n    if l_val and (overwrite or (fieldVal == '')):\n\n        try:\n            field_val_new = l_val['value']\n        except KeyError as Key_error_obj:\n            warnings.warn('schema error', Key_error_obj)\n\n    elif blankIfNoMatch and not l_val:\n\n        field_val_new = ''\n        derive_using = {'blankIfNoMatch': 'no match found'}\n\n    change = _CollectHistory_(lookupType='deriveValue', fromVal=fieldVal,\n                              toVal=field_val_new, using=derive_using)\n\n    hist_obj_upd = _CollectHistoryAgg_(contactHist=histObj, fieldHistObj=change,\n                                       fieldName=fieldName)\n\n    return field_val_new, hist_obj_upd, check_match"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nderive a value from another field in the current node.", "response": "def DeriveDataCopyValue(fieldName, deriveInput, overwrite, fieldVal, histObj={}):\n    \"\"\"\n    Return new value based on value from another field\n\n    :param string fieldName: Field name to query against\n    :param dict deriveInput: Values to perform lookup against:\n           {\"copyField1\": \"copyVal1\"}\n    :param bool overwrite: Should an existing field value be replaced\n    :param string fieldVal: Current field value\n    :param dict histObj: History object to which changes should be appended\n    \"\"\"\n\n    if len(deriveInput) > 1:\n        raise Exception(\"more than one field/value in deriveInput\")\n\n    field_val_new = fieldVal\n\n    row = list(deriveInput.keys())[0]\n\n    if deriveInput[row] != '' and (overwrite or (fieldVal == '')):\n        field_val_new = deriveInput[row]\n        check_match = True\n    else:\n        check_match = False\n\n    change = _CollectHistory_(lookupType='copyValue', fromVal=fieldVal,\n                              toVal=field_val_new, using=deriveInput)\n\n    hist_obj_upd = _CollectHistoryAgg_(contactHist=histObj, fieldHistObj=change,\n                                       fieldName=fieldName)\n\n    return field_val_new, hist_obj_upd, check_match"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nderive a new value from a field value based on a regular expression.", "response": "def DeriveDataRegex(fieldName, db, deriveInput, overwrite, fieldVal, histObj={},\n                    blankIfNoMatch=False):\n    \"\"\"\n    Return a new field value based on match (of another field) against regex\n    queried from MongoDB\n\n    :param string fieldName: Field name to query against\n    :param MongoClient db: MongoClient instance connected to MongoDB\n    :param dict deriveInput: Values to perform lookup against:\n           {\"lookupField1\": \"lookupVal1\"}\n    :param bool overwrite: Should an existing field value be replaced\n    :param string fieldVal: Current field value\n    :param dict histObj: History object to which changes should be appended\n    :param bool blankIfNoMatch: Should field value be set to blank\n           if no match is found\n    \"\"\"\n\n    if len(deriveInput) > 1:\n        raise Exception(\"more than one value in deriveInput\")\n\n    field_val_new = fieldVal\n    check_match = False\n\n    # derive_using = deriveInput\n\n    row = list(deriveInput.keys())[0]\n\n    pattern = ''\n\n    if deriveInput[row] != '' and (overwrite or (fieldVal == '')):\n\n        lookup_dict = {\n            'deriveFieldName': row,\n            'fieldName': fieldName\n        }\n\n        coll = db['deriveRegex']\n\n        re_val = coll.find(lookup_dict, ['pattern', 'replace'])\n\n        for l_val in re_val:\n\n            try:\n\n                match = re.match(l_val['pattern'],\n                                 _DataClean_(deriveInput[row]),\n                                 flags=re.IGNORECASE)\n\n                if match:\n\n                    field_val_new = re.sub(l_val['pattern'], l_val['replace'],\n                                           _DataClean_(deriveInput[row]),\n                                           flags=re.IGNORECASE)\n\n                    pattern = l_val['pattern']\n\n                    check_match = True\n                    break\n\n            except KeyError as key_error_obj:\n                warnings.warn('schema error', key_error_obj)\n\n        if re_val:\n            re_val.close()\n\n        if field_val_new == fieldVal and blankIfNoMatch:\n            field_val_new = ''\n            pattern = 'no matching pattern'\n            # derive_using = {\"blankIfNoMatch\": \"no match found\"}\n\n    change = _CollectHistory_(lookupType='deriveRegex', fromVal=fieldVal,\n                              toVal=field_val_new, using=deriveInput,\n                              pattern=pattern)\n\n    hist_obj_upd = _CollectHistoryAgg_(contactHist=histObj, fieldHistObj=change,\n                                       fieldName=fieldName)\n\n    return field_val_new, hist_obj_upd, check_match"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _normalize_select(select, frum, schema=None):\n    if not _Column:\n        _late_import()\n\n    if is_text(select):\n        canonical = select = Data(value=select)\n    else:\n        select = wrap(select)\n        canonical = select.copy()\n\n    canonical.aggregate = coalesce(canonical_aggregates[select.aggregate].name, select.aggregate, \"none\")\n    canonical.default = coalesce(select.default, canonical_aggregates[canonical.aggregate].default)\n\n    if hasattr(unwrap(frum), \"_normalize_select\"):\n        return frum._normalize_select(canonical)\n\n    output = []\n    if not select.value or select.value == \".\":\n        output.extend([\n            set_default(\n                {\n                    \"name\": c.name,\n                    \"value\": jx_expression(c.name, schema=schema)\n                },\n                canonical\n            )\n            for c in frum.get_leaves()\n        ])\n    elif is_text(select.value):\n        if select.value.endswith(\".*\"):\n            canonical.name = coalesce(select.name, \".\")\n            value = jx_expression(select[:-2], schema=schema)\n            if not is_op(value, Variable):\n                Log.error(\"`*` over general expression not supported yet\")\n                output.append([\n                    set_default(\n                        {\n                            \"value\": LeavesOp(value, prefix=select.prefix),\n                            \"format\": \"dict\"  # MARKUP FOR DECODING\n                        },\n                        canonical\n                    )\n                    for c in frum.get_columns()\n                    if c.jx_type not in STRUCT\n                ])\n            else:\n                Log.error(\"do not know what to do\")\n        else:\n            canonical.name = coalesce(select.name, select.value, select.aggregate)\n            canonical.value = jx_expression(select.value, schema=schema)\n            output.append(canonical)\n\n    output = wrap(output)\n    if any(n==None for n in output.name):\n        Log.error(\"expecting select to have a name: {{select}}\", select=select)\n    return output", "response": "Normalizes a single SELECT column."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _normalize_select_no_context(select, schema=None):\n    if not _Column:\n        _late_import()\n\n    if is_text(select):\n        select = Data(value=select)\n    else:\n        select = wrap(select)\n\n    output = select.copy()\n    if not select.value:\n        output.name = coalesce(select.name, select.aggregate)\n        if output.name:\n            output.value = jx_expression(\".\", schema=schema)\n        else:\n            return Null\n    elif is_text(select.value):\n        if select.value.endswith(\".*\"):\n            name = select.value[:-2].lstrip(\".\")\n            output.name = coalesce(select.name,  name)\n            output.value = LeavesOp(Variable(name), prefix=coalesce(select.prefix, name))\n        else:\n            if select.value == \".\":\n                output.name = coalesce(select.name, select.aggregate, \".\")\n                output.value = jx_expression(select.value, schema=schema)\n            elif select.value == \"*\":\n                output.name = coalesce(select.name, select.aggregate, \".\")\n                output.value = LeavesOp(Variable(\".\"))\n            else:\n                output.name = coalesce(select.name, select.value.lstrip(\".\"), select.aggregate)\n                output.value = jx_expression(select.value, schema=schema)\n    elif is_number(output.value):\n        if not output.name:\n            output.name = text_type(output.value)\n        output.value = jx_expression(select.value, schema=schema)\n    else:\n        output.value = jx_expression(select.value, schema=schema)\n\n    if not output.name:\n        Log.error(\"expecting select to have a name: {{select}}\",  select= select)\n    if output.name.endswith(\".*\"):\n        Log.error(\"{{name|quote}} is invalid select\", name=output.name)\n\n    output.aggregate = coalesce(canonical_aggregates[select.aggregate].name, select.aggregate, \"none\")\n    output.default = coalesce(select.default, canonical_aggregates[output.aggregate].default)\n    return output", "response": "Normalizes a select that does not have a context."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnormalizing a single edge into a list of Data objects.", "response": "def _normalize_edge(edge, dim_index, limit, schema=None):\n    \"\"\"\n    :param edge: Not normalized edge\n    :param dim_index: Dimensions are ordered; this is this edge's index into that order\n    :param schema: for context\n    :return: a normalized edge\n    \"\"\"\n    if not _Column:\n        _late_import()\n\n    if not edge:\n        Log.error(\"Edge has no value, or expression is empty\")\n    elif is_text(edge):\n        if schema:\n            leaves = unwraplist(list(schema.leaves(edge)))\n            if not leaves or is_container(leaves):\n                return [\n                    Data(\n                        name=edge,\n                        value=jx_expression(edge, schema=schema),\n                        allowNulls=True,\n                        dim=dim_index,\n                        domain=_normalize_domain(None, limit)\n                    )\n                ]\n            elif isinstance(leaves, _Column):\n                return [Data(\n                    name=edge,\n                    value=jx_expression(edge, schema=schema),\n                    allowNulls=True,\n                    dim=dim_index,\n                    domain=_normalize_domain(domain=leaves, limit=limit, schema=schema)\n                )]\n            elif is_list(leaves.fields) and len(leaves.fields) == 1:\n                return [Data(\n                    name=leaves.name,\n                    value=jx_expression(leaves.fields[0], schema=schema),\n                    allowNulls=True,\n                    dim=dim_index,\n                    domain=leaves.getDomain()\n                )]\n            else:\n                return [Data(\n                    name=leaves.name,\n                    allowNulls=True,\n                    dim=dim_index,\n                    domain=leaves.getDomain()\n                )]\n        else:\n            return [\n                Data(\n                    name=edge,\n                    value=jx_expression(edge, schema=schema),\n                    allowNulls=True,\n                    dim=dim_index,\n                    domain=DefaultDomain()\n                )\n            ]\n    else:\n        edge = wrap(edge)\n        if not edge.name and not is_text(edge.value):\n            Log.error(\"You must name compound and complex edges: {{edge}}\", edge=edge)\n\n        if is_container(edge.value) and not edge.domain:\n            # COMPLEX EDGE IS SHORT HAND\n            domain = _normalize_domain(schema=schema)\n            domain.dimension = Data(fields=edge.value)\n\n            return [Data(\n                name=edge.name,\n                value=jx_expression(edge.value, schema=schema),\n                allowNulls=bool(coalesce(edge.allowNulls, True)),\n                dim=dim_index,\n                domain=domain\n            )]\n\n        domain = _normalize_domain(edge.domain, schema=schema)\n\n        return [Data(\n            name=coalesce(edge.name, edge.value),\n            value=jx_expression(edge.value, schema=schema),\n            range=_normalize_range(edge.range),\n            allowNulls=bool(coalesce(edge.allowNulls, True)),\n            dim=dim_index,\n            domain=domain\n        )]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _normalize_group(edge, dim_index, limit, schema=None):\n    if is_text(edge):\n        if edge.endswith(\".*\"):\n            prefix = edge[:-2]\n            if schema:\n                output = wrap([\n                    {  # BECASUE THIS IS A GROUPBY, EARLY SPLIT INTO LEAVES WORKS JUST FINE\n                        \"name\": concat_field(prefix, literal_field(relative_field(untype_path(c.name), prefix))),\n                        \"put\": {\"name\": literal_field(untype_path(c.name))},\n                        \"value\": jx_expression(c.es_column, schema=schema),\n                        \"allowNulls\": True,\n                        \"domain\": {\"type\": \"default\"}\n                    }\n                    for c in schema.leaves(prefix)\n                ])\n                return output\n            else:\n                return wrap([{\n                    \"name\": untype_path(prefix),\n                    \"put\": {\"name\": literal_field(untype_path(prefix))},\n                    \"value\": LeavesOp(Variable(prefix)),\n                    \"allowNulls\": True,\n                    \"dim\":dim_index,\n                    \"domain\": {\"type\": \"default\"}\n                }])\n\n        return wrap([{\n            \"name\": edge,\n            \"value\": jx_expression(edge, schema=schema),\n            \"allowNulls\": True,\n            \"dim\": dim_index,\n            \"domain\": Domain(type=\"default\", limit=limit)\n        }])\n    else:\n        edge = wrap(edge)\n        if (edge.domain and edge.domain.type != \"default\") or edge.allowNulls != None:\n            Log.error(\"groupby does not accept complicated domains\")\n\n        if not edge.name and not is_text(edge.value):\n            Log.error(\"You must name compound edges: {{edge}}\",  edge= edge)\n\n        return wrap([{\n            \"name\": coalesce(edge.name, edge.value),\n            \"value\": jx_expression(edge.value, schema=schema),\n            \"allowNulls\": True,\n            \"dim\":dim_index,\n            \"domain\": {\"type\": \"default\"}\n        }])", "response": "This function normalizes a group by edge."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _map_term_using_schema(master, path, term, schema_edges):\n    output = FlatList()\n    for k, v in term.items():\n        dimension = schema_edges[k]\n        if isinstance(dimension, Dimension):\n            domain = dimension.getDomain()\n            if dimension.fields:\n                if is_data(dimension.fields):\n                    # EXPECTING A TUPLE\n                    for local_field, es_field in dimension.fields.items():\n                        local_value = v[local_field]\n                        if local_value == None:\n                            output.append({\"missing\": {\"field\": es_field}})\n                        else:\n                            output.append({\"term\": {es_field: local_value}})\n                    continue\n\n                if len(dimension.fields) == 1 and is_variable_name(dimension.fields[0]):\n                    # SIMPLE SINGLE-VALUED FIELD\n                    if domain.getPartByKey(v) is domain.NULL:\n                        output.append({\"missing\": {\"field\": dimension.fields[0]}})\n                    else:\n                        output.append({\"term\": {dimension.fields[0]: v}})\n                    continue\n\n                if AND(is_variable_name(f) for f in dimension.fields):\n                    # EXPECTING A TUPLE\n                    if not isinstance(v, tuple):\n                        Log.error(\"expecing {{name}}={{value}} to be a tuple\",  name= k,  value= v)\n                    for i, f in enumerate(dimension.fields):\n                        vv = v[i]\n                        if vv == None:\n                            output.append({\"missing\": {\"field\": f}})\n                        else:\n                            output.append({\"term\": {f: vv}})\n                    continue\n            if len(dimension.fields) == 1 and is_variable_name(dimension.fields[0]):\n                if domain.getPartByKey(v) is domain.NULL:\n                    output.append({\"missing\": {\"field\": dimension.fields[0]}})\n                else:\n                    output.append({\"term\": {dimension.fields[0]: v}})\n                continue\n            if domain.partitions:\n                part = domain.getPartByKey(v)\n                if part is domain.NULL or not part.esfilter:\n                    Log.error(\"not expected to get NULL\")\n                output.append(part.esfilter)\n                continue\n            else:\n                Log.error(\"not expected\")\n        elif is_data(v):\n            sub = _map_term_using_schema(master, path + [k], v, schema_edges[k])\n            output.append(sub)\n            continue\n\n        output.append({\"term\": {k: v}})\n    return {\"and\": output}", "response": "Map a term using a schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing THE SCHEMA TO CONVERT DIMENSION NAMES TO ES FILTERS master - TOP LEVEL WHERE (FOR PLACING NESTED FILTERS)", "response": "def _where_terms(master, where, schema):\n    \"\"\"\n    USE THE SCHEMA TO CONVERT DIMENSION NAMES TO ES FILTERS\n    master - TOP LEVEL WHERE (FOR PLACING NESTED FILTERS)\n    \"\"\"\n    if is_data(where):\n        if where.term:\n            # MAP TERM\n            try:\n                output = _map_term_using_schema(master, [], where.term, schema.edges)\n                return output\n            except Exception as e:\n                Log.error(\"programmer problem?\", e)\n        elif where.terms:\n            # MAP TERM\n            output = FlatList()\n            for k, v in where.terms.items():\n                if not is_container(v):\n                    Log.error(\"terms filter expects list of values\")\n                edge = schema.edges[k]\n                if not edge:\n                    output.append({\"terms\": {k: v}})\n                else:\n                    if is_text(edge):\n                        # DIRECT FIELD REFERENCE\n                        return {\"terms\": {edge: v}}\n                    try:\n                        domain = edge.getDomain()\n                    except Exception as e:\n                        Log.error(\"programmer error\", e)\n                    fields = domain.dimension.fields\n                    if is_data(fields):\n                        or_agg = []\n                        for vv in v:\n                            and_agg = []\n                            for local_field, es_field in fields.items():\n                                vvv = vv[local_field]\n                                if vvv != None:\n                                    and_agg.append({\"term\": {es_field: vvv}})\n                            or_agg.append({\"and\": and_agg})\n                        output.append({\"or\": or_agg})\n                    elif is_list(fields) and len(fields) == 1 and is_variable_name(fields[0]):\n                        output.append({\"terms\": {fields[0]: v}})\n                    elif domain.partitions:\n                        output.append({\"or\": [domain.getPartByKey(vv).esfilter for vv in v]})\n            return {\"and\": output}\n        elif where[\"or\"]:\n            return {\"or\": [unwrap(_where_terms(master, vv, schema)) for vv in where[\"or\"]]}\n        elif where[\"and\"]:\n            return {\"and\": [unwrap(_where_terms(master, vv, schema)) for vv in where[\"and\"]]}\n        elif where[\"not\"]:\n            return {\"not\": unwrap(_where_terms(master, where[\"not\"], schema))}\n    return where"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _normalize_sort(sort=None):\n\n    if sort==None:\n        return FlatList.EMPTY\n\n    output = FlatList()\n    for s in listwrap(sort):\n        if is_text(s):\n            output.append({\"value\": jx_expression(s), \"sort\": 1})\n        elif is_expression(s):\n            output.append({\"value\": s, \"sort\": 1})\n        elif mo_math.is_integer(s):\n            output.append({\"value\": jx_expression({\"offset\": s}), \"sort\": 1})\n        elif not s.sort and not s.value and all(d in sort_direction for d in s.values()):\n            for v, d in s.items():\n                output.append({\"value\": jx_expression(v), \"sort\": sort_direction[d]})\n        elif not s.sort and not s.value:\n            Log.error(\"`sort` clause must have a `value` property\")\n        else:\n            output.append({\"value\": jx_expression(coalesce(s.value, s.field)), \"sort\": sort_direction[s.sort]})\n    return output", "response": "CONVERT SORT PARAMETERS TO A NORMAL FORM SO EASIER TO USE\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a set of all variables in the current instance", "response": "def vars(self, exclude_where=False, exclude_select=False):\n        \"\"\"\n        :return: variables in query\n        \"\"\"\n        def edges_get_all_vars(e):\n            output = set()\n            if is_text(e.value):\n                output.add(e.value)\n            if is_expression(e.value):\n                output |= e.value.vars()\n            if e.domain.key:\n                output.add(e.domain.key)\n            if e.domain.where:\n                output |= e.domain.where.vars()\n            if e.range:\n                output |= e.range.min.vars()\n                output |= e.range.max.vars()\n            if e.domain.partitions:\n                for p in e.domain.partitions:\n                    if p.where:\n                        output |= p.where.vars()\n            return output\n\n        output = set()\n        try:\n            output |= self.frum.vars()\n        except Exception:\n            pass\n\n        if not exclude_select:\n            for s in listwrap(self.select):\n                output |= s.value.vars()\n        for s in listwrap(self.edges):\n            output |= edges_get_all_vars(s)\n        for s in listwrap(self.groupby):\n            output |= edges_get_all_vars(s)\n        if not exclude_where:\n            output |= self.where.vars()\n        for s in listwrap(self.sort):\n            output |= s.value.vars()\n\n        try:\n            output |= UNION(e.vars() for e in self.window)\n        except Exception:\n            pass\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wrap(query, container, namespace):\n        if is_op(query, QueryOp) or query == None:\n            return query\n\n        query = wrap(query)\n        table = container.get_table(query['from'])\n        schema = table.schema\n        output = QueryOp(\n            frum=table,\n            format=query.format,\n            limit=mo_math.min(MAX_LIMIT, coalesce(query.limit, DEFAULT_LIMIT))\n        )\n\n        if query.select or isinstance(query.select, (Mapping, list)):\n            output.select = _normalize_selects(query.select, query.frum, schema=schema)\n        else:\n            if query.edges or query.groupby:\n                output.select = DEFAULT_SELECT\n            else:\n                output.select = _normalize_selects(\".\", query.frum)\n\n        if query.groupby and query.edges:\n            Log.error(\"You can not use both the `groupby` and `edges` clauses in the same query!\")\n        elif query.edges:\n            output.edges = _normalize_edges(query.edges, limit=output.limit, schema=schema)\n            output.groupby = Null\n        elif query.groupby:\n            output.edges = Null\n            output.groupby = _normalize_groupby(query.groupby, limit=output.limit, schema=schema)\n        else:\n            output.edges = Null\n            output.groupby = Null\n\n        output.where = _normalize_where(query.where, schema=schema)\n        output.window = [_normalize_window(w) for w in listwrap(query.window)]\n        output.having = None\n        output.sort = _normalize_sort(query.sort)\n        if not mo_math.is_integer(output.limit) or output.limit < 0:\n            Log.error(\"Expecting limit >= 0\")\n\n        output.isLean = query.isLean\n\n        return output", "response": "Wraps a query into a QueryOp object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a cache_group with this manager.", "response": "def register_cache(self, cache_group):\n        \"\"\"\n        Register a cache_group with this manager.\n\n        Use this method to register more complicated\n        groups that you create yourself. Such as if you\n        need to register several models each with different\n        parameters.\n\n        :param cache_group: The group to register. \\\n        The group is registered with the cache_group key attribute. \\\n        Raises an exception if the key is already registered.\n        \"\"\"\n\n        if cache_group.key in self._registry:\n            raise Exception(\"%s is already registered\" % cache_group.key)\n        self._registry[cache_group.key] = cache_group"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_model(self, key, *models, **kwargs):\n\n        cache_group = CacheGroup(key)\n        for model in models:\n            cache_group.register(model, **kwargs)\n\n        self.register_cache(cache_group)", "response": "Register a model with this manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef invalidate_cache(self, klass, extra=None, **kwargs):\n\n        extra = extra or kwargs.pop('extra', {})\n        for group in self._registry.values():\n            if klass in group.models:\n                e = extra.get(group.key)\n                group.invalidate_cache(klass, extra=e, **kwargs)", "response": "Invalidate a cache for a specific class."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a prompt which implements the store feature.", "response": "def create_store_prompt(name):\n    \"\"\"Create a prompt which implements the `store` feature.\n\n    :param name: name of the generator\n    :return: prompt\n    \"\"\"\n    def _prompt(questions, answers=None, **kwargs):\n        stored_answers = _read_stored_answers(name)\n\n        to_store = []\n        for q in questions:\n            if 'store' in q:\n                if q.pop('store'):  # remove it so whaaaaat does not bark\n                    to_store.append(q['name'])\n                    if q['name'] in stored_answers:\n                        q['default'] = stored_answers[q['name']]\n\n        answers = prompt(questions, answers, **kwargs)\n        if to_store:\n            # save answers for questions flagged with 'store'\n            for s in to_store:\n                if s in answers:\n                    stored_answers[s] = answers[s]\n            _store_answers(name, stored_answers)\n        return answers\n    return _prompt"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef memoize(function):\n    _cache = {}\n    @wraps(function)\n    def wrapper(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in _cache:\n            _cache[key] = function(*args, **kwargs)\n        return _cache[key]\n    return wrapper", "response": "Memoizing function. Potentially not thread - safe since it will return\n            resuts across threads."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_inflators_bdf_to_cn(data_year):\n    '''\n    Calcule les ratios de calage (bdf sur cn pour ann\u00e9e de donn\u00e9es)\n    \u00e0 partir des masses de comptabilit\u00e9 nationale et des masses de consommation de bdf.\n    '''\n    data_cn = get_cn_aggregates(data_year)\n    data_bdf = get_bdf_aggregates(data_year)\n    masses = data_cn.merge(\n        data_bdf, left_index = True, right_index = True\n        )\n    masses.rename(columns = {'bdf_aggregates': 'conso_bdf{}'.format(data_year)}, inplace = True)\n    return (\n        masses['consoCN_COICOP_{}'.format(data_year)] / masses['conso_bdf{}'.format(data_year)]\n        ).to_dict()", "response": "Get the inflators bdf to cn"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the inflators of a given year from the data_years to the target_year.", "response": "def get_inflators_cn_to_cn(target_year):\n    '''\n        Calcule l'inflateur de vieillissement \u00e0 partir des masses de comptabilit\u00e9 nationale.\n    '''\n    data_year = find_nearest_inferior(data_years, target_year)\n    data_year_cn_aggregates = get_cn_aggregates(data_year)['consoCN_COICOP_{}'.format(data_year)].to_dict()\n    target_year_cn_aggregates = get_cn_aggregates(target_year)['consoCN_COICOP_{}'.format(target_year)].to_dict()\n\n    return dict(\n        (key, target_year_cn_aggregates[key] / data_year_cn_aggregates[key])\n        for key in data_year_cn_aggregates.keys()\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef map_to_array(pairs):\n    if pairs:\n        pairs = [TuidMap(*p) for p in pairs]\n        max_line = max(p.line for p in pairs)\n        tuids = [None] * max_line\n        for p in pairs:\n            if p.line:  # line==0 IS A PLACEHOLDER FOR FILES THAT DO NOT EXIST\n                tuids[p.line-1] = p.tuid\n        return tuids\n    else:\n        return None", "response": "Maps a list of TUIDs to a single array of TUIDS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dwmAll(data, db, configName='', config={}, udfNamespace=__name__, verbose=False):\n\n    if config=={} and configName=='':\n        raise Exception(\"Please either specify configName or pass a config\")\n\n    if config!={} and configName!='':\n        raise Exception(\"Please either specify configName or pass a config\")\n\n    if config=={}:\n        configColl = db['config']\n\n        config = configColl.find_one({\"configName\": configName})\n\n        if not config:\n            raise Exception(\"configName '\" + configName + \"' not found in collection 'config'\")\n\n    writeContactHistory = config[\"history\"][\"writeContactHistory\"]\n    returnHistoryId = config[\"history\"][\"returnHistoryId\"]\n    returnHistoryField = config[\"history\"][\"returnHistoryField\"]\n    histIdField = config[\"history\"][\"histIdField\"]\n\n    for field in config[\"fields\"]:\n\n        config[\"fields\"][field][\"derive\"] = OrderedDict(sorted(config[\"fields\"][field][\"derive\"].items()))\n\n    for position in config[\"userDefinedFunctions\"]:\n\n        config[\"userDefinedFunctions\"][position] = OrderedDict(sorted(config[\"userDefinedFunctions\"][position].items()))\n\n    if verbose:\n        for row in tqdm(data):\n            row, historyId = dwmOne(data=row, db=db, config=config, writeContactHistory=writeContactHistory, returnHistoryId=returnHistoryId, histIdField=histIdField, udfNamespace=udfNamespace)\n            if returnHistoryId and writeContactHistory:\n                row[returnHistoryField] = historyId\n    else:\n        for row in data:\n            row, historyId = dwmOne(data=row, db=db, config=config, writeContactHistory=writeContactHistory, returnHistoryId=returnHistoryId, histIdField=histIdField, udfNamespace=udfNamespace)\n            if returnHistoryId and writeContactHistory:\n                row[returnHistoryField] = historyId\n\n    return data", "response": "This function takes a list of dictionaries and returns a list of dictionaries after cleaning rules have been applied optionally with a history record ID appended."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a single dictionary (record) after cleaning rules have been applied; optionally insert history record to collection 'contactHistory' :param dict data: single record (dictionary) to which cleaning rules should be applied :param MongoClient db: MongoClient instance connected to MongoDB :param dict config: DWM configuration (see DataDictionary) :param bool writeContactHistory: Write field-level change history to collection 'contactHistory' :param bool returnHistoryId: If writeContactHistory, return '_id' of history record :param dict histIdField: Name of identifier for history record: {\"name\": \"emailAddress\", \"value\": \"emailAddress\"} :param namespace udfNamespace: namespace of current working script; must be passed if using user-defined functions", "response": "def dwmOne(data, db, config, writeContactHistory=True, returnHistoryId=True, histIdField={\"name\": \"emailAddress\", \"value\": \"emailAddress\"}, udfNamespace=__name__):\n    \"\"\"\n    Return a single dictionary (record) after cleaning rules have been applied; optionally insert history record to collection 'contactHistory'\n\n    :param dict data: single record (dictionary) to which cleaning rules should be applied\n    :param MongoClient db: MongoClient instance connected to MongoDB\n    :param dict config: DWM configuration (see DataDictionary)\n    :param bool writeContactHistory: Write field-level change history to collection 'contactHistory'\n    :param bool returnHistoryId: If writeContactHistory, return '_id' of history record\n    :param dict histIdField: Name of identifier for history record: {\"name\": \"emailAddress\", \"value\": \"emailAddress\"}\n    :param namespace udfNamespace: namespace of current working script; must be passed if using user-defined functions\n    \"\"\"\n\n    # setup history collector\n    history = {}\n\n    # get user-defined function config\n    udFun = config['userDefinedFunctions']\n\n    ## Get runtime field configuration\n    fieldConfig = config['fields']\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeGenericValidation\", namespace=udfNamespace)\n\n    # Run generic validation lookup\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='genericLookup', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeGenericRegex\", namespace=udfNamespace)\n\n    # Run generic validation regex\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='genericRegex', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeFieldSpecificValidation\", namespace=udfNamespace)\n\n    # Run field-specific validation lookup\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='fieldSpecificLookup', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeFieldSpecificRegex\", namespace=udfNamespace)\n\n    # Run field-specific validation regex\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='fieldSpecificRegex', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeNormalization\", namespace=udfNamespace)\n\n    # Run normalization lookup\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='normLookup', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeNormalizationRegex\", namespace=udfNamespace)\n\n    # Run normalization regex\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='normRegex', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeNormalizationIncludes\", namespace=udfNamespace)\n\n    # Run normalization includes\n    data, history = lookupAll(data=data, configFields=fieldConfig, lookupType='normIncludes', db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"beforeDeriveData\", namespace=udfNamespace)\n\n    # Fill gaps / refresh derived data\n    data, history = DeriveDataLookupAll(data=data, configFields=fieldConfig, db=db, histObj=history)\n\n    ## Run user-defined functions\n    data, history = _RunUserDefinedFunctions_(config=config, data=data, histObj=history, position=\"afterProcessing\", namespace=udfNamespace)\n\n    # check if need to write contact change history\n    if writeContactHistory:\n        history['timestamp'] = int(time.time())\n        history[histIdField['name']] = data[histIdField['value']]\n        history['configName'] = config['configName']\n\n        # Set _current value for most recent contact\n        history['_current'] = 0\n       \n        # Increment all _current\n        db['contactHistory'].update({histIdField['name']: data[histIdField['value']]}, {'$inc': {'_current': 1}}, multi=True)\n\n        # Insert into DB\n        historyId = db['contactHistory'].insert_one(history).inserted_id\n\n    if writeContactHistory and returnHistoryId:\n        return data, historyId\n    else:\n        return data, None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait(self):\n        if self._go:\n            return True\n\n        with self.lock:\n            if self._go:\n                return True\n            stopper = _allocate_lock()\n            stopper.acquire()\n            if not self.waiting_threads:\n                self.waiting_threads = [stopper]\n            else:\n                self.waiting_threads.append(stopper)\n\n        DEBUG and self._name and Log.note(\"wait for go {{name|quote}}\", name=self.name)\n        stopper.acquire()\n        DEBUG and self._name and Log.note(\"GOing! {{name|quote}}\", name=self.name)\n        return True", "response": "Wait for the current thread to be in the waiting state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngoing - run the signal.", "response": "def go(self):\n        \"\"\"\n        ACTIVATE SIGNAL (DOES NOTHING IF SIGNAL IS ALREADY ACTIVATED)\n        \"\"\"\n        DEBUG and self._name and Log.note(\"GO! {{name|quote}}\", name=self.name)\n\n        if self._go:\n            return\n\n        with self.lock:\n            if self._go:\n                return\n            self._go = True\n\n        DEBUG and self._name and Log.note(\"internal GO! {{name|quote}}\", name=self.name)\n        jobs, self.job_queue = self.job_queue, None\n        threads, self.waiting_threads = self.waiting_threads, None\n\n        if threads:\n            DEBUG and self._name and Log.note(\"Release {{num}} threads\", num=len(threads))\n            for t in threads:\n                t.release()\n\n        if jobs:\n            for j in jobs:\n                try:\n                    j()\n                except Exception as e:\n                    Log.warning(\"Trigger on Signal.go() failed!\", cause=e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_go(self, target):\n        if not target:\n            Log.error(\"expecting target\")\n\n        with self.lock:\n            if not self._go:\n                DEBUG and self._name and Log.note(\"Adding target to signal {{name|quote}}\", name=self.name)\n\n                if not self.job_queue:\n                    self.job_queue = [target]\n                else:\n                    self.job_queue.append(target)\n                return\n\n        (DEBUG_SIGNAL) and Log.note(\"Signal {{name|quote}} already triggered, running job immediately\", name=self.name)\n        target()", "response": "Called when a signal is triggered."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_go(self, target):\n        with self.lock:\n            if not self._go:\n                try:\n                    self.job_queue.remove(target)\n                except ValueError:\n                    pass", "response": "Removes a GO from the job queue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef missing(self):\n        if self.type == BOOLEAN:\n            Log.error(\"programmer error\")\n        return self.lang[MissingOp(self)]", "response": "Returns the missing language code for this attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting for a signal from the current lock.", "response": "def wait(self, till=None):\n        \"\"\"\n        THE ASSUMPTION IS wait() WILL ALWAYS RETURN WITH THE LOCK ACQUIRED\n        :param till: WHEN TO GIVE UP WAITING FOR ANOTHER THREAD TO SIGNAL\n        :return: True IF SIGNALED TO GO, False IF till WAS SIGNALED\n        \"\"\"\n        waiter = Signal()\n        if self.waiting:\n            DEBUG and _Log.note(\"waiting with {{num}} others on {{name|quote}}\", num=len(self.waiting), name=self.name, stack_depth=1)\n            self.waiting.insert(0, waiter)\n        else:\n            DEBUG and _Log.note(\"waiting by self on {{name|quote}}\", name=self.name)\n            self.waiting = [waiter]\n\n        try:\n            self.lock.release()\n            DEBUG and _Log.note(\"out of lock {{name|quote}}\", name=self.name)\n            (waiter | till).wait()\n            if DEBUG:\n                _Log.note(\"done minimum wait (for signal {{till|quote}})\", till=till.name if till else \"\", name=self.name)\n        except Exception as e:\n            if not _Log:\n                _late_import()\n            _Log.warning(\"problem\", cause=e)\n        finally:\n            self.lock.acquire()\n            DEBUG and _Log.note(\"re-acquired lock {{name|quote}}\", name=self.name)\n\n        try:\n            self.waiting.remove(waiter)\n            DEBUG and _Log.note(\"removed own signal from {{name|quote}}\", name=self.name)\n        except Exception:\n            pass\n\n        return bool(waiter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup(self):\n        # Get the existing mapping & cache it. We'll compare it\n        # during the ``update`` & if it doesn't match, we'll put the new\n        # mapping.\n        for language in self.languages:\n            self.index_name = self._index_name_for_language(language)\n            try:\n                self.existing_mapping[language] = self.conn.indices.get_mapping(\n                    index=self.index_name)\n            except NotFoundError:\n                pass\n            except Exception:\n                if not self.silently_fail:\n                    raise\n\n            unified_index = haystack.connections[self.connection_alias].get_unified_index()\n\n            self.content_field_name, field_mapping = self.build_schema(\n                unified_index.all_searchfields(), language)\n\n            current_mapping = {\n                'modelresult': {\n                    'properties': field_mapping,\n                    '_boost': {\n                        'name': 'boost',\n                        'null_value': 1.0\n                    }\n                }\n            }\n\n            if current_mapping != self.existing_mapping[language]:\n                try:\n                    # Make sure the index is there first.\n                    self.conn.indices.create(\n                        index=self.index_name,\n                        body=self.DEFAULT_SETTINGS,\n                        ignore=400)\n                    self.conn.indices.put_mapping(\n                        index=self.index_name,\n                        doc_type='modelresult',\n                        body=current_mapping\n                    )\n                    self.existing_mapping[language] = current_mapping\n                except Exception:\n                    if not self.silently_fail:\n                        raise\n\n        self.setup_complete = True", "response": "This method is called by the base class to setup the index and index for each language."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear(self, models=None, commit=True):\n        for language in self.languages:\n            self.log.debug('clearing index for {0}'.format(language))\n            self.index_name = self._index_name_for_language(language)\n            super(ElasticsearchMultilingualSearchBackend, self).clear(models, commit)\n        self._reset_existing_mapping()", "response": "Clear all indexes for the current project."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the index with the current data.", "response": "def update(self, index, iterable, commit=True):\n        \"\"\"\n        Updates the index with current data.\n        :param index: The search_indexes.Index object\n        :param iterable: The queryset\n        :param commit: commit to the backend.\n        \"\"\"\n        parler = False\n        # setup here because self.existing_mappings are overridden.\n        if not self.setup_complete:\n            try:\n                self.setup()\n            except elasticsearch.TransportError as e:\n                if not self.silently_fail:\n                    raise\n\n                self.log.error(\"Failed to add documents to Elasticsearch: %s\", e)\n                return\n\n        if hasattr(iterable, 'language') and hasattr(iterable.language, '__call__'):\n            parler = True  # Django-parler\n\n        for language in self.languages:\n            self.index_name = self._index_name_for_language(language)\n            # self.log.debug('updating index for {0}'.format(language))\n            if parler:\n                # workaround for django-parler\n                for item in iterable:\n                    item.set_current_language(language)\n                super(ElasticsearchMultilingualSearchBackend, self).update(\n                    index, iterable, commit)\n            else:\n                with translation.override(language):\n                    super(ElasticsearchMultilingualSearchBackend, self).update(\n                        index, iterable, commit)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the index schema for the given fields and language.", "response": "def build_schema(self, fields, language):\n        \"\"\"\n        Build the index schema for the given field. New argument language.\n        :param fields:\n        :param language: the language code\n        :return: a dictionary wit the field name (string) and the\n                 mapping configuration (dictionary)\n        \"\"\"\n        content_field_name = ''\n        mapping = {\n            DJANGO_CT: {'type': 'string', 'index': 'not_analyzed', 'include_in_all': False},\n            DJANGO_ID: {'type': 'string', 'index': 'not_analyzed', 'include_in_all': False},\n        }\n\n        for field_name, field_class in fields.items():\n            field_mapping = FIELD_MAPPINGS.get(\n                field_class.field_type, DEFAULT_FIELD_MAPPING).copy()\n            if field_class.boost != 1.0:\n                field_mapping['boost'] = field_class.boost\n\n            if field_class.document is True:\n                content_field_name = field_class.index_fieldname\n\n            # Do this last to override `text` fields.\n            if field_mapping['type'] == 'string':\n                # Use the language analyzer for text fields.\n                if field_mapping['analyzer'] == DEFAULT_FIELD_MAPPING['analyzer']:\n                    field_mapping['analyzer'] = get_analyzer_for(language)\n                if field_class.indexed is False or hasattr(field_class, 'facet_for'):\n                    field_mapping['index'] = 'not_analyzed'\n                    del field_mapping['analyzer']\n\n            mapping[field_class.index_fieldname] = field_mapping\n\n        return content_field_name, mapping"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for the given string and return the result_class instance.", "response": "def search(self, query_string, **kwargs):\n        \"\"\"\n        The main search method\n        :param query_string: The string to pass to Elasticsearch. e.g. '*:*'\n        :param kwargs: start_offset, end_offset, result_class\n        :return: result_class instance\n        \"\"\"\n        self.index_name = self._index_name_for_language(translation.get_language())\n        # self.log.debug('search method called (%s): %s' %\n        #                (translation.get_language(), query_string))\n        return super(ElasticsearchMultilingualSearchBackend, self).search(query_string, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving an object from the index.", "response": "def remove(self, obj_or_string, commit=True):\n        \"\"\"\n        Removes an object from the index.\n        :param obj_or_string:\n        :param commit:\n        \"\"\"\n        if not self.setup_complete:\n            try:\n                self.setup()\n            except elasticsearch.TransportError as e:\n                if not self.silently_fail:\n                    raise\n                doc_id = get_identifier(obj_or_string)\n                self.log.error(\"Failed to remove document '%s' from Elasticsearch: %s\", doc_id, e)\n                return\n\n        for language in self.languages:\n            # self.log.debug('removing {0} from index {1}'.format(obj_or_string, language))\n            self.index_name = self._index_name_for_language(language)\n            with translation.override(language):\n                super(ElasticsearchMultilingualSearchBackend, self).remove(obj_or_string,\n                                                                           commit=commit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the current version without importing pymds.", "response": "def get():\n    \"\"\"Returns the current version without importing pymds.\"\"\"\n    pkgnames = find_packages()\n\n    if len(pkgnames) == 0:\n        raise ValueError(\"Can't find any packages\")\n\n    pkgname = pkgnames[0]\n\n    content = open(join(pkgname, '__init__.py')).read()\n    c = re.compile(r\"__version__ *= *('[^']+'|\\\"[^\\\"]+\\\")\")\n    m = c.search(content)\n\n    if m is None:\n        raise ValueError(\"Can't find __version__ = ... in __init__.py\")\n\n    return m.groups()[0][1: -1]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef store_integers(items, allow_zero=True):\n    ints = [x for x in items if isinstance(x, int) and (allow_zero or x != 0)]\n    storage = Storage(ints)\n    return storage", "response": "Store integers from the given list in a storage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nappend item to the list.", "response": "def add_item(self, item):\n        \"\"\"Append item to the list.\n\n        :attr:`last_updated` will be set to :py:meth:`datetime.datetime.now`.\n\n        :param item:\n            Something to append to :attr:`items`.\n\n        \"\"\"\n        self.items.append(item)\n        self.last_updated = datetime.datetime.now()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map_http_status_to_exception(http_code):\n        http_exceptions = HttpError.__subclasses__()\n        for http_exception in http_exceptions:\n            http_statuses = http_exception.HTTP_STATUSES\n            if isinstance(http_statuses, int):\n                http_statuses = [http_exception.HTTP_STATUSES]\n\n            try:\n                if http_code in http_statuses:\n                    return http_exception\n            except TypeError:  # Pass if statuses is not iterable (\u2248 None)\n                pass\n\n        return HttpError", "response": "Bind a HTTP status to an exception."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the period of *data* according to the `Lomb-Scargle periodogram <https://en.wikipedia.org/wiki/Least-squares_spectral_analysis#The_Lomb.E2.80.93Scargle_periodogram>`_. **Parameters** data : array-like, shape = [n_samples, 2] or [n_samples, 3] Array containing columns *time*, *mag*, and (optional) *error*. precision : number Distance between contiguous frequencies in search-space. min_period : number Minimum period in search-space. max_period : number Maximum period in search-space. period_jobs : int, optional Number of simultaneous processes to use while searching. Only one process will ever be used, but argument is included to conform to *periodogram* standards of :func:`find_period` (default 1). **Returns** period : number The period of *data*.", "response": "def Lomb_Scargle(data, precision, min_period, max_period, period_jobs=1):\n    \"\"\"\n    Returns the period of *data* according to the\n    `Lomb-Scargle periodogram <https://en.wikipedia.org/wiki/Least-squares_spectral_analysis#The_Lomb.E2.80.93Scargle_periodogram>`_.\n\n    **Parameters**\n\n    data : array-like, shape = [n_samples, 2] or [n_samples, 3]\n        Array containing columns *time*, *mag*, and (optional) *error*.\n    precision : number\n        Distance between contiguous frequencies in search-space.\n    min_period : number\n        Minimum period in search-space.\n    max_period : number\n        Maximum period in search-space.\n    period_jobs : int, optional\n        Number of simultaneous processes to use while searching. Only one\n        process will ever be used, but argument is included to conform to\n        *periodogram* standards of :func:`find_period` (default 1).\n\n    **Returns**\n\n    period : number\n        The period of *data*.\n    \"\"\"\n    time, mags, *err = data.T\n    scaled_mags = (mags-mags.mean())/mags.std()\n    minf, maxf = 2*np.pi/max_period, 2*np.pi/min_period\n    freqs = np.arange(minf, maxf, precision)\n    pgram = lombscargle(time, scaled_mags, freqs)\n\n    return 2*np.pi/freqs[np.argmax(pgram)]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the period of *data* by minimizing conditional entropy. See `link <http://arxiv.org/pdf/1306.6664v2.pdf>`_ [GDDMD] for details. **Parameters** data : array-like, shape = [n_samples, 2] or [n_samples, 3] Array containing columns *time*, *mag*, and (optional) *error*. precision : number Distance between contiguous frequencies in search-space. min_period : number Minimum period in search-space. max_period : number Maximum period in search-space. xbins : int, optional Number of phase bins for each trial period (default 10). ybins : int, optional Number of magnitude bins for each trial period (default 5). period_jobs : int, optional Number of simultaneous processes to use while searching. Only one process will ever be used, but argument is included to conform to *periodogram* standards of :func:`find_period` (default 1). **Returns** period : number The period of *data*. **Citations** .. [GDDMD] Graham, Matthew J. ; Drake, Andrew J. ; Djorgovski, S. G. ; Mahabal, Ashish A. ; Donalek, Ciro, 2013, Monthly Notices of the Royal Astronomical Society, Volume 434, Issue 3, p.2629-2635", "response": "def conditional_entropy(data, precision, min_period, max_period,\n                        xbins=10, ybins=5, period_jobs=1):\n    \"\"\"\n    Returns the period of *data* by minimizing conditional entropy.\n    See `link <http://arxiv.org/pdf/1306.6664v2.pdf>`_ [GDDMD] for details.\n\n    **Parameters**\n\n    data : array-like, shape = [n_samples, 2] or [n_samples, 3]\n        Array containing columns *time*, *mag*, and (optional) *error*.\n    precision : number\n        Distance between contiguous frequencies in search-space.\n    min_period : number\n        Minimum period in search-space.\n    max_period : number\n        Maximum period in search-space.\n    xbins : int, optional\n        Number of phase bins for each trial period (default 10).\n    ybins : int, optional\n        Number of magnitude bins for each trial period (default 5).\n    period_jobs : int, optional\n        Number of simultaneous processes to use while searching. Only one\n        process will ever be used, but argument is included to conform to\n        *periodogram* standards of :func:`find_period` (default 1).\n\n    **Returns**\n\n    period : number\n        The period of *data*.\n\n    **Citations**\n\n    .. [GDDMD] Graham, Matthew J. ; Drake, Andrew J. ; Djorgovski, S. G. ;\n               Mahabal, Ashish A. ; Donalek, Ciro, 2013,\n               Monthly Notices of the Royal Astronomical Society,\n               Volume 434, Issue 3, p.2629-2635\n    \"\"\"\n    periods = np.arange(min_period, max_period, precision)\n    copy = np.ma.copy(data)\n    copy[:,1] = (copy[:,1]  - np.min(copy[:,1])) \\\n       / (np.max(copy[:,1]) - np.min(copy[:,1]))\n    partial_job = partial(CE, data=copy, xbins=xbins, ybins=ybins)\n    m = map if period_jobs <= 1 else Pool(period_jobs).map\n    entropies = list(m(partial_job, periods))\n\n    return periods[np.argmin(entropies)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CE(period, data, xbins=10, ybins=5):\n    if period <= 0:\n        return np.PINF\n\n    r = rephase(data, period)\n    bins, *_ = np.histogram2d(r[:,0], r[:,1], [xbins, ybins], [[0,1], [0,1]])\n    size = r.shape[0]\n\n# The following code was once more readable, but much slower.\n# Here is what it used to be:\n# -----------------------------------------------------------------------\n#    return np.sum((lambda p: p * np.log(np.sum(bins[i,:]) / size / p) \\\n#                             if p > 0 else 0)(bins[i][j] / size)\n#                  for i in np.arange(0, xbins)\n#                  for j in np.arange(0, ybins)) if size > 0 else np.PINF\n# -----------------------------------------------------------------------\n# TODO: replace this comment with something that's not old code\n    if size > 0:\n        # bins[i,j] / size\n        divided_bins = bins / size\n        # indices where that is positive\n        # to avoid division by zero\n        arg_positive = divided_bins > 0\n\n        # array containing the sums of each column in the bins array\n        column_sums = np.sum(divided_bins, axis=1) #changed 0 by 1\n        # array is repeated row-wise, so that it can be sliced by arg_positive\n        column_sums = np.repeat(np.reshape(column_sums, (xbins,1)), ybins, axis=1)\n        #column_sums = np.repeat(np.reshape(column_sums, (1,-1)), xbins, axis=0)\n\n\n        # select only the elements in both arrays which correspond to a\n        # positive bin\n        select_divided_bins = divided_bins[arg_positive]\n        select_column_sums  = column_sums[arg_positive]\n\n        # initialize the result array\n        A = np.empty((xbins, ybins), dtype=float)\n        # store at every index [i,j] in A which corresponds to a positive bin:\n        # bins[i,j]/size * log(bins[i,:] / size / (bins[i,j]/size))\n        A[ arg_positive] = select_divided_bins \\\n                         * np.log(select_column_sums / select_divided_bins)\n        # store 0 at every index in A which corresponds to a non-positive bin\n        A[~arg_positive] = 0\n\n        # return the summation\n        return np.sum(A)\n    else:\n        return np.PINF", "response": "This function returns the conditional entropy of data rephased with the given period."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_period(data,\n                min_period=0.2, max_period=32.0,\n                coarse_precision=1e-5, fine_precision=1e-9,\n                periodogram=Lomb_Scargle,\n                period_jobs=1):\n    \"\"\"find_period(data, min_period=0.2, max_period=32.0, coarse_precision=1e-5, fine_precision=1e-9, periodogram=Lomb_Scargle, period_jobs=1)\n\n    Returns the period of *data* according to the given *periodogram*,\n    searching first with a coarse precision, and then a fine precision.\n\n    **Parameters**\n\n    data : array-like, shape = [n_samples, 2] or [n_samples, 3]\n        Array containing columns *time*, *mag*, and (optional) *error*.\n    min_period : number\n        Minimum period in search-space.\n    max_period : number\n        Maximum period in search-space.\n    coarse_precision : number\n        Distance between contiguous frequencies in search-space during first\n        sweep.\n    fine_precision : number\n        Distance between contiguous frequencies in search-space during second\n        sweep.\n    periodogram : function\n        A function with arguments *data*, *precision*, *min_period*,\n        *max_period*, and *period_jobs*, and return value *period*.\n    period_jobs : int, optional\n        Number of simultaneous processes to use while searching (default 1).\n\n    **Returns**\n\n    period : number\n        The period of *data*.\n    \"\"\"\n    if min_period >= max_period:\n        return min_period\n\n    coarse_period = periodogram(data, coarse_precision, min_period, max_period,\n                                period_jobs=period_jobs)\n\n    return coarse_period if coarse_precision <= fine_precision else \\\n        periodogram(data, fine_precision,\n                    coarse_period - coarse_precision,\n                    coarse_period + coarse_precision,\n                    period_jobs=period_jobs)", "response": "This function returns the period of data according to the given coarse precision and max_period."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a copy of data with the time or phase shifted by a phase - shift and col.", "response": "def rephase(data, period=1.0, shift=0.0, col=0, copy=True):\n    \"\"\"\n    Returns *data* (or a copy) phased with *period*, and shifted by a\n    phase-shift *shift*.\n\n    **Parameters**\n\n    data : array-like, shape = [n_samples, n_cols]\n        Array containing the time or phase values to be rephased in column\n        *col*.\n    period : number, optional\n        Period to phase *data* by (default 1.0).\n    shift : number, optional\n        Phase shift to apply to phases (default 0.0).\n    col : int, optional\n        Column in *data* containing the time or phase values to be rephased\n        (default 0).\n    copy : bool, optional\n        If True, a new array is returned, otherwise *data* is rephased\n        in-place (default True).\n\n    **Returns**\n\n    rephased : array-like, shape = [n_samples, n_cols]\n        Array containing the rephased *data*.\n    \"\"\"\n    rephased = np.ma.array(data, copy=copy)\n    rephased[:, col] = get_phase(rephased[:, col], period, shift)\n\n    return rephased"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_xml_element(self):\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        self.xml_element.set('system', str(self.system))\n        self.xml_element.text = self.text\n\n        return self.xml_element", "response": "Updates the xml element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_xml_string(self):\n\n        self.update_xml_element()\n        xml = self.xml_element\n\n        return etree.tostring(xml, pretty_print=True).decode('utf-8')", "response": "Returns the XML string representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch(self):\n        if self.message_id is None:\n            raise Exception(\".message_id not set.\")\n        response = self.session.request(\"find:Message.content\", [ self.message_id ])\n        if response == None:\n            raise Exception(\"Message not found.\")\n        self.data = response\n        return self", "response": "Fetch data corresponding to this draft and store it as self. data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving current draft state.", "response": "def save(self):\n        \"\"\"Save current draft state.\"\"\"\n        response = self.session.request(\"save:Message\", [ self.data ])\n        self.data = response\n        self.message_id = self.data[\"id\"]\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_preview(self): # pragma: no cover\n        response = self.session.request(\"method:queuePreview\", [ self.data ])\n        self.data = response\n        return self", "response": "Send a preview of this draft."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines the correct query set based on the object.", "response": "def _get_query_sets_for_object(o):\n    \"\"\"\n    Determines the correct query set based on the object.\n\n    If the object is a literal, it will return a query set over LiteralStatements.\n    If the object is a URIRef or BNode, it will return a query set over Statements.\n    If the object is unknown, it will return both the LiteralStatement and Statement query sets.\n\n    This method always returns a list of size at least one.\n    \"\"\"\n    if o:\n        if isinstance(o, Literal):\n            query_sets = [models.LiteralStatement.objects]\n        else:\n            query_sets = [models.URIStatement.objects]\n    else:\n        query_sets = [models.URIStatement.objects, models.LiteralStatement.objects]\n    return query_sets"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_named_graph(context):\n    if context is None:\n        return None\n\n    return models.NamedGraph.objects.get_or_create(identifier=context.identifier)[0]", "response": "Returns the named graph for this context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef destroy(self, configuration=None):\n        models.NamedGraph.objects.all().delete()\n        models.URIStatement.objects.all().delete()\n        models.LiteralStatement.objects.all().delete()", "response": "Completely destroys a store and all the contexts and triples in the store."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, (s, p, o), context, quoted=False):\n        assert isinstance(s, Identifier)\n        assert isinstance(p, Identifier)\n        assert isinstance(o, Identifier)\n        assert not quoted\n\n        named_graph = _get_named_graph(context)\n\n        query_set = _get_query_sets_for_object(o)[0]\n        query_set.get_or_create(\n            subject=s,\n            predicate=p,\n            object=o,\n            context=named_graph,\n            )", "response": "Adds a triple to the store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a triple from the store.", "response": "def remove(self, (s, p, o), context=None):\n        \"\"\"\n        Removes a triple from the store.\n        \"\"\"\n        named_graph = _get_named_graph(context)\n        query_sets = _get_query_sets_for_object(o)\n\n        filter_parameters = dict()\n        if named_graph is not None:\n            filter_parameters['context_id'] = named_graph.id\n        if s:\n            filter_parameters['subject'] = s\n        if p:\n            filter_parameters['predicate'] = p\n        if o:\n            filter_parameters['object'] = o\n\n        query_sets = [qs.filter(**filter_parameters) for qs in query_sets]  # pylint: disable=W0142\n\n        for qs in query_sets:\n            qs.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef triples(self, (s, p, o), context=None):\n        named_graph = _get_named_graph(context)\n        query_sets = _get_query_sets_for_object(o)\n\n        filter_parameters = dict()\n        if named_graph is not None:\n            filter_parameters['context_id'] = named_graph.id\n        if s:\n            filter_parameters['subject'] = s\n        if p:\n            filter_parameters['predicate'] = p\n        if o:\n            filter_parameters['object'] = o\n\n        query_sets = [qs.filter(**filter_parameters) for qs in query_sets]  # pylint: disable=W0142\n\n        for qs in query_sets:\n            for statement in qs:\n                triple = statement.as_triple()\n                yield triple, context", "response": "Yields all triples in the current store."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addNew(label, version, baseVersion, dataHash=\"\", fixedHash=\"\", replayHash=\"\"):\n    baseVersion = int(baseVersion)\n    version     = int(version)\n    minVersChecks = {\"base-version\":baseVersion, \"version\":version}\n    if label in handle.ALL_VERS_DATA:\n        raise ValueError(\"given record label (%s) is already defined.  Consider performing update() for this record instead\"%(label))\n    for vCheckK,vCheckV in iteritems(minVersChecks): # verify no conflicting values\n        maxVersion  = min([vData[vCheckK] for vData in handle.ALL_VERS_DATA.values()])\n        if vCheckV < c.MIN_VERSION_AI_API:\n            raise ValueError(\"version %s / %s.%s does not support the Starcraft2 API\"%(baseVersion, label, version))\n        if vCheckV < maxVersion: # base version cannot be smaller than newest value\n            raise ValueError(\"given %s (%d) cannot be smaller than newest known %s (%d)\"%(vCheckK, vCheckV, vCheckK, maxVersion))\n    uniqueValHeaders = list(c.JSON_HEADERS)\n    uniqueValHeaders.remove(\"base-version\")\n    record = {\"base-version\" : baseVersion}\n    #print(\"%15s : %s (%s)\"%(\"base-version\", baseVersion, type(baseVersion)))\n    for k,v in zip(uniqueValHeaders, [label, version, dataHash, fixedHash, replayHash]): # new attr values must be unique within all handler records\n        record[k] = v # convert to dict while checking each param\n        #print(\"%15s : %s (%s)\"%(k,v,type(v)))\n        if not v: continue # ignore uniqueness requirement if value is unspecified\n        if v in [r[k] for r in Handler.ALL_VERS_DATA.values()]:\n            raise ValueError(\"'%s' '%s' is in known values: %s\"%(k, v, getattr(handle, k)))\n            return\n    handle.save(new=record)", "response": "Add a new record to the database to be tracked by the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self):\n        basepath = os.path.dirname(os.path.abspath(__file__))\n        filename = os.sep.join([basepath, c.FOLDER_JSON, c.FILE_GAME_VERSIONS])\n        Handler.ALL_VERS_DATA = {} # reset known data; do not retain defunct information\n        with open(filename, \"r\") as f:\n            data = json.loads( f.read() )\n        self.update(data)\n        self._updated = False", "response": "load ALL_VERS_DATA from disk"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, new=None, timeout=2):\n        if new: self.update(new) # allow two operations (update + save) with a single command\n        if not self._updated: return # nothing to do\n        thisPkg = os.path.dirname(__file__)\n        filename = os.path.join(thisPkg, c.FOLDER_JSON, c.FILE_GAME_VERSIONS)\n        fParts = c.FILE_GAME_VERSIONS.split('.')\n        newFile = os.path.join(thisPkg, c.FOLDER_JSON, \"%s_%s.%s\"%(fParts[0], dateFormat.now(), fParts[1]))\n        if not os.path.isfile(newFile):\n            #fParts = c.FILE_GAME_VERSIONS.split('.')\n            #newFile = \"%s%s%s_%s.%s\"%(c.FOLDER_JSON, os.sep, fParts[0], dateFormat.now(), fParts[1])\n            #if not os.path.isfile(newFile):\n            #print(filename)\n            #print(newFile)\n            os.rename(filename, newFile) # backup existing version file\n        recordKeys = [(record[\"version\"], record) for record in Handler.ALL_VERS_DATA.values()]\n        data = [r for k,r in sorted(recordKeys)] # i.e. get values sorted by version key\n        start = time.time()\n        while time.time()-start < timeout: # allow multiple retries if multiple processes fight over the version file\n            try:\n                with open(filename, \"wb\") as f:\n                    f.write(str.encode(json.dumps(data, indent=4, sort_keys=True))) # python3 requires encoding str => bytes to write to file\n                self._updated = False\n                return\n            except IOError: pass # continue waiting for file to be available\n        raise # after timeout, prior exception is what matters", "response": "write ALL_VERS_DATA to disk in pretty format"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching all records that have any args in any key - value requirements specified in kwargs", "response": "def search(self, *args, **kwargs):\n        \"\"\"match all records that have any args in any key/field that also match\n        key/value requirements specified in kwargs\"\"\"\n        ret = []\n        for record in Handler.ALL_VERS_DATA.values():\n            matchArgs = list(kwargs.keys())\n            for k,v in iteritems(kwargs): # restrict records based on key-value match requirement\n                try:\n                    if record[k] != v: break # a non-matching requirement means this record doesn't match\n                except: break # record doesn't have required key 'k'\n                matchArgs.remove(k)\n            if matchArgs: continue # didn't match all required kwargs\n            matchArgs = list(args)\n            for k,v in iteritems(record): # find any record with a <value> in it\n                if k in matchArgs: matchArgs.remove(k)\n                if v in matchArgs: matchArgs.remove(v)\n            if matchArgs: continue # didn't match all required args\n            ret.append(record)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, data):\n        if not isinstance(data, list): data = [data] # otherwise no conversion is necessary\n        master = Handler.ALL_VERS_DATA\n        for record in data:\n            #print(record)\n            for k,v in iteritems(record): # ensure record contents aretyped appropriately\n                try:                record[k] = int(v)\n                except ValueError:  record[k] = v\n            try: label = record[\"label\"] # verify this record has the required 'label' key\n            except KeyError:\n                raise ValueError(\"Must provide a valid label argument.  Given:%s%s\"%(\\\n                    os.linesep, (\"%s  \"%(os.linesep)).join(\n                        [\"%15s:%s\"%(k,v) for k,v in iteritems(kwargs)]\n                    )))\n            try:    masterLabel = master[label] # identify the already existing record that matches this to-be-updated record, if any\n            except KeyError: # master hasn't been defined yet\n                master[label] = record\n                self._updated = True # a new record should also be saved\n                continue\n            for k,v in iteritems(record): # determine whether master needs to be updated\n                try:\n                    if masterLabel[k] == v:  continue # whether an entry in the record needs to be updated (doesn't match)\n                except KeyError:             pass # this condition means that k is a new key, so the record must be updated\n                self._updated = True\n                try:    master[label].update(record) # index each record by its label\n                except KeyError:             break", "response": "update known data with newly provided data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getLocalIPaddress():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        s.connect(('google.com', 0))\n        my_local_ip = s.getsockname()[0] # takes ~0.005s\n        #from netifaces import interfaces, ifaddresses, AF_INET\n        #full solution in the event of multiple NICs (network interface cards) on the PC\n        #def ip4_addresses():\n        #    ip_list = []\n        #    for interface in interfaces():\n        #        for link in ifaddresses(interface)[AF_INET]: # If IPv6 addresses are needed instead, use AF_INET6 instead of AF_INET\n        #            ip_list.append(link['addr'])\n        #    return ip_list\n    except Exception:\n        my_local_ip = None\n    return my_local_ip", "response": "get the local IP address of the NICs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getPublicIPaddress(timeout=c.DEFAULT_TIMEOUT):\n    start = time.time()\n    my_public_ip = None\n    e = Exception\n    while my_public_ip == None:\n        if time.time() - start > timeout:\n            break\n        try: #httpbin.org -- site is useful to test scripts / applications.\n            my_public_ip = json.load(urlopen('http://httpbin.org/ip'))['origin'] # takes ~0.14s as ipv4\n            if my_public_ip: break\n        except Exception as e:\n            print(type(e), e, \"http://httpbin.org/ip\")\n        try: #jsonip.com -- Seemingly the sole purpose of this domain is to return IP address in JSON.\n            my_public_ip = json.load(urlopen('http://jsonip.com'))['ip']  # takes ~0.24s as ipv6\n            if my_public_ip: break\n        except Exception as e:\n            print(type(e), e, \"http://jsonip.com\")\n        try: #ipify.org -- Power of this service results from lack of limits (there is no rate limiting), infrastructure (placed on Heroku, with high availability in mind) and flexibility (works for both IPv4 and IPv6).\n            my_public_ip = load(urlopen('https://api.ipify.org/?format=json'))['ip']  # takes ~0.33s\n            if my_public_ip: break\n        except Exception as e:\n            print(type(e), e, \"https://api.ipify.org/\")\n        try: #ip.42.pl -- This is very convenient for scripts, you don't need JSON parsing here.\n            my_public_ip = urlopen('http://ip.42.pl/raw').read()  # takes ~0.35s\n            if my_public_ip: break\n        except Exception as e:\n            print(type(e), e, \"http://ip.42.pl/raw\")\n    if not my_public_ip:\n        raise e\n    return my_public_ip", "response": "Get the public IP address from the network."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bits_to_dict(bits):\n    # Strip any trailing commas\n    cleaned_bits = [bit[:-1] if bit.endswith(',') else bit for bit in bits]\n\n    # Create dictionary by splitting on equal signs\n    options = dict(bit.split('=') for bit in cleaned_bits)\n\n    # Coerce strings of types to Python types\n    for key in options:\n        if options[key] == \"'true'\" or options[key] == \"'false'\":\n            options[key] = options[key].title()\n        options[key] = ast.literal_eval(options[key])\n\n    return options", "response": "Convert a Django template tag s kwargs into a dictionary of Python types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a highlighted code block with Pygments.", "response": "def pygmentify(value, **kwargs):\n    \"\"\"Return a highlighted code block with Pygments.\"\"\"\n    soup = BeautifulSoup(value, 'html.parser')\n    for pre in soup.find_all('pre'):\n\n        # Get code\n        code = ''.join([to_string(item) for item in pre.contents])\n        code = code.replace('&lt;', '<')\n        code = code.replace('&gt;', '>')\n        code = code.replace('&#39;', \"'\")\n        code = code.replace('&quot;', '\"')\n        code = code.replace('&amp;', '&')\n\n        # Get lexer by language\n        class_list = pre.get('class', [])\n        lexers = []\n        options = {\n            'stripall': True\n        }\n\n        # Collect all found lexers\n        for c in class_list:\n            try:\n                lexers.append(get_lexer_by_name(c, **options))\n            except ClassNotFound:\n                pass\n\n        # Get first lexer match or none\n        try:\n            lexer = lexers[0]\n        except IndexError:\n            lexer = None\n\n        # If no lexer, try guessing\n        if lexer is None:\n            try:\n                lexer = guess_lexer(pre.text, **options)\n                class_list += [alias for alias in lexer.aliases]\n            except ClassNotFound:\n                pass\n\n        if lexer is not None:\n\n            # Get formatter\n            formatter = HtmlFormatter(**kwargs)\n\n            # Highlight code\n            highlighted = highlight(code, lexer, formatter)\n            class_string = ' '.join([c for c in class_list])\n            highlighted = highlighted.replace(\n                '<div class=\"%s\"><pre>' % kwargs['cssclass'],\n                '<div class=\"%s\"><pre class=\"%s\">' % (kwargs['cssclass'], class_string)\n            )\n            pre.replace_with(highlighted)\n\n    return soup.decode(formatter=None).strip()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the available language analyzer for the given language code.", "response": "def get_analyzer_for(language_code, default='snowball'):\n    \"\"\"\n    Get the available language analyzer for the given language code or else the default.\n    :param language_code: Django language code\n    :param default: The analyzer to return if no language analyzer has been found.\n                    Defaults to 'snowball'.\n    :return: The Haystack language name. E.g. 'german' or the default analyzer\n    \"\"\"\n    languages = {\n        'ar': 'arabic',\n        # '': 'armenian',\n        'eu': 'basque',\n        'pt-br': 'brazilian',\n        'bg': 'bulgarian',\n        'ca': 'catalan',\n        'zh-hans': 'chinese',\n        'zh-hant': 'chinese',\n        # 'cjk',\n        'cs': 'czech',\n        'da': 'danish',\n        'nl': 'dutch',\n        'en': 'english',\n        'fi': 'finnish',\n        'fr': 'french',\n        'gl': 'galician',\n        'de': 'german',\n        'el': 'greek',\n        'hi': 'hindi',\n        'hu': 'hungarian',\n        'id': 'indonesian',\n        'ga': 'irish',\n        'it': 'italian',\n        'lv': 'latvian',\n        'no': 'norwegian',\n        'fa': 'persian',\n        'pt': 'portuguese',\n        'ro': 'romanian',\n        'ru': 'russian',\n        # 'sorani',\n        'es': 'spanish',\n        'sv': 'swedish',\n        'tr': 'turkish',\n        'th': 'thai'\n    }\n    if language_code in languages:\n        return languages[language_code]\n    elif language_code[:2] in languages:\n        return languages[language_code[:2]]\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _encode_multipart_formdata(fields, files):\n    BOUNDARY = '----------A_vEry_UnlikelY_bouNdary_$'\n    CRLF = '\\r\\n'\n    L = []\n    for (key, value) in fields:\n        L.append('--' + BOUNDARY)\n        L.append(str('Content-Disposition: form-data; name=\"%s\"' % key))\n        L.append('')\n        L.append(value)\n    for (key, filename, value) in files:\n        L.append('--' + BOUNDARY)\n        L.append(str('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (key, filename)))\n        L.append('Content-Type: %s' % get_content_type(filename))\n        L.append('')\n        L.append(value)\n    L.append('--' + BOUNDARY + '--')\n    L.append('')\n    body = CRLF.join(L)\n    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY\n    return content_type, body", "response": "Encode the multipart form data for PUTing and POSTing."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a callable which conjures the URL for the resource and GETs a response", "response": "def _generate_read_callable(name, display_name, arguments, regex, doc, supported):\n    \"\"\"\n    Returns a callable which conjures the URL for the resource and GETs a response\n    \"\"\"\n    def f(self, *args, **kwargs):\n        url = self._generate_url(regex, args)\n        if 'params' in kwargs:\n            url += \"?\" + urllib.urlencode(kwargs['params'])\n        return self._get_data(url, accept=(kwargs.get('accept')))\n    f.__name__ = str('read_%s' % name)\n    f.__doc__ = doc\n    f._resource_uri = regex\n    f._get_args = arguments\n    f._put_or_post_args = None \n    f.resource_name = display_name\n    f.is_api_call = True\n    f.is_supported_api = supported\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_create_callable(name, display_name, arguments, regex, doc, supported, post_arguments, is_action):\n    def f(self, *args, **kwargs):\n        for key, value in args[-1].items():\n            if type(value) == file:\n                return self._put_or_post_multipart('POST', self._generate_url(regex, args[:-1]), args[-1])\n        return self._put_or_post_json('POST', self._generate_url(regex, args[:-1]), args[-1])\n    if is_action:\n        f.__name__ = str(name)\n    else:\n        f.__name__ = str('create_%s' % name)\n    f.__doc__ = doc\n    f._resource_uri = regex\n    f._get_args = arguments\n    f._put_or_post_args = post_arguments\n    f.resource_name = display_name\n    f.is_api_call = True\n    f.is_supported_api = supported\n    return f", "response": "Generate a callable which conjures the URL for the resource and POSTs data\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _split_regex(regex):\n    if regex[0] == '^':\n        regex = regex[1:]\n    if regex[-1] == '$':\n        regex = regex[0:-1]\n    results = []\n    line = ''\n    for c in regex:\n        if c == '(':\n            results.append(line)\n            line = ''\n        elif c == ')':\n            line = ''\n        else:\n            line = line + c\n    if len(line) > 0:\n        results.append(line)\n    return results", "response": "Split a regex into a list of the URL lines"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_help(self):\n        keyfunc = lambda x: (x.resource_name, x.__doc__.strip())\n        resources = groupby(sorted(filter(lambda x: (hasattr(x, 'is_api_call') and\n                                                     x.is_api_call and x.is_supported_api),\n                                          [getattr(self, resource) for resource in dir(self)]),\n                                   key=keyfunc),\n                            key=keyfunc)\n        for resource_desc, resource_methods in resources:\n            print resource_desc[0]\n            print '\\t', resource_desc[1]\n            print\n            print '\\t', 'Available methods:'\n            for r in resource_methods:\n                method_header = r.__name__ + '('\n                if r._get_args:\n                    method_header += ','.join(r._get_args)\n                if r._put_or_post_args:\n                    put_or_post_args = [arg['name'] for arg in reduce(lambda x, y: x+y, r._put_or_post_args.values())]\n                    method_header += ',{' + ','.join(put_or_post_args) + '}'\n                method_header += ')'\n                method_desc = \"\"\n                if r.__name__.startswith('create'):\n                    method_desc = 'Corresponding API call: POST to ' + r._resource_uri\n                if r.__name__.startswith('update'):\n                    method_desc = 'Corresponding API call: PUT to ' + r._resource_uri\n                if r.__name__.startswith('read'):\n                    method_desc = 'Corresponding API call: GET to ' + r._resource_uri\n                if r.__name__.startswith('delete'):\n                    method_desc = 'Corresponding API call: DELETE to ' + r._resource_uri\n\n                print '\\t\\t', method_header, ' - ', method_desc\n            print", "response": "Prints the help text for the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes the resource at url", "response": "def _delete_resource(self, url):\n        \"\"\"\n        DELETEs the resource at url\n        \"\"\"\n        conn, head = self._construct_request()\n        conn.request(\"DELETE\", url, \"\", head)\n        resp = conn.getresponse()\n        self._handle_response_errors('DELETE', url, resp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_data(self, url, accept=None):\n        if self.parsed_endpoint.scheme == 'https':\n            conn = httplib.HTTPSConnection(self.parsed_endpoint.netloc)\n        else:\n            conn = httplib.HTTPConnection(self.parsed_endpoint.netloc)\n        head = {\n            \"User-Agent\": USER_AGENT,\n            API_TOKEN_HEADER_NAME: self.api_token,\n        }\n        if self.api_version in ['0.1', '0.01a']:\n            head[API_VERSION_HEADER_NAME] = self.api_version\n        if accept:\n            head['Accept'] = accept\n        conn.request(\"GET\", url, \"\", head)\n        resp = conn.getresponse()\n        self._handle_response_errors('GET', url, resp)\n        content_type = resp.getheader('content-type')\n        if 'application/json' in content_type:\n            return json.loads(resp.read())\n        return resp.read()", "response": "Get the data at url and returns the raw response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding the data as a multipart form and PUT or POST to the url.", "response": "def _put_or_post_multipart(self, method, url, data):\n        \"\"\"\n        encodes the data as a multipart form and PUTs or POSTs to the url\n        the response is parsed as JSON and the returns the resulting data structure\n        \"\"\"\n        fields = []\n        files = []\n        for key, value in data.items():\n            if type(value) == file:\n                files.append((key, value.name, value.read()))\n            else:\n                fields.append((key, value))\n        content_type, body = _encode_multipart_formdata(fields, files)\n        if self.parsed_endpoint.scheme == 'https':\n            h = httplib.HTTPS(self.parsed_endpoint.netloc)\n        else:\n            h = httplib.HTTP(self.parsed_endpoint.netloc)\n        h.putrequest(method, url)\n        h.putheader('Content-Type', content_type)\n        h.putheader('Content-Length', str(len(body)))\n        h.putheader('Accept', 'application/json')\n        h.putheader('User-Agent', USER_AGENT)\n        h.putheader(API_TOKEN_HEADER_NAME, self.api_token)\n        if self.api_version in ['0.1', '0.01a']:\n            h.putheader(API_VERSION_HEADER_NAME, self.api_version)\n        h.endheaders()\n        h.send(body)\n        errcode, errmsg, headers = h.getreply()\n        if errcode not in [200, 202]:\n            raise IOError('Response to %s to URL %s was status code %s: %s' % (method, url, errcode, h.file.read()))\n        return json.loads(h.file.read())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _put_or_post_json(self, method, url, data):\n        if self.parsed_endpoint.scheme == 'https':\n            conn = httplib.HTTPSConnection(self.parsed_endpoint.netloc)\n        else:\n            conn = httplib.HTTPConnection(self.parsed_endpoint.netloc)\n        head = {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": USER_AGENT,\n            API_TOKEN_HEADER_NAME: self.api_token,\n        }\n        if self.api_version in ['0.1', '0.01a']:\n            head[API_VERSION_HEADER_NAME] = self.api_version\n        conn.request(method, url, json.dumps(data), head)\n        resp = conn.getresponse()\n        self._handle_response_errors(method, url, resp)\n        return json.loads(resp.read())", "response": "This method handles PUT or POST requests to the url and returns the data type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the URL for the given regex and arguments.", "response": "def _generate_url(self, regex, arguments):\n        \"\"\"\n        Uses the regex (of the type defined in Django's url patterns) and the arguments to return a relative URL\n        For example, if the regex is '^/api/shreddr/job/(?P<id>[\\d]+)$' and arguments is ['23']\n        then return would be '/api/shreddr/job/23'\n        \"\"\"\n        regex_tokens = _split_regex(regex)\n        result = ''\n        for i in range(len(arguments)):\n            result = result + str(regex_tokens[i]) + str(arguments[i])\n        if len(regex_tokens) > len(arguments):\n            result += regex_tokens[-1]\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_importer_frame():\n    byte = lambda ch: ord(ch) if PY2 else ch\n    frame = inspect.currentframe()\n    try:\n        while frame:\n            code = frame.f_code\n            lasti = frame.f_lasti\n            if byte(code.co_code[lasti]) == dis.opmap['IMPORT_NAME']:\n                # FIXME: Support EXTENDED_ARG.\n                arg = (\n                    byte(code.co_code[lasti + 1])\n                    + byte(code.co_code[lasti + 2]) * 256)\n                name = code.co_names[arg]\n                if name == 'end':\n                    break\n                end\n            end\n            frame = frame.f_back\n        end\n        return frame\n    finally:\n        del frame\n    end", "response": "Returns the outer frame importing this end module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a node is the end keyword.", "response": "def is_end_node(node):\n    \"\"\"Checks if a node is the \"end\" keyword.\n\n    Args:\n        node: AST node.\n\n    Returns:\n        True if the node is the \"end\" keyword, otherwise False.\n    \"\"\"\n    return (isinstance(node, ast.Expr) and\n            isinstance(node.value, ast.Name) and\n            node.value.id == 'end')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_compound_bodies(node):\n    if isinstance(node, (ast.Module, ast.FunctionDef, ast.ClassDef, ast.With)):\n        return [node.body]\n    elif isinstance(node, (ast.If, ast.While, ast.For)):\n        return [node.body, node.orelse]\n    elif PY2 and isinstance(node, ast.TryFinally):\n        return [node.body, node.finalbody]\n    elif PY2 and isinstance(node, ast.TryExcept):\n        return [node.body, node.orelse] + [h.body for h in node.handlers]\n    elif PY3 and isinstance(node, ast.Try):\n        return ([node.body, node.orelse, node.finalbody]\n                + [h.body for h in node.handlers])\n    end\n    return []", "response": "Returns a list of bodies of a compound statement node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_end_blocks(frame):\n    try:\n        try:\n            module_name = frame.f_globals['__name__']\n        except KeyError:\n            warnings.warn(\n                'Can not get the source of an uknown module. '\n                'End-of-block syntax check is skipped.',\n                EndSyntaxWarning)\n            return\n        end\n\n        filename = frame.f_globals.get('__file__', '<unknown>')\n        try:\n            source = inspect.getsource(sys.modules[module_name])\n        except Exception:\n            warnings.warn(\n                'Can not get the source of module \"%s\". '\n                'End-of-block syntax check is skipped.' % (module_name,),\n                EndSyntaxWarning)\n            return\n        end\n    finally:\n        del frame\n    end\n\n    root = ast.parse(source)\n    for node in ast.walk(root):\n        bodies = get_compound_bodies(node)\n        if not bodies:\n            continue\n        end\n\n        # FIXME: This is an inaccurate hack to handle if-elif-else.\n        if (isinstance(node, ast.If) and\n                len(node.orelse) == 1 and\n                isinstance(node.orelse[0], ast.If)):\n            continue\n        end\n\n        # FIXME: This is an inaccurate hack to handle try-except-finally\n        # statement which is parsed as ast.TryExcept in ast.TryFinally in\n        # Python 2.\n        if (PY2 and\n                isinstance(node, ast.TryFinally) and\n                len(node.body) == 1 and\n                isinstance(node.body[0], ast.TryExcept)):\n            continue\n        end\n\n        for body in bodies:\n            skip_next = False\n            for i, child in enumerate(body):\n                if skip_next:\n                    skip_next = False\n                elif is_end_node(child):\n                    raise SyntaxError(\n                        '\"end\" does not close a block.',\n                        [filename, child.lineno, child.col_offset,\n                         source.splitlines()[child.lineno - 1] + '\\n'])\n                elif get_compound_bodies(child):\n                    try:\n                        ok = is_end_node(body[i + 1])\n                    except IndexError:\n                        ok = False\n                    end\n                    if not ok:\n                        raise SyntaxError(\n                            'This block is not closed with \"end\".',\n                            [filename, child.lineno, child.col_offset,\n                             source.splitlines()[child.lineno - 1] + '\\n'])\n                    end\n                    skip_next = True\n                end\n            end\n        end\n    end", "response": "Performs end - of - block check."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransform a dict of metadata into a list of buffers.", "response": "def metadata_to_buffers(metadata):\n    \"\"\"\n    Transform a dict of metadata into a sequence of buffers.\n\n    :param metadata: The metadata, as a dict.\n    :returns: A list of buffers.\n    \"\"\"\n    results = []\n\n    for key, value in metadata.items():\n        assert len(key) < 256\n        assert len(value) < 2 ** 32\n        results.extend([\n            struct.pack('!B', len(key)),\n            key,\n            struct.pack('!I', len(value)),\n            value,\n        ])\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef buffer_to_metadata(buffer):\n    offset = 0\n    size = len(buffer)\n    metadata = {}\n\n    while offset < size:\n        name_size = struct.unpack_from('B', buffer, offset)[0]\n        offset += 1\n\n        if name_size > size - 4:\n            raise ProtocolError(\n                \"Invalid name size in metadata\",\n                fatal=True,\n            )\n\n        name = buffer[offset:offset + name_size]\n        offset += name_size\n\n        value_size = struct.unpack_from('!I', buffer, offset)[0]\n        offset += 4\n\n        if value_size > size - name_size - 5:\n            raise ProtocolError(\n                \"Invalid value size in metadata\",\n                fatal=True,\n            )\n\n        value = buffer[offset:offset + value_size]\n        offset += value_size\n        metadata[name.lower()] = value\n\n    return metadata", "response": "Transform a buffer to a metadata dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _status(self):\n        ''' Internal: Do not call. Returns the status list for a list of job_ids\n\n        Args:\n              self\n\n        Returns:\n              [status...] : Status list of all jobs\n        '''\n\n        job_id_list = ' '.join(self.resources.keys())\n\n        jobs_missing = list(self.resources.keys())\n\n        retcode, stdout, stderr = self.channel.execute_wait(\"qstat {0}\".format(job_id_list), 3)\n        for line in stdout.split('\\n'):\n            parts = line.split()\n            if not parts or parts[0].upper().startswith('JOB') or parts[0].startswith('---'):\n                continue\n            job_id = parts[0]\n            status = translate_table.get(parts[4], 'UNKNOWN')\n            self.resources[job_id]['status'] = status\n            jobs_missing.remove(job_id)\n\n        # squeue does not report on jobs that are not running. So we are filling in the\n        # blanks for missing jobs, we might lose some information about why the jobs failed.\n        for missing_job in jobs_missing:\n            if self.resources[missing_job]['status'] in ['PENDING', 'RUNNING']:\n                self.resources[missing_job]['status'] = translate_table['E']", "response": "Internal method to get the status of all jobs in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsubmit a command onto an Local Resource Manager job of blocksize parallel elements.", "response": "def submit(self, command, blocksize, job_name=\"parsl.auto\"):\n        ''' Submits the command onto an Local Resource Manager job of blocksize parallel elements.\n        Submit returns an ID that corresponds to the task that was just submitted.\n\n        If tasks_per_node <  1 : ! This is illegal. tasks_per_node should be integer\n\n        If tasks_per_node == 1:\n             A single node is provisioned\n\n        If tasks_per_node >  1 :\n             tasks_per_node * blocksize number of nodes are provisioned.\n\n        Args:\n             - command  :(String) Commandline invocation to be made on the remote side.\n             - blocksize   :(float)\n\n        Kwargs:\n             - job_name (String): Name for job, must be unique\n\n        Returns:\n             - None: At capacity, cannot provision more\n             - job_id: (string) Identifier for the job\n\n        '''\n\n        if self.provisioned_blocks >= self.max_blocks:\n            logger.warn(\"[%s] at capacity, cannot add more blocks now\", self.label)\n            return None\n\n        # Note: Fix this later to avoid confusing behavior.\n        # We should always allocate blocks in integer counts of node_granularity\n        if blocksize < self.nodes_per_block:\n            blocksize = self.nodes_per_block\n\n        # Set job name\n        job_name = \"parsl.{0}.{1}\".format(job_name, time.time())\n\n        # Set script path\n        script_path = \"{0}/{1}.submit\".format(self.script_dir, job_name)\n        script_path = os.path.abspath(script_path)\n\n        logger.debug(\"Requesting blocksize:%s nodes_per_block:%s tasks_per_node:%s\", blocksize, self.nodes_per_block,\n                     self.tasks_per_node)\n\n        job_config = {}\n        # TODO : script_path might need to change to accommodate script dir set via channels\n        job_config[\"submit_script_dir\"] = self.channel.script_dir\n        job_config[\"nodes\"] = self.nodes_per_block\n        job_config[\"task_blocks\"] = self.nodes_per_block * self.tasks_per_node\n        job_config[\"nodes_per_block\"] = self.nodes_per_block\n        job_config[\"tasks_per_node\"] = self.tasks_per_node\n        job_config[\"walltime\"] = self.walltime\n        job_config[\"overrides\"] = self.overrides\n        job_config[\"user_script\"] = command\n\n        # Wrap the command\n        job_config[\"user_script\"] = self.launcher(command,\n                                                  self.tasks_per_node,\n                                                  self.nodes_per_block)\n\n        logger.debug(\"Writing submit script\")\n        self._write_submit_script(template_string, script_path, job_name, job_config)\n\n        channel_script_path = self.channel.push_file(script_path, self.channel.script_dir)\n\n        submit_options = ''\n        if self.queue is not None:\n            submit_options = '{0} -q {1}'.format(submit_options, self.queue)\n        if self.account is not None:\n            submit_options = '{0} -A {1}'.format(submit_options, self.account)\n\n        launch_cmd = \"qsub {0} {1}\".format(submit_options, channel_script_path)\n        retcode, stdout, stderr = self.channel.execute_wait(launch_cmd, 10)\n\n        job_id = None\n        if retcode == 0:\n            for line in stdout.split('\\n'):\n                if line.strip():\n                    job_id = line.strip()\n                    self.resources[job_id] = {'job_id': job_id, 'status': 'PENDING', 'blocksize': blocksize}\n        else:\n            message = \"Command '{}' failed with return code {}\".format(launch_cmd, retcode)\n            if (stdout is not None) and (stderr is not None):\n                message += \"\\nstderr:{}\\nstdout{}\".format(stderr.strip(), stdout.strip())\n            logger.error(message)\n\n        return job_id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncancel the jobs specified by a list of job ids.", "response": "def cancel(self, job_ids):\n        ''' Cancels the jobs specified by a list of job ids\n\n        Args:\n        job_ids : [<job_id> ...]\n\n        Returns :\n        [True/False...] : If the cancel operation fails the entire list will be False.\n        '''\n\n        job_id_list = ' '.join(job_ids)\n        retcode, stdout, stderr = self.channel.execute_wait(\"qdel {0}\".format(job_id_list), 3)\n        rets = None\n        if retcode == 0:\n            for jid in job_ids:\n                self.resources[jid]['status'] = translate_table['E']  # Setting state to exiting\n            rets = [True for i in job_ids]\n        else:\n            rets = [False for i in job_ids]\n\n        return rets"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_identity(self):\n        identity = struct.pack('!BI', 0, self._base_identity)\n        self._base_identity += 1\n\n        if self._base_identity >= 2 ** 32:\n            self._base_identity = 0\n\n        return identity", "response": "Generate a unique but random identity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _wait_peers(self):\n        # Make sure we remove dead peers.\n        for p in self._peers[:]:\n            if p.dead:\n                self._peers.remove(p)\n\n        while not self._peers:\n            await self._peers.wait_not_empty()", "response": "Blocks until at least one non - dead peer is available."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _fair_get_in_peer(self):\n        peer = None\n\n        while not peer:\n            await self._wait_peers()\n\n            # This rotates the list, implementing fair-queuing.\n            peers = list(self._in_peers)\n\n            tasks = [asyncio.ensure_future(self._in_peers.wait_change())]\n            tasks.extend([\n                asyncio.ensure_future(\n                    p.inbox.wait_not_empty(),\n                    loop=self.loop,\n                )\n                for p in peers\n            ])\n\n            try:\n                done, pending = await asyncio.wait(\n                    tasks,\n                    return_when=asyncio.FIRST_COMPLETED,\n                    loop=self.loop,\n                )\n            finally:\n                for task in tasks:\n                    task.cancel()\n\n            tasks.pop(0)  # pop the wait_change task.\n            peer = next(\n                (\n                    p\n                    for task, p in zip(tasks, peers)\n                    if task in done and not task.cancelled()\n                ),\n                None,\n            )\n\n        return peer", "response": "Get the first available inbound peer in a fair manner."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def _fair_recv(self):\n        with await self._read_lock:\n            peer = await self._fair_get_in_peer()\n            result = peer.inbox.read_nowait()\n\n        return result", "response": "Receives from all the existing peers rotating the list of peers every\n        time."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the first available peer with non - blocking inbox or wait until one is ready to be written to.", "response": "async def _fair_get_out_peer(self):\n        \"\"\"\n        Get the first available peer, with non-blocking inbox or wait until one\n        meets the condition.\n\n        :returns: The peer whose outbox is ready to be written to.\n        \"\"\"\n        peer = None\n\n        while not peer:\n            await self._wait_peers()\n\n            # This rotates the list, implementing fair-queuing.\n            peers = list(self._out_peers)\n\n            tasks = [asyncio.ensure_future(self._out_peers.wait_change())]\n            tasks.extend([\n                asyncio.ensure_future(\n                    p.outbox.wait_not_full(),\n                    loop=self.loop,\n                )\n                for p in peers\n            ])\n\n            try:\n                done, pending = await asyncio.wait(\n                    tasks,\n                    return_when=asyncio.FIRST_COMPLETED,\n                    loop=self.loop,\n                )\n            finally:\n                for task in tasks:\n                    task.cancel()\n\n            tasks.pop(0)  # pop the wait_change task.\n            peer = next(  # pragma: no cover\n                (\n                    p\n                    for task, p in zip(tasks, peers)\n                    if task in done and not p.outbox.full()\n                ),\n                None,\n            )\n\n        return peer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a set of frames from the first available non - blocking peer or wait until one is used.", "response": "async def _fair_send(self, frames):\n        \"\"\"\n        Send from the first available, non-blocking peer or wait until one\n        meets the condition.\n\n        :params frames: The frames to write.\n        :returns: The peer that was used.\n        \"\"\"\n        peer = await self._fair_get_out_peer()\n        peer.outbox.write_nowait(frames)\n        return peer"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def subscribe(self, topic):\n        if self.socket_type not in {SUB, XSUB}:\n            raise AssertionError(\n                \"A %s socket cannot subscribe.\" % self.socket_type.decode(),\n            )\n\n        # Do this **BEFORE** awaiting so that new connections created during\n        # the execution below honor the setting.\n        self._subscriptions.append(topic)\n        tasks = [\n            asyncio.ensure_future(\n                peer.connection.local_subscribe(topic),\n                loop=self.loop,\n            )\n            for peer in self._peers\n            if peer.connection\n        ]\n\n        if tasks:\n            try:\n                await asyncio.wait(tasks, loop=self.loop)\n            finally:\n                for task in tasks:\n                    task.cancel()", "response": "Subscribe the socket to the specified topic."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def unsubscribe(self, topic):\n        if self.socket_type not in {SUB, XSUB}:\n            raise AssertionError(\n                \"A %s socket cannot unsubscribe.\" % self.socket_type.decode(),\n            )\n\n        # Do this **BEFORE** awaiting so that new connections created during\n        # the execution below honor the setting.\n        self._subscriptions.remove(topic)\n        tasks = [\n            asyncio.ensure_future(\n                peer.connection.local_unsubscribe(topic),\n                loop=self.loop,\n            )\n            for peer in self._peers\n            if peer.connection\n        ]\n\n        if tasks:\n            try:\n                await asyncio.wait(tasks, loop=self.loop)\n            finally:\n                for task in tasks:\n                    task.cancel()", "response": "Unsubscribe the socket from the specified topic."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef playerSurrendered(cfg):\n    if cfg.numAgents + cfg.numBots == 2:\n          otherResult = c.RESULT_VICTORY\n    else: otherResult = c.RESULT_UNDECIDED # if multiple players remain, they need to finish the match\n    return assignValue(cfg, c.RESULT_DEFEAT, otherResult)", "response": "the player has forceibly left the game"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassigning a value to a player in a match circumstances.", "response": "def assignValue(cfg, playerValue, otherValue):\n    \"\"\"artificially determine match results given match circumstances.\n    WARNING: cheating will be detected and your player will be banned from server\"\"\"\n    player = cfg.whoAmI()\n    result = {}\n    for p in cfg.players:\n        if p.name == player.name:   val = playerValue\n        else:                       val = otherValue\n        result[p.name] = val\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef idPlayerResults(cfg, rawResult):\n    result = {}\n    knownPlayers = []\n    dictResult = {plyrRes.player_id : plyrRes.result for plyrRes in rawResult}\n    for p in cfg.players:\n        if p.playerID and p.playerID in dictResult: # identified player w/ result\n            knownPlayers.append(p)\n            result[p.name] = dictResult[p.playerID]\n    #if len(knownPlayers) == len(dictResult) - 1: # identified all but one player\n    #    for p in cfg.players: # search for the not identified player\n    #        if p in knownPlayers: continue # already found\n    #        result.append( [p.name, p.playerID, dictResult[p.playerID]] )\n    #        break # found missing player; stop searching\n    #for r in result:\n    #    print(\"result:>\", r)\n    return result", "response": "interpret standard rawResult for all players with known IDs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an ObjectPosition to the object.", "response": "def save_model(self, request, obj, form, change):\n        \"\"\"Add an ObjectPosition to the object.\"\"\"\n        super(GenericPositionsAdmin, self).save_model(request, obj, form,\n                                                      change)\n        c_type = ContentType.objects.get_for_model(obj)\n        try:\n            ObjectPosition.objects.get(content_type__pk=c_type.id,\n                                       object_id=obj.id)\n        except ObjectPosition.DoesNotExist:\n            position_objects = ObjectPosition.objects.filter(\n                content_type__pk=c_type.id, position__isnull=False).order_by(\n                    '-position')\n            try:\n                position = (position_objects[0].position + 1)\n            except IndexError:\n                position = 1\n            ObjectPosition.objects.create(\n                content_object=obj, position=position)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_dict(self):\n\n        result_dict = super(Profile, self).as_dict()\n\n        statuses = list()\n        version = None\n        titles = list()\n        descriptions = list()\n        platforms = list()\n        selects = list()\n\n        for child in self.children:\n            if isinstance(child, Version):\n                version = child.as_dict()\n            elif isinstance(child, Status):\n                statuses.append(child.as_dict())\n            elif isinstance(child, Title):\n                titles.append(child.as_dict())\n            elif isinstance(child, Description):\n                descriptions.append(child.as_dict())\n            elif isinstance(child, Platform):\n                platforms.append(child.as_dict())\n            elif isinstance(child, Select):\n                selects.append(child.as_dict())\n\n        if version is not None:\n            result_dict['version'] = version\n        if len(statuses) > 0:\n            result_dict['statuses'] = statuses\n        if len(titles) > 0:\n            result_dict['titles'] = titles\n        if len(descriptions) > 0:\n            result_dict['descriptions'] = descriptions\n        if len(platforms) > 0:\n            result_dict['platforms'] = platforms\n        if len(selects) > 0:\n            result_dict['selects'] = selects\n\n        return result_dict", "response": "Serializes the object necessary data in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the xml element contents to match the instance contents.", "response": "def update_xml_element(self):\n        \"\"\"\n        Updates the xml element contents to matches the instance contents.\n\n        :returns: Updated XML element.\n        :rtype: lxml.etree._Element\n        \"\"\"\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        self.xml_element.clear()\n\n        if hasattr(self, 'abstract'):\n            self.xml_element.set('abstract', self.abstract)\n        if hasattr(self, 'prohibitChanges'):\n            self.xml_element.set('prohibitChanges', self.prohibitChanges)\n        self.xml_element.set('id', self.id)\n\n        for child in self.children:\n            if hasattr(child, 'update_xml_element'):\n                child.update_xml_element()\n                if hasattr(child, 'xml_element'):\n                    self.xml_element.append(child.xml_element)\n\n        return self.xml_element"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef managed(name, packages=None, requirements=None, saltenv='base', user=None):\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    comments = []\n\n    # Create virutalenv\n    try:\n        installation_comment = __salt__['conda.create'](name, user=user)\n        if installation_comment.endswith('created'):\n            comments.append('Virtual enviroment \"%s\" created' % name)\n        else:\n            comments.append('Virtual enviroment \"%s\" already exists' % name)\n    except Exception as e:\n        ret['comment'] = e\n        ret['result'] = False\n        return ret\n\n    # Install packages\n    if packages is not None:\n        installation_ret = installed(packages, env=name, saltenv=saltenv, user=user)\n        ret['result'] = ret['result'] and installation_ret['result']\n        comments.append('From list [%s]' % installation_ret['comment'])\n        ret['changes'].update(installation_ret['changes'])\n\n    if requirements is not None:\n        installation_ret = installed(requirements, env=name, saltenv=saltenv, user=user)\n        ret['result'] = ret['result'] and installation_ret['result']\n        comments.append('From file [%s]' % installation_ret['comment'])\n        ret['changes'].update(installation_ret['changes'])\n\n    ret['comment'] = '. '.join(comments)\n    return ret", "response": "Create and install python requirements in a conda enviroment"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef installed(name, env=None, saltenv='base', user=None):\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n\n    # Generates packages list\n    packages = []\n    if os.path.exists(name) or name.startswith('salt://'):\n        if name.startswith('salt://'):\n            lines = __salt__['cp.get_file_str'](name, saltenv)\n            lines = lines.split('\\n')\n        elif os.path.exists(name):\n            f = open(name, mode='r')\n            lines = f.readlines()\n            f.close()\n\n        for line in lines:\n            line = line.strip()\n            if line != '' and not line.startswith('#'):\n                line = line.split('#')[0].strip()    # Remove inline comments\n                packages.append(line)\n    else:\n        packages = [pkg.strip() for pkg in name.split(',')]\n\n    conda_list = __salt__['conda.list'](env=env, user=user)\n\n    def extract_info(pkgname):\n        pkgname, pkgversion = package, ''\n        pkgname, pkgversion = (package.split('==')[0], package.split('==')[1]\n                              ) if '==' in package else (package, pkgversion)\n        pkgname, pkgversion = (package.split('>=')[0], package.split('>=')[1]\n                              ) if '>=' in package else (pkgname, pkgversion)\n        pkgname, pkgversion = (package.split('>')[0], package.split('>=')[1]\n                              ) if '>' in package else (pkgname, pkgversion)\n        return pkgname, pkgversion\n\n    installed, failed, old = 0, 0, 0\n    for package in packages:\n        pkgname, pkgversion = extract_info(package)\n        conda_pkgname = pkgname + ' ' * (26 - len(pkgname)) + pkgversion\n\n        if conda_pkgname not in conda_list:\n            installation = __salt__['conda.install'](package, env=env, user=user)\n            if installation['retcode'] == 0:\n                ret['changes'][package] = 'installed'\n                installed += 1\n            else:\n                ret['changes'][package] = installation\n                failed += 1\n        else:\n            old += 1\n\n    comments = []\n    if installed > 0:\n        comments.append('{0} installed'.format(installed))\n    if failed > 0:\n        ret['result'] = False\n        comments.append('{0} failed'.format(failed))\n    if old > 0:\n        comments.append('{0} already installed'.format(old))\n\n    ret['comment'] = ', '.join(comments)\n    return ret", "response": "Installs a single package or list of packages in a requirements. txt file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_configs(self, command):\n\n        logger.debug(\"Requesting one block with {} nodes per block and {} tasks per node\".format(\n            self.nodes_per_block, self.tasks_per_node))\n\n        job_config = {}\n        job_config[\"submit_script_dir\"] = self.channel.script_dir\n        job_config[\"nodes\"] = self.nodes_per_block\n        job_config[\"walltime\"] = wtime_to_minutes(self.walltime)\n        job_config[\"overrides\"] = self.overrides\n        job_config[\"user_script\"] = command\n\n        job_config[\"user_script\"] = self.launcher(command,\n                                                  self.tasks_per_node,\n                                                  self.nodes_per_block)\n        return job_config", "response": "Compose a dictionary with information for writing the submit script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef submit(self, command=\"\", blocksize=1, job_name=\"parsl.auto\"):\n        ''' The submit method takes the command string to be executed upon\n        instantiation of a resource most often to start a pilot (such as IPP engine\n        or even Swift-T engines).\n\n        Args :\n             - command (str) : The bash command string to be executed.\n             - blocksize (int) : Blocksize to be requested\n\n        KWargs:\n             - job_name (str) : Human friendly name to be assigned to the job request\n\n        Returns:\n             - A job identifier, this could be an integer, string etc\n\n        Raises:\n             - ExecutionProviderException or its subclasses\n        '''\n\n        # Note: Fix this later to avoid confusing behavior.\n        # We should always allocate blocks in integer counts of node_granularity\n        if blocksize < self.nodes_per_block:\n            blocksize = self.nodes_per_block\n\n        # Set job name\n        job_name = \"{0}.{1}\".format(job_name, time.time())\n\n        # Set script path\n        script_path = \"{0}/{1}.submit\".format(self.script_dir, job_name)\n        script_path = os.path.abspath(script_path)\n\n        job_config = self.get_configs(command, blocksize)\n\n        logger.debug(\"Writing submit script\")\n        self._write_submit_script(template_string, script_path, job_name, job_config)\n\n        channel_script_path = self.channel.push_file(script_path, self.channel.script_dir)\n        cmd = \"qsub -terse {0}\".format(channel_script_path)\n        retcode, stdout, stderr = super().execute_wait(cmd, 10)\n\n        if retcode == 0:\n            for line in stdout.split('\\n'):\n                job_id = line.strip()\n                if not job_id:\n                    continue\n                self.resources[job_id] = {'job_id': job_id, 'status': 'PENDING', 'blocksize': blocksize}\n                return job_id\n        else:\n            print(\"[WARNING!!] Submission of command to scale_out failed\")\n            logger.error(\"Retcode:%s STDOUT:%s STDERR:%s\", retcode, stdout.strip(), stderr.strip())", "response": "This method is used to submit a command to the IPP engine."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qr2scad(stream):\n\n    img = Image.open(stream)\n\n    # Convert to black and white 8-bit\n    if img.mode != 'L':\n        img = img.convert('L')\n\n    # Invert color to get the right bounding box\n    img = ImageOps.invert(img)\n\n    bbox = img.getbbox()\n\n    # Crop to only contain contents within the PDPs\n    img = img.crop(bbox)\n\n    width, height = img.size\n\n    assert width == height,\\\n        'The QR code should be a square, but we found it to be %(w)sx%(h)s' % {\n            'w': width,\n            'h': height\n        }\n\n    qr_side = width\n\n    # QR code superpixel size\n    qr_pixel_size = (list(img.getdata()).index(0) / PDP_SIDE)\n\n    # Get the resize factor from the PDP size\n    new_size = qr_side / qr_pixel_size\n\n    # Set a more reasonable size\n    img = img.resize((new_size, new_size))\n    qr_side = new_size\n\n    img_matrix = img.load()\n\n    result = 'module _qr_code_dot() {\\n'\n    result += '    cube([%(block_side)s, %(block_side)s, 1]);\\n' % {\n        'block_side': BLOCK_SIDE\n    }\n    result += '}\\n'\n\n    result += 'module qr_code() {\\n'\n    for row in range(qr_side):\n        for column in range(qr_side):\n            if img_matrix[column, row] != 0:\n                result += '    translate([%(x)s, %(y)s, 0])' % {\n                    'x': BLOCK_SIZE * column - qr_side / 2,\n                    'y': -BLOCK_SIZE * row + qr_side / 2\n                }\n                result += ' _qr_code_dot();\\n'\n    result += '}\\n'\n    result += 'qr_code_size = %d;' % (qr_side)\n\n    return result", "response": "Convert black pixels to OpenSCAD cubes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload given envfile and run command with params", "response": "def run(*args):\n    \"\"\"Load given `envfile` and run `command` with `params`\"\"\"\n\n    if not args:\n        args = sys.argv[1:]\n\n    if len(args) < 2:\n        print('Usage: runenv <envfile> <command> <params>')\n        sys.exit(0)\n    os.environ.update(create_env(args[0]))\n    os.environ['_RUNENV_WRAPPED'] = '1'\n    runnable_path = args[1]\n\n    if not runnable_path.startswith(('/', '.')):\n        runnable_path = spawn.find_executable(runnable_path)\n\n    try:\n        if not(stat.S_IXUSR & os.stat(runnable_path)[stat.ST_MODE]):\n            print('File `%s is not executable' % runnable_path)\n            sys.exit(1)\n        return subprocess.check_call(\n            args[1:], env=os.environ\n        )\n    except subprocess.CalledProcessError as e:\n        return e.returncode"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_env(env_file):\n\n    environ = {}\n    with open(env_file, 'r') as f:\n        for line in f.readlines():\n            line = line.rstrip(os.linesep)\n            if '=' not in line:\n                continue\n            if line.startswith('#'):\n                continue\n            key, value = line.split('=', 1)\n            environ[key] = parse_value(value)\n    return environ", "response": "Create os. environ and\n    variables got from given env_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow information about site.", "response": "def info(args):\n    \" Show information about site. \"\n\n    site = find_site(args.PATH)\n    print_header(\"%s -- install information\" % site.get_name())\n    LOGGER.debug(site.get_info(full=True))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all sites in a Makesite site.", "response": "def ls(args):\n    \"\"\"\n    List sites\n    ----------\n\n    Show list of installed sites.\n\n    ::\n\n        usage: makesite ls [-h] [-v] [-p PATH]\n\n        Show list of installed sites.\n\n        optional arguments:\n        -p PATH, --path PATH  path to makesite sites instalation dir. you can set it\n                                in $makesite_home env variable.\n\n    Examples: ::\n\n            makesite ls\n\n    \"\"\"\n\n    assert args.path, \"Not finded MAKESITE HOME.\"\n\n    print_header(\"Installed sites:\")\n    for site in gen_sites(args.path):\n        LOGGER.debug(site.get_info())\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning site update --------------- Run updates for site or all installed. :: usage: main.py update [-h] [-v] [-p PATH] [SITE] Run site update positional arguments: SITE Path to site or name (project.branch) optional arguments: -p PATH, --path PATH path to makesite sites instalation dir. you can set it in $makesite_home env variable. Examples: :: # Update all makesite instances on server $ makesite update # Update by project name makesite update intaxi # Update by project name makesite update intaxi.develop # Update by project path makesite update /var/www/intaxi/master", "response": "def update(args):\n    \"\"\"\n    Run site update\n    ---------------\n\n    Run updates for site or all installed.\n\n    ::\n\n        usage: main.py update [-h] [-v] [-p PATH] [SITE]\n\n        Run site update\n\n        positional arguments:\n        SITE                  Path to site or name (project.branch)\n\n        optional arguments:\n        -p PATH, --path PATH  path to makesite sites instalation dir. you can set it\n                                in $makesite_home env variable.\n\n    Examples: ::\n\n        # Update all makesite instances on server\n        $ makesite update\n\n        # Update by project name\n        makesite update intaxi\n\n        # Update by project name\n        makesite update intaxi.develop\n\n        # Update by project path\n        makesite update /var/www/intaxi/master\n\n\n    \"\"\"\n    if args.SITE:\n        site = find_site(args.SITE, path=args.path)\n        return site.run_update()\n\n    for site in gen_sites(args.path):\n        site.run_update()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncopying module source to current directory.", "response": "def module(args):\n    \" Copy module source to current directory. \"\n\n    mod = op.join(settings.MOD_DIR, args.MODULE)\n    assert op.exists(mod), \"Not found module: %s\" % args.MODULE\n    if not args.DEST.startswith(op.sep):\n        args.DEST = op.join(getcwd(), args.DEST)\n    print_header(\"Copy module source\")\n    copytree(mod, args.DEST)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef template(args):\n    \" Add or remove templates from site. \"\n    site = Site(args.PATH)\n    if args.ACTION == \"add\":\n        return site.add_template(args.TEMPLATE)\n    return site.remove_template(args.TEMPLATE)", "response": "Add or remove templates from site."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shell(args):\n    \" A helper command to be used for shell integration \"\n    print\n    print \"# Makesite integration \"\n    print \"# ==================== \"\n    print \"export MAKESITE_HOME=%s\" % args.path\n    print \"source %s\" % op.join(settings.BASEDIR, 'shell.sh')\n    print", "response": "A helper command to be used for shell integration"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninstall site from sources or module", "response": "def install(args):\n    \" Install site from sources or module \"\n\n    # Deactivate virtualenv\n    if 'VIRTUAL_ENV' in environ:\n        LOGGER.warning('Virtualenv enabled: %s' % environ['VIRTUAL_ENV'])\n\n    # Install from base modules\n    if args.module:\n        args.src = op.join(settings.MOD_DIR, args.module)\n        assert op.exists(args.src), \"Not found module: %s\" % args.module\n\n    # Fix project name\n    args.PROJECT = args.PROJECT.replace('-', '_')\n\n    args.home = op.abspath(args.path)\n\n    # Create engine\n    engine = Installer(args)\n    args.deploy_dir = engine.target_dir\n\n    # Check dir exists\n    assert args.info or args.repeat or args.update or not op.exists(\n        engine.target_dir), \"Path %s exists. Stop deploy.\" % args.deploy_dir\n\n    try:\n        if args.repeat:\n            site = Site(engine.target_dir)\n            site.run_install()\n            return site\n\n        site = engine.clone_source()\n        if not site:\n            return True\n\n        engine.build(args.update)\n        site.run_install()\n        return site\n\n    except (CalledProcessError, AssertionError):\n        LOGGER.error(\"Installation failed\")\n        LOGGER.error(\"Fix errors and repeat installation with (-r) or run 'makesite uninstall %s' for cancel.\" % args.deploy_dir)\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _gradient(self, diff, d, coords):\n        denom = np.copy(d)\n        denom[denom == 0] = 1e-5\n\n        with np.errstate(divide='ignore', invalid='ignore'):\n            K = -2 * diff / denom\n\n        K[np.isnan(K)] = 0\n\n        g = np.empty_like(coords)\n        for n in range(self.n):\n            for i in range(self.m):\n                # Vectorised version of (~70 times faster)\n                # for j in range(self.m):\n                #     delta_g = ((coords[i, n] - coords[j, n]) * K[i, j]).sum()\n                #     g[i, n] += delta_g\n                g[i, n] = ((coords[i, n] - coords[:, n]) * K[i, :]).sum()\n\n        return g", "response": "Compute the gradient of the log likelihood of a set of univariate un"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _error_and_gradient(self, x):\n        coords = x.reshape((self.m, self.n))\n        d = squareform(pdist(coords))\n        diff = self.D - d\n        error = self._error(diff)\n        gradient = self._gradient(diff, d, coords)\n        return error, gradient.ravel()", "response": "Compute the error and gradient of the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef optimize(self, start=None, n=2):\n        self.n = n\n\n        if start is None:\n            start = np.random.rand(self.m * self.n) * 10\n\n        optim = minimize(\n            fun=self._error_and_gradient,\n            x0=start,\n            jac=True,\n            method='L-BFGS-B')\n\n        index = self.index if hasattr(self, \"index\") else None\n\n        return Projection.from_optimize_result(\n            result=optim, n=self.n, m=self.m, index=index)", "response": "Run multidimensional scaling on this distance matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns multiple optimizations using different starting coordinates.", "response": "def optimize_batch(self, batchsize=10, returns='best', paralell=True):\n        \"\"\"\n        Run multiple optimizations using different starting coordinates.\n\n        Args:\n            batchsize (`int`): Number of optimizations to run.\n            returns (`str`): If ``'all'``, return results of all optimizations,\n                ordered by stress, ascending. If ``'best'`` return the\n                projection with the lowest stress.\n            parallel (`bool`): If ``True``, run optimizations in parallel.\n\n        Examples:\n\n            .. doctest::\n\n               >>> import pandas as pd\n               >>> from pymds import DistanceMatrix\n               >>> dist = pd.DataFrame({\n               ...    'a': [0.0, 1.0, 2.0],\n               ...    'b': [1.0, 0.0, 3 ** 0.5],\n               ...    'c': [2.0, 3 ** 0.5, 0.0]} , index=['a', 'b', 'c'])\n               >>> dm = DistanceMatrix(dist)\n               >>> batch = dm.optimize_batch(batchsize=3, returns='all')\n               >>> len(batch)\n               3\n               >>> type(batch[0])\n               <class 'pymds.mds.Projection'>\n\n        Returns:\n            `list` or :py:class:`pymds.Projection`:\n\n                `list`: Length batchsize, containing instances of\n                :py:class:`pymds.Projection`. Sorted by stress, ascending.\n\n                or\n\n                :py:class:`pymds.Projection`: Projection with the lowest\n                stress.\n        \"\"\"\n        if returns not in ('best', 'all'):\n            raise ValueError('returns must be either \"best\" or \"all\"')\n\n        starts = [np.random.rand(self.m * 2) * 10 for i in range(batchsize)]\n\n        if paralell:\n            with Pool() as p:\n                results = p.map(self.optimize, starts)\n        else:\n            results = map(self.optimize, starts)\n\n        results = sorted(results, key=lambda x: x.stress)\n\n        return results if returns == 'all' else results[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_optimize_result(cls, result, n, m, index=None):\n        coords = pd.DataFrame(result.x.reshape((m, n)), index=index)\n        projection = cls(coords)\n        projection.stress = result.fun\n        return projection", "response": "Construct a Projection from an optimization result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the samples shared with another dataset.", "response": "def _get_samples_shared_with(self, other, index=None):\n        \"\"\"Find samples shared with another dataset.\n\n        Args:\n            other\n                (:py:class:`pymds.Projection` or :py:class:`pandas.DataFrame`\n                    or `array-like`):\n                The other dataset. If `other` is an instance of\n                :py:class:`pymds.Projection` or :py:class:`pandas.DataFrame`,\n                then `other` must have indexes in common with this projection.\n                If `array-like`, then other must have same dimensions as\n                `self.coords`.\n            index (`list-like` or `None`): If `other` is an instance of\n                :py:class:`pymds.Projection` or :py:class:`pandas.DataFrame`\n                then only return samples in index.\n\n        Returns:\n            `tuple`: containing:\n\n                - this (`numpy.array`) Shape [`x`, `n`].\n                - other (`numpy.array`) Shape [`x`, `n`].\n        \"\"\"\n        if isinstance(other, (pd.DataFrame, Projection)):\n            df_other = other.coords if isinstance(other, Projection) else other\n\n            if len(set(df_other.index)) != len(df_other.index):\n                raise ValueError(\"other index has duplicates\")\n\n            if len(set(self.coords.index)) != len(self.coords.index):\n                raise ValueError(\"This projection index has duplicates\")\n\n            if index:\n                uniq_idx = set(index)\n\n                if len(uniq_idx) != len(index):\n                    raise ValueError(\"index has has duplicates\")\n\n                if uniq_idx - set(df_other.index):\n                    raise ValueError(\"index has samples not in other\")\n\n                if uniq_idx - set(self.coords.index):\n                    raise ValueError(\n                        \"index has samples not in this projection\")\n\n            else:\n                uniq_idx = set(df_other.index) & set(self.coords.index)\n\n                if not len(uniq_idx):\n                    raise ValueError(\n                        \"No samples shared between other and this projection\")\n\n            idx = list(uniq_idx)\n            return self.coords.loc[idx, :].values, df_other.loc[idx, :].values\n\n        else:\n            other = np.array(other)\n\n            if other.shape != self.coords.shape:\n                raise ValueError(\n                    \"array-like must have the same shape as self.coords\")\n\n            return self.coords.values, other"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the coordinates of the current object.", "response": "def plot(self, **kwds):\n        \"\"\"Plot the coordinates in the first two dimensions of the projection.\n\n        Removes axis and tick labels, and sets the grid spacing to 1 unit.\n        One way to display the grid is to use `Seaborn`_:\n\n        Args:\n            **kwds: Passed to :py:meth:`pandas.DataFrame.plot.scatter`.\n\n        Examples:\n\n            >>> from pymds import DistanceMatrix\n            >>> import pandas as pd\n            >>> import seaborn as sns\n            >>> sns.set_style('whitegrid')\n            >>> dist = pd.DataFrame({\n            ...    'a': [0.0, 1.0, 2.0],\n            ...    'b': [1.0, 0.0, 3 ** 0.5],\n            ...    'c': [2.0, 3 ** 0.5, 0.0]} , index=['a', 'b', 'c'])\n            >>> dm = DistanceMatrix(dist)\n            >>> pro = dm.optimize()\n            >>> ax = pro.plot(c='black', s=50, edgecolor='white')\n\n        Returns:\n            :py:obj:`matplotlib.axes.Axes`\n\n        .. _Seaborn:\n            https://seaborn.pydata.org/\n        \"\"\"\n        ax = plt.gca()\n        self.coords.plot.scatter(x=0, y=1, ax=ax, **kwds)\n        ax.get_xaxis().set_major_locator(MultipleLocator(base=1.0))\n        ax.get_yaxis().set_major_locator(MultipleLocator(base=1.0))\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_xlabel('')\n        ax.set_ylabel('')\n        ax.set_aspect(1)\n        return ax"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot_lines_to(self, other, index=None, **kwds):\n        start, end = self._get_samples_shared_with(other, index=index)\n        segments = [[start[i, :], end[i, :]] for i in range(start.shape[0])]\n        ax = plt.gca()\n        ax.add_artist(LineCollection(segments=segments, **kwds))\n        return ax", "response": "Plot lines from samples shared between this dataset and another dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\norients this projection to another dataset.", "response": "def orient_to(self, other, index=None, inplace=False, scaling=False):\n        \"\"\"Orient this Projection to another dataset.\n\n        Orient this projection using reflection, rotation and translation to\n        match another projection using procrustes superimposition. Scaling is\n        optional.\n\n        Args:\n            other\n                (:py:class:`pymds.Projection` or :py:class:`pandas.DataFrame`\n                or `array-like`):\n                The other dataset to orient this projection to.\n                If other is an instance of :py:class:`pymds.Projection` or\n                :py:class:`pandas.DataFrame`, then other must have indexes in\n                common with this projection. If `array-like`, then other must\n                have the same dimensions as self.coords.\n            index (`list-like` or `None`): If other is an instance of\n                :py:class:`pandas.DataFrame` or :py:class:`pymds.Projection`\n                then orient this projection to other using only samples in\n                index.\n            inplace (`bool`): Update coordinates of this projection inplace,\n                or return an instance of :py:class:`pymds.Projection`.\n            scaling (`bool`): Allow scaling. (Not implemented yet).\n\n        Examples:\n\n            .. doctest::\n\n                >>> import numpy as np\n                >>> import pandas as pd\n                >>> from pymds import Projection\n                >>> array = np.random.randn(10, 2)\n                >>> pro = Projection(pd.DataFrame(array))\n                >>> # Flip left-right, rotate 90 deg and translate\n                >>> other = np.fliplr(array)\n                >>> other = np.dot(other, np.array([[0, -1], [1, 0]]))\n                >>> other += np.array([10, -5])\n                >>> oriented = pro.orient_to(other)\n                >>> (oriented.coords.values - other).sum() < 1e-6\n                True\n\n        Returns:\n            :py:class:`pymds.Projection`: If ``inplace=False``.\n        \"\"\"\n        arr_self, arr_other = self._get_samples_shared_with(other, index=index)\n\n        if scaling:\n            raise NotImplementedError()\n\n        else:\n            self_mean = arr_self.mean(axis=0)\n            other_mean = arr_other.mean(axis=0)\n\n            A = arr_self - self_mean\n            B = arr_other - other_mean\n            R, _ = orthogonal_procrustes(A, B)\n\n            to_rotate = self.coords - self.coords.mean(axis=0)\n            oriented = np.dot(to_rotate, R) + other_mean\n            oriented = pd.DataFrame(oriented, index=self.coords.index)\n\n        if inplace:\n            self.coords = oriented\n        else:\n            return Projection(oriented)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the conda prefix for a particular user", "response": "def conda_prefix(user=None):\n    \"\"\"\n    Get the conda prefix for a particular user (~/anaconda)\n    If user is None it defaults to /opt/anaconda\n    \"\"\"\n    if user == 'root':\n        return __salt__['grains.get']('conda:prefix', default='/opt/anaconda')\n    else:\n        if user is None:\n            user = __salt__['pillar.get']('system:user', 'ubuntu')\n        for u in pwd.getpwall():\n            if u.pw_name == user:\n                return os.path.join(u.pw_dir, 'anaconda')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a conda env", "response": "def create(name, packages=None, user=None):\n    \"\"\"\n    Create a conda env\n    \"\"\"\n    packages = packages or ''\n    packages = packages.split(',')\n    packages.append('pip')\n    args = packages + ['--yes', '-q']\n    cmd = _create_conda_cmd('create', args=args, env=name, user=user)\n    ret = _execcmd(cmd, user=user, return0=True)\n\n    if ret['retcode'] == 0:\n        ret['result'] = True\n        ret['comment'] = 'Virtual enviroment \"%s\" successfully created' % name\n    else:\n        if ret['stderr'].startswith('Error: prefix already exists:'):\n            ret['result'] = True\n            ret['comment'] = 'Virtual enviroment \"%s\" already exists' % name\n        else:\n            ret['result'] = False\n            ret['error'] = salt.exceptions.CommandExecutionError(ret['stderr'])\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_(env=None, user=None):\n    cmd = _create_conda_cmd('list', args=['--json'], env=env, user=user)\n    ret = _execcmd(cmd, user=user)\n    if ret['retcode'] == 0:\n        pkg_list = json.loads(ret['stdout'])\n        packages = {}\n        for pkg in pkg_list:\n            pkg_info = pkg.split('-')\n            name, version, build = '-'.join(pkg_info[:-2]), pkg_info[-2], pkg_info[-1]\n            packages[name] = {'version': version, 'build': build}\n        return packages\n    else:\n        return ret", "response": "List the installed packages on an environment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(packages, env=None, user=None):\n    packages = ' '.join(packages.split(','))\n    cmd = _create_conda_cmd('update', args=[packages, '--yes', '-q'], env=env, user=user)\n    return _execcmd(cmd, user=user)", "response": "Update conda packages in a conda environment"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(packages, env=None, user=None):\n    packages = ' '.join(packages.split(','))\n    cmd = _create_conda_cmd('remove', args=[packages, '--yes', '-q'], env=env, user=user)\n    return _execcmd(cmd, user=user, return0=True)", "response": "Remove conda packages in a conda environment"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_conda_cmd(conda_cmd, args=None, env=None, user=None):\n    cmd = [_get_conda_path(user=user), conda_cmd]\n    if env:\n        cmd.extend(['-n', env])\n    if args is not None and isinstance(args, list) and args != []:\n        cmd.extend(args)\n    return cmd", "response": "Utility to create a valid conda command"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initDeviceScan(self):\n        self.__isIphone = self.detectIphoneOrIpod()\n        self.__isAndroidPhone = self.detectAndroidPhone()\n        self.__isTierTablet = self.detectTierTablet()\n        self.__isTierIphone = self.detectTierIphone()\n        self.__isTierRichCss = self.detectTierRichCss()\n        self.__isTierGenericMobile = self.detectTierOtherPhones()", "response": "Initialize Key Stored Values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning detection of an iPhone", "response": "def detectIphone(self):\n        \"\"\"Return detection of an iPhone\n\n        Detects if the current device is an iPhone.\n        \"\"\"\n        # The iPad and iPod touch say they're an iPhone! So let's disambiguate.\n        return UAgentInfo.deviceIphone in self.__userAgent \\\n            and not self.detectIpad() \\\n            and not self.detectIpod()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns detection of an iPhone or iPod Touch", "response": "def detectIphoneOrIpod(self):\n        \"\"\"Return detection of an iPhone or iPod Touch\n\n        Detects if the current device is an iPhone or iPod Touch.\n        \"\"\"\n        #We repeat the searches here because some iPods may report themselves as an iPhone, which would be okay.\n        return UAgentInfo.deviceIphone in self.__userAgent \\\n            or UAgentInfo.deviceIpod in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn detection of an Android device", "response": "def detectAndroid(self):\n        \"\"\"Return detection of an Android device\n\n        Detects *any* Android OS-based device: phone, tablet, and multi-media player.\n        Also detects Google TV.\n        \"\"\"\n        if UAgentInfo.deviceAndroid in self.__userAgent \\\n           or self.detectGoogleTV():\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detectAndroidPhone(self):\n        #First, let's make sure we're on an Android device.\n        if not self.detectAndroid():\n            return False\n\n        #If it's Android and has 'mobile' in it, Google says it's a phone.\n        if UAgentInfo.mobile in self.__userAgent:\n            return True\n\n        #Special check for Android devices with Opera Mobile/Mini. They should report here.\n        if self.detectOperaMobile():\n            return True\n\n        return False", "response": "Return detection of an Android phone."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detectAndroidTablet(self):\n        #First, let's make sure we're on an Android device.\n        if not self.detectAndroid():\n            return False\n\n        #Special check for Android devices with Opera Mobile/Mini. They should NOT report here.\n        if self.detectOperaMobile():\n            return False\n\n        #Otherwise, if it's Android and does NOT have 'mobile' in it, Google says it's a tablet.\n        return UAgentInfo.mobile not in self.__userAgent", "response": "Return detection of an Android tablet."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns detection of Symbian S60 Open Source Browser.", "response": "def detectS60OssBrowser(self):\n        \"\"\"Return detection of Symbian S60 Browser\n\n        Detects if the current browser is the Symbian S60 Open Source Browser.\n        \"\"\"\n        #First, test for WebKit, then make sure it's either Symbian or S60.\n        return self.detectWebkit() \\\n            and (UAgentInfo.deviceSymbian in self.__userAgent\n                or UAgentInfo.deviceS60 in self.__userAgent)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef detectSymbianOS(self):\n        return UAgentInfo.deviceSymbian in self.__userAgent \\\n            or UAgentInfo.deviceS60 in self.__userAgent \\\n            or UAgentInfo.deviceS70 in self.__userAgent \\\n            or UAgentInfo.deviceS80 in self.__userAgent \\\n            or UAgentInfo.deviceS90 in self.__userAgent", "response": "Return detection of SymbianOS"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn detection of Windows Mobile device.", "response": "def detectWindowsMobile(self):\n        \"\"\"Return detection of Windows Mobile\n\n        Detects if the current browser is a Windows Mobile device.\n        Excludes Windows Phone 7 devices.\n        Focuses on Windows Mobile 6.xx and earlier.\n        \"\"\"\n        #Exclude new Windows Phone.\n        if self.detectWindowsPhone():\n            return False\n        #Most devices use 'Windows CE', but some report 'iemobile'\n        #  and some older ones report as 'PIE' for Pocket IE.\n        #  We also look for instances of HTC and Windows for many of their WinMo devices.\n        if UAgentInfo.deviceWinMob in self.__userAgent \\\n           or UAgentInfo.deviceIeMob in self.__userAgent \\\n           or UAgentInfo.enginePie in self.__userAgent:\n            return True\n        # Test for certain Windwos Mobile-based HTC devices.\n        if UAgentInfo.manuHtc in self.__userAgent \\\n           and UAgentInfo.deviceWindows in self.__userAgent:\n            return True\n        if self.detectWapWml() \\\n           and UAgentInfo.deviceWindows in self.__userAgent:\n            return True\n\n        #Test for Windows Mobile PPC but not old Macintosh PowerPC.\n        return UAgentInfo.devicePpc in self.__userAgent \\\n            and UAgentInfo.deviceMacPpc not in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef detectBlackBerry(self):\n        return UAgentInfo.deviceBB in self.__userAgent \\\n            or UAgentInfo.vndRIM in self.__httpAccept", "response": "Return detection of Blackberry"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn detection of a Blackberry 10 OS phone", "response": "def detectBlackBerry10Phone(self):\n        \"\"\"Return detection of a Blackberry 10 OS phone\n\n        Detects if the current browser is a BlackBerry 10 OS phone.\n        Excludes the PlayBook.\n        \"\"\"\n        return UAgentInfo.deviceBB10 in self.__userAgent \\\n            and UAgentInfo.mobile in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn detection of a Blackberry Touchscreen device", "response": "def detectBlackBerryTouch(self):\n        \"\"\"Return detection of a Blackberry touchscreen device\n\n        Detects if the current browser is a BlackBerry Touch\n        device, such as the Storm, Torch, and Bold Touch. Excludes the Playbook.\n        \"\"\"\n        return UAgentInfo.deviceBBStorm in self.__userAgent \\\n                or UAgentInfo.deviceBBTorch in self.__userAgent \\\n                or UAgentInfo.deviceBBBoldTouch in self.__userAgent \\\n                or UAgentInfo.deviceBBCurveTouch in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef detectBlackBerryHigh(self):\n        #Disambiguate for BlackBerry OS 6 or 7 (WebKit) browser\n        if self.detectBlackBerryWebKit():\n            return False\n        if not self.detectBlackBerry():\n            return False\n\n        return self.detectBlackBerryTouch() \\\n            or UAgentInfo.deviceBBBold in self.__userAgent \\\n            or UAgentInfo.deviceBBTour in self.__userAgent \\\n            or UAgentInfo.deviceBBCurve in self.__userAgent", "response": "Return detection of a Blackberry device with a better browser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn detection of a PalmOS device", "response": "def detectPalmOS(self):\n        \"\"\"Return detection of a PalmOS device\n\n        Detects if the current browser is on a PalmOS device.\n        \"\"\"\n        #Most devices nowadays report as 'Palm', but some older ones reported as Blazer or Xiino.\n        if UAgentInfo.devicePalm in self.__userAgent \\\n           or UAgentInfo.engineBlazer in self.__userAgent \\\n           or UAgentInfo.engineXiino in self.__userAgent:\n            # Make sure it's not WebOS\n            return not self.detectPalmWebOS()\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detectWebOSTablet(self):\n        return UAgentInfo.deviceWebOShp in self.__userAgent \\\n            and UAgentInfo.deviceTablet in self.__userAgent", "response": "Return detection of an HP WebOS tablet"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns detection of a WebOS smart TV", "response": "def detectWebOSTV(self):\n        \"\"\"Return detection of a WebOS smart TV\n\n        Detects if the current browser is on a WebOS smart TV.\n        \"\"\"\n        return UAgentInfo.deviceWebOStv in self.__userAgent \\\n            and UAgentInfo.smartTV2 in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn detection of a Tizen device", "response": "def detectTizen(self):\n        \"\"\"Return detection of a Tizen device\n\n        Detects a device running the Tizen smartphone OS.\n        \"\"\"\n        return UAgentInfo.deviceTizen in self.__userAgent \\\n            and UAgentInfo.mobile in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detectTizenTV(self):\n        return UAgentInfo.deviceTizen in self.__userAgent \\\n            and UAgentInfo.smartTV1 in self.__userAgent", "response": "Return detection of a Tizen smart TV"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning detection of a Meego phone", "response": "def detectMeegoPhone(self):\n        \"\"\"Return detection of a Meego phone\n\n        Detects a phone running the Meego OS.\n        \"\"\"\n        return UAgentInfo.deviceMeego in self.__userAgent \\\n            and UAgentInfo.mobi in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns detection of a Firefox OS phone", "response": "def detectFirefoxOSPhone(self):\n        \"\"\"Return detection of a Firefox OS phone\n\n        Detects a phone (probably) running the Firefox OS.\n        \"\"\"\n        if self.detectIos() \\\n            or self.detectAndroid() \\\n            or self.detectSailfish():\n            return False\n\n        if UAgentInfo.engineFirefox in self.__userAgent \\\n           and UAgentInfo.mobile in self.__userAgent:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns detection of a Firefox OS tablet", "response": "def detectFirefoxOSTablet(self):\n        \"\"\"Return detection of a Firefox OS tablet\n\n        Detects a tablet (probably) running the Firefox OS.\n        \"\"\"\n        if self.detectIos() \\\n            or self.detectAndroid() \\\n            or self.detectSailfish():\n            return False\n\n        if UAgentInfo.engineFirefox in self.__userAgent \\\n           and UAgentInfo.deviceTablet in self.__userAgent:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detectSailfishPhone(self):\n        if self.detectSailfish() \\\n           and UAgentInfo.mobile in self.__userAgent:\n            return True\n\n        return False", "response": "Return detection of a Sailfish phone"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detectUbuntuPhone(self):\n        if UAgentInfo.deviceUbuntu in self.__userAgent \\\n           and UAgentInfo.mobile in self.__userAgent:\n            return True\n\n        return False", "response": "Return detection of an Ubuntu Mobile OS phone"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning detection of an Ubuntu Mobile OS tablet", "response": "def detectUbuntuTablet(self):\n        \"\"\"Return detection of an Ubuntu Mobile OS tablet\n\n        Detects a tablet running the Ubuntu Mobile OS.\n        \"\"\"\n        if UAgentInfo.deviceUbuntu in self.__userAgent \\\n           and UAgentInfo.deviceTablet in self.__userAgent:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns detection of a Danger Hiptop device", "response": "def detectDangerHiptop(self):\n        \"\"\"Return detection of a Danger Hiptop\n\n        Detects the Danger Hiptop device.\n        \"\"\"\n        return UAgentInfo.deviceDanger in self.__userAgent \\\n            or UAgentInfo.deviceHiptop in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef detectOperaMobile(self):\n        return UAgentInfo.engineOpera in self.__userAgent \\\n            and (UAgentInfo.mini in self.__userAgent\n                or UAgentInfo.mobi in self.__userAgent)", "response": "Return detection of an Opera mobile device"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning detection of a WAP - or WML - capable device", "response": "def detectWapWml(self):\n        \"\"\"Return detection of a WAP- or WML-capable device\n\n        Detects whether the device supports WAP or WML.\n        \"\"\"\n        return UAgentInfo.vndwap in self.__httpAccept \\\n            or UAgentInfo.wml in self.__httpAccept"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef detectGamingHandheld(self):\n        return UAgentInfo.devicePlaystation in self.__userAgent \\\n            and UAgentInfo.devicePlaystationVita in self.__userAgent", "response": "Return detection of a gaming handheld with a modern iPhone - class browser"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning detection of Nintendo game device.", "response": "def detectNintendo(self):\n        \"\"\"Return detection of Nintendo\n\n        Detects if the current device is a Nintendo game device.\n        \"\"\"\n        return UAgentInfo.deviceNintendo in self.__userAgent \\\n            or UAgentInfo.deviceNintendo in self.__userAgent \\\n            or UAgentInfo.deviceNintendo in self.__userAgent"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detectMidpCapable(self):\n        return UAgentInfo.deviceMidp in self.__userAgent \\\n            or UAgentInfo.deviceMidp in self.__httpAccept", "response": "Return detection of a MIDP mobile Java - capable device"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef detectMaemoTablet(self):\n        if UAgentInfo.maemo in self.__userAgent:\n            return True\n\n        return UAgentInfo.linux in self.__userAgent \\\n            and UAgentInfo.deviceTablet in self.__userAgent \\\n            and not self.detectWebOSTablet() \\\n            and not self.detectAndroid()", "response": "Return detection of a Maemo OS tablet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning detection of a Sony Mylo device", "response": "def detectSonyMylo(self):\n        \"\"\"Return detection of a Sony Mylo device\n\n        Detects if the current browser is a Sony Mylo device.\n        \"\"\"\n        return UAgentInfo.manuSony in self.__userAgent \\\n            and (UAgentInfo.qtembedded in self.__userAgent\n                or UAgentInfo.mylocom2 in self.__userAgent)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef detectSmartphone(self):\n        return self.detectTierIphone() \\\n            or self.detectS60OssBrowser() \\\n            or self.detectSymbianOS() \\\n            or self.detectWindowsMobile() \\\n            or self.detectBlackBerry() \\\n            or self.detectMeegoPhone() \\\n            or self.detectPalmWebOS()", "response": "Return detection of a smartphone device."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn detection of any mobile device using the quicker method.", "response": "def detectMobileQuick(self):\n        \"\"\"Return detection of any mobile device using the quicker method\n\n        Detects if the current device is a mobile device.\n        This method catches most of the popular modern devices.\n        Excludes Apple iPads and other modern tablets.\n        \"\"\"\n        #Let's exclude tablets\n        if self.__isTierTablet:\n            return False\n\n        #Most mobile browsing is done on smartphones\n        if self.detectSmartphone():\n            return True\n\n        #Catch-all for many mobile devices\n        if UAgentInfo.mobile in self.__userAgent:\n            return True\n\n        if self.detectOperaMobile():\n            return True\n\n        #We also look for Kindle devices\n        if self.detectKindle() \\\n            or self.detectAmazonSilk():\n            return True\n\n        if self.detectWapWml() \\\n           or self.detectMidpCapable() \\\n           or self.detectBrewDevice():\n            return True\n\n        if UAgentInfo.engineNetfront in self.__userAgent \\\n           or UAgentInfo.engineUpBrowser in self.__userAgent:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef detectMobileLong(self):\n\n        if self.detectMobileQuick() \\\n           or self.detectGameConsole():\n            return True\n\n        if self.detectDangerHiptop() \\\n           or self.detectMaemoTablet() \\\n           or self.detectSonyMylo() \\\n           or self.detectArchos():\n            return True\n\n        if UAgentInfo.devicePda in self.__userAgent \\\n           and UAgentInfo.disUpdate not in self.__userAgent:\n            return True\n\n        #detect older phones from certain manufacturers and operators.\n        return UAgentInfo.uplink in self.__userAgent \\\n            or UAgentInfo.engineOpenWeb in self.__userAgent \\\n            or UAgentInfo.manuSamsung1 in self.__userAgent \\\n            or UAgentInfo.manuSonyEricsson in self.__userAgent \\\n            or UAgentInfo.manuericsson in self.__userAgent \\\n            or UAgentInfo.svcDocomo in self.__userAgent \\\n            or UAgentInfo.svcKddi in self.__userAgent \\\n            or UAgentInfo.svcVodafone in self.__userAgent", "response": "Return detection of any mobile device using the more thorough way to detect if any device is a long one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning detection of any device in the Tablet Tier", "response": "def detectTierTablet(self):\n        \"\"\"Return detection of any device in the Tablet Tier\n\n        The quick way to detect for a tier of devices.\n        This method detects for the new generation of\n        HTML 5 capable, larger screen tablets.\n        Includes iPad, Android (e.g., Xoom), BB Playbook, WebOS, etc.\n        \"\"\"\n        return self.detectIpad() \\\n            or self.detectAndroidTablet() \\\n            or self.detectBlackBerryTablet() \\\n            or self.detectFirefoxOSTablet() \\\n            or self.detectUbuntuTablet() \\\n            or self.detectWebOSTablet()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detectTierIphone(self):\n        return self.__isIphone \\\n            or self.__isAndroidPhone \\\n            or self.detectWindowsPhone() \\\n            or self.detectBlackBerry10Phone() \\\n            or self.detectPalmWebOS() \\\n            or self.detectBada() \\\n            or self.detectTizen() \\\n            or self.detectFirefoxOSPhone() \\\n            or self.detectSailfishPhone() \\\n            or self.detectUbuntuPhone() \\\n            or self.detectGamingHandheld()", "response": "Return detection of any device in the iPhone AndroidWP7 WebOS Tier\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detectTierRichCss(self):\n        #The following devices are explicitly ok.\n        #Note: 'High' BlackBerry devices ONLY\n        if not self.detectMobileQuick():\n            return False\n        #Exclude iPhone Tier and e-Ink Kindle devices\n        if self.detectTierIphone() \\\n            or self.detectKindle():\n            return False\n        #The following devices are explicitly ok.\n        #Note: 'High' BlackBerry devices ONLY\n        #Older Windows 'Mobile' isn't good enough for iPhone Tier.\n        return self.detectWebkit() \\\n            or self.detectS60OssBrowser() \\\n            or self.detectBlackBerryHigh() \\\n            or self.detectWindowsMobile() \\\n            or UAgentInfo.engineTelecaQ in self.__userAgent", "response": "Return detection of any device in the Rich CSS Tier\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the date attribute as a date object.", "response": "def str_to_date(self):\n        \"\"\"\n        Returns the date attribute as a date object.\n\n        :returns: Date of the status if it exists.\n        :rtype: date or NoneType\n        \"\"\"\n\n        if hasattr(self, 'date'):\n            return date(*list(map(int, self.date.split('-'))))\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_xml_element(self):\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        if hasattr(self, 'date'):\n            self.xml_element.set('date', self.date)\n        self.xml_element.text = self.text\n\n        return self.xml_element", "response": "Updates the xml element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwait for some task to complete but aborts as soon asthe instance is being closed.", "response": "async def await_until_closing(self, coro):\n        \"\"\"\n        Wait for some task to complete but aborts as soon asthe instance is\n        being closed.\n\n        :param coro: The coroutine or future-like object to wait for.\n        \"\"\"\n        wait_task = asyncio.ensure_future(self.wait_closing(), loop=self.loop)\n        coro_task = asyncio.ensure_future(coro, loop=self.loop)\n\n        try:\n            done, pending = await asyncio.wait(\n                [wait_task, coro_task],\n                return_when=asyncio.FIRST_COMPLETED,\n                loop=self.loop,\n            )\n\n        finally:\n            wait_task.cancel()\n            coro_task.cancel()\n\n        # It could be that the previous instructions cancelled coro_task if it\n        # wasn't done yet.\n        return await coro_task"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_closed(self, future):\n        logger.debug(\"%s[%s] closed.\", self.__class__.__name__, id(self))\n        self.on_closed.emit(self)\n        self._closed_future.set_result(future.result())", "response": "Indicate that the instance is effectively closed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a new child that will be closed whenever the current instance closes.", "response": "def register_child(self, child):\n        \"\"\"\n        Register a new child that will be closed whenever the current instance\n        closes.\n\n        :param child: The child instance.\n        \"\"\"\n        if self.closing:\n            child.close()\n        else:\n            self._children.add(child)\n            child.on_closed.connect(self.unregister_child)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unregister_child(self, child):\n        self._children.remove(child)\n        child.on_closed.disconnect(self.unregister_child)", "response": "Unregister an existing child that is no longer owned by the\n        current instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_open(self, callback, timeout):\n        super().on_open()\n        self.callback = callback\n        self.timeout = timeout\n        self.revive_event = asyncio.Event(loop=self.loop)", "response": "Initialize a new timeout."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreviving the timeout. :param timeout: If not `None`, specifies a new timeout value to use.", "response": "def revive(self, timeout=None):\n        \"\"\"\n        Revive the timeout.\n\n        :param timeout: If not `None`, specifies a new timeout value to use.\n        \"\"\"\n        if timeout is not None:\n            self.timeout = timeout\n\n        self.revive_event.set()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_open(self, callback, period):\n        super().on_open()\n        self.callback = callback\n        self.period = period\n        self.reset_event = asyncio.Event(loop=self.loop)", "response": "Initialize a new timer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset(self, period=None):\n        if period is not None:\n            self.period = period\n\n        self.reset_event.set()", "response": "Reset the internal timer to the specified period."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def read(self):\n        result = await self._queue.get()\n\n        self._can_write.set()\n\n        if self._queue.empty():\n            self._can_read.clear()\n\n        return result", "response": "Read an item from the box in a blocking manner."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_nowait(self):\n        result = self._queue.get_nowait()\n\n        self._can_write.set()\n\n        if self._queue.empty():\n            self._can_read.clear()\n\n        return result", "response": "Reads a set of items from the box in a non - blocking manner."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites an item in the queue.", "response": "async def write(self, item):\n        \"\"\"\n        Write an item in the queue.\n\n        :param item: The item.\n        \"\"\"\n        await self._queue.put(item)\n        self._can_read.set()\n\n        if self._queue.full():\n            self._can_write.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites in the box in a non - blocking manner.", "response": "def write_nowait(self, item):\n        \"\"\"\n        Write in the box in a non-blocking manner.\n\n        If the box is full, an exception is thrown. You should always check\n        for fullness with `full` or `wait_not_full` before calling this method.\n\n        :param item: An item.\n        \"\"\"\n        self._queue.put_nowait(item)\n        self._can_read.set()\n\n        if self._queue.full():\n            self._can_write.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclones the box. :returns: A new box with the same item queue. The cloned box is not closed, no matter the initial state of the original instance.", "response": "def clone(self):\n        \"\"\"\n        Clone the box.\n\n        :returns: A new box with the same item queue.\n\n        The cloned box is not closed, no matter the initial state of the\n        original instance.\n        \"\"\"\n        result = AsyncBox(maxsize=self._maxsize, loop=self.loop)\n        result._queue = self._queue\n        result._can_read = self._can_read\n        result._can_write = self._can_write\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_expr(self, ctx):\n        varname = ctx.lookup_variable(self.varname)\n        if varname is None:\n            val = ctx.lookup_constant(self.varname)\n            if val:\n                try:\n                    return val.generate_code(ctx)\n                except AttributeError:\n                    return val\n            raise MuvError(\n                \"Undeclared identifier '%s'.\" % self.varname,\n                position=self.position\n            )\n        if len(self.indexing) == 0:\n            return \"{var} @\".format(\n                var=varname,\n            )\n        if len(self.indexing) == 1:\n            return \"{var} @ {idx} []\".format(\n                var=varname,\n                idx=self.indexing[0],\n            )\n        return (\n            \"{var} @ {{ {idx} }}list array_nested_get\".format(\n                var=varname,\n                idx=\" \".join(str(x) for x in self.indexing),\n            )\n        )", "response": "Returns the MUF needed to get the contents of the lvalue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the expression for assigning this variable to the current value.", "response": "def set_expr(self, ctx):\n        \"\"\"\n        Returns the MUF needed to do an assign on the lvalue. (=)\n        Returned MUF expects a value to be on the stack.\n        \"\"\"\n        if self.readonly:\n            raise MuvError(\n                \"Cannot assign value to constant '%s'.\" % self.varname,\n                position=self.position\n            )\n        if self.declare:\n            varname = ctx.declare_variable(self.varname)\n            if len(self.indexing) == 0:\n                return \"var! {var}\".format(var=varname)\n        else:\n            varname = ctx.lookup_variable(self.varname)\n            if varname is None:\n                raise MuvError(\n                    \"Undeclared identifier '%s'.\" % self.varname,\n                    position=self.position\n                )\n        if len(self.indexing) == 0:\n            if ctx.assign_level > 1:\n                return \"dup {var} !\".format(var=varname)\n            else:\n                return \"{var} !\".format(var=varname)\n        if len(self.indexing) == 1:\n            if ctx.target in ['fb7']:\n                if ctx.assign_level > 1:\n                    fmt = \"dup {var} @ {idx} ->[] pop\"\n                else:\n                    fmt = \"{var} @ {idx} ->[] pop\"\n            else:\n                if ctx.assign_level > 1:\n                    fmt = \"dup {var} @ {idx} ->[] {var} !\"\n                else:\n                    fmt = \"{var} @ {idx} ->[] {var} !\"\n            return fmt.format(\n                var=varname,\n                idx=self.indexing[0].generate_code(ctx),\n            )\n        if ctx.target in ['fb7']:\n            if ctx.assign_level > 1:\n                fmt = \"dup {var} @ {{ {idx} }}list array_nested_set pop\"\n            else:\n                fmt = \"{var} @ {{ {idx} }}list array_nested_set pop\"\n        else:\n            if ctx.assign_level > 1:\n                fmt = \"dup {var} @ {{ {idx} }}list array_nested_set {var} !\"\n            else:\n                fmt = \"{var} @ {{ {idx} }}list array_nested_set {var} !\"\n        return fmt.format(\n            var=varname,\n            idx=\" \".join(x.generate_code(ctx) for x in self.indexing)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef oper_set_expr(self, ctx, oper, val):\n        if self.readonly:\n            raise MuvError(\n                \"Cannot assign value to constant '%s'.\" % self.varname,\n                position=self.position\n            )\n        varname = ctx.lookup_variable(self.varname)\n        if varname is None:\n            raise MuvError(\n                \"Undeclared identifier '%s'.\" % self.varname,\n                position=self.position\n            )\n        if len(self.indexing) == 0:\n            if ctx.assign_level > 1:\n                fmt = \"{var} @ {val} {oper} dup {var} !\"\n            else:\n                fmt = \"{var} @ {val} {oper} {var} !\"\n            return fmt.format(\n                var=varname,\n                oper=oper,\n                val=val.generate_code(ctx),\n            )\n        if len(self.indexing) == 1:\n            if ctx.target in ['fb7']:\n                if ctx.assign_level > 1:\n                    fmt = (\n                        \"{var} @ {idx} \"\n                        \"over over [] {val} {oper} \"\n                        \"dup -4 rotate \"\n                        \"-rot ->[] pop\"\n                    )\n                else:\n                    fmt = (\n                        \"{var} @ {idx} \"\n                        \"over over [] {val} {oper} \"\n                        \"-rot ->[] pop\"\n                    )\n            else:\n                if ctx.assign_level > 1:\n                    fmt = (\n                        \"{var} @ {idx} \"\n                        \"over over [] {val} {oper} \"\n                        \"dup -4 rotate \"\n                        \"rot rot ->[] {var} !\"\n                    )\n                else:\n                    fmt = (\n                        \"{var} @ {idx} \"\n                        \"over over [] {val} {oper} \"\n                        \"rot rot ->[] {var} !\"\n                    )\n            return fmt.format(\n                var=varname,\n                oper=oper,\n                val=val.generate_code(ctx),\n                idx=self.indexing[0].generate_code(ctx),\n            )\n        if ctx.target in ['fb7']:\n            if ctx.assign_level > 1:\n                fmt = (\n                    \"{var} @ {{ {sidx} }}list array_nested_get \"\n                    \"{lidx} over over [] {val} {oper} \"\n                    \"dup -4 rotate \"\n                    \"-rot ->[] pop\"\n                )\n            else:\n                fmt = (\n                    \"{var} @ {{ {sidx} }}list array_nested_get \"\n                    \"{lidx} over over [] {val} {oper} \"\n                    \"-rot ->[] pop\"\n                )\n        else:\n            if ctx.assign_level > 1:\n                fmt = (\n                    \"{var} @ {{ {idx} }}list \"\n                    \"over over array_nested_get {val} {oper} \"\n                    \"dup -4 rotate \"\n                    \"rot rot array_nested_set {var} !\"\n                )\n            else:\n                fmt = (\n                    \"{var} @ {{ {idx} }}list \"\n                    \"over over array_nested_get {val} {oper} \"\n                    \"rot rot array_nested_set {var} !\"\n                )\n        return fmt.format(\n            var=varname,\n            oper=oper,\n            val=val.generate_code(ctx),\n            idx=\" \".join(\n                x.generate_code(ctx)\n                for x in self.indexing\n            ),\n            sidx=\" \".join(\n                x.generate_code(ctx)\n                for x in self.indexing[:-1]\n            ),\n            lidx=self.indexing[-1].generate_code(ctx)\n        )", "response": "Returns the expression that can be used to set the value of a variable in a MUF."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unary_set_expr(self, ctx, oper, postoper=False):\n        if self.readonly:\n            raise MuvError(\n                \"Cannot increment or decrement constant '%s'.\" % self.varname,\n                position=self.position\n            )\n        varname = ctx.lookup_variable(self.varname)\n        if varname is None:\n            raise MuvError(\n                \"Undeclared identifier '%s'.\" % self.varname,\n                position=self.position\n            )\n        if len(self.indexing) == 0:\n            if postoper:\n                fmt = \"{var} @ {var} {oper}\"\n            else:\n                fmt = \"{var} dup {oper} @\"\n            return fmt.format(var=varname, oper=oper)\n        if len(self.indexing) == 1:\n            if ctx.target in ['fb7']:\n                if postoper:\n                    fmt = (\n                        \"{idx} {var} @ \"\n                        \"dup 3 pick [] \"\n                        \"dup -4 rotate {oper} \"\n                        \"swap rot ->[] pop\"\n                    )\n                else:\n                    fmt = (\n                        \"{idx} {var} @ \"\n                        \"dup 3 pick [] {oper} \"\n                        \"dup -4 rotate \"\n                        \"swap rot ->[] pop\"\n                    )\n            else:\n                if postoper:\n                    fmt = (\n                        \"{idx} {var} @ \"\n                        \"dup 3 pick [] \"\n                        \"dup -4 rotate {oper} \"\n                        \"swap rot ->[] {var} !\"\n                    )\n                else:\n                    fmt = (\n                        \"{idx} {var} @ \"\n                        \"dup 3 pick [] {oper} \"\n                        \"dup -4 rotate \"\n                        \"swap rot ->[] {var} !\"\n                    )\n            return fmt.format(\n                var=varname,\n                oper=oper,\n                idx=self.indexing[0].generate_code(ctx),\n            )\n        if ctx.target in ['fb7']:\n            if postoper:\n                fmt = (\n                    \"{{ {idx} }}list {var} @ \"\n                    \"dup 3 pick array_nested_get \"\n                    \"dup -4 rotate {oper} \"\n                    \"swap rot array_nested_set pop\"\n                )\n            else:\n                fmt = (\n                    \"{{ {idx} }}list {var} @ \"\n                    \"dup 3 pick array_nested_get {oper} \"\n                    \"dup -4 rotate \"\n                    \"swap rot array_nested_set pop\"\n                )\n        else:\n            if postoper:\n                fmt = (\n                    \"{{ {idx} }}list {var} @ \"\n                    \"dup 3 pick array_nested_get \"\n                    \"dup -4 rotate {oper} \"\n                    \"swap rot array_nested_set {var} !\"\n                )\n            else:\n                fmt = (\n                    \"{{ {idx} }}list {var} @ \"\n                    \"dup 3 pick array_nested_get {oper} \"\n                    \"dup -4 rotate \"\n                    \"swap rot array_nested_set {var} !\"\n                )\n        return fmt.format(\n            var=varname,\n            oper=oper,\n            idx=\" \".join(\n                x.generate_code(ctx)\n                for x in self.indexing\n            )\n        )", "response": "Returns the expression that can be used to set the value of a variable in a MUF."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef del_expr(self, ctx):\n        if self.readonly:\n            raise MuvError(\n                \"Cannot assign value to constant '%s'.\" % self.varname,\n                position=self.position\n            )\n        varname = ctx.lookup_variable(self.varname)\n        if varname is None:\n            raise MuvError(\n                \"Undeclared identifier '%s'.\" % self.varname,\n                position=self.position\n            )\n        if len(self.indexing) == 0:\n            return \"0 {var} !\".format(var=varname)\n        if len(self.indexing) == 1:\n            if ctx.target in ['fb7']:\n                return \"{var} @ {idx} array_delitem\".format(\n                    var=varname,\n                    idx=self.indexing[0].generate_code(ctx),\n                )\n            else:\n                return \"{var} @ {idx} array_delitem dup {var} !\".format(\n                    var=varname,\n                    idx=self.indexing[0].generate_code(ctx),\n                )\n        if ctx.target in ['fb7']:\n            return \"{var} @ {{ {idx} }}list array_nested_del\".format(\n                var=varname,\n                idx=\" \".join(x.generate_code(ctx) for x in self.indexing),\n            )\n        else:\n            return \"{var} @ {{ {idx} }}list array_nested_del dup {var} !\".format(\n                var=varname,\n                idx=\" \".join(x.generate_code(ctx) for x in self.indexing),\n            )", "response": "Returns the expression that can be used to delete a given lvalue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_list(cls, values, settings):\n        logger.debug('Creating Cluster from list')\n        self = cls()\n        self.settings = settings\n        self.instances = []\n\n        for instance in values:\n            uid, ip, port = instance['uid'], instance['ip'], instance['port']\n            new_instance = Instance.new(settings=settings, cluster=self, uid=uid, ip=ip, port=port)\n            self.instances.append(new_instance)\n        return self", "response": "Create a Cluster object from a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert the object to a list of dicts", "response": "def to_list(self):\n        \"\"\"\n        To a list of dicts (each dict is an instances)\n        \"\"\"\n        ret = []\n        for instance in self.instances:\n            ret.append(instance.to_dict())\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating instances for the Bare provider.", "response": "def create_bare(self):\n        \"\"\"\n        Create instances for the Bare provider\n        \"\"\"\n        self.instances = []\n        for ip in self.settings['NODES']:\n            new_instance = Instance.new(settings=self.settings, cluster=self)\n            new_instance.ip = ip\n            self.instances.append(new_instance)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate instances for the cloud providers", "response": "def create_cloud(self):\n        \"\"\"\n        Create instances for the cloud providers\n        \"\"\"\n        instances = []\n        for i in range(self.settings['NUMBER_NODES']):\n            new_instance = Instance.new(settings=self.settings, cluster=self)\n            instances.append(new_instance)\n\n        create_nodes = [instance.create(suffix=i) for i, instance in enumerate(instances)]\n        fetch_nodes = [instance.node for instance in instances]\n        self.driver.wait_until_running(fetch_nodes)\n\n        node_ids = [node.id for node in fetch_nodes]\n        all_nodes = self.driver.list_nodes()\n        new_nodes = [node for node in all_nodes if node.id in node_ids]\n        for instance, node in zip(instances, new_nodes):\n            instance.node = node\n\n        self.instances = instances"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize_uri(value):\n    if isinstance(value, BNode):\n        return value.n3()\n    if isinstance(value, URIRef):\n        return unicode(value)\n    raise ValueError(\"Cannot get prepvalue for {0} of type {1}\".format(value, value.__class__))", "response": "Serialize a BNode or URIRef."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_lazy_load_wegobject(f):\n    '''\n    Decorator function to lazy load a :class:`Wegobject`.\n    '''\n    def wrapper(*args):\n        wegobject = args[0]\n        if (\n            wegobject._centroid is None or\n            wegobject._bounding_box is None or\n            wegobject._metadata is None\n        ):\n            log.debug('Lazy loading Wegobject %d', wegobject.id)\n            wegobject.check_gateway()\n            w = wegobject.gateway.get_wegobject_by_id(wegobject.id)\n            wegobject._centroid = w._centroid\n            wegobject._bounding_box = w._bounding_box\n            wegobject._metadata = w._metadata\n        return f(*args)\n    return wrapper", "response": "Decorator to lazy load a Wegobject."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_lazy_load_terreinobject(f):\n    '''\n    Decorator function to lazy load a :class:`Terreinobject`.\n    '''\n    def wrapper(*args):\n        terreinobject = args[0]\n        if (\n            terreinobject._centroid is None or\n            terreinobject._bounding_box is None or\n            terreinobject._metadata is None\n        ):\n            log.debug('Lazy loading Terreinobject %s', terreinobject.id)\n            terreinobject.check_gateway()\n            t = terreinobject.gateway.get_terreinobject_by_id(terreinobject.id)\n            terreinobject._centroid = t._centroid\n            terreinobject._bounding_box = t._bounding_box\n            terreinobject._metadata = t._metadata\n        return f(*args)\n    return wrapper", "response": "Decorator to lazy load a Terreinobject."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_lazy_load_gebouw(f):\n    '''\n    Decorator function to lazy load a :class:`Gebouw`.\n    '''\n    def wrapper(*args):\n        gebouw = args[0]\n        if (\n            gebouw._methode_id is None or gebouw._geometrie is None or\n            gebouw._metadata is None\n        ):\n            log.debug('Lazy loading Gebouw %d', gebouw.id)\n            gebouw.check_gateway()\n            g = gebouw.gateway.get_gebouw_by_id(gebouw.id)\n            gebouw._methode_id = g._methode_id\n            gebouw._geometrie = g._geometrie\n            gebouw._metadata = g._metadata\n        return f(*args)\n    return wrapper", "response": "Decorator to lazy load a Gebouw."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_lazy_load_subadres(f):\n    '''\n    Decorator function to lazy load a :class:`Subadres`.\n    '''\n    def wrapper(*args):\n        subadres = args[0]\n        if (\n            subadres._metadata is None or\n            subadres.aard_id is None or\n            subadres.huisnummer_id is None\n        ):\n            log.debug('Lazy loading Subadres %d', subadres.id)\n            subadres.check_gateway()\n            s = subadres.gateway.get_subadres_by_id(subadres.id)\n            subadres._metadata = s._metadata\n            subadres.aard_id = s.aard_id\n            subadres.huisnummer_id = s.huisnummer_id\n        return f(*args)\n    return wrapper", "response": "Decorator to lazy load a : class : Subadres."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_lazy_load_adrespositie(f):\n    '''\n    Decorator function to lazy load a :class:`Adrespositie`.\n    '''\n    def wrapper(*args):\n        adrespositie = args[0]\n        if (\n            adrespositie._geometrie is None or\n            adrespositie._aard is None or\n            adrespositie._metadata is None\n        ):\n            log.debug('Lazy loading Adrespositie %d', adrespositie.id)\n            adrespositie.check_gateway()\n            a = adrespositie.gateway.get_adrespositie_by_id(adrespositie.id)\n            adrespositie._geometrie = a._geometrie\n            adrespositie.aard_id = a.aard_id\n            adrespositie._metadata = a._metadata\n        return f(*args)\n    return wrapper", "response": "Decorator to lazy load a : class : Adrespositie."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist all gewesten in Belgium.", "response": "def list_gewesten(self, sort=1):\n        '''\n        List all `gewesten` in Belgium.\n\n        :param integer sort: What field to sort on.\n        :rtype: A :class`list` of class: `Gewest`.\n        '''\n        def creator():\n            res = crab_gateway_request(self.client, 'ListGewesten', sort)\n            tmp = {}\n            for r in res.GewestItem:\n                if r.GewestId not in tmp:\n                    tmp[r.GewestId] = {}\n                tmp[r.GewestId][r.TaalCodeGewestNaam] = r.GewestNaam\n            return[\n                Gewest(\n                    k,\n                    v\n                )for k, v in tmp.items()\n            ]\n        if self.caches['permanent'].is_configured:\n            key = 'ListGewesten#%s' % sort\n            gewesten = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            gewesten = creator()\n        for g in gewesten:\n            g.set_gateway(self)\n        return gewesten"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a gewest by id.", "response": "def get_gewest_by_id(self, id):\n        '''\n        Get a `gewest` by id.\n\n        :param integer id: The id of a `gewest`.\n        :rtype: A :class:`Gewest`.\n        '''\n        def creator():\n            nl = crab_gateway_request(\n                self.client, 'GetGewestByGewestIdAndTaalCode', id, 'nl'\n            )\n            fr = crab_gateway_request(\n                self.client, 'GetGewestByGewestIdAndTaalCode', id, 'fr'\n            )\n            de = crab_gateway_request(\n                self.client, 'GetGewestByGewestIdAndTaalCode', id, 'de'\n            )\n            if nl == None:\n                raise GatewayResourceNotFoundException()\n            return Gewest(\n                nl.GewestId,\n                {\n                    'nl': nl.GewestNaam,\n                    'fr': fr.GewestNaam,\n                    'de': de.GewestNaam\n                },\n                (nl.CenterX, nl.CenterY),\n                (nl.MinimumX, nl.MinimumY, nl.MaximumX, nl.MaximumY),\n            )\n        if self.caches['permanent'].is_configured:\n            key = 'GetGewestByGewestId#%s' % id\n            gewest = self.caches['long'].get_or_create(key, creator)\n        else:\n            gewest = creator()\n        gewest.set_gateway(self)\n        return gewest"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_provincies(self, gewest=2):\n        '''\n        List all `provincies` in a `gewest`.\n\n        :param gewest: The :class:`Gewest` for which the \\\n            `provincies` are wanted.\n        :param integer sort: What field to sort on.\n        :rtype: A :class:`list` of :class:`Provincie`.\n        '''\n        try:\n            gewest_id = gewest.id\n        except AttributeError:\n            gewest_id = gewest\n\n        def creator():\n            return [Provincie(p[0], p[1], Gewest(p[2])) for p in self.provincies if p[2] == gewest_id]\n\n        if self.caches['permanent'].is_configured:\n            key = 'ListProvinciesByGewestId#%s' % gewest_id\n            provincies = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            provincies = creator()\n        for p in provincies:\n            p.set_gateway(self)\n        return provincies", "response": "List all provincies in a gewest."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves a provincie by the niscode.", "response": "def get_provincie_by_id(self, niscode):\n        '''\n        Retrieve a `provincie` by the niscode.\n\n        :param integer niscode: The niscode of the provincie.\n        :rtype: :class:`Provincie`\n        '''\n        def creator():\n            for p in self.provincies:\n                if p[0] == niscode:\n                    return Provincie(p[0], p[1], Gewest(p[2]))\n\n        if self.caches['permanent'].is_configured:\n            key = 'GetProvincieByProvincieNiscode#%s' % niscode\n            provincie = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            provincie = creator()\n        if provincie == None:\n            raise GatewayResourceNotFoundException()\n        provincie.set_gateway(self)\n        return provincie"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_gemeenten_by_provincie(self, provincie):\n        '''\n        List all `gemeenten` in a `provincie`.\n\n        :param provincie: The :class:`Provincie` for which the \\\n            `gemeenten` are wanted.\n        :rtype: A :class:`list` of :class:`Gemeente`.\n        '''\n        try:\n            gewest = provincie.gewest\n            prov = provincie\n        except AttributeError:\n            prov = self.get_provincie_by_id(provincie)\n            gewest = prov.gewest\n        gewest.clear_gateway()\n\n        def creator():\n            gewest_gemeenten = self.list_gemeenten(gewest.id)\n            return[\n                Gemeente(\n                    r.id,\n                    r.naam,\n                    r.niscode,\n                    gewest\n                )for r in gewest_gemeenten if str(r.niscode)[0] == str(prov.niscode)[0]\n            ]\n\n        if self.caches['permanent'].is_configured:\n            key = 'ListGemeentenByProvincieId#%s' % prov.id\n            gemeente = self.caches['long'].get_or_create(key, creator)\n        else:\n            gemeente = creator()\n        for g in gemeente:\n            g.set_gateway(self)\n        return gemeente", "response": "List all gemeenten in a given provincie."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all gemeenten in a gewest.", "response": "def list_gemeenten(self, gewest=2, sort=1):\n        '''\n        List all `gemeenten` in a `gewest`.\n\n        :param gewest: The :class:`Gewest` for which the \\\n            `gemeenten` are wanted.\n        :param integer sort: What field to sort on.\n        :rtype: A :class:`list` of :class:`Gemeente`.\n        '''\n        try:\n            gewest_id = gewest.id\n        except AttributeError:\n            gewest_id = gewest\n            gewest = self.get_gewest_by_id(gewest_id)\n        gewest.clear_gateway()\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListGemeentenByGewestId', gewest_id, sort\n            )\n            return[\n                Gemeente(\n                    r.GemeenteId,\n                    r.GemeenteNaam,\n                    r.NISGemeenteCode,\n                    gewest\n                )for r in res.GemeenteItem if r.TaalCode == r.TaalCodeGemeenteNaam\n            ]\n        if self.caches['permanent'].is_configured:\n            key = 'ListGemeentenByGewestId#%s#%s' % (gewest_id, sort)\n            gemeenten = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            gemeenten = creator()\n        for g in gemeenten:\n            g.set_gateway(self)\n        return gemeenten"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_gemeente_by_id(self, id):\n        '''\n        Retrieve a `gemeente` by the crab id.\n\n        :param integer id: The CRAB id of the gemeente.\n        :rtype: :class:`Gemeente`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetGemeenteByGemeenteId', id\n            )\n            if res == None:\n                 raise GatewayResourceNotFoundException()\n            return Gemeente(\n                res.GemeenteId,\n                res.GemeenteNaam,\n                res.NisGemeenteCode,\n                Gewest(res.GewestId),\n                res.TaalCode,\n                (res.CenterX, res.CenterY),\n                (res.MinimumX, res.MinimumY, res.MaximumX, res.MaximumY),\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['long'].is_configured:\n            key = 'GetGemeenteByGemeenteId#%s' % id\n            gemeente = self.caches['long'].get_or_create(key, creator)\n        else:\n            gemeente = creator()\n        gemeente.set_gateway(self)\n        return gemeente", "response": "Retrieve a gemeente by the CRAB id."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist all deelgemeenten in a gewest.", "response": "def list_deelgemeenten(self, gewest=2):\n        '''\n        List all `deelgemeenten` in a `gewest`.\n\n        :param gewest: The :class:`Gewest` for which the \\\n            `deelgemeenten` are wanted. Currently only Flanders is supported.\n        :rtype: A :class:`list` of :class:`Deelgemeente`.\n        '''\n        try:\n            gewest_id = gewest.id\n        except AttributeError:\n            gewest_id = gewest\n\n        if gewest_id != 2:\n            raise ValueError('Currently only deelgemeenten in Flanders are known.')\n\n        def creator():\n            return [Deelgemeente(dg['id'], dg['naam'], dg['gemeente_niscode']) for dg in self.deelgemeenten.values()]\n\n        if self.caches['permanent'].is_configured:\n            key = 'ListDeelgemeentenByGewestId#%s' % gewest_id\n            deelgemeenten = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            deelgemeenten = creator()\n        for dg in deelgemeenten:\n            dg.set_gateway(self)\n        return deelgemeenten"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_deelgemeenten_by_gemeente(self, gemeente):\n        '''\n        List all `deelgemeenten` in a `gemeente`.\n\n        :param gemeente: The :class:`Gemeente` for which the \\\n            `deelgemeenten` are wanted. Currently only Flanders is supported.\n        :rtype: A :class:`list` of :class:`Deelgemeente`.\n        '''\n        try:\n            niscode = gemeente.niscode\n        except AttributeError:\n            niscode = gemeente\n\n        def creator():\n            return [\n                Deelgemeente(dg['id'], dg['naam'], dg['gemeente_niscode'])\n                for dg in self.deelgemeenten.values() if dg['gemeente_niscode'] == niscode\n            ]\n\n        if self.caches['permanent'].is_configured:\n            key = 'ListDeelgemeentenByGemeenteId#%s' % niscode\n            deelgemeenten = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            deelgemeenten = creator()\n        for dg in deelgemeenten:\n            dg.set_gateway(self)\n        return deelgemeenten", "response": "List all deelgemeenten in a gemeente."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_deelgemeente_by_id(self, id):\n        '''\n        Retrieve a `deelgemeente` by the id.\n\n        :param string id: The id of the deelgemeente.\n        :rtype: :class:`Deelgemeente`\n        '''\n        def creator():\n            if id in self.deelgemeenten:\n                dg = self.deelgemeenten[id]\n                return Deelgemeente(dg['id'], dg['naam'], dg['gemeente_niscode'])\n            else:\n                return None\n\n        if self.caches['permanent'].is_configured:\n            key = 'GetDeelgemeenteByDeelgemeenteId#%s' % id\n            deelgemeente = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            deelgemeente = creator()\n        if deelgemeente == None:\n            raise GatewayResourceNotFoundException()\n        deelgemeente.set_gateway(self)\n        return deelgemeente", "response": "Retrieve a deelgemeente by the id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting all straten in a Gemeente.", "response": "def list_straten(self, gemeente, sort=1):\n        '''\n        List all `straten` in a `Gemeente`.\n\n        :param gemeente: The :class:`Gemeente` for which the \\\n            `straten` are wanted.\n        :rtype: A :class:`list` of :class:`Straat`\n        '''\n        try:\n            id = gemeente.id\n        except AttributeError:\n            id = gemeente\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListStraatnamenWithStatusByGemeenteId',\n                id, sort\n            )\n            try:\n                return[\n                    Straat(\n                        r.StraatnaamId,\n                        r.StraatnaamLabel,\n                        id,\n                        r.StatusStraatnaam\n                    )for r in res.StraatnaamWithStatusItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['long'].is_configured:\n            key = 'ListStraatnamenWithStatusByGemeenteId#%s%s' % (id, sort)\n            straten = self.caches['long'].get_or_create(key, creator)\n        else:\n            straten = creator()\n        for s in straten:\n            s.set_gateway(self)\n        return straten"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_straat_by_id(self, id):\n        '''\n        Retrieve a `straat` by the Id.\n\n        :param integer id: The id of the `straat`.\n        :rtype: :class:`Straat`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetStraatnaamWithStatusByStraatnaamId', id\n            )\n            if res == None:\n                 raise GatewayResourceNotFoundException()\n            return Straat(\n                res.StraatnaamId,\n                res.StraatnaamLabel,\n                res.GemeenteId,\n                res.StatusStraatnaam,\n                res.Straatnaam,\n                res.TaalCode,\n                res.StraatnaamTweedeTaal,\n                res.TaalCodeTweedeTaal,\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n\n        if self.caches['long'].is_configured:\n            key = 'GetStraatnaamWithStatusByStraatnaamId#%s' % (id)\n            straat = self.caches['long'].get_or_create(key, creator)\n        else:\n            straat = creator()\n        straat.set_gateway(self)\n        return straat", "response": "Retrieve a straat by the Id."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists all huisnummers in a Straat.", "response": "def list_huisnummers_by_straat(self, straat, sort=1):\n        '''\n        List all `huisnummers` in a `Straat`.\n\n        :param straat: The :class:`Straat` for which the \\\n            `huisnummers` are wanted.\n        :rtype: A :class: `list` of :class:`Huisnummer`\n        '''\n        try:\n            id = straat.id\n        except AttributeError:\n            id = straat\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListHuisnummersWithStatusByStraatnaamId',\n                id, sort\n            )\n            try:\n                return[\n                    Huisnummer(\n                        r.HuisnummerId,\n                        r.StatusHuisnummer,\n                        r.Huisnummer,\n                        id\n                    ) for r in res.HuisnummerWithStatusItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListHuisnummersWithStatusByStraatnaamId#%s%s' % (id, sort)\n            huisnummers = self.caches['short'].get_or_create(key, creator)\n        else:\n            huisnummers = creator()\n        for h in huisnummers:\n            h.set_gateway(self)\n        return huisnummers"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist all huisnummers on a Pereel.", "response": "def list_huisnummers_by_perceel(self, perceel, sort=1):\n        '''\n        List all `huisnummers` on a `Pereel`.\n\n        Generally there will only be one, but multiples are possible.\n\n        :param perceel: The :class:`Perceel` for which the \\\n            `huisnummers` are wanted.\n        :rtype: A :class: `list` of :class:`Huisnummer`\n        '''\n        try:\n            id = perceel.id\n        except AttributeError:\n            id = perceel\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListHuisnummersWithStatusByIdentificatorPerceel',\n                id, sort\n            )\n            try:\n                huisnummers= []\n                for r in res.HuisnummerWithStatusItem:\n                    h = self.get_huisnummer_by_id(r.HuisnummerId)\n                    h.clear_gateway()\n                    huisnummers.append(h)\n                return huisnummers\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListHuisnummersWithStatusByIdentificatorPerceel#%s%s' % (id, sort)\n            huisnummers = self.caches['short'].get_or_create(key, creator)\n        else:\n            huisnummers = creator()\n        for h in huisnummers:\n            h.set_gateway(self)\n        return huisnummers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_huisnummer_by_id(self, id):\n        '''\n        Retrieve a `huisnummer` by the Id.\n\n        :param integer id: the Id of the `huisnummer`\n        :rtype: :class:`Huisnummer`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetHuisnummerWithStatusByHuisnummerId', id\n            )\n            if res == None:\n                 raise GatewayResourceNotFoundException()\n            return Huisnummer(\n                res.HuisnummerId,\n                res.StatusHuisnummer,\n                res.Huisnummer,\n                res.StraatnaamId,\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetHuisnummerWithStatusByHuisnummerId#%s' % (id)\n            huisnummer = self.caches['short'].get_or_create(key, creator)\n        else:\n            huisnummer = creator()\n        huisnummer.set_gateway(self)\n        return huisnummer", "response": "Retrieve a Huisnummer by the Id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_postkantons_by_gemeente(self, gemeente):\n        '''\n        List all `postkantons` in a :class:`Gemeente`\n\n        :param gemeente: The :class:`Gemeente` for which the \\\n            `potkantons` are wanted.\n        :rtype: A :class:`list` of :class:`Postkanton`\n        '''\n        try:\n            id = gemeente.id\n        except AttributeError:\n            id = gemeente\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListPostkantonsByGemeenteId', id\n            )\n            try:\n                return[\n                    Postkanton(\n                        r.PostkantonCode\n                    )for r in res.PostkantonItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['long'].is_configured:\n            key = 'ListPostkantonsByGemeenteId#%s' % (id)\n            postkantons = self.caches['long'].get_or_create(key, creator)\n        else:\n            postkantons = creator()\n        for r in postkantons:\n            r.set_gateway(self)\n        return postkantons", "response": "List all postkantons in a Gemeente."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving a postkanton by the Huisnummer.", "response": "def get_postkanton_by_huisnummer(self, huisnummer):\n        '''\n        Retrieve a `postkanton` by the Huisnummer.\n\n        :param huisnummer: The :class:`Huisnummer` for which the `postkanton` \\\n                is wanted.\n        :rtype: :class:`Postkanton`\n        '''\n        try:\n            id = huisnummer.id\n        except AttributeError:\n            id = huisnummer\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetPostkantonByHuisnummerId', id\n            )\n            if res == None:\n                 raise GatewayResourceNotFoundException()\n            return Postkanton(\n                res.PostkantonCode\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetPostkantonByHuisnummerId#%s' % (id)\n            postkanton = self.caches['short'].get_or_create(key, creator)\n        else:\n            postkanton = creator()\n        postkanton.set_gateway(self)\n        return postkanton"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a Wegobject by the Id.", "response": "def get_wegobject_by_id(self, id):\n        '''\n        Retrieve a `Wegobject` by the Id.\n\n        :param integer id: the Id of the `Wegobject`\n        :rtype: :class:`Wegobject`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetWegobjectByIdentificatorWegobject', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Wegobject(\n                res.IdentificatorWegobject,\n                res.AardWegobject,\n                (res.CenterX, res.CenterY),\n                (res.MinimumX, res.MinimumY, res.MaximumX, res.MaximumY),\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetWegobjectByIdentificatorWegobject#%s' % (id)\n            wegobject = self.caches['short'].get_or_create(key, creator)\n        else:\n            wegobject = creator()\n        wegobject.set_gateway(self)\n        return wegobject"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all wegobjecten in a Straat.", "response": "def list_wegobjecten_by_straat(self, straat):\n        '''\n        List all `wegobjecten` in a :class:`Straat`\n\n        :param straat: The :class:`Straat` for which the `wegobjecten` \\\n                are wanted.\n        :rtype: A :class:`list` of :class:`Wegobject`\n        '''\n        try:\n            id = straat.id\n        except AttributeError:\n            id = straat\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListWegobjectenByStraatnaamId', id\n            )\n            try:\n                return [\n                    Wegobject(\n                        r.IdentificatorWegobject,\n                        r.AardWegobject\n                    )for r in res.WegobjectItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListWegobjectenByStraatnaamId#%s' % (id)\n            wegobjecten = self.caches['short'].get_or_create(key, creator)\n        else:\n            wegobjecten = creator()\n        for r in wegobjecten:\n            r.set_gateway(self)\n        return wegobjecten"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a wegsegment by the Id.", "response": "def get_wegsegment_by_id(self, id):\n        '''\n        Retrieve a `wegsegment` by the Id.\n\n        :param integer id: the Id of the `wegsegment`\n        :rtype: :class:`Wegsegment`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client,\n                'GetWegsegmentByIdentificatorWegsegment', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Wegsegment(\n                res.IdentificatorWegsegment,\n                res.StatusWegsegment,\n                res.GeometriemethodeWegsegment,\n                res.Geometrie,\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetWegsegmentByIdentificatorWegsegment#%s' % (id)\n            wegsegment = self.caches['short'].get_or_create(key, creator)\n        else:\n            wegsegment = creator()\n        wegsegment.set_gateway(self)\n        return wegsegment"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist all wegsegmenten in a Straat.", "response": "def list_wegsegmenten_by_straat(self, straat):\n        '''\n        List all `wegsegmenten` in a :class:`Straat`\n\n        :param straat: The :class:`Straat` for which the `wegsegmenten` \\\n                are wanted.\n        :rtype: A :class:`list` of :class:`Wegsegment`\n        '''\n        try:\n            id = straat.id\n        except AttributeError:\n            id = straat\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListWegsegmentenByStraatnaamId', id\n            )\n            try:\n                return[\n                    Wegsegment(\n                        r.IdentificatorWegsegment,\n                        r.StatusWegsegment\n                    )for r in res.WegsegmentItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListWegsegmentenByStraatnaamId#%s' % (id)\n            wegsegmenten = self.caches['short'].get_or_create(key, creator)\n        else:\n            wegsegmenten = creator()\n        for r in wegsegmenten:\n            r.set_gateway(self)\n        return wegsegmenten"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting all terreinobjecten for a given huisnummer.", "response": "def list_terreinobjecten_by_huisnummer(self, huisnummer):\n        '''\n        List all `terreinobjecten` for a :class:`Huisnummer`\n\n        :param huisnummer: The :class:`Huisnummer` for which the \\\n            `terreinobjecten` are wanted.\n        :rtype: A :class:`list` of :class:`Terreinobject`\n        '''\n        try:\n            id = huisnummer.id\n        except AttributeError:\n            id = huisnummer\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListTerreinobjectenByHuisnummerId', id\n            )\n            try:\n                return[\n                    Terreinobject(\n                        r.IdentificatorTerreinobject,\n                        r.AardTerreinobject\n                    )for r in res.TerreinobjectItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListTerreinobjectenByHuisnummerId#%s' % (id)\n            terreinobjecten = self.caches['short'].get_or_create(key, creator)\n        else:\n            terreinobjecten = creator()\n        for r in terreinobjecten:\n            r.set_gateway(self)\n        return terreinobjecten"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve a Terreinobject by the Id.", "response": "def get_terreinobject_by_id(self, id):\n        '''\n        Retrieve a `Terreinobject` by the Id.\n\n        :param integer id: the Id of the `Terreinobject`\n        :rtype: :class:`Terreinobject`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client,\n                'GetTerreinobjectByIdentificatorTerreinobject', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Terreinobject(\n                res.IdentificatorTerreinobject,\n                res.AardTerreinobject,\n                (res.CenterX, res.CenterY),\n                (res.MinimumX, res.MinimumY, res.MaximumX, res.MaximumY),\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetTerreinobjectByIdentificatorTerreinobject#%s' % (id)\n            terreinobject = self.caches['short'].get_or_create(key, creator)\n        else:\n            terreinobject = creator()\n        terreinobject.set_gateway(self)\n        return terreinobject"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting all percelen for a Huisnummer.", "response": "def list_percelen_by_huisnummer(self, huisnummer):\n        '''\n        List all `percelen` for a :class:`Huisnummer`\n\n        :param huisnummer: The :class:`Huisnummer` for which the \\\n            `percelen` are wanted.\n        :rtype: A :class:`list` of :class:`Perceel`\n        '''\n        try:\n            id = huisnummer.id\n        except AttributeError:\n            id = huisnummer\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListPercelenByHuisnummerId', id\n            )\n            try:\n                return [\n                    Perceel(\n                        r.IdentificatorPerceel\n                    )for r in res.PerceelItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListPercelenByHuisnummerId#%s' % (id)\n            percelen = self.caches['short'].get_or_create(key, creator)\n        else:\n            percelen = creator()\n        for r in percelen:\n            r.set_gateway(self)\n        return percelen"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving a Perceel by the Id.", "response": "def get_perceel_by_id(self, id):\n        '''\n        Retrieve a `Perceel` by the Id.\n\n        :param string id: the Id of the `Perceel`\n        :rtype: :class:`Perceel`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetPerceelByIdentificatorPerceel', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Perceel(\n                res.IdentificatorPerceel,\n                (res.CenterX, res.CenterY),\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetPerceelByIdentificatorPerceel#%s' % (id)\n            perceel = self.caches['short'].get_or_create(key, creator)\n        else:\n            perceel = creator()\n        perceel.set_gateway(self)\n        return perceel"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all gebouwen for a Huisnummer.", "response": "def list_gebouwen_by_huisnummer(self, huisnummer):\n        '''\n        List all `gebouwen` for a :class:`Huisnummer`.\n\n        :param huisnummer: The :class:`Huisnummer` for which the \\\n            `gebouwen` are wanted.\n        :rtype: A :class:`list` of :class:`Gebouw`\n        '''\n        try:\n            id = huisnummer.id\n        except AttributeError:\n            id = huisnummer\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListGebouwenByHuisnummerId', id\n            )\n            try:\n                return [\n                    Gebouw(\n                        r.IdentificatorGebouw,\n                        r.AardGebouw,\n                        r.StatusGebouw\n                    )for r in res.GebouwItem\n                ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListGebouwenByHuisnummerId#%s' % (id)\n            gebouwen = self.caches['short'].get_or_create(key, creator)\n        else:\n            gebouwen = creator()\n        for r in gebouwen:\n            r.set_gateway(self)\n        return gebouwen"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gebouw_by_id(self, id):\n        '''\n        Retrieve a `Gebouw` by the Id.\n\n        :param integer id: the Id of the `Gebouw`\n        :rtype: :class:`Gebouw`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetGebouwByIdentificatorGebouw', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Gebouw(\n                res.IdentificatorGebouw,\n                res.AardGebouw,\n                res.StatusGebouw,\n                res.GeometriemethodeGebouw,\n                res.Geometrie,\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetGebouwByIdentificatorGebouw#%s' % (id)\n            gebouw = self.caches['short'].get_or_create(key, creator)\n        else:\n            gebouw = creator()\n        gebouw.set_gateway(self)\n        return gebouw", "response": "Retrieve a Gebouw by the Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all subadressen for a given huisnummer.", "response": "def list_subadressen_by_huisnummer(self, huisnummer):\n        '''\n        List all `subadressen` for a :class:`Huisnummer`.\n\n        :param huisnummer: The :class:`Huisnummer` for which the \\\n            `subadressen` are wanted. OR A huisnummer id.\n        :rtype: A :class:`list` of :class:`Gebouw`\n        '''\n        try:\n            id = huisnummer.id\n        except AttributeError:\n            id = huisnummer\n\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListSubadressenWithStatusByHuisnummerId', id\n            )\n            try:\n                return [ Subadres(\n                    r.SubadresId,\n                    r.Subadres,\n                    r.StatusSubadres\n                )for r in res.SubadresWithStatusItem ]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListSubadressenWithStatusByHuisnummerId#%s' % (id)\n            subadressen = self.caches['short'].get_or_create(key, creator)\n        else:\n            subadressen = creator()\n        for s in subadressen:\n            s.set_gateway(self)\n        return subadressen"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_subadres_by_id(self, id):\n        '''\n        Retrieve a `Subadres` by the Id.\n\n        :param integer id: the Id of the `Subadres`\n        :rtype: :class:`Subadres`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetSubadresWithStatusBySubadresId', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Subadres(\n                res.SubadresId,\n                res.Subadres,\n                res.StatusSubadres,\n                res.HuisnummerId,\n                res.AardSubadres,\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetSubadresWithStatusBySubadresId#%s' % (id)\n            subadres = self.caches['short'].get_or_create(key, creator)\n        else:\n            subadres = creator()\n        subadres.set_gateway(self)\n        return subadres", "response": "Retrieve a Subadres by the Id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_adresposities_by_nummer_and_straat(self, nummer, straat):\n        '''\n        List all `adresposities` for a huisnummer and a :class:`Straat`.\n\n        :param nummer: A string representing a certain huisnummer.\n        :param straat: The :class:`Straat` for which the \\\n            `adresposities` are wanted. OR A straat id.\n        :rtype: A :class:`list` of :class:`Adrespositie`\n        '''\n        try:\n            sid = straat.id\n        except AttributeError:\n            sid = straat\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListAdrespositiesByHuisnummer', nummer, sid\n            )\n            try:\n                return [Adrespositie(\n                    r.AdrespositieId,\n                    r.HerkomstAdrespositie\n                )for r in res.AdrespositieItem]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListAdrespositiesByHuisnummer#%s%s' % (nummer, sid)\n            adresposities = self.caches['short'].get_or_create(key, creator)\n        else:\n            adresposities = creator()\n        for a in adresposities:\n            a.set_gateway(self)\n        return adresposities", "response": "List all adresposities for a certain huisnummer and a straat."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_adresposities_by_subadres_and_huisnummer(self, subadres, huisnummer):\n        '''\n        List all `adresposities` for a subadres and a :class:`Huisnummer`.\n\n        :param subadres: A string representing a certain subadres.\n        :param huisnummer: The :class:`Huisnummer` for which the \\\n            `adresposities` are wanted. OR A huisnummer id.\n        :rtype: A :class:`list` of :class:`Adrespositie`\n        '''\n        try:\n            hid = huisnummer.id\n        except AttributeError:\n            hid = huisnummer\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'ListAdrespositiesBySubadres', subadres, hid\n            )\n            try:\n                return [Adrespositie(\n                    r.AdrespositieId,\n                    r.HerkomstAdrespositie\n                )for r in res.AdrespositieItem]\n            except AttributeError:\n                return []\n        if self.caches['short'].is_configured:\n            key = 'ListAdrespositiesBySubadres#%s%s' % (subadres, hid)\n            adresposities = self.caches['short'].get_or_create(key, creator)\n        else:\n            adresposities = creator()\n        for a in adresposities:\n            a.set_gateway(self)\n        return adresposities", "response": "List all adresposities for a certain subadres and huisnummer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_adrespositie_by_id(self, id):\n        '''\n        Retrieve a `Adrespositie` by the Id.\n\n        :param integer id: the Id of the `Adrespositie`\n        :rtype: :class:`Adrespositie`\n        '''\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetAdrespositieByAdrespositieId', id\n            )\n            if res == None:\n                raise GatewayResourceNotFoundException()\n            return Adrespositie(\n                res.AdrespositieId,\n                res.HerkomstAdrespositie,\n                res.Geometrie,\n                res.AardAdres,\n                Metadata(\n                    res.BeginDatum,\n                    res.BeginTijd,\n                    self.get_bewerking(res.BeginBewerking),\n                    self.get_organisatie(res.BeginOrganisatie)\n                )\n            )\n        if self.caches['short'].is_configured:\n            key = 'GetAdrespositieByAdrespositieId#%s' % (id)\n            adrespositie = self.caches['short'].get_or_create(key, creator)\n        else:\n            adrespositie = creator()\n        adrespositie.set_gateway(self)\n        return adrespositie", "response": "Retrieve a Adrespositie by the Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_postadres_by_huisnummer(self, huisnummer):\n        '''\n        Get the `postadres` for a :class:`Huisnummer`.\n\n        :param huisnummer: The :class:`Huisnummer` for which the \\\n            `postadres` is wanted. OR A huisnummer id.\n        :rtype: A :class:`str`.\n        '''\n        try:\n            id = huisnummer.id\n        except AttributeError:\n            id = huisnummer\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetPostadresByHuisnummerId', id\n            )\n            if res == None:\n                 raise GatewayResourceNotFoundException()\n            return res.Postadres\n        if self.caches['short'].is_configured:\n            key = 'GetPostadresByHuisnummerId#%s' % (id)\n            postadres = self.caches['short'].get_or_create(key, creator)\n        else:\n            postadres = creator()\n        return postadres", "response": "Get the postadres for a Huisnummer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_postadres_by_subadres(self, subadres):\n        '''\n        Get the `postadres` for a :class:`Subadres`.\n\n        :param subadres: The :class:`Subadres` for which the \\\n            `postadres` is wanted. OR A subadres id.\n        :rtype: A :class:`str`.\n        '''\n        try:\n            id = subadres.id\n        except AttributeError:\n            id = subadres\n        def creator():\n            res = crab_gateway_request(\n                self.client, 'GetPostadresBySubadresId', id\n            )\n            if res == None:\n                 raise GatewayResourceNotFoundException()\n            return res.Postadres\n        if self.caches['short'].is_configured:\n            key = 'GetPostadresBySubadresId#%s' % (id)\n            postadres = self.caches['short'].get_or_create(key, creator)\n        else:\n            postadres = creator()\n        return postadres", "response": "Get the postadres for a subadres."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_gateway(self, gateway):\n        '''\n        :param crabpy.gateway.crab.CrabGateway gateway: Gateway to use.\n        '''\n        self.gateway = gateway\n        self.gewest.gateway = gateway", "response": "Sets the gateway for this object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef postadressen(self):\n        '''\n        Returns the postadressen for this Perceel.\n\n        Will only take the huisnummers with status `inGebruik` into account.\n\n        :rtype: list \n        '''\n        return [h.postadres for h in self.huisnummers if h.status.id == '3']", "response": "Returns the postadressen for this Perceel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_salt_cmd(target, module, args=None, kwargs=None):\n    args = args or []\n    kwargs = kwargs or {}\n    target = target or '*'\n    target = '\"%s\"' % target\n    cmd = [target, module]\n    for arg in args:\n        cmd.append(arg)\n    for key in kwargs:\n        cmd.append('{0}={1}'.format(key, kwargs[key]))\n    return cmd", "response": "Generates a salt command"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute a salt - ssh command", "response": "def salt_ssh(project, target, module, args=None, kwargs=None):\n    \"\"\"\n    Execute a `salt-ssh` command\n    \"\"\"\n    cmd = ['salt-ssh']\n    cmd.extend(generate_salt_cmd(target, module, args, kwargs))\n    cmd.append('--state-output=mixed')\n    cmd.append('--roster-file=%s' % project.roster_path)\n    cmd.append('--config-dir=%s' % project.salt_ssh_config_dir)\n    cmd.append('--ignore-host-keys')\n    cmd.append('--force-color')\n    cmd = ' '.join(cmd)\n    logger.debug('salt-ssh cmd: %s', cmd)\n\n    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    out, err = proc.communicate()\n    if proc.returncode != 0 or err:\n        raise Exception(err)\n    return out + err"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef salt_master(project, target, module, args=None, kwargs=None):\n    client = project.cluster.head.ssh_client\n\n    cmd = ['salt']\n    cmd.extend(generate_salt_cmd(target, module, args, kwargs))\n    cmd.append('--timeout=300')\n    cmd.append('--state-output=mixed')\n    cmd = ' '.join(cmd)\n\n    output = client.exec_command(cmd, sudo=True)\n    if output['exit_code'] == 0:\n        return output['stdout']\n    else:\n        return output['stderr']", "response": "Execute a salt command in the head node"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getenv(name, **kwargs):\n    default_value = kwargs.pop('default', None)\n    desired_type = kwargs.pop('type', str)\n    list_separator = kwargs.pop('separator', ',')\n\n    value = os.getenv(name, None)\n\n    if value is None:\n        if default_value is None:\n            return None\n        else:\n            return default_value\n\n    if desired_type is bool:\n        if value.lower() in ['false', '0']:\n            return False\n        else:\n            return bool(value)\n\n    if desired_type is list or desired_type is tuple:\n        value = value.split(list_separator)\n        return desired_type(value)\n\n    if desired_type is dict:\n        return dict(literal_eval(value))\n\n    return desired_type(value)", "response": "Retrieves environment variable by name and casts the value to desired type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_network(user=None, reset=False):\n\n    token = collect_token()\n\n    try:\n        gh = login(token=token)\n        root_user = gh.user(user)\n    except Exception, e:\n        # Failed to login using the token, github3.models.GitHubError\n        raise e\n\n    graph_nodes = []\n    graph_edges = []\n\n    username = user if user is not None else root_user.login\n\n    if not is_cached(username_to_file(username)) or reset:\n        graph_nodes.append(username)\n\n        # @TODO: take care of the 'rate limit exceeding' if imposed\n        try:\n            for person in gh.iter_following(username):\n                graph_nodes.append(str(person))\n                graph_edges.append((root_user.login, str(person)))\n\n            for i in range(1, root_user.following):\n                user = gh.user(graph_nodes[i])\n                user_following_edges = [(user.login, str(person)) for person in gh.iter_following(\n                    user) if str(person) in graph_nodes]\n                graph_edges += user_following_edges\n        except Exception, e:\n            raise e\n\n        generate_gml(username, graph_nodes, graph_edges, True)\n    else:\n        reuse_gml(username)\n\n    return username", "response": "Generate the network for a given user"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports the element from an lxml. etree. _Element xml_element and loads its content.", "response": "def import_element(self, xml_element):\n        \"\"\"\n        Imports the element from an lxml element and loads its content.\n\n        :param lxml.etree._Element xml_element: XML element to import.\n        \"\"\"\n\n        self.xml_element = xml_element\n\n        uri, tag = Element.get_namespace_and_tag(self.xml_element.tag)\n        self.namespace = uri\n        self.name = tag\n\n        self.load_xml_attrs()\n\n        if self.xml_element.text is None:\n            self.text = ''\n        else:\n            self.text = self.xml_element.text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes the object necessary data in a dictionary.", "response": "def as_dict(self):\n        \"\"\"\n        Serializes the object necessary data in a dictionary.\n\n        :returns: Serialized data in a dictionary.\n        :rtype: dict\n        \"\"\"\n\n        element_dict = dict()\n        if hasattr(self, 'namespace'):\n            element_dict['namespace'] = self.namespace\n        if hasattr(self, 'name'):\n            element_dict['name'] = self.name\n        if hasattr(self, 'text'):\n            element_dict['text'] = self.text\n\n        attr_dict = dict()\n        for attr in self.attrs:\n            if hasattr(self, attr):\n                attr_dict[attr] = getattr(self, attr)\n        element_dict['attrs'] = attr_dict\n\n        return element_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_xml_attrs(self):\n\n        attrs_list = list()\n\n        if hasattr(self, 'xml_element'):\n            xml_attrs = self.xml_element.attrib\n\n            for variable, value in iter(xml_attrs.items()):\n                uri, tag = Element.get_namespace_and_tag(variable)\n                tag = tag.replace('-', '_')\n                attrs_list.append(tag)\n                setattr(self, tag, value)\n\n            self.attrs = attrs_list\n\n        return self.attrs", "response": "Loads XML attributes as object attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nseparating the namespace and tag from an element.", "response": "def get_namespace_and_tag(name):\n        \"\"\"\n        Separates the namespace and tag from an element.\n\n        :param str name: Tag.\n        :returns: Namespace URI and Tag namespace.\n        :rtype: tuple\n        \"\"\"\n\n        if isinstance(name, str):\n            if name[0] == \"{\":\n                uri, ignore, tag = name[1:].partition(\"}\")\n            else:\n                uri = None\n                tag = name\n        else:\n            uri = None\n            tag = None\n        return uri, tag"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a command to the specified writer.", "response": "def write_command(cls, writer, name, buffers=()):\n        \"\"\"\n        Write a command to the specified writer.\n\n        :param writer: The writer to use.\n        :param name: The command name.\n        :param buffers: The buffers to writer.\n        \"\"\"\n        assert len(name) < 256\n\n        body_len = len(name) + 1 + sum(len(buffer) for buffer in buffers)\n\n        if body_len < 256:\n            writer.write(struct.pack('!BBB', 0x04, body_len, len(name)))\n        else:\n            writer.write(struct.pack('!BQB', 0x06, body_len, len(name)))\n\n        writer.write(name)\n\n        for buffer in buffers:\n            writer.write(buffer)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def _expect_command(cls, reader, name):\n        size_type = struct.unpack('B', await reader.readexactly(1))[0]\n\n        if size_type == 0x04:\n            size = struct.unpack('!B', await reader.readexactly(1))[0]\n        elif size_type == 0x06:\n            size = struct.unpack('!Q', await reader.readexactly(8))[0]\n        else:\n            raise ProtocolError(\n                \"Unexpected size type: %0x\" % size_type,\n                fatal=True,\n            )\n\n        name_size = struct.unpack('B', await reader.readexactly(1))[0]\n\n        if name_size != len(name):\n            raise ProtocolError(\n                \"Unexpected command name size: %s (expecting %s)\" % (\n                    name_size,\n                    len(name),\n                ),\n                fatal=True,\n            )\n\n        c_name = await reader.readexactly(name_size)\n\n        if c_name != name:\n            raise ProtocolError(\n                \"Unexpected command name: %s (expecting %s)\" % (c_name, name),\n                fatal=True,\n            )\n\n        return await reader.readexactly(size - name_size - 1)", "response": "Expect a command.\n\n        :param reader: The reader to use.\n        :returns: The command data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfits a new entry set according to the Baart criteria.", "response": "def fit(self, X, y=None):\n        \"\"\"\n        Sets *self.degree* according to :func:`baart_criteria` if *degree_range*\n        is not None, otherwise does nothing.\n\n        **Parameters**\n\n        X : array-like, shape = [n_samples, 1]\n            Column vector of phases.\n        y : array-like or None, shape = [n_samples], optional\n            Row vector of magnitudes (default None).\n\n        **Returns**\n\n        self : returns an instance of self\n        \"\"\"\n        if self.degree_range is not None:\n            self.degree = self.baart_criteria(X, y)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntransforming X from phase - space to Fourier - space returning the design matrix produced by Fourier. design_matrix.", "response": "def transform(self, X, y=None, **params):\n        \"\"\"\n        Transforms *X* from phase-space to Fourier-space, returning the design\n        matrix produced by :func:`Fourier.design_matrix` for input to a\n        regressor.\n\n        **Parameters**\n\n        X : array-like, shape = [n_samples, 1]\n            Column vector of phases.\n        y : None, optional\n            Unused argument for conformity (default None).\n\n        **Returns**\n\n        design_matrix : array-like, shape = [n_samples, 2*degree+1]\n            Fourier design matrix produced by :func:`Fourier.design_matrix`.\n        \"\"\"\n        data = numpy.dstack((numpy.array(X).T[0], range(len(X))))[0]\n        phase, order = data[data[:,0].argsort()].T\n        design_matrix = self.design_matrix(phase, self.degree)\n        return design_matrix[order.argsort()]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the optimal Fourier series degree as determined by Baart s Criteria <http://articles. adsabs. harvard. edu. edu > = 1986 A&A Vol. 170 p. 59 - 69.", "response": "def baart_criteria(self, X, y):\n        \"\"\"\n        Returns the optimal Fourier series degree as determined by\n        `Baart's Criteria <http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1986A%26A...170...59P&amp;data_type=PDF_HIGH&amp;whole_paper=YES&amp;type=PRINTER&amp;filetype=.pdf>`_ [JOP]_.\n\n        **Citations**\n\n        .. [JOP] J. O. Petersen, 1986,\n                 \"Studies of Cepheid type variability. IV.\n                 The uncertainties of Fourier decomposition parameters.\",\n                 A&A, Vol. 170, p. 59-69\n        \"\"\"\n        try:\n            min_degree, max_degree = self.degree_range\n        except ValueError:\n            raise ValueError(\"Degree range must be a length two sequence\")\n\n        cutoff = self.baart_tolerance(X)\n        pipeline = Pipeline([('Fourier', Fourier()),\n                             ('Regressor', self.regressor)])\n        sorted_X = numpy.sort(X, axis=0)\n        X_sorting = numpy.argsort(rowvec(X))\n        for degree in range(min_degree, max_degree):\n            pipeline.set_params(Fourier__degree=degree)\n            pipeline.fit(X, y)\n            lc = pipeline.predict(sorted_X)\n            residuals = y[X_sorting] - lc\n            p_c = autocorrelation(residuals)\n            if abs(p_c) <= cutoff:\n                return degree\n        # reached max_degree without reaching cutoff\n        return max_degree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a design matrix for the entry - set of the entry set.", "response": "def design_matrix(phases, degree):\n        r\"\"\"\n        Constructs an :math:`N \\times 2n+1` matrix of the form:\n\n        .. math::\n\n            \\begin{bmatrix}\n              1\n            & \\sin(1 \\cdot 2\\pi \\cdot \\phi_0)\n            & \\cos(1 \\cdot 2\\pi \\cdot \\phi_0)\n            & \\ldots\n            & \\sin(n \\cdot 2\\pi \\cdot \\phi_0)\n            & \\cos(n \\cdot 2\\pi \\cdot \\phi_0)\n            \\\\\n              \\vdots\n            & \\vdots\n            & \\vdots\n            & \\ddots\n            & \\vdots\n            & \\vdots\n            \\\\\n              1\n            & \\sin(1 \\cdot 2\\pi \\cdot \\phi_N)\n            & \\cos(1 \\cdot 2\\pi \\cdot \\phi_N)\n            & \\ldots\n            & \\sin(n \\cdot 2\\pi \\cdot \\phi_N)\n            & \\cos(n \\cdot 2\\pi \\cdot \\phi_N)\n            \\end{bmatrix}\n\n        where :math:`n =` *degree*, :math:`N =` *n_samples*, and\n        :math:`\\phi_i =` *phases[i]*.\n\n        Parameters\n        ----------\n        phases : array-like, shape = [n_samples]\n            \n        \"\"\"\n        n_samples = phases.size\n        # initialize coefficient matrix\n        M = numpy.empty((n_samples, 2*degree+1))\n        # indices\n        i = numpy.arange(1, degree+1)\n        # initialize the Nxn matrix that is repeated within the\n        # sine and cosine terms\n        x = numpy.empty((n_samples, degree))\n        # the Nxn matrix now has N copies of the same row, and each row is\n        # integer multiples of pi counting from 1 to the degree\n        x[:,:] = i*2*numpy.pi\n        # multiply each row of x by the phases\n        x.T[:,:] *= phases\n        # place 1's in the first column of the coefficient matrix\n        M[:,0]    = 1\n        # the odd indices of the coefficient matrix have sine terms\n        M[:,1::2] = numpy.sin(x)\n        # the even indices of the coefficient matrix have cosine terms\n        M[:,2::2] = numpy.cos(x)\n        return M"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef phase_shifted_coefficients(amplitude_coefficients, form='cos',\n                                   shift=0.0):\n        r\"\"\"\n        Converts Fourier coefficients from the amplitude form to the\n        phase-shifted form, as either a sine or cosine series.\n\n        Amplitude form:\n\n        .. math::\n            m(t) = A_0 + \\sum_{k=1}^n (a_k \\sin(k \\omega t)\n                                     + b_k \\cos(k \\omega t))\n\n        Sine form:\n\n        .. math::\n            m(t) = A_0 + \\sum_{k=1}^n A_k \\sin(k \\omega t + \\Phi_k)\n\n        Cosine form:\n\n        .. math::\n            m(t) = A_0 + \\sum_{k=1}^n A_k \\cos(k \\omega t + \\Phi_k)\n\n        **Parameters**\n\n        amplitude_coefficients : array-like, shape = [:math:`2n+1`]\n            Array of coefficients\n            :math:`[ A_0, a_1, b_1, \\ldots a_n, b_n ]`.\n        form : str, optional\n            Form of output coefficients, must be one of 'sin' or 'cos'\n            (default 'cos').\n        shift : number, optional\n            Shift to apply to light curve (default 0.0).\n\n        **Returns**\n\n        out : array-like, shape = [:math:`2n+1`]\n            Array of coefficients\n            :math:`[ A_0, A_1, \\Phi_1, \\ldots, A_n, \\Phi_n ]`.\n        \"\"\"\n        if form != 'sin' and form != 'cos':\n            raise NotImplementedError(\n                'Fourier series must have form sin or cos')\n\n        # separate array of coefficients into respective parts\n        A_0 = amplitude_coefficients[0]\n        a_k = amplitude_coefficients[1::2]\n        b_k = amplitude_coefficients[2::2]\n\n        degree = a_k.size\n        k = numpy.arange(1, degree+1)\n        # A_k and Phi_k are the angle and hypotenuse in the right triangles\n        # pictured below. A_k is obtained with the Pythagorean theorem, and\n        # Phi_k is obtained with the 2-argument inverse tangent.\n        # The positions of a_k and b_k depend on whether it is a sin or cos\n        # series.\n        #\n        # Cos series                Sin series\n        #\n        #    b_k                          /|\n        # ---------                      / |\n        # \\ \u03a6_k |_|                     /  |\n        #  \\      |                A_k /   |\n        #   \\     |                   /    | b_k\n        #    \\    | a_k              /     |\n        # A_k \\   |                 /     _|\n        #      \\  |                / \u03a6_k | |\n        #       \\ |                ---------\n        #        \\|                   a_k\n        #\n        A_k   = numpy.sqrt(a_k**2 + b_k**2)\n        # phase coefficients are shifted to the left by optional ``shift``\n        if form == 'cos':\n            Phi_k = numpy.arctan2(-a_k, b_k) + 2*pi*k*shift\n        elif form == 'sin':\n            Phi_k = numpy.arctan2(b_k, a_k) + 2*pi*k*shift\n        # constrain Phi between 0 and 2*pi\n        Phi_k %= 2*pi\n\n        phase_shifted_coefficients_ = numpy.empty(amplitude_coefficients.shape,\n                                                  dtype=float)\n        phase_shifted_coefficients_[0]    = A_0\n        phase_shifted_coefficients_[1::2] = A_k\n        phase_shifted_coefficients_[2::2] = Phi_k\n\n        return phase_shifted_coefficients_", "response": "r Converts the given amplitude coefficients to phase - shifted form."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fourier_ratios(phase_shifted_coeffs):\n\n\n        n_coeff = phase_shifted_coeffs.size\n        # n_coeff = 2*degree + 1 => degree = (n_coeff-1)/2\n        degree = (n_coeff - 1) / 2\n\n        amplitudes = phase_shifted_coeffs[1::2]\n        phases = phase_shifted_coeffs[2::2]\n\n        # there are degree-1 amplitude ratios, and degree-1 phase deltas,\n        # so altogether there are 2*(degree-1) values\n        ratios = numpy.empty(2*(degree-1), dtype=float)\n        amplitude_ratios = ratios[::2]\n        phase_deltas = ratios[1::2]\n\n        # amplitudes may be zero, so suppress division by zero warnings\n        with numpy.errstate(divide=\"ignore\"):\n            amplitude_ratios[:] = amplitudes[1:]\n            amplitude_ratios   /= amplitudes[0]\n\n        # indices for phase deltas\n        i = numpy.arange(2, degree+1)\n        phase_deltas[:] = phases[1:]\n        phase_deltas   -= i*phases[0]\n        # constrain phase_deltas between 0 and 2*pi\n        phase_deltas   %= 2*pi\n\n        return ratios", "response": "r Returns the R^j and \\ phi_j values for the given phase - shifted coefficients."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the specified command relative to the repository root. Returns a tuple containing the return code and the process output.", "response": "def _execute(self, command, stdin=None, stdout=subprocess.PIPE):\n        \"\"\"Executes the specified command relative to the repository root.\n        Returns a tuple containing the return code and the process output.\n        \"\"\"\n        process = subprocess.Popen(command, shell=True, cwd=self.root_path, stdin=stdin, stdout=stdout)\n        return (process.wait(), None if stdout is not subprocess.PIPE else process.communicate()[0].decode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_patch(self, patch_path):\n        # Do not create .orig backup files, and merge files in place.\n        return self._execute('patch -p1 --no-backup-if-mismatch --merge', stdout=open(os.devnull, 'w'), stdin=open(patch_path, 'r'))[0]", "response": "Applies the patch located at patch_path. Returns the return code of\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlooking at the root path of the repository.", "response": "def get_root_path(self, path):\n        \"\"\"See :py:meth:`~stash.repository.Repository.get_root_path`.\"\"\"\n        # Look at the directories present in the current working directory. In\n        # case a .svn directory is present, we know we are in the root directory\n        # of a Subversion repository (for Subversion 1.7.x). In case no\n        # repository specific folder is found, and the current directory has a\n        # parent directory, look if a repository specific directory can be found\n        # in the parent directory.\n        while path != '/':\n            if '.svn' in os.listdir(path):\n                return path\n            path = os.path.abspath(os.path.join(path, os.pardir))\n\n        # No Subversion repository found.\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef status(self):\n        result = set()\n        for line in self._execute('svn stat')[1].splitlines():\n            if line[0] == '?':\n                result.add((FileStatus.Added, line[2:].strip()))\n            elif line[0] == '!':\n                result.add((FileStatus.Removed, line[2:].strip()))\n        return result", "response": "Return a set of all the files in the repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_prefix(self):\n        if self.instance.fixed:\n            return self.instance.prefix\n\n        prefix = self.cleaned_data['prefix']\n        if not namespace.is_ncname(prefix):\n            raise forms.ValidationError(\"This is an invalid prefix\")\n\n        return prefix", "response": "Validates the prefix and returns the correct value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an SQLAlchemy query of the object s history ( previous versions.", "response": "def history(self):\n        \"\"\"Returns an SQLAlchemy query of the object's history (previous\n        versions). If the class does not support history/versioning,\n        returns None.\n        \"\"\"\n        history = self.history_class\n        if history:\n            return self.session.query(history).filter(history.id == self.id)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an appstruct of the object and it s properties. Does not recurse into SQLAlchemy relationships.", "response": "def generate_appstruct(self):\n        \"\"\"Returns a Deform compatible appstruct of the object and it's\n        properties. Does not recurse into SQLAlchemy relationships.\n        An example using the :class:`~drinks.models.User` class (that\n        inherits from BaseMixin):\n\n        .. code-block:: python\n\n            >>> user = User(username='mcuserpants', disabled=True)\n            >>> user.appstruct\n            {'disabled': True, 'username': 'mcuserpants'}\n\n        \"\"\"\n        mapper = object_mapper(self)\n        return dict([(p.key, self.__getattribute__(p.key)) for\n                     p in mapper.iterate_properties if\n                     not self.__getattribute__(p.key) is None])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the absolute path for patch_name.", "response": "def _get_patch_path(cls, patch_name):\n        \"\"\"Returns the absolute path for patch *patch_name*.\"\"\"\n        return os.path.join(cls.STASH_PATH, patch_name) if patch_name else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_patch(cls, patch_name):\n        try:\n            os.unlink(cls._get_patch_path(patch_name))\n        except:\n            raise StashException(\"patch '%s' does not exist\" % patch_name)", "response": "Removes a patch from the stash."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the contents of the specified patch.", "response": "def get_patch(cls, patch_name):\n        \"\"\"Returns the contents of the specified patch *patch_name*.\n\n        :raises: :py:exc:`~stash.exception.StashException` in case *patch_name* does not exist.\n        \"\"\"\n        try:\n            return open(cls._get_patch_path(patch_name), 'r').read()\n        except:\n            raise StashException(\"patch '%s' does not exist\" % patch_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies the patch on to the current working directory in the stash. Returns True if the patch was successful False otherwise.", "response": "def apply_patch(self, patch_name):\n        \"\"\"Applies the patch *patch_name* on to the current working directory in\n        case the patch exists. In case applying the patch was successful, the\n        patch is automatically removed from the stash. Returns ``True`` in case\n        applying the patch was successful, otherwise ``False`` is returned.\n\n        :raises: :py:exc:`~stash.exception.StashException` in case *patch_name* does not exist.\n        \"\"\"\n        if patch_name in self.get_patches():\n            patch_path = self._get_patch_path(patch_name)\n\n            # Apply the patch, and determine the files that have been added and\n            # removed.\n            pre_file_status = self.repository.status()\n            patch_return_code = self.repository.apply_patch(patch_path)\n            changed_file_status = self.repository.status().difference(pre_file_status)\n\n            # Determine all files that have been added.\n            for status, file_name in changed_file_status:\n                if status == FileStatus.Added:\n                    self.repository.add([file_name])\n                elif status == FileStatus.Removed:\n                    self.repository.remove([file_name])\n\n            if patch_return_code == 0:\n                # Applying the patch succeeded, remove stashed patch.\n                os.unlink(patch_path)\n\n            return patch_return_code == 0\n        else:\n            raise StashException(\"patch '%s' does not exist\" % patch_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new patch based on the changes in the current repository.", "response": "def create_patch(self, patch_name):\n        \"\"\"Creates a patch based on the changes in the current repository. In\n        case the specified patch *patch_name* already exists, ask the user to\n        overwrite the patch. In case creating the patch was successful, all\n        changes in the current repository are reverted. Returns ``True`` in case\n        a patch was created, and ``False`` otherwise.\n\n        :raises: :py:exc:`~stash.exception.StashException` in case *patch_name* already exists.\n        \"\"\"\n        # Raise an exception in case the specified patch already exists.\n        patch_path = self._get_patch_path(patch_name)\n        if os.path.exists(patch_path):\n            raise StashException(\"patch '%s' already exists\" % patch_name)\n\n        # Determine the contents for the new patch.\n        patch = self.repository.diff()\n        if patch != '':\n            # Create the patch.\n            patch_file = open(patch_path, 'wb')\n            patch_file.write(patch.encode('utf-8'))\n            patch_file.close()\n\n            # Undo all changes in the repository, and determine which files have\n            # been added or removed. Files that were added, need to be removed\n            # again.\n            pre_file_status = self.repository.status()\n            self.repository.revert_all()\n            changed_file_status = self.repository.status().difference(pre_file_status)\n\n            # Remove all files that are created by the patch that is now being\n            # stashed.\n            for status, file_name in changed_file_status:\n                if status == FileStatus.Added:\n                    os.unlink(os.path.join(self.repository.root_path, file_name))\n\n        # Return whether a non-empty patch was created.\n        return patch != ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns template context from configs.", "response": "def as_dict(self, section='Main', **kwargs):\n        \"\"\"Return template context from configs.\n\n        \"\"\"\n        items = super(MakesiteParser, self).items(section, **kwargs)\n        return dict(items)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate cache key and clean cached value.", "response": "def clean_cache(cached, **kwargs):\n    \" Generate cache key and clean cached value. \"\n\n    if isinstance(cached, basestring):\n        cached = _str_to_model(cached)\n\n    cache_key = generate_cache_key(cached, **kwargs)\n    cache.delete(cache_key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_cache_key(cached, **kwargs):\n\n    if isinstance(cached, QuerySet):\n        key = str(cached.query)\n\n    elif isinstance(cached, (Model, ModelBase)):\n        key = '%s.%s:%s' % (cached._meta.app_label,\n                            cached._meta.module_name,\n                            ','.join('%s=%s' % item for item in kwargs.iteritems()))\n\n    else:\n        raise AttributeError(\"Objects must be queryset or model.\")\n\n    if not key:\n        raise Exception('Cache key cannot be empty.')\n\n    key = clean_cache_key(key)\n    return key", "response": "Auto generate cache key for model or queryset"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces spaces with '-' and hash if length is greater than 250.", "response": "def clean_cache_key(key):\n    \"\"\" Replace spaces with '-' and hash if length is greater than 250.\n    \"\"\"\n    cache_key = re.sub(r'\\s+', '-', key)\n    cache_key = smart_str(cache_key)\n\n    if len(cache_key) > 200:\n        cache_key = cache_key[:150] + '-' + hashlib.md5(cache_key).hexdigest()\n\n    return cache_key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collect_static_files(src_map, dst):\n    for rel_src, abs_src in src_map.iteritems():\n        abs_dst = os.path.join(dst, rel_src)\n        copy_file(abs_src, abs_dst)", "response": "Collect all static files and move them into a temporary location."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a command and write it s stdout to root / dst.", "response": "def run_command(cmd, root, dst, input, params):\n    \"\"\"\n    Execute a command, and if successful write it's stdout to ``root``/``dst``.\n    \"\"\"\n    use_stdout = '{output}' not in cmd\n    if not use_stdout:\n        params['output'] = dst\n    parsed_cmd = parse_command(cmd, input=input, params=params)\n\n    ensure_dirs(os.path.join(root, dst))\n\n    logger.info(\"Running [%s] from [%s]\", parsed_cmd, root)\n\n    proc = subprocess.Popen(\n        args=parsed_cmd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        shell=True,\n        cwd=root,\n    )\n    (stdout, stderr) = proc.communicate()\n\n    assert not proc.returncode, stderr\n\n    if use_stdout:\n        # TODO: this should probably change dest to be a temp file\n        with open(os.path.join(root, dst), 'w') as fp:\n            fp.write(stdout)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_preprocessors(root, src, dst, processors):\n    matches = [(pattern, cmds) for pattern, cmds in processors.iteritems() if fnmatch(src, pattern)]\n    if not matches:\n        return False\n\n    params = get_format_params(dst)\n\n    for pattern, cmd_list in matches:\n        for cmd in cmd_list:\n            run_command(cmd, root=root, dst=dst, input=src, params=params)\n            src = dst\n\n    return True", "response": "Apply the processors to the source filename and run the commands to the destination filename."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_postcompilers(root, src_list, dst, processors):\n    dst_file = os.path.join(root, dst)\n\n    matches = [(pattern, cmds) for pattern, cmds in processors.iteritems() if fnmatch(dst, pattern)]\n    if not matches:\n        ensure_dirs(dst_file)\n        logger.info('Combining [%s] into [%s]', ' '.join(src_list), dst_file)\n        # We should just concatenate the files\n        with open(dst_file, 'w') as dst_fp:\n            for src in src_list:\n                with open(os.path.join(root, src)) as src_fp:\n                    for chunk in src_fp:\n                        dst_fp.write(chunk)\n        return True\n\n    params = get_format_params(dst)\n\n    # TODO: probably doesnt play nice everywhere\n    src_names = src_list\n    for pattern, cmd_list in matches:\n        for cmd in cmd_list:\n            run_command(cmd, root=root, dst=dst, input=' '.join(src_names), params=params)\n            src_names = [dst]\n\n    return True", "response": "Apply postcompilers to the source files."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset internal data to model.", "response": "def set_model_internal_data(model, original_data, modified_data, deleted_data):\n    \"\"\"\n    Set internal data to model.\n    \"\"\"\n    model.__original_data__ = original_data\n    list(map(model._prepare_child, model.__original_data__))\n\n    model.__modified_data__ = modified_data\n    list(map(model._prepare_child, model.__modified_data__))\n\n    model.__deleted_fields__ = deleted_data\n\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recover_model_from_data(model_class, original_data, modified_data, deleted_data):\n    model = model_class()\n    return set_model_internal_data(model, original_data, modified_data, deleted_data)", "response": "Reconstructs a model from original data modified and deleted data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recover_dynamic_model_from_data(model_class, original_data, modified_data, deleted_data, structure):\n    model = model_class()\n\n    model.__structure__ = {k: d[0](**d[1]) for k, d in structure.items()}\n\n    return set_model_internal_data(model, original_data, modified_data, deleted_data)", "response": "Function to reconstruct a DirtyModel from original data modified and deleted data structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recover_hashmap_model_from_data(model_class, original_data, modified_data, deleted_data, field_type):\n    model = model_class(field_type=field_type[0](**field_type[1]))\n    return set_model_internal_data(model, original_data, modified_data, deleted_data)", "response": "Reconstructs a model from original data modified and deleted data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recover_fast_dynamic_model_from_data(model_class, original_data, modified_data, deleted_data, field_types):\n    model = model_class()\n\n    model.__field_types__ = {k: d[0](**d[1]) for k, d in field_types.items()}\n\n    return set_model_internal_data(model, original_data, modified_data, deleted_data)", "response": "Function to reconstruct a model from original data modified and deleted data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_base_field(cls, field, key):\n        if not field.name:\n            field.name = key\n        elif key != field.name:\n            if not isinstance(field.alias, list):\n                field.alias = [key]\n            else:\n                field.alias.insert(0, key)\n            setattr(cls, field.name, field)\n\n        cls.prepare_field(field)\n\n        if field.alias:\n            for alias_name in field.alias:\n                if key is not alias_name:\n                    setattr(cls, alias_name, field)", "response": "Preprocess base field instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_field_value(self, name, value):\n        name = self.get_real_name(name)\n\n        if not name or not self._can_write_field(name):\n            return\n\n        if name in self.__deleted_fields__:\n            self.__deleted_fields__.remove(name)\n        if self.__original_data__.get(name) == value:\n            try:\n                self.__modified_data__.pop(name)\n            except KeyError:\n                pass\n        else:\n            self.__modified_data__[name] = value\n            self._prepare_child(value)\n            if name not in self.__structure__ or not self.__structure__[name].read_only:\n                return\n\n            try:\n                value.set_read_only(True)\n            except AttributeError:\n                pass", "response": "Set the value of a field in the modified_data structure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the value of a field from the modified data or the original one.", "response": "def get_field_value(self, name):\n        \"\"\"\n        Get the field value from the modified data or the original one\n        \"\"\"\n        name = self.get_real_name(name)\n\n        if not name or name in self.__deleted_fields__:\n            return None\n        modified = self.__modified_data__.get(name)\n        if modified is not None:\n            return modified\n        return self.__original_data__.get(name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_field_value(self, name):\n        name = self.get_real_name(name)\n\n        if name and self._can_write_field(name):\n            if name in self.__modified_data__:\n                self.__modified_data__.pop(name)\n\n            if name in self.__original_data__ and name not in self.__deleted_fields__:\n                self.__deleted_fields__.append(name)", "response": "Delete the value of a field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset_field_value(self, name):\n        name = self.get_real_name(name)\n\n        if name and self._can_write_field(name):\n            if name in self.__modified_data__:\n                del self.__modified_data__[name]\n\n            if name in self.__deleted_fields__:\n                self.__deleted_fields__.remove(name)\n\n            try:\n                self.__original_data__[name].clear_modified_data()\n            except (KeyError, AttributeError):\n                pass", "response": "Resets the value of a field in the record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn whether a field is modified or not", "response": "def is_modified_field(self, name):\n        \"\"\"\n        Returns whether a field is modified or not\n        \"\"\"\n        name = self.get_real_name(name)\n\n        if name in self.__modified_data__ or name in self.__deleted_fields__:\n            return True\n\n        try:\n            return self.get_field_value(name).is_modified()\n        except Exception:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_data(self, data):\n        if self.get_read_only() and self.is_locked():\n            return\n\n        if isinstance(data, BaseModel):\n            data = data.export_data()\n\n        if not isinstance(data, (dict, Mapping)):\n            raise TypeError('Impossible to import data')\n\n        self._import_data(data)", "response": "Imports the data into the instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef import_deleted_fields(self, data):\n\n        if self.get_read_only() and self.is_locked():\n            return\n\n        if isinstance(data, str):\n            data = [data]\n\n        for key in data:\n            if hasattr(self, key):\n                delattr(self, key)\n                continue\n\n            keys = key.split('.', 1)\n\n            if len(keys) != 2:\n                continue\n\n            child = getattr(self, keys[0])\n            child.import_deleted_fields(keys[1])", "response": "Import the deleted fields from the data list to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the results with the modified_data", "response": "def export_data(self):\n        \"\"\"\n        Get the results with the modified_data\n        \"\"\"\n        result = {}\n        data = self.__original_data__.copy()\n        data.update(self.__modified_data__)\n        for key, value in data.items():\n            if key in self.__deleted_fields__:\n                continue\n\n            try:\n                result[key] = value.export_data()\n            except AttributeError:\n                result[key] = value\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the modified data for the current object", "response": "def export_modified_data(self):\n        \"\"\"\n        Get the modified data\n        \"\"\"\n        # TODO: why None? Try to get a better flag\n        result = {key: None for key in self.__deleted_fields__}\n\n        for key, value in self.__modified_data__.items():\n            if key in result.keys():\n                continue\n            try:\n                result[key] = value.export_modified_data()\n            except AttributeError:\n                result[key] = value\n\n        for key, value in self.__original_data__.items():\n            if key in result.keys():\n                continue\n            try:\n                if value.is_modified():\n                    result[key] = value.export_modified_data()\n            except AttributeError:\n                pass\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn original field value or None", "response": "def get_original_field_value(self, name):\n        \"\"\"\n        Returns original field value or None\n        \"\"\"\n        name = self.get_real_name(name)\n\n        try:\n            value = self.__original_data__[name]\n        except KeyError:\n            return None\n\n        try:\n            return value.export_original_data()\n        except AttributeError:\n            return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef export_original_data(self):\n\n        return {key: self.get_original_field_value(key) for key in self.__original_data__.keys()}", "response": "Get the original data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef export_deleted_fields(self):\n        result = self.__deleted_fields__.copy()\n\n        for key, value in self.__original_data__.items():\n            if key in result:\n                continue\n            try:\n                partial = value.export_deleted_fields()\n                result.extend(['.'.join([key, key2]) for key2 in partial])\n            except AttributeError:\n                pass\n\n        return result", "response": "Returns a list with any deleted fields form original data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flat_data(self):\n\n        def flat_field(value):\n            \"\"\"\n            Flat field data\n            \"\"\"\n            try:\n                value.flat_data()\n                return value\n            except AttributeError:\n                return value\n\n        modified_dict = self.__original_data__\n        modified_dict.update(self.__modified_data__)\n        self.__original_data__ = {k: flat_field(v)\n                                  for k, v in modified_dict.items()\n                                  if k not in self.__deleted_fields__}\n\n        self.clear_modified_data()", "response": "Pass all the data from modified_data to original_data__"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears only the modified data for the related object", "response": "def clear_modified_data(self):\n        \"\"\"\n        Clears only the modified data\n        \"\"\"\n        self.__modified_data__ = {}\n        self.__deleted_fields__ = []\n\n        for value in self.__original_data__.values():\n            try:\n                value.clear_modified_data()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing all the data in the object keeping original data", "response": "def clear(self):\n        \"\"\"\n        Clears all the data in the object, keeping original data\n        \"\"\"\n        self.__modified_data__ = {}\n        self.__deleted_fields__ = [field for field in self.__original_data__.keys()]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning used fields of model", "response": "def get_fields(self):\n        \"\"\"\n        Returns used fields of model\n        \"\"\"\n        result = [key for key in self.__original_data__.keys()\n                  if key not in self.__deleted_fields__]\n        result.extend([key for key in self.__modified_data__.keys()\n                       if key not in result and key not in self.__deleted_fields__])\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_modified(self):\n        if len(self.__modified_data__) or len(self.__deleted_fields__):\n            return True\n\n        for value in self.__original_data__.values():\n            try:\n                if value.is_modified():\n                    return True\n            except AttributeError:\n                pass\n\n        return False", "response": "Returns whether the model is modified or not"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_attrs_by_path(self, field_path, stop_first=False):\n        fields, next_field = self._get_fields_by_path(field_path)\n        values = []\n        for field in fields:\n            if next_field:\n                try:\n                    res = self.get_field_value(field).get_attrs_by_path(next_field, stop_first=stop_first)\n                    if res is None:\n                        continue\n                    values.extend(res)\n\n                    if stop_first and len(values):\n                        break\n\n                except AttributeError:\n                    pass\n            else:\n                value = self.get_field_value(field)\n                if value is None:\n                    continue\n                if stop_first:\n                    return [value, ]\n                values.append(value)\n\n        return values if len(values) else None", "response": "This method returns a list of values looked up by field path. It returns a list of values or None if the path is invalid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_attr_by_path(self, field_path):\n        fields, next_field = self._get_fields_by_path(field_path)\n        for field in fields:\n            if next_field:\n                try:\n                    self.get_field_value(field).delete_attr_by_path(next_field)\n                except AttributeError:\n                    pass\n            else:\n                self.delete_field_value(field)", "response": "This method deletes the attribute of the related object by field path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reset_attr_by_path(self, field_path):\n        fields, next_field = self._get_fields_by_path(field_path)\n        for field in fields:\n            if next_field:\n                try:\n                    self.get_field_value(field).reset_attr_by_path(next_field)\n                except AttributeError:\n                    pass\n            else:\n                self.reset_field_value(field)", "response": "This method resets the original values for all the related fields in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting the data from the database into the instance.", "response": "def _import_data(self, data):\n        \"\"\"\n        Set the fields established in data to the instance\n        \"\"\"\n\n        for key, value in data.items():\n            if key.startswith('__'):\n                self._not_allowed_field(key)\n                continue\n\n            if not self.get_field_obj(key) and not self._define_new_field_by_value(key, value):\n                self._not_allowed_value(key, value)\n                continue\n\n            setattr(self, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a copy of the current object", "response": "def copy(self):\n        \"\"\"\n        Creates a copy of model\n        \"\"\"\n        return self.__class__(field_type=self.get_field_type(), data=self.export_data())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the value validated by the field_type", "response": "def get_validated_object(self, value):\n        \"\"\"\n        Returns the value validated by the field_type\n        \"\"\"\n        try:\n            if self.get_field_type().check_value(value) or self.get_field_type().can_use_value(value):\n                data = self.get_field_type().use_value(value)\n                self._prepare_child(data)\n                return data\n            else:\n                return None\n        except AttributeError:\n            return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_validated_object(self, field_type, value):\n        if field_type.check_value(value) or field_type.can_use_value(value):\n            data = field_type.use_value(value)\n            self._prepare_child(data)\n            return data\n        else:\n            return None", "response": "Returns the value validated by the field_type\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_current_structure(self):\n\n        struct = self.__class__.get_structure()\n        struct.update(self.__field_types__)\n        return struct", "response": "Returns a dictionary with model field objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self):\n        try:\n            self.client.connect(self.host, username=self.username,\n                           password=self.password, port=self.port,\n                           pkey=self.pkey, timeout=self.timeout)\n        except sock_gaierror, ex:\n            raise Exception(\"Unknown host '%s'\" % self.host)\n        except sock_error, ex:\n            raise Exception(\"Error connecting to host '%s:%s'\\n%s\" % (self.host, self.port, ex))\n        except paramiko.AuthenticationException, ex:\n            msg = \"Host is '%s:%s'\"\n            raise Exception(\"Authentication Error to host '%s'\" % self.host)\n        except paramiko.SSHException, ex:\n            msg = \"General SSH error - %s\" % ex\n            raise Exception(msg)", "response": "Connect to the current host and return the ID of the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping to paramiko. SSHClient. exec_command", "response": "def exec_command(self, command, sudo=False, **kwargs):\n        \"\"\"Wrapper to paramiko.SSHClient.exec_command\n        \"\"\"\n        channel = self.client.get_transport().open_session()\n        # stdin = channel.makefile('wb')\n        stdout = channel.makefile('rb')\n        stderr = channel.makefile_stderr('rb')\n\n        if sudo:\n            command = 'sudo -S bash -c \\'%s\\'' % command\n        else:\n            command = 'bash -c \\'%s\\'' % command\n\n        logger.debug(\"Running command %s on '%s'\", command, self.host)\n        channel.exec_command(command, **kwargs)\n\n        while not (channel.recv_ready() or channel.closed or\n                   channel.exit_status_ready()):\n            time.sleep(.2)\n\n        ret = {'stdout': stdout.read().strip(), 'stderr': stderr.read().strip(),\n               'exit_code': channel.recv_exit_status()}\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_sftp(self):\n        transport = self.client.get_transport()\n        transport.open_session()\n        return paramiko.SFTPClient.from_transport(transport)", "response": "Make a SFTP client from the open transport"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncopying local file to host via SFTP command Copy is done natively using SFTP version 2 protocol", "response": "def put(self, local, remote, sudo=False):\n        \"\"\"Copy local file to host via SFTP/SCP\n\n        Copy is done natively using SFTP/SCP version 2 protocol, no scp command\n        is used or required.\n        \"\"\"\n        if(os.path.isdir(local)):\n            self.put_dir(local, remote, sudo=sudo)\n        else:\n            self.put_single(local, remote, sudo=sudo)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef staticbundle(bundle, mimetype=None, **attrs):\n    config = getattr(settings, 'STATIC_BUNDLES', {})\n\n    if settings.DEBUG and 'packages' in config and bundle in config['packages']:\n        cache_root = os.path.join(settings.STATIC_ROOT, config.get('cache') or DEFAULT_CACHE_DIR)\n\n        bundle_opts = config['packages'][bundle]\n\n        root = os.path.join(cache_root, bundle_opts.get('cwd', ''))\n\n        changed = set()\n        src_list = bundle_opts['src']\n        is_mapping = isinstance(src_list, dict)\n\n        for src in src_list:\n            src_path = os.path.join(bundle_opts.get('cwd', ''), src)\n            abs_src = os.path.join(settings.STATIC_ROOT, src_path)\n\n            if is_mapping and not os.path.exists(os.path.join(root, src_list[src])):\n                    changed.add(src)\n\n            if abs_src is not None:\n                cached_mtime = BUNDLE_CACHE.get(abs_src)\n                current_mtime = os.stat(abs_src).st_mtime\n                if cached_mtime is None:\n                    try:\n                        BUNDLE_CACHE[abs_src] = cached_mtime = current_mtime\n                    except OSError:\n                        cached_mtime = 0\n                else:\n                    cached_mtime = BUNDLE_CACHE[abs_src]\n\n                if current_mtime != cached_mtime:\n                    changed.add(src_path)\n                    BUNDLE_CACHE[abs_src] = current_mtime\n\n            elif settings.TEMPLATE_DEBUG:\n                raise template.TemplateSyntaxError(\n                    \"The source file '%s' could not be located.\" % src_path)\n\n        if changed:\n            logger.info('Regenerating %s due to changes: %s', bundle, ' '.join(changed))\n            call_command('compilestatic', bundle)\n\n    #     if isinstance(src_list, dict):\n    #         src_list = src_list.values()\n\n    src_list = [bundle]\n\n    output = []\n    for src_path in src_list:\n        url = staticfiles_storage.url(src_path)\n\n        # Some storages backends will yield urls with querystring attached\n        path = urlparse.urlparse(url).path\n        if path.endswith('.css'):\n            mimetype = 'text/css'\n        elif path.endswith('.js'):\n            mimetype = 'text/javascript'\n\n        output.append(TEMPLATES[mimetype] % dict(\n            url=url,\n            mimetype=mimetype,\n            attrs=' '.join('%s=\"%s\"' % (k, escape(v)) for k, v in attrs.iteritems()),\n        ))\n\n    return '\\n'.join(output)", "response": "Generate a static bundle for the given bundle."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a XCCDF dateTime string to a datetime object.", "response": "def str_to_time(self):\n        \"\"\"\n        Formats a XCCDF dateTime string to a datetime object.\n\n        :returns: datetime object.\n        :rtype: datetime.datetime\n        \"\"\"\n\n        return datetime(*list(map(int, re.split(r'-|:|T', self.time))))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the xml element contents to match the instance contents.", "response": "def update_xml_element(self):\n        \"\"\"\n        Updates the xml element contents to matches the instance contents\n\n        :returns: Updated XML element\n        :rtype: lxml.etree._Element\n        \"\"\"\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        if hasattr(self, 'time'):\n            self.xml_element.set('time', self.time_to_str())\n        if hasattr(self, 'update'):\n            self.xml_element.set('update', str(self.update))\n        self.xml_element.text = self.text\n\n        return self.xml_element"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compile(pattern, flags=0, sep=None, split_prefix=False):\n  '''\n  Converts a glob-matching pattern (using Apache Cocoon style rules)\n  to a regular expression, which basically means that the following\n  characters have special meanings:\n\n  * ``?``:     matches any single character excluding the separator character\n  * ``*``:     matches zero or more characters excluding the separator character\n  * ``**``:    matches zero or more characters including the separator character\n  * ``\\``:     escape character used to precede any of the others for a literal\n  * ``[...]``: matches any character in the specified regex-style range\n  * ``{...}``: inlines a regex expression\n\n  :Parameters:\n\n  sep : str; default: \"/\"\n\n    The `sep` parameter specifies the hierarchical path component\n    separator to use. By default, it uses the unix-style forward-slash\n    separator (``\"/\"``), but can be overriden to be a sequence of\n    alternative valid hierarchical path component separator characters.\n    Note that although `sep` *could* be set to both forward- and back-\n    slashes (i.e. ``\"/\\\\\"``) to, theoretically, support either unix- and\n    windows-style path components, this has the significant flaw that\n    then *both* characters can be used within the same path as\n    separators.\n\n  flags : int; default: 0\n\n    The `flags` bit mask can contain all the standard `re` flags, in\n    addition to the ``globre.EXACT`` flag. If EXACT is set, then the\n    returned regex will include a leading '^' and trailing '$', meaning\n    that the regex must match the entire string, from beginning to end.\n\n  split_prefix : bool; default: false\n\n    If `split_prefix` is truthy, the return value becomes a tuple with\n    the first element set to any initial non-wildcarded string found in\n    the pattern. The second element remains the regex object as before.\n    For example, the pattern ``foo/**.ini`` would result in a tuple\n    equivalent to ``('foo/', re.compile('foo/.*\\\\.ini'))``.\n  '''\n\n  prefix = None\n  expr   = ''\n\n  if sep is None:\n    sep = '/'\n  if not sep:\n    TypeError('invalid parameter \"sep\" value: %r' % (sep,))\n  if set(sep) & set(SPECIAL_CHARS):\n    TypeError('parameter \"sep\" cannot contain any of %r' % (SPECIAL_CHARS,))\n  if len(sep) == 1:\n    literal = re.escape\n  else:\n    def make_literal(sep):\n      sep = '[' + re.escape(sep) + ']'\n      sepcre = re.compile(sep)\n      def _literal(text):\n        return sep.join(sepcre.split(text))\n      return _literal\n    literal = make_literal(sep)\n  if sep != '/':\n    sep = re.escape(sep)\n\n  for token in Tokenizer(pattern).tokens():\n    if split_prefix and expr == '':\n      prefix = token[1] if token[0] == Tokenizer.LITERAL else ''\n    if token[0] == Tokenizer.LITERAL:\n      expr += literal(token[1])\n    elif token[0] == Tokenizer.SINGLE:\n      expr += '[^' + sep + ']'\n    elif token[0] == Tokenizer.MULTIPLE:\n      expr += '[^' + sep + ']*?'\n    elif token[0] == Tokenizer.ANY:\n      expr += '.*?'\n    elif token[0] == Tokenizer.RANGE:\n      expr += '[' + token[1] + ']'\n    elif token[0] == Tokenizer.REGEX:\n      expr += token[1]\n    else:\n      ValueError('unexpected token %r from globre.Tokenizer for glob: %s'\n                 % (token, pattern))\n\n  if flags & EXACT:\n    if not expr.startswith('^'):\n      expr = '^' + expr\n    # todo: technically, the last \"$\" *could* be escaped and therefore\n    #       an extra \"$\" would need to be added... but that is very unlikely.\n    if not expr.endswith('$'):\n      expr += '$'\n\n  expr = re.compile(expr, flags=flags & ~ EXACT)\n\n  if prefix is not None:\n    return (prefix, expr)\n  return expr", "response": "Converts a glob - matching pattern into a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_value(type: str, val: str):\n    if type.upper() in PARSER_MAP:\n        #prep_val = prepare_value(val)\n        out = PARSER_MAP[type](val)\n        log.debug('For {} entered {}, got {} out'.format(type, val, out))\n        return out\n    else:\n        raise ObdPidParserUnknownError(type, val)", "response": "Parses a given OBD value of a given type and returns the parsed value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a dictionary with the key being the OBD PID and the value being the OBD VAT returns value by the OBD interface", "response": "def parse_obj(o):\n    \"\"\"\n    Parses a given dictionary with the key being the OBD PID and the value its\n    returned value by the OBD interface\n    :param dict o:\n    :return:\n    \"\"\"\n    r = {}\n    for k, v in o.items():\n        if is_unable_to_connect(v):\n            r[k] = None\n\n        try:\n            r[k] = parse_value(k, v)\n        except (ObdPidParserUnknownError, AttributeError, TypeError):\n            r[k] = None\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_0101(v):\n    tv = trim_obd_value(v)\n    mil_status = None  # type: bool\n    num_dtc = None  # type: int\n\n    try:\n        byte_a = int(v[:2], 16)\n        mil_status = byte_a / 0xF >= 1\n        num_dtc = mil_status % 0xF\n    except ValueError:\n        mil_status = None\n        num_dtc = None\n\n    return mil_status, num_dtc", "response": "Parses the DTC status and returns two elements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the status of the fuel system in the format of 1. 0103.", "response": "def parse_0103(v):\n    \"\"\"\n    Parses the fuel system status and returns an array with two elements (one for\n    each fuel system).\n    The returned values are converted to decimal integers and returned as is.\n    The fuel system values are described here:\n    https://en.wikipedia.org/wiki/OBD-II_PIDs#Mode_1_PID_03\n\n    1  Open loop due to insufficient engine temperature\n\n    2  Closed loop, using oxygen sensor feedback to determine fuel mix\n\n    4  Open loop due to engine load OR fuel cut due to deceleration\n\n    8  Open loop due to system failure\n\n    16 Closed loop, using at least one oxygen sensor but there is a fault in the feedback system\n\n    :param str v: e.g. \"41030100\"\n    :return int, int:\n    \"\"\"\n    tv = trim_obd_value(v)  # trimmed value\n    status_1, status_2 = None, None\n    try:\n        status_1 = int(v[:2], 16)\n    except ValueError:\n        status_1 = None\n\n    try:\n        status_2 = int(v[2:4], 16)\n    except ValueError:\n        status_2 = None\n\n    return status_1, status_2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_010c(v) -> int:\n    try:\n        val = int(trim_obd_value(v), 16)\n        return int(val / 4)\n    except ValueError:\n        return None", "response": "Parses Engine RPM and returns it in [ RPM ] as a float from 0 - 16383. 75"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the O2 Sensor Value 0134 - 013B and returns two values parsed from it", "response": "def parse_0134_013b(v):\n    \"\"\"\n    Parses the O2 Sensor Value (0134 - 013B) and returns two values parsed from it:\n    1. Fuel-Air Equivalence [Ratio] as a float from 0 - 2\n    2. Current in [mA] as a float from -128 - 128\n    :param str v:\n    :return tuple of float, float:\n    \"\"\"\n    try:\n        trim_val = trim_obd_value(v)\n        val_ab = int(trim_val[0:2], 16)\n        val_cd = int(trim_val[2:4], 16)\n        return (2 / 65536) * val_ab, val_cd - 128\n    except ValueError:\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(debug=False):\n    FLAGS(sys.argv)\n    config = gameConfig.Config(\n        version=None, # vers is None... unless a specific game version is desired\n        themap=selectMap(ladder=True), # pick a random ladder map\n        players=[\"defaulthuman\", \"blizzbot2_easy\"],\n    )\n    createReq = sc_pb.RequestCreateGame( # used to advance to \"Init Game\" state, when hosting\n        realtime    = config.realtime,\n        disable_fog = config.fogDisabled,\n        random_seed = int(now()), # a game is created using the current second timestamp as the seed\n        local_map   = sc_pb.LocalMap(map_path=config.mapLocalPath,\n                                     map_data=config.mapData) )\n    joinRace = None\n    for player in config.players:\n        reqPlayer = createReq.player_setup.add() # add new player; get link to settings\n        playerObj = PlayerPreGame(player)\n        if playerObj.isComputer:\n              reqPlayer.difficulty  = playerObj.difficulty.gameValue()\n              pType                 = playerObj.type.type\n        else: pType                 = c.PARTICIPANT\n        reqPlayer.type              = t.PlayerControls(pType).gameValue()\n        reqPlayer.race              = playerObj.selectedRace.gameValue()\n        if not playerObj.isComputer:\n            joinRace                = reqPlayer.race\n    interface = sc_pb.InterfaceOptions()\n    raw,score,feature,rendered = config.interfaces\n    interface.raw   = raw   # whether raw data is reported in observations\n    interface.score = score # whether score data is reported in observations\n    interface.feature_layer.width = 24\n    joinReq = sc_pb.RequestJoinGame(options=interface) # SC2APIProtocol.RequestJoinGame\n    joinReq.race = joinRace # update joinGame request as necessary\n    if debug: print(\"Starcraft2 game process is launching.\")\n    controller = None\n    with config.launchApp() as controller:\n      try:\n        if debug: print(\"Starcraft2 application is live. (%s)\"%(controller.status)) # status: launched\n        controller.create_game(createReq)\n        if debug: print(\"Starcraft2 is waiting for %d player(s) to join. (%s)\"%(config.numAgents, controller.status)) # status: init_game\n        playerID = controller.join_game(joinReq).player_id # SC2APIProtocol.RequestJoinGame\n        print(\"[GET IN-GAME DATA] player#%d %s\"%(playerID, config))\n        return (controller.ping(), controller.data())\n      except (protocol.ConnectionError, protocol.ProtocolError, remote_controller.RequestError) as e:\n        if debug:   print(\"%s Connection to game closed (NOT a bug)%s%s\"%(type(e), os.linesep, e))\n        else:       print(   \"Connection to game closed.\")\n      except KeyboardInterrupt:\n        print(\"caught command to forcibly shutdown Starcraft2 host server.\")\n      finally:\n        config.disable() # if the saved cfg file still exists, always remove it\n        controller.quit()", "response": "START a starcraft2 game process"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_project_templates(path):\n    \" Get list of installed templates. \"\n\n    try:\n        return open(op.join(path, TPLNAME)).read().strip().split(',')\n    except IOError:\n        raise MakesiteException(\"Invalid makesite-project: %s\" % path)", "response": "Get list of installed templates."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_base_modules():\n    \" Get list of installed modules. \"\n\n    return sorted(filter(\n                  lambda x: op.isdir(op.join(MOD_DIR, x)),\n                  listdir(MOD_DIR)))", "response": "Get list of installed modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets list of installed templates.", "response": "def get_base_templates():\n    \" Get list of installed templates. \"\n\n    return sorted(filter(\n                  lambda x: op.isdir(op.join(TPL_DIR, x)),\n                  listdir(TPL_DIR)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck program is exists.", "response": "def which(program):\n    \" Check program is exists. \"\n\n    head, _ = op.split(program)\n\n    if head:\n        if is_exe(program):\n            return program\n    else:\n        for path in environ[\"PATH\"].split(pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates relative template pathes.", "response": "def gen_template_files(path):\n    \" Generate relative template pathes. \"\n\n    path = path.rstrip(op.sep)\n    for root, _, files in walk(path):\n        for f in filter(lambda x: not x in (TPLNAME, CFGNAME), files):\n            yield op.relpath(op.join(root, f), path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_config( config_path=CONFIG_PATH ):\n   \n    parser = SafeConfigParser()\n    parser.read( config_path )\n\n    config_dir = os.path.dirname(config_path)\n\n    immutable_key = False\n    key_id = None\n    blockchain_id = None\n    hostname = socket.gethostname()\n    wallet = None\n \n    if parser.has_section('blockstack-file'):\n\n        if parser.has_option('blockstack-file', 'immutable_key'):\n            immutable_key = parser.get('blockstack-file', 'immutable_key')\n            if immutable_key.lower() in ['1', 'yes', 'true']:\n                immutable_key = True\n            else:\n                immutable_key = False\n\n        if parser.has_option('blockstack-file', 'file_id'):\n            key_id = parser.get('blockstack-file', 'key_id' )\n\n        if parser.has_option('blockstack-file', 'blockchain_id'):\n            blockchain_id = parser.get('blockstack-file', 'blockchain_id')\n\n        if parser.has_option('blockstack-file', 'hostname'):\n            hostname = parser.get('blockstack-file', 'hostname')\n\n        if parser.has_option('blockstack-file', 'wallet'):\n            wallet = parser.get('blockstack-file', 'wallet')\n        \n    config = {\n        'immutable_key': immutable_key,\n        'key_id': key_id,\n        'blockchain_id': blockchain_id,\n        'hostname': hostname,\n        'wallet': wallet\n    }\n\n    return config", "response": "Get the config from the config file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_key_lookup( blockchain_id, index, hostname, key_id=None, config_path=CONFIG_PATH, wallet_keys=None ):\n\n    log.debug(\"lookup '%s' key for %s (index %s, key_id = %s)\" % (hostname, blockchain_id, index, key_id))\n    conf = get_config( config_path )\n    config_dir = os.path.dirname(config_path)\n    \n    proxy = blockstack_client.get_default_proxy( config_path=config_path )\n    immutable = conf['immutable_key']\n\n    if key_id is not None:\n        # we know exactly which key to get \n        # try each current key \n        hosts_listing = file_list_hosts( blockchain_id, wallet_keys=wallet_keys, config_path=config_path )\n        if 'error' in hosts_listing:\n            log.error(\"Failed to list hosts for %s: %s\" % (blockchain_id, hosts_listing['error']))\n            return {'error': 'Failed to look up hosts'}\n\n        hosts = hosts_listing['hosts']\n        for hostname in hosts:\n            file_key = blockstack_gpg.gpg_app_get_key( blockchain_id, APP_NAME, hostname, immutable=immutable, key_id=key_id, config_dir=config_dir )\n            if 'error' not in file_key:\n                if key_id == file_key['key_id']:\n                    # success!\n                    return file_key\n\n        # check previous keys...\n        url = file_url_expired_keys( blockchain_id )\n        old_key_bundle_res = blockstack_client.data_get( url, wallet_keys=wallet_keys, proxy=proxy )\n        if 'error' in old_key_bundle_res:\n            return old_key_bundle_res\n\n        old_key_list = old_key_bundle_res['data']['old_keys']\n        for i in xrange(0, len(old_key_list)):\n            old_key = old_key_list[i]\n            if old_key['key_id'] == key_id:\n                # success!\n                ret = {}\n                ret.update( old_key )\n                ret['stale_key_index'] = i+1 \n                return old_key\n\n        return {'error': 'No such key %s' % key_id}\n\n    elif index == 0:\n        file_key = blockstack_gpg.gpg_app_get_key( blockchain_id, APP_NAME, hostname, immutable=immutable, key_id=key_id, config_dir=config_dir )\n        if 'error' in file_key:\n            return file_key\n\n        return file_key\n    \n    else:\n        # get the bundle of revoked keys\n        url = file_url_expired_keys( blockchain_id )\n        old_key_bundle_res = blockstack_client.data_get( url, wallet_keys=wallet_keys, proxy=proxy )\n        if 'error' in old_key_bundle_res:\n            return old_key_bundle_res\n\n        old_key_list = old_key_bundle_res['data']['old_keys']\n        if index >= len(old_key_list)+1:\n            return {'error': 'Index out of bounds: %s' % index}\n\n        return old_key_list[index-1]", "response": "Get the file - encryption GPG key for the given blockchain ID by index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_key_retire( blockchain_id, file_key, config_path=CONFIG_PATH, wallet_keys=None ):\n\n    config_dir = os.path.dirname(config_path)\n    url = file_url_expired_keys( blockchain_id )\n    proxy = blockstack_client.get_default_proxy( config_path=config_path )\n        \n    old_key_bundle_res = blockstack_client.data_get( url, wallet_keys=wallet_keys, proxy=proxy )\n    if 'error' in old_key_bundle_res:\n        log.warn('Failed to get old key bundle: %s' % old_key_bundle_res['error'])\n        old_key_list = []\n\n    else:\n        old_key_list = old_key_bundle_res['data']['old_keys']\n        for old_key in old_key_list:\n            if old_key['key_id'] == file_key['key_id']:\n                # already present \n                log.warning(\"Key %s is already retired\" % file_key['key_id'])\n                return {'status': True}\n\n    old_key_list.insert(0, file_key )\n\n    res = blockstack_client.data_put( url, {'old_keys': old_key_list}, wallet_keys=wallet_keys, proxy=proxy )\n    if 'error' in res:\n        log.error(\"Failed to append to expired key bundle: %s\" % res['error'])\n        return {'error': 'Failed to append to expired key list'}\n\n    return {'status': True}", "response": "Retire the given file key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a new encryption key.", "response": "def file_key_regenerate( blockchain_id, hostname, config_path=CONFIG_PATH, wallet_keys=None ):\n    \"\"\"\n    Generate a new encryption key.\n    Retire the existing key, if it exists.\n    Return {'status': True} on success\n    Return {'error': ...} on error\n    \"\"\"\n    \n    config_dir = os.path.dirname(config_path)\n    current_key = file_key_lookup( blockchain_id, 0, hostname, config_path=config_path )\n    if 'status' in current_key and current_key['status']:\n        # retire\n        # NOTE: implicitly depends on this method failing only because the key doesn't exist\n        res = file_key_retire( blockchain_id, current_key, config_path=config_path, wallet_keys=wallet_keys )\n        if 'error' in res:\n            log.error(\"Failed to retire key %s: %s\" % (current_key['key_id'], res['error']))\n            return {'error': 'Failed to retire key'}\n\n    # make a new key \n    res = blockstack_gpg.gpg_app_create_key( blockchain_id, \"files\", hostname, wallet_keys=wallet_keys, config_dir=config_dir )\n    if 'error' in res:\n        log.error(\"Failed to generate new key: %s\" % res['error'])\n        return {'error': 'Failed to generate new key'}\n\n    return {'status': True}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencrypt a file for a set of recipients.", "response": "def file_encrypt( blockchain_id, hostname, recipient_blockchain_id_and_hosts, input_path, output_path, passphrase=None, config_path=CONFIG_PATH, wallet_keys=None ):\n    \"\"\"\n    Encrypt a file for a set of recipients.\n    @recipient_blockchain_id_and_hosts must contain a list of (blockchain_id, hostname)\n    Return {'status': True, 'sender_key_id': ...} on success, and write ciphertext to output_path\n    Return {'error': ...} on error\n    \"\"\"\n    config_dir = os.path.dirname(config_path)\n\n    # find our encryption key\n    key_info = file_key_lookup( blockchain_id, 0, hostname, config_path=config_path, wallet_keys=wallet_keys )\n    if 'error' in key_info:\n        return {'error': 'Failed to lookup encryption key'}\n\n    # find the encryption key IDs for the recipients \n    recipient_keys = []\n    for (recipient_id, recipient_hostname) in recipient_blockchain_id_and_hosts:\n        if recipient_id == blockchain_id and recipient_hostname == hostname:\n            # already have it \n            recipient_keys.append(key_info)\n            continue\n\n        recipient_info = file_key_lookup( recipient_id, 0, recipient_hostname, config_path=config_path, wallet_keys=wallet_keys )\n        if 'error' in recipient_info:\n            return {'error': \"Failed to look up key for '%s'\" % recipient_id}\n\n        recipient_keys.append(recipient_info)\n\n    # encrypt\n    res = None\n    with open(input_path, \"r\") as f:\n        res = blockstack_gpg.gpg_encrypt( f, output_path, key_info, recipient_keys, passphrase=passphrase, config_dir=config_dir )\n        \n    if 'error' in res:\n        log.error(\"Failed to encrypt: %s\" % res['error'])\n        return {'error': 'Failed to encrypt'}\n\n    return {'status': True, 'sender_key_id': key_info['key_id']}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to decrypt data with one of the receiver's keys Return {'status': True} if we succeeded Return {'error': ..., 'status': False} if we failed permanently Return {'error': ..., 'status': True} if the key failed, and we should try the next one.", "response": "def file_decrypt_from_key_info( sender_key_info, blockchain_id, key_index, hostname, input_path, output_path, passphrase=None, config_path=CONFIG_PATH, wallet_keys=None ):\n    \"\"\"\n    Try to decrypt data with one of the receiver's keys\n    Return {'status': True} if we succeeded\n    Return {'error': ..., 'status': False} if we failed permanently\n    Return {'error': ..., 'status': True} if the key failed, and we should try the next one.\n    \"\"\"\n    config_dir = os.path.dirname(config_path)\n\n    # find remote sender\n    my_key_info = file_key_lookup( blockchain_id, key_index, hostname, config_path=config_path, wallet_keys=wallet_keys )\n    if 'error' in my_key_info:\n        log.error(\"Failed to look up key: %s\" % my_key_info['error'])\n        return {'status': True, 'error': 'Failed to lookup sender key'}\n\n    # decrypt\n    res = None \n    with open(input_path, \"r\") as f:\n        res = blockstack_gpg.gpg_decrypt( f, output_path, sender_key_info, my_key_info, passphrase=passphrase, config_dir=config_dir )\n\n    if 'error' in res:\n        if res['error'] == 'Failed to decrypt data':\n            log.warn(\"Key %s failed to decrypt\" % my_key_info['key_id'])\n            return {'status': True, 'error': 'Failed to decrypt with key'}\n\n        else:\n            log.error(\"Failed to decrypt: %s\" % res['error'])\n            return {'status': False, 'error': 'GPG error (%s)' % res['error']}\n\n    return {'status': True}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef file_decrypt( blockchain_id, hostname, sender_blockchain_id, sender_key_id, input_path, output_path, passphrase=None, config_path=CONFIG_PATH, wallet_keys=None ):\n    config_dir = os.path.dirname(config_path)\n    decrypted = False\n    old_key = False\n    old_key_index = 0\n    sender_old_key_index = 0\n\n    # get the sender key \n    sender_key_info = file_key_lookup( sender_blockchain_id, None, None, key_id=sender_key_id, config_path=config_path, wallet_keys=wallet_keys ) \n    if 'error' in sender_key_info:\n        log.error(\"Failed to look up sender key: %s\" % sender_key_info['error'])\n        return {'error': 'Failed to lookup sender key'}\n\n    if 'stale_key_index' in sender_key_info.keys():\n        old_key = True\n        sender_old_key_index = sender_key_info['sender_key_index']\n\n    # try each of our keys\n    # current key...\n    key_info = file_key_lookup( blockchain_id, 0, hostname, config_path=config_path, wallet_keys=wallet_keys )\n    if 'error' not in key_info:\n        res = file_decrypt_from_key_info( sender_key_info, blockchain_id, 0, hostname, input_path, output_path, passphrase=passphrase, config_path=config_path, wallet_keys=wallet_keys )\n        if 'error' in res:\n            if not res['status']:\n                # permanent failure \n                log.error(\"Failed to decrypt: %s\" % res['error'])\n                return {'error': 'Failed to decrypt'}\n\n        else:\n            decrypted = True\n\n    else:\n        # did not look up key \n        log.error(\"Failed to lookup key: %s\" % key_info['error'])\n\n    if not decrypted:\n        # try old keys \n        for i in xrange(1, MAX_EXPIRED_KEYS):\n            res = file_decrypt_from_key_info( sender_key_info, blockchain_id, i, hostname, input_path, output_path, passphrase=passphrase, config_path=config_path, wallet_keys=wallet_keys )\n            if 'error' in res:\n                # key is not online, but don't try again \n                log.error(\"Failed to decrypt: %s\" % res['error'])\n                return {'error': 'Failed to decrypt'}\n            else:\n                decrypted = True\n                old_key = True\n                old_key_index = i\n                break\n\n    if decrypted:\n        log.debug(\"Decrypted with %s.%s\" % (blockchain_id, hostname))\n\n        ret = {'status': True}\n        if old_key:\n            ret['warning'] = \"Used stale key\"\n            ret['stale_key_index'] = old_key_index\n            ret['stale_sender_key_index'] = sender_old_key_index\n\n        return ret\n\n    else:\n        return {'error': 'No keys could decrypt'}", "response": "Decrypt a file from a sender s blockchain ID and a key ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsigns a file with the current blockchain ID s host s public key.", "response": "def file_sign( blockchain_id, hostname, input_path, passphrase=None, config_path=CONFIG_PATH, wallet_keys=None ):\n    \"\"\"\n    Sign a file with the current blockchain ID's host's public key.\n    @config_path should be for the *client*, not blockstack-file\n    Return {'status': True, 'sender_key_id': ..., 'sig': ...} on success, and write ciphertext to output_path\n    Return {'error': ...} on error\n    \"\"\"\n    config_dir = os.path.dirname(config_path)\n\n    # find our encryption key\n    key_info = file_key_lookup( blockchain_id, 0, hostname, config_path=config_path, wallet_keys=wallet_keys )\n    if 'error' in key_info:\n        return {'error': 'Failed to lookup encryption key'}\n\n    # sign\n    res = blockstack_gpg.gpg_sign( input_path, key_info, config_dir=config_dir )\n    if 'error' in res:\n        log.error(\"Failed to encrypt: %s\" % res['error'])\n        return {'error': 'Failed to encrypt'}\n\n    return {'status': True, 'sender_key_id': key_info['key_id'], 'sig': res['sig']}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef file_verify( sender_blockchain_id, sender_key_id, input_path, sig, config_path=CONFIG_PATH, wallet_keys=None ):\n    config_dir = os.path.dirname(config_path)\n    old_key = False\n    old_key_index = 0\n    sender_old_key_index = 0\n\n    # get the sender key \n    sender_key_info = file_key_lookup( sender_blockchain_id, None, None, key_id=sender_key_id, config_path=config_path, wallet_keys=wallet_keys ) \n    if 'error' in sender_key_info:\n        log.error(\"Failed to look up sender key: %s\" % sender_key_info['error'])\n        return {'error': 'Failed to lookup sender key'}\n\n    if 'stale_key_index' in sender_key_info.keys():\n        old_key = True\n        sender_old_key_index = sender_key_info['sender_key_index']\n\n    # attempt to verify \n    res = blockstack_gpg.gpg_verify( input_path, sig, sender_key_info, config_dir=config_dir )\n    if 'error' in res:\n        log.error(\"Failed to verify from %s.%s\" % (sender_blockchain_id, sender_key_id))\n        return {'error': 'Failed to verify'}\n\n    return {'status': True}", "response": "Verify that a file was signed with the given blockchain ID"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef file_list_hosts( blockchain_id, wallet_keys=None, config_path=CONFIG_PATH ):\n    config_dir = os.path.dirname(config_path)\n    try:\n        ret = blockstack_gpg.gpg_list_app_keys( blockchain_id, APP_NAME, wallet_keys=wallet_keys, config_dir=config_dir )\n    except Exception, e:\n        ret = {'error': traceback.format_exc(e)}\n\n    if 'error' in ret:\n        log.error(\"Failed to list app keys: %s\" % ret['error'])\n        return {'error': 'Failed to list app keys'}\n\n    hosts = []\n    for key_info in ret:\n        hostname = key_info['keyName']\n        hosts.append(hostname)\n\n    return {'status': True, 'hosts': hosts}", "response": "Given a blockchain ID find out the hosts that the blockchain ID owner has registered keys for."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_put( blockchain_id, hostname, recipient_blockchain_ids, data_name, input_path, passphrase=None, config_path=CONFIG_PATH, wallet_keys=None ):\n    fd, output_path = tempfile.mkstemp( prefix=\"blockstack-file-\" )\n    os.fchmod( fd, 0600 )\n    os.close(fd)\n\n    config_dir = os.path.dirname(config_path)\n    client_config_path = os.path.join(config_dir, blockstack_client.CONFIG_FILENAME )\n\n    all_recipients = []\n    \n    # make available to all other hosts for this blockchain_id\n    my_hosts = file_list_hosts( blockchain_id, wallet_keys=wallet_keys, config_path=config_path )\n    if 'error' in my_hosts:\n        log.error(\"Failed to list hosts: %s\" % my_hosts['error'])\n        os.unlink(output_path)\n        return {'error': 'Failed to look up sender keys'}\n\n    if hostname in my_hosts:\n        my_hosts.remove(hostname)\n\n    all_recipients += [(blockchain_id, host) for host in my_hosts['hosts']]\n\n    # make available to all hosts for each recipient \n    for recipient_blockchain_id in recipient_blockchain_ids:\n        their_hosts = file_list_hosts( recipient_blockchain_id, wallet_keys=wallet_keys, config_path=config_path )\n        if 'error' in their_hosts:\n            log.error(\"Failed to list hosts for %s: %s\" % (recipient_blockchain_id, their_hosts['error']))\n            os.unlink(output_path)\n            return {'error': 'Failed to look up recipient keys'}\n\n        all_recipients += [(recipient_blockchain_id, host) for host in their_hosts['hosts']]\n\n    # encrypt\n    res = file_encrypt( blockchain_id, hostname, all_recipients, input_path, output_path, passphrase=passphrase, config_path=config_path, wallet_keys=wallet_keys )\n    if 'error' in res:\n        log.error(\"Failed to encrypt: %s\" % res['error'])\n        os.unlink(output_path)\n        return {'error': 'Failed to encrypt'}\n\n    # load up \n    with open(output_path, \"r\") as f:\n        ciphertext = f.read()\n\n    message = {'ciphertext': ciphertext, 'sender_key_id': res['sender_key_id']}\n\n    # put to mutable storage \n    fq_data_name = file_fq_data_name( data_name ) \n    proxy = blockstack_client.get_default_proxy( config_path=client_config_path )\n\n    res = blockstack_client.data_put( blockstack_client.make_mutable_data_url( blockchain_id, fq_data_name, None ), message, wallet_keys=wallet_keys, proxy=proxy )\n    if 'error' in res:\n        log.error(\"Failed to put data: %s\" % res['error'])\n        os.unlink(output_path)\n        return {'error': 'Failed to replicate data'}\n\n    os.unlink(output_path)\n    return {'status': True}", "response": "Upload a file to a given recipient"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef file_get( blockchain_id, hostname, sender_blockchain_id, data_name, output_path, passphrase=None, config_path=CONFIG_PATH, wallet_keys=None ):\n  \n    config_dir = os.path.dirname(config_path)\n    client_config_path = os.path.join(config_dir, blockstack_client.CONFIG_FILENAME )\n    proxy = blockstack_client.get_default_proxy( config_path=client_config_path )\n\n    # get the ciphertext\n    fq_data_name = file_fq_data_name( data_name ) \n    res = blockstack_client.data_get( blockstack_client.make_mutable_data_url( sender_blockchain_id, fq_data_name, None ), wallet_keys=wallet_keys, proxy=proxy )\n    if 'error' in res:\n        log.error(\"Failed to get ciphertext for %s: %s\" % (fq_data_name, res['error']))\n        return {'error': 'Failed to get encrypted file'}\n\n    # stash\n    fd, path = tempfile.mkstemp( prefix=\"blockstack-file-\" )\n    f = os.fdopen(fd, \"w\")\n    f.write( res['data']['ciphertext'] )\n    f.flush()\n    os.fsync(f.fileno())\n    f.close()\n\n    sender_key_id = res['data']['sender_key_id']\n\n    # decrypt it\n    res = file_decrypt( blockchain_id, hostname, sender_blockchain_id, sender_key_id, path, output_path, passphrase=passphrase, config_path=config_path, wallet_keys=wallet_keys )\n    os.unlink( path )\n    if 'error' in res:\n        log.error(\"Failed to decrypt: %s\" % res['error'])\n        return {'error': 'Failed to decrypt data'}\n\n    else:\n        # success!\n        return res", "response": "Get a file from a known sender."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete a file in the blockchain", "response": "def file_delete( blockchain_id, data_name, config_path=CONFIG_PATH, wallet_keys=None ):\n    \"\"\"\n    Remove a file\n    Return {'status': True} on success\n    Return {'error': error} on failure\n    \"\"\"\n\n    config_dir = os.path.dirname(config_path)\n    client_config_path = os.path.join(config_dir, blockstack_client.CONFIG_FILENAME )\n    proxy = blockstack_client.get_default_proxy( config_path=client_config_path )\n\n    fq_data_name = file_fq_data_name( data_name ) \n    res = blockstack_client.data_delete( blockstack_client.make_mutable_data_url( blockchain_id, fq_data_name, None ), proxy=proxy, wallet_keys=wallet_keys )\n    if 'error' in res:\n        log.error(\"Failed to delete: %s\" % res['error'])\n        return {'error': 'Failed to delete'}\n\n    return {'status': True}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all files uploaded to a particular blockchain ID", "response": "def file_list( blockchain_id, config_path=CONFIG_PATH, wallet_keys=None ):\n    \"\"\"\n    List all files uploaded to a particular blockchain ID\n    Return {'status': True, 'listing': list} on success\n    Return {'error': ...} on error\n    \"\"\"\n\n    config_dir = os.path.dirname(config_path)\n    client_config_path = os.path.join(config_dir, blockstack_client.CONFIG_FILENAME )\n    proxy = blockstack_client.get_default_proxy( config_path=client_config_path )\n\n    res = blockstack_client.data_list( blockchain_id, wallet_keys=wallet_keys, proxy=proxy )\n    if 'error' in res:\n        log.error(\"Failed to list data: %s\" % res['error'])\n        return {'error': 'Failed to list data'}\n\n    listing = []\n\n    # find the ones that this app put there \n    for rec in res['listing']:\n        if not file_is_fq_data_name( rec['data_id'] ):\n            continue\n        \n        listing.append( rec )\n\n    return {'status': True, 'listing': listing}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n   \n    argparser = argparse.ArgumentParser(\n            description='Blockstack-file version {}'.format(__version__))\n\n    subparsers = argparser.add_subparsers(\n            dest='action', help='The file command to take [get/put/delete]')\n\n    parser = subparsers.add_parser(\n            'init',\n            help='Initialize this host to start sending and receiving files')\n    parser.add_argument(\n            '--config', action='store',\n            help='path to the config file to use (default is %s)' % CONFIG_PATH)\n    parser.add_argument(\n            '--blockchain_id', action='store',\n            help='the recipient blockchain ID to use'),\n    parser.add_argument(\n            '--hostname', action='store',\n            help='the recipient hostname to use')\n\n    parser = subparsers.add_parser(\n            'reset',\n            help='Reset this host\\'s key')\n    parser.add_argument(\n            '--config', action='store',\n            help='path to the config file to use (default is %s)' % CONFIG_PATH)\n    parser.add_argument(\n            '--blockchain_id', action='store',\n            help='the recipient blockchain ID to use'),\n    parser.add_argument(\n            '--hostname', action='store',\n            help='the recipient hostname to use')\n\n    parser = subparsers.add_parser(\n            'get',\n            help='Get a file')\n    parser.add_argument(\n            '--config', action='store',\n            help='path to the config file to use (default is %s)' % CONFIG_PATH)\n    parser.add_argument(\n            '--blockchain_id', action='store',\n            help='the recipient blockchain ID to use'),\n    parser.add_argument(\n            '--hostname', action='store',\n            help='the recipient hostname to use')\n    parser.add_argument(\n            '--passphrase', action='store',\n            help='decryption passphrase')\n    parser.add_argument(\n            '--wallet', action='store',\n            help='path to your Blockstack wallet')\n    parser.add_argument(\n            'sender_blockchain_id', action='store',\n            help='the sender\\'s blockchain ID')\n    parser.add_argument(\n            'data_name', action='store',\n            help='Public name of the file to fetch')\n    parser.add_argument(\n            'output_path', action='store', nargs='?',\n            help='[optional] destination path to save the file; defaults to stdout')\n\n    parser = subparsers.add_parser(\n            'put',\n            help='Share a file')\n    parser.add_argument(\n            '--config', action='store',\n            help='path to the config file to use (default is %s)' % CONFIG_PATH)\n    parser.add_argument(\n            '--blockchain_id', action='store',\n            help='the sender blockchain ID to use'),\n    parser.add_argument(\n            '--hostname', action='store',\n            help='the sender hostname to use')\n    parser.add_argument(\n            '--passphrase', action='store',\n            help='encryption passphrase')\n    parser.add_argument(\n            '--wallet', action='store',\n            help='path to your Blockstack wallet')\n    parser.add_argument(\n            'input_path', action='store',\n            help='Path to the file to share')\n    parser.add_argument(\n            'data_name', action='store',\n            help='Public name of the file to store')\n    # recipients come afterwards\n\n\n    parser = subparsers.add_parser(\n            'delete',\n            help='Delete a shared file')\n    parser.add_argument(\n            '--config', action='store',\n            help='path to the config file to use (default is %s)' % CONFIG_PATH)\n    parser.add_argument(\n            '--blockchain_id', action='store',\n            help='the sender blockchain ID to use'),\n    parser.add_argument(\n            '--hostname', action='store',\n            help='the sender hostname to use')\n    parser.add_argument(\n            '--wallet', action='store',\n            help='path to your Blockstack wallet')\n    parser.add_argument(\n            'data_name', action='store',\n            help='Public name of the file to delete')\n\n    args, unparsed = argparser.parse_known_args()\n\n    # load up config\n    config_path = args.config\n    if config_path is None:\n        config_path = CONFIG_PATH\n\n    conf = get_config( config_path )\n    config_dir = os.path.dirname(config_path)\n    blockchain_id = getattr(args, \"blockchain_id\", None)\n    hostname = getattr(args, \"hostname\", None)\n    passphrase = getattr(args, \"passphrase\", None)\n    data_name = getattr(args, \"data_name\", None)\n    wallet_path = getattr(args, \"wallet\", None)\n\n    if blockchain_id is None:\n        blockchain_id = conf['blockchain_id']\n\n    if hostname is None:\n        hostname = conf['hostname']\n\n    if wallet_path is None:\n        wallet_path = conf['wallet']\n    \n    if wallet_path is None and config_dir is not None:\n        wallet_path = os.path.join(config_dir, blockstack_client.config.WALLET_FILENAME)\n\n    # load wallet \n    if wallet_path is not None and os.path.exists( wallet_path ):\n        # load from disk\n        log.debug(\"Load wallet from %s\" % wallet_path)\n        wallet = blockstack_client.load_wallet( config_dir=config_dir, wallet_path=wallet_path, include_private=True )\n        if 'error' in wallet:\n            print >> sys.stderr, json.dumps(wallet, sort_keys=True, indent=4 )\n            sys.exit(1)\n\n        else:\n            wallet = wallet['wallet']\n\n    else:\n        # load from RPC\n        log.debug(\"Load wallet from RPC\")\n        wallet = blockstack_client.dump_wallet(config_path=config_path)\n        if 'error' in wallet:\n            print >> sys.stderr, json.dumps(wallet, sort_keys=True, indent=4)\n            sys.exit(1)\n\n    log.debug(\"Process %s\" %  args.action)\n    if args.action in ['init', 'reset']:\n        # (re)key\n        res = file_key_regenerate( blockchain_id, hostname, config_path=config_path, wallet_keys=wallet ) \n        if 'error' in res:\n            print >> sys.stderr, json.dumps(res, sort_keys=True, indent=4 )\n            sys.exit(1)\n        \n\n    if args.action == 'get':\n        # get a file\n        sender_blockchain_id = args.sender_blockchain_id\n        output_path = args.output_path\n\n        tmp = False\n        if output_path is None:\n            fd, path = tempfile.mkstemp( prefix='blockstack-file-', dir=config_dir )\n            os.close(fd)\n            output_path = path\n            tmp = True\n\n        res = file_get( blockchain_id, hostname, sender_blockchain_id, data_name, output_path, passphrase=passphrase, config_path=config_path, wallet_keys=wallet )\n        if 'error' in res:\n            print >> sys.stderr, json.dumps(res, sort_keys=True, indent=4 )\n            sys.exit(1)\n\n        if tmp:\n            # print to stdout \n            with open(output_path, \"r\") as f:\n                while True:\n                    buf = f.read(65536)\n                    if len(buf) == 0:\n                        break\n\n                    sys.stdout.write(buf)\n\n            os.unlink(output_path)\n\n    elif args.action == 'put':\n        # put a file\n        recipients = unparsed\n        input_path = args.input_path\n        res = file_put( blockchain_id, hostname, recipients, data_name, input_path, passphrase=passphrase, config_path=config_path, wallet_keys=wallet )\n        if 'error' in res:\n            print >> sys.stderr, json.dumps(res, sort_keys=True, indent=4 )\n            sys.exit(1)\n\n    elif args.action == 'delete':\n        # delete a file\n        res = file_delete( blockchain_id, data_name, config_path=config_path, wallet_keys=wallet )\n        if 'error' in res:\n            print >> sys.stderr, json.dumps(res, sort_keys=True, indent=4 )\n            sys.exit(1)\n\n    \n    print >> sys.stderr, json.dumps({'status': True}, sort_keys=True, indent=4 )\n    sys.exit(0)", "response": "Entry point for the CLI interface\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cancelMatchRequest(cfg):\n    payload = json.dumps([cfg.thePlayer])\n    ladder = cfg.ladder\n    return requests.post(\n        url  = c.URL_BASE%(ladder.ipAddress, ladder.serverPort, \"cancelmatch\"),\n        data = payload,\n        #headers=headers,\n    )", "response": "cancel the match request"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ladderPlayerInfo(cfg, playerName, getMatchHistory=False):\n    payload = json.dumps([playerName, getMatchHistory]) # if playerName == None, info on all players is retrieved\n    ladder = cfg.ladder\n    return requests.post(\n        url  = c.URL_BASE%(ladder.ipAddress, ladder.serverPort, \"playerstats\"),\n        data = payload,\n        #headers=headers,\n    )", "response": "obtain information housed on the ladder about playerName"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending information back to the server about the match s winners and losers", "response": "def reportMatchCompletion(cfg, results, replayData):\n    \"\"\"send information back to the server about the match's winners/losers\"\"\"\n    payload = json.dumps([cfg.flatten(), results, replayData])\n    ladder = cfg.ladder\n    return requests.post(\n        url  = c.URL_BASE%(ladder.ipAddress, ladder.serverPort, \"matchfinished\"),\n        data = payload,\n        #headers=headers,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess the response from the server.", "response": "def process_response(self, request, response):\n        \"\"\"\n        Adds WWW-Authenticate: Basic headers to 401 responses, and rewrites\n        redirects the login page to be 401 responses if it's a non-browser\n        agent.\n        \"\"\"\n        process = False\n\n        # Don't do anything for unsecure requests, unless DEBUG is on\n        if not self.allow_http and not request.is_secure():\n            return response\n\n        if response.status_code == UNAUTHORIZED:\n            pass\n        elif response.status_code == FOUND:\n            location = urllib_parse.urlparse(response['Location'])\n            if location.path != settings.LOGIN_URL:\n                # If it wasn't a redirect to the login page, we don't touch it.\n                return response\n            elif not self.is_agent_a_robot(request):\n                # We don't touch requests made in order to be shown to humans.\n                return response\n\n        realm = getattr(settings, 'BASIC_AUTH_REALM', request.META.get('HTTP_HOST', 'restricted'))\n        \n        if response.status_code == FOUND:\n            response = self.unauthorized_view(request)\n\n        authenticate = response.get('WWW-Authenticate', None)\n        if authenticate:\n            authenticate = 'Basic realm=\"%s\", %s' % (realm, authenticate)\n        else:\n            authenticate = 'Basic realm=\"%s\"' % realm\n        response['WWW-Authenticate'] = authenticate\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint a message to stderr only if the given operation is in the list of verbosity.", "response": "def verbose_print(message, *, operation, verbosity):\n    \"\"\"\n    Prints *message* to stderr only if the given *operation* is in the list\n    *verbosity*. If \"all\" is in *verbosity*, all operations are printed.\n\n    **Parameters**\n\n    message : str\n        The message to print.\n    operation : str\n        The type of operation being performed.\n    verbosity : [str] or None\n        The list of operations to print *message* for. If \"all\" is contained\n        in the list, then all operations are printed. If None, no operation is\n        printed.\n\n    **Returns**\n\n    None\n    \"\"\"\n    if (verbosity is not None) and ((operation in verbosity) or\n                                    (\"all\"     in verbosity)):\n        print(message, file=stderr)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mad(data, axis=None):\n    return median(absolute(data - median(data, axis)), axis)", "response": "Computes the median absolute deviation of data along a given axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef autocorrelation(X, lag=1):\n    differences = X - X.mean()\n    products = differences * concatenate((differences[lag:],\n                                          differences[:lag]))\n\n    return products.sum() / (differences**2).sum()", "response": "Computes the autocorrelation of X with the given lag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsanitizing a string for input to LaTeX.", "response": "def sanitize_latex(string):\n    \"\"\"\n    Sanitize a string for input to LaTeX.\n\n    Replacements taken from `Stack Overflow\n    <http://stackoverflow.com/questions/2627135/how-do-i-sanitize-latex-input>`_\n\n    **Parameters**\n\n    string: str\n\n    **Returns**\n\n    sanitized_string: str\n    \"\"\"\n    sanitized_string = string\n    for old, new in _latex_replacements:\n        sanitized_string = sanitized_string.replace(old, new)\n    return sanitized_string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_renderers(self, request, context=None, template_name=None,\n                      accept_header=None, formats=None, default_format=None, fallback_formats=None,\n                      early=False):\n        \"\"\"\n        Returns a list of renderer functions in the order they should be tried.\n        \n        Tries the format override parameter first, then the Accept header. If\n        neither is present, attempt to fall back to self._default_format. If\n        a fallback format has been specified, we try that last.\n        \n        If early is true, don't test renderers to see whether they can handle\n        a serialization. This is useful if we're trying to find all relevant\n        serializers before we've built a context which they will accept. \n        \"\"\"\n        if formats:\n            renderers, seen_formats = [], set()\n            for format in formats:\n                if format in self.renderers_by_format and format not in seen_formats:\n                    renderers.extend(self.renderers_by_format[format])\n                    seen_formats.add(format)\n        elif accept_header:\n            accepts = MediaType.parse_accept_header(accept_header)\n            renderers = MediaType.resolve(accepts, self.renderers)\n        elif default_format:\n            renderers = self.renderers_by_format[default_format]\n        else:\n            renderers = []\n\n        fallback_formats = fallback_formats if isinstance(fallback_formats, (list, tuple)) else (fallback_formats,)\n        for format in fallback_formats:\n            for renderer in self.renderers_by_format[format]:\n                if renderer not in renderers:\n                    renderers.append(renderer)\n\n        if not early and context is not None and template_name:\n            renderers = [r for r in renderers if r.test(request, context, template_name)]\n\n        return renderers", "response": "Returns a list of renderer functions that can be used to build a new context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_secret_key(token):\n    if not isinstance(token, string_types):\n        raise exceptions.ConfigurationError('Expected string value for token.')\n\n    config.secret_key = token", "response": "Initializes a Authentication and sets it as the default global authentication."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves a payment from its id.", "response": "def retrieve(payment_id):\n        \"\"\"\n        Retrieve a payment from its id.\n\n        :param payment_id: The payment id\n        :type payment_id: string\n\n        :return: The payment resource\n        :rtype: resources.Payment\n        \"\"\"\n        http_client = HttpClient()\n        response, __ = http_client.get(routes.url(routes.PAYMENT_RESOURCE, resource_id=payment_id))\n        return resources.Payment(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef abort(payment):\n        if isinstance(payment, resources.Payment):\n            payment = payment.id\n\n        http_client = HttpClient()\n        response, __ = http_client.patch(routes.url(routes.PAYMENT_RESOURCE, resource_id=payment), {'abort': True})\n        return resources.Payment(**response)", "response": "Abort a payment from its id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(**data):\n        http_client = HttpClient()\n        response, _ = http_client.post(routes.url(routes.PAYMENT_RESOURCE), data)\n        return resources.Payment(**response)", "response": "Create a Payment request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list(per_page=None, page=None):\n        # Comprehension dict are not supported in Python 2.6-. You can use this commented line instead of the current\n        # line when you drop support for Python 2.6.\n        # pagination = {key: value for (key, value) in [('page', page), ('per_page', per_page)] if value}\n        pagination = dict((key, value) for (key, value) in [('page', page), ('per_page', per_page)] if value)\n\n        http_client = HttpClient()\n        response, _ = http_client.get(routes.url(routes.PAYMENT_RESOURCE, pagination=pagination))\n        return resources.APIResourceCollection(resources.Payment, **response)", "response": "List of payments. You have to handle pagination manually."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a refund from a payment and the refund id.", "response": "def retrieve(payment, refund_id):\n        \"\"\"\n        Retrieve a refund from a payment and the refund id.\n\n        :param payment: The payment id or the payment object\n        :type payment: resources.Payment|string\n        :param refund_id: The refund id\n        :type refund_id: string\n\n        :return: The refund resource\n        :rtype: resources.Refund\n        \"\"\"\n        if isinstance(payment, resources.Payment):\n            payment = payment.id\n\n        http_client = HttpClient()\n        response, _ = http_client.get(routes.url(routes.REFUND_RESOURCE, resource_id=refund_id, payment_id=payment))\n        return resources.Refund(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a refund on a payment.", "response": "def create(payment, **data):\n        \"\"\"\n        Create a refund on a payment.\n\n        :param payment: Either the payment object or the payment id you want to refund.\n        :type payment: resources.Payment|string\n        :param data: data required to create the refund\n\n        :return: The refund resource\n        :rtype resources.Refund\n        \"\"\"\n        if isinstance(payment, resources.Payment):\n            payment = payment.id\n\n        http_client = HttpClient()\n        response, _ = http_client.post(routes.url(routes.REFUND_RESOURCE, payment_id=payment), data)\n        return resources.Refund(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist all the refunds for a payment.", "response": "def list(payment):\n        \"\"\"\n        List all the refunds for a payment.\n\n        :param payment: The payment object or the payment id\n        :type payment: resources.Payment|string\n\n        :return: A collection of refunds\n        :rtype resources.APIResourceCollection\n        \"\"\"\n        if isinstance(payment, resources.Payment):\n            payment = payment.id\n\n        http_client = HttpClient()\n        response, _ = http_client.get(routes.url(routes.REFUND_RESOURCE, payment_id=payment))\n        return resources.APIResourceCollection(resources.Refund, **response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves a customer from its id.", "response": "def retrieve(customer_id):\n        \"\"\"\n        Retrieve a customer from its id.\n\n        :param customer_id: The customer id\n        :type customer_id: string\n\n        :return: The customer resource\n        :rtype: resources.Customer\n        \"\"\"\n        http_client = HttpClient()\n        response, __ = http_client.get(routes.url(routes.CUSTOMER_RESOURCE, resource_id=customer_id))\n        return resources.Customer(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(customer):\n        if isinstance(customer, resources.Customer):\n            customer = customer.id\n\n        http_client = HttpClient()\n        http_client.delete(routes.url(routes.CUSTOMER_RESOURCE, resource_id=customer))", "response": "Delete a customer from its id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(customer, **data):\n        if isinstance(customer, resources.Customer):\n            customer = customer.id\n\n        http_client = HttpClient()\n        response, _ = http_client.patch(routes.url(routes.CUSTOMER_RESOURCE, resource_id=customer), data)\n        return resources.Customer(**response)", "response": "Update a customer s internal cache entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a customer. :param data: data required to create the customer :return: The customer resource :rtype resources.Customer", "response": "def create(**data):\n        \"\"\"\n        Create a customer.\n\n        :param data: data required to create the customer\n\n        :return: The customer resource\n        :rtype resources.Customer\n        \"\"\"\n        http_client = HttpClient()\n        response, _ = http_client.post(routes.url(routes.CUSTOMER_RESOURCE), data)\n        return resources.Customer(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef retrieve(customer, card_id):\n        if isinstance(customer, resources.Customer):\n            customer = customer.id\n\n        http_client = HttpClient()\n        response, __ = http_client.get(routes.url(routes.CARD_RESOURCE, resource_id=card_id, customer_id=customer))\n        return resources.Card(**response)", "response": "Retrieve a card from its id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a card from its id.", "response": "def delete(customer, card):\n        \"\"\"\n        Delete a card from its id.\n\n        :param customer: The customer id or object\n        :type customer: string|Customer\n        :param card: The card id or object\n        :type card: string|Card\n        \"\"\"\n        if isinstance(customer, resources.Customer):\n            customer = customer.id\n        if isinstance(card, resources.Card):\n            card = card.id\n\n        http_client = HttpClient()\n        http_client.delete(routes.url(routes.CARD_RESOURCE, resource_id=card, customer_id=customer))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(customer, **data):\n        if isinstance(customer, resources.Customer):\n            customer = customer.id\n\n        http_client = HttpClient()\n        response, _ = http_client.post(routes.url(routes.CARD_RESOURCE, customer_id=customer), data)\n        return resources.Card(**response)", "response": "Create a card instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist of cards. You can use pagination manually for the moment.", "response": "def list(customer, per_page=None, page=None):\n        \"\"\"\n        List of cards. You have to handle pagination manually for the moment.\n\n        :param customer: the customer id or object\n        :type customer: string|Customer\n        :param page: the page number\n        :type page: int|None\n        :param per_page: number of customers per page. It's a good practice to increase this number if you know that you\n        will need a lot of payments.\n        :type per_page: int|None\n\n        :return A collection of cards\n        :rtype resources.APIResourceCollection\n        \"\"\"\n        if isinstance(customer, resources.Customer):\n            customer = customer.id\n\n        # Comprehension dict are not supported in Python 2.6-. You can use this commented line instead of the current\n        # line when you drop support for Python 2.6.\n        # pagination = {key: value for (key, value) in [('page', page), ('per_page', per_page)] if value}\n        pagination = dict((key, value) for (key, value) in [('page', page), ('per_page', per_page)] if value)\n\n        http_client = HttpClient()\n        response, _ = http_client.get(routes.url(routes.CARD_RESOURCE, customer_id=customer, pagination=pagination))\n        return resources.APIResourceCollection(resources.Card, **response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the value using the specified date format.", "response": "def strptime(self, value, format):\n        \"\"\"\n        By default, parse datetime with TZ.\n        If TZ is False, convert datetime to local time and disable TZ\n        \"\"\"\n\n        value = force_str(value)\n        if format == ISO_8601:\n            try:\n                parsed = parse_datetime(value)\n                if not settings.USE_TZ:\n                        fr_tz = pytz.timezone(settings.TIME_ZONE)\n                        parsed = parsed.astimezone(fr_tz).replace(tzinfo=None)\n            except:\n                raise APIException(\n                    \"date parsing error: since parameter use the date format ISO 8601 (ex: 2014-11-18T15:56:58Z)\")\n\n            if parsed is None:\n                raise APIException(\n                    \"since parameter use the date format ISO 8601 (ex: 2014-11-18T15:56:58Z)\")\n            return parsed\n        return super(IsoDateTimeField, self).strptime(value, format)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlocate the specified data - files and returns the matches in a data_files compatible format.", "response": "def find_data_files(source, target, patterns):\n    \"\"\"\n    Locates the specified data-files and returns the matches\n    in a data_files compatible format.\n\n    source is the root of the source data tree.\n        Use '' or '.' for current directory.\n    target is the root of the target data tree.\n        Use '' or '.' for the distribution directory.\n    patterns is a sequence of glob-patterns for the\n        files you want to copy.\n    \"\"\"\n    if glob.has_magic(source) or glob.has_magic(target):\n        raise ValueError(\"Magic not allowed in src, target\")\n    ret = {}\n    for pattern in patterns:\n        pattern = os.path.join(source, pattern)\n        for filename in glob.glob(pattern):\n            if os.path.isfile(filename):\n                targetpath = os.path.join(\n                    target, os.path.relpath(filename, source)\n                )\n                path = os.path.dirname(targetpath)\n                ret.setdefault(path, []).append(filename)\n    return sorted(ret.items())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nquery or return the Graph API representation of this resource.", "response": "def cache(self):\n        \"\"\"Query or return the Graph API representation of this resource.\"\"\"\n        if not self._cache:\n            self._cache = self.graph.get('%s' % self.id)\n\n        return self._cache"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse response bounding box from the CapakeyRestGateway to ( MinimumX MaximumY MaximumX MaximumY )", "response": "def _parse_bounding_box(bounding_box):\n        '''\n        Parse response bounding box from the CapakeyRestGateway to (MinimumX, MinimumY, MaximumX, MaximumY)\n        \n        :param bounding_box: response bounding box from the CapakeyRestGateway\n        :return: (MinimumX, MinimumY, MaximumX, MaximumY)\n        '''\n        coordinates = json.loads(bounding_box)[\"coordinates\"]\n        x_coords = [x for x, y in coordinates[0]]\n        y_coords = [y for x, y in coordinates[0]]\n        return min(x_coords), min(y_coords), max(x_coords), max(y_coords)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting all gemeenten in Vlaanderen.", "response": "def list_gemeenten(self, sort=1):\n        '''\n        List all `gemeenten` in Vlaanderen.\n\n        :param integer sort: What field to sort on.\n        :rtype: A :class:`list` of :class:`Gemeente`.\n        '''\n\n        def creator():\n            url = self.base_url + '/municipality'\n            h = self.base_headers\n            p = {\n                'orderbyCode': sort == 1\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return [\n                Gemeente(r['municipalityCode'], r['municipalityName'])\n                for r in res['municipalities']\n            ]\n\n        if self.caches['permanent'].is_configured:\n            key = 'list_gemeenten_rest#%s' % sort\n            gemeente = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            gemeente = creator()\n        for g in gemeente:\n            g.set_gateway(self)\n        return gemeente"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving a gemeente by id.", "response": "def get_gemeente_by_id(self, id):\n        '''\n        Retrieve a `gemeente` by id (the NIScode).\n\n        :rtype: :class:`Gemeente`\n        '''\n\n        def creator():\n            url = self.base_url + '/municipality/%s' % id\n            h = self.base_headers\n            p = {\n                'geometry': 'full',\n                'srs': '31370'\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return Gemeente(\n                res['municipalityCode'],\n                res['municipalityName'],\n                self._parse_centroid(res['geometry']['center']),\n                self._parse_bounding_box(res['geometry']['boundingBox']),\n                res['geometry']['shape']\n            )\n\n        if self.caches['long'].is_configured:\n            key = 'get_gemeente_by_id_rest#%s' % id\n            gemeente = self.caches['long'].get_or_create(key, creator)\n        else:\n            gemeente = creator()\n        gemeente.set_gateway(self)\n        return gemeente"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting all kadastrale afdelingen in Flanders.", "response": "def list_kadastrale_afdelingen(self):\n        '''\n        List all `kadastrale afdelingen` in Flanders.\n\n        :param integer sort: Field to sort on.\n        :rtype: A :class:`list` of :class:`Afdeling`.\n        '''\n\n        def creator():\n            gemeentes = self.list_gemeenten()\n            res = []\n            for g in gemeentes:\n                res += self.list_kadastrale_afdelingen_by_gemeente(g)\n            return res\n\n        if self.caches['permanent'].is_configured:\n            key = 'list_afdelingen_rest'\n            afdelingen = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            afdelingen = creator()\n        return afdelingen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist all kadastrale afdelingen in a gemeente.", "response": "def list_kadastrale_afdelingen_by_gemeente(self, gemeente, sort=1):\n        '''\n        List all `kadastrale afdelingen` in a `gemeente`.\n\n        :param gemeente: The :class:`Gemeente` for which the \\\n            `afdelingen` are wanted.\n        :param integer sort: Field to sort on.\n        :rtype: A :class:`list` of :class:`Afdeling`.\n        '''\n        try:\n            gid = gemeente.id\n        except AttributeError:\n            gid = gemeente\n            gemeente = self.get_gemeente_by_id(gid)\n        gemeente.clear_gateway()\n\n        def creator():\n            url = self.base_url + '/municipality/%s/department' % gid\n            h = self.base_headers\n            p = {\n                'orderbyCode': sort == 1\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return [\n                Afdeling(\n                    id=r['departmentCode'],\n                    naam=r['departmentName'],\n                    gemeente=gemeente\n                ) for r in res['departments']]\n\n        if self.caches['permanent'].is_configured:\n            key = 'list_kadastrale_afdelingen_by_gemeente_rest#%s#%s' % (gid, sort)\n            afdelingen = self.caches['permanent'].get_or_create(key, creator)\n        else:\n            afdelingen = creator()\n        for a in afdelingen:\n            a.set_gateway(self)\n        return afdelingen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a kadastrale afdeling by id.", "response": "def get_kadastrale_afdeling_by_id(self, aid):\n        '''\n        Retrieve a 'kadastrale afdeling' by id.\n\n        :param aid: An id of a `kadastrale afdeling`.\n        :rtype: A :class:`Afdeling`.\n        '''\n\n        def creator():\n            url = self.base_url + '/department/%s' % (aid)\n            h = self.base_headers\n            p = {\n                'geometry': 'full',\n                'srs': '31370'\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return Afdeling(\n                id=res['departmentCode'],\n                naam=res['departmentName'],\n                gemeente=Gemeente(res['municipalityCode'], res['municipalityName']),\n                centroid=self._parse_centroid(res['geometry']['center']),\n                bounding_box=self._parse_bounding_box(res['geometry']['boundingBox']),\n                shape=res['geometry']['shape']\n            )\n\n        if self.caches['long'].is_configured:\n            key = 'get_kadastrale_afdeling_by_id_rest#%s' % aid\n            afdeling = self.caches['long'].get_or_create(key, creator)\n        else:\n            afdeling = creator()\n        afdeling.set_gateway(self)\n        return afdeling"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all secties in a kadastrale afdeling.", "response": "def list_secties_by_afdeling(self, afdeling):\n        '''\n        List all `secties` in a `kadastrale afdeling`.\n\n        :param afdeling: The :class:`Afdeling` for which the `secties` are \\\n            wanted. Can also be the id of and `afdeling`.\n        :rtype: A :class:`list` of `Sectie`.\n        '''\n        try:\n            aid = afdeling.id\n            gid = afdeling.gemeente.id\n        except AttributeError:\n            aid = afdeling\n            afdeling = self.get_kadastrale_afdeling_by_id(aid)\n            gid = afdeling.gemeente.id\n        afdeling.clear_gateway()\n\n        def creator():\n            url = self.base_url + '/municipality/%s/department/%s/section' % (gid, aid)\n            h = self.base_headers\n            res = capakey_rest_gateway_request(url, h).json()\n            return [\n                Sectie(\n                    r['sectionCode'],\n                    afdeling\n                ) for r in res['sections']\n            ]\n\n        if self.caches['long'].is_configured:\n            key = 'list_secties_by_afdeling_rest#%s' % aid\n            secties = self.caches['long'].get_or_create(key, creator)\n        else:\n            secties = creator()\n        for s in secties:\n            s.set_gateway(self)\n        return secties"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_sectie_by_id_and_afdeling(self, id, afdeling):\n        '''\n        Get a `sectie`.\n\n        :param id: An id of a sectie. eg. \"A\"\n        :param afdeling: The :class:`Afdeling` for in which the `sectie` can \\\n            be found. Can also be the id of and `afdeling`.\n        :rtype: A :class:`Sectie`.\n        '''\n        try:\n            aid = afdeling.id\n        except AttributeError:\n            aid = afdeling\n            afdeling = self.get_kadastrale_afdeling_by_id(aid)\n        afdeling.clear_gateway()\n\n        def creator():\n            url = self.base_url + '/municipality/%s/department/%s/section/%s' % (afdeling.gemeente.id, afdeling.id, id)\n            h = self.base_headers\n            p = {\n                'geometry': 'full',\n                'srs': '31370'\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return Sectie(\n                res['sectionCode'],\n                afdeling,\n                self._parse_centroid(res['geometry']['center']),\n                self._parse_bounding_box(res['geometry']['boundingBox']),\n                res['geometry']['shape'],\n            )\n\n        if self.caches['long'].is_configured:\n            key = 'get_sectie_by_id_and_afdeling_rest#%s#%s' % (id, aid)\n            sectie = self.caches['long'].get_or_create(key, creator)\n        else:\n            sectie = creator()\n        sectie.set_gateway(self)\n        return sectie", "response": "Get a sectie by id and afdeling."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all percelen in a sectie.", "response": "def list_percelen_by_sectie(self, sectie):\n        '''\n        List all percelen in a `sectie`.\n\n        :param sectie: The :class:`Sectie` for which the percelen are wanted.\n        :param integer sort: Field to sort on.\n        :rtype: A :class:`list` of :class:`Perceel`.\n        '''\n        sid = sectie.id\n        aid = sectie.afdeling.id\n        gid = sectie.afdeling.gemeente.id\n        sectie.clear_gateway()\n\n        def creator():\n            url = self.base_url + '/municipality/%s/department/%s/section/%s/parcel' % (gid, aid, sid)\n            h = self.base_headers\n            p = {\n                'data': 'adp'\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return [\n                Perceel(\n                    r['perceelnummer'],\n                    sectie,\n                    r['capakey'],\n                    self.parse_percid(r['capakey']),\n                ) for r in res['parcels']\n            ]\n\n        if self.caches['short'].is_configured:\n            key = 'list_percelen_by_sectie_rest#%s#%s#%s' % (gid, aid, sid)\n            percelen = self.caches['short'].get_or_create(key, creator)\n        else:\n            percelen = creator()\n        for p in percelen:\n            p.set_gateway(self)\n        return percelen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a Perceel by id and sectie.", "response": "def get_perceel_by_id_and_sectie(self, id, sectie):\n        '''\n        Get a `perceel`.\n\n        :param id: An id for a `perceel`.\n        :param sectie: The :class:`Sectie` that contains the perceel.\n        :rtype: :class:`Perceel`\n        '''\n        sid = sectie.id\n        aid = sectie.afdeling.id\n        gid = sectie.afdeling.gemeente.id\n        sectie.clear_gateway()\n\n        def creator():\n            url = self.base_url + '/municipality/%s/department/%s/section/%s/parcel/%s' % (\n            gid, aid, sid, id)\n            h = self.base_headers\n            p = {\n                'geometry': 'full',\n                'srs': '31370',\n                'data': 'adp'\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return Perceel(\n                res['perceelnummer'],\n                sectie,\n                res['capakey'],\n                Perceel.get_percid_from_capakey(res['capakey']),\n                None,\n                None,\n                self._parse_centroid(res['geometry']['center']),\n                self._parse_bounding_box(res['geometry']['boundingBox']),\n                res['geometry']['shape']\n            )\n\n        if self.caches['short'].is_configured:\n            key = 'get_perceel_by_id_and_sectie_rest#%s#%s#%s' % (id, sectie.id, sectie.afdeling.id)\n            perceel = self.caches['short'].get_or_create(key, creator)\n        else:\n            perceel = creator()\n        perceel.set_gateway(self)\n        return perceel"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_perceel_by_capakey(self, capakey):\n        '''\n        Get a `perceel`.\n\n        :param capakey: An capakey for a `perceel`.\n        :rtype: :class:`Perceel`\n        '''\n\n        def creator():\n            url = self.base_url + '/parcel/%s' % capakey\n            h = self.base_headers\n            p = {\n                'geometry': 'full',\n                'srs': '31370',\n                'data': 'adp'\n            }\n            res = capakey_rest_gateway_request(url, h, p).json()\n            return Perceel(\n                res['perceelnummer'],\n                Sectie(\n                    res['sectionCode'],\n                    Afdeling(\n                        res['departmentCode'],\n                        res['departmentName'],\n                        Gemeente(res['municipalityCode'], res['municipalityName'])\n                    )\n                ),\n                res['capakey'],\n                Perceel.get_percid_from_capakey(res['capakey']),\n                None,\n                None,\n                self._parse_centroid(res['geometry']['center']),\n                self._parse_bounding_box(res['geometry']['boundingBox']),\n                res['geometry']['shape']\n            )\n\n        if self.caches['short'].is_configured:\n            key = 'get_perceel_by_capakey_rest#%s' % capakey\n            perceel = self.caches['short'].get_or_create(key, creator)\n        else:\n            perceel = creator()\n        perceel.set_gateway(self)\n        return perceel", "response": "Get a perceel by a capakey."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the gateway for this object.", "response": "def set_gateway(self, gateway):\n        '''\n        :param crabpy.gateway.capakey.CapakeyGateway gateway: Gateway to use.\n        '''\n        self.gateway = gateway\n        if (self._gemeente is not None):\n            self._gemeente.set_gateway(gateway)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_gateway(self, gateway):\n        '''\n        :param crabpy.gateway.capakey.CapakeyGateway gateway: Gateway to use.\n        '''\n        self.gateway = gateway\n        self.afdeling.set_gateway(gateway)", "response": "Sets the gateway for this object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_gateway(self, gateway):\n        '''\n        :param crabpy.gateway.capakey.CapakeyGateway gateway: Gateway to use.\n        '''\n        self.gateway = gateway\n        self.sectie.set_gateway(gateway)", "response": "Sets the CapakeyGateway for this session."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsplits a capakey into more readable elements.", "response": "def _split_capakey(self):\n        '''\n        Split a capakey into more readable elements.\n\n        Splits a capakey into it's grondnummer, bisnummer, exponent and macht.\n        '''\n        import re\n        match = re.match(\n            r\"^[0-9]{5}[A-Z]{1}([0-9]{4})\\/([0-9]{2})([A-Z\\_]{1})([0-9]{3})$\",\n            self.capakey\n        )\n        if match:\n            self.grondnummer = match.group(1)\n            self.bisnummer = match.group(2)\n            self.exponent = match.group(3)\n            self.macht = match.group(4)\n        else:\n            raise ValueError(\n                \"Invalid Capakey %s can't be parsed\" % self.capakey\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmarking a function as requiring libsodium.", "response": "def requires_libsodium(func):\n    \"\"\"\n    Mark a function as requiring libsodium.\n\n    If no libsodium support is detected, a `RuntimeError` is thrown.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        libsodium_check()\n        return func(*args, **kwargs)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_delete_permission(self, request, obj=None):\n        if obj is not None and obj.fixed:\n            return False\n\n        return super(NamespaceAdmin, self).has_delete_permission(request, obj)", "response": "Check if user can delete a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_install_requires():\n    install_requires = get_requirements('requirements.txt')\n    if 'bdist_wheel' not in sys.argv:\n        if sys.version_info[0] == 2:\n            # On Python 2.6 and 2.7 we pull in Bazaar.\n            install_requires.append('bzr >= 2.6.0')\n        if sys.version_info[2:] == (2, 6):\n            # On Python 2.6 we have to stick to versions of Mercurial below 4.3\n            # because 4.3 drops support for Python 2.6, see the change log:\n            # https://www.mercurial-scm.org/wiki/WhatsNew\n            install_requires.append('mercurial >= 2.9, < 4.3')\n        elif (2, 6) < sys.version_info[:2] < (3, 0):\n            # On Python 2.7 we pull in Mercurial.\n            install_requires.append('mercurial >= 2.9')\n    return sorted(install_requires)", "response": "Add conditional dependencies ( when creating source distributions )."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverloads the admin s urls for WYMEditor.", "response": "def get_urls(self):\n        \"\"\"\n        Overload the admin's urls for WYMEditor.\n        \"\"\"\n        entry_admin_urls = super(EntryAdminWYMEditorMixin, self).get_urls()\n        urls = [\n            url(r'^wymeditor/$',\n                self.admin_site.admin_view(self.wymeditor),\n                name='zinnia_entry_wymeditor'),\n        ]\n        return urls + entry_admin_urls"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _media(self):\n        def static_url(url):\n            return staticfiles_storage.url('zinnia_wymeditor/%s' % url)\n\n        media = super(EntryAdminWYMEditorMixin, self).media\n\n        media += Media(\n            js=(static_url('js/jquery.min.js'),\n                static_url('js/wymeditor/jquery.wymeditor.pack.js'),\n                static_url('js/wymeditor/plugins/hovertools/'\n                           'jquery.wymeditor.hovertools.js'),\n                reverse('admin:zinnia_entry_wymeditor')))\n        return media", "response": "A media that provides the admin page for the admin page."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlaunch editor using a specific map object", "response": "def launchEditor(mapObj):\n    \"\"\"\n    PURPOSE: launch the editor using a specific map object\n    INPUT:   mapObj (sc2maptool.mapRecord.MapRecord)\n    \"\"\"\n    cfg = Config()\n    if cfg.is64bit: selectedArchitecture = c.SUPPORT_64_BIT_TERMS\n    else:           selectedArchitecture = c.SUPPORT_32_BIT_TERMS\n    editorCmd = \"%s -run %s -testMod %s -displayMode 1\"\n    fullAppPath = os.path.join(\n        cfg.installedApp.data_dir,\n        c.FOLDER_APP_SUPPORT%(selectedArchitecture[0]))\n    appCmd = c.FILE_EDITOR_APP%(selectedArchitecture[1])\n    fullAppFile = os.path.join(fullAppPath, appCmd)\n    baseVersion = cfg.version.baseVersion\n    availableVers = [int(re.sub(\"^.*?Base\", \"\", os.path.basename(path)))\n        for path in glob.glob(os.path.join(c.FOLDER_MODS, \"Base*\"))]\n    selV = max([v for v in availableVers if v <= baseVersion])\n    modFilepath = os.path.join(c.FOLDER_MODS, \"Base%s\"%selV, c.FILE_EDITOR_MOD)\n    os.chmod(fullAppFile, stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH|stat.S_IXUSR|\\\n                          stat.S_IRUSR|stat.S_IWUSR|stat.S_IWGRP|stat.S_IXGRP) # switcher file must be executable\n    finalCmd = editorCmd%(appCmd, mapObj.path, modFilepath)\n    cwd = os.getcwd() # remember the current path once the editor has finished\n    os.chdir(fullAppPath)\n    os.system(finalCmd)\n    os.chdir(cwd)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initScenario(controller, scenario, thisPlayerID, debug=False):\n    ############################################################################\n    def createUnitsWithTags(unitList, existingUnits={}, maxTries=25):\n        \"\"\"create each unit of unitList in game, identified by their tag\"\"\"\n        createCmds = debugCmds.create(*unitList)\n        controller.debug(*createCmds) # send create cmd via controller\n        triesRemaining = maxTries\n        getGameState = controller.observe # function that observes what's changed since the prior gameloop(s)\n        numNeededNewUnits = len(unitList)\n        newUnits = {}\n        while len(newUnits) < numNeededNewUnits and triesRemaining > 0: # wait until new units are created\n            units = getGameState().observation.raw_data.units\n            for i, unit in enumerate(unitList): # match new unit tags with their originating units\n                if unit.tag: continue # already found a matching tag for this unit\n                for liveUnit in units: # identify new units and their tags\n                    if liveUnit.unit_type != unit.code:     continue # can't match a unit of a different type\n                    if liveUnit.owner     != unit.owner:    continue # can't match units with different owners\n                    if liveUnit.tag       in existingUnits: continue # don't match against previously existing or new units\n                    unit.tag = liveUnit.tag # found a match; sync tags + decalre this unit matched\n                    existingUnits[unit.tag] = liveUnit # remember this association between unit and its properties\n                    newUnits[unit.tag] = unit # distinguish the new units from the existing units\n                    break # once a match is made, stop searching\n                #if not unit.tag:  print(\"%02d.  missing: %s\"%(maxTries-triesRemaining, unit))\n            triesRemaining -= 1\n        return newUnits\n    ############################################################################\n    def detectCurrentUnits(**filters):\n        \"\"\"identify all units currently visible by the player\"\"\"\n        detectedUnits = {}\n        getGameState = controller.observe # function that observes what's changed since the prior gameloop(s)\n        while True:\n            obs = getGameState()\n            if obs.observation.game_loop <= 1: continue\n            foundNewUnit = False\n            for u in obs.observation.raw_data.units: # identify existing units (requieres no fog to be disabled?)\n                if u.tag in detectedUnits: continue\n                foundNewUnit = True\n                detectedUnits[u.tag] = u\n            if foundNewUnit: continue # ensure that two consecutive gameloops have identical units\n            if detectedUnits: break # wait until units are found in the raw observations\n        if filters:  return filterUnits(detectedUnits, **filters)\n        else:        return detectedUnits\n    ############################################################################\n    def filterUnits(unitDict, noNeutral=False, ownedOnly=False):\n        \"\"\"select the desired types of units from unitDict\"\"\"\n        ########################################################################\n        def allow(unit):\n            if noNeutral:\n                if unit.alliance == c.NEUTRAL:              return False # ignore neutral units visible via snapshot to start the game\n                if unit.mineral_contents:                   return False # don't include mineral nodes\n                if unit.vespene_contents:                   return False # don't include vespene nodes\n            if ownedOnly and unit.owner != thisPlayerID:    return False\n            return True\n        ########################################################################\n        if not (noNeutral or ownedOnly): return unitDict # must select filters to get something different\n        return {unit.tag : unit for unit in unitDict.values() if allow(unit)}\n    ############################################################################\n    def removeUnitsByKey(originalUnits=None, keepTags=[], **filters):\n        \"\"\"remove all detected units\"\"\"\n        if originalUnits:\n            units = filterUnits(originalUnits, **filters) # potentially filter an existing unit list\n        else:\n            originalUnits = detectCurrentUnits(**filters) # query currently existing units and filter appropriately\n            units = originalUnits\n        rmTags = list(units.keys())\n        for keeper in keepTags:\n            try:    rmTags.remove(keeper)\n            except: pass\n        return removeUnitsByTag(*rmTags, knownUnits=originalUnits)\n    ############################################################################\n    def removeUnitsByTag(*rmUnitTags, knownUnits={}):\n        \"\"\"remove specific units\"\"\"\n        for rmTag in rmUnitTags:\n            try:    del knownUnits[rmTag]\n            except:\n                if not knownUnits: break # already removed all monitored units\n        if rmUnitTags:\n            rmCmd = debugCmds.remove(*rmUnitTags) # create command to remove existing units\n            controller.debug(rmCmd) # send remove cmd to remove existing units\n        return knownUnits\n    ############################################################################\n    def wait(delay, msg):\n        \"\"\"control timing and messaging around delayed timing\"\"\"\n        if debug: print(msg)\n        while True:\n            time.sleep(1)\n            delay -= 1\n            if delay > 0:\n                if debug: print(\"%d...\"%delay)\n                continue\n            break\n    ############################################################################\n    knownUnits = detectCurrentUnits(noNeutral=True) # all initial units, including misc units\n    for pIdx, p in scenario.players.items():\n        baseUnits = scenario.newBaseUnits(pIdx)\n        newUs = createUnitsWithTags(p.baseUnits, existingUnits=knownUnits)\n    wait(2, \"delay before default unit deletion; %d remain\"%len(newUs))\n    if scenario.units: # remove initial units, but only if custom units are specified\n        rmTags = []\n        keepUnits = {19, 60, 95, 137} # supply depot, pylon, nydus network and burrowed creep tumor\n        for unit in knownUnits.values():\n            if unit.unit_type in keepUnits: continue # don't remove the main building\n            rmTags.append(unit.tag) # collect all tags to remove them in a single command, all at once\n        removeUnitsByTag(*rmTags, knownUnits=knownUnits) # skip 'knownUnits' option since initial units has already excluded rmTags\n        wait(1, \"idle for unit kills (keep %d)\"%len(knownUnits))\n        removeUnitsByKey(keepTags=knownUnits.keys(), noNeutral=True) # attempt again because zerg building deaths produce broodlings\n    if debug:  print(\"%d remaining initial, known units\"%len(knownUnits))\n    initialUnits = dict(knownUnits)\n    if thisPlayerID == 1: # this is the host (enable cheats for all players)\n        controller.debug(debugCmds.disableAllCosts(), # enable cheats\n                         debugCmds.allowEnemyControl(),\n                         debugCmds.fastProduction())\n    wait(0.5, \"delay before creation\") # wait before sending more commands\n    actionLists = []\n    nonActionLists = []\n    newU = {}\n    for playerID, upgrades in scenario.upgrades.items(): # set upgrades when appropriately specified in the scenario\n        if not upgrades: continue\n        reqs = scenario.players[playerID].upgradeReqs\n        producingUnits = reqs.keys()\n        if playerID == thisPlayerID:\n            if debug: print(\"preparing %d upgrades for player #%d\"%(len(upgrades), playerID))\n            newU = createUnitsWithTags(producingUnits, existingUnits=knownUnits) # new units are created with in-game tags\n        for unit, toDoActions in reqs.items():\n            for i, ability in enumerate(toDoActions): # convert ability into requisite upgrade protocol action\n                while len(actionLists) <= i:\n                    actionLists.append([])\n                    nonActionLists.append([])\n                action = Action()\n                uCmd = action.action_raw.unit_command\n                uCmd.unit_tags.append(unit.tag)\n                uCmd.queue_command = True\n                uCmd.ability_id, ignoreTargetType = ability.getGameCmd() # upgrade abilities are targetless; therefore ignore target type of the action\n                if playerID == thisPlayerID:    actionLists[i].append(action)\n                else:                        nonActionLists[i].append(action)\n    for i, (al, nal) in enumerate(zip(actionLists, nonActionLists)): # units that perform subsequent research commands must issue them consecutively\n        if debug:  print(\"upgrade action list #%d commands: %d\"%(i+1, len(al)))\n        if al:  controller.actions(RequestAction(actions=al))\n        elif not nal: continue # no player has any upgrade actions to perform for this tech level\n        if   i == 0:  wait(6, \"wait for all player's level 1 upgrades\")\n        elif i == 1:  wait(7, \"wait for all player's level 2 upgrades\")\n        elif i == 2:  wait(8, \"wait for all player's level 3 upgrades\")\n    if thisPlayerID == 1: # this is the host (disable cheats for all players)\n        controller.debug(debugCmds.disableAllCosts(), # disable cheats\n                         debugCmds.allowEnemyControl(),\n                         debugCmds.fastProduction())\n    wait(0.5, \"wait to disable cheats before proceeding\")\n    if thisPlayerID == 1:\n        removeUnitsByKey(keepTags=initialUnits, noNeutral=True) # remove tech researching units (and any other unit the player happened to create during research time\n        wait(1.0, \"idle for unit kills\")\n        knownUnits = removeUnitsByKey(keepTags=initialUnits, noNeutral=True) # attempt again in case zerg units produced broodlings\n    cameraMv = Action()\n    playerLoc = scenario.players[thisPlayerID].loc # set camera location to player's location\n    playerLoc.assignIntoInt(cameraMv.action_raw.camera_move.center_world_space)\n    controller.actions(RequestAction(actions=[cameraMv]))\n    if debug: print(\"repositioned camera\")\n    scenarioUnits = {}\n    for p in scenario.players.values(): # create the new scenario units only (not base units)\n        newUnits = createUnitsWithTags(p.units, existingUnits=knownUnits)\n        scenarioUnits.update(newUnits)\n    modifyCmds = debugCmds.modify(*scenarioUnits.values()) # create command to set properties of in-game units\n    controller.debug(*modifyCmds) # send modify cmd via controller\n    wait(0.1, \"allow modifications to finish\")\n    controller.debug(debugCmds.revealMap()) # reenable fog of war\n    if debug:  print(\"scenario setup is finished\")", "response": "initScenario - initialize the game with the given scenario"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_properties(self, path, mode):\n        self.name = path\n        self.mode = mode\n\n        if 'b' in self.mode:\n            if not isinstance(self.read_data, bytes):\n                self.read_data = bytes(self.read_data, encoding='utf8')\n        else:\n            if not isinstance(self.read_data, str):\n                self.read_data = str(self.read_data, encoding='utf8')", "response": "Set file s properties."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_mock(self, visited=None):\n        # In some versions of the mock library, `reset_mock` takes an argument\n        # and in some it doesn't. We try to handle all situations.\n        if visited is not None:\n            super(FileLikeMock, self).reset_mock(visited)\n        else:\n            super(FileLikeMock, self).reset_mock()\n\n        # Reset contents and tell/read/write/close side effects.\n        self.read_data = ''\n        self.close.side_effect = self._close", "response": "Reset the default tell read write etc side effects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new FileLikeMock instance with the same attributes as the parent.", "response": "def _get_child_mock(self, **kws):\n        \"\"\"Create a new FileLikeMock instance.\n\n        The new mock will inherit the parent's side_effect and read_data\n        attributes.\n        \"\"\"\n        kws.update({\n            '_new_parent': self,\n            'side_effect': self._mock_side_effect,\n            'read_data': self.__read_data,\n        })\n        return FileLikeMock(**kws)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef allow(self, ip):\n        self.whitelist.append(ip)\n        self.blacklist.clear()", "response": "Allow the specified IP to connect."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef deny(self, ip):\n        self.blacklist.append(ip)\n        self.whitelist.clear()", "response": "Allow the specified IP to connect."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def on_request(\n        self,\n        domain,\n        address,\n        identity,\n        mechanism,\n        credentials,\n    ):\n        \"\"\"\n        Handle a ZAP request.\n        \"\"\"\n        logger.debug(\n            \"Request in domain %s for %s (%r): %r (%r)\",\n            domain,\n            address,\n            identity,\n            mechanism,\n            credentials,\n        )\n\n        user_id = None\n        metadata = {}\n\n        if self.whitelist:\n            if address not in self.whitelist:\n                raise ZAPAuthenticationFailure(\n                    \"IP address is not in the whitelist\",\n                )\n        elif self.blacklist:\n            if address in self.blacklist:\n                raise ZAPAuthenticationFailure(\"IP address is blacklisted\")\n\n        if mechanism == b'PLAIN':\n            username = credentials[0].decode('utf-8')\n            password = credentials[1].decode('utf-8')\n            ref_password = self.passwords.get(username)\n\n            if not ref_password:\n                raise ZAPAuthenticationFailure(\"No such user %r\" % username)\n\n            if password != ref_password:\n                raise ZAPAuthenticationFailure(\n                    \"Invalid password for user %r\" % username,\n                )\n\n            user_id = username\n\n        elif mechanism == b'CURVE':\n            public_key = credentials[0]\n\n            if public_key not in self.authorized_keys:\n                raise ZAPAuthenticationFailure(\n                    \"Unauthorized key %r\" % public_key,\n                )\n\n        return user_id, metadata", "response": "Handle a ZAP request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to reconstruct the APIResource from its data. :param data: The APIResource data :type data: dict :return: The guessed APIResource :raise exceptions.UnkownAPIResource when it's impossible to reconstruct the APIResource from its data.", "response": "def factory(data):\n        \"\"\"\n        Try to reconstruct the APIResource from its data.\n\n        :param data: The APIResource data\n        :type data: dict\n\n        :return: The guessed APIResource\n\n        :raise\n            exceptions.UnkownAPIResource when it's impossible to reconstruct the APIResource from its data.\n        \"\"\"\n        if 'object' not in data:\n            raise exceptions.UnknownAPIResource('Missing `object` key in resource.')\n\n        for reconstituable_api_resource_type in ReconstituableAPIResource.__subclasses__():\n            if reconstituable_api_resource_type.object_type == data['object']:\n                return reconstituable_api_resource_type(**data)\n\n        raise exceptions.UnknownAPIResource('Unknown object `' + data['object'] + '`.')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing a resource. Default behavior is just to set all the attributes. You may want to override this. :param resource_attributes: The resource attributes", "response": "def _initialize(self, **resource_attributes):\n        \"\"\"\n        Initialize a resource.\n        Default behavior is just to set all the attributes. You may want to override this.\n\n        :param resource_attributes: The resource attributes\n        \"\"\"\n        self._set_attributes(**resource_attributes)\n        for attribute, attribute_type in list(self._mapper.items()):\n            if attribute in resource_attributes and isinstance(resource_attributes[attribute], dict):\n                setattr(self, attribute, attribute_type(**resource_attributes[attribute]))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _mapper(self):\n        return {\n            'card': Payment.Card,\n            'customer': Payment.Customer,\n            'hosted_payment': Payment.HostedPayment,\n            'notification': Payment.Notification,\n            'failure': Payment.Failure,\n        }", "response": "Maps payment attributes to their specific types."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a payment that you can trust", "response": "def get_consistent_resource(self):\n        \"\"\"\n        :return a payment that you can trust.\n        :rtype Payment\n        \"\"\"\n        http_client = HttpClient()\n        response, _ = http_client.get(routes.url(routes.PAYMENT_RESOURCE, resource_id=self.id))\n        return Payment(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a refund that you can trust.", "response": "def get_consistent_resource(self):\n        \"\"\"\n        :return a refund that you can trust.\n        :rtype Refund\n        \"\"\"\n        http_client = HttpClient()\n        response, _ = http_client.get(\n            routes.url(routes.REFUND_RESOURCE, resource_id=self.id, payment_id=self.payment_id)\n        )\n        return Refund(**response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_cards(self, *args, **kwargs):\n        return payplug.Card.list(self, *args, **kwargs)", "response": "List the cards of the customer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _initialize(self, **resource_attributes):\n        super(APIResourceCollection, self)._initialize(**resource_attributes)\n\n        dict_list = self.data\n        self.data = []\n        for resource in dict_list:\n            self.data.append(self._expected_api_resource(**resource))", "response": "Initialize the collection.\n\n        :param resource_attributes: API resource parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef retry(retries=10, wait=5, catch=None):\n    catch = catch or (Exception,)\n\n    def real_retry(function):\n\n        def wrapper(*args, **kwargs):\n            for _ in range(retries):\n                try:\n                    ret = function(*args, **kwargs)\n                    return ret\n                except catch:\n                    time.sleep(wait)\n                except Exception as e:\n                    raise e\n                else:\n                    raise DSBException('Retries limit exceded.')\n\n        return wrapper\n\n    return real_retry", "response": "Decorator to retry on exceptions raised\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace_all(filepath, searchExp, replaceExp):\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "response": "Replace all the ocurrences of a string with another string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef discard_incoming_messages(self):\n        # Flush any received message so far.\n        self.inbox.clear()\n\n        # This allows nesting of discard_incoming_messages() calls.\n        previous = self._discard_incoming_messages\n        self._discard_incoming_messages = True\n\n        try:\n            yield\n        finally:\n            self._discard_incoming_messages = previous", "response": "Discard all incoming messages for the time of the context manager."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef provides(self, imt):\n        return self.type[:imt.specifity] == imt.type[:imt.specifity]", "response": "Returns True iff the self is at least as specific as other."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resolve(cls, accept, available_renderers):\n        assert isinstance(available_renderers, tuple)\n        accept = sorted(accept)\n\n        renderers, seen = [], set()\n\n        accept_groups = [[accept.pop()]]\n        for imt in accept:\n            if imt.equivalent(accept_groups[-1][0]):\n                accept_groups[-1].append(imt)\n            else:\n                accept_groups.append([imt])\n\n        for accept_group in accept_groups:\n            for renderer in available_renderers:\n                if renderer in seen:\n                    continue\n                for mimetype in renderer.mimetypes:\n                    for imt in accept_group:\n                        if mimetype.provides(imt):\n                            renderers.append(renderer)\n                            seen.add(renderer)\n                            break\n\n        return renderers", "response": "Resolves a list of accepted MediaTypes and available renderers to the preferred renderer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the name of the available file.", "response": "def get_available_name(self, name):\n        \"\"\"\n        Deletes the given file if it exists.\n        \"\"\"\n        if self.exists(name):\n            self.delete(name)\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a file from the cache.", "response": "def delete(self, name):\n        \"\"\"\n        Handle deletion race condition present in Django prior to 1.4\n        https://code.djangoproject.com/ticket/16108\n        \"\"\"\n        try:\n            super(StaticCompilerFileStorage, self).delete(name)\n        except OSError, e:\n            if e.errno != errno.ENOENT:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a socket to the multiplexer.", "response": "def add_socket(self, socket):\n        \"\"\"\n        Add a socket to the multiplexer.\n\n        :param socket: The socket. If it was added already, it won't be added a\n            second time.\n        \"\"\"\n        if socket not in self._sockets:\n            self._sockets.add(socket)\n            socket.on_closed.connect(self.remove_socket)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a socket from the multiplexer.", "response": "def remove_socket(self, socket):\n        \"\"\"\n        Remove a socket from the multiplexer.\n\n        :param socket: The socket. If it was removed already or if it wasn't\n            added, the call does nothing.\n        \"\"\"\n        if socket in self._sockets:\n            socket.on_closed.disconnect(self.remove_socket)\n            self._sockets.remove(socket)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading from all the associated sockets and store the result in the cache.", "response": "async def recv_multipart(self):\n        \"\"\"\n        Read from all the associated sockets.\n\n        :returns: A list of tuples (socket, frames) for each socket that\n            returned a result.\n        \"\"\"\n        if not self._sockets:\n            return []\n\n        results = []\n\n        async def recv_and_store(socket):\n            frames = await socket.recv_multipart()\n            results.append((socket, frames))\n\n        tasks = [\n            asyncio.ensure_future(recv_and_store(socket), loop=self.loop)\n            for socket in self._sockets\n        ]\n\n        try:\n            await asyncio.wait(\n                tasks,\n                return_when=asyncio.FIRST_COMPLETED,\n                loop=self.loop,\n            )\n        finally:\n            for task in tasks:\n                task.cancel()\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_dict(self):\n\n        result_dict = super(Group, self).as_dict()\n\n        statuses = list()\n        version = None\n        titles = list()\n        descriptions = list()\n        platforms = list()\n        groups = list()\n        rules = list()\n\n        for child in self.children:\n            if isinstance(child, Version):\n                version = child.as_dict()\n            elif isinstance(child, Status):\n                statuses.append(child.as_dict())\n            elif isinstance(child, Title):\n                titles.append(child.as_dict())\n            elif isinstance(child, Description):\n                descriptions.append(child.as_dict())\n            elif isinstance(child, Platform):\n                platforms.append(child.as_dict())\n            elif isinstance(child, Group):\n                groups.append(child.as_dict())\n            elif isinstance(child, Rule):\n                rules.append(child.as_dict())\n\n        if version is not None:\n            result_dict['version'] = version\n        if len(statuses) > 0:\n            result_dict['statuses'] = statuses\n        if len(titles) > 0:\n            result_dict['titles'] = titles\n        if len(descriptions) > 0:\n            result_dict['descriptions'] = descriptions\n        if len(platforms) > 0:\n            result_dict['platforms'] = platforms\n        if len(groups) > 0:\n            result_dict['groups'] = groups\n        if len(rules) > 0:\n            result_dict['rules'] = rules\n\n        return result_dict", "response": "Serializes the object necessary data in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialise the modified_data if necessary.", "response": "def initialise_modified_data(self):\n        \"\"\"\n        Initialise the modified_data if necessary\n        \"\"\"\n        if self.__modified_data__ is None:\n            if self.__original_data__:\n                self.__modified_data__ = list(self.__original_data__)\n            else:\n                self.__modified_data__ = []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append(self, item):\n        validated_value = self.get_validated_object(item)\n        if validated_value is not None:\n            self.__modified_data__.append(validated_value)", "response": "Append the item to our list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts an element to a list of items.", "response": "def insert(self, index, p_object):\n        \"\"\"\n        Insert an element to a list\n        \"\"\"\n        validated_value = self.get_validated_object(p_object)\n        if validated_value is not None:\n            self.__modified_data__.insert(index, validated_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index(self, value):\n        if self.__modified_data__ is not None:\n            return self.__modified_data__.index(value)\n        return self.__original_data__.index(value)", "response": "Gets the index in the list for a value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef count(self, value):\n        if self.__modified_data__ is not None:\n            return self.__modified_data__.count(value)\n        return self.__original_data__.count(value)", "response": "Returns the number of occurrencies of a value in the list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flat_data(self):\n\n        def flat_field(value):\n            \"\"\"\n            Flat item\n            \"\"\"\n            try:\n                value.flat_data()\n                return value\n            except AttributeError:\n                return value\n\n        modified_data = self.__modified_data__ if self.__modified_data__ is not None else self.__original_data__\n        if modified_data is not None:\n            self.__original_data__ = [flat_field(value) for value in modified_data]\n        self.__modified_data__ = None", "response": "Function to pass our modified values to the original ones\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the data in a jsoned form", "response": "def export_data(self):\n        \"\"\"\n        Retrieves the data in a jsoned form\n        \"\"\"\n\n        def export_field(value):\n            \"\"\"\n            Export item\n            \"\"\"\n            try:\n                return value.export_data()\n            except AttributeError:\n                return value\n\n        if self.__modified_data__ is not None:\n            return [export_field(value) for value in self.__modified_data__]\n        return [export_field(value) for value in self.__original_data__]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_modified_data(self):\n\n        def export_modfield(value, is_modified_seq=True):\n            \"\"\"\n            Export modified item\n            \"\"\"\n            try:\n                return value.export_modified_data()\n            except AttributeError:\n                if is_modified_seq:\n                    return value\n\n        if self.__modified_data__ is not None:\n            return [export_modfield(value) for value in self.__modified_data__]\n        return list(x for x in [export_modfield(value) for value in self.__original_data__] if x is not None)", "response": "Returns the modified data in a jsoned form"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef export_modifications(self):\n        if self.__modified_data__ is not None:\n            return self.export_data()\n\n        result = {}\n\n        for key, value in enumerate(self.__original_data__):\n            try:\n                if not value.is_modified():\n                    continue\n                modifications = value.export_modifications()\n            except AttributeError:\n                continue\n\n            try:\n                result.update({'{}.{}'.format(key, f): v for f, v in modifications.items()})\n            except AttributeError:\n                result[key] = modifications\n\n        return result", "response": "Returns a list of modifications."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the original data of the object", "response": "def export_original_data(self):\n        \"\"\"\n        Retrieves the original_data\n        \"\"\"\n\n        def export_field(value):\n            \"\"\"\n            Export item\n            \"\"\"\n            try:\n                return value.export_original_data()\n            except AttributeError:\n                return value\n\n        return [export_field(val) for val in self.__original_data__]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset data fields to deleted", "response": "def import_deleted_fields(self, data):\n        \"\"\"\n        Set data fields to deleted\n        \"\"\"\n\n        def child_delete_from_str(data_str):\n            \"\"\"\n            Inner function to set children fields to deleted\n            \"\"\"\n            parts = data_str.split('.', 1)\n            if parts[0].isnumeric:\n                self[int(parts[0])].import_deleted_fields(parts[1])\n\n        if not self.get_read_only() or not self.is_locked():\n            if isinstance(data, str):\n                data = [data]\n            if isinstance(data, list):\n                for key in data:\n                    child_delete_from_str(key)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list with any deleted fields form original data.", "response": "def export_deleted_fields(self):\n        \"\"\"\n        Returns a list with any deleted fields form original data.\n        In tree models, deleted fields on children will be appended.\n        \"\"\"\n        result = []\n        if self.__modified_data__ is not None:\n            return result\n\n        for index, item in enumerate(self):\n            try:\n                deleted_fields = item.export_deleted_fields()\n                result.extend(['{}.{}'.format(index, key) for key in deleted_fields])\n            except AttributeError:\n                pass\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_modified(self):\n        if self.__modified_data__ is not None:\n            return True\n        for value in self.__original_data__:\n            try:\n                if value.is_modified():\n                    return True\n            except AttributeError:\n                pass\n\n        return False", "response": "Returns whether the list is modified or not"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_modified_data(self):\n        self.__modified_data__ = None\n\n        for value in self.__original_data__:\n            try:\n                value.clear_modified_data()\n            except AttributeError:\n                pass", "response": "Clears only the modified data for the related object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_attrs_by_path(self, field_path, stop_first=False):\n        index_list, next_field = self._get_indexes_by_path(field_path)\n        values = []\n        for idx in index_list:\n            if next_field:\n                try:\n                    res = self[idx].get_attrs_by_path(next_field, stop_first=stop_first)\n                    if res is None:\n                        continue\n                    values.extend(res)\n\n                    if stop_first and len(values):\n                        break\n\n                except AttributeError:\n                    pass\n            else:\n                if stop_first:\n                    return [self[idx], ]\n                values.append(self[idx])\n\n        return values if len(values) else None", "response": "This method returns a list of values looked up by field path. It returns list of values in order of the path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfunctioning for deleting a field in the whole model by specifying the path in the whole model as described by the path in the whole model as described by the path in the whole model as described by the path in the whole model as described by the function_by_path method in : func : dirty. models. BaseModel. perform_function_by_path", "response": "def delete_attr_by_path(self, field):\n        \"\"\"\n        Function for deleting a field specifying the path in the whole model as described\n        in :func:`dirty:models.models.BaseModel.perform_function_by_path`\n        \"\"\"\n        index_list, next_field = self._get_indexes_by_path(field)\n        if index_list:\n            for index in reversed(index_list):\n                if next_field:\n                    self[index].delete_attr_by_path(next_field)\n                else:\n                    self.pop(index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of indexes by field path.", "response": "def _get_indexes_by_path(self, field):\n        \"\"\"\n        Returns a list of indexes by field path.\n\n        :param field: Field structure as following:\n         *.subfield_2  would apply the function to the every subfield_2 of the elements\n         1.subfield_2  would apply the function to the subfield_2 of the element 1\n         * would apply the function to every element\n         1 would apply the function to element 1\n        \"\"\"\n        try:\n            field, next_field = field.split('.', 1)\n        except ValueError:\n            next_field = ''\n\n        if field == '*':\n            index_list = []\n            for item in self:\n                index_list.append(self.index(item))\n            if index_list:\n                return index_list, next_field\n            return [], None\n        elif field.isnumeric():\n            index = int(field)\n            if index >= len(self):\n                return None, None\n            return [index], next_field"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_enum(func):\n\n    @wraps(func)\n    def inner(self, value):\n        try:\n            if self.check_value(value.value):\n                return value.value\n            return func(self, value.value)\n        except AttributeError:\n            pass\n\n        return func(self, value)\n\n    return inner", "response": "Decorator to use Enum value on type casts.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_value(self, value):\n        if self.check_value(value):\n            return value\n        return self.convert_value(value)", "response": "Converts value to field type"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets value to model if not empty", "response": "def set_value(self, obj, value):\n        \"\"\"Sets value to model if not empty\"\"\"\n        if value:\n            obj.set_field_value(self.name, value)\n        else:\n            self.delete_value(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a string from datetime using parse_format.", "response": "def get_formatted_value(self, value):\n        \"\"\"\n        Returns a string from datetime using :member:`parse_format`.\n\n        :param value: Datetime to cast to string\n        :type value: datetime\n        :return: str\n        \"\"\"\n\n        def get_formatter(parser_desc):\n            try:\n                return parser_desc['formatter']\n            except TypeError:\n                if isinstance(parser_desc, str):\n                    try:\n                        return get_formatter(self.date_parsers[parser_desc])\n                    except KeyError:\n                        return parser_desc\n                else:\n                    pass\n            except KeyError:\n                try:\n                    if isinstance(parser_desc['parser'], str):\n                        return parser_desc['parser']\n                except KeyError:\n                    pass\n\n        formatter = get_formatter(self.parse_format)\n\n        if formatter is None:\n            return str(value)\n\n        if callable(formatter):\n            return formatter(value)\n\n        return value.strftime(format=formatter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninvokes functions according to the supplied flags", "response": "def action(self):\n        \"\"\"\n        Invoke functions according to the supplied flags\n        \"\"\"\n\n        user = self.args['--user'] if self.args['--user'] else None\n        reset = True if self.args['--reset'] else False\n\n        if self.args['generate']:\n            generate_network(user, reset)\n        elif self.args['publish']:\n            publish_network(user, reset)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecorating a view method to say that it renders a particular format and mimetypes. Use as: @renderer(format=\"foo\") def render_foo(self, request, context, template_name): ... or @renderer(format=\"foo\", mimetypes=(\"application/x-foo\",)) def render_foo(self, request, context, template_name): ... The former case will inherit mimetypes from the previous renderer for that format in the MRO. Where there isn't one, it will default to the empty tuple. Takes an optional priority argument to resolve ties between renderers.", "response": "def renderer(format, mimetypes=(), priority=0, name=None, test=None):\n    \"\"\"\n    Decorates a view method to say that it renders a particular format and mimetypes.\n\n    Use as:\n        @renderer(format=\"foo\")\n        def render_foo(self, request, context, template_name): ...\n    or\n        @renderer(format=\"foo\", mimetypes=(\"application/x-foo\",))\n        def render_foo(self, request, context, template_name): ...\n    \n    The former case will inherit mimetypes from the previous renderer for that\n    format in the MRO. Where there isn't one, it will default to the empty\n    tuple.\n\n    Takes an optional priority argument to resolve ties between renderers.\n    \"\"\"\n\n    def g(f):\n        return Renderer(f, format, mimetypes, priority, name, test)\n    return g"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def wait_change(self):\n        future = asyncio.Future(loop=self.loop)\n        self._change_futures.add(future)\n        future.add_done_callback(self._change_futures.discard)\n        await future", "response": "Wait for the list to change."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shift(self, count=1):\n        if self:\n            self._index = (self._index + count) % len(self)\n        else:\n            self._index = 0", "response": "Shift the view a specified number of times."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(value):\n    # Empty urls\n    if not value:  # use case: wild card imports\n        return r'^$'\n\n    if value[0] != beginning:\n        value = beginning + value\n\n    if value[-1] != end:\n        value += end\n\n    return value", "response": "This function renders a naive URL into a url pattern."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_part(self, part):\n        if isinstance(part, RE_TYPE):\n            part = part.pattern\n\n        # Allow U / spmething syntax\n        if self == '^$':\n            return URLPattern(part, self.separator)\n        else:\n            # Erase dup separator inbetween\n            sep = self.separator\n            return URLPattern(self.rstrip('$' + sep) + sep + part.lstrip(sep),\n                              sep)", "response": "Function for adding a partial pattern to the value\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an open conjunctive graph.", "response": "def get_conjunctive_graph(store_id=None):\n    \"\"\"\n    Returns an open conjunctive graph.\n    \"\"\"\n    if not store_id:\n        store_id = DEFAULT_STORE\n\n    store = DjangoStore(DEFAULT_STORE)\n    graph = ConjunctiveGraph(store=store, identifier=store_id)\n    if graph.open(None) != VALID_STORE:\n        raise ValueError(\"The store identified by {0} is not a valid store\".format(store_id))\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an open named graph.", "response": "def get_named_graph(identifier, store_id=DEFAULT_STORE, create=True):\n    \"\"\"\n    Returns an open named graph.\n    \"\"\"\n    if not isinstance(identifier, URIRef):\n        identifier = URIRef(identifier)\n\n    store = DjangoStore(store_id)\n    graph = Graph(store, identifier=identifier)\n    if graph.open(None, create=create) != VALID_STORE:\n        raise ValueError(\"The store identified by {0} is not a valid store\".format(store_id))\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the README. rst file and returns the long description as a string.", "response": "def read_readme():\n    \"\"\"\n    Reads part of the README.rst for use as long_description in setup().\n    \"\"\"\n    text = open(\"README.rst\", \"rt\").read()\n    text_lines = text.split(\"\\n\")\n    ld_i_beg = 0\n    while text_lines[ld_i_beg].find(\"start long description\") < 0:\n        ld_i_beg += 1\n    ld_i_beg += 1\n    ld_i_end = ld_i_beg\n    while text_lines[ld_i_end].find(\"end long description\") < 0:\n        ld_i_end += 1\n\n    ld_text = \"\\n\".join(text_lines[ld_i_beg:ld_i_end])\n\n    return ld_text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef education(self):\n        educations = []\n\n        for education in self.cache['education']:\n            school        = Page(**education.get('school'))\n            year          = Page(**education.get('year'))\n            type          = education.get('type')\n            \n            if 'concentration' in education:\n                concentration = map(lambda c: Page(**c), education.get('concentration'))\n            else:\n                concentration = False\n\n            education = Structure(\n                school = school,\n                year = year,\n                concentration = concentration,\n                type = type\n            )\n\n            educations.append(education)\n\n        return educations", "response": "A list of structures describing the user s education history."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef accounts(self):\n        response = self.graph.get('%s/accounts' % self.id)\n\n        accounts = []\n        for item in response['data']:\n            account = Structure(\n                page = Page(\n                    id = item['id'],\n                    name = item['name'],\n                    category = item['category']\n                ),\n                access_token = item['access_token'],\n                permissions = item['perms']\n            )\n\n            accounts.append(account)\n\n        return accounts", "response": "Returns a list of structures describing apps and pages owned by this user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_xml_element(self):\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        self.xml_element.clear()\n\n        if hasattr(self, 'resolved'):\n            self.xml_element.set('resolved', self.resolved)\n        if hasattr(self, 'style'):\n            self.xml_element.set('style', self.style)\n        if hasattr(self, 'style_href'):\n            self.xml_element.set('style-href', self.style_href)\n        if hasattr(self, 'lang'):\n            self.xml_element.set(\n                '{http://www.w3.org/XML/1998/namespace}lang', self.lang)\n        self.xml_element.set('id', self.id)\n\n        for child in self.children:\n            if hasattr(child, 'update_xml_element'):\n                child.update_xml_element()\n                if hasattr(child, 'xml_element'):\n                    self.xml_element.append(child.xml_element)\n\n        return self.xml_element", "response": "Updates the XML element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize the object necessary data in a dictionary.", "response": "def as_dict(self):\n        \"\"\"\n        Serializes the object necessary data in a dictionary.\n\n        :returns: Serialized data in a dictionary.\n        :rtype: dict\n        \"\"\"\n\n        result_dict = super(Benchmark, self).as_dict()\n\n        statuses = list()\n        titles = list()\n        descriptions = list()\n        front_matters = list()\n        rear_matters = list()\n        platforms = list()\n        version = None\n        profiles = list()\n        groups = list()\n\n        for child in self.children:\n            if isinstance(child, Version):\n                version = child.as_dict()\n            elif isinstance(child, Status):\n                statuses.append(child.as_dict())\n            elif isinstance(child, Title):\n                titles.append(child.as_dict())\n            elif isinstance(child, Description):\n                descriptions.append(child.as_dict())\n            elif isinstance(child, FrontMatter):\n                front_matters.append(child.as_dict())\n            elif isinstance(child, RearMatter):\n                rear_matters.append(child.as_dict())\n            elif isinstance(child, Platform):\n                platforms.append(child.as_dict())\n            elif isinstance(child, Profile):\n                profiles.append(child.as_dict())\n            elif isinstance(child, Group):\n                groups.append(child.as_dict())\n\n        if version is not None:\n            result_dict['version'] = version\n        if len(statuses) > 0:\n            result_dict['statuses'] = statuses\n        if len(titles) > 0:\n            result_dict['titles'] = titles\n        if len(descriptions) > 0:\n            result_dict['descriptions'] = descriptions\n        if len(front_matters) > 0:\n            result_dict['front_matters'] = front_matters\n        if len(rear_matters) > 0:\n            result_dict['rear_matters'] = rear_matters\n        if len(platforms) > 0:\n            result_dict['platforms'] = platforms\n        if len(profiles) > 0:\n            result_dict['profiles'] = profiles\n        if len(groups) > 0:\n            result_dict['groups'] = groups\n\n        return result_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post_message(plugin, polled_time, identity, message):\n    user = plugin.build_identifier(identity)\n    return plugin.send(user, message)", "response": "Post a message to a single node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart listening for connection using Windows named pipes.", "response": "async def start_pipe_server(\n    client_connected_cb,\n    *,\n    path,\n    loop=None,\n    limit=DEFAULT_LIMIT\n):\n    \"\"\"\n    Start listening for connection using Windows named pipes.\n    \"\"\"\n    path = path.replace('/', '\\\\')\n    loop = loop or asyncio.get_event_loop()\n\n    def factory():\n        reader = asyncio.StreamReader(limit=limit, loop=loop)\n        protocol = asyncio.StreamReaderProtocol(\n            reader,\n            client_connected_cb,\n            loop=loop,\n        )\n\n        return protocol\n\n    server, *_ = await loop.start_serving_pipe(factory, address=path)\n\n    # The returned instance sadly doesn't have a `wait_closed` method so we add\n    # one.\n    closed = asyncio.Event(loop=loop)\n    original_close = server.close\n\n    def close():\n        original_close()\n        closed.set()\n\n    server.close = close\n    server.wait_closed = closed.wait\n\n    return server"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def open_pipe_connection(\n    path=None,\n    *,\n    loop=None,\n    limit=DEFAULT_LIMIT,\n    **kwargs\n):\n    \"\"\"\n    Connect to a server using a Windows named pipe.\n    \"\"\"\n    path = path.replace('/', '\\\\')\n    loop = loop or asyncio.get_event_loop()\n\n    reader = asyncio.StreamReader(limit=limit, loop=loop)\n    protocol = asyncio.StreamReaderProtocol(reader, loop=loop)\n    transport, _ = await loop.create_pipe_connection(\n        lambda: protocol,\n        path,\n        **kwargs\n    )\n    writer = asyncio.StreamWriter(transport, protocol, reader, loop)\n\n    return reader, writer", "response": "Open a new connection to a Windows named pipe."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_read_only(self, value):\n        if self.__read_only__ != value:\n            self.__read_only__ = value\n            self._update_read_only()", "response": "Sets whether the resource is read only or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns whether the current instance is locked.", "response": "def is_locked(self):\n        \"\"\"\n        Returns whether model is locked\n        \"\"\"\n        if not self.__locked__:\n            return False\n        elif self.get_parent():\n            return self.get_parent().is_locked()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_gml(username, nodes, edges, cache=False):\n\n    # file segment that represents all the nodes in graph\n    node_content = \"\"\n    for i in range(len(nodes)):\n        node_id = \"\\t\\tid %d\\n\" % (i + 1)\n        node_label = \"\\t\\tlabel \\\"%s\\\"\\n\" % (nodes[i])\n\n        node_content += format_node(node_id, node_label)\n\n    # file segment that represents all the edges in graph\n    edge_content = \"\"\n    for i in range(len(edges)):\n        edge = edges[i]\n\n        edge_source = \"\\t\\tsource %d\\n\" % (nodes.index(edge[0]) + 1)\n        edge_target = \"\\t\\ttarget %d\\n\" % (nodes.index(edge[1]) + 1)\n\n        edge_content += format_edge(edge_source, edge_target)\n\n    # formatted file content\n    content = format_content(node_content, edge_content)\n\n    with open(username_to_file(username), 'w') as f:\n        f.write(content)\n\n    # save the file for further use\n    if cache:\n    \tcache_file(username_to_file(username))", "response": "Generate a GML format file representing the given graph attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef activate_crontab(self):\n        self._crontab = []\n        if hasattr(self, 'CRONTAB'):\n            for crontab_spec in self.CRONTAB:\n                args = cronjob.parse_crontab(crontab_spec)\n                job = cronjob.CronJob()\n                if args['_timer'] == 'datetime':\n                    job.set_triggers(args['trigger_format'], args['trigger_time'])\n                if args['_timer'] == 'crontab':\n                    job.set_crontab(args['crontab'])\n                if args['action'].startswith('.'):\n                    action_name = args['action'][1:]\n                    action_ = getattr(self.__class__, action_name)\n                else:\n                    action_ = args['action']\n                job.set_action(action_, *args['args'])\n                self._crontab.append(job)\n        self.start_poller(30, self.poll_crontab)", "response": "Activate polling function and register first crontab\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking crontab and run target jobs", "response": "def poll_crontab(self):\n        \"\"\"Check crontab and run target jobs\n        \"\"\"\n        polled_time = self._get_current_time()\n        if polled_time.second >= 30:\n            self.log.debug('Skip cronjobs in {}'.format(polled_time))\n            return\n        for job in self._crontab:\n            if not job.is_runnable(polled_time):\n                continue\n            job.do_action(self, polled_time)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef include(self, location, namespace=None, app_name=None):\n        sorted_entries = sorted(self.routes, key=operator.itemgetter(0),\n                                reverse=True)\n\n        arg = [u for _, u in sorted_entries]\n        return url(location, urls.include(\n            arg=arg,\n            namespace=namespace,\n            app_name=app_name))", "response": "Return an object suitable for url_patterns. include."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clone_source(self):\n        \" Clone source and prepare templates \"\n\n        print_header('Clone src: %s' % self.src, '-')\n\n        # Get source\n        source_dir = self._get_source()\n\n        # Append settings from source\n        self.read(op.join(source_dir, settings.CFGNAME))\n\n        self.templates += (self.args.template or self.template).split(',')\n        self.templates = OrderedSet(self._gen_templates(self.templates))\n        self['template'] = ','.join(str(x[0]) for x in self.templates)\n\n        print_header('Deploy templates: %s' % self.template, sep='-')\n        with open(op.join(self.deploy_dir, settings.TPLNAME), 'w') as f:\n            f.write(self.template)\n\n        with open(op.join(self.deploy_dir, settings.CFGNAME), 'w') as f:\n            self['deploy_dir'], tmp_dir = self.target_dir, self.deploy_dir\n            self.write(f)\n            self['deploy_dir'] = tmp_dir\n\n        # Create site\n        site = Site(self.deploy_dir)\n\n        # Prepare templates\n        for template_name, template in self.templates:\n            site.paste_template(template_name, template, tmp_dir)\n\n        # Create site\n        if self.args.info:\n            print_header('Project context', sep='-')\n            LOGGER.debug(site.get_info(full=True))\n            return None\n\n        # Check requirements\n        call('sudo chmod +x %s/*.sh' % self.service_dir)\n        site.run_check(service_dir=self.service_dir)\n\n        # Save options\n        site.write()\n\n        return site", "response": "Clone source and prepare templates"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_source(self):\n        \" Get source from CVS or filepath. \"\n        source_dir = op.join(self.deploy_dir, 'source')\n        for tp, cmd in settings.SRC_CLONE:\n            if self.src.startswith(tp + '+'):\n                program = which(tp)\n                assert program, '%s not found.' % tp\n                cmd = cmd % dict(src=self.src[len(tp) + 1:],\n                                 source_dir=source_dir,\n                                 branch=self.branch)\n                cmd = \"sudo -u %s %s\" % (self['src_user'], cmd)\n                call(cmd, shell=True)\n                self.templates.append('src-%s' % tp)\n                break\n        else:\n            self.templates.append('src-dir')\n            copytree(self.src, source_dir)\n\n        return source_dir", "response": "Get source from CVS or filepath."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef quote(text, ws=plain):\n    return \"\".join(chr in ws and chr or '\\\\' + chr\n                        for chr in text)", "response": "Quote special characters in shell command arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_plot_data(data_file):\n\n    G = ig.Graph.Read_GML(data_file)\n\n    layout = G.layout('graphopt')\n    labels = list(G.vs['label'])\n\n    N = len(labels)\n    E = [e.tuple for e in G.es]\n\n    community = G.community_multilevel().membership\n    communities = len(set(community))\n\n    color_list = community_colors(communities)\n\n    Xn = [layout[k][0] for k in range(N)]\n    Yn = [layout[k][1] for k in range(N)]\n\n    Xe = []\n    Ye = []\n\n    for e in E:\n        Xe += [layout[e[0]][0], layout[e[1]][0], None]\n        Ye += [layout[e[0]][1], layout[e[1]][1], None]\n\n    lines = Scatter(x=Xe,\n                    y=Ye,\n                    mode='lines',\n                    line=Line(color='rgb(210,210,210)', width=1),\n                    hoverinfo='none'\n                    )\n    plot_data = [lines]\n\n    node_x = [[] for i in range(communities)]\n    node_y = [[] for i in range(communities)]\n    node_labels = [[] for i in range(communities)]\n\n    for j in range(len(community)):\n        index = community[j]\n\n        node_x[index].append(layout[j][0])\n        node_y[index].append(layout[j][1])\n        node_labels[index].append(labels[j])\n\n    for i in range(communities):\n        trace = Scatter(x=node_x[i],\n                        y=node_y[i],\n                        mode='markers',\n                        name='ntw',\n                        marker=Marker(symbol='dot',\n                                      size=5,\n                                      color=color_list[i],\n                                      line=Line(\n                                          color='rgb(50,50,50)', width=0.5)\n                                      ),\n                        text=node_labels[i],\n                        hoverinfo='text'\n                        )\n\n        plot_data.append(trace)\n\n    return plot_data", "response": "Prepare the plot data for the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npublishes the network for a user and show it using Plotly", "response": "def publish_network(user=None, reset=False):\n    \"\"\"\n    Generate graph network for a user and plot it using Plotly\n    \"\"\"\n\n    username = generate_network(user, reset)\n    network_file = username_to_file(username)\n\n    plot_data = prepare_plot_data(network_file)\n    data = Data(plot_data)\n\n    # hide axis line, grid, ticklabels and title\n    axis = dict(showline=False,\n                zeroline=False,\n                showgrid=False,\n                showticklabels=False,\n                title=''\n                )\n\n    width = 800\n    height = 800\n\n    layout = Layout(title='GitHub Network for \"{0}\"'.format(username),\n                    font=Font(size=12),\n                    showlegend=False,\n                    autosize=False,\n                    width=width,\n                    height=height,\n                    xaxis=XAxis(axis),\n                    yaxis=YAxis(axis),\n                    margin=Margin(\n                        l=40,\n                        r=40,\n                        b=85,\n                        t=100,\n                    ),\n                    hovermode='closest',\n                    annotations=Annotations([\n                        Annotation(\n                            showarrow=False,\n                            text='This igraph.Graph has the graphopt layout',\n                            xref='paper',\n                            yref='paper',\n                            x=0,\n                            y=-0.1,\n                            xanchor='left',\n                            yanchor='bottom',\n                            font=Font(\n                                size=14\n                            )\n                        )\n                    ]),\n                    )\n\n    fig = Figure(data=data, layout=layout)\n\n    # use credentials of the bot \"octogrid\", if user isn't authenticated\n    login_as_bot()\n\n    try:\n        plot_id = ''.join(choice(string.lowercase) for i in range(5))\n        plot_url = plotly.plot(\n            fig, filename='Octogrid: GitHub communities for {0} [v{1}]'.format(username, plot_id))\n\n        print 'Published the network graph at {0}'.format(plot_url)\n    except Exception, e:\n        raise e"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new list of length new_length with obj.", "response": "def pad_with_object(sequence, new_length, obj=None):\n    \"\"\"\n    Returns :samp:`sequence` :obj:`list` end-padded with :samp:`{obj}`\n    elements so that the length of the returned list equals :samp:`{new_length}`.\n\n    :type sequence: iterable\n    :param sequence: Return *listified* sequence which has been end-padded.\n    :type new_length: :obj:`int`\n    :param new_length: The length of the returned list.\n    :type obj: :obj:`object`\n    :param obj: Object used as padding elements.\n    :rtype: :obj:`list`\n    :return: A :obj:`list` of length :samp:`{new_length}`.\n    :raises ValueError: if :samp:`len({sequence}) > {new_length})`.\n\n    Example::\n\n       >>> pad_with_object([1, 2, 3], 5, obj=0)\n       [1, 2, 3, 0, 0]\n       >>> pad_with_object([1, 2, 3], 5, obj=None)\n       [1, 2, 3, None, None]\n\n    \"\"\"\n    if len(sequence) < new_length:\n        sequence = \\\n            list(sequence) + [obj, ] * (new_length - len(sequence))\n    elif len(sequence) > new_length:\n        raise ValueError(\n            \"Got len(sequence)=%s which exceeds new_length=%s\"\n            %\n            (len(sequence), new_length)\n        )\n\n    return sequence"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a numpy. ndarray of n factors.", "response": "def shape_factors(n, dim=2):\n    \"\"\"\n    Returns a :obj:`numpy.ndarray` of factors :samp:`f` such\n    that :samp:`(len(f) == {dim}) and (numpy.product(f) == {n})`.\n    The returned factors are as *square* (*cubic*, etc) as possible.\n    For example::\n\n       >>> shape_factors(24, 1)\n       array([24])\n       >>> shape_factors(24, 2)\n       array([4, 6])\n       >>> shape_factors(24, 3)\n       array([2, 3, 4])\n       >>> shape_factors(24, 4)\n       array([2, 2, 2, 3])\n       >>> shape_factors(24, 5)\n       array([1, 2, 2, 2, 3])\n       >>> shape_factors(24, 6)\n       array([1, 1, 2, 2, 2, 3])\n\n    :type n: :obj:`int`\n    :param n: Integer which is factored into :samp:`{dim}` factors.\n    :type dim: :obj:`int`\n    :param dim: Number of factors.\n    :rtype: :obj:`numpy.ndarray`\n    :return: A :samp:`({dim},)` shaped array of integers which are factors of :samp:`{n}`.\n    \"\"\"\n    if dim <= 1:\n        factors = [n, ]\n    else:\n        for f in range(int(n ** (1.0 / float(dim))) + 1, 0, -1):\n            if (n % f) == 0:\n                factors = [f, ] + list(shape_factors(n // f, dim=dim - 1))\n                break\n\n    factors.sort()\n    return _np.array(factors)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_tile_shape_for_max_bytes(\n    array_shape,\n    array_itemsize,\n    max_tile_bytes,\n    max_tile_shape=None,\n    sub_tile_shape=None,\n    halo=None\n):\n    \"\"\"\n    Returns a tile shape :samp:`tile_shape`\n    such that :samp:`numpy.product(tile_shape)*numpy.sum({array_itemsize}) <= {max_tile_bytes}`.\n    Also, if :samp:`{max_tile_shape} is not None`\n    then :samp:`numpy.all(tile_shape <= {max_tile_shape}) is True` and\n    if :samp:`{sub_tile_shape} is not None`\n    the :samp:`numpy.all((tile_shape % {sub_tile_shape}) == 0) is True`.\n\n    :type array_shape: sequence of :obj:`int`\n    :param array_shape: Shape of the array which is to be split into tiles.\n    :type array_itemsize: :obj:`int`\n    :param array_itemsize: The number of bytes per element of the array to be tiled.\n    :type max_tile_bytes: :obj:`int`\n    :param max_tile_bytes: The maximum number of bytes for the returned :samp:`tile_shape`.\n    :type max_tile_shape: sequence of :obj:`int`\n    :param max_tile_shape: Per axis maximum shapes for the returned :samp:`tile_shape`.\n    :type sub_tile_shape: sequence of :obj:`int`\n    :param sub_tile_shape: The returned :samp:`tile_shape` will be an even multiple\n       of this sub-tile shape.\n    :type halo: :obj:`int`, sequence of :obj:`int`, or :samp:`(len({array_shape}), 2)`\n       shaped :obj:`numpy.ndarray`\n    :param halo: How tiles are extended in each axis direction with *halo*\n       elements. See :ref:`the-halo-parameter-examples` for meaning of :samp:`{halo}` values.\n    :rtype: :obj:`numpy.ndarray`\n    :return: A 1D array of shape :samp:`(len(array_shape),)` indicating a *tile shape*\n       which will (approximately) uniformly divide the given :samp:`{array_shape}` into\n       tiles (sub-arrays).\n\n    Examples::\n\n       >>> from array_split.split import calculate_tile_shape_for_max_bytes\n       >>> calculate_tile_shape_for_max_bytes(\n       ... array_shape=[512,],\n       ... array_itemsize=1,\n       ... max_tile_bytes=512\n       ... )\n       array([512])\n       >>> calculate_tile_shape_for_max_bytes(\n       ... array_shape=[512,],\n       ... array_itemsize=2,  # Doubling the itemsize halves the tile size.\n       ... max_tile_bytes=512\n       ... )\n       array([256])\n       >>> calculate_tile_shape_for_max_bytes(\n       ... array_shape=[512,],\n       ... array_itemsize=1,\n       ... max_tile_bytes=512-1  # tile shape will now be halved\n       ... )\n       array([256])\n\n\n    \"\"\"\n\n    logger = _logging.getLogger(__name__ + \".calculate_tile_shape_for_max_bytes\")\n    logger.debug(\"calculate_tile_shape_for_max_bytes: enter:\")\n    logger.debug(\"array_shape=%s\", array_shape)\n    logger.debug(\"array_itemsize=%s\", array_itemsize)\n    logger.debug(\"max_tile_bytes=%s\", max_tile_bytes)\n    logger.debug(\"max_tile_shape=%s\", max_tile_shape)\n    logger.debug(\"sub_tile_shape=%s\", sub_tile_shape)\n    logger.debug(\"halo=%s\", halo)\n\n    array_shape = _np.array(array_shape, dtype=\"int64\")\n    array_itemsize = _np.sum(array_itemsize, dtype=\"int64\")\n\n    if max_tile_shape is None:\n        max_tile_shape = _np.array(array_shape, copy=True)\n    max_tile_shape = \\\n        _np.array(_np.minimum(max_tile_shape, array_shape), copy=True, dtype=array_shape.dtype)\n\n    if sub_tile_shape is None:\n        sub_tile_shape = _np.ones((len(array_shape),), dtype=\"int64\")\n\n    sub_tile_shape = _np.array(sub_tile_shape, dtype=\"int64\")\n\n    halo = convert_halo_to_array_form(halo=halo, ndim=len(array_shape))\n\n    if _np.any(array_shape < sub_tile_shape):\n        raise ValueError(\n            \"Got array_shape=%s element less than corresponding sub_tile_shape=%s element.\"\n            %\n            (\n                array_shape,\n                sub_tile_shape\n            )\n        )\n\n    logger.debug(\"max_tile_shape=%s\", max_tile_shape)\n    logger.debug(\"sub_tile_shape=%s\", sub_tile_shape)\n    logger.debug(\"halo=%s\", halo)\n    array_sub_tile_split_shape = ((array_shape - 1) // sub_tile_shape) + 1\n    tile_sub_tile_split_shape = array_shape // sub_tile_shape\n    if len(tile_sub_tile_split_shape) <= 1:\n        tile_sub_tile_split_shape[0] = \\\n            int(_np.floor(\n                (\n                    (max_tile_bytes / float(array_itemsize))\n                    -\n                    _np.sum(halo)\n                )\n                /\n                float(sub_tile_shape[0])\n            ))\n\n    tile_sub_tile_split_shape = \\\n        _np.minimum(\n            tile_sub_tile_split_shape,\n            max_tile_shape // sub_tile_shape\n        )\n    logger.debug(\"Pre loop: tile_sub_tile_split_shape=%s\", tile_sub_tile_split_shape)\n\n    current_axis = 0\n    while (\n        (current_axis < len(tile_sub_tile_split_shape))\n        and\n        (\n            (\n                _np.product(tile_sub_tile_split_shape * sub_tile_shape + _np.sum(halo, axis=1))\n                *\n                array_itemsize\n            )\n            >\n            max_tile_bytes\n        )\n    ):\n        if current_axis < (len(tile_sub_tile_split_shape) - 1):\n            tile_sub_tile_split_shape[current_axis] = 1\n            tile_sub_tile_split_shape[current_axis] = \\\n                (\n                    max_tile_bytes\n                    //\n                    (\n                        _np.product(\n                            tile_sub_tile_split_shape *\n                            sub_tile_shape +\n                            _np.sum(\n                                halo,\n                                axis=1))\n                        *\n                        array_itemsize\n                    )\n            )\n            tile_sub_tile_split_shape[current_axis] = \\\n                max([1, tile_sub_tile_split_shape[current_axis]])\n        else:\n            sub_tile_shape_h = sub_tile_shape.copy()\n            sub_tile_shape_h[0:current_axis] += _np.sum(halo[0:current_axis, :], axis=1)\n            tile_sub_tile_split_shape[current_axis] = \\\n                int(_np.floor(\n                    (\n                        (max_tile_bytes / float(array_itemsize))\n                        -\n                        _np.sum(halo[current_axis]) * _np.product(sub_tile_shape_h[0:current_axis])\n                    )\n                    /\n                    float(_np.product(sub_tile_shape_h))\n                ))\n        current_axis += 1\n\n    logger.debug(\"Post loop: tile_sub_tile_split_shape=%s\", tile_sub_tile_split_shape)\n    tile_shape = _np.minimum(array_shape, tile_sub_tile_split_shape * sub_tile_shape)\n    logger.debug(\"pre cannonicalise tile_shape=%s\", tile_shape)\n\n    tile_split_shape = ((array_shape - 1) // tile_shape) + 1\n    logger.debug(\"tile_split_shape=%s\", tile_split_shape)\n\n    tile_shape = (((array_sub_tile_split_shape - 1) // tile_split_shape) + 1) * sub_tile_shape\n    logger.debug(\"post cannonicalise tile_shape=%s\", tile_shape)\n\n    return tile_shape", "response": "Calculates the tile shape for the given array and maximum number of bytes per element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the number of slices per axis for a given number of slices per axis.", "response": "def calculate_num_slices_per_axis(num_slices_per_axis, num_slices, max_slices_per_axis=None):\n    \"\"\"\n    Returns a :obj:`numpy.ndarray` (:samp:`return_array` say) where non-positive elements of\n    the :samp:`{num_slices_per_axis}` sequence have been replaced with\n    positive integer values such that :samp:`numpy.product(return_array) == num_slices`\n    and::\n\n       numpy.all(\n           return_array[numpy.where(num_slices_per_axis <= 0)]\n           <=\n           max_slices_per_axis[numpy.where(num_slices_per_axis <= 0)]\n       ) is True\n\n\n    :type num_slices_per_axis: sequence of :obj:`int`\n    :param num_slices_per_axis: Constraint for per-axis sub-divisions.\n       Non-positive elements indicate values to be replaced in the\n       returned array. Positive values are identical to the corresponding\n       element in the returned array.\n    :type num_slices: integer\n    :param num_slices: Indicates the number of slices (rectangular sub-arrays)\n       formed by performing sub-divisions per axis. The returned array :samp:`return_array`\n       has elements assigned such that :samp:`numpy.product(return_array) == {num_slices}`.\n    :type max_slices_per_axis: sequence of :obj:`int` (or :samp:`None`)\n    :param max_slices_per_axis: Constraint specifying maximum number of per-axis sub-divisions.\n       If :samp:`None` defaults to :samp:`numpy.array([numpy.inf,]*len({num_slices_per_axis}))`.\n    :rtype: :obj:`numpy.ndarray`\n    :return: An array :samp:`return_array`\n       such that :samp:`numpy.product(return_array) == num_slices`.\n\n\n    Examples::\n\n       >>> from array_split.split import calculate_num_slices_per_axis\n       >>>\n       >>> calculate_num_slices_per_axis([0, 0, 0], 16)\n       array([4, 2, 2])\n       >>> calculate_num_slices_per_axis([1, 0, 0], 16)\n       array([1, 4, 4])\n       >>> calculate_num_slices_per_axis([1, 0, 0], 16, [2, 2, 16])\n       array([1, 2, 8])\n\n\n    \"\"\"\n    logger = _logging.getLogger(__name__)\n\n    ret_array = _np.array(num_slices_per_axis, copy=True)\n    if max_slices_per_axis is None:\n        max_slices_per_axis = _np.array([_np.inf, ] * len(num_slices_per_axis))\n\n    max_slices_per_axis = _np.array(max_slices_per_axis)\n\n    if _np.any(max_slices_per_axis <= 0):\n        raise ValueError(\"Got non-positive value in max_slices_per_axis=%s\" % max_slices_per_axis)\n\n    while _np.any(ret_array <= 0):\n        prd = _np.product(ret_array[_np.where(ret_array > 0)])  # returns 1 for zero-length array\n        if (num_slices < prd) or ((num_slices % prd) > 0):\n            raise ValueError(\n                (\n                    \"Unable to construct grid of num_slices=%s elements from \"\n                    +\n                    \"num_slices_per_axis=%s (with max_slices_per_axis=%s)\"\n                )\n                %\n                (num_slices, num_slices_per_axis, max_slices_per_axis)\n            )\n        ridx = _np.where(ret_array <= 0)\n        f = shape_factors(num_slices // prd, ridx[0].shape[0])[::-1]\n        if _np.all(f < max_slices_per_axis[ridx]):\n            ret_array[ridx] = f\n        else:\n            for i in range(ridx[0].shape[0]):\n                if f[i] >= max_slices_per_axis[ridx[0][i]]:\n                    ret_array[ridx[0][i]] = max_slices_per_axis[ridx[0][i]]\n                    prd = _np.product(ret_array[_np.where(ret_array > 0)])\n                    while (num_slices % prd) > 0:\n                        ret_array[ridx[0][i]] -= 1\n                        prd = _np.product(ret_array[_np.where(ret_array > 0)])\n        logger.debug(\n            \"ridx=%s, f=%s, ret_array=%s, max_slices_per_axis=%s\",\n            ridx, f, ret_array, max_slices_per_axis\n        )\n    return ret_array"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the given Halo argument to a array form.", "response": "def convert_halo_to_array_form(halo, ndim):\n    \"\"\"\n    Converts the :samp:`{halo}` argument to a :samp:`(ndim, 2)`\n    shaped array.\n\n    :type halo: :samp:`None`, :obj:`int`, an :samp:`{ndim}` length sequence\n        of :samp:`int` or :samp:`({ndim}, 2)` shaped array\n        of :samp:`int`\n    :param halo: Halo to be converted to :samp:`({ndim}, 2)` shaped array form.\n    :type ndim: :obj:`int`\n    :param ndim: Number of dimensions.\n    :rtype: :obj:`numpy.ndarray`\n    :return: A :samp:`({ndim}, 2)` shaped array of :obj:`numpy.int64` elements.\n\n    Examples::\n\n       >>> convert_halo_to_array_form(halo=2, ndim=4)\n       array([[2, 2],\n              [2, 2],\n              [2, 2],\n              [2, 2]])\n       >>> convert_halo_to_array_form(halo=[0, 1, 2], ndim=3)\n       array([[0, 0],\n              [1, 1],\n              [2, 2]])\n       >>> convert_halo_to_array_form(halo=[[0, 1], [2, 3], [3, 4]], ndim=3)\n       array([[0, 1],\n              [2, 3],\n              [3, 4]])\n\n    \"\"\"\n    dtyp = _np.int64\n    if halo is None:\n        halo = _np.zeros((ndim, 2), dtype=dtyp)\n    elif is_scalar(halo):\n        halo = _np.zeros((ndim, 2), dtype=dtyp) + halo\n    elif (ndim == 1) and (_np.array(halo).shape == (2,)):\n        halo = _np.array([halo, ], copy=True, dtype=dtyp)\n    elif len(_np.array(halo).shape) == 1:\n        halo = _np.array([halo, halo], dtype=dtyp).T.copy()\n    else:\n        halo = _np.array(halo, copy=True, dtype=dtyp)\n\n    if halo.shape[0] != ndim:\n        raise ValueError(\n            \"Got halo.shape=%s, expecting halo.shape=(%s, 2)\"\n            %\n            (halo.shape, ndim)\n        )\n\n    return halo"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the given halo to a numpy array.", "response": "def convert_halo_to_array_form(self, halo):\n        \"\"\"\n        Converts the :samp:`{halo}` argument to a :samp:`({self}.array_shape.size, 2)`\n        shaped array.\n\n        :type halo: :samp:`None`, :obj:`int`, :samp:`self.array_shape.size` length sequence\n            of :samp:`int` or :samp:`(self.array_shape.size, 2)` shaped array\n            of :samp:`int`\n        :param halo: Halo to be converted to :samp:`(len(self.array_shape), 2)` shaped array form.\n        :rtype: :obj:`numpy.ndarray`\n        :return: A :samp:`(len(self.array_shape), 2)` shaped array of :obj:`numpy.int64` elements.\n        \"\"\"\n        return convert_halo_to_array_form(halo=halo, ndim=len(self.array_shape))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nraise : obj : ValueError if self. tile_bounds_policy is not in self. valid_tile_bounds_policies.", "response": "def check_tile_bounds_policy(self):\n        \"\"\"\n        Raises :obj:`ValueError` if :attr:`tile_bounds_policy`\n        is not in :samp:`[{self}.ARRAY_BOUNDS, {self}.NO_BOUNDS]`.\n        \"\"\"\n        if self.tile_bounds_policy not in self.valid_tile_bounds_policies:\n            raise ValueError(\n                \"Got self.tile_bounds_policy=%s, which is not in %s.\"\n                %\n                (self.tile_bounds_policy, self.valid_tile_bounds_policies)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_consistent_parameter_dimensions(self):\n        if self.indices_per_axis is not None:\n            if len(self.indices_per_axis) > len(self.array_shape):\n                raise ValueError(\n                    \"Got len(self.indices_per_axis)=%s > len(self.array_shape)=%s, should be equal.\"\n                    %\n                    (len(self.indices_per_axis), len(self.array_shape))\n                )\n        if self.split_num_slices_per_axis is not None:\n            if len(self.split_num_slices_per_axis) > len(self.array_shape):\n                raise ValueError(\n                    (\n                        \"Got len(self.split_num_slices_per_axis)=%s > len(self.array_shape)=%s,\"\n                        +\n                        \" should be equal.\"\n                    )\n                    %\n                    (len(self.split_num_slices_per_axis), len(self.array_shape))\n                )\n        if self.tile_shape is not None:\n            if len(self.tile_shape) != len(self.array_shape):\n                raise ValueError(\n                    \"Got len(self.tile_shape)=%s > len(self.array_shape)=%s, should be equal.\"\n                    %\n                    (len(self.tile_shape), len(self.array_shape))\n                )\n\n        if self.sub_tile_shape is not None:\n            if len(self.sub_tile_shape) != len(self.array_shape):\n                raise ValueError(\n                    \"Got len(self.sub_tile_shape)=%s > len(self.array_shape)=%s, should be equal.\"\n                    %\n                    (len(self.sub_tile_shape), len(self.array_shape))\n                )\n\n        if self.max_tile_shape is not None:\n            if len(self.max_tile_shape) != len(self.array_shape):\n                raise ValueError(\n                    \"Got len(self.max_tile_shape)=%s > len(self.array_shape)=%s, should be equal.\"\n                    %\n                    (len(self.max_tile_shape), len(self.array_shape))\n                )\n\n        if self.array_start is not None:\n            if len(self.array_start) != len(self.array_shape):\n                raise ValueError(\n                    \"Got len(self.array_start)=%s > len(self.array_shape)=%s, should be equal.\"\n                    %\n                    (len(self.array_start), len(self.array_shape))\n                )", "response": "Ensures that all parameter dimensions are consistent with the array_shape dimension."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_consistent_parameter_grouping(self):\n        parameter_groups = {}\n        if self.indices_per_axis is not None:\n            parameter_groups[\"indices_per_axis\"] = \\\n                {\"self.indices_per_axis\": self.indices_per_axis}\n        if (self.split_size is not None) or (self.split_num_slices_per_axis is not None):\n            parameter_groups[\"split_size\"] = \\\n                {\n                    \"self.split_size\": self.split_size,\n                    \"self.split_num_slices_per_axis\": self.split_num_slices_per_axis,\n            }\n        if self.tile_shape is not None:\n            parameter_groups[\"tile_shape\"] = \\\n                {\"self.tile_shape\": self.tile_shape}\n        if self.max_tile_bytes is not None:\n            parameter_groups[\"max_tile_bytes\"] = \\\n                {\"self.max_tile_bytes\": self.max_tile_bytes}\n        if self.max_tile_shape is not None:\n            if \"max_tile_bytes\" not in parameter_groups.keys():\n                parameter_groups[\"max_tile_bytes\"] = {}\n            parameter_groups[\"max_tile_bytes\"][\"self.max_tile_shape\"] = self.max_tile_shape\n        if self.sub_tile_shape is not None:\n            if \"max_tile_bytes\" not in parameter_groups.keys():\n                parameter_groups[\"max_tile_bytes\"] = {}\n            parameter_groups[\"max_tile_bytes\"][\"self.sub_tile_shape\"] = self.sub_tile_shape\n\n        self.logger.debug(\"parameter_groups=%s\", parameter_groups)\n\n        if len(parameter_groups.keys()) > 1:\n            group_keys = sorted(parameter_groups.keys())\n            raise ValueError(\n                \"Got conflicting parameter groups specified, \"\n                +\n                \"should only specify one group to define the split:\\n\"\n                +\n                (\n                    \"\\n\".join(\n                        [\n                            (\n                                (\"Group %18s: \" % (\"'%s'\" % group_key))\n                                +\n                                str(parameter_groups[group_key])\n                            )\n                            for group_key in group_keys\n                        ]\n                    )\n                )\n            )\n        if len(parameter_groups.keys()) <= 0:\n            raise ValueError(\n                \"No split parameters specified, need parameters from one of the groups: \"\n                +\n                \"'indices_per_axis', 'split_size', 'tile_shape' or 'max_tile_bytes'\"\n            )", "response": "Ensures that the parameters of the current object are consistent."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_tile_extent_bounds(self):\n\n        if self.tile_bounds_policy == NO_BOUNDS:\n            self.tile_beg_min = self.array_start - self.halo[:, 0]\n            self.tile_end_max = self.array_start + self.array_shape + self.halo[:, 1]\n        elif self.tile_bounds_policy == ARRAY_BOUNDS:\n            self.tile_beg_min = self.array_start\n            self.tile_end_max = self.array_start + self.array_shape", "response": "Updates the tile_beg_min and tile_end_max attributes of the data members according to the tile_bounds_policy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the split shape and split extents for each element of the array by the indices_per_axis.", "response": "def set_split_extents_by_indices_per_axis(self):\n        \"\"\"\n        Sets split shape :attr:`split_shape` and\n        split extents (:attr:`split_begs` and :attr:`split_ends`)\n        from values in :attr:`indices_per_axis`.\n        \"\"\"\n        if self.indices_per_axis is None:\n            raise ValueError(\"Got None for self.indices_per_axis\")\n\n        self.logger.debug(\"self.array_shape=%s\", self.array_shape)\n        self.logger.debug(\"self.indices_per_axis=%s\", self.indices_per_axis)\n        self.indices_per_axis = \\\n            pad_with_none(self.indices_per_axis, len(self.array_shape))\n\n        # Define the start and stop indices (extents) for each axis slice\n        self.split_shape = _np.ones(len(self.array_shape), dtype=\"int64\")\n        self.split_begs = [[], ] * len(self.array_shape)\n        self.split_ends = [[], ] * len(self.array_shape)\n        for i in range(len(self.indices_per_axis)):\n            indices = self.indices_per_axis[i]\n            if (indices is not None) and (len(indices) > 0):\n                self.split_shape[i] = len(indices) + 1\n                self.split_begs[i] = _np.zeros((len(indices) + 1,), dtype=\"int64\")\n                self.split_begs[i][1:] = indices\n                self.split_ends[i] = _np.zeros((len(self.split_begs[i]),), dtype=\"int64\")\n                self.split_ends[i][0:-1] = self.split_begs[i][1:]\n                self.split_ends[i][-1] = self.array_shape[i]\n            else:\n                # start and stop is the full width of the axis\n                self.split_begs[i] = [0, ]\n                self.split_ends[i] = [self.array_shape[i], ]\n\n        self.logger.debug(\"self.indices_per_axis=%s\", self.indices_per_axis)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_split_from_extents(self):\n        self.logger.debug(\"self.split_shape=%s\", self.split_shape)\n        self.logger.debug(\"self.split_begs=%s\", self.split_begs)\n        self.logger.debug(\"self.split_ends=%s\", self.split_ends)\n\n        ret = \\\n            _np.array(\n                [\n                    tuple(\n                        [\n                            slice(\n                                max([\n                                    self.split_begs[d][idx[d]]\n                                    + self.array_start[d]\n                                    - self.halo[d, 0]\n                                    * (self.split_ends[d][idx[d]] > self.split_begs[d][idx[d]]),\n                                    self.tile_beg_min[d]\n                                ]),\n                                min([\n                                    self.split_ends[d][idx[d]]\n                                    + self.array_start[d]\n                                    + self.halo[d, 1]\n                                    * (self.split_ends[d][idx[d]] > self.split_begs[d][idx[d]]),\n                                    self.tile_end_max[d]\n                                ])\n                            )\n                            for d in range(len(self.split_shape))\n                        ]\n                    )\n                    for idx in\n                    _np.array(\n                        _np.unravel_index(\n                            _np.arange(0, _np.product(self.split_shape)),\n                            self.split_shape\n                        )\n                    ).T\n                ],\n                dtype=[(\"%d\" % d, \"object\") for d in range(len(self.split_shape))]\n            ).reshape(self.split_shape)\n\n        return ret", "response": "Calculates the split array from the extents obtained by the split_begs and split_ends."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndivide :samp:`range(0, {size})` into (approximately) equal sized intervals. Returns :samp:`(begs, ends)` where :samp:`slice(begs[i], ends[i])` define the intervals for :samp:`i in range(0, {num_sections})`. :type num_sections: :obj:`int` :param num_sections: Divide :samp:`range(0, {size})` into this many intervals (approximately) equal sized intervals. :type size: :obj:`int` :param size: Range for the subdivision. :rtype: :obj:`tuple` :return: Two element tuple :samp:`(begs, ends)` such that :samp:`slice(begs[i], ends[i])` define the intervals for :samp:`i in range(0, {num_sections})`.", "response": "def calculate_axis_split_extents(self, num_sections, size):\n        \"\"\"\n        Divides :samp:`range(0, {size})` into (approximately) equal sized\n        intervals. Returns :samp:`(begs, ends)` where :samp:`slice(begs[i], ends[i])`\n        define the intervals for :samp:`i in range(0, {num_sections})`.\n\n        :type num_sections: :obj:`int`\n        :param num_sections: Divide  :samp:`range(0, {size})` into this\n           many intervals (approximately) equal sized intervals.\n        :type size: :obj:`int`\n        :param size: Range for the subdivision.\n        :rtype: :obj:`tuple`\n        :return: Two element tuple :samp:`(begs, ends)`\n           such that :samp:`slice(begs[i], ends[i])` define the\n           intervals for :samp:`i in range(0, {num_sections})`.\n\n        \"\"\"\n        section_size = size // num_sections\n        if section_size >= 1:\n            begs = _np.arange(0, section_size * num_sections, section_size)\n            rem = size - section_size * num_sections\n            if rem > 0:\n                for i in range(rem):\n                    begs[i + 1:] += 1\n            ends = _np.zeros_like(begs)\n            ends[0:-1] = begs[1:]\n            ends[-1] = size\n        else:\n            begs = _np.arange(0, num_sections)\n            begs[size:] = size\n            ends = begs.copy()\n            ends[0:-1] = begs[1:]\n\n        return begs, ends"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_split_extents_by_split_size(self):\n\n        if self.split_size is None:\n            if (\n                _np.all([s is not None for s in self.split_num_slices_per_axis])\n                and\n                _np.all([s > 0 for s in self.split_num_slices_per_axis])\n            ):\n                self.split_size = _np.product(self.split_num_slices_per_axis)\n            else:\n                raise ValueError(\n                    (\n                        \"Got invalid self.split_num_slices_per_axis=%s, all elements \"\n                        +\n                        \"need to be integers greater than zero when self.split_size is None.\"\n                    )\n                    %\n                    self.split_num_slices_per_axis\n                )\n        self.logger.debug(\n            \"Pre  cannonicalise: self.split_num_slices_per_axis=%s\",\n            self.split_num_slices_per_axis)\n        self.split_num_slices_per_axis = \\\n            calculate_num_slices_per_axis(\n                self.split_num_slices_per_axis,\n                self.split_size,\n                self.array_shape\n            )\n        self.logger.debug(\n            \"Post cannonicalise: self.split_num_slices_per_axis=%s\",\n            self.split_num_slices_per_axis)\n        # Define the start and stop indices (extents) for each axis slice\n        self.split_shape = self.split_num_slices_per_axis.copy()\n        self.split_begs = [[], ] * len(self.array_shape)\n        self.split_ends = [[], ] * len(self.array_shape)\n        for i in range(len(self.array_shape)):\n            self.split_begs[i], self.split_ends[i] = \\\n                self.calculate_axis_split_extents(\n                    self.split_shape[i],\n                    self.array_shape[i]\n            )", "response": "Sets split shape split extents and split num_slices_per_axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_split_extents_by_tile_shape(self):\n        self.split_shape = ((self.array_shape - 1) // self.tile_shape) + 1\n        self.split_begs = [[], ] * len(self.array_shape)\n        self.split_ends = [[], ] * len(self.array_shape)\n        for i in range(len(self.array_shape)):\n            self.split_begs[i] = _np.arange(0, self.array_shape[i], self.tile_shape[i])\n            self.split_ends[i] = _np.zeros_like(self.split_begs[i])\n            self.split_ends[i][0:-1] = self.split_begs[i][1:]\n            self.split_ends[i][-1] = self.array_shape[i]", "response": "Sets split shape and split extents by tile shape."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_split_extents_by_tile_max_bytes(self):\n        self.tile_shape = \\\n            calculate_tile_shape_for_max_bytes(\n                array_shape=self.array_shape,\n                array_itemsize=self.array_itemsize,\n                max_tile_bytes=self.max_tile_bytes,\n                max_tile_shape=self.max_tile_shape,\n                sub_tile_shape=self.sub_tile_shape,\n                halo=self.halo\n            )\n        self.set_split_extents_by_tile_shape()", "response": "Sets the split extents for the species based on the max_bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the split extents of the species.", "response": "def set_split_extents(self):\n        \"\"\"\n        Sets split extents (:attr:`split_begs`\n        and :attr:`split_ends`) calculated using\n        selected attributes set from :meth:`__init__`.\n        \"\"\"\n\n        self.check_split_parameters()\n        self.update_tile_extent_bounds()\n\n        if self.indices_per_axis is not None:\n            self.set_split_extents_by_indices_per_axis()\n        elif (self.split_size is not None) or (self.split_num_slices_per_axis is not None):\n            self.set_split_extents_by_split_size()\n        elif self.tile_shape is not None:\n            self.set_split_extents_by_tile_shape()\n        elif self.max_tile_bytes is not None:\n            self.set_split_extents_by_tile_max_bytes()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the subelements from the xml_element in its correspondent classes.", "response": "def load_children(self):\n        \"\"\"\n        Load the subelements from the xml_element in its correspondent classes.\n\n        :returns: List of child objects.\n        :rtype: list\n        :raises CardinalityException: If there is more than one Version child.\n        :raises CardinalityException: If there is no Version child.\n        :raises CardinalityException: If there is no Profile element.\n        \"\"\"\n        # Containers\n        children = list()\n        statuses = list()\n        version = None\n        profiles = list()\n\n        # Element load\n        for element in self.xml_element:\n            uri, tag = Element.get_namespace_and_tag(element.tag)\n            if tag == 'version':\n                if version is None:\n                    version = TailoringVersion(element)\n                else:\n                    error_msg = 'version element found more than once'\n                    raise CardinalityException(error_msg)\n            elif tag == 'status':\n                statuses.append(Status(element))\n            elif tag == 'Profile':\n                profiles.append(Profile(element))\n\n        # Element validation\n        if version is None:\n            error_msg = 'version element is required'\n            raise CardinalityException(error_msg)\n        if len(profiles) <= 0:\n            error_msg = 'Profile element is required at least once'\n            raise CardinalityException(error_msg)\n\n        # List construction\n        children.extend(statuses)\n        if version is not None:\n            children.append(version)\n        children.extend(profiles)\n\n        return children"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_xml_element(self):\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        self.xml_element.clear()\n        self.xml_element.set('id', self.id)\n\n        for child in self.children:\n            child.update_xml_element()\n            self.xml_element.append(child.xml_element)\n\n        return self.xml_element", "response": "Updates the xml element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_predictor(regressor=LassoLarsIC(fit_intercept=False),\n                   Selector=GridSearchCV, fourier_degree=(2, 25),\n                   selector_processes=1,\n                   use_baart=False, scoring='r2', scoring_cv=3,\n                   **kwargs):\n    \"\"\"make_predictor(regressor=LassoLarsIC(fit_intercept=False), Selector=GridSearchCV, fourier_degree=(2, 25), selector_processes=1, use_baart=False, scoring='r2', scoring_cv=3, **kwargs)\n\n    Makes a predictor object for use in :func:`get_lightcurve`.\n\n    **Parameters**\n\n    regressor : object with \"fit\" and \"transform\" methods, optional\n        Regression object used for solving Fourier matrix\n        (default ``sklearn.linear_model.LassoLarsIC(fit_intercept=False)``).\n    Selector : class with \"fit\" and \"predict\" methods, optional\n        Model selection class used for finding the best fit\n        (default :class:`sklearn.grid_search.GridSearchCV`).\n    selector_processes : positive integer, optional\n        Number of processes to use for *Selector* (default 1).\n    use_baart : boolean, optional\n        If True, ignores *Selector* and uses Baart's Criteria to find\n        the Fourier degree, within the boundaries (default False).\n    fourier_degree : 2-tuple, optional\n        Tuple containing lower and upper bounds on Fourier degree, in that\n        order (default (2, 25)).\n    scoring : str, optional\n        Scoring method to use for *Selector*. This parameter can be:\n            * \"r2\", in which case use :math:`R^2` (the default)\n            * \"mse\", in which case use mean square error\n    scoring_cv : positive integer, optional\n        Number of cross validation folds used in scoring (default 3).\n\n    **Returns**\n\n    out : object with \"fit\" and \"predict\" methods\n        The created predictor object.\n    \"\"\"\n    fourier = Fourier(degree_range=fourier_degree, regressor=regressor) \\\n              if use_baart else Fourier()\n    pipeline = Pipeline([('Fourier', fourier), ('Regressor', regressor)])\n    if use_baart:\n        return pipeline\n    else:\n        params = {'Fourier__degree': list(range(fourier_degree[0],\n                                                fourier_degree[1]+1))}\n        return Selector(pipeline, params, scoring=scoring, cv=scoring_cv,\n                        n_jobs=selector_processes)", "response": "Make a predictor object for use in a single cluster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new object with the light curves obtained from the given data.", "response": "def get_lightcurve(data, copy=False, name=None,\n                   predictor=None, periodogram=Lomb_Scargle,\n                   sigma_clipping=mad,\n                   scoring='r2', scoring_cv=3, scoring_processes=1,\n                   period=None, min_period=0.2, max_period=32,\n                   coarse_precision=1e-5, fine_precision=1e-9,\n                   period_processes=1,\n                   sigma=20,\n                   shift=None,\n                   min_phase_cover=0.0, min_observations=1, n_phases=100,\n                   verbosity=None, **kwargs):\n    \"\"\"get_lightcurve(data, copy=False, name=None, predictor=None, periodogram=Lomb_Scargle, sigma_clipping=mad, scoring='r2', scoring_cv=3, scoring_processes=1, period=None, min_period=0.2, max_period=32, coarse_precision=1e-5, fine_precision=1e-9, period_processes=1, sigma=20, shift=None, min_phase_cover=0.0, n_phases=100, verbosity=None, **kwargs)\n\n    Fits a light curve to the given `data` using the specified methods,\n    with default behavior defined for all methods.\n\n    **Parameters**\n\n    data : array-like, shape = [n_samples, 2] or [n_samples, 3]\n        Photometry array with columns *time*, *magnitude*, and (optional)\n        *error*. *time* should be unphased.\n    name : string or None, optional\n        Name of star being processed.\n    predictor : object that has \"fit\" and \"predict\" methods, optional\n        Object which fits the light curve obtained from *data* after rephasing\n        (default ``make_predictor(scoring=scoring, scoring_cv=scoring_cv)``).\n    periodogram : function, optional\n        Function which finds one or more *period*\\s. If *period* is already\n        provided, the function is not used. Defaults to\n        :func:`plotypus.periodogram.Lomb_Scargle`\n    sigma_clipping : function, optional\n        Function which takes an array and assigns sigma scores to each element.\n        Defaults to :func:`plotypus.utils.mad`.\n    scoring : str, optional\n        Scoring method used by *predictor*. This parameter can be\n            * \"r2\", in which case use :func:`R^2` (the default)\n            * \"mse\", in which case use mean square error\n    scoring_cv : positive integer, optional\n        Number of cross validation folds used in scoring (default 3).\n    scoring_processes : positive integer, optional\n        Number of processes to use for scoring cross validation (default 1).\n    period : number or None, optional\n        Period of oscillation used in the fit. This parameter can be:\n            * None, in which case the period is obtained with the given\n              *periodogram* function (the default).\n            * A single positive number, giving the period to phase *data*.\n    min_period : non-negative number, optional\n        Lower bound on period obtained by *periodogram* (default 0.2).\n    max_period : non-negative number, optional\n        Upper bound on period obtained by *periodogram* (default 32.0).\n    course_precision : positive number, optional\n        Precision used in first period search sweep (default 1e-5).\n    fine_precision : positive number, optional\n        Precision used in second period search sweep (default 1e-9).\n    period_processes : positive integer, optional\n        Number of processes to use for period finding (default 1).\n    sigma : number, optional\n        Upper bound on score obtained by *sigma_clipping* for a point to be\n        considered an inlier.\n    shift : number or None, optional\n        Phase shift to apply to light curve if provided. Light curve is shifted\n        such that max light occurs at ``phase[0]`` if None given (default None).\n    min_phase_cover : number on interval [0, 1], optional\n        Fraction of binned light curve that must contain points in order to\n        proceed. If light curve has insufficient coverage, a warning is\n        printed if \"outlier\" *verbosity* is on, and None is returned\n        (default 0.0).\n    n_phases : positive integer\n        Number of equally spaced phases to predict magnitudes at (default 100)\n    verbosity : list or None, optional\n        Verbosity level. See :func:`plotypus.utils.verbose_print`.\n\n    **Returns**\n\n    out : dict\n        Results of the fit in a dictionary. The keys are:\n            * name : str or None\n                The name of the star.\n            * period : number\n                The star's period.\n            * lightcurve : array-like, shape = [n_phases]\n                Magnitudes of fitted light curve sampled at sample phases.\n            * coefficients : array-like, shape = [n_coeffs]\n                Fitted light curve coefficients.\n            * dA_0 : non-negative number\n                Error on mean magnitude.\n            * phased_data : array-like, shape = [n_samples]\n                *data* transformed from temporal to phase space.\n            * model : predictor object\n                The predictor used to fit the light curve.\n            * R2 : number\n                The :math:`R^2` score of the fit.\n            * MSE : number\n                The mean square error of the fit.\n            * degree : positive integer\n                The degree of the Fourier fit.\n            * shift : number\n                The phase shift applied.\n            * coverage : number on interval [0, 1]\n                The light curve coverage.\n\n    **See also**\n\n    :func:`get_lightcurve_from_file`\n    \"\"\"\n    data = numpy.ma.array(data, copy=copy)\n    phases = numpy.linspace(0, 1, n_phases, endpoint=False)\n# TODO ###\n# Replace dA_0 with error matrix dA\n    if predictor is None:\n        predictor = make_predictor(scoring=scoring, scoring_cv=scoring_cv)\n\n    while True:\n        signal = get_signal(data)\n        if len(signal) <= scoring_cv:\n            verbose_print(\n                \"{}: length of signal ({}) less than cv folds ({})\".format(\n                    name, len(signal), scoring_cv),\n                operation=\"coverage\", verbosity=verbosity)\n            return\n        elif len(signal) < min_observations:\n            verbose_print(\n                \"{}: length of signal ({}) \"\n                \"less than min_observations ({})\".format(\n                    name, len(signal), min_observations),\n                operation=\"coverage\", verbosity=verbosity)\n            return\n        # Find the period of the inliers\n        if period is not None:\n            _period = period\n        else:\n            verbose_print(\"{}: finding period\".format(name),\n                          operation=\"period\", verbosity=verbosity)\n            _period = find_period(signal,\n                                  min_period, max_period,\n                                  coarse_precision, fine_precision,\n                                  periodogram, period_processes)\n\n        verbose_print(\"{}: using period {}\".format(name, _period),\n                      operation=\"period\", verbosity=verbosity)\n        phase, mag, *err = rephase(signal, _period).T\n\n# TODO ###\n# Generalize number of bins to function parameter ``coverage_bins``, which\n# defaults to 100, the current hard-coded behavior\n        # Determine whether there is sufficient phase coverage\n        coverage = numpy.zeros((100))\n        for p in phase:\n            coverage[int(floor(p*100))] = 1\n        coverage = sum(coverage)/100\n        if coverage < min_phase_cover:\n            verbose_print(\"{}: {} {}\".format(name, coverage, min_phase_cover),\n                          operation=\"coverage\",\n                          verbosity=verbosity)\n            verbose_print(\"Insufficient phase coverage\",\n                          operation=\"outlier\",\n                          verbosity=verbosity)\n            return\n\n        # Predict light curve\n        with warnings.catch_warnings(record=True) as w:\n            try:\n                predictor = predictor.fit(colvec(phase), mag)\n            except Warning:\n                # not sure if this should be only in verbose mode\n                print(name, w, file=stderr)\n                return\n\n        # Reject outliers and repeat the process if there are any\n        if sigma:\n            outliers = find_outliers(rephase(data.data, _period), predictor,\n                                     sigma, sigma_clipping)\n            num_outliers = sum(outliers)[0]\n            if num_outliers == 0 or \\\n               set.issubset(set(numpy.nonzero(outliers.T[0])[0]),\n                            set(numpy.nonzero(data.mask.T[0])[0])):\n                data.mask = outliers\n                break\n            if num_outliers > 0:\n                verbose_print(\"{}: {} outliers\".format(name, sum(outliers)[0]),\n                              operation=\"outlier\",\n                              verbosity=verbosity)\n            data.mask = numpy.ma.mask_or(data.mask, outliers)\n\n    # Build light curve and optionally shift to max light\n    lightcurve = predictor.predict([[i] for i in phases])\n    if shift is None:\n        arg_max_light = lightcurve.argmin()\n        lightcurve = numpy.concatenate((lightcurve[arg_max_light:],\n                                        lightcurve[:arg_max_light]))\n        shift = arg_max_light/len(phases)\n\n    data.T[0] = rephase(data.data, _period, shift).T[0]\n\n    # Grab the coefficients from the model\n    coefficients = predictor.named_steps['Regressor'].coef_ \\\n        if isinstance(predictor, Pipeline) \\\n        else predictor.best_estimator_.named_steps['Regressor'].coef_,\n\n    # compute R^2 and MSE if they haven't already been\n    # (one or zero have been computed, depending on the predictor)\n    estimator = predictor.best_estimator_ \\\n        if hasattr(predictor, 'best_estimator_') \\\n        else predictor\n\n    get_score = lambda scoring: predictor.best_score_ \\\n        if hasattr(predictor, 'best_score_') \\\n        and predictor.scoring == scoring \\\n        else cross_val_score(estimator, colvec(phase), mag,\n                             cv=scoring_cv, scoring=scoring,\n                             n_jobs=scoring_processes).mean()\n\n    return {'name':         name,\n            'period':       _period,\n            'lightcurve':   lightcurve,\n            'coefficients': coefficients[0],\n            'dA_0':         sem(lightcurve),\n            'phased_data':  data,\n            'model':        predictor,\n            'R2':           get_score('r2'),\n            'MSE':          abs(get_score('mean_squared_error')),\n            'degree':       estimator.get_params()['Fourier__degree'],\n            'shift':        shift,\n            'coverage':     coverage}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding outliers in a given data set.", "response": "def find_outliers(data, predictor, sigma,\n                  method=mad):\n    \"\"\"find_outliers(data, predictor, sigma, method=mad)\n\n    Returns a boolean array indicating the outliers in the given *data* array.\n\n    **Parameters**\n\n    data : array-like, shape = [n_samples, 2] or [n_samples, 3]\n        Photometry array containing columns *phase*, *magnitude*, and\n        (optional) *error*.\n    predictor : object that has \"fit\" and \"predict\" methods, optional\n        Object which fits the light curve obtained from *data* after rephasing.\n    sigma : number\n        Outlier cutoff criteria.\n    method : function, optional\n        Function to score residuals for outlier detection\n        (default :func:`plotypus.utils.mad`).\n\n    **Returns**\n\n    out : array-like, shape = data.shape\n        Boolean array indicating the outliers in the given *data* array.\n    \"\"\"\n    phase, mag, *err = data.T\n    residuals = numpy.absolute(predictor.predict(colvec(phase)) - mag)\n    outliers = numpy.logical_and((residuals > err[0]) if err else True,\n                                 residuals > sigma * method(residuals))\n\n    return numpy.tile(numpy.vstack(outliers), data.shape[1])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to plot a lightcurve.", "response": "def plot_lightcurve(name, lightcurve, period, data,\n                    output='.', legend=False, sanitize_latex=False,\n                    color=True, n_phases=100,\n                    err_const=0.005,\n                    **kwargs):\n    \"\"\"plot_lightcurve(name, lightcurve, period, data, output='.', legend=False, color=True, n_phases=100, err_const=0.005, **kwargs)\n\n    Save a plot of the given *lightcurve* to directory *output*.\n\n    **Parameters**\n\n    name : str\n        Name of the star. Used in filename and plot title.\n    lightcurve : array-like, shape = [n_samples]\n        Fitted lightcurve.\n    period : number\n        Period to phase time by.\n    data : array-like, shape = [n_samples, 2] or [n_samples, 3]\n        Photometry array containing columns *time*, *magnitude*, and\n        (optional) *error*. *time* should be unphased.\n    output : str, optional\n        Directory to save plot to (default '.').\n    legend : boolean, optional\n        Whether or not to display legend on plot (default False).\n    color : boolean, optional\n        Whether or not to display color in plot (default True).\n    n_phases : integer, optional\n        Number of phase points in fit (default 100).\n    err_const : number, optional\n        Constant to use in absence of error (default 0.005).\n\n    **Returns**\n\n    None\n    \"\"\"\n    phases = numpy.linspace(0, 1, n_phases, endpoint=False)\n    ax = plt.gca()\n    ax.invert_yaxis()\n    plt.xlim(0,2)\n\n    # Plot points used\n    phase, mag, *err = get_signal(data).T\n\n    error = err[0] if err else mag*err_const\n\n    inliers = plt.errorbar(numpy.hstack((phase,1+phase)),\n                           numpy.hstack((mag, mag)),\n                           yerr=numpy.hstack((error, error)),\n                           ls='None',\n                           ms=.01, mew=.01, capsize=0)\n\n    # Plot outliers rejected\n    phase, mag, *err = get_noise(data).T\n\n    error = err[0] if err else mag*err_const\n\n    outliers = plt.errorbar(numpy.hstack((phase,1+phase)),\n                            numpy.hstack((mag, mag)),\n                            yerr=numpy.hstack((error, error)),\n                            ls='None', marker='o' if color else 'x',\n                            ms=.01 if color else 4,\n                            mew=.01 if color else 1,\n                            capsize=0 if color else 1)\n\n    # Plot the fitted light curve\n    signal, = plt.plot(numpy.hstack((phases,1+phases)),\n                       numpy.hstack((lightcurve, lightcurve)),\n                       linewidth=1)\n\n    if legend:\n        plt.legend([signal, inliers, outliers],\n                   [\"Light Curve\", \"Inliers\", \"Outliers\"],\n                   loc='best')\n\n    plt.xlabel('Phase ({0:0.7} day period)'.format(period))\n    plt.ylabel('Magnitude')\n\n    plt.title(utils.sanitize_latex(name) if sanitize_latex else name)\n    plt.tight_layout(pad=0.1)\n    make_sure_path_exists(output)\n    plt.savefig(path.join(output, name))\n    plt.clf()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate and register a new socket.", "response": "def socket(self, socket_type, identity=None, mechanism=None):\n        \"\"\"\n        Create and register a new socket.\n\n        :param socket_type: The type of the socket.\n        :param loop: An optional event loop to associate the socket with.\n\n        This is the preferred method to create new sockets.\n        \"\"\"\n        socket = Socket(\n            context=self,\n            socket_type=socket_type,\n            identity=identity,\n            mechanism=mechanism,\n            loop=self.loop,\n        )\n        self.register_child(socket)\n        return socket"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform a record into an intermediate representation.", "response": "def transform_record(self, pid, record, links_factory=None):\n        \"\"\"Transform record into an intermediate representation.\n\n        :param pid: The :class:`invenio_pidstore.models.PersistentIdentifier`\n            instance.\n        :param record: The :class:`invenio_records.api.Record` instance.\n        :param links_factory: The link factory. (Default: ``None``)\n        :returns: The intermediate representation for the record.\n        \"\"\"\n        return self.dump(self.preprocess_record(pid, record,\n                         links_factory=links_factory))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransform a search result hit into an intermediate representation.", "response": "def transform_search_hit(self, pid, record_hit, links_factory=None):\n        \"\"\"Transform search result hit into an intermediate representation.\n\n        :param pid: The :class:`invenio_pidstore.models.PersistentIdentifier`\n            instance.\n        :param record_hit: A dictionary containing a ``'_source'`` key with\n            the record data.\n        :param links_factory: The link factory. (Default: ``None``)\n        :returns: The intermediate representation for the record.\n        \"\"\"\n        return self.dump(self.preprocess_search_hit(pid, record_hit,\n                         links_factory=links_factory))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef contains_repository(cls, context, directory):\n        directory = cls.get_vcs_directory(context, directory)\n        return context.is_file(os.path.join(directory, 'config'))", "response": "Check whether the given directory contains a local repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the pathname of the directory containing the version control metadata files.", "response": "def get_vcs_directory(context, directory):\n        \"\"\"Get the pathname of the directory containing the version control metadata files.\"\"\"\n        nested = os.path.join(directory, '.git')\n        return nested if context.is_directory(nested) else directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a boolean indicating whether the local repository is clean.", "response": "def is_clean(self):\n        \"\"\"\n        :data:`True` if the working tree (and index) is clean, :data:`False` otherwise.\n\n        The implementation of :attr:`GitRepo.is_clean` checks whether ``git\n        diff`` reports any differences. This command has several variants:\n\n        1. ``git diff`` shows the difference between the index and working tree.\n        2. ``git diff --cached`` shows the difference between the last commit and index.\n        3. ``git diff HEAD`` shows the difference between the last commit and working tree.\n\n        The implementation of :attr:`GitRepo.is_clean` uses the third command\n        (``git diff HEAD``) in an attempt to hide the existence of git's index\n        from callers that are trying to write code that works with Git and\n        Mercurial using the same Python API.\n        \"\"\"\n        # Make sure the local repository exists.\n        self.create()\n        # Check whether the `git diff HEAD' output is empty.\n        listing = self.context.capture('git', 'diff', 'HEAD', check=False, silent=True)\n        return len(listing.splitlines()) == 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef known_remotes(self):\n        objects = []\n        for line in self.context.capture('git', 'remote', '--verbose').splitlines():\n            tokens = line.split()\n            if len(tokens) >= 2:\n                name = tokens[0]\n                objects.append(Remote(\n                    default=(name == 'origin'),\n                    location=tokens[1], name=name, repository=self,\n                    # We fall back to allowing both roles when we fail to\n                    # recognize either role because:\n                    #\n                    #  1. This code is relatively new and may be buggy.\n                    #  2. Practically speaking most git repositories will use\n                    #     the same remote for pushing and pulling and in fact\n                    #     this remote is likely to be the only remote :-).\n                    roles=(['pull'] if '(fetch)' in tokens\n                           else (['push'] if '(push)' in tokens\n                           else (['push', 'pull']))),\n                ))\n        return objects", "response": "The names of the configured remote repositories ( a list of : class :. Remote objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge_conflicts(self):\n        filenames = set()\n        listing = self.context.capture('git', 'ls-files', '--unmerged', '-z')\n        for entry in split(listing, '\\0'):\n            # The output of `git ls-files --unmerged -z' consists of two\n            # tab-delimited fields per zero-byte terminated record, where the\n            # first field contains metadata and the second field contains the\n            # filename. A single filename can be output more than once.\n            metadata, _, name = entry.partition('\\t')\n            if metadata and name:\n                filenames.add(name)\n        return sorted(filenames)", "response": "The filenames of any files with merge conflicts ( a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expand_branch_name(self, name):\n        # If no name is given we pick the default revision.\n        if not name:\n            return self.default_revision\n        # Run `git for-each-ref' once and remember the results.\n        branches = list(self.find_branches_raw())\n        # Check for an exact match against a local branch.\n        for prefix, other_name, revision_id in branches:\n            if prefix == 'refs/heads/' and name == other_name:\n                # If we find a local branch whose name exactly matches the name\n                # given by the caller then we consider the argument given by\n                # the caller unambiguous.\n                logger.debug(\"Branch name %r matches local branch.\", name)\n                return name\n        # Check for an exact match against a remote branch.\n        for prefix, other_name, revision_id in branches:\n            if prefix.startswith('refs/remotes/') and name == other_name:\n                # If we find a remote branch whose name exactly matches the\n                # name given by the caller then we expand the name given by the\n                # caller into the full %(refname) emitted by `git for-each-ref'.\n                unambiguous_name = prefix + name\n                logger.debug(\"Branch name %r matches remote branch %r.\", name, unambiguous_name)\n                return unambiguous_name\n        # As a fall back we return the given name without expanding it.\n        # This code path might not be necessary but was added out of\n        # conservativeness, with the goal of trying to guarantee\n        # backwards compatibility.\n        logger.debug(\"Failed to expand branch name %r.\", name)\n        return name", "response": "Expand branch names to their unambiguous form."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the author information from the version control system.", "response": "def find_author(self):\n        \"\"\"Get the author information from the version control system.\"\"\"\n        return Author(name=self.context.capture('git', 'config', 'user.name', check=False, silent=True),\n                      email=self.context.capture('git', 'config', 'user.email', check=False, silent=True))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding information about the branches in the repository.", "response": "def find_branches(self):\n        \"\"\"Find information about the branches in the repository.\"\"\"\n        for prefix, name, revision_id in self.find_branches_raw():\n            yield Revision(\n                branch=name,\n                repository=self,\n                revision_id=revision_id,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_branches_raw(self):\n        listing = self.context.capture('git', 'for-each-ref', '--format=%(refname)\\t%(objectname)')\n        for line in listing.splitlines():\n            match = FOR_EACH_REF_PATTERN.match(line)\n            if match and match.group('name') != 'HEAD':\n                yield (match.group('prefix'),\n                       match.group('name'),\n                       match.group('revision_id'))", "response": "Find information about the branches in the repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_revision_id(self, revision=None):\n        # Make sure the local repository exists.\n        self.create()\n        # Try to find the revision id of the specified revision.\n        revision = self.expand_branch_name(revision)\n        output = self.context.capture('git', 'rev-parse', revision)\n        # Validate the `git rev-parse' output.\n        return self.ensure_hexadecimal_string(output, 'git rev-parse')", "response": "Find the global revision id of the given revision."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the local revision number of the given revision.", "response": "def find_revision_number(self, revision=None):\n        \"\"\"Find the local revision number of the given revision.\"\"\"\n        # Make sure the local repository exists.\n        self.create()\n        # Try to find the revision number of the specified revision.\n        revision = self.expand_branch_name(revision)\n        output = self.context.capture('git', 'rev-list', revision, '--count')\n        if not (output and output.isdigit()):\n            msg = \"Failed to find local revision number! ('git rev-list --count' gave unexpected output)\"\n            raise ValueError(msg)\n        return int(output)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_tags(self):\n        listing = self.context.capture('git', 'show-ref', '--tags', check=False)\n        for line in listing.splitlines():\n            tokens = line.split()\n            if len(tokens) >= 2 and tokens[1].startswith('refs/tags/'):\n                yield Revision(\n                    repository=self,\n                    revision_id=tokens[0],\n                    tag=tokens[1][len('refs/tags/'):],\n                )", "response": "Find information about the tags in the repository."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_add_files_command(self, *filenames):\n        command = ['git', 'add']\n        if filenames:\n            command.append('--')\n            command.extend(filenames)\n        else:\n            command.extend(('--all', '.'))\n        return command", "response": "Get the command to include added and removed files in the next commit."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the command to commit changes to tracked files in the working tree.", "response": "def get_commit_command(self, message, author=None):\n        \"\"\"Get the command to commit changes to tracked files in the working tree.\"\"\"\n        command = ['git']\n        if author:\n            command.extend(('-c', 'user.name=%s' % author.name))\n            command.extend(('-c', 'user.email=%s' % author.email))\n        command.append('commit')\n        command.append('--all')\n        command.append('--message')\n        command.append(message)\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the command to create the local repository.", "response": "def get_create_command(self):\n        \"\"\"Get the command to create the local repository.\"\"\"\n        command = ['git', 'clone' if self.remote else 'init']\n        if self.bare:\n            command.append('--bare')\n        if self.remote:\n            command.append(self.remote)\n        command.append(self.local)\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_export_command(self, directory, revision):\n        shell_command = 'git archive %s | tar --extract --directory=%s'\n        return [shell_command % (quote(revision), quote(directory))]", "response": "Get the command to export the complete tree from the local repository."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_merge_command(self, revision):\n        return [\n            'git',\n            '-c', 'user.name=%s' % self.author.name,\n            '-c', 'user.email=%s' % self.author.email,\n            'merge', '--no-commit', '--no-ff',\n            revision,\n        ]", "response": "Get the command to merge a revision into the current branch."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the command to pull changes from a remote repository into a local repository.", "response": "def get_pull_command(self, remote=None, revision=None):\n        \"\"\"\n        Get the command to pull changes from a remote repository into the local repository.\n\n        When you pull a specific branch using git, the default behavior is to\n        pull the change sets from the remote branch into the local repository\n        and merge them into the *currently checked out* branch.\n\n        What Mercurial does is to pull the change sets from the remote branch\n        into the local repository and create a local branch whose contents\n        mirror those of the remote branch. Merging is left to the operator.\n\n        In my opinion the default behavior of Mercurial is more sane and\n        predictable than the default behavior of git and so :class:`GitRepo`\n        tries to emulate the default behavior of Mercurial.\n\n        When a specific revision is pulled, the revision is assumed to be a\n        branch name and git is instructed to pull the change sets from the\n        remote branch into a local branch with the same name.\n\n        .. warning:: The logic described above will undoubtedly break when\n                     `revision` is given but is not a branch name. I'd fix\n                     this if I knew how to, but I don't...\n        \"\"\"\n        if revision:\n            revision = '%s:%s' % (revision, revision)\n        if self.bare:\n            return [\n                'git', 'fetch',\n                remote or 'origin',\n                # http://stackoverflow.com/a/10697486\n                revision or '+refs/heads/*:refs/heads/*',\n            ]\n        else:\n            command = ['git', 'pull']\n            if remote or revision:\n                command.append(remote or 'origin')\n                if revision:\n                    command.append(revision)\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the command to push changes from the local repository to a remote repository.", "response": "def get_push_command(self, remote=None, revision=None):\n        \"\"\"Get the command to push changes from the local repository to a remote repository.\"\"\"\n        # TODO What about tags?\n        command = ['git', '-c', 'push.default=matching', 'push']\n        if remote or revision:\n            command.append(remote or 'origin')\n            if revision:\n                command.append(revision)\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new instance based on the Settings object", "response": "def new(cls, settings, *args, **kwargs):\n        \"\"\"\n        Create a new Cloud instance based on the Settings\n        \"\"\"\n        logger.debug('Initializing new \"%s\" Instance object' % settings['CLOUD'])\n        cloud = settings['CLOUD']\n        if cloud == 'bare':\n            self = BareInstance(settings=settings, *args, **kwargs)\n        elif cloud == 'aws':\n            self = AWSInstance(settings=settings, *args, **kwargs)\n        elif cloud == 'gcp':\n            self = GCPInstance(settings=settings, *args, **kwargs)\n        else:\n            raise DSBException('Cloud \"%s\" not supported' % cloud)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitialises specified loggers to generate output at the specified logging level.", "response": "def initialise_loggers(names, log_level=_builtin_logging.WARNING, handler_class=SplitStreamHandler):\n    \"\"\"\n    Initialises specified loggers to generate output at the\n    specified logging level. If the specified named loggers do not exist,\n    they are created.\n\n    :type names: :obj:`list` of :obj:`str`\n    :param names: List of logger names.\n    :type log_level: :obj:`int`\n    :param log_level: Log level for messages, typically\n       one of :obj:`logging.DEBUG`, :obj:`logging.INFO`, :obj:`logging.WARN`, :obj:`logging.ERROR`\n       or :obj:`logging.CRITICAL`.\n       See :ref:`levels`.\n    :type handler_class: One of the :obj:`logging.handlers` classes.\n    :param handler_class: The handler class for output of log messages,\n       for example :obj:`SplitStreamHandler` or :obj:`logging.StreamHandler`.\n\n    Example::\n\n       >>> from array_split import logging\n       >>> logging.initialise_loggers([\"my_logger\",], log_level=logging.INFO)\n       >>> logger = logging.getLogger(\"my_logger\")\n       >>> logger.info(\"This is info logging.\")\n       16:35:09|ARRSPLT| This is info logging.\n       >>> logger.debug(\"Not logged at logging.INFO level.\")\n       >>>\n\n    \"\"\"\n    frmttr = get_formatter()\n    for name in names:\n        logr = _builtin_logging.getLogger(name)\n        handler = handler_class()\n        handler.setFormatter(frmttr)\n        logr.addHandler(handler)\n        logr.setLevel(log_level)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef emit(self, record):\n        try:\n            msg = self.format(record)\n            if record.levelno < self.splitLevel:\n                stream = self.outStream\n            else:\n                stream = self.errStream\n            fs = \"%s\\n\"\n\n            try:\n                if (isinstance(msg, unicode) and  # noqa: F405\n                        getattr(stream, 'encoding', None)):\n                    ufs = fs.decode(stream.encoding)\n                    try:\n                        stream.write(ufs % msg)\n                    except UnicodeEncodeError:\n                        stream.write((ufs % msg).encode(stream.encoding))\n                else:\n                    stream.write(fs % msg)\n            except UnicodeError:\n                stream.write(fs % msg.encode(\"UTF-8\"))\n\n            stream.flush()\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except:\n            self.handleError(record)", "response": "This method is called by the logging module when a record is emitted."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nemits a record. If a formatter is specified, it is used to format the record. The record is then written to the stream with a trailing newline. If exception information is present, it is formatted using traceback.print_exception and appended to the stream. If the stream has an 'encoding' attribute, it is used to determine how to do the output to the stream.", "response": "def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline.  If\n        exception information is present, it is formatted using\n        traceback.print_exception and appended to the stream.  If the stream\n        has an 'encoding' attribute, it is used to determine how to do the\n        output to the stream.\n        \"\"\"\n        try:\n            msg = self.format(record)\n            if record.levelno < self.splitLevel:\n                stream = self.outStream\n            else:\n                stream = self.errStream\n            stream.write(msg)\n            stream.write(self.terminator)\n            self.flush()\n        except (KeyboardInterrupt, SystemExit):  # pragma: no cover\n            raise\n        except:\n            self.handleError(record)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshuts down the socket connection client and controller.", "response": "def close(self):\n        \"\"\"Shut down the socket connection, client and controller\"\"\"\n        self._sock = None\n        self._controller = None\n        if hasattr(self, \"_port\") and self._port:\n            portpicker.return_port(self._port)\n            self._port = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconnect to a new starcraft2 process.", "response": "def connect(self, url=c.LOCALHOST, port=None, timeout=c.INITIAL_TIMEOUT,\n                      debug=False):\n        \"\"\"socket connect to an already running starcraft2 process\"\"\"\n        if port != None: # force a selection to a new port\n            if self._port!=None: # if previously allocated port, return it\n                portpicker.return_port(self._port)\n            self._port = port\n        elif self._port==None: # no connection exists\n            self._port = portpicker.pick_unused_port()\n        self._url = url\n        if \":\" in url and not url.startswith(\"[\"):  # Support ipv6 addresses.\n            url = \"[%s]\" % url\n        for i in range(timeout):\n            startTime = time.time()\n            if debug:\n                print(\"attempt #%d to websocket connect to %s:%s\"%(i, url, port))\n            try:\n                finalUrl = \"ws://%s:%s/sc2api\" %(url, self._port)\n                ws = websocket.create_connection(finalUrl, timeout=timeout)\n                #print(\"ws:\", ws)\n                self._client = protocol.StarcraftProtocol(ws)\n                #super(ClientController, self).__init__(client) # ensure RemoteController initializtion is performed\n                #if self.ping(): print(\"init ping()\") # ensure the latest state is synced\n                # ping returns:\n                #   game_version:   \"4.1.2.60604\"\n                #   data_version:   \"33D9FE28909573253B7FC352CE7AEA40\"\n                #   data_build:     60604\n                #   base_build:     60321\n                return self\n            except socket.error: pass  # SC2 hasn't started listening yet.\n            except websocket.WebSocketException as err:\n                print(err, type(err))\n                if \"Handshake Status 404\" in str(err):\n                    pass  # SC2 is listening, but hasn't set up the /sc2api endpoint yet.\n                else: raise\n            except Exception as e:\n                print(type(e), e)\n            sleepTime = max(0, 1 - (time.time() - startTime)) # try to wait for up to 1 second total\n            if sleepTime:   time.sleep(sleepTime)\n        raise websocket.WebSocketException(\"Could not connect to game at %s on port %s\"%(url, port))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a debug command to control the game state s setup", "response": "def debug(self, *debugReqs):\n        \"\"\"send a debug command to control the game state's setup\"\"\"\n        return self._client.send(debug=sc2api_pb2.RequestDebug(debug=debugReqs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef submit(self, command=\"\", blocksize=1, job_name=\"parsl.auto\"):\n        ''' The submit method takes the command string to be executed upon\n        instantiation of a resource most often to start a pilot.\n\n        Args :\n             - command (str) : The bash command string to be executed.\n             - blocksize (int) : Blocksize to be requested\n\n        KWargs:\n             - job_name (str) : Human friendly name to be assigned to the job request\n\n        Returns:\n             - A job identifier, this could be an integer, string etc\n\n        Raises:\n             - ExecutionProviderException or its subclasses\n        '''\n        instance, name = self.create_instance(command=command)\n        self.provisioned_blocks += 1\n        self.resources[name] = {\"job_id\": name, \"status\": translate_table[instance['status']]}\n        return name", "response": "The submit method creates a new instance of the appropriate class and adds it to the resource list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunpack the response from a view.", "response": "def unpack(rv):\n    \"\"\"Unpack the response from a view.\n\n    :param rv: the view response\n    :type rv: either a :class:`werkzeug.wrappers.Response` or a\n        tuple of (data, status_code, headers)\n\n    \"\"\"\n    if isinstance(rv, ResponseBase):\n        return rv\n\n    status = headers = None\n    if isinstance(rv, tuple):\n        rv, status, headers = rv + (None,) * (3 - len(rv))\n\n    if rv is None:\n        raise ValueError('View function did not return a response')\n\n    if status is None:\n        status = 200\n    return rv, status, headers or {}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init_app(self, app):\n        try:\n            # Assume this is a blueprint and defer initialization\n            if app._got_registered_once is True:\n                raise ValueError(\"\"\"Blueprint is already registered with an app.\"\"\")\n            app.record(self._deferred_blueprint_init)\n        except AttributeError:\n            self._init_app(app)\n        else:\n            self.blueprint = app", "response": "Initialize actions with the app or blueprint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing actions with the given flask. Flask object.", "response": "def _init_app(self, app):\n        \"\"\"Initialize actions with the given :class:`flask.Flask` object.\n\n        :param app: The flask application object\n        :type app: :class:`~flask.Flask`\n        \"\"\"\n        for resource, urls, kwargs in self.resources:\n            self._register_view(app, resource, *urls, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _deferred_blueprint_init(self, setup_state):\n        self.blueprint_setup = setup_state\n        if setup_state.add_url_rule.__name__ != '_add_url_rule_patch':\n            setup_state._original_add_url_rule = setup_state.add_url_rule\n            setup_state.add_url_rule = MethodType(Api._add_url_rule_patch,\n                                                  setup_state)\n        if not setup_state.first_registration:\n            raise ValueError('flask-RESTEasy blueprints can only be registered once.')\n        self._init_app(setup_state.app)", "response": "Called by the blueprints module when the app is initialized."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _register_view(self, app, resource, *urls, **kwargs):\n        endpoint = kwargs.pop('endpoint', None) or resource.__name__.lower()\n        self.endpoints.add(endpoint)\n\n        if endpoint in getattr(app, 'view_class', {}):\n            existing_view_class = app.view_functions[endpoint].__dict__['view_class']\n\n            # if you override the endpoint with a different class, avoid the collision by raising an exception\n            if existing_view_class != resource:\n                raise ValueError('Endpoint {!r} is already set to {!r}.'\n                                 .format(endpoint, existing_view_class.__name__))\n\n        if not hasattr(resource, 'endpoint'):  # Don't replace existing endpoint\n            resource.endpoint = endpoint\n        resource_func = self.output(resource.as_view(endpoint))\n\n        for decorator in chain(kwargs.pop('decorators', ()), self.decorators):\n            resource_func = decorator(resource_func)\n\n        for url in urls:\n            rule = self._make_url(url, self.blueprint.url_prefix if self.blueprint else None)\n\n            # If this Api has a blueprint\n            if self.blueprint:\n                # And this Api has been setup\n                if self.blueprint_setup:\n                    # Set the rule to a string directly, as the blueprint\n                    # is already set up.\n                    self.blueprint_setup.add_url_rule(self._make_url(url, None), view_func=resource_func, **kwargs)\n                    continue\n                else:\n                    # Set the rule to a function that expects the blueprint\n                    # prefix to construct the final url.  Allows deferment\n                    # of url finalization in the case that the Blueprint\n                    # has not yet been registered to an application, so we\n                    # can wait for the registration prefix\n                    rule = partial(self._make_url, url)\n            else:\n                # If we've got no Blueprint, just build a url with no prefix\n                rule = self._make_url(url, None)\n            # Add the url to the application or blueprint\n            app.add_url_rule(rule, view_func=resource_func, **kwargs)", "response": "Bind resources to the app."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npatches BlueprintSetupState. add_url_rule for delayed creation.", "response": "def _add_url_rule_patch(blueprint_setup, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Patch BlueprintSetupState.add_url_rule for delayed creation.\n\n        Method used for setup state instance corresponding to this Api\n        instance.  Exists primarily to enable _make_url's function.\n\n        :param blueprint_setup: The BlueprintSetupState instance (self)\n        :param rule: A string or callable that takes a string and returns a\n            string(_make_url) that is the url rule for the endpoint\n            being registered\n        :param endpoint: See :meth:`flask.BlueprintSetupState.add_url_rule`\n        :param view_func: See :meth:`flask.BlueprintSetupState.add_url_rule`\n        :param **options: See :meth:`flask.BlueprintSetupState.add_url_rule`\n        \"\"\"\n        if callable(rule):\n            rule = rule(blueprint_setup.url_prefix)\n        elif blueprint_setup.url_prefix:\n            rule = blueprint_setup.url_prefix + rule\n        options.setdefault('subdomain', blueprint_setup.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        defaults = blueprint_setup.url_defaults\n        if 'defaults' in options:\n            defaults = dict(defaults, **options.pop('defaults'))\n        blueprint_setup.app.add_url_rule(rule, '%s.%s' % (blueprint_setup.blueprint.name, endpoint),\n                                         view_func, defaults=defaults, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef output(self, resource):\n        @wraps(resource)\n        def wrapper(*args, **kwargs):\n            rv = resource(*args, **kwargs)\n            rv = self.responder(rv)\n            return rv\n\n        return wrapper", "response": "Wrap a resource function to return a response object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_url(self, url_part, blueprint_prefix):\n        parts = (blueprint_prefix, self.prefix, url_part)\n        return ''.join(_ for _ in parts if _)", "response": "Create URL from blueprint_prefix api prefix and resource url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef url_for(self, resource, **kwargs):\n        if self.blueprint:\n            return flask.url_for('.' + resource.endpoint, **kwargs)\n        return flask.url_for(resource.endpoint, **kwargs)", "response": "Create a url for the given resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef emit(only=None, return_vars=None, namespace=None,\n         sender=None, post_result_name='result',\n         capture_result=True):\n    \"\"\"Decorator to mark a method or function as\n    a signal emitter::\n\n        @blinker_herald.emit()\n        def create(self, value1, value2):\n            return client.do.a.create.post.return.object()\n\n    The above will cause that method to act as::\n\n        # prefixes 'pre' and 'post' + {method name}\n        pre_create = _signals.signal('pre_create')\n        post_create = _signals.signal('post_create')\n\n        def create(self, value1, value2)\n            signals.pre_create.send(self, value1=value1, value2=value2,\n              signal_emitter=self)\n            result = client.do.a.create.post.return.object()\n            signals.post_create.send(\n                self, value1=value1, value2=value2, result=result,\n                signal_emitter=self\n            )\n            return result\n\n    If you want to use your own namespace you need to specify in the\n    'namespace' argument::\n        @signals.emit(namespace=MySignalsNameSpace)\n\n    :param only: can be 'pre' or 'post' and only that signal will emit\n    :param return_vars: If not specified all the locals() will be send,\n        otherwise only names in the list will be taken from locals()\n        can be a dict in form {'pre': ['var1'], 'post': ['var2']}\n        if variable is not found it defaults to None\n    :param namespace: If not specified namespace will be default\n    :param sender: Object or String to be the sender, if not specified\n       the first method parameter will be used (commonly self)\n    :param post_result_name: the name of the result variable e.g: result\n    :param capture_result: Should result be sent to post signals handlers?\n    \"\"\"\n    namespace = namespace or signals_namespace\n    if not getattr(return_vars, 'get', None):\n        return_vars = {'pre': return_vars,\n                       'post': return_vars}\n\n    def decorator(fn):\n        fnargs = inspect.getargspec(fn).args\n        fname = fn.__name__\n        fn.pre = namespace.signal('pre_{0}'.format(fname))\n        fn.post = namespace.signal('post_{0}'.format(fname))\n        if not sender and 'self' not in fnargs and 'cls' not in fnargs:\n            raise RuntimeError(\n                'functions and static methods requires a sender '\n                'e.g: @signals.emit(sender=\"name or object\")'\n            )\n\n        def send(action, *a, **kw):\n            if only is not None and action != only:\n                return\n            sig_name = '{0}_{1}'.format(action, fname)\n            send_return_vars = return_vars.get(action)\n            result = kw.pop(post_result_name, None)\n            kw.update(inspect.getcallargs(fn, *a, **kw))\n            sendkw = {k: v for k, v in kw.items()\n                      if k in (send_return_vars or kw.keys())}\n            sendkw['signal_emitter'] = sendkw.pop(\n                'self', sendkw.pop('cls', kw.get('self', kw.get('cls', fn))))\n            _sender = sender or sendkw['signal_emitter']\n            if isinstance(\n                _sender, type(SENDER_NAME)\n            ) and _sender.__name__ == (SENDER_NAME).__name__:\n                _sender = _sender(sendkw['signal_emitter'])\n            if capture_result and action == 'post':\n                sendkw[post_result_name] = result\n            namespace.signal(sig_name).send(_sender, **sendkw)\n\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            send('pre', *args, **kwargs)\n            result = fn(*args, **kwargs)\n            kwargs[post_result_name] = result\n            send('post', *args, **kwargs)\n            return result\n        return wrapper\n    return decorator", "response": "Decorator to mark a method or function as a new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeploys the template to a resource group.", "response": "def deploy(self, job_name, command='', blocksize=1):\n        instances = []\n        \"\"\"Deploy the template to a resource group.\"\"\"\n        self.client.resource_groups.create_or_update(\n            self.resource_group,\n            {\n                'location': self.location,\n\n            }\n        )\n\n        template_path = os.path.join(os.path.dirname(\n            __file__), 'templates', 'template.json')\n        with open(template_path, 'r') as template_file_fd:\n            template = json.load(template_file_fd)\n\n        parameters = {\n            'sshKeyData': self.pub_ssh_key,\n            'vmName': 'azure-deployment-sample-vm',\n            'dnsLabelPrefix': self.dns_label_prefix\n        }\n        parameters = {k: {'value': v} for k, v in parameters.items()}\n\n        deployment_properties = {\n            'mode': DeploymentMode.incremental,\n            'template': template,\n            'parameters': parameters\n        }\n        for i in range(blocksize):\n            deployment_async_operation = self.client.deployments.create_or_update(\n                self.resource_group,\n                'azure-sample',\n                deployment_properties\n            )\n            instances.append(deployment_async_operation.wait())\n        return instances"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef destroy(self, job_ids):\n        for job_id in job_ids:\n            self.client.resource_groups.delete(self.resource_group)", "response": "Destroy the given resource group"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vm(self, resource_group_name, vm_name):\n        '''\n        you need to retry this just in case the credentials token expires,\n        that's where the decorator comes in\n        this will return all the data about the virtual machine\n        '''\n        return self.client.virtual_machines.get(\n            resource_group_name, vm_name, expand='instanceView')", "response": "Get a virtual machine by name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vm_status(self, vm_name, rgn):\n        '''\n        this will just return the status of the virtual machine\n        sometime the status may be unknown as shown by the azure portal;\n        in that case statuses[1] doesn't exist, hence retrying on IndexError\n        also, it may take on the order of minutes for the status to become\n        available so the decorator will bang on it forever\n        '''\n        rgn = rgn if rgn else self.resource_group\n        return self.client.virtual_machines.get(\n            rgn, vm_name).instance_view.statuses[1].display_status", "response": "Returns the status of the virtual machine with the given name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _retrieve_cached_zone_variable(self, zone_id, name):\n        try:\n            s = self._zone_state[zone_id][name.lower()]\n            logger.debug(\"Zone Cache retrieve %s.%s = %s\",\n                         zone_id.device_str(), name, s)\n            return s\n        except KeyError:\n            raise UncachedVariable", "response": "Retrieves the cache state of a specific variable for a particular zone."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _store_cached_zone_variable(self, zone_id, name, value):\n        zone_state = self._zone_state.setdefault(zone_id, {})\n        name = name.lower()\n        zone_state[name] = value\n        logger.debug(\"Zone Cache store %s.%s = %s\",\n                     zone_id.device_str(), name, value)\n        for callback in self._zone_callbacks:\n            callback(zone_id, name, value)", "response": "Stores the current known value of a zone variable into the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _retrieve_cached_source_variable(self, source_id, name):\n        try:\n            s = self._source_state[source_id][name.lower()]\n            logger.debug(\"Source Cache retrieve S[%d].%s = %s\",\n                         source_id, name, s)\n            return s\n        except KeyError:\n            raise UncachedVariable", "response": "Retrieves the cache state of a specific named variable for a particular source."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstores the current known value of a source variable into the cache.", "response": "def _store_cached_source_variable(self, source_id, name, value):\n        \"\"\"\n        Stores the current known value of a source variable into the cache.\n        Calls any source callbacks.\n        \"\"\"\n        source_state = self._source_state.setdefault(source_id, {})\n        name = name.lower()\n        source_state[name] = value\n        logger.debug(\"Source Cache store S[%d].%s = %s\",\n                     source_id, name, value)\n        for callback in self._source_callbacks:\n            callback(source_id, name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self):\n        logger.info(\"Connecting to %s:%s\", self._host, self._port)\n        reader, writer = yield from asyncio.open_connection(\n                self._host, self._port, loop=self._loop)\n        self._ioloop_future = ensure_future(\n                self._ioloop(reader, writer), loop=self._loop)\n        logger.info(\"Connected\")", "response": "Connect to the controller and start processing responses."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef close(self):\n        logger.info(\"Closing connection to %s:%s\", self._host, self._port)\n        self._ioloop_future.cancel()\n        try:\n            yield from self._ioloop_future\n        except asyncio.CancelledError:\n            pass", "response": "Close the connection to the controller."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_zone_variable(self, zone_id, variable, value):\n        return self._send_cmd(\"SET %s.%s=\\\"%s\\\"\" % (\n            zone_id.device_str(), variable, value))", "response": "Set a zone variable to a new value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_zone_variable(self, zone_id, variable):\n\n        try:\n            return self._retrieve_cached_zone_variable(zone_id, variable)\n        except UncachedVariable:\n            return (yield from self._send_cmd(\"GET %s.%s\" % (\n                zone_id.device_str(), variable)))", "response": "Retrieve the current value of a zone variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves the current value of a zone variable from the cache or return the default value if the variable is not present.", "response": "def get_cached_zone_variable(self, zone_id, variable, default=None):\n        \"\"\" Retrieve the current value of a zone variable from the cache or\n        return the default value if the variable is not present. \"\"\"\n\n        try:\n            return self._retrieve_cached_zone_variable(zone_id, variable)\n        except UncachedVariable:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef watch_zone(self, zone_id):\n        r = yield from self._send_cmd(\n                \"WATCH %s ON\" % (zone_id.device_str(), ))\n        self._watched_zones.add(zone_id)\n        return r", "response": "Add a zone to the watchlist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving a zone from the watchlist.", "response": "def unwatch_zone(self, zone_id):\n        \"\"\" Remove a zone from the watchlist. \"\"\"\n        self._watched_zones.remove(zone_id)\n        return (yield from\n                self._send_cmd(\"WATCH %s OFF\" % (zone_id.device_str(), )))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending an event to a zone.", "response": "def send_zone_event(self, zone_id, event_name, *args):\n        \"\"\" Send an event to a zone. \"\"\"\n        cmd = \"EVENT %s!%s %s\" % (\n                zone_id.device_str(), event_name,\n                \" \".join(str(x) for x in args))\n        return (yield from self._send_cmd(cmd))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of zone_id zone_name tuples.", "response": "def enumerate_zones(self):\n        \"\"\" Return a list of (zone_id, zone_name) tuples \"\"\"\n        zones = []\n        for controller in range(1, 8):\n            for zone in range(1, 17):\n                zone_id = ZoneID(zone, controller)\n                try:\n                    name = yield from self.get_zone_variable(zone_id, 'name')\n                    if name:\n                        zones.append((zone_id, name))\n                except CommandException:\n                    break\n        return zones"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_source_variable(self, source_id, variable, value):\n        source_id = int(source_id)\n        return self._send_cmd(\"SET S[%d].%s=\\\"%s\\\"\" % (\n            source_id, variable, value))", "response": "Change the value of a source variable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_source_variable(self, source_id, variable):\n\n        source_id = int(source_id)\n        try:\n            return self._retrieve_cached_source_variable(\n                    source_id, variable)\n        except UncachedVariable:\n            return (yield from self._send_cmd(\"GET S[%d].%s\" % (\n                source_id, variable)))", "response": "Get the current value of a source variable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_cached_source_variable(self, source_id, variable, default=None):\n\n        source_id = int(source_id)\n        try:\n            return self._retrieve_cached_source_variable(\n                    source_id, variable)\n        except UncachedVariable:\n            return default", "response": "Get the cached value of a source variable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a souce to the watchlist.", "response": "def watch_source(self, source_id):\n        \"\"\" Add a souce to the watchlist. \"\"\"\n        source_id = int(source_id)\n        r = yield from self._send_cmd(\n                \"WATCH S[%d] ON\" % (source_id, ))\n        self._watched_source.add(source_id)\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a source from the watchlist.", "response": "def unwatch_source(self, source_id):\n        \"\"\" Remove a souce from the watchlist. \"\"\"\n        source_id = int(source_id)\n        self._watched_sources.remove(source_id)\n        return (yield from\n                self._send_cmd(\"WATCH S[%d] OFF\" % (\n                    source_id, )))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of tuples that are available for source_id and source_name.", "response": "def enumerate_sources(self):\n        \"\"\" Return a list of (source_id, source_name) tuples \"\"\"\n        sources = []\n        for source_id in range(1, 17):\n            try:\n                name = yield from self.get_source_variable(source_id, 'name')\n                if name:\n                    sources.append((source_id, name))\n            except CommandException:\n                break\n        return sources"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_time(cls, other):\n        return cls(other.hour, other.minute, other.second, other.microsecond)", "response": "Construct an nptime object from a datetime. time object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_timedelta(self):\n        return timedelta(hours=self.hour, minutes=self.minute,\n                seconds=self.second, microseconds=self.microsecond)", "response": "Construct a : class : timedelta object from an nptime object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_renderers(self, request=None, context=None, template_name=None, early=False):\n        request, context, template_name = self.get_render_params(request, context, template_name)\n\n        args = (self.conneg, context, template_name,\n                self._default_format, self._force_fallback_format, self._format_override_parameter)\n        if getattr(request, 'renderers_for_args', None) != args:\n            fallback_formats = self._force_fallback_format or ()\n            if not isinstance(fallback_formats, (list, tuple)):\n                fallback_formats = (fallback_formats,)\n            request.renderers = self.conneg.get_renderers(request=request,\n                                                          context=context,\n                                                          template_name=template_name,\n                                                          accept_header=request.META.get('HTTP_ACCEPT'),\n                                                          formats=self.format_override,\n                                                          default_format=self._default_format,\n                                                          fallback_formats=fallback_formats,\n                                                          early=early)\n            request.renderers_for_view = args\n        if self._include_renderer_details_in_context:\n            self.context['renderers'] = [self.renderer_for_context(request, r) for r in self.conneg.renderers]\n        return request.renderers", "response": "Sets the renderers attribute on the request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self, request=None, context=None, template_name=None):\n        request, context, template_name = self.get_render_params(request, context, template_name)\n\n        self.set_renderers()\n\n        status_code = context.pop('status_code', http_client.OK)\n        additional_headers = context.pop('additional_headers', {})\n\n        for renderer in request.renderers:\n            response = renderer(request, context, template_name)\n            if response is NotImplemented:\n                continue\n            response.status_code = status_code\n            response.renderer = renderer\n            break\n        else:\n            tried_mimetypes = list(itertools.chain(*[r.mimetypes for r in request.renderers]))\n            response = self.http_not_acceptable(request, tried_mimetypes)\n            response.renderer = None\n        for key, value in additional_headers.items():\n            response[key] = value\n\n        # We're doing content-negotiation, so tell the user-agent that the\n        # response will vary depending on the accept header.\n        patch_vary_headers(response, ('Accept',))\n        return response", "response": "Renders the content of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\njoining a template name with a given extension.", "response": "def join_template_name(self, template_name, extension):\n        \"\"\"\n        Appends an extension to a template_name or list of template_names.\n        \"\"\"\n        if template_name is None:\n            return None\n        if isinstance(template_name, (list, tuple)):\n            return tuple('.'.join([n, extension]) for n in template_name)\n        if isinstance(template_name, str_types):\n            return '.'.join([template_name, extension])\n        raise AssertionError('template_name not of correct type: %r' % type(template_name))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsubmitting a command to an Azure instance and return the ID that corresponds to the task that was just submitted.", "response": "def submit(self, command='sleep 1', blocksize=1, job_name=\"parsl.auto\"):\n        \"\"\"Submit command to an Azure instance.\n\n        Submit returns an ID that corresponds to the task that was just submitted.\n\n        Parameters\n        ----------\n        command : str\n            Command to be invoked on the remote side.\n        blocksize : int\n            Number of blocks requested.\n        job_name : str\n             Prefix for job name.\n\n        Returns\n        -------\n        None or str\n            If at capacity (no more can be provisioned), None is returned. Otherwise,\n            an identifier for the job is returned.\n        \"\"\"\n\n        job_name = \"parsl.auto.{0}\".format(time.time())\n        [instance, *rest] = self.deployer.deploy(command=command, job_name=job_name, blocksize=1)\n\n        if not instance:\n            logger.error(\"Failed to submit request to Azure\")\n            return None\n\n        logger.debug(\"Started instance_id: {0}\".format(instance.instance_id))\n\n        state = translate_table.get(instance.state['Name'], \"PENDING\")\n\n        self.resources[instance.instance_id] = {\"job_id\": instance.instance_id, \"instance\": instance, \"status\": state}\n\n        return instance.instance_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef status(self, job_ids):\n        states = []\n        statuses = self.deployer.get_vm_status([self.resources.get(job_id) for job_id in job_ids])\n        for status in statuses:\n            states.append(translate_table.get(status.state['Name'], \"PENDING\"))\n        return states", "response": "Get the status of a list of jobs identified by their ids."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cancel(self, job_ids):\n        for job_id in job_ids:\n            try:\n                self.deployer.destroy(self.resources.get(job_id))\n                return True\n            except e:\n                logger.error(\"Failed to cancel {}\".format(repr(job_id)))\n                logger.error(e)\n                return False", "response": "Cancels the jobs specified by a list of job ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_positions(post_data, queryset=None):\n    if not queryset:\n        queryset = ObjectPosition.objects.all()\n    for key in post_data:\n        if key.startswith('position-'):\n            try:\n                obj_id = int(key.replace('position-', ''))\n            except ValueError:\n                continue\n            queryset.filter(pk=obj_id).update(position=post_data[key])", "response": "Function to update a queryset of object positions with a post data dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef order_by_position(qs, reverse=False):\n    if qs:\n        # ATTENTION: Django creates an invalid sql statement if two related\n        # models have both generic positions, so we cannot use\n        # qs.oder_by('generic_position__position')\n        position = 'position'\n        if reverse:\n            position = '-' + position\n        # Get content type of first queryset item\n        c_type = ContentType.objects.get_for_model(qs[0])\n        # Check that every item has a valid position item\n        for obj in qs:\n            ObjectPosition.objects.get_or_create(\n                content_type=c_type, object_id=obj.pk)\n        return [\n            o.content_object for o in ObjectPosition.objects.filter(\n                content_type=c_type, object_id__in=qs).order_by(position)\n        ]\n    return qs", "response": "Template filter to return a position - ordered queryset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef position_input(obj, visible=False):\n    if not obj.generic_position.all():\n        ObjectPosition.objects.create(content_object=obj)\n    return {'obj': obj, 'visible': visible,\n            'object_position': obj.generic_position.all()[0]}", "response": "Template tag to return an input field for the position of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a template which iters through the models and appends a new position column.", "response": "def position_result_list(change_list):\n    \"\"\"\n    Returns a template which iters through the models and appends a new\n    position column.\n\n    \"\"\"\n    result = result_list(change_list)\n    # Remove sortable attributes\n    for x in range(0, len(result['result_headers'])):\n        result['result_headers'][x]['sorted'] = False\n        if result['result_headers'][x]['sortable']:\n            result['result_headers'][x]['class_attrib'] = mark_safe(\n                ' class=\"sortable\"')\n    # Append position <th> element\n    result['result_headers'].append({\n        'url_remove': '?o=',\n        'sort_priority': 1,\n        'sortable': True,\n        'class_attrib': mark_safe(' class=\"sortable sorted ascending\"'),\n        'sorted': True,\n        'text': 'position',\n        'ascending': True,\n        'url_primary': '?o=-1',\n        'url_toggle': '?o=-1',\n    })\n    # Append the editable field to every result item\n    for x in range(0, len(result['results'])):\n        obj = change_list.result_list[x]\n        # Get position object\n        c_type = ContentType.objects.get_for_model(obj)\n        try:\n            object_position = ObjectPosition.objects.get(\n                content_type__pk=c_type.id, object_id=obj.id)\n        except ObjectPosition.DoesNotExist:\n            object_position = ObjectPosition.objects.create(content_object=obj)\n        # Add the <td>\n        html = ('<td><input class=\"vTextField\" id=\"id_position-{0}\"'\n                ' maxlength=\"10\" name=\"position-{0}\" type=\"text\"'\n                ' value=\"{1}\" /></td>').format(object_position.id,\n                                               object_position.position)\n        result['results'][x].append(mark_safe(html))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters a custom path converter for a Django model.", "response": "def register_model_converter(model, name=None, field='pk', base=IntConverter, queryset=None):\n    \"\"\"\n    Registers a custom path converter for a model.\n\n    :param model: a Django model\n    :param str name: name to register the converter as\n    :param str field: name of the lookup field\n    :param base: base path converter, either by name or as class\n                 (optional, defaults to `django.urls.converter.IntConverter`)\n    :param queryset: a custom querset to use (optional, defaults to `model.objects.all()`)\n    \"\"\"\n    if name is None:\n        name = camel_to_snake(model.__name__)\n        converter_name = '{}Converter'.format(model.__name__)\n    else:\n        converter_name = '{}Converter'.format(snake_to_camel(name))\n\n    if isinstance(base, str):\n        base = get_converter(base).__class__\n\n    converter_class = type(\n        converter_name,\n        (ModelConverterMixin, base,),\n        {'model': model, 'field': field, 'queryset': queryset}\n    )\n\n    register_converter(converter_class, name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nviewing function which handles an authentication request.", "response": "def login():\n    \" View function which handles an authentication request. \"\n    form = LoginForm(request.form)\n    # make sure data are valid, but doesn't validate password is right\n    if form.validate_on_submit():\n        user = User.query.filter_by(email=form.email.data).first()\n        # we use werzeug to validate user's password\n        if user and user.check_password(form.password.data):\n            users.login(user)\n            flash(_('Welcome %(user)s', user=user.username))\n            return redirect(url_for('users.profile'))\n        flash(_('Wrong email or password'), 'error-message')\n    return redirect(request.referrer or url_for(users._login_manager.login_view))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logout():\n    \" View function which handles a logout request. \"\n    users.logout()\n    return redirect(request.referrer or url_for(users._login_manager.login_view))", "response": "View function which handles a logout request."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the directory where the settings file is located.", "response": "def settings_dir(self):\n        \"\"\"\n        Directory that contains the the settings for the project\n        \"\"\"\n        path = os.path.join(self.dir, '.dsb')\n        utils.create_dir(path)\n        return os.path.realpath(path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the settings file and populates self. settings", "response": "def read_settings(self):\n        \"\"\"\n        Read the \"dsbfile\" file\n        Populates `self.settings`\n        \"\"\"\n        logger.debug('Reading settings from: %s', self.settings_path)\n        self.settings = Settings.from_dsbfile(self.settings_path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading dsb instances. yaml and populate self. cluster", "response": "def read_instances(self):\n        \"\"\"\n        Read `.dsb/instances.yaml`\n        Populates `self.cluster`\n        \"\"\"\n        logger.debug('Reading instances from: %s', self.instances_path)\n        if os.path.exists(self.instances_path):\n            with open(self.instances_path, 'r') as f:\n                list_ = yaml.load(f.read())\n                self.cluster = Cluster.from_list(list_, settings=self.settings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef salt(self, module, target='*', args=None, kwargs=None, ssh=False):\n        if ssh:\n            return salt.salt_ssh(self, target, module, args, kwargs)\n        else:\n            return salt.salt_master(self, target, module, args, kwargs)", "response": "Execute a salt command"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_salt_ssh(self):\n        self.copy_salt_and_pillar()\n        self.create_roster_file()\n        self.salt_ssh_create_dirs()\n        self.salt_ssh_create_master_file()", "response": "Setup salt - ssh"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the salt - ssh required directories into the settings directory structure", "response": "def salt_ssh_create_dirs(self):\n        \"\"\"\n        Creates the `salt-ssh` required directory structure\n        \"\"\"\n        logger.debug('Creating salt-ssh dirs into: %s', self.settings_dir)\n        utils.create_dir(os.path.join(self.settings_dir, 'salt'))\n        utils.create_dir(os.path.join(self.settings_dir, 'pillar'))\n        utils.create_dir(os.path.join(self.settings_dir, 'etc', 'salt'))\n        utils.create_dir(os.path.join(self.settings_dir, 'var', 'cache', 'salt'))\n        utils.create_dir(os.path.join(self.settings_dir, 'var', 'log', 'salt'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the tabulate method to a jsonModel object", "response": "def tabulate(json_model):\n    \n    '''\n        a function to add the tabulate method to a jsonModel object\n        \n    :param json_model: jsonModel object\n    :return: jsonModel object\n    '''\n\n    import types\n    from jsonmodel._extensions import tabulate as _tabulate\n    try:\n        from tabulate import tabulate\n    except:\n        import sys\n        print('jsonmodel.extensions.tabulate requires the tabulate module. try: pip install tabulate')\n        sys.exit(1)\n\n    setattr(json_model, 'tabulate', _tabulate.__get__(json_model, types.MethodType))\n\n    return json_model"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the xml element contents to match the instance contents.", "response": "def update_xml_element(self):\n        \"\"\"\n        Updates the xml element contents to matches the instance contents.\n\n        :returns: Updated XML element.\n        :rtype: lxml.etree._Element\n        \"\"\"\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        if hasattr(self, 'idref'):\n            self.xml_element.set('idref', self.idref)\n\n        return self.xml_element"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_xml_element(self):\n\n        super(Description, self).update_xml_element()\n\n        if hasattr(self, 'lang'):\n            self.xml_element.set(\n                '{http://www.w3.org/XML/1998/namespace}lang', self.lang)\n        if hasattr(self, 'override'):\n            self.xml_element.set('override', str(self.override))\n\n        return self.xml_element", "response": "Updates the xml element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(*units):\n    ret = []\n    for unit in units: # implemented using sc2simulator.ScenarioUnit\n        x, y = unit.position[:2]\n        pt = Point2D(x=x, y=y)\n        unit.tag = 0 # forget any tag because a new unit will be created\n        new = DebugCommand(create_unit=DebugCreateUnit(\n            unit_type   = unit.code,\n            owner       = unit.owner,\n            pos         = pt,\n            quantity    = 1,\n        ))\n        ret.append(new)\n    return ret", "response": "create this unit within the game as specified"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmodifying the units in - game with desired properties", "response": "def modify(*units):\n    \"\"\"set the unit defined by in-game tag with desired properties\n    NOTE: all units must be owned by the same player or the command fails.\"\"\"\n    ret = []\n    for unit in units: # add one command for each attribute\n        for attr, idx in [(\"energy\", 1), (\"life\", 2), (\"shields\", 3)]: # see debug_pb2.UnitValue for enum declaration\n            newValue = getattr(unit, attr)\n            if not newValue: continue # don't bother setting something that isn't necessary\n            new = DebugCommand(unit_value=DebugSetUnitValue(\n                value       = newValue,\n                unit_value  = idx,\n                unit_tag    = unit.tag))\n            ret.append(new)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting standard wallclock time string to minutes.", "response": "def wtime_to_minutes(time_string):\n    ''' wtime_to_minutes\n\n    Convert standard wallclock time string to minutes.\n\n    Args:\n        - Time_string in HH:MM:SS format\n\n    Returns:\n        (int) minutes\n\n    '''\n    hours, mins, seconds = time_string.split(':')\n    return int(hours) * 60 + int(mins) + 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a callback function to rewrite links.", "response": "def rewrite_links(self, func):\n        \"\"\"\n        Add a callback for rewriting links.\n\n        The callback should take a single argument, the url, and\n        should return a replacement url.  The callback function is\n        called everytime a ``[]()`` or ``<link>`` is processed.\n\n        You can use this method as a decorator on the function you\n        want to set as the callback.\n        \"\"\"\n        @libmarkdown.e_url_callback\n        def _rewrite_links_func(string, size, context):\n            ret = func(string[:size])\n            if ret is not None:\n                buf = ctypes.create_string_buffer(ret)\n                self._alloc.append(buf)\n                return ctypes.addressof(buf)\n\n        self._rewrite_links_func = _rewrite_links_func\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a callback for adding attributes to links.", "response": "def link_attrs(self, func):\n        \"\"\"\n        Add a callback for adding attributes to links.\n\n        The callback should take a single argument, the url, and\n        should return additional text to be inserted in the link tag,\n        i.e. ``\"target=\"_blank\"``.\n\n        You can use this method as a decorator on the function you\n        want to set as the callback.\n        \"\"\"\n        @libmarkdown.e_flags_callback\n        def _link_attrs_func(string, size, context):\n            ret = func(string[:size])\n            if ret is not None:\n                buf = ctypes.create_string_buffer(ret)\n                self._alloc.append(buf)\n                return ctypes.addressof(buf)\n\n        self._link_attrs_func = _link_attrs_func\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if obj is a sequence - like object.", "response": "def isseq(obj):\n  '''\n  Returns True if `obj` is a sequence-like object (but not a string or\n  dict); i.e. a tuple, list, subclass thereof, or having an interface\n  that supports iteration.\n  '''\n  return \\\n    not isstr(obj) \\\n    and not isdict(obj) \\\n    and ( isinstance(obj, (list, tuple)) \\\n          or callable(getattr(obj, '__iter__', None)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef isdict(obj):\n  '''\n  Returns True if `obj` is a dict-like object (but not a string or\n  list); i.e. a dict, subclass thereof, or having an interface that\n  supports key, value, and item iteration.\n  '''\n  return \\\n    not isstr(obj) \\\n    and ( isinstance(obj, dict) \\\n          or ( callable(getattr(obj, 'keys', None)) \\\n               and callable(getattr(obj, 'values', None)) \\\n               and callable(getattr(obj, 'items', None)) ))", "response": "Returns True if obj is a dict - like object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a bool representation of obj.", "response": "def tobool(obj, default=False):\n  '''\n  Returns a bool representation of `obj`: if `obj` is not a string,\n  it is returned cast to a boolean by calling `bool()`. Otherwise, it\n  is checked for \"truthy\" or \"falsy\" values, and that is returned. If\n  it is not truthy or falsy, `default` is returned (which defaults to\n  ``False``) unless `default` is set to ``ValueError``, in which case\n  an exception is raised.\n\n  '''\n  if isinstance(obj, bool):\n    return obj\n  if not isstr(obj):\n    return bool(obj)\n  lobj = obj.lower()\n  if lobj in truthy:\n    return True\n  if lobj in falsy:\n    return False\n  if default is ValueError:\n    raise ValueError('invalid literal for tobool(): %r' % (obj,))\n  return default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn obj as a list if flat is truthy returns an empty list ; if flat is truthy returns a list optionally flattened if split is truthy returns a list of substrings of the sequence - like object.", "response": "def tolist(obj, flat=True, split=True):\n  '''\n  Returns `obj` as a list: if it is falsy, returns an empty list; if\n  it is a string and `split` is truthy, then it is split into\n  substrings using Unix shell semantics; if it is sequence-like, a\n  list is returned optionally flattened if `flat` is truthy (see\n  :func:`flatten`).\n  '''\n  # todo: it would be \"pretty awesome\" if this could auto-detect\n  #       comma-separation rather than space-separation\n  if not obj:\n    return []\n  if isseq(obj):\n    return flatten(obj) if flat else list(obj)\n  if isstr(obj) and split:\n    return shlex.split(obj)\n  return [obj]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nflattens a list - like object into a single list - like object", "response": "def flatten(obj):\n  '''\n  TODO: add docs\n  '''\n  if isseq(obj):\n    ret = []\n    for item in obj:\n      if isseq(item):\n        ret.extend(flatten(item))\n      else:\n        ret.append(item)\n    return ret\n  if isdict(obj):\n    ret = dict()\n    for key, value in obj.items():\n      for skey, sval in _relflatten(value):\n        ret[key + skey] = sval\n    return ret\n  raise ValueError(\n    'only list- and dict-like objects can be flattened, not %r' % (obj,))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a source dict or object returns a new dict that contains a subset of keys and or a new object that contains the specified keys.", "response": "def pick(source, *keys, **kws):\n  '''\n  Given a `source` dict or object, returns a new dict that contains a\n  subset of keys (each key is a separate positional argument) and/or\n  where each key is a string and has the specified `prefix`, specified\n  as a keyword argument. Also accepts the optional keyword argument\n  `dict` which must be a dict-like class that will be used to\n  instantiate the returned object. Note that if `source` is an object\n  without an `items()` iterator, then the selected keys will be\n  extracted as attributes. The `prefix` keyword only works with\n  dict-like objects. If the `tree` keyword is specified and set to\n  truthy, each key is evaluated as a hierchical key walker spec. In\n  other words, the following are equivalent:\n\n  .. code:: python\n\n    src = dict(a=dict(b='bee', c='cee'), d='dee')\n    assert morph.pick(src, 'a.b', tree=True) == dict(a=dict(b='bee'))\n\n  Requests for keys not found in `source` are silently ignored.\n\n  :Changes:\n\n  * `tree` support added in version 0.1.3.\n  '''\n  rettype = kws.pop('dict', dict)\n  prefix  = kws.pop('prefix', None)\n  tree    = kws.pop('tree', False)\n  if kws:\n    raise ValueError('invalid pick keyword arguments: %r' % (kws.keys(),))\n  if prefix is not None and tree:\n    raise ValueError('`prefix` and `tree` currently cannot be used together')\n  if not source:\n    return rettype()\n  if prefix is not None:\n    try:\n      items = source.items()\n    except AttributeError:\n      items = None\n    if items is not None:\n      source = {k[len(prefix):]: v\n                for k, v in items\n                if getattr(k, 'startswith', lambda x: False)(prefix)}\n    else:\n      source = {attr[len(prefix):]: getattr(source, attr)\n                for attr in properties(source)\n                if attr.startswith(prefix)}\n  if len(keys) <= 0:\n    if prefix is not None:\n      return rettype(source)\n    return rettype()\n  rkeys = keys\n  if tree:\n    rkeys = [key.split('.', 1)[0] for key in rkeys]\n  try:\n    ret = rettype({k: v for k, v in source.items() if k in rkeys})\n  except AttributeError:\n    ret = rettype({k: getattr(source, k) for k in rkeys if hasattr(source, k)})\n  if tree:\n    for key in keys:\n      if '.' in key:\n        key, rem = key.split('.', 1)\n        if key in ret:\n          ret[key] = pick(ret[key], rem, dict=rettype, prefix=prefix, tree=tree)\n  return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the subelements from the xml_element in its correspondent classes.", "response": "def load_children(self):\n        \"\"\"\n        Load the subelements from the xml_element in its correspondent classes.\n\n        :returns: List of child objects.\n        :rtype: list\n        :raises CardinalityException: If there is more than one Version child.\n        \"\"\"\n\n        # Containers\n        children = list()\n        statuses = list()\n        version = None\n        titles = list()\n        descriptions = list()\n        platforms = list()\n        idents = list()\n\n        # Element load\n        for element in self.xml_element:\n            uri, tag = Element.get_namespace_and_tag(element.tag)\n            if tag == 'version':\n                if version is None:\n                    version = Version(element)\n                else:\n                    error_msg = 'version element found more than once'\n                    raise CardinalityException(error_msg)\n            elif tag == 'status':\n                statuses.append(Status(element))\n            elif tag == 'title':\n                titles.append(Title(element))\n            elif tag == 'description':\n                descriptions.append(Description(element))\n            elif tag == 'platform':\n                platforms.append(Platform(element))\n            elif tag == 'ident':\n                idents.append(Ident(element))\n\n        # List construction\n        children.extend(statuses)\n        if version is not None:\n            children.append(version)\n        children.extend(titles)\n        children.extend(descriptions)\n        children.extend(platforms)\n        children.extend(idents)\n\n        return children"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _evaluate_field(self, record_dict, field_name, field_criteria):\n\n        ''' a helper method for evaluating record values based upon query criteria\n\n        :param record_dict: dictionary with model valid data to evaluate\n        :param field_name: string with path to root of query field\n        :param field_criteria: dictionary with query operators and qualifiers\n        :return: boolean (True if no field_criteria evaluate to false)\n        '''\n\n    # determine value existence criteria\n        value_exists = True\n        if 'value_exists' in field_criteria.keys():\n            if not field_criteria['value_exists']:\n                value_exists = False\n\n    # validate existence of field\n        field_exists = True\n        try:\n            record_values = self._walk(field_name, record_dict)\n        except:\n            field_exists = False\n\n    # evaluate existence query criteria\n        if value_exists != field_exists:\n            return False\n        elif not value_exists:\n            return True\n\n    # convert javascript dot_path to class dot_path\n        field_key = field_name\n        if not field_name:\n            field_key = '.'\n        else:\n            if field_name[0] != '.':\n                field_key = '.%s' % field_name\n\n    # evaluate other query criteria\n        for key, value in field_criteria.items():\n            if key in ('min_size', 'min_length'):\n                found = False\n                if self.keyMap[field_key]['value_datatype'] == 'map':\n                    for record_value in record_values:\n                        record_size = sys.getsizeof(json.dumps(str(record_value)).replace(' ','')) - 51\n                        if record_size >= value:\n                            found = True\n                            break\n                else:\n                    for record_value in record_values:\n                        if len(record_value) >= value:\n                            found = True\n                            break\n                if not found:\n                    return False\n            elif key in ('max_size', 'max_length'):\n                found = False\n                if self.keyMap[field_key]['value_datatype'] == 'map':\n                    for record_value in record_values:\n                        record_size = sys.getsizeof(json.dumps(str(record_value)).replace(' ','')) - 51\n                        if record_size <= value:\n                            found = True\n                            break\n                else:\n                    for record_value in record_values:\n                        if len(record_value) <= value:\n                            found = True\n                            break\n                if not found:\n                    return False\n            elif key == 'min_value':\n                found = False\n                for record_value in record_values:\n                    if record_value >= value:\n                        found = True\n                        break\n                if not found:\n                    return False\n            elif key == 'max_value':\n                found = False\n                for record_value in record_values:\n                    if record_value <= value:\n                        found = True\n                        break\n                if not found:\n                    return False\n            elif key == 'equal_to':\n                found = False\n                for record_value in record_values:\n                    if record_value == value:\n                        found = True\n                        break\n                if not found:\n                    return False\n            elif key == 'greater_than':\n                found = False\n                for record_value in record_values:\n                    if record_value > value:\n                        found = True\n                        break\n                if not found:\n                    return False\n            elif key == 'less_than':\n                found = False\n                for record_value in record_values:\n                    if record_value < value:\n                        found = True\n                        break\n                if not found:\n                    return False\n            elif key == 'excluded_values':\n                for record_value in record_values:\n                    if record_value in value:\n                        return False\n            elif key == 'discrete_values':\n                found = False\n                for record_value in record_values:\n                    if record_value in value:\n                        found = True\n                        break\n                if not found:\n                    return False\n            elif key == 'integer_data':\n                found = False\n                dummy_int = 1\n                for record_value in record_values:\n                    if record_value.__class__ == dummy_int.__class__:\n                        found = True\n                        break\n                if value != found:\n                    return False\n            elif key == 'byte_data':\n                found = False\n                for record_value in record_values:\n                    try:\n                        decoded_bytes = b64decode(record_value)\n                    except:\n                        decoded_bytes = ''\n                    if isinstance(decoded_bytes, bytes):\n                        found = True\n                        break\n                if value != found:\n                    return False\n            elif key == 'must_contain':\n                for regex in value:\n                    regex_pattern = re.compile(regex)\n                    found = False\n                    for record_value in record_values:\n                        if regex_pattern.findall(record_value):\n                            found = True\n                            break\n                    if not found:\n                        return False\n            elif key == 'must_not_contain':\n                for regex in value:\n                    regex_pattern = re.compile(regex)\n                    found = False\n                    for record_value in record_values:\n                        if regex_pattern.findall(record_value):\n                            found = True\n                            break\n                    if found:\n                        return False\n            elif key == 'contains_either':\n                found = False\n                for regex in value:\n                    regex_pattern = re.compile(regex)\n                    for record_value in record_values:\n                        if regex_pattern.findall(record_value):\n                            found = True\n                            break\n                    if found:\n                        break\n                if not found:\n                    return False\n            elif key == 'unique_values':\n                for record_value in record_values:\n                    unique_values = True\n                    if len(record_value) != len(set(record_value)):\n                        unique_values = False\n                    if value != unique_values:\n                        return False\n\n        return True", "response": "a helper method for evaluating the value of a record field based upon query criteria and qualifiers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_string(self, input_string, path_to_root, object_title=''):\n\n        '''\n            a helper method for validating properties of a string\n\n        :return: input_string\n        '''\n\n        rules_path_to_root = re.sub('\\[\\d+\\]', '[0]', path_to_root)\n        input_criteria = self.keyMap[rules_path_to_root]\n        error_dict = {\n            'object_title': object_title,\n            'model_schema': self.schema,\n            'input_criteria': input_criteria,\n            'failed_test': 'value_datatype',\n            'input_path': path_to_root,\n            'error_value': input_string,\n            'error_code': 4001\n        }\n        if 'byte_data' in input_criteria.keys():\n            if input_criteria['byte_data']:\n                error_dict['failed_test'] = 'byte_data'\n                error_dict['error_code'] = 4011\n                try:\n                    decoded_bytes = b64decode(input_string)\n                except:\n                    raise InputValidationError(error_dict)\n                if not isinstance(decoded_bytes, bytes):\n                    raise InputValidationError(error_dict)\n        if 'min_value' in input_criteria.keys():\n            if input_string < input_criteria['min_value']:\n                error_dict['failed_test'] = 'min_value'\n                error_dict['error_code'] = 4022\n                raise InputValidationError(error_dict)\n        if 'max_value' in input_criteria.keys():\n            if input_string > input_criteria['max_value']:\n                error_dict['failed_test'] = 'max_value'\n                error_dict['error_code'] = 4023\n                raise InputValidationError(error_dict)\n        if 'greater_than' in input_criteria.keys():\n            if input_string <= input_criteria['greater_than']:\n                error_dict['failed_test'] = 'greater_than'\n                error_dict['error_code'] = 4024\n                raise InputValidationError(error_dict)\n        if 'less_than' in input_criteria.keys():\n            if input_string >= input_criteria['less_than']:\n                error_dict['failed_test'] = 'less_than'\n                error_dict['error_code'] = 4025\n                raise InputValidationError(error_dict)\n        if 'equal_to' in input_criteria.keys():\n            if input_string != input_criteria['equal_to']:\n                error_dict['failed_test'] = 'equal_to'\n                error_dict['error_code'] = 4026\n                raise InputValidationError(error_dict)\n        if 'min_length' in input_criteria.keys():\n            if len(input_string) < input_criteria['min_length']:\n                error_dict['failed_test'] = 'min_length'\n                error_dict['error_code'] = 4012\n                raise InputValidationError(error_dict)\n        if 'max_length' in input_criteria.keys():\n            if len(input_string) > input_criteria['max_length']:\n                error_dict['failed_test'] = 'max_length'\n                error_dict['error_code'] = 4013\n                raise InputValidationError(error_dict)\n        if 'must_not_contain' in input_criteria.keys():\n            for regex in input_criteria['must_not_contain']:\n                regex_pattern = re.compile(regex)\n                if regex_pattern.findall(input_string):\n                    error_dict['failed_test'] = 'must_not_contain'\n                    error_dict['error_code'] = 4014\n                    raise InputValidationError(error_dict)\n        if 'must_contain' in input_criteria.keys():\n            for regex in input_criteria['must_contain']:\n                regex_pattern = re.compile(regex)\n                if not regex_pattern.findall(input_string):\n                    error_dict['failed_test'] = 'must_contain'\n                    error_dict['error_code'] = 4015\n                    raise InputValidationError(error_dict)\n        if 'contains_either' in input_criteria.keys():\n            regex_match = False\n            for regex in input_criteria['contains_either']:\n                regex_pattern = re.compile(regex)\n                if regex_pattern.findall(input_string):\n                    regex_match = True\n            if not regex_match:\n                error_dict['failed_test'] = 'contains_either'\n                error_dict['error_code'] = 4016\n                raise InputValidationError(error_dict)\n        if 'discrete_values' in input_criteria.keys():\n            if input_string not in input_criteria['discrete_values']:\n                error_dict['failed_test'] = 'discrete_values'\n                error_dict['error_code'] = 4041\n                raise InputValidationError(error_dict)\n        if 'excluded_values' in input_criteria.keys():\n            if input_string in input_criteria['excluded_values']:\n                error_dict['failed_test'] = 'excluded_values'\n                error_dict['error_code'] = 4042\n                raise InputValidationError(error_dict)\n\n    # TODO: validate string against identical to reference\n\n    # TODO: run lambda function and call validation url\n\n        return input_string", "response": "helper method for validating properties of a string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _ingest_boolean(self, input_boolean, path_to_root):\n\n        '''\n            a helper method for ingesting a boolean\n\n        :return: valid_boolean\n        '''\n\n        valid_boolean = False\n\n        try:\n            valid_boolean = self._validate_boolean(input_boolean, path_to_root)\n        except:\n            rules_path_to_root = re.sub('\\[\\d+\\]', '[0]', path_to_root)\n            if 'default_value' in self.keyMap[rules_path_to_root]:\n                valid_boolean = self.keyMap[rules_path_to_root]['default_value']\n\n        return valid_boolean", "response": "a helper method for ingesting a boolean"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _walk(self, path_to_root, record_dict):\n\n        '''\n            a helper method for finding the record endpoint from a path to root\n\n        :param path_to_root: string with dot path to root from\n        :param record_dict:\n        :return: list, dict, string, number, or boolean at path to root\n        '''\n\n    # split path to root into segments\n        item_pattern = re.compile('\\d+\\\\]')\n        dot_pattern = re.compile('\\\\.|\\\\[')\n        path_segments = dot_pattern.split(path_to_root)\n\n    # construct empty fields\n        record_endpoints = []\n\n    # determine starting position\n        if not path_segments[0]:\n            path_segments.pop(0)\n        \n    # define internal recursive function\n        def _walk_int(path_segments, record_dict):\n            record_endpoint = record_dict\n            for i in range(0, len(path_segments)):\n                if item_pattern.match(path_segments[i]):\n                    for j in range(0, len(record_endpoint)):\n                        if len(path_segments) == 2:\n                            record_endpoints.append(record_endpoint[j])\n                        else:\n                            stop_chain = False\n                            for x in range(0, i):\n                                if item_pattern.match(path_segments[x]):\n                                    stop_chain = True\n                            if not stop_chain:\n                                shortened_segments = []\n                                for z in range(i + 1, len(path_segments)):\n                                    shortened_segments.append(path_segments[z])\n                                _walk_int(shortened_segments, record_endpoint[j])\n                else:\n                    stop_chain = False\n                    for y in range(0, i):\n                        if item_pattern.match(path_segments[y]):\n                            stop_chain = True\n                    if not stop_chain:\n                        if len(path_segments) == i + 1:\n                            record_endpoints.append(record_endpoint[path_segments[i]])\n                        else:\n                            record_endpoint = record_endpoint[path_segments[i]]\n\n    # conduct recursive walk\n        _walk_int(path_segments, record_dict)\n\n        return record_endpoints", "response": "helper method for finding the record endpoint from a path to root"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self, input_data, path_to_root='', object_title=''):\n\n        '''\n            a core method for validating input against the model\n\n            input_data is only returned if all data is valid\n\n        :param input_data: list, dict, string, number, or boolean to validate\n        :param path_to_root: [optional] string with dot-path of model component\n        :param object_title: [optional] string with name of input to validate\n        :return: input_data (or InputValidationError)\n        '''\n\n        __name__ = '%s.validate' % self.__class__.__name__\n        _path_arg = '%s(path_to_root=\"...\")' % __name__\n        _title_arg = '%s(object_title=\"...\")' % __name__\n\n    # validate input\n        copy_path = path_to_root\n        if path_to_root:\n            if not isinstance(path_to_root, str):\n                raise ModelValidationError('%s must be a string.' % _path_arg)\n            else:\n                if path_to_root[0] != '.':\n                    copy_path = '.%s' % path_to_root\n                if not copy_path in self.keyMap.keys():\n                    raise ModelValidationError('%s does not exist in components %s.' % (_path_arg.replace('...', path_to_root), self.keyMap.keys()))\n        else:\n            copy_path = '.'\n        if object_title:\n            if not isinstance(object_title, str):\n                raise ModelValidationError('%s must be a string' % _title_arg)\n\n    # construct generic error dictionary\n        error_dict = {\n            'object_title': object_title,\n            'model_schema': self.schema,\n            'input_criteria': self.keyMap[copy_path],\n            'failed_test': 'value_datatype',\n            'input_path': copy_path,\n            'error_value': input_data,\n            'error_code': 4001\n        }\n\n    # determine value type of input data\n        try:\n            input_index = self._datatype_classes.index(input_data.__class__)\n        except:\n            error_dict['error_value'] = input_data.__class__.__name__\n            raise InputValidationError(error_dict)\n        input_type = self._datatype_names[input_index]\n\n    # validate input data type\n        if input_type != self.keyMap[copy_path]['value_datatype']:\n            raise InputValidationError(error_dict)\n\n    # run helper method appropriate to data type\n        if input_type == 'boolean':\n            input_data = self._validate_boolean(input_data, copy_path, object_title)\n        elif input_type == 'number':\n            input_data = self._validate_number(input_data, copy_path, object_title)\n        elif input_type == 'string':\n            input_data = self._validate_string(input_data, copy_path, object_title)\n        elif input_type == 'list':\n            schema_list = self._reconstruct(copy_path)\n            input_data = self._validate_list(input_data, schema_list, copy_path, object_title)\n        elif input_type == 'map':\n            schema_dict = self._reconstruct(copy_path)\n            input_data = self._validate_dict(input_data, schema_dict, copy_path, object_title)\n\n        return input_data", "response": "a method for validating input against the model"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query(self, query_criteria, valid_record=None):\n\n        '''\n            a core method for querying model valid data with criteria\n\n            **NOTE: input is only returned if all fields & qualifiers are valid for model\n\n            :param query_criteria: dictionary with model field names and query qualifiers\n            :param valid_record: dictionary with model valid record\n            :return: boolean (or QueryValidationError)\n\n            an example of how to construct the query_criteria argument:\n\n            query_criteria = {\n                '.path.to.number': {\n                    'min_value': 4.5\n                },\n                '.path.to.string': {\n                    'must_contain': [ '\\\\regex' ]\n                }\n            }\n\n            **NOTE: for a full list of operators for query_criteria based upon field\n                    datatype, see either the query-rules.json file or REFERENCE file\n        '''\n\n        __name__ = '%s.query' % self.__class__.__name__\n        _query_arg = '%s(query_criteria={...})' % __name__\n        _record_arg = '%s(valid_record={...})' % __name__\n\n    # validate input\n        if not isinstance(query_criteria, dict):\n            raise ModelValidationError('%s must be a dictionary.' % _query_arg)\n\n    # convert javascript dot_path to class dot_path\n        criteria_copy = {}\n        equal_fields = []\n        dot_fields = []\n        for key, value in query_criteria.items():\n            copy_key = key\n            if not key:\n                copy_key = '.'\n            else:\n                if key[0] != '.':\n                    copy_key = '.%s' % key\n                    dot_fields.append(copy_key)\n            criteria_copy[copy_key] = value\n            if value.__class__ in self._datatype_classes[0:4]:\n                criteria_copy[copy_key] = {\n                    'equal_to': value\n                }\n                equal_fields.append(copy_key)\n\n    # validate query criteria against query rules\n        query_kwargs = {\n            'fields_dict': criteria_copy,\n            'fields_rules': self.queryRules,\n            'declared_value': False\n        }\n        try:\n            self._validate_fields(**query_kwargs)\n        except ModelValidationError as err:\n            message = err.error['message']\n            for field in equal_fields:\n                equal_error = 'field %s qualifier equal_to' % field\n                if message.find(equal_error) > -1:\n                    message = message.replace(equal_error, 'field %s' % field)\n                    break\n            field_pattern = re.compile('ield\\s(\\..*?)\\s')\n            field_name = field_pattern.findall(message)\n            if field_name:\n                if field_name[0] in dot_fields:\n                    def _replace_field(x):\n                        return 'ield %s ' % x.group(1)[1:]\n                    message = field_pattern.sub(_replace_field, message)\n            raise QueryValidationError(message)\n\n    # query test record\n        if valid_record:\n            if not isinstance(valid_record, dict):\n                raise ModelValidationError('%s must be a dictionary.' % _record_arg)\n            for key, value in criteria_copy.items():\n                eval_outcome = self._evaluate_field(valid_record, key, value)\n                if not eval_outcome:\n                    return False\n\n        return True", "response": "a method for querying model valid data with criteria"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef url_view(url_pattern, name=None, priority=None):\n\n    def meta_wrapper(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n\n        wrapper.urljects_view = True\n        wrapper.url = url_pattern\n        wrapper.url_name = name or func.__name__\n        wrapper.url_priority = priority\n\n        return wrapper\n    return meta_wrapper", "response": "Decorator for registering functional views."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_name(view):\n    if inspect.isfunction(view):\n        return view.__name__\n    if hasattr(view, 'url_name'):\n        return view.url_name\n    if isinstance(view, six.string_types):\n        return view.split('.')[-1]\n    return None", "response": "Try to guess the name of the view."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef url(url_pattern, view, kwargs=None, name=None):\n    # Special handling for included view\n    if isinstance(url_pattern, URLPattern) and isinstance(view, tuple):\n        url_pattern = url_pattern.for_include()\n\n    if name is None:\n        name = resolve_name(view)\n\n    if callable(view) and hasattr(view, 'as_view') and callable(view.as_view):\n        view = view.as_view()\n\n    return urls.url(\n        regex=url_pattern,\n        view=view,\n        kwargs=kwargs,\n        name=name)", "response": "This is replacement for django. conf. urls. url function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef view_include(view_module, namespace=None, app_name=None):\n\n    # since Django 1.8 patterns() are deprecated, list should be used instead\n    # {priority:[views,]}\n    view_dict = defaultdict(list)\n\n    if isinstance(view_module, six.string_types):\n        view_module = importlib.import_module(view_module)\n\n    # pylint:disable=unused-variable\n    for member_name, member in inspect.getmembers(view_module):\n        is_class_view = inspect.isclass(member) and issubclass(member, URLView)\n        is_func_view = (inspect.isfunction(member) and\n                        hasattr(member, 'urljects_view') and\n                        member.urljects_view)\n\n        if (is_class_view and member is not URLView) or is_func_view:\n            view_dict[member.url_priority].append(\n                url(member.url, member, name=member.url_name))\n\n    view_patterns = list(*[\n        view_dict[priority] for priority in sorted(view_dict)\n        ])\n\n    return urls.include(\n        arg=view_patterns,\n        namespace=namespace,\n        app_name=app_name)", "response": "Includes view in the url works similar to django include function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncaching a given file for further use", "response": "def cache_file(file_name):\n\t\"\"\"\n\tCache a given file for further use (by storing them on disk)\n\t\"\"\"\n\n\tremote_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\ttry:\n\t\tcopyfile(file_name, remote_file_path)\n\texcept Exception, e:\n\t\traise e"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_file(file_name):\n\n\tremote_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\tcurrent_path = join(getcwd(), file_name)\n\n\ttry:\n\t\tcopyfile(remote_file_path, current_path)\n\texcept Exception, e:\n\t\traise e", "response": "Copy a given file from the cache storage\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_cached(file_name):\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "response": "Check if a given file is available in the cache or not\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tabulate(self, format='html', syntax=''):\n\n    '''\n        a function to create a table from the class model keyMap\n\n    :param format: string with format for table output\n    :param syntax: [optional] string with linguistic syntax\n    :return: string with table\n    '''\n\n    from tabulate import tabulate as _tabulate\n    \n# define headers\n    headers = ['Field', 'Datatype', 'Required', 'Default', 'Examples', 'Conditionals', 'Description']\n    rows = []\n    default_values = False\n    additional_conditions = False\n    field_description = False\n\n# construct rows\n    for key, value in self.keyMap.items():\n\n        key_segments = _segment_path(key)\n\n        if key_segments:\n\n            row = []\n\n        # add field column\n            field_name = ''\n            if len(key_segments) > 1:\n                for i in range(1,len(key_segments)):\n                    field_name += '&nbsp;&nbsp;&nbsp;&nbsp;'\n            if key_segments[-1] == '0':\n                field_name += '<i>item</i>'\n            else:\n                field_name += key_segments[-1]\n            row.append(field_name)\n\n        # add datatype column\n            value_datatype = value['value_datatype']\n            if 'integer_data' in value.keys():\n                if value['integer_data'] and syntax != 'javascript':\n                    value_datatype = 'integer'\n            elif value['value_datatype'] == 'map':\n                if syntax == 'javascript':\n                    value_datatype = 'object'\n            elif value['value_datatype'] == 'list':\n                if syntax == 'javascript':\n                    value_datatype = 'array'\n            # retrieve datatype of item in list\n                item_key = key + '[0]'\n                item_datatype = self.keyMap[item_key]['value_datatype']\n                if syntax == 'javascript':\n                    if item_datatype == 'list':\n                        item_datatype = 'array'\n                    elif item_datatype == 'map':\n                        item_datatype = 'object'\n                elif 'integer_data' in self.keyMap[item_key].keys():\n                    if self.keyMap[item_key]['integer_data']:\n                        item_datatype = 'integer'\n                value_datatype += ' of %ss' % item_datatype\n            row.append(value_datatype)\n\n        # add required column\n            if value['required_field']:\n                row.append('yes')\n            else:\n                row.append('')\n\n        # add default column\n            if 'default_value' in value.keys():\n                default_values = True\n                if isinstance(value['default_value'], str):\n                    row.append('\"%s\"' % value['default_value'])\n                elif isinstance(value['default_value'], bool):\n                    row.append(str(value['default_value']).lower())\n                else:\n                    row.append(str(value['default_value']))\n            else:\n                row.append('')\n\n        # define recursive example constructor\n            def determine_example(k, v):\n                example_value = ''\n                if 'example_values' in v.keys():\n                    for i in v['example_values']:\n                        if example_value:\n                            example_value += ', '\n                        if isinstance(i, str):\n                            example_value += '\"%s\"' % i\n                        else:\n                            example_value += value\n                elif 'declared_value' in v.keys():\n                    if isinstance(v['declared_value'], str):\n                        example_value = '\"%s\"' % v['declared_value']\n                    elif isinstance(v['declared_value'], bool):\n                        example_value = str(v['declared_value']).lower()\n                    else:\n                        example_value = v['declared_value']\n                else:\n                    if v['value_datatype'] == 'map':\n                        example_value = '{...}'\n                    elif v['value_datatype'] == 'list':\n                        example_value = '[...]'\n                    elif v['value_datatype'] == 'null':\n                        example_value = 'null'\n                return example_value\n\n        # add examples column\n            row.append(determine_example(key, value))\n\n        # add additional conditions\n            conditions = ''\n            description = ''\n            for k, v in value.items():\n                extra_integer = False\n                if k == 'integer_data' and syntax == 'javascript':\n                    extra_integer = True\n                if k not in ('example_values', 'value_datatype', 'required_field', 'declared_value', 'default_value', 'field_position', 'field_metadata') or extra_integer:\n                    add_extra = False\n                    if k == 'extra_fields':\n                        if v:\n                            add_extra = True\n                    if k in ('field_description', 'field_title'):\n                        field_description = True\n                        if k == 'field_description':\n                            description = v\n                        elif not description:\n                            description = v\n                    elif k != 'extra_fields' or add_extra:\n                        additional_conditions = True\n                        if conditions:\n                            conditions += '<br>'\n                        condition_value = v\n                        if isinstance(v, str):\n                            condition_value = '\"%s\"' % v\n                        elif isinstance(v, bool):\n                            condition_value = str(v).lower()\n                        conditions += '%s: %s' % (k, condition_value)\n            row.append(conditions)\n            row.append(description)\n\n        # add row to rows\n            rows.append(row)\n\n# add rows for top field\n    top_dict = self.keyMap['.']\n    if top_dict['extra_fields']:\n        rows.append(['<i>**extra fields allowed</i>', '', '', '', '', '', ''])\n    if 'max_bytes' in top_dict.keys():\n        rows.append(['<i>**max bytes: %s</i>' % top_dict['max_bytes'], '', '', '', '', '', ''])\n\n# eliminate unused columns\n    if not field_description:\n        headers.pop()\n    if not additional_conditions:\n        headers.pop()\n    if not default_values:\n        headers.pop(3)\n    for row in rows:\n        if not field_description:\n            row.pop()\n        if not additional_conditions:\n            row.pop()\n        if not default_values:\n            row.pop(3)\n\n# construct table html\n    table_html = _tabulate(rows, headers, tablefmt='html')\n\n# add links to urls in text\n    # markdown_url = re.compile('\\[(.*?)\\]\\((.*)\\)')\n    table_html = _add_links(table_html)\n\n    return table_html", "response": "function to create a table from the class model keyMap\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register(self, app, *args, **kwargs):\n        \" Activate loginmanager and principal. \"\n\n        if not self._login_manager or self.app != app:\n            self._login_manager = LoginManager()\n            self._login_manager.user_callback = self.user_loader\n            self._login_manager.setup_app(app)\n            self._login_manager.login_view = 'urls.index'\n            self._login_manager.login_message = u'You need to be signed in for this page.'\n\n        self.app = app\n\n        if not self._principal:\n            self._principal = Principal(app)\n            identity_loaded.connect(self.identity_loaded)\n\n        super(UserManager, self).register(app, *args, **kwargs)", "response": "Activate loginmanager and principal."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trim_start(self, string, start, end=None):\n        extract = string[string.find(start) + len(start):end]\n        return extract.strip()", "response": "Removes the starting substring from the entire string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing a star s lightcurve and saves it to a file.", "response": "def process_star(filename, output, *, extension, star_name, period, shift,\n                 parameters, period_label, shift_label, **kwargs):\n    \"\"\"Processes a star's lightcurve, prints its coefficients, and saves\n    its plotted lightcurve to a file. Returns the result of get_lightcurve.\n    \"\"\"\n    if star_name is None:\n        basename = path.basename(filename)\n        if basename.endswith(extension):\n            star_name = basename[:-len(extension)]\n        else:\n            # file has wrong extension\n            return\n    if parameters is not None:\n        if period is None:\n            try:\n                period = parameters[period_label][star_name]\n            except KeyError:\n                pass\n            if shift is None:\n                try:\n                    shift = parameters.loc[shift_label][star_name]\n                except KeyError:\n                    pass\n\n    result = get_lightcurve_from_file(filename, name=star_name,\n                                      period=period, shift=shift,\n                                      **kwargs)\n    if result is None:\n        return\n    if output is not None:\n        plot_lightcurve(star_name, result['lightcurve'], result['period'],\n                        result['phased_data'], output=output, **kwargs)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef port_in_use(port, kill=False, logging=False):\n\n    command_template = 'lsof -iTCP:{0} -sTCP:LISTEN'\n    process = subprocess.Popen(command_template.format(port).split(),\n                               stdout=subprocess.PIPE)\n    headers = process.stdout.readline().decode().split()\n\n    if 'PID' not in headers:\n        _log(logging, 'Port {0} is free.'.format(port))\n        return False\n\n    index_pid = headers.index('PID')\n    index_cmd = headers.index('COMMAND')\n    row = process.stdout.readline().decode().split()\n    if len(row) < index_pid:\n        _log(logging, 'Port {0} is free.'.format(port))\n        return False\n\n    pid = int(row[index_pid])\n    command = row[index_cmd]\n    \n    if pid and command.startswith('python'):\n        _log(logging, 'Port {0} is already being used by process {1}!'\n             .format(port, pid))\n    \n        if kill:\n            _log(logging,\n                 'Killing process with id {0} listening on port {1}!'\n                 .format(pid, port))\n            os.kill(pid, signal.SIGKILL)\n\n            # Check whether it was really killed.\n            try:\n                # If still alive\n                kill_process(pid, logging)\n                # call me again\n                _log(logging,\n                     'Process {0} is still alive! checking again...'\n                     .format(pid))\n                return port_in_use(port, kill)\n            except OSError:\n                # If killed\n                return False\n        else:\n            return pid", "response": "Checks whether a port is free or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _normalize_check_url(self, check_url):\n\n        # TODO: Write tests for this method\n        split_url = urlsplit(check_url)\n        host = splitport(split_url.path or split_url.netloc)[0]\n        return '{0}://{1}:{2}'.format(self.scheme, host, self.port)", "response": "Normalizes a check_url by adding the http scheme and port if missing\n        is True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks whether a server is running.", "response": "def check(self, check_url=None):\n        \"\"\"\n        Checks whether a server is running.\n\n        :param str check_url:\n            URL where to check whether the server is running.\n            Default is ``\"http://{self.host}:{self.port}\"``.\n        \"\"\"\n\n        if check_url is not None:\n            self.check_url = self._normalize_check_url(check_url)\n\n        response = None\n        sleeped = 0.0\n        t = datetime.now()\n\n        while not response:\n            try:\n                response = requests.get(self.check_url, verify=False)\n            except requests.exceptions.ConnectionError:\n                if sleeped > self.timeout:\n                    self._kill()\n                    raise LiveAndLetDieError(\n                        '{0} server {1} didn\\'t start in specified timeout {2} '\n                        'seconds!\\ncommand: {3}'.format(\n                            self.__class__.__name__,\n                            self.check_url,\n                            self.timeout,\n                            ' '.join(self.create_command())\n                        )\n                    )\n                time.sleep(1)\n                sleeped = _get_total_seconds(datetime.now() - t)\n\n        return _get_total_seconds(datetime.now() - t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef live(self, kill_port=False, check_url=None):\n        \n        pid = port_in_use(self.port, kill_port)\n\n        if pid:\n            raise LiveAndLetDieError(\n                'Port {0} is already being used by process {1}!'\n                .format(self.port, pid)\n            )\n\n        host = str(self.host)\n        if re.match(_VALID_HOST_PATTERN, host):\n            with open(os.devnull, \"w\") as devnull:\n                if self.suppress_output:\n                    self.process = subprocess.Popen(self.create_command(),\n                                                    stderr=devnull,\n                                                    stdout=devnull,\n                                                    preexec_fn=os.setsid)\n                else:\n                    self.process = subprocess.Popen(self.create_command(),\n                                                    preexec_fn=os.setsid)\n\n            _log(self.logging, 'Starting process PID: {0}'\n                 .format(self.process.pid))\n            duration = self.check(check_url)\n            _log(self.logging,\n                 'Live server started in {0} seconds. PID: {1}'\n                 .format(duration, self.process.pid))\n            return self.process\n        else:\n            raise LiveAndLetDieError('{0} is not a valid host!'.format(host))", "response": "Starts a live server in a separate process and checks whether it is running."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef die(self):\n        if self.process:\n            _log(self.logging,\n                 'Stopping {0} server with PID: {1} running at {2}.'\n                     .format(self.__class__.__name__, self.process.pid,\n                             self.check_url))\n\n            self._kill()", "response": "Stops the server if it is running."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse command line arguments and returns a tuple of host and port.", "response": "def parse_args(cls, logging=False):\n        \"\"\"\n        Parses command line arguments.\n\n        Looks for --liveandletdie [host]\n\n        :returns:\n            A ``(str(host), int(port))`` or ``(None, None)`` tuple.\n        \"\"\"\n\n        cls._add_args()\n        args = cls._argument_parser.parse_args()\n\n        if args.liveandletdie:\n            _log(logging, 'Running as test live server at {0}'\n                 .format(args.liveandletdie))\n            return split_host(args.liveandletdie)\n        else:\n            return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap(cls, app):\n\n        host, port = cls.parse_args()\n        ssl = cls._argument_parser.parse_args().ssl\n        ssl_context = None\n\n        if host:\n            if ssl:\n                try:\n                    import OpenSSL\n                except ImportError:\n                    # OSX fix\n                    sys.path.append(\n                        '/System/Library/Frameworks/Python.framework/Versions/'\n                        '{0}.{1}/Extras/lib/python/'\n                        .format(sys.version_info.major, sys.version_info.minor)\n                    )\n\n                try:\n                    import OpenSSL\n                except ImportError:\n                    # Linux fix\n                    sys.path.append(\n                        '/usr/lib/python{0}.{1}/dist-packages/'\n                        .format(sys.version_info.major, sys.version_info.minor)\n                    )\n\n                try:\n                    import OpenSSL\n                except ImportError:\n                    raise LiveAndLetDieError(\n                        'Flask app could not be launched because the pyopenssl '\n                        'library is not installed on your system!'\n                    )\n                ssl_context = 'adhoc'\n\n            app.run(host=host, port=port, ssl_context=ssl_context)\n            sys.exit()", "response": "Adds test live server capability to a Flask app module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an absolute URL to an API resource.", "response": "def url(route, resource_id=None, pagination=None, **parameters):\n    \"\"\"\n    Generates an absolute URL to an API resource.\n\n    :param route: One of the routes available (see the header of this file)\n    :type route: string\n    :param resource_id: The resource ID you want. If None, it will point to the endpoint.\n    :type resource_id: string|None\n    :param pagination: parameters for pagination\n    :type pagination: dict|None\n    :param parameters: additional parameters required by the route\n\n    :return the absolute route to the API\n    :rtype string\n    \"\"\"\n    route = route.format(**parameters)\n\n    resource_id_url = '/' + str(resource_id) if resource_id else ''\n\n    query_parameters = ''\n    if pagination:\n        query_parameters += urlencode(pagination)\n    if query_parameters:\n        query_parameters = '?' + query_parameters\n\n    return _base_url() + route + resource_id_url + query_parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if values is composed only by iterable elements.", "response": "def is_nested(values):\n    '''Check if values is composed only by iterable elements.'''\n    return (all(isinstance(item, Iterable) for item in values)\n            if isinstance(values, Iterable) else False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_element(self, xml_element):\n\n        super(HTMLElement, self).import_element(xml_element)\n\n        self.content = self.get_html_content()", "response": "Imports the element from an lxml element and loads its content."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_dict(self):\n\n        element_dict = super(HTMLElement, self).as_dict()\n\n        if hasattr(self, 'content'):\n            element_dict['content'] = self.content\n\n        return element_dict", "response": "Serializes the object necessary data in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_html_content(self):\n\n        # Extract full element node content (including subelements)\n        html_content = ''\n        if hasattr(self, 'xml_element'):\n            xml = self.xml_element\n            content_list = [\"\" if xml.text is None else xml.text]\n\n            def to_string(xml):\n                if isinstance(xml, _Comment):\n                    return str(xml)\n                else:\n                    return ElementTree.tostring(xml).decode('utf-8')\n\n            content_list += [to_string(e) for e in xml.getchildren()]\n\n            full_xml_content = \"\".join(content_list)\n\n            # Parse tags to generate HTML valid content\n            first_regex = r'html:'\n            second_regex = r' xmlns:html=([\"\\'])(?:(?=(\\\\?))\\2.)*?\\1'\n            html_content = re.sub(first_regex, '',\n                                  re.sub(second_regex, '', full_xml_content))\n\n        return html_content", "response": "Parses the element and subelements and returns any HTML enabled text content."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_html_to_xml(self):\n\n        if hasattr(self, 'content') and self.content != '':\n            regex = r'<(?!/)(?!!)'\n            xml_content = re.sub(regex, '<xhtml:', self.content)\n            return xml_content\n        else:\n            return ''", "response": "Parses the HTML parsed texts and converts its tags to XML valid tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_xml_element(self):\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        for element in self.xml_element:\n            self.xml_element.remove(element)\n\n        self.xml_element.tail = ''\n        self.xml_element.text = self.convert_html_to_xml()\n\n        return self.xml_element", "response": "Updates the xml element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsubmit a job to the next available resource.", "response": "def submit(self, cmd_string, blocksize, job_name=\"parsl.auto\"):\n        \"\"\" Submit a job\n\n        Args:\n             - cmd_string  :(String) - Name of the container to initiate\n             - blocksize   :(float) - Number of replicas\n\n        Kwargs:\n             - job_name (String): Name for job, must be unique\n\n        Returns:\n             - None: At capacity, cannot provision more\n             - job_id: (string) Identifier for the job\n\n        \"\"\"\n        if not self.resources:\n            job_name = \"{0}-{1}\".format(job_name, time.time()).split(\".\")[0]\n\n            self.deployment_name = '{}-{}-deployment'.format(job_name,\n                                                             str(time.time()).split('.')[0])\n\n            formatted_cmd = template_string.format(command=cmd_string,\n                                                   overrides=self.config[\"execution\"][\"block\"][\"options\"].get(\"overrides\", ''))\n\n            print(\"Creating replicas :\", self.init_blocks)\n            self.deployment_obj = self._create_deployment_object(job_name,\n                                                                 self.image,\n                                                                 self.deployment_name,\n                                                                 cmd_string=formatted_cmd,\n                                                                 replicas=self.init_blocks)\n            logger.debug(\"Deployment name :{}\".format(self.deployment_name))\n            self._create_deployment(self.deployment_obj)\n            self.resources[self.deployment_name] = {'status': 'RUNNING',\n                                                    'pods': self.init_blocks}\n\n        return self.deployment_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cancel(self, job_ids):\n        for job in job_ids:\n            logger.debug(\"Terminating job/proc_id : {0}\".format(job))\n            # Here we are assuming that for local, the job_ids are the process id's\n            self._delete_deployment(job)\n\n            self.resources[job]['status'] = 'CANCELLED'\n        rets = [True for i in job_ids]\n\n        return rets", "response": "Cancels the jobs specified by a list of job ids."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a kubernetes deployment object for the job.", "response": "def _create_deployment_object(self, job_name, job_image,\n                                  deployment_name, port=80,\n                                  replicas=1,\n                                  cmd_string=None,\n                                  engine_json_file='~/.ipython/profile_default/security/ipcontroller-engine.json',\n                                  engine_dir='.'):\n        \"\"\" Create a kubernetes deployment for the job.\n\n        Args:\n              - job_name (string) : Name of the job and deployment\n              - job_image (string) : Docker image to launch\n\n        KWargs:\n             - port (integer) : Container port\n             - replicas : Number of replica containers to maintain\n\n        Returns:\n              - True: The deployment object to launch\n        \"\"\"\n\n        # sorry, quick hack that doesn't pass this stuff through to test it works.\n        # TODO it also doesn't only add what is set :(\n        security_context = None\n        if 'security' in self.config['execution']:\n            security_context = client.V1SecurityContext(run_as_group=self.group_id,\n                                                        run_as_user=self.user_id,\n                                                        run_as_non_root=self.run_as_non_root)\n            #                    self.user_id = None\n            #                    self.group_id = None\n            #                    self.run_as_non_root = None\n        # Create the enviornment variables and command to initiate IPP\n        environment_vars = client.V1EnvVar(name=\"TEST\", value=\"SOME DATA\")\n\n        launch_args = [\"-c\", \"{0}; /app/deploy.sh;\".format(cmd_string)]\n        print(launch_args)\n\n        # Configureate Pod template container\n        container = None\n        if security_context:\n            container = client.V1Container(\n                name=job_name,\n                image=job_image,\n                ports=[client.V1ContainerPort(container_port=port)],\n                command=['/bin/bash'],\n                args=launch_args,\n                env=[environment_vars],\n                security_context=security_context)\n        else:\n            container = client.V1Container(\n                name=job_name,\n                image=job_image,\n                ports=[client.V1ContainerPort(container_port=port)],\n                command=['/bin/bash'],\n                args=launch_args,\n                env=[environment_vars])\n        # Create a secret to enable pulling images from secure repositories\n        secret = None\n        if self.secret:\n            secret = client.V1LocalObjectReference(name=self.secret)\n\n        # Create and configurate a spec section\n        template = client.V1PodTemplateSpec(\n            metadata=client.V1ObjectMeta(labels={\"app\": job_name}),\n            spec=client.V1PodSpec(containers=[container], image_pull_secrets=[secret]))\n\n        # Create the specification of deployment\n        spec = client.ExtensionsV1beta1DeploymentSpec(replicas=replicas,\n                                                      template=template)\n\n        # Instantiate the deployment object\n        deployment = client.ExtensionsV1beta1Deployment(\n            api_version=\"extensions/v1beta1\",\n            kind=\"Deployment\",\n            metadata=client.V1ObjectMeta(name=deployment_name),\n            spec=spec)\n\n        return deployment"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gen_sites(path):\n    \" Seek sites by path. \"\n\n    for root, _, _ in walklevel(path, 2):\n        try:\n            yield Site(root)\n        except AssertionError:\n            continue", "response": "Seek sites by path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_site(site, path=None):\n    \" Return inited site by name (project.bracnch) or path \"\n\n    try:\n        return Site(site)\n\n    except AssertionError:\n        path = path or settings.MAKESITE_HOME\n        if op.sep in site:\n            raise\n\n        site = site if '.' in site else \"%s.master\" % site\n        project, branch = site.split('.', 1)\n        return Site(op.join(path, project, branch))", "response": "Return inited site by name ( project. bracnch ) or path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn printable information about current site.", "response": "def get_info(self, full=False):\n        \" Return printable information about current site. \"\n\n        if full:\n            context = self.as_dict()\n            return \"\".join(\"{0:<25} = {1}\\n\".format(\n                           key, context[key]) for key in sorted(context.iterkeys()))\n        return \"%s [%s]\" % (self.get_name(), self.template)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nidentify which players are agents. Errors if flattened.", "response": "def agents(self):\n        \"\"\"identify which players are agents (not observers or computers). Errors if flattened.\"\"\"\n        ret = []\n        for player in self.players:\n            if player.isComputer: continue\n            try:\n                if player.observer: continue\n            except: pass\n            ret.append(player)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef allLobbySlots(self):\n        if self.debug:\n            p      = [\"Lobby Configuration detail:\"] + \\\n                     [\"    %s:%s%s\"%(p, \" \"*(12-len(p.type)), p.name)]\n                     #[\"    agent:     %s\"%p for p in self.agents] + \\\n                     #[\"    computer:  %s, %s\"%(r,d) for r,d in self.computers]\n            if self.observers: # must separate condition because numObs is a number, not an iterator\n                p += [\"    observers: %d\"%self.observers]\n            print(os.linesep.join(p))\n        return (self.agents, self.computers, self.observers)", "response": "the current configuration of the lobby s players defined before the match starts"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nidentify the remote connection parameters", "response": "def connection(self):\n        \"\"\"identify the remote connection parameters\"\"\"\n        self.getPorts()         # acquire if necessary\n        self.getIPaddresses()   # acquire if necessary\n        return (self.ipAddress, self.ports)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nidentify the propery application to launch given the configuration", "response": "def installedApp(self):\n        \"\"\"identify the propery application to launch, given the configuration\"\"\"\n        try:    return self._installedApp\n        except: # raises if not yet defined\n            self._installedApp = runConfigs.get() # application/install/platform management\n            return self._installedApp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all participants that are partners of this game.", "response": "def participants(self):\n        \"\"\"agents + computers (i.e. all non-observers)\"\"\"\n        ret = []\n        for p in self.players:\n            try:\n                if     p.isComputer: ret.append(p)\n                if not p.isObserver: ret.append(p) # could cause an exception if player isn't a PlayerPreGame\n            except AttributeError: pass\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flatten(self, data=None):\n        if data == None: data=self.attrs\n        ret = {}\n        for k,v in iteritems(data):\n            if not v: continue # don't flatten if there's nothing to flatten\n            elif k == \"expo\":               v = v.type\n            elif k == \"version\":            v = v.label\n            elif k == \"ladder\":             v = v.name\n            elif k == \"players\":\n                newPs = []\n                for i,p in enumerate(v):\n                    try:    diff = p.difficulty.type\n                    except: diff = p.difficulty\n                    if isinstance(p, PlayerPreGame):    newPs.append( (p.name, p.type.type, p.initCmd, p.initOptions, diff, p.rating, p.selectedRace.type, self.numObserve, p.playerID, p.raceDefault) )\n                    else:                               newPs.append( (p.name, p.type.type, p.initCmd, p.initOptions, diff, p.rating) )\n                # TODO -- handle if type or observers params are not available (i.e. if a simple PlayerRecord, not a PlayerPreGame\n                ret[k] = newPs\n                continue\n            elif k == \"mode\"   and self.mode:   v = v.type\n            #elif k == \"state\":\n            elif k == \"themap\" and self.themap: v = v.name\n            ret[k] = v\n        return ret", "response": "flatten all objects into a simplified value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inflate(self, newData={}):\n        from sc2maptool.functions import selectMap\n        from sc2maptool.mapRecord import MapRecord\n        self.__dict__.update(newData)\n        #if not isinstance(self.state, types.GameStates):      self.state     = types.GameStates(self.state)\n        if self.expo    and not isinstance(self.expo, types.ExpansionNames):    self.expo       = types.ExpansionNames(self.expo)\n        if self.version and not isinstance(self.version, versions.Version):     self.version    = versions.Version(self.version)\n        if self.ladder  and not isinstance(self.ladder, Ladder):                self.ladder     = Ladder(self.ladder)\n        for i,player in enumerate(self.players): # iterate over all players\n            if       isinstance(player, str):                                   self.players[i] = getPlayer(player)\n            elif not isinstance(player, PlayerRecord):                          self.players[i] = buildPlayer(*player)\n        if self.mode    and not isinstance(self.mode, types.GameModes):         self.mode       = types.GameModes(self.mode)\n        if self.themap  and not isinstance(self.themap, MapRecord):             self.themap     = selectMap(name=self.themap)", "response": "Update the object with the new data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef launchApp(self, **kwargs):\n        app = self.installedApp\n        # TODO -- launch host in window minimized/headless mode\n        vers = self.getVersion()\n        return app.start(version=vers,#game_version=vers.baseVersion, data_version=vers.dataHash,\n            full_screen=self.fullscreen, verbose=self.debug, **kwargs)", "response": "Launch Starcraft2 process in the background using this configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, cfgFile=None, timeout=None):\n        #if cfgFile != None: self.cfgFile = cfgFile # if it's specified, use it\n        if not cfgFile:\n            cfgs = activeConfigs()\n            if   len(cfgs) > 1: raise Exception(\"found too many configurations (%s); not clear which to load: %s\"%(len(cfgs), cfgs))\n            elif len(cfgs) < 1:\n                if timeout: # wait for a configuration file to appear to be loaded\n                    startWait = time.time()\n                    timeReported = 0\n                    while not cfgs:\n                        timeWaited = time.time() - startWait\n                        if timeWaited > timeout:\n                            raise c.TimeoutExceeded(\"could not join game after %s seconds\"%(timeout))\n                        try:  cfgs = activeConfigs()\n                        except:\n                            if self.debug and timeWaited - timeReported >= 1:\n                                timeReported += 1\n                                print(\"second(s) waited for game to appear:  %d\"%(timeReported))\n                else:  raise Exception(\"must have a saved configuration to load or allow loading via timeout setting\")\n            cfgFile = cfgs.pop()\n        try:\n            with open(cfgFile, \"rb\") as f:\n                data = f.read() # bytes => str\n        except TypeError as e:\n            print(\"ERROR %s: %s %s\"%(e, cfgFile, type(cfgFile)))\n            raise\n        self.loadJson(data) # str => dict\n        if self.debug:\n            print(\"configuration loaded: %s\"%(self.name))\n            self.display()", "response": "load the data from a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the json data into the obj s attrs", "response": "def loadJson(self, data):\n        \"\"\"convert the json data into updating this obj's attrs\"\"\"\n        if not isinstance(data, dict):\n            data = json.loads(data)\n        self.__dict__.update(data)\n        self.inflate() # restore objects from str values\n        #if self.ports:  self._gotPorts = True\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the flattened dictionary into json", "response": "def toJson(self, data=None, pretty=False):\n        \"\"\"convert the flattened dictionary into json\"\"\"\n        if data==None: data = self.attrs\n        data = self.flatten(data) # don't send objects as str in json\n        #if pretty:\n        ret = json.dumps(data, indent=4, sort_keys=True)\n        #self.inflate() # restore objects from json str data\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getIPaddresses(self):\n        if not self.ipAddress:\n            self.ipAddress = ipAddresses.getAll() # update with IP address\n        return self.ipAddress", "response": "identify the IP addresses where this process client will launch the SC2 client"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nacquires ports to be used by the SC2 client launched by this process", "response": "def getPorts(self):\n        \"\"\"acquire ports to be used by the SC2 client launched by this process\"\"\"\n        if self.ports: # no need to get ports if ports are al\n            return self.ports\n        if not self._gotPorts:\n            self.ports = [\n                portpicker.pick_unused_port(), # game_port\n                portpicker.pick_unused_port(), # base_port\n                portpicker.pick_unused_port(), # shared_port / init port\n            ]\n            self._gotPorts = True\n        return self.ports"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding configuration to the SC2 protocol create request", "response": "def requestCreateDetails(self):\n        \"\"\"add configuration to the SC2 protocol create request\"\"\"\n        createReq = sc_pb.RequestCreateGame( # used to advance to Status.initGame state, when hosting\n            realtime    = self.realtime,\n            disable_fog = self.fogDisabled,\n            random_seed = int(time.time()), # a game is created using the current second timestamp as the seed\n            local_map   = sc_pb.LocalMap(map_path=self.mapLocalPath,\n                                         map_data=self.mapData))\n        for player in self.players:\n            reqPlayer = createReq.player_setup.add() # add new player; get link to settings\n            playerObj = PlayerPreGame(player)\n            if playerObj.isComputer:\n                reqPlayer.difficulty    = playerObj.difficulty.gameValue()\n            reqPlayer.type              = c.types.PlayerControls(playerObj.control).gameValue()\n            reqPlayer.race              = playerObj.selectedRace.gameValue()\n        return createReq # SC2APIProtocol.RequestCreateGame"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding configuration information to the SC2 protocol join request", "response": "def requestJoinDetails(self):\n        \"\"\"add configuration information to the SC2 protocol join request\n    REQUIREMENTS FOR SUCCESSFUL LAUNCH:\n    server game_port must match between all join requests to client (represents the host's port to sync game clients)\n    server base_port\n    client game_port must be unique between each client (represents ???)\n    client base_port\n    client shared_port must match between all join requests to client\n        \"\"\"\n        raw,score,feature,rendered = self.interfaces\n        interface = sc_pb.InterfaceOptions()\n        interface.raw   = raw   # whether raw data is reported in observations\n        interface.score = score # whether score data is reported in observations\n        interface.feature_layer.width = 24\n        #interface.feature_layer.resolution =\n        #interface.feature_layer.minimap_resolution =\n        joinReq = sc_pb.RequestJoinGame(\n            options = interface,\n            #observed_player_id=__?__,\n            race = self.whoAmI().selectedRace.gameValue())\n        # TODO -- allow player to be an observer, not just a player w/ race\n        if self.host: # always add ports for joining player to connect to defined host\n            hostPorts = self.host[1]\n            joinReq.server_ports.game_port = hostPorts[0]\n            joinReq.server_ports.base_port = hostPorts[1]\n            joinReq.shared_port            = hostPorts[2]\n            clientPorts = joinReq.client_ports.add()\n            clientPorts.game_port = self.ports[0]\n            clientPorts.base_port = self.ports[1]\n            ret = self.ports[2]\n        elif self.isMultiplayer: # always add ports as host of multiple agents/clients\n            if len(self.ports) < 5:\n                self.ports += [ # get new private client ports for the host\n                    portpicker.pick_unused_port(), # game_port\n                    portpicker.pick_unused_port(), # base_port\n                ]\n            joinReq.server_ports.game_port = self.ports[0]\n            joinReq.server_ports.base_port = self.ports[1]\n            joinReq.shared_port            = self.ports[2]\n            clientPorts = joinReq.client_ports.add()\n            clientPorts.game_port = self.ports[3] # new private client game port\n            clientPorts.base_port = self.ports[4] # new private client base port\n        return joinReq # SC2APIProtocol.RequestJoinGame"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef returnPorts(self):\n        if self._gotPorts:\n            #print(\"deleting ports >%s<\"%(self.ports))\n            map(portpicker.return_port, self.ports)\n            self._gotPorts = False\n        self.ports = []", "response": "deallocate specific ports on the current machine"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self, filename=None, debug=False):\n        if not filename: filename = self.name\n        with open(filename, \"w\") as f: # save config data file\n            f.write(self.toJson(self.attrs))\n        if self.debug or debug:\n            print(\"saved configuration %s\"%(self.name))\n            for k,v in sorted(iteritems(self.attrs)):\n                print(\"%15s : %s\"%(k,v))", "response": "save a data file such that all processes know the game that is running"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef updateIDs(self, ginfo, tag=None, debug=False):\n            # SC2APIProtocol.ResponseGameInfo attributes:\n                # map_name\n                # mod_names\n                # local_map_path\n                # player_info\n                # start_raw\n                # options\n        thisPlayer = self.whoAmI()\n        for pInfo in ginfo.player_info: # parse ResponseGameInfo.player_info to validate player information (SC2APIProtocol.PlayerInfo) against the specified configuration\n            pID = pInfo.player_id\n            if pID == thisPlayer.playerID: continue # already updated\n            pCon = c.types.PlayerControls(pInfo.type)\n            rReq = c.types.SelectRaces(pInfo.race_requested)\n            for p in self.players: # ensure joined player is identified appropriately\n                if p.playerID and p.playerID != pID: continue # if this non-matching player already has a set playerID, it can't match\n                if p.control == pCon and p.selectedRace == rReq: # matched player\n                    p.playerID = pID # updated player IDs should be saved into the game configuration\n                    if debug: print(\"[%s] match contains %s.\"%(tag, p))\n                    pID = 0 # declare that the player has been identified\n                    break\n            if pID: raise c.UnknownPlayer(\"could not match %s %s %s to any \"\n                \"existing player of %s\"%(pID, pCon, rReq, self.players))", "response": "Update the player ID of all players in the game with the information in ginfo."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the player object that owns this configuration", "response": "def whoAmI(self):\n        \"\"\"return the player object that owns this configuration\"\"\"\n        self.inflate() # ensure self.players contains player objects\n        if self.thePlayer:\n            for p in self.players:\n                if p.name != self.thePlayer: continue\n                return p\n        elif len(self.players) == 1:\n            ret = self.players[0]\n            self.thePlayer = ret.name # remember this for the future in case more players are added\n            return ret\n        raise Exception(\"could not identify which player this is given %s (%s)\"%(self.players, self.thePlayer))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request(self, service, data):\n        _res = self._request(service, data)\n        res = _res.json()[0][0]\n        if res[\"success\"] == True:\n            return res[\"result\"]\n        else:\n            err_msg = res[\"errmsg\"]\n            raise Exception(\"Request not successful: '{0}'\".format(err_msg))", "response": "Makes a call to TinyLetter s __svcbus__ endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of messages that have been sent.", "response": "def get_messages(self,\n            statuses=DEFAULT_MESSAGE_STATUSES,\n            order=\"sent_at desc\",\n            offset=None,\n            count=None,\n            content=False):\n        \"\"\"Returns a list of messages your account sent.\n        \n        Messages are sorted by ``order``, starting at an optional integer ``offset``, and optionally limited to the first ``count`` items (in sorted order).\n\n        Returned data includes various statistics about each message, e.g., ``total_opens``, ``open_rate``, ``total_clicks``, ``unsubs``, ``soft_bounces``. If ``content=True``, the returned data will also include HTML content of each message.\n        \"\"\"\n\n        req_data = [ { \"status\": statuses }, order, fmt_paging(offset, count) ]\n        service = \"query:Message.stats\"\n        if content: service += \", Message.content\"\n        return self.request(service, req_data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_drafts(self, **kwargs):\n        default_kwargs = { \"order\": \"updated_at desc\" }\n        default_kwargs.update(kwargs)\n        return self.get_messages(statuses=[\"draft\"], **default_kwargs)", "response": "Same as Session. get_messages but where statuses = draft."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_urls(self, order=\"total_clicks desc\", offset=None, count=None):\n        req_data = [ None, order, fmt_paging(offset, count) ]\n        return self.request(\"query:Message_Url\", req_data)", "response": "Returns a list of URLs you ve included in messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_message_urls(self, message_id, order=\"total_clicks desc\"):\n        req_data = [ { \"message_id\": str(message_id) }, order, None ]\n        return self.request(\"query:Message_Url\", req_data)", "response": "Returns a list of URLs you ve included in a specific message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of subscribers.", "response": "def get_subscribers(self, \n            order=\"created_at desc\",\n            offset=None,\n            count=None):\n        \"\"\"Returns a list of subscribers.\n        \n        List is sorted by most-recent-to-subsribe, starting at an optional integer ``offset``, and optionally limited to the first ``count`` items (in sorted order).\n\n        Returned data includes various statistics about each subscriber, e.g., ``total_sent``, ``total_opens``, ``total_clicks``.\n        \"\"\"\n        req_data = [ None, order, fmt_paging(offset, count)]\n        return self.request(\"query:Contact.stats\", req_data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the status of a list of jobs identified by their ids.", "response": "def status(self, job_ids):\n        '''  Get the status of a list of jobs identified by their ids.\n\n        Args:\n            - job_ids (List of ids) : List of identifiers for the jobs\n\n        Returns:\n            - List of status codes.\n\n        '''\n\n        logging.debug(\"Checking status of : {0}\".format(job_ids))\n        for job_id in self.resources:\n            poll_code = self.resources[job_id]['proc'].poll()\n            if self.resources[job_id]['status'] in ['COMPLETED', 'FAILED']:\n                continue\n\n            if poll_code is None:\n                self.resources[job_id]['status'] = 'RUNNING'\n            elif poll_code == 0 and self.resources[job_id]['status'] != 'RUNNING':\n                self.resources[job_id]['status'] = 'COMPLETED'\n            elif poll_code < 0 and self.resources[job_id]['status'] != 'RUNNING':\n                self.resources[job_id]['status'] = 'FAILED'\n\n        return [self.resources[jid]['status'] for jid in job_ids]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the submit script to the submit script file.", "response": "def _write_submit_script(self, script_string, script_filename):\n        '''\n        Load the template string with config values and write the generated submit script to\n        a submit script file.\n\n        Args:\n              - template_string (string) : The template string to be used for the writing submit script\n              - script_filename (string) : Name of the submit script\n\n        Returns:\n              - True: on success\n\n        Raises:\n              SchedulerMissingArgs : If template is missing args\n              ScriptPathError : Unable to write submit script out\n        '''\n\n        try:\n            with open(script_filename, 'w') as f:\n                f.write(script_string)\n\n        except KeyError as e:\n            logger.error(\"Missing keys for submit script : %s\", e)\n            raise (ep_error.SchedulerMissingArgs(e.args, self.label))\n\n        except IOError as e:\n            logger.error(\"Failed writing to submit script: %s\", script_filename)\n            raise (ep_error.ScriptPathError(script_filename, e))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsubmit a command onto a Local Resource Manager job of blocksize parallel elements.", "response": "def submit(self, command, blocksize, job_name=\"parsl.auto\"):\n        ''' Submits the command onto an Local Resource Manager job of blocksize parallel elements.\n        Submit returns an ID that corresponds to the task that was just submitted.\n\n        If tasks_per_node <  1:\n             1/tasks_per_node is provisioned\n\n        If tasks_per_node == 1:\n             A single node is provisioned\n\n        If tasks_per_node >  1 :\n             tasks_per_node * blocksize number of nodes are provisioned.\n\n        Args:\n             - command  :(String) Commandline invocation to be made on the remote side.\n             - blocksize   :(float) - Not really used for local\n\n        Kwargs:\n             - job_name (String): Name for job, must be unique\n\n        Returns:\n             - None: At capacity, cannot provision more\n             - job_id: (string) Identifier for the job\n\n        '''\n\n        job_name = \"{0}.{1}\".format(job_name, time.time())\n\n        # Set script path\n        script_path = \"{0}/{1}.sh\".format(self.script_dir, job_name)\n        script_path = os.path.abspath(script_path)\n\n        wrap_command = self.launcher(command, self.tasks_per_node, self.nodes_per_block)\n\n        self._write_submit_script(wrap_command, script_path)\n\n        job_id, proc = self.channel.execute_no_wait('bash {0}'.format(script_path), 3)\n        self.resources[job_id] = {'job_id': job_id, 'status': 'RUNNING', 'blocksize': blocksize, 'proc': proc}\n\n        return job_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cancel(self, job_ids):\n        ''' Cancels the jobs specified by a list of job ids\n\n        Args:\n        job_ids : [<job_id> ...]\n\n        Returns :\n        [True/False...] : If the cancel operation fails the entire list will be False.\n        '''\n\n        for job in job_ids:\n            logger.debug(\"Terminating job/proc_id : {0}\".format(job))\n            # Here we are assuming that for local, the job_ids are the process id's\n            proc = self.resources[job]['proc']\n            os.killpg(os.getpgid(proc.pid), signal.SIGTERM)\n            self.resources[job]['status'] = 'CANCELLED'\n        rets = [True for i in job_ids]\n\n        return rets", "response": "Cancels the jobs specified by a list of job ids."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_bare(self):\n        # Make sure the local repository exists.\n        self.create()\n        # Check the global revision id of the working tree.\n        try:\n            output = self.context.capture('hg', 'id', silent=True)\n            tokens = output.split()\n            return int(tokens[0]) == 0\n        except Exception:\n            return False", "response": "Check if the local repository is bare."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_conflicts(self):\n        filenames = set()\n        listing = self.context.capture('hg', 'resolve', '--list')\n        for line in listing.splitlines():\n            tokens = line.split(None, 1)\n            if len(tokens) == 2:\n                status, name = tokens\n                if status and name and status.upper() != 'R':\n                    filenames.add(name)\n        return sorted(filenames)", "response": "The filenames of any files with merge conflicts ( a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the branches in the Mercurial repository.", "response": "def find_branches(self):\n        \"\"\"\n        Find the branches in the Mercurial repository.\n\n        :returns: A generator of :class:`.Revision` objects.\n\n        .. note:: Closed branches are not included.\n        \"\"\"\n        listing = self.context.capture('hg', 'branches')\n        for line in listing.splitlines():\n            tokens = line.split()\n            if len(tokens) >= 2 and ':' in tokens[1]:\n                revision_number, revision_id = tokens[1].split(':')\n                yield Revision(\n                    branch=tokens[0],\n                    repository=self,\n                    revision_id=revision_id,\n                    revision_number=int(revision_number),\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_revision_id(self, revision=None):\n        # Make sure the local repository exists.\n        self.create()\n        # Try to find the revision id of the specified revision.\n        revision = revision or self.default_revision\n        output = self.context.capture('hg', 'id', '--rev=%s' % revision, '--debug', '--id').rstrip('+')\n        # Validate the `hg id --debug --id' output.\n        return self.ensure_hexadecimal_string(output, 'hg id --id')", "response": "Find the global revision id of the given revision."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the local revision number of the given revision.", "response": "def find_revision_number(self, revision=None):\n        \"\"\"Find the local revision number of the given revision.\"\"\"\n        # Make sure the local repository exists.\n        self.create()\n        # Try to find the revision number of the specified revision.\n        revision = revision or self.default_revision\n        output = self.context.capture('hg', 'id', '--rev=%s' % revision, '--num').rstrip('+')\n        # Validate the `hg id --num' output.\n        if not output.isdigit():\n            msg = \"Failed to find local revision number! ('hg id --num' gave unexpected output)\"\n            raise EnvironmentError(msg)\n        return int(output)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_tags(self):\n        listing = self.context.capture('hg', 'tags')\n        for line in listing.splitlines():\n            tokens = line.split()\n            if len(tokens) >= 2 and ':' in tokens[1]:\n                revision_number, revision_id = tokens[1].split(':')\n                yield Revision(\n                    repository=self,\n                    revision_id=revision_id,\n                    revision_number=int(revision_number),\n                    tag=tokens[0],\n                )", "response": "Find information about the tags in the repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the command to update the working tree of the local repository.", "response": "def get_checkout_command(self, revision, clean=False):\n        \"\"\"Get the command to update the working tree of the local repository.\"\"\"\n        command = ['hg', 'update']\n        if clean:\n            command.append('--clean')\n        command.append('--rev=%s' % revision)\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the command to commit changes to tracked files in the working tree.", "response": "def get_commit_command(self, message, author=None):\n        \"\"\"\n        Get the command to commit changes to tracked files in the working tree.\n\n        This method uses the ``hg remove --after`` to match the semantics of\n        ``git commit --all`` (which is _not_ the same as ``hg commit\n        --addremove``) however ``hg remove --after`` is _very_ verbose (it\n        comments on every existing file in the repository) and it ignores the\n        ``--quiet`` option. This explains why I've decided to silence the\n        standard error stream (though I feel I may regret this later).\n        \"\"\"\n        tokens = ['hg remove --after 2>/dev/null; hg commit']\n        if author:\n            tokens.append('--user=%s' % quote(author.combined))\n        tokens.append('--message=%s' % quote(message))\n        return [' '.join(tokens)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the command to delete or close a branch in the local repository.", "response": "def get_delete_branch_command(self, branch_name, message, author):\n        \"\"\"Get the command to delete or close a branch in the local repository.\"\"\"\n        tokens = ['hg update --rev=%s && hg commit' % quote(branch_name)]\n        if author:\n            tokens.append('--user=%s' % quote(author.combined))\n        tokens.append('--message=%s' % quote(message))\n        tokens.append('--close-branch')\n        return [' '.join(tokens)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_pull_command(self, remote=None, revision=None):\n        command = ['hg', 'pull']\n        if remote:\n            command.append(remote)\n        if revision:\n            command.append('--rev=%s' % revision)\n        return command", "response": "Get the command to pull changes from a remote repository into the local repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(self):\n\n        try:\n            self.sock.connect((self._host, self._port))\n            _LOGGER.info(\"Successfully connected to Russound on %s:%s\", self._host, self._port)\n            return True\n        except socket.error as msg:\n            _LOGGER.error(\"Error trying to connect to Russound controller.\")\n            _LOGGER.error(msg)\n            return False", "response": "Connect to the Russound controller."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nswitch power on or off to a specific zone.", "response": "def set_power(self, controller, zone, power):\n        \"\"\" Switch power on/off to a zone\n        :param controller: Russound Controller ID. For systems with one controller this should be a value of 1.\n        :param zone: The zone to be controlled. Expect a 1 based number.\n        :param power: 0 = off, 1 = on\n        \"\"\"\n\n        _LOGGER.debug(\"Begin - controller= %s, zone= %s, change power to %s\",controller, zone, power)\n        send_msg = self.create_send_message(\"F0 @cc 00 7F 00 00 @kk 05 02 02 00 00 F1 23 00 @pr 00 @zz 00 01\",\n                                            controller, zone, power)\n        try:\n            self.lock.acquire()\n            _LOGGER.debug('Zone %s - acquired lock for ', zone)\n            self.send_data(send_msg)\n            _LOGGER.debug(\"Zone %s - sent message %s\", zone, send_msg)\n            self.get_response_message()  # Clear response buffer\n        finally:\n            self.lock.release()\n            _LOGGER.debug(\"Zone %s - released lock for \", zone)\n            _LOGGER.debug(\"End - controller %s, zone %s, power set to %s.\\n\", controller, zone, power)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_volume(self, controller, zone, volume):\n\n        _LOGGER.debug(\"Begin - controller= %s, zone= %s, change volume to %s\",controller, zone, volume)\n        send_msg = self.create_send_message(\"F0 @cc 00 7F 00 00 @kk 05 02 02 00 00 F1 21 00 @pr 00 @zz 00 01\",\n                                            controller, zone, volume // 2)\n        try:\n            self.lock.acquire()\n            _LOGGER.debug('Zone %s - acquired lock for ', zone)\n            self.send_data(send_msg)\n            _LOGGER.debug(\"Zone %s - sent message %s\", zone, send_msg)\n            self.get_response_message()  # Clear response buffer\n        finally:\n            self.lock.release()\n            _LOGGER.debug(\"Zone %s - released lock for \", zone)\n            _LOGGER.debug(\"End - controller %s, zone %s, volume set to %s.\\n\", controller, zone, volume)", "response": "Set the volume for a specific controller and zone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the source for a specific controller and zone.", "response": "def set_source(self, controller, zone, source):\n        \"\"\" Set source for a zone - 0 based value for source \"\"\"\n\n        _LOGGER.info(\"Begin - controller= %s, zone= %s change source to %s.\", controller, zone, source)\n        send_msg = self.create_send_message(\"F0 @cc 00 7F 00 @zz @kk 05 02 00 00 00 F1 3E 00 00 00 @pr 00 01\",\n                                            controller, zone, source)\n        try:\n            self.lock.acquire()\n            _LOGGER.debug('Zone %s - acquired lock for ', zone)\n            self.send_data(send_msg)\n            _LOGGER.debug(\"Zone %s - sent message %s\", zone, send_msg)\n            # Clear response buffer in case there is any response data(ensures correct results on future reads)\n            self.get_response_message()\n        finally:\n            self.lock.release()\n            _LOGGER.debug(\"Zone %s - released lock for \", zone)\n            _LOGGER.debug(\"End - controller= %s, zone= %s source set to %s.\\n\", controller, zone, source)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all_on_off(self, power):\n\n        send_msg = self.create_send_message(\"F0 7F 00 7F 00 00 @kk 05 02 02 00 00 F1 22 00 00 @pr 00 00 01\",\n                                            None, None, power)\n        self.send_data(send_msg)\n        self.get_response_message()", "response": "Turn all zones on or off"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntoggle mute on or off for a specific resource.", "response": "def toggle_mute(self, controller, zone):\n        \"\"\" Toggle mute on/off for a zone\n        Note: Not tested (acambitsis) \"\"\"\n\n        send_msg = self.create_send_message(\"F0 @cc 00 7F 00 @zz @kk 05 02 02 00 00 F1 40 00 00 00 0D 00 01\",\n                                            controller, zone)\n        self.send_data(send_msg)\n        self.get_response_message()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all relevant info for the specified zone.", "response": "def get_zone_info(self, controller, zone, return_variable):\n        \"\"\" Get all relevant info for the zone\n            When called with return_variable == 4, then the function returns a list with current\n             volume, source and ON/OFF status.\n            When called with 0, 1 or 2, it will return an integer with the Power, Source and Volume \"\"\"\n\n        # Define the signature for a response message, used later to find the correct response from the controller.\n        # FF is the hex we use to signify bytes that need to be ignored when comparing to response message.\n        # resp_msg_signature = self.create_response_signature(\"04 02 00 @zz 07 00 00 01 00 0C\", zone)\n\n        _LOGGER.debug(\"Begin - controller= %s, zone= %s, get status\", controller, zone)\n        resp_msg_signature = self.create_response_signature(\"04 02 00 @zz 07\", zone)\n        send_msg = self.create_send_message(\"F0 @cc 00 7F 00 00 @kk 01 04 02 00 @zz 07 00 00\", controller, zone)\n        try:\n            self.lock.acquire()\n            _LOGGER.debug('Acquired lock for zone %s', zone)\n            self.send_data(send_msg)\n            _LOGGER.debug(\"Zone: %s Sent: %s\", zone, send_msg)\n            # Expected response is as per pg 23 of cav6.6_rnet_protocol_v1.01.00.pdf\n            matching_message = self.get_response_message(resp_msg_signature)\n            if matching_message is not None:\n                # Offset of 11 is the position of return data payload is that we require for the signature we are using.\n                _LOGGER.debug(\"matching message to use= %s\", matching_message)\n                _LOGGER.debug(\"matching message length= %s\", len(matching_message))\n                if return_variable == 4:\n                    return_value = [matching_message[11], matching_message[12], matching_message[13]]\n                else:\n                    return_value = matching_message[return_variable + 11]\n            else:\n                return_value = None\n                _LOGGER.warning(\"Did not receive expected Russound power state for controller %s and zone %s.\", controller, zone)\n        finally:\n            self.lock.release()\n            _LOGGER.debug(\"Released lock for zone %s\", zone)\n            _LOGGER.debug(\"End - controller= %s, zone= %s, get status \\n\", controller, zone)\n            return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_volume(self, controller, zone):\n        volume_level = self.get_zone_info(controller, zone, 2)\n        if volume_level is not None:\n            volume_level *= 2\n        return volume_level", "response": "Gets the volume level of the given controller and zone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a send message from a string", "response": "def create_send_message(self, string_message, controller, zone=None, parameter=None):\n        \"\"\" Creates a message from a string, substituting the necessary parameters,\n        that is ready to send to the socket \"\"\"\n\n        cc = hex(int(controller) - 1).replace('0x', '')  # RNET requires controller value to be zero based\n        if zone is not None:\n            zz = hex(int(zone) - 1).replace('0x', '')  # RNET requires zone value to be zero based\n        else:\n            zz = ''\n        if parameter is not None:\n            pr = hex(int(parameter)).replace('0x', '')\n        else:\n            pr = ''\n\n        string_message = string_message.replace('@cc', cc)  # Replace controller parameter\n        string_message = string_message.replace('@zz', zz)  # Replace zone parameter\n        string_message = string_message.replace('@kk', KEYPAD_CODE)  # Replace keypad parameter\n        string_message = string_message.replace('@pr', pr)  # Replace specific parameter to message\n\n        # Split message into an array for each \"byte\" and add the checksum and end of message bytes\n        send_msg = string_message.split()\n        send_msg = self.calc_checksum(send_msg)\n        return send_msg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_response_signature(self, string_message, zone):\n\n        zz = ''\n        if zone is not None:\n            zz = hex(int(zone)-1).replace('0x', '')  # RNET requires zone value to be zero based\n        string_message = string_message.replace('@zz', zz)  # Replace zone parameter\n        return string_message", "response": "Create a response signature for a message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend data to connected gateway.", "response": "def send_data(self, data, delay=COMMAND_DELAY):\n        \"\"\" Send data to connected gateway \"\"\"\n\n        time_since_last_send = time.time() - self._last_send\n        delay = max(0, delay - time_since_last_send)\n        time.sleep(delay)  # Ensure minim recommended delay since last send\n\n        for item in data:\n            data = bytes.fromhex(str(item.zfill(2)))\n            try:\n                self.sock.send(data)\n            except ConnectionResetError as msg:\n                _LOGGER.error(\"Error trying to connect to Russound controller. \"\n                              \"Check that no other device or system is using the port that \"\n                              \"you are trying to connect to. Try resetting the bridge you are using to connect.\")\n                _LOGGER.error(msg)\n        self._last_send = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_response_message(self, resp_msg_signature=None, delay=COMMAND_DELAY):\n\n        matching_message = None  # Set intial value to none (assume no response found)\n        if resp_msg_signature is None:\n            no_of_socket_reads = 1  # If we are not looking for a specific response do a single read to clear the buffer\n        else:\n            no_of_socket_reads = 10 # Try 10x (= approx 1s at default)if we are looking for a specific response\n\n        time.sleep(delay)  # Insert recommended delay to ensure command is processed correctly\n        self.sock.setblocking(0)  # Needed to prevent request for waiting indefinitely\n\n        data = B''\n        for i in range(0, no_of_socket_reads):\n            try:\n                # Receive what has been sent\n                data += self.sock.recv(4096)\n                _LOGGER.debug('i= %s; len= %s data= %s', i, len(data), '[{}]'.format(', '.join(hex(x) for x in data)))\n            except BlockingIOError:  # Expected outcome if there is not data\n                _LOGGER.debug('Passed=%s', i)\n                pass\n            except ConnectionResetError as msg:\n                _LOGGER.error(\"Error trying to connect to Russound controller. Check that no other device or system \"\n                              \"is using the port that you are trying to connect to. \"\n                              \"Try resetting the bridge you are using to connect.\")\n                _LOGGER.error(msg)\n            # Check if we have our message.  If so break out else keep looping.\n            if resp_msg_signature is not None:  # If we are looking for a specific response\n                matching_message, data = self.find_signature(data, resp_msg_signature)\n            if matching_message is not None:  # Required response found\n                _LOGGER.debug(\"Number of reads=%s\", i + 1)\n                break\n            time.sleep(delay)  # Wait before reading again - default of 100ms\n        return matching_message", "response": "Get the response message from the connected gateway and if required seach and return a stream that starts at the required\n        response message signature."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes the stream of bytes received and finds a message that matches the signature.", "response": "def find_signature(self, data_stream, msg_signature):\n        \"\"\" Takes the stream of bytes received and looks for a message that matches the signature\n        of the expected response \"\"\"\n\n        signature_match_index = None  # The message that will be returned if it matches the signature\n        msg_signature = msg_signature.split()  # Split into list\n        # convert to bytearray in order to be able to compare with the messages list which contains bytearrays\n        msg_signature = bytearray(int(x, 16) for x in msg_signature)\n        # loop through each message returned from Russound\n        index_of_last_f7 = None\n        for i in range(len(data_stream)):\n            if data_stream[i] == 247:\n                index_of_last_f7 = i\n            # the below line checks for the matching signature, ensuring ALL bytes of the response have been received\n            if (data_stream[i:i + len(msg_signature)] == msg_signature) and (len(data_stream) - i >= 24):\n                signature_match_index = i\n                break\n        if signature_match_index is None:\n            # Scrap bytes up to end of msg (to avoid searching these again)\n            data_stream = data_stream[index_of_last_f7:len(data_stream)]\n            matching_message = None\n        else:\n            matching_message = data_stream[signature_match_index:len(data_stream)]\n\n        _LOGGER.debug(\"Message signature found at location: %s\", signature_match_index)\n        return matching_message, data_stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calc_checksum(self, data):\n\n        output = 0\n        length = len(data)\n        for value in data:\n            output += int(value, 16)\n\n        output += length\n        checksum = hex(output & int('0x007F', 16)).lstrip(\"0x\")\n        data.append(checksum)\n        data.append('F7')\n        return data", "response": "Calculate the checksum of the data we need"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a factory that generates a CRAB client.", "response": "def crab_factory(**kwargs):\n    '''\n    Factory that generates a CRAB client.\n\n    A few parameters will be handled by the factory, other parameters will\n    be passed on to the client.\n\n    :param wsdl: `Optional.` Allows overriding the default CRAB wsdl url.\n    :param proxy: `Optional.` A dictionary of proxy information that is passed\n        to the underlying :class:`suds.client.Client`\n    :rtype: :class:`suds.client.Client`\n    '''\n    if 'wsdl' in kwargs:\n        wsdl = kwargs['wsdl']\n        del kwargs['wsdl']\n    else:\n        wsdl = \"http://crab.agiv.be/wscrab/wscrab.svc?wsdl\"\n    log.info('Creating CRAB client with wsdl: %s', wsdl)\n    c = Client(\n        wsdl,\n        **kwargs\n    )\n    return c"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef crab_request(client, action, *args):\n    '''\n    Utility function that helps making requests to the CRAB service.\n\n    :param client: A :class:`suds.client.Client` for the CRAB service.\n    :param string action: Which method to call, eg. `ListGewesten`\n    :returns: Result of the SOAP call.\n\n    .. versionadded:: 0.3.0\n    '''\n    log.debug('Calling %s on CRAB service.', action)\n    return getattr(client.service, action)(*args)", "response": "Utility function that helps making requests to the CRAB service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_bare(self):\n        # Make sure the local repository exists.\n        self.create()\n        # Check the existence of the directory.\n        checkout_directory = os.path.join(self.vcs_directory, 'checkout')\n        return not self.context.is_directory(checkout_directory)", "response": "Check if the local repository is bare."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_revision_id(self, revision=None):\n        # Make sure the local repository exists.\n        self.create()\n        # Try to find the revision id of the specified revision.\n        revision = revision or self.default_revision\n        output = self.context.capture(\n            'bzr', 'version-info', '--revision=%s' % revision,\n            '--custom', '--template={revision_id}',\n        )\n        # Validate the `bzr version-info' output.\n        if not output:\n            msg = \"Failed to find global revision id! ('bzr version-info' gave unexpected output)\"\n            raise ValueError(msg)\n        return output", "response": "Find the global revision id of the given revision."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_revision_number(self, revision=None):\n        # Make sure the local repository exists.\n        self.create()\n        # Try to find the revision number of the specified revision.\n        revision = revision or self.default_revision\n        output = self.context.capture('bzr', 'log', '--revision=..%s' % revision, '--line')\n        revision_number = len([line for line in output.splitlines() if not is_empty_line(line)])\n        if not (revision_number > 0):\n            msg = \"Failed to find local revision number! ('bzr log --line' gave unexpected output)\"\n            raise EnvironmentError(msg)\n        return revision_number", "response": "Find the local revision number of the given revision."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding a list of revisions for all the tags in the repository.", "response": "def find_tags(self):\n        \"\"\"\n        Find information about the tags in the repository.\n\n        .. note:: The ``bzr tags`` command reports tags pointing to\n                  non-existing revisions as ``?`` but doesn't provide revision\n                  ids. We can get the revision ids using the ``bzr tags\n                  --show-ids`` command but this command doesn't mark tags\n                  pointing to non-existing revisions. We combine the output of\n                  both because we want all the information.\n        \"\"\"\n        valid_tags = []\n        listing = self.context.capture('bzr', 'tags')\n        for line in listing.splitlines():\n            tokens = line.split()\n            if len(tokens) == 2 and tokens[1] != '?':\n                valid_tags.append(tokens[0])\n        listing = self.context.capture('bzr', 'tags', '--show-ids')\n        for line in listing.splitlines():\n            tokens = line.split()\n            if len(tokens) == 2 and tokens[0] in valid_tags:\n                tag, revision_id = tokens\n                yield Revision(\n                    repository=self,\n                    revision_id=tokens[1],\n                    tag=tokens[0],\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_commit_command(self, message, author=None):\n        command = ['bzr', 'commit']\n        if author:\n            command.extend(('--author', author.combined))\n        command.append('--message')\n        command.append(message)\n        return command", "response": "Get the command to commit changes to tracked files in the working tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_pull_command(self, remote=None, revision=None):\n        if revision:\n            raise NotImplementedError(compact(\"\"\"\n                Bazaar repository support doesn't include\n                the ability to pull specific revisions!\n            \"\"\"))\n        command = ['bzr', 'pull']\n        if remote:\n            command.append(remote)\n        return command", "response": "Get the command to pull changes from a remote repository into the local repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the command to push changes from the local repository to a remote repository.", "response": "def get_push_command(self, remote=None, revision=None):\n        \"\"\"Get the command to push changes from the local repository to a remote repository.\"\"\"\n        if revision:\n            raise NotImplementedError(compact(\"\"\"\n                Bazaar repository support doesn't include\n                the ability to push specific revisions!\n            \"\"\"))\n        command = ['bzr', 'push']\n        if remote:\n            command.append(remote)\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the context of this repository with the current configuration.", "response": "def update_context(self):\n        \"\"\"\n        Make sure Bazaar respects the configured author.\n\n        This method first calls :func:`.Repository.update_context()` and then\n        it sets the ``$BZR_EMAIL`` environment variable based on the value of\n        :attr:`~Repository.author` (but only if :attr:`~Repository.author` was\n        set by the caller).\n\n        This is a workaround for a weird behavior of Bazaar that I've observed\n        when running under Python 2.6: The ``bzr commit --author`` command line\n        option is documented but it doesn't prevent Bazaar from nevertheless\n        reporting the following error::\n\n         bzr: ERROR: Unable to determine your name.\n         Please, set your name with the 'whoami' command.\n         E.g. bzr whoami \"Your Name <name@example.com>\"\n        \"\"\"\n        # Call our superclass.\n        super(BzrRepo, self).update_context()\n        # Try to ensure that $BZR_EMAIL is set (see above for the reason)\n        # but only if the `author' property was set by the caller (more\n        # specifically there's no point in setting $BZR_EMAIL to the\n        # output of `bzr whoami').\n        if self.__dict__.get('author'):\n            environment = self.context.options.setdefault('environment', {})\n            environment.setdefault('BZR_EMAIL', self.author.combined)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the executable path for this platform. Possibly find the latest build.", "response": "def exec_path(self, baseVersion=None):\n    \"\"\"Get the exec_path for this platform. Possibly find the latest build.\"\"\"\n    if not os.path.isdir(self.data_dir):\n        raise sc_process.SC2LaunchError(\"Install Starcraft II at %s or set the SC2PATH environment variable\"%(self.data_dir))\n    if baseVersion==None: # then select most recent version's baseVersion\n        mostRecent = versions.handle.mostRecent\n        if mostRecent:  return mostRecent[\"base-version\"]\n        raise sc_process.SC2LaunchError(\n            \"When requesting a versioned executable path without specifying base-version, expected \"\n            \"to find StarCraft II versions installed at %s.\"%(self.versionsDir))\n    elif isinstance(baseVersion, versions.Version):\n        baseVersion = baseVersion.baseVersion\n    elif str(baseVersion).count(\".\") > 0:\n        baseVersion = versions.Version(baseVersion).baseVersion\n    #else: # otherwise expect that the baseVersion specified is correct\n    baseVersExec = os.path.join(self.versionsDir, \"Base%s\"%baseVersion, self._exec_name)\n    if os.path.isfile(baseVersExec):\n        return baseVersExec # if baseVersion in Versions subdir is valid, it is the correct executable\n    raise sc_process.SC2LaunchError(\"Specified baseVersion %s does not exist at %s.%s    available: %s\"%(\\\n        baseVersion, baseVersExec, os.linesep, \" \".join(\n            str(val) for val in sorted(self.versionMap().keys())) ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self, version=None, **kwargs):#game_version=None, data_version=None, **kwargs):\n    if not version:\n        version = self.mostRecentVersion\n    pysc2Version = lib.Version( # convert to pysc2 Version\n        version.version,\n        version.baseVersion,\n        version.dataHash,\n        version.fixedHash)\n    return sc_process.StarcraftProcess(\n                self,\n                exec_path=self.exec_path(version.baseVersion),\n                version=pysc2Version,\n                **kwargs)", "response": "Launch the game process."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclick the specified element or element.", "response": "def press(self, coordinate, success=None):\n        \"\"\"Success must be given as a tuple of a (coordinate, timeout).\n        Use (coordinate,) if you want to use the default timeout.\"\"\"\n        if isinstance(coordinate, WebElement):\n            coordinate.click()\n        else:\n            self.get_element(coordinate).click()\n        if success is not None:\n            assert self.is_available(*success)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_text(self, coordinate, text, select2drop=None):\n        '''\n        :param an element or a locator of the select element\n        :param a selection text or selection index to be selected\n        :param the select2 dropdown locator\n        :return: True\n        '''\n        if not isinstance(coordinate, Select):\n            if isinstance(coordinate, str):\n                element = self.get_element(coordinate)\n            else:\n                element = coordinate\n            if element.tag_name.lower() != \"select\":\n                # Selenium's Select does not support non-select tags\n                return self.select2(element, select2drop, text)\n            selection = Select(element)\n        else:\n            selection = coordinate\n            # TODO: Can't understand why Select made it private, replace Select in the future(?)\n            element = coordinate._el\n        if isinstance(text, int):\n            if select2drop is not None:\n                return self.select2(element, select2drop, text)\n            return selection.select_by_index(text)\n        try:\n            selection.select_by_visible_text(text)\n            return True\n        except NoSuchElementException:\n            available_selections = []\n            for option in selection.options:\n                if text in option.text:\n                    selection.select_by_visible_text(option.text)\n                    return True\n                available_selections.append(option.text)\n            print(\"[Error!] Selection not found: {}\".format(text))\n            print(\"Available Selections\\n {}\".format(available_selections))\n        except ValueError:\n            if select2drop is None:\n                print(\"[Hint] You might be dealing with a select2 element. Try specifying select2drop locator.\")\n                raise\n            # We are assuming we encountered a select2 selection box\n            self.select2(element, select2drop, text)", "response": "Select text from an element or select2 element"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select2(self, box, drop, text):\n        '''\n        :param box: the locator for Selection Box\n        :param drop: the locator for Selection Dropdown\n        :param text: the text value to select or the index of the option to select\n        :return: True\n        :example: https://github.com/ldiary/marigoso/blob/master/notebooks/handling_select2_controls_in_selenium_webdriver.ipynb\n        '''\n        if not self.is_available(drop):\n            if isinstance(box, str):\n                self.get_element(box).click()\n            else:\n                box.click()\n        ul_dropdown = self.get_element(drop)\n        options = ul_dropdown.get_children('tag=li')\n        if isinstance(text, int):\n            options[text].click()\n            return True\n\n        for option in options:\n            if option.text == text:\n                option.click()\n                return True\n        print(\"[Error!] Selection not found: {}\".format(text))\n        print(\"Available Selections\\n {}\".format([option.text for option in options]))", "response": "Select 2 - Select the option from the selected element"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef submit_btn(self, value, success=None):\n        self.press(\"css=input[value='{}']\".format(value))\n        if success is not None:\n            assert self.is_available(*success)", "response": "This presses an input button with type = submit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_request_access_signature(parameters, secret_key):\n    # pull out the parameter keys\n    keys = parameters.keys()\n\n    # alphanumerically sort the keys in place\n    keys.sort()\n\n    # create an array of url encoded key:value pairs\n    encoded_pairs = [urlencode({key: parameters[key]}) for key in keys]\n\n    # create the serialized parameters in a single, URL style string\n    serialized_parameters = '&'.join(encoded_pairs)\n\n    # create the string with the secret key and the parameters which will be hashed\n    string_to_hash = '%s:%s' % (secret_key, serialized_parameters)\n\n    # return the hex digest of the hashed string\n    return sha256(string_to_hash).hexdigest()", "response": "Generate the parameter signature used during third party access requests\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the auth token string if the user credentials are already stored", "response": "def has_credentials_stored():\n    \"\"\"\n    Return 'auth token' string, if the user credentials are already stored\n    \"\"\"\n\n    try:\n        with open(credentials_file, 'r') as f:\n            token = f.readline().strip()\n            id = f.readline().strip()\n\n            return token\n    except Exception, e:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authenticate():\n\n    print LOGIN_INIT_MESSAGE\n\n    username = raw_input('{0}: '.format(LOGIN_USER_MESSAGE))\n    password = None\n\n    while password is None:\n        password = getpass('Password for {0}: '.format(username))\n\n    gh = login(username, password=password)\n    try:\n        gh.user()\n        instance = authorize(username, password, APP_SCOPE, APP_DESC, APP_URL)\n    except Exception, e:\n        raise e\n\n    with open(credentials_file, 'w') as f:\n        f.write(instance.token)\n\n    return instance.token", "response": "Authenticate the user and store the token for further use\n    Return the authentication token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of visually separable colors according to total communities", "response": "def community_colors(n):\n\t\"\"\"\n\tReturns a list of visually separable colors according to total communities\n\t\"\"\"\n\n\tif (n > 0):\n\t\tcolors = cl.scales['12']['qual']['Paired']\n\t\tshuffle(colors)\n\n\t\treturn colors[:n]\n\telse:\n\t\treturn choice(cl.scales['12']['qual']['Paired'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs-in as the bot account octogrid", "response": "def login_as_bot():\n\t\"\"\"\n\tLogin as the bot account \"octogrid\", if user isn't authenticated on Plotly\n\t\"\"\"\n\n\tplotly_credentials_file = join(\n    \tjoin(expanduser('~'), PLOTLY_DIRECTORY), PLOTLY_CREDENTIALS_FILENAME)\n\n\tif isfile(plotly_credentials_file):\n\t\twith open(plotly_credentials_file, 'r') as f:\n\t\t\tcredentials = loads(f.read())\n\n\t\tif (credentials['username'] == '' or credentials['api_key'] == ''):\n\t\t\tplotly.sign_in(BOT_USERNAME, BOT_API_KEY)\n\telse:\n\t\tplotly.sign_in(BOT_USERNAME, BOT_API_KEY)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsubmit a command as a slurm job of blocksize parallel elements.", "response": "def submit(self, command, blocksize, job_name=\"parsl.auto\"):\n        \"\"\"Submit the command as a slurm job of blocksize parallel elements.\n\n        Parameters\n        ----------\n        command : str\n            Command to be made on the remote side.\n        blocksize : int\n            Not implemented.\n        job_name : str\n            Name for the job (must be unique).\n\n        Returns\n        -------\n        None or str\n            If at capacity, returns None; otherwise, a string identifier for the job\n        \"\"\"\n\n        if self.provisioned_blocks >= self.max_blocks:\n            logger.warn(\"Slurm provider '{}' is at capacity (no more blocks will be added)\".format(self.label))\n            return None\n\n        job_name = \"{0}.{1}\".format(job_name, time.time())\n\n        script_path = \"{0}/{1}.submit\".format(self.script_dir, job_name)\n        script_path = os.path.abspath(script_path)\n\n        logger.debug(\"Requesting one block with {} nodes\".format(self.nodes_per_block))\n\n        job_config = {}\n        job_config[\"submit_script_dir\"] = self.channel.script_dir\n        job_config[\"nodes\"] = self.nodes_per_block\n        job_config[\"tasks_per_node\"] = self.tasks_per_node\n        job_config[\"walltime\"] = wtime_to_minutes(self.walltime)\n        job_config[\"overrides\"] = self.overrides\n        job_config[\"partition\"] = self.partition\n        job_config[\"user_script\"] = command\n\n        # Wrap the command\n        job_config[\"user_script\"] = self.launcher(command,\n                                                  self.tasks_per_node,\n                                                  self.nodes_per_block)\n\n        logger.debug(\"Writing submit script\")\n        self._write_submit_script(template_string, script_path, job_name, job_config)\n\n        channel_script_path = self.channel.push_file(script_path, self.channel.script_dir)\n\n        retcode, stdout, stderr = super().execute_wait(\"sbatch {0}\".format(channel_script_path))\n\n        job_id = None\n        if retcode == 0:\n            for line in stdout.split('\\n'):\n                if line.startswith(\"Submitted batch job\"):\n                    job_id = line.split(\"Submitted batch job\")[1].strip()\n                    self.resources[job_id] = {'job_id': job_id, 'status': 'PENDING', 'blocksize': blocksize}\n        else:\n            print(\"Submission of command to scale_out failed\")\n            logger.error(\"Retcode:%s STDOUT:%s STDERR:%s\", retcode, stdout.strip(), stderr.strip())\n        return job_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_xml_element(self):\n\n        if not hasattr(self, 'xml_element'):\n            self.xml_element = etree.Element(self.name, nsmap=NSMAP)\n\n        if hasattr(self, 'lang'):\n            self.xml_element.set(\n                '{http://www.w3.org/XML/1998/namespace}lang', self.lang)\n        if hasattr(self, 'override'):\n            self.xml_element.set('override', str(self.override))\n        if hasattr(self, 'text'):\n            self.xml_element.text = self.text\n\n        return self.xml_element", "response": "Updates the xml element contents to match the instance contents."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upload_to(instance, filename, prefix=None):\n    ext = path.splitext(filename)[1]\n    name = str(instance.pk or time()) + filename\n\n    # We think that we use utf8 based OS file system\n    filename = md5(name.encode('utf8')).hexdigest() + ext\n    basedir = path.join(instance._meta.app_label, instance._meta.module_name)\n    if prefix:\n        basedir = path.join(basedir, prefix)\n    return path.join(basedir, filename[:2], filename[2:4], filename)", "response": "Auto upload function for File and Image fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reverse_toctree(app, doctree, docname):\n    if docname == \"changes\":\n        for node in doctree.traverse():\n            if node.tagname == \"toctree\" and node.get(\"glob\"):\n                node[\"entries\"].reverse()\n                break", "response": "Reverse the order of entries in the root toctree if glob is used."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes object with schema.", "response": "def dump(self, obj):\n        \"\"\"Serialize object with schema.\n\n        :param obj: The object to serialize.\n        :returns: The object serialized.\n        \"\"\"\n        if self.schema_class:\n            obj = self.schema_class().dump(obj).data\n        else:\n            obj = obj['metadata']\n        return super(MARCXMLSerializer, self).dump(obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serialize(self, pid, record, links_factory=None):\n        return dumps(self.transform_record(pid, record, links_factory),\n                     **self.dumps_kwargs)", "response": "Serialize a single record and persistent identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize_search(self, pid_fetcher, search_result,\n                         item_links_factory=None, **kwargs):\n        \"\"\"Serialize a search result.\n\n        :param pid_fetcher: Persistent identifier fetcher.\n        :param search_result: Elasticsearch search result.\n        :param item_links_factory: Factory function for the items in result.\n            (Default: ``None``)\n        :returns: The objects serialized.\n        \"\"\"\n        ret = [self.transform_search_hit(pid_fetcher(hit['_id'],\n                                         hit['_source']),\n                                         hit,\n                                         links_factory=item_links_factory)\n               for hit in search_result['hits']['hits']]\n\n        return dumps(ret, **self.dumps_kwargs)", "response": "Serialize a search result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serialize_oaipmh(self, pid, record):\n        obj = self.transform_record(pid, record['_source']) \\\n            if isinstance(record['_source'], Record) \\\n            else self.transform_search_hit(pid, record)\n\n        return dumps_etree(obj, **self.dumps_kwargs)", "response": "Serialize a single record for OAI - PMH."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef treat(request_body):\n    # Python 3+ support\n    if isinstance(request_body, six.binary_type):\n        request_body = request_body.decode('utf-8')\n\n    try:\n        data = json.loads(request_body)\n    except ValueError:\n        raise exceptions.UnknownAPIResource('Request body is malformed JSON.')\n\n    unsafe_api_resource = APIResource.factory(data)\n\n    try:\n        consistent_api_resource = unsafe_api_resource.get_consistent_resource()\n    except AttributeError:\n        raise exceptions.UnknownAPIResource('The API resource provided is invalid.')\n\n    return consistent_api_resource", "response": "Takes a request body and returns a safe APIResource object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a command on the shell and returns the process ID and the process object.", "response": "def execute_no_wait(self, cmd, walltime, envs={}):\n        ''' Synchronously execute a commandline string on the shell.\n\n        Args:\n            - cmd (string) : Commandline string to execute\n            - walltime (int) : walltime in seconds, this is not really used now.\n\n        Returns:\n\n           - retcode : Return code from the execution, -1 on fail\n           - stdout  : stdout string\n           - stderr  : stderr string\n\n        Raises:\n         None.\n        '''\n        current_env = copy.deepcopy(self._envs)\n        current_env.update(envs)\n\n        try:\n            proc = subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                cwd=self.userhome,\n                env=current_env,\n                shell=True,\n                preexec_fn=os.setpgrp\n            )\n            pid = proc.pid\n\n        except Exception as e:\n            print(\"Caught exception : {0}\".format(e))\n            logger.warn(\"Execution of command [%s] failed due to \\n %s \", (cmd, e))\n\n        return pid, proc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ticker(self, pair, ignore_invalid=0):\n        return self._public_api_call('ticker', pair=pair, ignore_invalid=ignore_invalid)", "response": "This method provides all the information about currently active pairs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef depth(self, pair, limit=150, ignore_invalid=0):\n        return self._public_api_call('depth', pair=pair, limit=limit, ignore_invalid=ignore_invalid)", "response": "This method provides the information about the active orders on the pair."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef trades(self, pair, limit=150, ignore_invalid=0):\n        return self._public_api_call('trades', pair=pair, limit=limit, ignore_invalid=ignore_invalid)", "response": "This method provides the information about the last trades in a given pair."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trade(self, pair, type_, rate, amount):\n        return self._trade_api_call('Trade', pair=pair, type_=type_, rate=rate, amount=amount)", "response": "This method is used to create trade orders and trades on the exchange"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning trade history. To use this method you need a privilege of the info key. :param int or None from_: trade ID, from which the display starts (default 0) :param int or None count: the number of trades for display (default 1000) :param int or None from_id: trade ID, from which the display starts (default 0) :param int or None end_id: trade ID on which the display ends (default inf.) :param str or None order: sorting (default 'DESC') :param int or None since: the time to start the display (default 0) :param int or None end: the time to end the display (default inf.) :param str or None pair: pair to be displayed (ex. 'btc_usd')", "response": "def trade_history(\n        self, from_=None, count=None, from_id=None, end_id=None,\n        order=None, since=None, end=None, pair=None\n    ):\n        \"\"\"\n        Returns trade history.\n        To use this method you need a privilege of the info key.\n\n        :param int or None from_: trade ID, from which the display starts (default 0)\n        :param int or None count: the number of trades for display\t(default 1000)\n        :param int or None from_id: trade ID, from which the display starts\t(default 0)\n        :param int or None end_id: trade ID on which the display ends (default inf.)\n        :param str or None order: sorting (default 'DESC')\n        :param int or None since: the time to start the display (default 0)\n        :param int or None end: the time to end the display\t(default inf.)\n        :param str or None pair: pair to be displayed (ex. 'btc_usd')\n        \"\"\"\n        return self._trade_api_call(\n            'TradeHistory', from_=from_, count=count, from_id=from_id, end_id=end_id,\n            order=order, since=since, end=end, pair=pair\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trans_history(\n        self, from_=None, count=None, from_id=None, end_id=None,\n        order=None, since=None, end=None\n    ):\n        \"\"\"\n        Returns the history of transactions.\n        To use this method you need a privilege of the info key.\n\n        :param int or None from_: transaction ID, from which the display starts (default 0)\n        :param int or None count: number of transaction to be displayed\t(default 1000)\n        :param int or None from_id: transaction ID, from which the display starts (default 0)\n        :param int or None end_id: transaction ID on which the display ends\t(default inf.)\n        :param str or None order: sorting (default 'DESC')\n        :param int or None since: the time to start the display (default 0)\n        :param int or None end: the time to end the display\t(default inf.)\n        \"\"\"\n        return self._trade_api_call(\n            'TransHistory', from_=from_, count=count, from_id=from_id, end_id=end_id,\n            order=order, since=since, end=end\n        )", "response": "This method returns the history of the transactions in the info key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef withdraw_coin(self, coin_name, amount, address):\n        return self._trade_api_call('WithdrawCoin', coinName=coin_name, amount=amount, address=address)", "response": "This method is designed for cryptocurrency withdrawals. It is designed for cryptocurrency withdrawals."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_coupon(self, currency, amount, receiver):\n        return self._trade_api_call('CreateCoupon', currency=currency, amount=amount, receiver=receiver)", "response": "This method creates a new coupon for the given currency and amount."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlaunching a new game and return the result of the agent.", "response": "def playerJoin(config, agentCallBack, lobbyTimeout=c.INITIAL_TIMEOUT, debug=True):\n    \"\"\"cause an agent to join an already hosted game\"\"\"\n    FLAGS(sys.argv) # ignore pysc2 command-line handling (eww)\n    log = protocol.logging.logging\n    log.disable(log.CRITICAL) # disable pysc2 logging\n    amHosting   = not bool(config.host)\n    thisPlayer  = config.whoAmI()\n    operPrefix  = \"HOST\" if amHosting else \"JOIN\"\n    operType    = \"%sGAME\"%operPrefix\n    createReq   = config.requestCreateDetails() if amHosting else None\n    joinReq     = config.requestJoinDetails()\n    selectedIP  = config.clientInitHost()\n    selectPort  = config.clientInitPort()\n    controller  = None # the object that manages the application process\n    finalResult = rh.playerSurrendered(config) # default to this player losing if somehow a result wasn't acquired normally\n    replayData  = \"\" # complete raw replay data for the match\n    if debug: print(\"[%s] Starcraft2 game process is launching (fullscreen=%s).\"%(operType, config.fullscreen))\n    with config.launchApp(ip_address=selectedIP, port=selectPort, connect=False):\n      try: # WARNING: if port equals the same port of the host on the same machine, this subsequent process closes!\n        controller = ClientController()\n        controller.connect(url=selectedIP, port=selectPort, timeout=lobbyTimeout) # establish socket connection\n        if amHosting:\n            if debug:\n                  print(\"[%s] Starcraft2 host application is live. (%s)\"%(operType, controller.status)) # status: launched\n                  print(\"[%s] Creating Starcraft Game at %s\"%(operType, controller))\n            controller.create_game(createReq)\n            if debug:\n                  print(\"[%s] Starcraft2 is waiting for %d player(s) to join. (%s)\"%(operType, config.numAgents, controller.status)) # status: init_game\n                  print(\"[%s] sending request to join game. (%s)\"%(operType, controller.status)) # status: init_game\n        else: # joining clients must wait for host to perfrom its join request\n            timeToWait = c.DEFAULT_HOST_DELAY\n            for i in range(timeToWait): # WARNING: the host must perform its join action with its client before any joining players issue join requests to their clients\n                if debug: print(\"[%s] waiting %d seconds for the host to finish its init sequence.\"%(operType, timeToWait-i))\n                time.sleep(1)\n        joinResp = controller.join_game(joinReq) # SC2APIProtocol.RequestJoinGame\n        print(\"[%s] connection to %s:%d was successful. Game is starting! (%s)\"%(operType, selectedIP, selectPort, controller.status)) # status: in_game\n        thisPlayer.playerID = int(joinResp.player_id) # update playerID; repsponse to join game request is authority\n        if debug: print(\"[%s] joined match as %s.\"%(operType, thisPlayer)) # all players have actually joined already to advance beyond join_game (init_game)\n        config.updateIDs(controller.game_info(), tag=operType, debug=debug) # SC2APIProtocol.ResponseGameInfo object\n        if debug: print(\"[%s] all %d player(s) found; game has started! (%s)\"%(operType, config.numGameClients, controller.status)) # status: init_game\n        config.save() # \"publish\" the configuration file for other procs\n        try:    agentCallBack(config.name) # send the configuration to the controlling agent\n        except Exception as e:\n            print(\"ERROR: agent %s crashed during init: %s (%s)\"%(thisPlayer.initCmd, e, type(e)))\n            return (rh.playerCrashed(config), \"\") # no replay information to get\n        getGameState = controller.observe # function that observes what's changed since the prior gameloop(s)\n        startWaitTime = now()\n        while True:  # wait for game to end while players/bots do their thing\n            obs = getGameState()\n            result = obs.player_result\n            if result: # match end condition was supplied by the client\n                finalResult = rh.idPlayerResults(config, result)\n                break\n            try: agentCallBack(obs) # do developer's creative stuff\n            except Exception as e:\n                print(\"%s ERROR: agent callback %s of %s crashed during game: %s\"%(type(e), agentCallBack, thisPlayer.initCmd, e))\n                finalResult = rh.playerCrashed(config)\n                break\n            newNow = now() # periodicially acquire the game's replay data (in case of abnormal termination)\n            if newNow - startWaitTime > c.REPLAY_SAVE_FREQUENCY:\n                replayData = controller.save_replay()\n                startWaitTime = newNow\n        replayData = controller.save_replay() # one final attempt to get the complete replay data\n        #controller.leave() # the connection to the server process is (cleanly) severed\n      except (protocol.ConnectionError, protocol.ProtocolError, remote_controller.RequestError) as e:\n        if \"Status.in_game\" in str(e): # state was previously in game and then exited that state\n            finalResult = rh.playerSurrendered(config) # rage quit is losing\n        else:\n            finalResult = rh.playerDisconnected(config)\n            print(\"%s Connection to game host has ended, even intentionally by agent. Message:%s%s\"%(type(e), os.linesep, e))\n      except KeyboardInterrupt:\n        if debug: print(\"caught command to forcibly shutdown Starcraft2 client.\")\n        finalResult = rh.playerSurrendered(config)\n      finally:\n        if replayData: # ensure replay data can be transmitted over http\n            replayData = base64.encodestring(replayData).decode() # convert raw bytes into str\n        if controller: controller.quit() # force the sc2 application to close\n    return (finalResult, replayData)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_python_version_string():\n    version_info = sys.version_info\n    return '.'.join(map(str, [version_info[0], version_info[1], version_info[2]]))", "response": "Returns a string representation of the Python version."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _raise_unrecoverable_error_payplug(self, exception):\n        message = ('There was an unrecoverable error during the HTTP request. It seems to come from our servers. '\n                   'If you are behind a proxy, ensure that it is configured correctly. If the issue persists, do not '\n                   'hesitate to contact us with the following information: `' + repr(exception) + '`.')\n        raise exceptions.ClientError(message, client_exception=exception)", "response": "Raises an exception if the error was not received from PayPlug."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nraise an exception if the client has unrecoverable error.", "response": "def _raise_unrecoverable_error_client(self, exception):\n        \"\"\"\n        Raises an exceptions.ClientError with a message telling that the error probably comes from the client\n        configuration.\n        :param exception: Exception that caused the ClientError\n        :type exception: Exception\n        :raise exceptions.ClientError\n        \"\"\"\n        message = ('There was an unrecoverable error during the HTTP request which is probably related to your '\n                   'configuration. Please verify `' + self.DEPENDENCY + '` library configuration and update it. If the '\n                   'issue persists, do not hesitate to contact us with the following information: `' + repr(exception) +\n                   '`.')\n        raise exceptions.ClientError(message, client_exception=exception)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo a request to the API.", "response": "def do_request(self, http_verb, url, headers, data=None):\n        \"\"\"\n        :see :func:`~HttpRequest.do_request`\n        \"\"\"\n        if data:\n            data = json.dumps(data)\n        try:\n            response = requests.request(http_verb, url, headers=headers, data=data, verify=config.CACERT_PATH)\n        except (requests.exceptions.Timeout, requests.exceptions.TooManyRedirects) as exception:\n            self._raise_unrecoverable_error_payplug(exception)\n        except requests.exceptions.RequestException as exception:\n            self._raise_unrecoverable_error_client(exception)\n\n        return response.content, response.status_code, response.headers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_request(self, http_verb, url, headers, data=None):\n        if data:\n            data = json.dumps(data)\n        request = urllib.request.Request(url, data, headers)\n        request.get_method = lambda: http_verb\n\n        try:\n            response = urllib.request.urlopen(request)\n        except urllib.error.HTTPError as response_:\n            response = response_\n        except urllib.error.URLError as exception:\n            if isinstance(exception.reason, socket.timeout):  # Python 2.6\n                self._raise_unrecoverable_error_payplug(exception)\n            else:\n                self._raise_unrecoverable_error_client(exception)\n        except socket.timeout as exception:  # Python 2.7+\n            self._raise_unrecoverable_error_payplug(exception)\n        except http_client.HTTPException as exception:\n            self._raise_unrecoverable_error_client(exception)\n\n        return response.read(), response.code, dict(response.info())", "response": "Do a request to the specified url and return the response code and info."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a HTTP request.", "response": "def _request(self, http_verb, url, data=None, authenticated=True):\n        \"\"\"\n        Perform an HTTP request.\n\n        See https://docs.python.org/3/library/json.html#json-to-py-table for the http response object.\n\n        :param http_verb: the HTTP verb (GET, POST, PUT, \u2026)\n        :type http_verb: string\n        :param url: the path to the resource queried\n        :type url: string\n        :param data: the request content\n        :type data: dict\n        :param authenticated: the request should be authenticated\n        :type authenticated: bool\n\n        :return: http response, http status\n        :rtype tuple(object, int)\n        \"\"\"\n        user_agent = ('PayPlug-Python/{lib_version} (Python/{python_version}; '\n                      '{request_library})'\n                      .format(lib_version=__version__,\n                              python_version=_get_python_version_string(),\n                              request_library=self._request_handler.get_useragent_string()))\n        headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': user_agent,\n        }\n        if authenticated:\n            headers['Authorization'] = 'Bearer ' + self._secret_key\n\n        requestor = self._request_handler()\n        response, status, _ = requestor.do_request(http_verb, url, headers, data)\n\n        # Since Python 3.2+, response body is a bytes-like object. We have to decode it to a string.\n        if isinstance(response, six.binary_type):\n            response = response.decode('utf-8')\n\n        if not 200 <= status < 300:\n            raise exceptions.HttpError.map_http_status_to_exception(status)(http_response=response,\n                                                                            http_status=status)\n\n        try:\n            response_object = json.loads(response)\n        except ValueError:\n            raise exceptions.UnexpectedAPIResponseException(http_response=response, http_status=status)\n\n        return response_object, status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncoercing a string or Author object to an Author object.", "response": "def coerce_author(value):\n    \"\"\"\n    Coerce strings to :class:`Author` objects.\n\n    :param value: A string or :class:`Author` object.\n    :returns: An :class:`Author` object.\n    :raises: :exc:`~exceptions.ValueError` when `value`\n             isn't a string or :class:`Author` object.\n    \"\"\"\n    # Author objects pass through untouched.\n    if isinstance(value, Author):\n        return value\n    # In all other cases we expect a string.\n    if not isinstance(value, string_types):\n        msg = \"Expected Author object or string as argument, got %s instead!\"\n        raise ValueError(msg % type(value))\n    # Try to parse the `name <email>' format.\n    match = re.match('^(.+?) <(.+?)>$', value)\n    if not match:\n        msg = \"Provided author information isn't in 'name <email>' format! (%r)\"\n        raise ValueError(msg % value)\n    return Author(\n        name=match.group(1).strip(),\n        email=match.group(2).strip(),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef coerce_feature_branch(value):\n    # Repository objects pass through untouched.\n    if isinstance(value, FeatureBranchSpec):\n        return value\n    # We expect a string with a name or URL.\n    if not isinstance(value, string_types):\n        msg = \"Expected string or FeatureBranchSpec object as argument, got %s instead!\"\n        raise ValueError(msg % type(value))\n    return FeatureBranchSpec(expression=value)", "response": "Coerce a string or FeatureBranchSpec object to a FeatureBranchSpec object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncoerces a string to a repository object.", "response": "def coerce_repository(value, context=None):\n    \"\"\"\n    Convert a string (taken to be a repository name or location) to a :class:`Repository` object.\n\n    :param value: The name or location of a repository (a string) or a\n                  :class:`Repository` object.\n    :param context: An execution context created by :mod:`executor.contexts`\n                    (defaults to :class:`executor.contexts.LocalContext`).\n    :returns: A :class:`Repository` object.\n    :raises: :exc:`~exceptions.ValueError` when the given value is not a string\n             or a :class:`Repository` object or if the value is a string but\n             doesn't match the name of any configured repository and also can't\n             be parsed as the location of a repository.\n\n    The :func:`coerce_repository()` function creates :class:`Repository` objects:\n\n    1. If the value is already a :class:`Repository` object it is returned to\n       the caller untouched.\n    2. If the value is accepted by :func:`find_configured_repository()` then\n       the resulting :class:`Repository` object is returned.\n    3. If the value is a string that starts with a known VCS type prefix (e.g.\n       ``hg+https://bitbucket.org/ianb/virtualenv``) the prefix is removed from\n       the string and a :class:`Repository` object is returned:\n\n       - If the resulting string points to an existing local directory it will\n         be used to set :attr:`~Repository.local`.\n       - Otherwise the resulting string is used to set\n         :attr:`~Repository.remote`.\n    4. If the value is a string pointing to an existing local directory, the\n       VCS type is inferred from the directory's contents and a\n       :class:`Repository` object is returned whose :attr:`~Repository.local`\n       property is set to the local directory.\n    5. If the value is a string that ends with ``.git`` (a common idiom for git\n       repositories) a :class:`Repository` object is returned:\n\n       - If the value points to an existing local directory it will be used to\n         set :attr:`~Repository.local`.\n       - Otherwise the value is used to set :attr:`~Repository.remote`.\n    \"\"\"\n    # Coerce the context argument.\n    context = context or LocalContext()\n    # Repository objects pass through untouched.\n    if isinstance(value, Repository):\n        return value\n    # We expect a string with a name or URL.\n    if not isinstance(value, string_types):\n        msg = \"Expected string or Repository object as argument, got %s instead!\"\n        raise ValueError(msg % type(value))\n    # If the string matches the name of a configured repository we'll return that.\n    try:\n        return find_configured_repository(value)\n    except NoSuchRepositoryError:\n        pass\n    # Parse and try to resolve the VCS type prefix.\n    vcs_type, _, location = value.partition('+')\n    if vcs_type and location:\n        kw = {\n            'context': context,\n            'local' if context.exists(location) else 'remote': location,\n        }\n        try:\n            return repository_factory(vcs_type, **kw)\n        except UnknownRepositoryTypeError:\n            pass\n    # Try to infer the type of an existing local repository.\n    for cls in load_backends():\n        if cls.contains_repository(context, value):\n            return repository_factory(cls, context=context, local=value)\n    # Check for locations that end with `.git' (a common idiom for remote\n    # git repositories) even if the location isn't prefixed with `git+'.\n    if value.endswith('.git'):\n        from vcs_repo_mgr.backends.git import GitRepo\n        return repository_factory(GitRepo, **{\n            'context': context,\n            'local' if context.exists(value) else 'remote': value,\n        })\n    # If all else fails, at least give a clear explanation of the problem.\n    msg = (\"The string %r doesn't match the name of any configured repository\"\n           \" and it also can't be parsed as the location of a remote\"\n           \" repository! (maybe you forgot to prefix the type?)\")\n    raise ValueError(msg % value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the directory where temporary local checkouts are to be stored.", "response": "def find_cache_directory(remote):\n    \"\"\"\n    Find the directory where temporary local checkouts are to be stored.\n\n    :returns: The absolute pathname of a directory (a string).\n    \"\"\"\n    return os.path.join('/var/cache/vcs-repo-mgr' if os.access('/var/cache', os.W_OK) else tempfile.gettempdir(),\n                        urlparse.quote(remote, safe=''))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_configured_repository(name):\n    parser = configparser.RawConfigParser()\n    for config_file in [SYSTEM_CONFIG_FILE, USER_CONFIG_FILE]:\n        config_file = parse_path(config_file)\n        if os.path.isfile(config_file):\n            logger.debug(\"Loading configuration file (%s) ..\", format_path(config_file))\n            parser.read(config_file)\n    matching_repos = [r for r in parser.sections() if normalize_name(name) == normalize_name(r)]\n    if not matching_repos:\n        msg = \"No repositories found matching the name '%s'!\"\n        raise NoSuchRepositoryError(msg % name)\n    elif len(matching_repos) != 1:\n        msg = \"Multiple repositories found matching the name '%s'! (matches: %s)\"\n        raise AmbiguousRepositoryNameError(msg % (name, concatenate(map(repr, matching_repos))))\n    else:\n        kw = {}\n        # Get the repository specific options.\n        options = dict(parser.items(matching_repos[0]))\n        vcs_type = options.get('type', '').lower()\n        # Process the `local' directory pathname.\n        local_path = options.get('local')\n        if local_path:\n            # Expand a leading tilde and/or environment variables.\n            kw['local'] = parse_path(local_path)\n        # Process the `bare' option.\n        bare = options.get('bare', None)\n        if bare is not None:\n            # Default to bare=None but enable configuration\n            # file(s) to enforce bare=True or bare=False.\n            kw['bare'] = coerce_boolean(bare)\n        # Process the `remote', `release_scheme' and `release_filter' options.\n        for name in 'remote', 'release-scheme', 'release-filter':\n            value = options.get(name)\n            if value is not None:\n                kw[name.replace('-', '_')] = value\n        return repository_factory(vcs_type, **kw)", "response": "Find a version control repository defined by the user in a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef repository_factory(vcs_type, **kw):\n    # Resolve VCS aliases to Repository subclasses.\n    if isinstance(vcs_type, string_types):\n        vcs_type = vcs_type.lower()\n        for cls in load_backends():\n            if vcs_type in cls.ALIASES:\n                vcs_type = cls\n                break\n    # Make sure we have a valid repository type to work with.\n    if not (isinstance(vcs_type, type) and issubclass(vcs_type, Repository)):\n        raise UnknownRepositoryTypeError(\"Unknown VCS repository type! (%r)\" % vcs_type)\n    # Generate a cache key that we will use to avoid constructing duplicates.\n    cache_key = tuple('%s=%s' % (k, v) for k, v in sorted(kw.items()))\n    logger.debug(\"Generated repository cache key: %r\", cache_key)\n    if cache_key in loaded_repositories:\n        logger.debug(\"Repository previously constructed, returning cached instance ..\")\n    else:\n        logger.debug(\"Repository not yet constructed, creating new instance ..\")\n        loaded_repositories[cache_key] = vcs_type(**kw)\n    return loaded_repositories[cache_key]", "response": "Returns a new instance of the given type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsum revision numbers of multiple repository names and revision pairs.", "response": "def sum_revision_numbers(arguments):\n    \"\"\"\n    Sum revision numbers of multiple repository/revision pairs.\n\n    :param arguments: A list of strings with repository names and revision\n                      strings.\n    :returns: A single integer containing the summed revision numbers.\n\n    This is useful when you're building a package based on revisions from\n    multiple VCS repositories. By taking changes in all repositories into\n    account when generating version numbers you can make sure that your version\n    number is bumped with every single change.\n    \"\"\"\n    arguments = list(arguments)\n    if len(arguments) % 2 != 0:\n        raise ValueError(\"Please provide an even number of arguments! (one or more repository/revision pairs)\")\n    summed_revision_number = 0\n    while arguments:\n        repository = coerce_repository(arguments.pop(0))\n        summed_revision_number += repository.find_revision_number(arguments.pop(0))\n    return summed_revision_number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef revision(self):\n        location, _, revision = self.expression.partition('#')\n        return revision if location and revision else self.expression", "response": "The revision of the feature branch."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks whether the given directory contains a local repository.", "response": "def contains_repository(cls, context, directory):\n        \"\"\"\n        Check whether the given directory contains a local repository.\n\n        :param directory: The pathname of a directory (a string).\n        :returns: :data:`True` if the directory contains a local repository,\n                  :data:`False` otherwise.\n\n        By default :func:`contains_repository()` just checks whether the\n        directory reported by :func:`get_vcs_directory()` exists, but\n        :class:`Repository` subclasses can override this class method to\n        improve detection accuracy.\n        \"\"\"\n        return context.is_directory(cls.get_vcs_directory(context, directory))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary that maps branch names to revisions.", "response": "def branches(self):\n        \"\"\"\n        A dictionary that maps branch names to :class:`Revision` objects.\n\n        Here's an example based on a mirror of the git project's repository:\n\n        >>> from pprint import pprint\n        >>> from vcs_repo_mgr.backends.git import GitRepo\n        >>> repository = GitRepo(remote='https://github.com/git/git.git')\n        >>> pprint(repository.branches)\n        {'maint':  Revision(repository=GitRepo(...), branch='maint',  revision_id='16018ae'),\n         'master': Revision(repository=GitRepo(...), branch='master', revision_id='8440f74'),\n         'next':   Revision(repository=GitRepo(...), branch='next',   revision_id='38e7071'),\n         'pu':     Revision(repository=GitRepo(...), branch='pu',     revision_id='d61c1fa'),\n         'todo':   Revision(repository=GitRepo(...), branch='todo',   revision_id='dea8a2d')}\n        \"\"\"\n        # Make sure the local repository exists.\n        self.create()\n        # Create a mapping of branch names to revisions.\n        return dict((r.branch, r) for r in self.find_branches())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef last_updated(self):\n        try:\n            if self.context.exists(self.last_updated_file):\n                return int(self.context.read_file(self.last_updated_file))\n        except Exception:\n            pass\n        return 0", "response": "Returns the date and time when the last update was made."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef release_branches(self):\n        self.ensure_release_scheme('branches')\n        return dict((r.revision.branch, r) for r in self.releases.values())", "response": "A dictionary that maps branch names to Release objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef release_filter(self, value):\n        compiled_pattern = coerce_pattern(value)\n        if compiled_pattern.groups > 1:\n            raise ValueError(compact(\"\"\"\n                Release filter regular expression pattern is expected to have\n                zero or one capture group, but it has {count} instead!\n            \"\"\", count=compiled_pattern.groups))\n        set_property(self, 'release_filter', value)\n        set_property(self, 'compiled_filter', compiled_pattern)", "response": "Validate the release filter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the release scheme.", "response": "def release_scheme(self, value):\n        \"\"\"Validate the release scheme.\"\"\"\n        if value not in KNOWN_RELEASE_SCHEMES:\n            msg = \"Release scheme %r is not supported! (valid options are %s)\"\n            raise ValueError(msg % (value, concatenate(map(repr, KNOWN_RELEASE_SCHEMES))))\n        set_property(self, 'release_scheme', value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef releases(self):\n        available_releases = {}\n        available_revisions = getattr(self, self.release_scheme)\n        for identifier, revision in available_revisions.items():\n            match = self.compiled_filter.match(identifier)\n            if match:\n                # If the regular expression contains a capturing group we\n                # set the release identifier to the captured substring\n                # instead of the complete tag/branch identifier.\n                captures = match.groups()\n                if captures:\n                    identifier = captures[0]\n                available_releases[identifier] = Release(\n                    revision=revision,\n                    identifier=identifier,\n                )\n        return available_releases", "response": "r A dictionary that maps release identifiers to a list of Release objects. Each entry in the dictionary maps the revision number to the corresponding release."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tags(self):\n        # Make sure the local repository exists.\n        self.create()\n        # Create a mapping of tag names to revisions.\n        return dict((r.tag, r) for r in self.find_tags())", "response": "Returns a dictionary that maps tag names to revision objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the given files to the current working tree.", "response": "def add_files(self, *filenames, **kw):\n        \"\"\"\n        Include added and/or removed files in the working tree in the next commit.\n\n        :param filenames: The filenames of the files to include in the next\n                          commit (zero or more strings). If no arguments are\n                          given all untracked files are added.\n        :param kw: Keyword arguments are ignored (instead of raising\n                   :exc:`~exceptions.TypeError`) to enable backwards\n                   compatibility with older versions of `vcs-repo-mgr`\n                   where the keyword argument `all` was used.\n        \"\"\"\n        # Make sure the local repository exists and supports a working tree.\n        self.create()\n        self.ensure_working_tree()\n        # Include added and/or removed files in the next commit.\n        logger.info(\"Staging changes to be committed in %s ..\", format_path(self.local))\n        self.context.execute(*self.get_add_files_command(*filenames))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the working tree of the local repository to the specified revision.", "response": "def checkout(self, revision=None, clean=False):\n        \"\"\"\n        Update the working tree of the local repository to the specified revision.\n\n        :param revision: The revision to check out (a string,\n                         defaults to :attr:`default_revision`).\n        :param clean: :data:`True` to discard changes in the working tree,\n                      :data:`False` otherwise.\n        \"\"\"\n        # Make sure the local repository exists and supports a working tree.\n        self.create()\n        self.ensure_working_tree()\n        # Update the working tree of the local repository.\n        revision = revision or self.default_revision\n        logger.info(\"Checking out revision '%s' in %s ..\", revision, format_path(self.local))\n        self.context.execute(*self.get_checkout_command(revision, clean))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommitting changes to tracked files in the working tree.", "response": "def commit(self, message, author=None):\n        \"\"\"\n        Commit changes to tracked files in the working tree.\n\n        :param message: The commit message (a string).\n        :param author: Override :attr:`author` (refer to\n                       :func:`coerce_author()` for details\n                       on argument handling).\n        \"\"\"\n        # Make sure the local repository exists and supports a working tree.\n        self.ensure_exists()\n        self.ensure_working_tree()\n        logger.info(\"Committing changes in %s: %s\", format_path(self.local), message)\n        author = coerce_author(author) if author else self.author\n        self.context.execute(*self.get_commit_command(message, author))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating the local repository.", "response": "def create(self):\n        \"\"\"\n        Create the local repository (if it doesn't already exist).\n\n        :returns: :data:`True` if the local repository was just created,\n                  :data:`False` if it already existed.\n\n        What :func:`create()` does depends on the situation:\n\n        - When :attr:`exists` is :data:`True` nothing is done.\n        - When the :attr:`local` repository doesn't exist but a :attr:`remote`\n          repository location is given, a clone of the remote repository is\n          created.\n        - When the :attr:`local` repository doesn't exist and no :attr:`remote`\n          repository has been specified then a new local repository will be\n          created.\n\n        When :func:`create()` is responsible for creating the :attr:`local`\n        repository it will make sure the :attr:`bare` option is respected.\n        \"\"\"\n        if self.exists:\n            logger.debug(\"Local %s repository (%s) already exists, ignoring request to create it.\",\n                         self.friendly_name, format_path(self.local))\n            return False\n        else:\n            timer = Timer()\n            if self.remote:\n                logger.info(\"Creating local %s repository (%s) by cloning %s ..\",\n                            self.friendly_name, format_path(self.local), self.remote)\n            else:\n                logger.info(\"Creating local %s repository (%s) ..\",\n                            self.friendly_name, format_path(self.local))\n            self.context.execute(*self.get_create_command())\n            logger.debug(\"Took %s to %s local %s repository.\",\n                         timer, \"clone\" if self.remote else \"create\",\n                         self.friendly_name)\n            if self.remote:\n                self.mark_updated()\n            # Ensure that all further commands are executed in the local repository.\n            self.update_context()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new branch based on the working tree s revision.", "response": "def create_branch(self, branch_name):\n        \"\"\"\n        Create a new branch based on the working tree's revision.\n\n        :param branch_name: The name of the branch to create (a string).\n\n        This method automatically checks out the new branch, but note that the\n        new branch may not actually exist until a commit has been made on the\n        branch.\n        \"\"\"\n        # Make sure the local repository exists and supports a working tree.\n        self.create()\n        self.ensure_working_tree()\n        # Create the new branch in the local repository.\n        logger.info(\"Creating branch '%s' in %s ..\", branch_name, format_path(self.local))\n        self.context.execute(*self.get_create_branch_command(branch_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_release_branch(self, branch_name):\n        # Validate the release scheme.\n        self.ensure_release_scheme('branches')\n        # Validate the name of the release branch.\n        if self.compiled_filter.match(branch_name) is None:\n            msg = \"The branch name '%s' doesn't match the release filter!\"\n            raise ValueError(msg % branch_name)\n        # Make sure the local repository exists.\n        self.create()\n        # Figure out the correct parent release branch.\n        candidates = natsort([r.revision.branch for r in self.ordered_releases] + [branch_name])\n        index = candidates.index(branch_name) - 1\n        if index < 0:\n            msg = \"Failed to determine suitable parent branch for release branch '%s'!\"\n            raise ValueError(msg % branch_name)\n        parent_branch = candidates[index]\n        self.checkout(parent_branch)\n        self.create_branch(branch_name)", "response": "Creates a new release branch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_tag(self, tag_name):\n        # Make sure the local repository exists and supports a working tree.\n        self.create()\n        self.ensure_working_tree()\n        # Create the new tag in the local repository.\n        logger.info(\"Creating tag '%s' in %s ..\", tag_name, format_path(self.local))\n        self.context.execute(*self.get_create_tag_command(tag_name))", "response": "Create a new tag based on the working tree s revision."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes or close a branch in the local repository.", "response": "def delete_branch(self, branch_name, message=None, author=None):\n        \"\"\"\n        Delete or close a branch in the local repository.\n\n        :param branch_name: The name of the branch to delete or close (a string).\n        :param message: The message to use when closing the branch requires a\n                        commit (a string or :data:`None`, defaults to the\n                        string \"Closing branch NAME\").\n        :param author: Override :attr:`author` (refer to\n                       :func:`coerce_author()` for details\n                       on argument handling).\n        \"\"\"\n        # Make sure the local repository exists.\n        self.create()\n        # Delete the branch in the local repository.\n        logger.info(\"Deleting branch '%s' in %s ..\", branch_name, format_path(self.local))\n        self.context.execute(*self.get_delete_branch_command(\n            author=(coerce_author(author) if author else self.author),\n            message=(message or (\"Closing branch %s\" % branch_name)),\n            branch_name=branch_name,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure that the working tree is clean.", "response": "def ensure_clean(self):\n        \"\"\"\n        Make sure the working tree is clean (contains no changes to tracked files).\n\n        :raises: :exc:`~vcs_repo_mgr.exceptions.WorkingTreeNotCleanError`\n                 when the working tree contains changes to tracked files.\n        \"\"\"\n        if not self.is_clean:\n            raise WorkingTreeNotCleanError(compact(\"\"\"\n                The repository's local working tree ({local})\n                contains changes to tracked files!\n            \"\"\", local=format_path(self.local)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures that the local repository exists.", "response": "def ensure_exists(self):\n        \"\"\"\n        Make sure the local repository exists.\n\n        :raises: :exc:`~exceptions.ValueError` when the\n                 local repository doesn't exist yet.\n        \"\"\"\n        if not self.exists:\n            msg = \"The local %s repository %s doesn't exist!\"\n            raise ValueError(msg % (self.friendly_name, format_path(self.local)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures that the given value is a hexadecimal string.", "response": "def ensure_hexadecimal_string(self, value, command=None):\n        \"\"\"\n        Make sure the given value is a hexadecimal string.\n\n        :param value: The value to check (a string).\n        :param command: The command that produced the value (a string or :data:`None`).\n        :returns: The validated hexadecimal string.\n        :raises: :exc:`~exceptions.ValueError` when `value` is not a hexadecimal string.\n        \"\"\"\n        if not HEX_PATTERN.match(value):\n            msg = \"Expected a hexadecimal string, got '%s' instead!\"\n            if command:\n                msg += \" ('%s' gave unexpected output)\"\n                msg %= (value, command)\n            else:\n                msg %= value\n            raise ValueError(msg)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ensure_release_scheme(self, expected_scheme):\n        if self.release_scheme != expected_scheme:\n            msg = \"Repository isn't using '%s' release scheme!\"\n            raise TypeError(msg % expected_scheme)", "response": "Ensures that the release scheme is correctly configured."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ensure_working_tree(self):\n        if not self.supports_working_tree:\n            raise MissingWorkingTreeError(compact(\"\"\"\n                A working tree is required but the local {friendly_name}\n                repository at {directory} doesn't support a working tree!\n            \"\"\", friendly_name=self.friendly_name, directory=format_path(self.local)))", "response": "Ensures that the local repository supports a working tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef export(self, directory, revision=None):\n        # Make sure we're dealing with an absolute pathname (because a relative\n        # pathname would be interpreted as relative to the repository's main\n        # directory, which isn't necessarily what the caller expects).\n        directory = os.path.abspath(directory)\n        # Make sure the local repository exists.\n        self.create()\n        # Export the tree from the local repository.\n        timer = Timer()\n        revision = revision or self.default_revision\n        logger.info(\"Exporting revision '%s' in %s to %s ..\", revision, format_path(self.local), directory)\n        self.context.execute('mkdir', '-p', directory)\n        self.context.execute(*self.get_export_command(directory, revision))\n        logger.debug(\"Took %s to pull changes from remote %s repository.\", timer, self.friendly_name)", "response": "Export the complete tree from the local version control repository."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding a remote repository connected to the local repository.", "response": "def find_remote(self, default=False, name=None, role=None):\n        \"\"\"\n        Find a remote repository connected to the local repository.\n\n        :param default: :data:`True` to only look for default remotes,\n                        :data:`False` otherwise.\n        :param name: The name of the remote to look for\n                     (a string or :data:`None`).\n        :param role: A role that the remote should have\n                     (a string or :data:`None`).\n        :returns: A :class:`Remote` object or :data:`None`.\n        \"\"\"\n        for remote in self.known_remotes:\n            if ((remote.default if default else True) and\n                    (remote.name == name if name else True) and\n                    (role in remote.roles if role else True)):\n                return remote"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_control_field(self, revision=None):\n        value = \"%s#%s\" % (self.remote or self.local, self.find_revision_id(revision))\n        return self.control_field, value", "response": "Generate a Debian control file field referring for this repository and revision."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive the operator a chance to interactively resolve merge conflicts. :param exception: An :exc:`~executor.ExternalCommandFailed` object. :returns: :data:`True` if the operator has interactively resolved any merge conflicts (and as such the merge error doesn't need to be propagated), :data:`False` otherwise. This method checks whether :data:`sys.stdin` is connected to a terminal to decide whether interaction with an operator is possible. If it is then an interactive terminal prompt is used to ask the operator to resolve the merge conflict(s). If the operator confirms the prompt, the merge error is swallowed instead of propagated. When :data:`sys.stdin` is not connected to a terminal or the operator denies the prompt the merge error is propagated.", "response": "def interactive_merge_conflict_handler(self, exception):\n        \"\"\"\n        Give the operator a chance to interactively resolve merge conflicts.\n\n        :param exception: An :exc:`~executor.ExternalCommandFailed` object.\n        :returns: :data:`True` if the operator has interactively resolved any\n                  merge conflicts (and as such the merge error doesn't need to\n                  be propagated), :data:`False` otherwise.\n\n        This method checks whether :data:`sys.stdin` is connected to a terminal\n        to decide whether interaction with an operator is possible. If it is\n        then an interactive terminal prompt is used to ask the operator to\n        resolve the merge conflict(s). If the operator confirms the prompt, the\n        merge error is swallowed instead of propagated. When :data:`sys.stdin`\n        is not connected to a terminal or the operator denies the prompt the\n        merge error is propagated.\n        \"\"\"\n        if connected_to_terminal(sys.stdin):\n            logger.info(compact(\"\"\"\n                It seems that I'm connected to a terminal so I'll give you a\n                chance to interactively fix the merge conflict(s) in order to\n                avoid propagating the merge error. Please mark or stage your\n                changes but don't commit the result just yet (it will be done\n                for you).\n            \"\"\"))\n            while True:\n                if prompt_for_confirmation(\"Ignore merge error because you've resolved all conflicts?\"):\n                    if self.merge_conflicts:\n                        logger.warning(\"I'm still seeing merge conflicts, please double check! (%s)\",\n                                       concatenate(self.merge_conflicts))\n                    else:\n                        # The operator resolved all conflicts.\n                        return True\n                else:\n                    # The operator wants us to propagate the error.\n                    break\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_feature_branch(self, branch_name):\n        # The following checks are intentionally ordered from lightweight to heavyweight.\n        if branch_name == self.default_revision:\n            # The default branch is never a feature branch.\n            return False\n        elif branch_name not in self.branches:\n            # Invalid branch names can't be feature branch names.\n            return False\n        elif self.release_scheme == 'branches' and branch_name in self.release_branches:\n            # Release branches are not feature branches.\n            return False\n        else:\n            # Other valid branches are considered feature branches.\n            return True", "response": "Determines whether a branch name refers to a feature branch."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmerges a revision into the current branch.", "response": "def merge(self, revision=None):\n        \"\"\"\n        Merge a revision into the current branch (without committing the result).\n\n        :param revision: The revision to merge in (a string or :data:`None`,\n                         defaults to :attr:`default_revision`).\n        :raises: The following exceptions can be raised:\n\n                 - :exc:`~vcs_repo_mgr.exceptions.MergeConflictError` if the\n                   merge command reports an error and merge conflicts are\n                   detected that can't be (or haven't been) resolved\n                   interactively.\n                 - :exc:`~executor.ExternalCommandFailed` if the merge command\n                   reports an error but no merge conflicts are detected.\n\n        Refer to the documentation of :attr:`merge_conflict_handler` if you\n        want to customize the handling of merge conflicts.\n        \"\"\"\n        # Make sure the local repository exists and supports a working tree.\n        self.create()\n        self.ensure_working_tree()\n        # Merge the specified revision into the current branch.\n        revision = revision or self.default_revision\n        logger.info(\"Merging revision '%s' in %s ..\", revision, format_path(self.local))\n        try:\n            self.context.execute(*self.get_merge_command(revision))\n        except ExternalCommandFailed as e:\n            # Check for merge conflicts.\n            conflicts = self.merge_conflicts\n            if conflicts:\n                # Always warn about merge conflicts and log the relevant filenames.\n                explanation = format(\"Merge failed due to conflicts in %s! (%s)\",\n                                     pluralize(len(conflicts), \"file\"),\n                                     concatenate(sorted(conflicts)))\n                logger.warning(\"%s\", explanation)\n                if self.merge_conflict_handler(e):\n                    # Trust the operator (or caller) and swallow the exception.\n                    return\n                else:\n                    # Raise a specific exception for merge conflicts.\n                    raise MergeConflictError(explanation)\n            else:\n                # Don't swallow the exception or obscure the traceback\n                # in case we're not `allowed' to handle the exception.\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_up(self, target_branch=None, feature_branch=None, delete=True, create=True):\n        timer = Timer()\n        repository_was_created = self.create()\n        revision_to_merge = None\n        # Default the target branch to the current branch.\n        if not target_branch:\n            target_branch = self.current_branch\n            if not target_branch:\n                raise TypeError(\"You need to specify the target branch! (where merging starts)\")\n        # Parse the feature branch specification.\n        feature_branch = coerce_feature_branch(feature_branch) if feature_branch else None\n        # Make sure we start with a clean working tree.\n        self.ensure_clean()\n        # Make sure we're up to date with our upstream repository (if any).\n        if not repository_was_created:\n            self.pull()\n        # Checkout or create the target branch.\n        logger.debug(\"Checking if target branch exists (%s) ..\", target_branch)\n        if target_branch in self.branches:\n            self.checkout(revision=target_branch)\n            # Get the global revision id of the release branch we're about to merge.\n            revision_to_merge = self.find_revision_id(target_branch)\n        elif not create:\n            raise ValueError(\"The target branch %r doesn't exist!\" % target_branch)\n        elif self.compiled_filter.match(target_branch):\n            self.create_release_branch(target_branch)\n        else:\n            self.create_branch(target_branch)\n        # Check if we need to merge in a feature branch.\n        if feature_branch:\n            if feature_branch.location:\n                # Pull in the feature branch.\n                self.pull(remote=feature_branch.location,\n                          revision=feature_branch.revision)\n            # Get the global revision id of the feature branch we're about to merge.\n            revision_to_merge = self.find_revision_id(feature_branch.revision)\n            # Merge in the feature branch.\n            self.merge(revision=feature_branch.revision)\n            # Commit the merge.\n            self.commit(message=\"Merged %s\" % feature_branch.expression)\n        # We skip merging up through release branches when the target branch is\n        # the default branch (in other words, there's nothing to merge up).\n        if target_branch != self.default_revision:\n            # Find the release branches in the repository.\n            release_branches = [release.revision.branch for release in self.ordered_releases]\n            logger.debug(\"Found %s: %s\",\n                         pluralize(len(release_branches), \"release branch\", \"release branches\"),\n                         concatenate(release_branches))\n            # Find the release branches after the target branch.\n            later_branches = release_branches[release_branches.index(target_branch) + 1:]\n            logger.info(\"Found %s after target branch (%s): %s\",\n                        pluralize(len(later_branches), \"release branch\", \"release branches\"),\n                        target_branch,\n                        concatenate(later_branches))\n            # Determine the branches that need to be merged.\n            branches_to_upmerge = later_branches + [self.default_revision]\n            logger.info(\"Merging up from '%s' to %s: %s\",\n                        target_branch,\n                        pluralize(len(branches_to_upmerge), \"branch\", \"branches\"),\n                        concatenate(branches_to_upmerge))\n            # Merge the feature branch up through the selected branches.\n            merge_queue = [target_branch] + branches_to_upmerge\n            while len(merge_queue) >= 2:\n                from_branch = merge_queue[0]\n                to_branch = merge_queue[1]\n                logger.info(\"Merging '%s' into '%s' ..\", from_branch, to_branch)\n                self.checkout(revision=to_branch)\n                self.merge(revision=from_branch)\n                self.commit(message=\"Merged %s\" % from_branch)\n                merge_queue.pop(0)\n        # Check if we need to delete or close the feature branch.\n        if delete and feature_branch and self.is_feature_branch(feature_branch.revision):\n            # Delete or close the feature branch.\n            self.delete_branch(\n                branch_name=feature_branch.revision,\n                message=\"Closing feature branch %s\" % feature_branch.revision,\n            )\n            # Update the working tree to the default branch.\n            self.checkout()\n        logger.info(\"Done! Finished merging up in %s.\", timer)\n        return revision_to_merge", "response": "Merge a change into one or more release branches and the default branch."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pull(self, remote=None, revision=None):\n        remote = remote or self.remote\n        # Make sure the local repository exists.\n        if self.create() and (remote == self.remote or not remote):\n            # Don't waste time pulling from a remote repository that we just cloned.\n            logger.info(\"Skipping pull from default remote because we just created the local %s repository.\",\n                        self.friendly_name)\n            return\n        # Make sure there is a remote repository to pull from.\n        if not (remote or self.default_pull_remote):\n            logger.info(\"Skipping pull (no default remote is configured).\")\n            return\n        # Check if we're about to perform a redundant pull.\n        update_limit = int(os.environ.get(UPDATE_VARIABLE, '0'))\n        if update_limit and self.last_updated >= update_limit:\n            logger.info(\"Skipping pull due to update limit.\")\n            return\n        # Pull the changes from the remote repository.\n        timer = Timer()\n        logger.info(\"Pulling changes from %s into local %s repository (%s) ..\",\n                    remote or \"default remote\", self.friendly_name, format_path(self.local))\n        self.context.execute(*self.get_pull_command(remote=remote, revision=revision))\n        logger.debug(\"Took %s to pull changes from remote %s repository.\", timer, self.friendly_name)\n        self.mark_updated()", "response": "Pulls changes from a remote repository into a local repository."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef push(self, remote=None, revision=None):\n        # Make sure the local repository exists.\n        self.ensure_exists()\n        # Make sure there is a remote repository to push to.\n        if not (remote or self.remote or self.default_push_remote):\n            logger.info(\"Skipping push (no default remote is configured).\")\n        # Push the changes to the remote repository.\n        timer = Timer()\n        logger.info(\"Pushing changes from %s to %s ..\",\n                    format_path(self.local),\n                    remote or self.remote or \"default remote\")\n        self.context.execute(*self.get_push_command(remote, revision))\n        logger.debug(\"Took %s to push changes to remote repository.\", timer)", "response": "Push changes from the local repository to the remote repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef release_to_tag(self, release_id):\n        self.ensure_release_scheme('tags')\n        return self.releases[release_id].revision.tag", "response": "Shortcut to translate a release identifier to a tag name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nselect the newest release that is not newer than the given release.", "response": "def select_release(self, highest_allowed_release):\n        \"\"\"\n        Select the newest release that is not newer than the given release.\n\n        :param highest_allowed_release: The identifier of the release that sets\n                                        the upper bound for the selection (a\n                                        string).\n        :returns: The identifier of the selected release (a string).\n        :raises: :exc:`~vcs_repo_mgr.exceptions.NoMatchingReleasesError`\n                 when no matching releases are found.\n        \"\"\"\n        matching_releases = []\n        highest_allowed_key = natsort_key(highest_allowed_release)\n        for release in self.ordered_releases:\n            release_key = natsort_key(release.identifier)\n            if release_key <= highest_allowed_key:\n                matching_releases.append(release)\n        if not matching_releases:\n            msg = \"No releases below or equal to %r found in repository!\"\n            raise NoMatchingReleasesError(msg % highest_allowed_release)\n        return matching_releases[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the execution context with the current working directory.", "response": "def update_context(self):\n        \"\"\"\n        Try to ensure that external commands are executed in the local repository.\n\n        What :func:`update_context()` does depends on whether the directory\n        given by :attr:`local` exists:\n\n        - If :attr:`local` exists then the working directory of :attr:`context`\n          will be set to :attr:`local`. This is to ensure that version control\n          commands are run inside of the intended version control repository.\n\n        - If :attr:`local` doesn't exist then the working directory of\n          :attr:`context` is cleared. This avoids external commands from\n          failing due to an invalid (non existing) working directory.\n        \"\"\"\n        if self.context.is_directory(self.local):\n            # Set the working directory of the execution context\n            # to the directory containing the local repository.\n            self.context.options['directory'] = self.local\n        else:\n            # Clear the execution context's working directory.\n            self.context.options.pop('directory', None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enumerate(vendor_id=0, product_id=0):\n    info = hidapi.hid_enumerate(vendor_id, product_id)\n    while info:\n        yield DeviceInfo(info)\n        info = info.next\n    hidapi.hid_free_enumeration(info)", "response": "Enumerate the HID Devices."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, data, report_id=b'\\0'):\n        self._check_device_status()\n        bufp = ffi.new(\"unsigned char[]\", len(data)+1)\n        buf = ffi.buffer(bufp, len(data)+1)\n        buf[0] = report_id\n        buf[1:] = data\n        rv = hidapi.hid_write(self._device, bufp, len(data)+1)\n        if rv == -1:\n            raise IOError(\"Failed to write to HID device.\")", "response": "Write an output report to a HID device."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading an Input report from a HID device.", "response": "def read(self, length, timeout_ms=0, blocking=False):\n        \"\"\" Read an Input report from a HID device with timeout.\n\n        Input reports are returned to the host through the `INTERRUPT IN`\n        endpoint. The first byte will contain the Report number if the device\n        uses numbered reports.\n        By default reads are non-blocking, i.e. the method will return\n        `None` if no data was available. Blocking reads can be enabled with\n        :param blocking:. Additionally, a timeout for the read can be\n        specified.\n\n        :param length:      The number of bytes to read. For devices with\n                            multiple reports, make sure to read an extra byte\n                            for the report number.\n        :param timeout_ms:  Timeout in miliseconds\n        :type timeout_ms:   int\n        :param blocking:    Block until data is available\n\n        \"\"\"\n        self._check_device_status()\n        bufp = ffi.new(\"unsigned char[]\", length)\n        if not timeout_ms and blocking:\n            timeout_ms = -1\n        if timeout_ms:\n            rv = hidapi.hid_read_timeout(self._device, bufp, length,\n                                         timeout_ms)\n        else:\n            rv = hidapi.hid_read(self._device, bufp, length)\n        if rv == -1:\n            raise IOError(\"Failed to read from HID device: {0}\"\n                          .format(self._get_last_error_string()))\n        elif rv == 0:\n            return None\n        else:\n            return ffi.buffer(bufp, rv)[:]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the Manufacturer String from the HID device.", "response": "def get_manufacturer_string(self):\n        \"\"\" Get the Manufacturer String from the HID device.\n\n        :return:    The Manufacturer String\n        :rtype:     unicode\n\n        \"\"\"\n        self._check_device_status()\n        str_p = ffi.new(\"wchar_t[]\", 255)\n        rv = hidapi.hid_get_manufacturer_string(self._device, str_p, 255)\n        if rv == -1:\n            raise IOError(\"Failed to read manufacturer string from HID \"\n                          \"device: {0}\".format(self._get_last_error_string()))\n        return ffi.string(str_p)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_product_string(self):\n        self._check_device_status()\n        str_p = ffi.new(\"wchar_t[]\", 255)\n        rv = hidapi.hid_get_product_string(self._device, str_p, 255)\n        if rv == -1:\n            raise IOError(\"Failed to read product string from HID device: {0}\"\n                          .format(self._get_last_error_string()))\n        return ffi.string(str_p)", "response": "Get the Product String from the HID device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_serial_number_string(self):\n        self._check_device_status()\n        str_p = ffi.new(\"wchar_t[]\", 255)\n        rv = hidapi.hid_get_serial_number_string(self._device, str_p, 255)\n        if rv == -1:\n            raise IOError(\"Failed to read serial number string from HID \"\n                          \"device: {0}\".format(self._get_last_error_string()))\n        return ffi.string(str_p)", "response": "Get the Serial Number String from the HID device."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a Feature report to the HID device.", "response": "def send_feature_report(self, data, report_id=0x0):\n        \"\"\" Send a Feature report to the device.\n\n        Feature reports are sent over the Control endpoint as a Set_Report\n        transfer.\n\n        :param data:        The data to send\n        :type data:         str/bytes\n        :param report_id:   The Report ID to send to\n        :type report_id:    int\n\n        \"\"\"\n        self._check_device_status()\n        bufp = ffi.new(\"unsigned char[]\", len(data)+1)\n        buf = ffi.buffer(bufp, len(data)+1)\n        buf[0] = report_id\n        buf[1:] = data\n        rv = hidapi.hid_send_feature_report(self._device, bufp, len(bufp))\n        if rv == -1:\n            raise IOError(\"Failed to send feature report to HID device: {0}\"\n                          .format(self._get_last_error_string()))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a feature report from the device.", "response": "def get_feature_report(self, report_id, length):\n        \"\"\" Get a feature report from the device.\n\n        :param report_id:   The Report ID of the report to be read\n        :type report_id:    int\n        :return:            The report data\n        :rtype:             str/bytes\n\n        \"\"\"\n        self._check_device_status()\n        bufp = ffi.new(\"unsigned char[]\", length+1)\n        buf = ffi.buffer(bufp, length+1)\n        buf[0] = report_id\n        rv = hidapi.hid_get_feature_report(self._device, bufp, length+1)\n        if rv == -1:\n            raise IOError(\"Failed to get feature report from HID device: {0}\"\n                          .format(self._get_last_error_string()))\n        return buf[1:]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_indexed_string(self, idx):\n        self._check_device_status()\n        bufp = ffi.new(\"wchar_t*\")\n        rv = hidapi.hid_get_indexed_string(self._device, idx, bufp, 65536)\n        if rv == -1:\n            raise IOError(\"Failed to read string with index {0} from HID \"\n                          \"device: {0}\"\n                          .format(idx, self._get_last_error_string()))\n        return ffi.buffer(bufp, 65536)[:].strip()", "response": "Get a string from the device based on its string index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        self._check_device_status()\n        hidapi.hid_close(self._device)\n        self._device = None", "response": "Close the connection to the HID device."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_raw_rules(cls, url):\r\n        \"Load raw rules from url or package file.\"\r\n        raw_rules = []\r\n        filename = url.split('/')[-1] # e.g.: easylist.txt\r\n        try:\r\n            with closing(request.get(url, stream=True)) as file:\r\n                file.raise_for_status()\r\n                # lines = 0 # to be removed\r\n                for rule in file.iter_lines():\r\n                    raw_rules.append(rule.strip())\r\n                    # lines += 1 # tbr\r\n                    # if lines == 2500: break # tbr, only for windoze with no re2\r\n            logger.info(\"Adblock online %s: %d\", filename, len(raw_rules))\r\n        except: # file server down or bad url\r\n            with open(resource_filename('summary', filename), 'r') as file:\r\n                for rule in file:\r\n                    raw_rules.append(rule.strip())\r\n            logger.info(\"Adblock offline %s: %d\", filename, len(raw_rules))\r\n        return raw_rules", "response": "Load raw rules from url or package file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading all available Adblock rules.", "response": "def get_all_rules(cls):\r\n        \"Load all available Adblock rules.\"\r\n        from adblockparser import AdblockRules\r\n        \r\n        raw_rules = []\r\n        for url in [\r\n            config.ADBLOCK_EASYLIST_URL, config.ADBLOCK_EXTRALIST_URL]:\r\n            raw_rules.extend(cls.load_raw_rules(url))\r\n\r\n        rules = AdblockRules(raw_rules)\r\n        return rules"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_image(cls, url):\r\n        from PIL.ImageFile import Parser as PILParser\r\n\r\n        length = 0\r\n        raw_image = None\r\n        with closing(request.get(url, stream=True)) as response:\r\n            response.raise_for_status()\r\n            response_url = response.url\r\n            parser = PILParser()\r\n            for chunk in response.iter_content(config.CHUNK_SIZE):\r\n                length += len(chunk)\r\n                if length > config.IMAGE_MAX_BYTESIZE:\r\n                    del parser\r\n                    raise cls.MaxBytesException\r\n                parser.feed(chunk)\r\n                # comment this to get the whole file\r\n                if parser.image and parser.image.size:\r\n                    raw_image = parser.image\r\n                    del parser # free some memory\r\n                    break\r\n            # or this to get just the size and format\r\n            # raw_image = parser.close()\r\n        if length == 0:\r\n            raise cls.ZeroBytesException\r\n        if not raw_image:\r\n            raise cls.NoImageException\r\n        image = Image(response_url, raw_image.size, raw_image.format)\r\n        return image", "response": "Returns a new Image instance with the given url."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_color(cls, raw_image):\r\n        # sum(img.convert(\"L\").getextrema()) in (0, 2)\r\n        extrema = raw_image.convert(\"L\").getextrema()\r\n        if extrema == (255, 255): # all white\r\n            raise cls.MonoImageException", "response": "Check if the raw_image is completely black or white."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck whether the gif is animated.", "response": "def check_animated(cls, raw_image):\r\n        \"Checks whether the gif is animated.\"\r\n        try:\r\n            raw_image.seek(1)\r\n        except EOFError:\r\n            isanimated= False\r\n        else:\r\n            isanimated= True\r\n            raise cls.AnimatedImageException"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef valid_options(kwargs, allowed_options):\n\n    diff = set(kwargs) - set(allowed_options)\n    if diff:\n        print(\"Invalid option(s): \", ', '.join(diff))\n        return False\n    return True", "response": "Checks that kwargs are valid API options"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new entry in the course cache.", "response": "def create(self, fullname, shortname, category_id, **kwargs):\n        \"\"\"\n        Create a new course\n\n        :param string fullname: The course's fullname\n        :param string shortname: The course's shortname\n        :param int category_id: The course's category\n\n        :keyword string idnumber: (optional) Course ID number. \\\n            Yes, it's a string, blame Moodle.\n        :keyword int summaryformat: (optional) Defaults to 1 (HTML). \\\n            Summary format options: (1 = HTML, 0 = Moodle, 2 = Plain, \\\n            or 4 = Markdown)\n        :keyword string format: (optional) Defaults to \"topics\"\n            Topic options: (weeks, topics, social, site)\n        :keyword bool showgrades: (optional) Defaults to True. \\\n            Determines if grades are shown\n        :keyword int newsitems: (optional) Defaults to 5. \\\n            Number of recent items appearing on the course page\n        :keyword bool startdate: (optional) Timestamp when the course start\n        :keyword int maxbytes: (optional) Defaults to 83886080. \\\n            Largest size of file that can be uploaded into the course\n        :keyword bool showreports: Default to True. Are activity report shown?\n        :keyword bool visible: (optional) Determines if course is \\\n            visible to students\n        :keyword int groupmode: (optional) Defaults to 2.\n            options: (0 = no group, 1 = separate, 2 = visible)\n        :keyword bool groupmodeforce: (optional) Defaults to False. \\\n            Force group mode\n        :keyword int defaultgroupingid: (optional) Defaults to 0. \\\n            Default grouping id\n        :keyword bool enablecompletion: (optional) Enable control via \\\n            completion in activity settings.\n        :keyword bool completionstartonenrol: (optional) \\\n            Begin tracking a student's progress in course completion after\n        :keyword bool completionnotify: (optional) Default? Dunno. \\\n            Presumably notifies course completion\n        :keyword string lang: (optional) Force course language.\n        :keyword string forcetheme: (optional) Name of the force theme\n\n        Example Usage::\n\n        >>> import muddle\n        >>> muddle.course().create('a new course', 'new-course', 20)\n        \"\"\"\n\n        allowed_options = ['idnumber', 'summaryformat',\n                           'format', 'showgrades',\n                           'newsitems', 'startdate',\n                           'maxbytes', 'showreports',\n                           'visible', 'groupmode',\n                           'groupmodeforce', 'jdefaultgroupingid',\n                           'enablecompletion', 'completionstartonenrol',\n                           'completionnotify', 'lang',\n                           'forcetheme']\n\n        if valid_options(kwargs, allowed_options):\n            option_params = {}\n            for index, key in enumerate(kwargs):\n                val = kwargs.get(key)\n\n                if isinstance(val, bool):\n                    val = int(val)\n\n                option_params.update({'courses[0][' + key + ']': val})\n\n            params = {'wsfunction': 'core_course_create_courses',\n                      'courses[0][fullname]': fullname,\n                      'courses[0][shortname]': shortname,\n                      'courses[0][categoryid]': category_id}\n\n            params.update(option_params)\n            params.update(self.request_params)\n\n            return requests.post(self.api_url, params=params, verify=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a specified courses", "response": "def delete(self):\n        \"\"\"\n        Deletes a specified courses\n\n        Example Usage::\n\n        >>> import muddle\n        >>> muddle.course(10).delete()\n        \"\"\"\n\n        params = {'wsfunction': 'core_course_delete_courses',\n                  'courseids[0]': self.course_id}\n        params.update(self.request_params)\n\n        return requests.post(self.api_url, params=params, verify=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn entire contents of course page", "response": "def contents(self):\n        \"\"\"\n        Returns entire contents of course page\n\n        :returns: response object\n\n        Example Usage::\n\n        >>> import muddle\n        >>> muddle.course(10).content()\n        \"\"\"\n\n        params = self.request_params\n        params.update({'wsfunction': 'core_course_get_contents',\n                       'courseid': self.course_id})\n\n        return requests.get(self.api_url, params=params, verify=False).json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef duplicate(self, fullname, shortname, categoryid,\n                  visible=True, **kwargs):\n        \"\"\"\n        Duplicates an existing course with options.\n        Note: Can be very slow running.\n\n        :param string fullname: The new course's full name\n        :param string shortname: The new course's short name\n        :param string categoryid: Category new course should be created under\n\n        :keyword bool visible: Defaults to True. The new course's visiblity\n        :keyword bool activities: (optional) Defaults to True. \\\n            Include course activites\n        :keyword bool blocks: (optional) Defaults to True. \\\n            Include course blocks\n        :keyword bool filters: (optional) Defaults to True. \\\n            Include course filters\n        :keyword bool users: (optional) Defaults to False. Include users\n        :keyword bool role_assignments: (optional) Defaults to False. \\\n            Include role assignments\n        :keyword bool comments: (optional) Defaults to False. \\\n            Include user comments\n        :keyword bool usercompletion: (optional) Defaults to False. \\\n            Include user course completion information\n        :keyword bool logs: (optional) Defaults to False. Include course logs\n        :keyword bool grade_histories: (optional) Defaults to False. \\\n            Include histories\n\n        :returns: response object\n\n        Example Usage::\n\n        >>> import muddle\n        >>> muddle.course(10).duplicate('new-fullname', 'new-shortname', 20)\n        \"\"\"\n\n        # TODO\n        # Ideally categoryid should be optional here and\n        # should default to catid of course being duplicated.\n\n        allowed_options = ['activities', 'blocks',\n                           'filters', 'users',\n                           'role_assignments', 'comments',\n                           'usercompletion', 'logs',\n                           'grade_histories']\n\n        if valid_options(kwargs, allowed_options):\n            option_params = {}\n            for index, key in enumerate(kwargs):\n                option_params.update(\n                    {'options[' + str(index) + '][name]': key,\n                     'options[' + str(index) + '][value]':\n                        int(kwargs.get(key))})\n\n            params = {'wsfunction': 'core_course_duplicate_course',\n                      'courseid': self.course_id,\n                      'fullname': fullname,\n                      'shortname': shortname,\n                      'categoryid': categoryid,\n                      'visible': int(visible)}\n            params.update(option_params)\n            params.update(self.request_params)\n\n            return requests.post(self.api_url, params=params, verify=False)", "response": "This method is used to create a duplicate of an existing course."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_data(self, export_to, delete_content=False):\n        params = {'wsfunction': 'core_course_import_course',\n                  'importfrom': self.course_id,\n                  'importto': export_to,\n                  'deletecontent': int(delete_content)}\n        params.update(self.request_params)\n\n        return requests.post(self.api_url, params=params, verify=False)", "response": "Export course data to another course."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning details for given category", "response": "def details(self):\n        \"\"\"\n        Returns details for given category\n\n        :returns: category response object\n\n        Example Usage::\n\n        >>> import muddle\n        >>> muddle.category(10).details()\n        \"\"\"\n        params = {'wsfunction': 'core_course_get_categories',\n                  'criteria[0][key]': 'id',\n                  'criteria[0][value]': self.category_id}\n\n        params.update(self.request_params)\n\n        return requests.post(self.api_url, params=params, verify=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a category. Optionally moves content to new parent.", "response": "def delete(self, new_parent=None, recursive=False):\n        \"\"\"\n        Deletes a category. Optionally moves content to new category.\n        Note: If category is in root, new_parent must be specified.\n\n        :param int new_parent: (optional) Category ID of new parent\n        :param bool recursive: recursively delete contents inside this category\n\n        Example Usage::\n\n        >>> import muddle\n        >>> muddle.category(10).delete()\n        \"\"\"\n\n        params = {'wsfunction': 'core_course_delete_categories',\n                  'categories[0][id]': self.category_id,\n                  'categories[0][recursive]': int(recursive)}\n        if new_parent:\n            params.update({'categories[0][newparent]': new_parent})\n        params.update(self.request_params)\n\n        return requests.post(self.api_url, params=params, verify=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that a path is legal.", "response": "def check_path(path):\n    \"\"\"Check that a path is legal.\n\n    :return: the path if all is OK\n    :raise ValueError: if the path is illegal\n    \"\"\"\n    if path is None or path == b'' or path.startswith(b'/'):\n        raise ValueError(\"illegal path '%s'\" % path)\n\n    if (\n        (sys.version_info[0] >= 3 and not isinstance(path, bytes)) and\n        (sys.version_info[0] == 2 and not isinstance(path, str))\n    ):\n        raise TypeError(\"illegale type for path '%r'\" % path)\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting a path in utf8 quoting it if necessary.", "response": "def format_path(p, quote_spaces=False):\n    \"\"\"Format a path in utf8, quoting it if necessary.\"\"\"\n    if b'\\n' in p:\n        p = re.sub(b'\\n', b'\\\\n', p)\n        quote = True\n    else:\n        quote = p[0] == b'\"' or (quote_spaces and b' ' in p)\n    if quote:\n        extra = GIT_FAST_IMPORT_NEEDS_EXTRA_SPACE_AFTER_QUOTE and b' ' or b''\n        p = b'\"' + p + b'\"' + extra\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a tuple of name email sec - since - epoch utc - offset - secs as a string.", "response": "def format_who_when(fields):\n    \"\"\"Format a tuple of name,email,secs-since-epoch,utc-offset-secs as a string.\"\"\"\n    offset = fields[3]\n    if offset < 0:\n        offset_sign = b'-'\n        offset = abs(offset)\n    else:\n        offset_sign = b'+'\n    offset_hours = offset // 3600\n    offset_minutes = offset // 60 - offset_hours * 60\n    offset_str = offset_sign + ('%02d%02d' % (offset_hours, offset_minutes)).encode('ascii')\n    name = fields[0]\n\n    if name == b'':\n        sep = b''\n    else:\n        sep = b' '\n\n    name = utf8_bytes_string(name)\n\n    email = fields[1]\n\n    email = utf8_bytes_string(email)\n\n    return b''.join((name, sep, b'<', email, b'> ', (\"%d\" % fields[2]).encode('ascii'), b' ', offset_str))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat the name and value of a property as a string.", "response": "def format_property(name, value):\n    \"\"\"Format the name and value (both unicode) of a property as a string.\"\"\"\n    result = b''\n    utf8_name = utf8_bytes_string(name)\n\n    result = b'property ' + utf8_name\n    if value is not None:\n        utf8_value = utf8_bytes_string(value)\n        result += b' ' + ('%d' % len(utf8_value)).encode('ascii') + b' ' + utf8_value\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump_str(self, names=None, child_lists=None, verbose=False):\n        interesting = {}\n        if names is None:\n            fields = [\n                k for k in list(self.__dict__.keys())\n                if not k.startswith(b'_')\n            ]\n        else:\n            fields = names\n        for field in fields:\n            value = self.__dict__.get(field)\n            if field in self._binary and value is not None:\n                value = b'(...)'\n            interesting[field] = value\n        if verbose:\n            return \"%s: %s\" % (self.__class__.__name__, interesting)\n        else:\n            return \"\\t\".join([repr(interesting[k]) for k in fields])", "response": "Dump the fields of this object as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_range(self):\n\n\t\tif not self.page:\n\t\t\treturn (1, self.last_blocks[self.coinid])\n\n\t\t# Get start of the range\n\t\tstart = self.page * self.limit\n\n\t\t# Get finish of the range\n\t\tend = (self.page + 1) * self.limit\n\n\t\tif start > self.last_blocks[self.coinid]:\n\t\t\treturn (1,1)\n\t\tif end > self.last_blocks[self.coinid]:\n\t\t\treturn (start, self.last_blocks[self.coinid])\n\t\treturn (start, end)", "response": "Get the range of the last block"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _open_repo(args, path_key='<path>'):\n    path = pathlib.Path(args[path_key]) if args[path_key] else None\n\n    try:\n        repo = open_repository(path)\n    except ValueError as exc:\n        raise ExitError(ExitCode.DATA_ERR, str(exc))\n\n    return repo", "response": "Open and return the repository containing the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_anchor(repo, id_prefix):\n    result = None\n    for anchor_id, anchor in repo.items():\n        if anchor_id.startswith(id_prefix):\n            if result is not None:\n                raise ExitError(\n                    ExitCode.DATA_ERR,\n                    'Ambiguous ID specification')\n\n            result = (anchor_id, anchor)\n\n    if result is None:\n        raise ExitError(\n            ExitCode.DATA_ERR,\n            'No anchor matching ID specification')\n\n    return result", "response": "Get an anchor by ID or a prefix of its id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize a new spor repository in the current directory.", "response": "def init_handler(args):\n    \"\"\"usage: {program} init\n\n    Initialize a new spor repository in the current directory.\n    \"\"\"\n    try:\n        initialize_repository(pathlib.Path.cwd())\n    except ValueError as exc:\n        print(exc, file=sys.stderr)\n        return ExitCode.DATAERR\n\n    return ExitCode.OK"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting - h for detailed help", "response": "def list_handler(args):\n    \"\"\"usage: {program} list\n\n    List the anchors for a file.\n    \"\"\"\n    repo = open_repository(None)\n    for anchor_id, anchor in repo.items():\n        print(\"{} {}:{} => {}\".format(anchor_id,\n                                      anchor.file_path.relative_to(repo.root),\n                                      anchor.context.offset, anchor.metadata))\n\n    return ExitCode.OK"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_handler(args):\n    file_path = pathlib.Path(args['<source-file>']).resolve()\n\n    try:\n        offset = int(args['<offset>'])\n        width = int(args['<width>'])\n        context_width = int(args['<context-width>'])\n    except ValueError as exc:\n        print(exc, file=sys.stderr)\n        return ExitCode.DATAERR\n\n    repo = _open_repo(args, '<source-file>')\n\n    if sys.stdin.isatty():\n        text = _launch_editor('# json metadata')\n    else:\n        text = sys.stdin.read()\n\n    try:\n        metadata = json.loads(text)\n    except json.JSONDecodeError:\n        print(\n            'Failed to create anchor. Invalid JSON metadata.', file=sys.stderr)\n        return ExitCode.DATAERR\n\n    # TODO: let user specify encoding\n    with file_path.open(mode='rt') as handle:\n        anchor = make_anchor(\n            file_path, offset, width, context_width, metadata, handle=handle)\n\n    repo.add(anchor)\n\n    return ExitCode.OK", "response": "add handler for add command"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving - h handler for remove", "response": "def remove_handler(args):\n    \"\"\"usage: {program} remove <anchor-id> [<path>]\n\n    Remove an existing anchor.\n    \"\"\"\n\n    repo = _open_repo(args)\n    anchor_id, anchor = _get_anchor(repo, args['<anchor-id>'])\n    del repo[anchor_id]\n\n    return ExitCode.OK"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _launch_editor(starting_text=''):\n    \"Launch editor, let user write text, then return that text.\"\n    # TODO: What is a reasonable default for windows? Does this approach even\n    # make sense on windows?\n    editor = os.environ.get('EDITOR', 'vim')\n\n    with tempfile.TemporaryDirectory() as dirname:\n        filename = pathlib.Path(dirname) / 'metadata.yml'\n        with filename.open(mode='wt') as handle:\n            handle.write(starting_text)\n        subprocess.call([editor, filename])\n\n        with filename.open(mode='rt') as handle:\n            text = handle.read()\n    return text", "response": "Launch editor let user write text then return that text."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates - h for all anchors in the current repository", "response": "def update_handler(args):\n    \"\"\"usage: {program} update [<path>]\n\n    Update out of date anchors in the current repository.\n    \"\"\"\n    repo = _open_repo(args)\n\n    for anchor_id, anchor in repo.items():\n        try:\n            anchor = update(anchor)\n        except AlignmentError as e:\n            print('Unable to update anchor {}. Reason: {}'.format(\n                anchor_id, e))\n        else:\n            repo[anchor_id] = anchor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating anchors in the current repository and print out the changes", "response": "def status_handler(args):\n    \"\"\"usage: {program} status [<path>]\n\n    Validate the anchors in the current repository.\n    \"\"\"\n\n    repo = _open_repo(args)\n\n    for anchor_id, anchor in repo.items():\n        diff_lines = get_anchor_diff(anchor)\n        if diff_lines:\n            print('{} {}:{} out-of-date'.format(\n                anchor_id,\n                anchor.file_path,\n                anchor.context.offset))\n\n    return ExitCode.OK"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetail - h for detailed help", "response": "def details_handler(args):\n    \"\"\"usage: {program} details <anchor-id> [<path>]\n\n    Get the details of a single anchor.\n    \"\"\"\n\n    repo = _open_repo(args)\n    _, anchor = _get_anchor(repo, args['<anchor-id>'])\n\n    print(\"\"\"path: {file_path}\nencoding: {encoding}\n\n[before]\n{before}\n--------------\n\n[topic]\n{topic}\n--------------\n\n[after]\n{after}\n--------------\n\noffset: {offset}\nwidth: {width}\"\"\".format(\n        file_path=anchor.file_path,\n        encoding=anchor.encoding,\n        before=anchor.context.before,\n        topic=anchor.context.topic,\n        after=anchor.context.after,\n        offset=anchor.context.offset,\n        width=anchor.context.width))\n\n    return ExitCode.OK"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _days_from_3744(hebrew_year):\n    # Start point for calculation is Molad new year 3744 (16BC)\n    years_from_3744 = hebrew_year - 3744\n    molad_3744 = get_chalakim(1 + 6, 779)    # Molad 3744 + 6 hours in parts\n\n    # Time in months\n\n    # Number of leap months\n    leap_months = (years_from_3744 * 7 + 1) // 19\n    leap_left = (years_from_3744 * 7 + 1) % 19    # Months left of leap cycle\n    months = years_from_3744 * 12 + leap_months   # Total Number of months\n\n    # Time in parts and days\n    # Molad This year + Molad 3744 - corrections\n    parts = months * PARTS_IN_MONTH + molad_3744\n    # 28 days in month + corrections\n    days = months * 28 + parts // PARTS_IN_DAY - 2\n\n    # Time left for round date in corrections\n    # 28 % 7 = 0 so only corrections counts\n    parts_left_in_week = parts % PARTS_IN_WEEK\n    parts_left_in_day = parts % PARTS_IN_DAY\n    week_day = parts_left_in_week // PARTS_IN_DAY\n\n    # pylint: disable=too-many-boolean-expressions\n    # pylint-comment: Splitting the 'if' below might create a bug in case\n    # the order is not kept.\n\n    # Molad \u05d3\"\u05e8 \u05d8\"\u05d2\n    if ((leap_left < 12 and week_day == 3 and\n         parts_left_in_day >= get_chalakim(9 + 6, 204)) or\n            # Molad \u05d8\"\u05e4\u05e7\u05ea \u05d5\"\u05d8\u05d1\n            (leap_left < 7 and week_day == 2 and\n             parts_left_in_day >= get_chalakim(15 + 6, 589))):\n        days += 1\n        week_day += 1\n\n    # pylint: enable=too-many-boolean-expressions\n\n    # ADU\n    if week_day in (1, 4, 6):\n        days += 1\n\n    return days", "response": "Return the number of days since 3 1 3744."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gdate_to_jdn(date):\n    not_jan_or_feb = (14 - date.month) // 12\n    year_since_4800bc = date.year + 4800 - not_jan_or_feb\n    month_since_4800bc = date.month + 12 * not_jan_or_feb - 3\n    jdn = date.day + (153 * month_since_4800bc + 2) // 5 \\\n        + 365 * year_since_4800bc \\\n        + (year_since_4800bc // 4 - year_since_4800bc // 100 +\n           year_since_4800bc // 400) - 32045\n    return jdn", "response": "Compute Julian day from Gregorian day month and year."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hdate_to_jdn(date):\n    day = date.day\n    month = date.month\n    if date.month == 13:\n        month = 6\n    if date.month == 14:\n        month = 6\n        day += 30\n\n    # Calculate days since 1,1,3744\n    day = _days_from_3744(date.year) + (59 * (month - 1) + 1) // 2 + day\n\n    # length of year\n    length_of_year = get_size_of_hebrew_year(date.year)\n    # Special cases for this year\n    if length_of_year % 10 > 4 and month > 2:  # long Heshvan\n        day += 1\n    if length_of_year % 10 < 4 and month > 3:  # short Kislev\n        day -= 1\n    if length_of_year > 365 and month > 6:  # leap year\n        day += 30\n\n    # adjust to julian\n    return day + 1715118", "response": "Compute Julian day number from Hebrew day month and year."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef jdn_to_gdate(jdn):\n    # pylint: disable=invalid-name\n\n    # The algorithm is a verbatim copy from Peter Meyer's article\n    # No explanation in the article is given for the variables\n    # Hence the exceptions for pylint and for flake8 (E741)\n\n    l = jdn + 68569  # noqa: E741\n    n = (4 * l) // 146097\n    l = l - (146097 * n + 3) // 4  # noqa: E741\n    i = (4000 * (l + 1)) // 1461001  # that's 1,461,001\n    l = l - (1461 * i) // 4 + 31  # noqa: E741\n    j = (80 * l) // 2447\n    day = l - (2447 * j) // 80\n    l = j // 11  # noqa: E741\n    month = j + 2 - (12 * l)\n    year = 100 * (n - 49) + i + l  # that's a lower-case L\n\n    return datetime.date(year, month, day)", "response": "Convert from the Julian day to the Gregorian day."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert from the Julian day to the Hebrew day.", "response": "def jdn_to_hdate(jdn):\n    \"\"\"Convert from the Julian day to the Hebrew day.\"\"\"\n    # calculate Gregorian date\n    date = jdn_to_gdate(jdn)\n\n    # Guess Hebrew year is Gregorian year + 3760\n    year = date.year + 3760\n\n    jdn_tishrey1 = hdate_to_jdn(HebrewDate(year, 1, 1))\n    jdn_tishrey1_next_year = hdate_to_jdn(HebrewDate(year + 1, 1, 1))\n\n    # Check if computed year was underestimated\n    if jdn_tishrey1_next_year <= jdn:\n        year = year + 1\n        jdn_tishrey1 = jdn_tishrey1_next_year\n        jdn_tishrey1_next_year = hdate_to_jdn(HebrewDate(year + 1, 1, 1))\n\n    size_of_year = get_size_of_hebrew_year(year)\n\n    # days into this year, first month 0..29\n    days = jdn - jdn_tishrey1\n\n    # last 8 months always have 236 days\n    if days >= (size_of_year - 236):  # in last 8 months\n        days = days - (size_of_year - 236)\n        month = days * 2 // 59\n        day = days - (month * 59 + 1) // 2 + 1\n\n        month = month + 4 + 1\n\n        # if leap\n        if size_of_year > 355 and month <= 6:\n            month = month + 8\n    else:  # in 4-5 first months\n        # Special cases for this year\n        if size_of_year % 10 > 4 and days == 59:   # long Heshvan (day 30)\n            month = 1\n            day = 30\n        elif size_of_year % 10 > 4 and days > 59:  # long Heshvan\n            month = (days - 1) * 2 // 59\n            day = days - (month * 59 + 1) // 2\n        elif size_of_year % 10 < 4 and days > 87:  # short kislev\n            month = (days + 1) * 2 // 59\n            day = days - (month * 59 + 1) // 2 + 2\n        else:  # regular months\n            month = days * 2 // 59\n            day = days - (month * 59 + 1) // 2 + 1\n\n        month = month + 1\n\n    return HebrewDate(year, month, day)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate an anchor based on the current contents of its source file.", "response": "def update(anchor, handle=None):\n    \"\"\"Update an anchor based on the current contents of its source file.\n\n    Args:\n        anchor: The `Anchor` to be updated.\n        handle: File-like object containing contents of the anchor's file. If\n            `None`, then this function will open the file and read it.\n\n    Returns: A new `Anchor`, possibly identical to the input.\n\n    Raises:\n        ValueError: No alignments could be found between old anchor and new\n            text.\n        AlignmentError: If no anchor could be created. The message of the\n            exception will say what the problem is.\n\n    \"\"\"\n    if handle is None:\n        with anchor.file_path.open(mode='rt') as fp:\n            source_text = fp.read()\n    else:\n        source_text = handle.read()\n        handle.seek(0)\n\n    ctxt = anchor.context\n\n    a_score, alignments = align(ctxt.full_text,\n                                source_text,\n                                score,\n                                gap_penalty)\n    # max_score = len(ctxt.full_text) * 3\n\n    try:\n        alignment = next(alignments)\n    except StopIteration:\n        raise AlignmentError('No alignments for anchor: {}'.format(anchor))\n\n    anchor_offset = ctxt.offset - len(ctxt.before)\n\n    source_indices = tuple(\n        s_idx\n        for (a_idx, s_idx) in alignment\n        if a_idx is not None\n        if s_idx is not None\n        if _index_in_topic(a_idx + anchor_offset, anchor))\n\n    if not source_indices:\n        raise AlignmentError(\n            \"Best alignment does not map topic to updated source.\")\n\n    return make_anchor(\n        file_path=anchor.file_path,\n        offset=source_indices[0],\n        width=len(source_indices),\n        context_width=anchor.context.width,\n        metadata=anchor.metadata,\n        handle=handle)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_callargs(self, *args, **kwargs):\n        callargs = getcallargs(self.func, *args, **kwargs)\n        return callargs", "response": "Retrieve all arguments that self. func needs and\n        return a dictionary with call arguments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search_by(url=None, file=None):\n\n    image_url = url\n    # image_file = file\n\n    \"\"\"\n    Search result page\n    \"\"\"\n\n    result_url = GOOGLE_SEARCH_BY_ENDPOINT + image_url\n\n    referer = 'http://www.google.com/imghp'\n    result_html = fire_request(result_url, referer)\n\n    result = SBIResult()\n    result.result_page = result_url\n    result.best_guess = extract_best_guess(result_html)\n\n    soup = cook_soup(result_html)\n\n    all_sizes_a_tag = soup.find('a', text='All sizes')\n\n    # No other sizes of this image found\n    if not all_sizes_a_tag:\n        return result\n\n    all_sizes_href = all_sizes_a_tag['href']\n    all_sizes_url = urlparse.urljoin(GOOGLE_BASE_URL, all_sizes_href)\n\n    result.all_sizes_page = all_sizes_url\n\n    \"\"\"\n    All sizes page\n    \"\"\"\n\n    all_sizes_html = fire_request(all_sizes_url, referer=all_sizes_url)\n\n    soup = cook_soup(all_sizes_html)\n\n    img_links =  soup.find_all('a', {'class': 'rg_l'})\n    images = []\n    for a in img_links:\n        url = a['href']\n        parse_result = urlparse.urlparse(url)\n\n        querystring = parse_result.query\n        querystring_dict = urlparse.parse_qs(querystring)\n\n        image = {}\n        image['url'] = querystring_dict['imgurl'][0]\n        image['width'] = int(querystring_dict['w'][0])\n        image['height'] = int(querystring_dict['h'][0])\n\n        images.append(image)\n\n    result.images = images\n\n    return result", "response": "Search by url or file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexports all attributes of the user to a dict.", "response": "def export(self):\n        \"\"\"Export all attributes of the user to a dict.\n\n        :return: attributes of the user.\n        :rtype: dict.\n        \"\"\"\n        data = {}\n        data[\"name\"] = self.name\n        data[\"contributions\"] = self.contributions\n        data[\"avatar\"] = self.avatar\n        data[\"followers\"] = self.followers\n        data[\"join\"] = self.join\n        data[\"organizations\"] = self.organizations\n        data[\"repositories\"] = self.numberOfRepos\n        data[\"bio\"] = self.bio\n        data[\"private\"] = self.private\n        data[\"public\"] = self.public\n        data[\"location\"] = self.location\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __getContributions(self, web):\n        contributions_raw = web.find_all('h2',\n                                         {'class': 'f4 text-normal mb-2'})\n        try:\n            contrText = contributions_raw[0].text\n            contrText = contrText.lstrip().split(\" \")[0]\n            contrText = contrText.replace(\",\", \"\")\n        except IndexError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)\n        except AttributeError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)\n\n        self.contributions = int(contrText)", "response": "Scrap the contributions from a GitHub profile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscrapping the avatar from a GitHub profile.", "response": "def __getAvatar(self, web):\n        \"\"\"Scrap the avatar from a GitHub profile.\n\n        :param web: parsed web.\n        :type web: BeautifulSoup node.\n        \"\"\"\n        try:\n            self.avatar = web.find(\"img\", {\"class\": \"avatar\"})['src'][:-10]\n        except IndexError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)\n        except AttributeError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nscrap the number of repositories from a GitHub profile.", "response": "def __getNumberOfRepositories(self, web):\n        \"\"\"Scrap the number of repositories from a GitHub profile.\n\n        :param web: parsed web.\n        :type web: BeautifulSoup node.\n        \"\"\"\n        counters = web.find_all('span', {'class': 'Counter'})\n        try:\n            if 'k' not in counters[0].text:\n                self.numberOfRepos = int(counters[0].text)\n            else:\n                reposText = counters[0].text.replace(\" \", \"\")\n                reposText = reposText.replace(\"\\n\", \"\").replace(\"k\", \"\")\n\n                if reposText and len(reposText) > 1:\n                    self.numberOfRepos = int(reposText.split(\".\")[0]) * \\\n                        1000 + int(reposText.split(\".\")[1]) * 100\n                elif reposText:\n                    self.numberOfRepos = int(reposText.split(\".\")[0]) * 1000\n        except IndexError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)\n        except AttributeError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nscrapping the number of followers from a GitHub profile.", "response": "def __getNumberOfFollowers(self, web):\n        \"\"\"Scrap the number of followers from a GitHub profile.\n\n        :param web: parsed web.\n        :type web: BeautifulSoup node.\n        \"\"\"\n        counters = web.find_all('span', {'class': 'Counter'})\n        try:\n            if 'k' not in counters[2].text:\n                self.followers = int(counters[2].text)\n            else:\n                follText = counters[2].text.replace(\" \", \"\")\n                follText = follText.replace(\"\\n\", \"\").replace(\"k\", \"\")\n\n                if follText and len(follText) > 1:\n                    self.followers = int(follText.split(\".\")[0])*1000 + \\\n                        int(follText.split(\".\")[1]) * 100\n                elif follText:\n                    self.followers = int(follText.split(\".\")[0])*1000\n        except IndexError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)\n        except AttributeError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __getLocation(self, web):\n        try:\n            self.location = web.find(\"span\", {\"class\": \"p-label\"}).text\n        except AttributeError as error:\n            print(\"There was an error with the user \" + self.name)\n            print(error)", "response": "Scrap the location from a GitHub profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __getJoin(self, web):\n        join = web.findAll(\"a\", {\"class\": \"dropdown-item\"})\n        for j in join:\n            try:\n                if \"Joined GitHub\" in j.text:\n                    self.join = j[\"href\"][-10:]\n            except IndexError as error:\n                print(\"There was an error with the user \" + self.name)\n                print(error)\n            except AttributeError as error:\n                print(\"There was an error with the user \" + self.name)\n                print(error)", "response": "Scrap the join date from a GitHub profile."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __getBio(self, web):\n        bio = web.find_all(\"div\", {\"class\": \"user-profile-bio\"})\n\n        if bio:\n            try:\n                bio = bio[0].text\n                if bio and GitHubUser.isASCII(bio):\n                    bioText = bio.replace(\"\\n\", \"\")\n                    bioText = bioText.replace(\"\\t\", \" \").replace(\"\\\"\", \"\")\n                    bioText = bioText.replace(\"\\'\", \"\").replace(\"\\\\\", \"\")\n                    self.bio = bioText\n                else:\n                    self.bio = \"\"\n            except IndexError as error:\n                print(\"There was an error with the user \" + self.name)\n                print(error)\n            except AttributeError as error:\n                print(\"There was an error with the user \" + self.name)\n                print(error)", "response": "Scrap the bio from a GitHub profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nscraps the number of organizations from a GitHub profile.", "response": "def __getOrganizations(self, web):\n        \"\"\"Scrap the number of organizations from a GitHub profile.\n\n        :param web: parsed web.\n        :type web: BeautifulSoup node.\n        \"\"\"\n        orgsElements = web.find_all(\"a\", {\"class\": \"avatar-group-item\"})\n        self.organizations = len(orgsElements)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget data of the GitHub user.", "response": "def getData(self):\n        \"\"\"Get data of the GitHub user.\"\"\"\n        url = self.server + self.name\n        data = GitHubUser.__getDataFromURL(url)\n        web = BeautifulSoup(data, \"lxml\")\n        self.__getContributions(web)\n        self.__getLocation(web)\n        self.__getAvatar(web)\n        self.__getNumberOfRepositories(web)\n        self.__getNumberOfFollowers(web)\n        self.__getBio(web)\n        self.__getJoin(web)\n        self.__getOrganizations(web)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getRealContributions(self):\n        datefrom = datetime.now() - relativedelta(days=366)\n        dateto = datefrom + relativedelta(months=1) - relativedelta(days=1)\n        private = 0\n\n        while datefrom < datetime.now():\n            fromstr = datefrom.strftime(\"%Y-%m-%d\")\n            tostr = dateto.strftime(\"%Y-%m-%d\")\n            url = self.server + self.name\n            url += \"?tab=overview&from=\" + fromstr + \"&to=\" + tostr\n\n            data = GitHubUser.__getDataFromURL(url)\n            web = BeautifulSoup(data, \"lxml\")\n\n            aux = \"f4 lh-condensed m-0 text-gray\"\n            pcontribs = web.find_all(\"span\", {\"class\": aux})\n\n            aux = web.find_all('span', {'class': 'text-gray m-0'})\n\n            noContribs = False\n\n            for compr in aux:\n                if \"had no activity during this period.\" in compr.text:\n                    noContribs = True\n\n            try:\n                if not noContribs:\n                    for contrib in pcontribs:\n                        contribution = None\n                        contribution = contrib.text\n                        contribution = contribution.lstrip().replace(\",\", \"\")\n                        contribution = contribution.replace(\"\\n\", \" \")\n                        contribution = contribution.partition(\" \")[0]\n                        private += int(contribution)\n            except IndexError as error:\n                print(\"There was an error with the user \" + self.name)\n                print(error)\n            except AttributeError as error:\n                print(\"There was an error with the user \" + self.name)\n                print(error)\n\n            datefrom += relativedelta(months=1)\n            dateto += relativedelta(months=1)\n\n        self.private = private\n        self.public = self.contributions - private\n\n        if self.public < 0:  # Is not exact\n            self.public = 0", "response": "Get the real number of contributions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __getDataFromURL(url):\n        code = 0\n\n        while code != 200:\n            req = Request(url)\n            try:\n                response = urlopen(req)\n                code = response.code\n                sleep(0.01)\n            except HTTPError as error:\n                code = error.code\n                if code == 404:\n                    break\n            except URLError as error:\n                sleep(3)\n\n        if code == 404:\n            raise Exception(\"User was not found\")\n        return response.read().decode('utf-8')", "response": "Read HTML data from an URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean(self, settings):\n        return {k: v for k, v in settings.items() if k in DEFAULT_SETTINGS}", "response": "Filter given settings to keep only key names available in\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets every given settings as object attributes.", "response": "def set_settings(self, settings):\n        \"\"\"\n        Set every given settings as object attributes.\n\n        Args:\n            settings (dict): Dictionnary of settings.\n\n        \"\"\"\n        for k, v in settings.items():\n            setattr(self, k, v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, settings):\n        settings = self.clean(settings)\n\n        # Update internal dict\n        self._settings.update(settings)\n\n        # Push every setting items as class object attributes\n        self.set_settings(settings)\n\n        return self._settings", "response": "Update internal dict with given settings"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_with_retrieved(self, retrieved):\n        from aiida.common.exceptions import InvalidOperation\n        import os\n\n        output_path = None\n        error_path = None\n        try:\n            output_path, error_path = self._fetch_output_files(retrieved)\n        except InvalidOperation:\n            raise\n        except IOError as e:\n            self.logger.error(e.message)\n            return False, ()\n\n        if output_path is None and error_path is None:\n            self.logger.error(\"No output files found\")\n            return False, ()\n\n        return True, self._get_output_nodes(output_path, error_path)", "response": "Parses the input dictionary of retrieved nodes and returns a tuple of a boolean indicating whether the parsing was successful and the list of nodes that were successfully parsed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fetch_output_files(self, retrieved):\n        from aiida.common.datastructures import calc_states\n        from aiida.common.exceptions import InvalidOperation\n        import os\n\n        # check in order not to overwrite anything\n        #         state = self._calc.get_state()\n        #         if state != calc_states.PARSING:\n        #             raise InvalidOperation(\"Calculation not in {} state\"\n        #                                    .format(calc_states.PARSING) )\n\n        # Check that the retrieved folder is there\n        try:\n            out_folder = retrieved[self._calc._get_linkname_retrieved()]\n        except KeyError:\n            raise IOError(\"No retrieved folder found\")\n\n        list_of_files = out_folder.get_folder_list()\n\n        output_path = None\n        error_path = None\n\n        if self._calc._DEFAULT_OUTPUT_FILE in list_of_files:\n            output_path = os.path.join(out_folder.get_abs_path('.'),\n                                       self._calc._DEFAULT_OUTPUT_FILE)\n        if self._calc._DEFAULT_ERROR_FILE in list_of_files:\n            error_path = os.path.join(out_folder.get_abs_path('.'),\n                                      self._calc._DEFAULT_ERROR_FILE)\n\n        return output_path, error_path", "response": "Checks the output folder for standard output and standard error files returns their absolute paths on success."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reset(self):\n\n        self.config = None\n        self.html = None\n        self.parsed_tree = None\n        self.tidied = False\n        self.next_page_link = None\n        self.title = None\n        self.author = set()\n        self.language = None\n        self.date = None\n        self.body = None\n        self.failures = set()\n        self.success = False\n\n        LOGGER.debug(u'Reset extractor instance to defaults/empty.')", "response": "Reset all instance attributes to default."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _process_replacements(self, html):\n\n        if self.config.find_string:\n            for find_pattern, replace_pattern in self.config.replace_patterns:\n                html = html.replace(find_pattern, replace_pattern)\n\n            LOGGER.info(u'Done replacements.',\n                        extra={'siteconfig': self.config.host})\n\n        return html", "response": "Do raw string replacements on html."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _tidy(self, html, smart_tidy):\n\n        if self.config.tidy and tidylib and smart_tidy:\n\n            try:\n                document, errors = tidylib.tidy_document(html, self.tidy_config)\n\n            except UnicodeDecodeError:\n                # For some reason, pytidylib fails to decode, whereas the\n                # original html content converts perfectly manually.\n                document, errors = tidylib.tidy_document(html.encode('utf-8'),\n                                                         self.tidy_config)\n                document = document.decode('utf-8')\n            # if errors:\n            #     LOGGER.debug(u'Ignored errors returned by tidylib: %s',\n            #                  errors)\n\n            self.tidied = True\n            self.html = document\n\n            LOGGER.info(u'Tidied document.')\n\n        else:\n            self.html = html", "response": "Tidy HTML if we have a tidy method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the parser and parse self. html.", "response": "def _parse_html(self):\n        \"\"\" Load the parser and parse `self.html`. \"\"\"\n\n        if self.config.parser != 'lxml':\n            raise NotImplementedError('%s parser not implemented' %\n                                      self.config.parser)\n\n        self.parser = etree.HTMLParser()\n\n        try:\n            self.parsed_tree = etree.parse(StringIO(self.html), self.parser)\n\n        except ValueError, e:\n            if u'Unicode strings with encoding declaration are not supported' \\\n                    in unicode(e):\n\n                # For some reason, the HTML/XML declares another encoding\n                # in its meta tags. TODO: we should probably remove this\n                # meta tag, because the sparks detection mechanism usually\n                # does a pretty good job at finding it.\n                #\n                # For now, this will fail for anything other than utf-8 and\n                # make the program crash.\n                self.parsed_tree = etree.parse(StringIO(\n                    self.html.encode('utf-8')), self.parser)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _extract_next_page_link(self):\n\n        # HEADS UP: we do not abort if next_page_link is already set:\n        #           we try to find next (eg. find 3 if already at page 2).\n\n        for pattern in self.config.next_page_link:\n            items = self.parsed_tree.xpath(pattern)\n\n            if not items:\n                continue\n\n            if len(items) == 1:\n                item = items[0]\n\n                if 'href' in item.keys():\n                    self.next_page_link = item.get('href')\n\n                else:\n                    self.next_page_link = item.text.strip()\n\n                LOGGER.info(u'Found next page link: %s.',\n                            self.next_page_link)\n\n                # First found link is the good one.\n                break\n\n            else:\n                LOGGER.warning(u'%s items for next-page link %s',\n                               items, pattern,\n                               extra={'siteconfig': self.config.host})", "response": "Try to find next page link."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _extract_title(self):\n\n        if self.title:\n            return\n\n        for pattern in self.config.title:\n            items = self.parsed_tree.xpath(pattern)\n\n            if not items:\n                continue\n\n            if isinstance(items, basestring):\n                # In case xpath returns only one element.\n                items = [items]\n\n            if len(items) == 1:\n                item = items[0]\n\n                try:\n                    self.title = item.text.strip()\n\n                except AttributeError:\n                    # '_ElementStringResult' object has no attribute 'text'\n                    self.title = unicode(item).strip()\n\n                LOGGER.info(u'Title extracted: \u201c%s\u201d.', self.title,\n                            extra={'siteconfig': self.config.host})\n\n                try:\n                    item.getparent().remove(item)\n\n                except TypeError:\n                    # Argument 'element' has incorrect type (expected\n                    # lxml.etree._Element, got _ElementStringResult)\n                    pass\n\n                except AttributeError, e:\n                    if u'NoneType' not in unicode(e):\n                        LOGGER.exception(u'Could not remove title from '\n                                         u'document.',\n                                         extra={'siteconfig': self.config.host})\n                    # implicit: else: this is begnin\n\n                except:\n                    LOGGER.exception(u'Could not remove title from document.',\n                                     extra={'siteconfig': self.config.host})\n\n                # Exit at first item found.\n                break\n\n            else:\n                LOGGER.warning(u'Multiple items (%s) for title pattern %s.',\n                               items, pattern,\n                               extra={'siteconfig': self.config.host})", "response": "Extract the title and remove it from the document."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts author from xml file.", "response": "def _extract_author(self):\n        \"\"\" Extract author(s) if not already done. \"\"\"\n\n        if bool(self.author):\n            return\n\n        for pattern in self.config.author:\n\n            items = self.parsed_tree.xpath(pattern)\n\n            if isinstance(items, basestring):\n                # In case xpath returns only one element.\n                items = [items]\n\n            for item in items:\n\n                if isinstance(item, basestring):\n                    # '_ElementStringResult' object has no attribute 'text'\n                    stripped_author = unicode(item).strip()\n\n                else:\n                    try:\n                        stripped_author = item.text.strip()\n\n                    except AttributeError:\n                        # We got a <div>\u2026\n                        stripped_author = etree.tostring(item)\n\n                if stripped_author:\n                    self.author.add(stripped_author)\n                    LOGGER.info(u'Author extracted: %s.', stripped_author,\n                                extra={'siteconfig': self.config.host})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract language from the HTML tags.", "response": "def _extract_language(self):\n        \"\"\" Extract language from the HTML ``<head>`` tags. \"\"\"\n\n        if self.language:\n            return\n\n        found = False\n\n        for pattern in self.config.language:\n            for item in self.parsed_tree.xpath(pattern):\n                stripped_language = item.strip()\n\n                if stripped_language:\n                    self.language = stripped_language\n                    LOGGER.info(u'Language extracted: %s.', stripped_language,\n                                extra={'siteconfig': self.config.host})\n                    found = True\n                    break\n\n            if found:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts date from HTML.", "response": "def _extract_date(self):\n        \"\"\" Extract date from HTML. \"\"\"\n\n        if self.date:\n            return\n\n        found = False\n\n        for pattern in self.config.date:\n\n            items = self.parsed_tree.xpath(pattern)\n\n            if isinstance(items, basestring):\n                # In case xpath returns only one element.\n                items = [items]\n\n            for item in items:\n                if isinstance(item, basestring):\n                    # '_ElementStringResult' object has no attribute 'text'\n                    stripped_date = unicode(item).strip()\n\n                else:\n                    try:\n                        stripped_date = item.text.strip()\n\n                    except AttributeError:\n                        # .text is None. We got a <div> item with span-only\n                        # content. The result will probably be completely\n                        # useless to a python developer, but at least we\n                        # didn't fail handling the siteconfig directive.\n                        stripped_date = etree.tostring(item)\n\n                if stripped_date:\n                    # self.date = strtotime(trim(elems, \"; \\t\\n\\r\\0\\x0B\"))\n                    self.date = stripped_date\n                    LOGGER.info(u'Date extracted: %s.', stripped_date,\n                                extra={'siteconfig': self.config.host})\n                    found = True\n                    break\n\n            if found:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _extract_body(self):\n\n        def is_descendant_node(parent, node):\n            node = node.getparent()\n            while node is not None:\n                if node == parent:\n                    return True\n                node = node.getparent()\n            return False\n\n        for pattern in self.config.body:\n            items = self.parsed_tree.xpath(pattern)\n\n            if len(items) == 1:\n                if self.config.prune:\n                    self.body = Document(etree.tostring(items[0])).summary()\n\n                else:\n                    self.body = etree.tostring(items[0])\n\n                # We've got a body now.\n                break\n\n            else:\n                appended_something = False\n                body = etree.Element(\"root\")\n\n                for item in items:\n                    if item.getparent() is None:\n                        continue\n\n                    is_descendant = False\n\n                    for parent in body:\n                        if (is_descendant_node(parent, item)):\n                            is_descendant = True\n                            break\n\n                    if not is_descendant:\n\n                        if self.config.prune:\n\n                            # Clean with readability. Needs\n                            # to-string conversion first.\n                            pruned_string = Document(\n                                etree.tostring(item)).summary()\n\n                            # Re-parse the readability string\n                            # output and include it in our body.\n                            new_tree = etree.parse(\n                                StringIO(pruned_string), self.parser)\n\n                            failed = False\n\n                            try:\n                                body.append(\n                                    new_tree.xpath('//html/body/div/div')[0]\n                                )\n                            except IndexError:\n\n                                if 'id=\"readabilityBody\"' in pruned_string:\n                                    try:\n                                        body.append(\n                                            new_tree.xpath('//body')\n                                        )\n                                    except:\n                                        failed = True\n\n                                else:\n                                    failed = True\n\n                            if failed:\n                                LOGGER.error(u'Pruning item failed:'\n                                             u'\\n\\n%s\\n\\nWe got: \u201c%s\u201d '\n                                             u'and skipped it.',\n                                             etree.tostring(\n                                                 item).replace(u'\\n', u''),\n                                             pruned_string.replace(u'\\n', u''),\n                                             extra={'siteconfig':\n                                                    self.config.host})\n                                pass\n\n                        else:\n                            body.append(item)\n\n                        appended_something = True\n\n                if appended_something:\n                    self.body = etree.tostring(body)\n\n                    # We've got a body now.\n                    break", "response": "Extract the body content from the HTML."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _auto_extract_if_failed(self):\n\n        if not self.config.autodetect_on_failure:\n            return\n\n        readabilitized = Document(self.html)\n\n        if self.title is None:\n            if bool(self.config.title):\n                self.failures.add('title')\n\n            title = readabilitized.title().strip()\n\n            if title:\n                self.title = title\n                LOGGER.info(u'Title extracted in automatic mode.',\n                            extra={'siteconfig': self.config.host})\n\n            else:\n                self.failures.add('title')\n\n        if self.body is None:\n            if bool(self.config.body):\n                self.failures.add('body')\n\n            body = readabilitized.summary().strip()\n\n            if body:\n                self.body = body\n                LOGGER.info(u'Body extracted in automatic mode.',\n                            extra={'siteconfig': self.config.host})\n\n            else:\n                self.failures.add('body')\n\n        for attr_name in ('date', 'language', 'author', ):\n            if not bool(getattr(self, attr_name, None)):\n                if bool(getattr(self.config, attr_name, None)):\n                    self.failures.add(attr_name)\n                    LOGGER.warning(u'Could not extract any %s from XPath '\n                                   u'expression(s) %s.', attr_name,\n                                   u', '.join(getattr(self.config, attr_name)),\n                                   extra={'siteconfig': self.config.host})", "response": "Try to automatically extract the content of the XML file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses HTML content or URL.", "response": "def process(self, html, url=None, smart_tidy=True):\n        u\"\"\" Process HTML content or URL.\n\n        For automatic extraction patterns and cleanups, :mod:`readability-lxml`\n        is used, to stick as much as possible to the original PHP\n        implementation and produce at least similar results with the same\n        site config on the same article/content.\n\n        :param html: an unicode string containing a full HTML page content.\n            Expected to have a ``DOCTYPE`` and all other standard\n            attributes\u00a0; eg. HTML fragments are not supported.\n            It will be replaced, tidied, cleaned, striped, and all\n            metadata and body attributes will be extracted from it.\n            Beware\u00a0: this HTML piece will be mauled. See source code for\n            exact processing workflow, it's quite gorgeous.\n        :type html: unicode\n\n        :param url: as of version 0.5, this parameter is ignored. (**TODO**)\n        :type url: str, unicode or ``None``\n\n        :param smart_tidy: When ``True`` (default), runs :mod:`pytidylib`\n            to tidy the HTML, after after run ``find_string``/``replace_string``\n            replacements and before running extractions.\n        :type smart_tidy: bool\n\n        :returns: ``True`` on success, ``False`` on failure.\n        :raises:\n            - :class:`RuntimeError` if config has not been set at\n              instantiation. This should change in the future by looking\n              up a config if an ``url`` is passed as argument.\n\n        .. note:: If tidy is used and no result is produced, we will try\n            again without tidying.\n            Generally speaking, tidy helps us deal with PHP's patchy HTML\n            parsing (LOOOOOL. Zeriously?) most of the time but it has\n            problems of its own which we try to avoid with this option.\n            In the Python implementation, `pytidylib` has showed to help\n            sanitize a lot the HTML before processing it. But nobody's\n            perfect, and errors can happen in the Python world too, thus\n            the *tidy* behavior was thought sane enough to be keep.\n        \"\"\"\n\n        # TODO: re-implement URL handling with self.reset() here.\n\n        if self.config is None:\n            raise RuntimeError(u'extractor site config is not set.')\n\n        # TODO: If re-running ourselves over an already-replaced string,\n        #       this should just do nothing because everything has been\n        #       done. We should have a test for that.\n        html = self._process_replacements(html)\n\n        # We keep the html untouched after replacements.\n        # All processing happens on self.html after this point.\n        self._tidy(html, smart_tidy)\n\n        # return\n\n        self._parse_html()\n\n        self._extract_next_page_link()\n\n        self._extract_title()\n\n        self._extract_author()\n\n        self._extract_language()\n\n        self._extract_date()\n\n        self._strip_unwanted_elements()\n\n        self._extract_body()\n\n        # TODO: re-implement auto-detection here.\n        # NOTE: hNews extractor was here.\n        # NOTE: instapaper extractor was here.\n\n        self._auto_extract_if_failed()\n\n        if self.title is not None or self.body is not None \\\n            or bool(self.author) or self.date is not None \\\n                or self.language is not None:\n            self.success = True\n\n        # if we've had no success and we've used tidy, there's a chance\n        # that tidy has messed up. So let's try again without tidy...\n        if not self.success and self.tidied and smart_tidy:\n            self.process(html, url=None, smart_tidy=False)\n\n        return self.success"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef staticflatpage(request, path):\n    # Don't render a base.html template.\n    if path.replace(\"/\", '').lower() == \"base\":\n        raise Http404\n\n    if not path.startswith('/'):\n        path = \"/{0}\".format(path)\n    if path.endswith('/'):\n        path = path[:-1]\n\n    # Support for index.html templates.\n    if path == '':\n        path = \"/index\"\n\n    # paths should be in the format: staticflatpages/path/from/url.html\n    path = \"staticflatpages{0}.html\".format(path)\n    try:\n        return render(request, path)\n    except TemplateDoesNotExist:\n        raise Http404", "response": "Load a staticflatpage template corresponding to the path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of DatalakeRecords for the specified url", "response": "def list_from_url(cls, url):\n        '''return a list of DatalakeRecords for the specified url'''\n        key = cls._get_key(url)\n        metadata = cls._get_metadata_from_key(key)\n        ct = cls._get_create_time(key)\n        time_buckets = cls.get_time_buckets_from_metadata(metadata)\n        return [cls(url, metadata, t, ct, key.size) for t in time_buckets]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_from_metadata(cls, url, metadata):\n        '''return a list of DatalakeRecords for the url and metadata'''\n        key = cls._get_key(url)\n        metadata = Metadata(**metadata)\n        ct = cls._get_create_time(key)\n        time_buckets = cls.get_time_buckets_from_metadata(metadata)\n        return [cls(url, metadata, t, ct, key.size) for t in time_buckets]", "response": "return a list of DatalakeRecords for the url and metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_time_buckets_from_metadata(metadata):\n        '''return a list of time buckets in which the metadata falls'''\n        start = metadata['start']\n        end = metadata.get('end') or start\n        buckets = DatalakeRecord.get_time_buckets(start, end)\n        if len(buckets) > DatalakeRecord.MAXIMUM_BUCKET_SPAN:\n            msg = 'metadata spans too many time buckets: {}'\n            j = json.dumps(metadata)\n            msg = msg.format(j)\n            raise UnsupportedTimeRange(msg)\n        return buckets", "response": "return a list of time buckets in which the metadata falls"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the time buckets spanned by the start and end times", "response": "def get_time_buckets(start, end):\n        '''get the time buckets spanned by the start and end times'''\n        d = DatalakeRecord.TIME_BUCKET_SIZE_IN_MS\n        first_bucket = start / d\n        last_bucket = end / d\n        return list(range(\n            int(first_bucket),\n            int(last_bucket) + 1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_pdb(residues, chain_id=' ', alt_states=False, strip_states=False):\n    pdb_atom_col_dict = PDB_ATOM_COLUMNS\n    out_pdb = []\n    if len(str(chain_id)) > 1:\n        poly_id = ' '\n    else:\n        poly_id = str(chain_id)\n    for monomer in residues:\n        if (len(monomer.states) > 1) and alt_states and not strip_states:\n            atom_list = itertools.chain(\n                *[x[1].items() for x in sorted(monomer.states.items())])\n        else:\n            atom_list = monomer.atoms.items()\n        if 'chain_id' in monomer.tags:\n            poly_id = monomer.tags['chain_id']\n        for atom_t, atom in atom_list:\n            if strip_states:\n                state_label = ' '\n            elif (atom.tags['state'] == 'A') and (len(monomer.states) == 1):\n                state_label = ' '\n            else:\n                state_label = atom.tags['state']\n            atom_data = {\n                'atom_number': '{:>5}'.format(cap(atom.id, 5)),\n                'atom_name': '{:<4}'.format(cap(pdb_atom_col_dict[atom_t], 4)),\n                'alt_loc_ind': '{:<1}'.format(cap(state_label, 1)),\n                'residue_type': '{:<3}'.format(cap(monomer.mol_code, 3)),\n                'chain_id': '{:<1}'.format(cap(poly_id, 1)),\n                'res_num': '{:>4}'.format(cap(monomer.id, 4)),\n                'icode': '{:<1}'.format(cap(monomer.insertion_code, 1)),\n                'coord_str': '{0:>8.3f}{1:>8.3f}{2:>8.3f}'.format(\n                    *[x for x in atom]),\n                'occupancy': '{:>6.2f}'.format(atom.tags['occupancy']),\n                'temp_factor': '{:>6.2f}'.format(atom.tags['bfactor']),\n                'element': '{:>2}'.format(cap(atom.element, 2)),\n                'charge': '{:<2}'.format(cap(atom.tags['charge'], 2))\n            }\n            if monomer.is_hetero:\n                pdb_line_template = (\n                    'HETATM{atom_number} {atom_name}{alt_loc_ind}{residue_type}'\n                    ' {chain_id}{res_num}{icode}   {coord_str}{occupancy}'\n                    '{temp_factor}          {element}{charge}\\n'\n                )\n            else:\n                pdb_line_template = (\n                    'ATOM  {atom_number} {atom_name}{alt_loc_ind}{residue_type}'\n                    ' {chain_id}{res_num}{icode}   {coord_str}{occupancy}'\n                    '{temp_factor}          {element}{charge}\\n'\n                )\n            out_pdb.append(pdb_line_template.format(**atom_data))\n    return ''.join(out_pdb)", "response": "Writes a pdb file for a list of Residue objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the centre of mass of AMPAL object.", "response": "def centre_of_mass(self):\n        \"\"\"Returns the centre of mass of AMPAL object.\n\n        Notes\n        -----\n        All atoms are included in calculation, call `centre_of_mass`\n        manually if another selection is require.\n\n        Returns\n        -------\n        centre_of_mass : numpy.array\n            3D coordinate for the centre of mass.\n        \"\"\"\n        elts = set([x.element for x in self.get_atoms()])\n        masses_dict = {e: ELEMENT_DATA[e]['atomic mass'] for e in elts}\n        points = [x._vector for x in self.get_atoms()]\n        masses = [masses_dict[x.element] for x in self.get_atoms()]\n        return centre_of_mass(points=points, masses=masses)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn all atoms in the Monomer.", "response": "def get_atoms(self, inc_alt_states=False):\n        \"\"\"Returns all atoms in the `Monomer`.\n\n        Parameters\n        ----------\n        inc_alt_states : bool, optional\n            If `True`, will return `Atoms` for alternate states.\n        \"\"\"\n        if inc_alt_states:\n            return itertools.chain(*[x[1].values() for x in sorted(list(self.states.items()))])\n        return self.atoms.values()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_pdb(self):\n        pdb_str = write_pdb(\n            [self], ' ' if not self.parent else self.parent.id)\n        return pdb_str", "response": "Generates a PDB string for the Monomer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close_monomers(self, group, cutoff=4.0):\n        nearby_residues = []\n        for self_atom in self.atoms.values():\n            nearby_atoms = group.is_within(cutoff, self_atom)\n            for res_atom in nearby_atoms:\n                if res_atom.parent not in nearby_residues:\n                    nearby_residues.append(res_atom.parent)\n        return nearby_residues", "response": "Returns a list of Monomers from within a cut off distance of the Monomer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unique_id(self):\n        chain = self.parent.parent.id\n        residue = self.parent.id\n        return chain, residue, self.id", "response": "Creates a unique ID for the Atom based on its parents."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef translate(self, vector):\n        vector = numpy.array(vector)\n        self._vector += numpy.array(vector)\n        return", "response": "Translates `Atom`.\n\n        Parameters\n        ----------\n        vector : 3D Vector (tuple, list, numpy.array)\n            Vector used for translation.\n        inc_alt_states : bool, optional\n            If true, will rotate atoms in all states i.e. includes\n            alternate conformations for sidechains."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommanding line interface. :param list args: command line options (defaults to sys.argv) :returns: exit code :rtype: int", "response": "def main(args=None):\n    \"\"\"Command line interface.\n\n    :param list args: command line options (defaults to sys.argv)\n    :returns: exit code\n    :rtype: int\n\n    \"\"\"\n    parser = ArgumentParser(\n        prog='baseline',\n        description=DESCRIPTION)\n\n    parser.add_argument(\n        'path', nargs='*',\n        help='module or directory path')\n\n    parser.add_argument(\n        '--movepath', help='location to move script updates')\n\n    parser.add_argument(\n        '-w', '--walk', action='store_true',\n        help='recursively walk directories')\n\n    args = parser.parse_args(args)\n\n    paths = args.path or ['.']\n\n    paths = [path for pattern in paths for path in glob(pattern)]\n\n    if args.walk:\n        for dirpath in (p for p in paths if os.path.isdir(p)):\n            for root, _dirs, files in os.walk(dirpath):\n                paths += (os.path.join(root, filename) for filename in files)\n    else:\n        for dirpath in (p for p in paths if os.path.isdir(p)):\n            paths += (os.path.join(dirpath, pth) for pth in os.listdir(dirpath))\n\n    update_paths = [\n        os.path.relpath(p) for p in paths if p.lower().endswith(UPDATE_EXT)]\n\n    exitcode = 0\n\n    if update_paths:\n        script_paths = [pth[:-len(UPDATE_EXT)] + '.py' for pth in update_paths]\n\n        print('Found updates for:')\n        for path in script_paths:\n            print('  ' + path)\n        print()\n\n        if not args.movepath:\n            try:\n                input('Hit [ENTER] to update, [Ctrl-C] to cancel ')\n            except KeyboardInterrupt:\n                print()\n                print('Update canceled.')\n                exitcode = 1\n            else:\n                print()\n\n        if exitcode == 0:\n            for script_path, update_path in zip(script_paths, update_paths):\n                if args.movepath:\n                    script_path = os.path.join(args.movepath, script_path)\n                    if update_path.startswith('..'):\n                        raise RuntimeError(\n                            'destination outside of move path: ' + script_path)\n                    script_dirpath = os.path.dirname(script_path)\n                    if not os.path.isdir(script_dirpath):\n                        os.makedirs(script_dirpath)\n                with open(update_path) as update:\n                    new_content = update.read()\n                with open(script_path, 'w') as script:\n                    script.write(new_content)\n                os.remove(update_path)\n                print(update_path + ' -> ' + script_path)\n\n    return exitcode"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recv(self):\n        LOGGER.debug('Receiving')\n        try:\n            message_length = struct.unpack('>i', self._socket.recv(4))[0]\n            message_length -= Connection.COMM_LENGTH\n            LOGGER.debug('Length: %i', message_length)\n        except socket.timeout:\n            return None\n        \n        comm_status = struct.unpack('>i', self._socket.recv(4))[0]\n        LOGGER.debug('Status: %i', comm_status)\n        bytes_received = 0\n        message = b\"\"\n        \n        while bytes_received < message_length:\n            if message_length - bytes_received >= 1024:\n                recv_len = 1024\n            else:\n                recv_len = message_length - bytes_received\n            bytes_received += recv_len\n            LOGGER.debug('Received %i', bytes_received)\n            message += self._socket.recv(recv_len)\n        \n        if comm_status == 0:\n            message = self._crypt.decrypt(message)\n        else:\n            return Message(len(message), Connection.COMM_ERROR, message)\n        \n        msg = Message(message_length, comm_status, message)\n\n        return msg", "response": "Receives a message from PS and decrypts it and returns a Message object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a JavaScript command to PS", "response": "def send(self, content):\n        \"\"\"Sends a JavaScript command to PS\n\n        :param content: Script content\n        :type content: str\n        :yields: :class:`.Message`\n        \"\"\"\n        LOGGER.debug('Sending: %s', content)\n        all_bytes = struct.pack('>i', Connection.PROTOCOL_VERSION)\n        all_bytes += struct.pack('>i', self._id)\n        all_bytes += struct.pack('>i', 2)\n        self._id += 1\n        for char in content:\n            all_bytes += struct.pack('>c', char.encode('utf8'))\n\n        encrypted_bytes = self._crypt.encrypt(all_bytes)\n\n        message_length = Connection.COMM_LENGTH + len(encrypted_bytes)\n\n        self._socket.send(struct.pack('>i', message_length))\n        self._socket.send(struct.pack('>i', Connection.NO_COMM_ERROR))\n        self._socket.send(encrypted_bytes)\n        LOGGER.debug('Sent')\n\n        message = self.recv()\n        while message is None:\n            message = self.recv()\n            yield message\n\n        yield message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef watch_command(context, backend, config, poll):\n    logger = logging.getLogger(\"boussole\")\n    logger.info(\"Watching project\")\n\n    # Discover settings file\n    try:\n        discovering = Discover(backends=[SettingsBackendJson,\n                                         SettingsBackendYaml])\n        config_filepath, config_engine = discovering.search(\n            filepath=config,\n            basedir=os.getcwd(),\n            kind=backend\n        )\n\n        project = ProjectBase(backend_name=config_engine._kind_name)\n        settings = project.backend_engine.load(filepath=config_filepath)\n    except BoussoleBaseException as e:\n        logger.critical(six.text_type(e))\n        raise click.Abort()\n\n    logger.debug(u\"Settings file: {} ({})\".format(\n                 config_filepath, config_engine._kind_name))\n    logger.debug(u\"Project sources directory: {}\".format(\n                settings.SOURCES_PATH))\n    logger.debug(u\"Project destination directory: {}\".format(\n                settings.TARGET_PATH))\n    logger.debug(u\"Exclude patterns: {}\".format(\n                settings.EXCLUDES))\n\n    # Watcher settings\n    watcher_templates_patterns = {\n        'patterns': ['*.scss'],\n        'ignore_patterns': ['*.part'],\n        'ignore_directories': False,\n        'case_sensitive': True,\n    }\n\n    # Init inspector instance shared through all handlers\n    inspector = ScssInspector()\n\n    if not poll:\n        logger.debug(u\"Using Watchdog native platform observer\")\n        observer = Observer()\n    else:\n        logger.debug(u\"Using Watchdog polling observer\")\n        observer = PollingObserver()\n\n    # Init event handlers\n    project_handler = WatchdogProjectEventHandler(settings, inspector,\n                                                  **watcher_templates_patterns)\n\n    lib_handler = WatchdogLibraryEventHandler(settings, inspector,\n                                              **watcher_templates_patterns)\n\n    # Observe source directory\n    observer.schedule(project_handler, settings.SOURCES_PATH, recursive=True)\n\n    # Also observe libraries directories\n    for libpath in settings.LIBRARY_PATHS:\n        observer.schedule(lib_handler, libpath, recursive=True)\n\n    # Start watching\n    logger.warning(u\"Launching the watcher, use CTRL+C to stop it\")\n    observer.start()\n\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        logger.warning(u\"CTRL+C used, stopping..\")\n        observer.stop()\n\n    observer.join()", "response": "Watch for changes on your Sass project sources then compile them to CSS."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes DEBUG and DEBUGALL.", "response": "def init(deb1, deb2=False):\n    \"\"\"Initialize DEBUG and DEBUGALL.\n\n    Allows other modules to set DEBUG and DEBUGALL, so their\n    call to dprint or dprintx generate output.\n\n    Args:\n        deb1 (bool): value of DEBUG to set\n        deb2 (bool): optional - value of DEBUGALL to set,\n                     defaults to False.\n\n    \"\"\"\n    global DEBUG        # pylint: disable=global-statement\n    global DEBUGALL     # pylint: disable=global-statement\n    DEBUG = deb1\n    DEBUGALL = deb2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting Text if DEBUGALL set optionally with PrettyPrint.", "response": "def dprintx(passeditem, special=False):\n    \"\"\"Print Text if DEBUGALL set, optionally with PrettyPrint.\n\n    Args:\n        passeditem (str): item to print\n        special (bool): determines if item prints with PrettyPrint\n                        or regular print.\n\n    \"\"\"\n    if DEBUGALL:\n        if special:\n            from pprint import pprint\n            pprint(passeditem)\n        else:\n            print(\"%s%s%s\" % (C_TI, passeditem, C_NORM))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap for requests. get function to set params.", "response": "def get(url, **kwargs):\n    \"\"\"\n    Wrapper for `request.get` function to set params.\n    \"\"\"\n    headers = kwargs.get('headers', {})\n    headers['User-Agent'] = config.USER_AGENT # overwrite\n    kwargs['headers'] = headers\n\n    timeout = kwargs.get('timeout', config.TIMEOUT)\n    kwargs['timeout'] = timeout\n\n    kwargs['verify'] = False # no SSLError\n\n    logger.debug(\"Getting: %s\", url)\n    return requests.get(url, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms the request via PhantomJS.", "response": "def phantomjs_get(url):\n    \"\"\"\n    Perform the request via PhantomJS.\n    \"\"\"\n    from selenium import webdriver\n    from selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n\n    dcap = dict(DesiredCapabilities.PHANTOMJS)\n    dcap[\"phantomjs.page.settings.userAgent\"] = config.USER_AGENT\n    dcap[\"phantomjs.page.settings.loadImages\"] = False\n    driver = webdriver.PhantomJS(desired_capabilities=dcap, executable_path=config.PHANTOMJS_BIN)\n\n    logger.debug(\"PhantomJS get: %s\", url)\n    driver.get(url)\n    time.sleep(10) # to follow redirects\n\n    response = driver.page_source\n    driver.quit()\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_software_package_compilation_timestamp(cls,calc,**kwargs):\n        from dateutil.parser import parse\n        try:\n            date = calc.out.job_info.get_dict()['compiled']\n            return parse(date.replace('_', ' ')).isoformat()\n        except Exception:\n            return None", "response": "Returns the timestamp of the package compilation in ISO 8601."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_atom_type_symbol(cls,calc,**kwargs):\n        parameters = calc.out.output\n        dictionary = parameters.get_dict()\n        if 'basis_set' not in dictionary.keys():\n            return None\n        return sorted(dictionary['basis_set'].keys())", "response": "Returns a list of atom types. Each atom site MUST occur only\n        once in this list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_atom_type_basisset(cls,calc,**kwargs):\n        parameters = calc.out.output\n        dictionary = parameters.get_dict()\n        if 'basis_set' not in dictionary.keys():\n            return None\n        return [dictionary['basis_set'][x]['description']\n                for x in cls.get_atom_type_symbol(calc,**kwargs)]", "response": "Returns a list of basisset names for each atom type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _print_command(self, cmd):\n        text = helpers.repr_bytes(cmd)\n        self.outf.write(text)\n        if not text.endswith(b'\\n'):\n            self.outf.write(b'\\n')", "response": "Wrapper to avoid adding unnecessary blank lines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _filter_filecommands(self, filecmd_iter):\n        if self.includes is None and self.excludes is None:\n            return list(filecmd_iter())\n\n        # Do the filtering, adjusting for the new_root\n        result = []\n        for fc in filecmd_iter():\n            if (isinstance(fc, commands.FileModifyCommand) or\n                isinstance(fc, commands.FileDeleteCommand)):\n                if self._path_to_be_kept(fc.path):\n                    fc.path = self._adjust_for_new_root(fc.path)\n                else:\n                    continue\n            elif isinstance(fc, commands.FileDeleteAllCommand):\n                pass\n            elif isinstance(fc, commands.FileRenameCommand):\n                fc = self._convert_rename(fc)\n            elif isinstance(fc, commands.FileCopyCommand):\n                fc = self._convert_copy(fc)\n            else:\n                self.warning(\"cannot handle FileCommands of class %s - ignoring\",\n                        fc.__class__)\n                continue\n            if fc is not None:\n                result.append(fc)\n        return result", "response": "Filter the filecommands by includes & excludes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _path_to_be_kept(self, path):\n        if self.excludes and (path in self.excludes\n                or helpers.is_inside_any(self.excludes, path)):\n            return False\n        if self.includes:\n            return (path in self.includes\n                or helpers.is_inside_any(self.includes, path))\n        return True", "response": "Does the given path pass the filtering criteria?"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadjusting a path given the new root directory of the output.", "response": "def _adjust_for_new_root(self, path):\n        \"\"\"Adjust a path given the new root directory of the output.\"\"\"\n        if self.new_root is None:\n            return path\n        elif path.startswith(self.new_root):\n            return path[len(self.new_root):]\n        else:\n            return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_rename(self, fc):\n        old = fc.old_path\n        new = fc.new_path\n        keep_old = self._path_to_be_kept(old)\n        keep_new = self._path_to_be_kept(new)\n        if keep_old and keep_new:\n            fc.old_path = self._adjust_for_new_root(old)\n            fc.new_path = self._adjust_for_new_root(new)\n            return fc\n        elif keep_old:\n            # The file has been renamed to a non-interesting location.\n            # Delete it!\n            old = self._adjust_for_new_root(old)\n            return commands.FileDeleteCommand(old)\n        elif keep_new:\n            # The file has been renamed into an interesting location\n            # We really ought to add it but we don't currently buffer\n            # the contents of all previous files and probably never want\n            # to. Maybe fast-import-info needs to be extended to\n            # remember all renames and a config file can be passed\n            # into here ala fast-import?\n            self.warning(\"cannot turn rename of %s into an add of %s yet\" %\n                (old, new))\n        return None", "response": "Convert a FileRenameCommand into a new FileCommand."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a FileCopyCommand into a new FileCommand.", "response": "def _convert_copy(self, fc):\n        \"\"\"Convert a FileCopyCommand into a new FileCommand.\n\n        :return: None if the copy is being ignored, otherwise a\n          new FileCommand based on the whether the source and destination\n          paths are inside or outside of the interesting locations.\n          \"\"\"\n        src = fc.src_path\n        dest = fc.dest_path\n        keep_src = self._path_to_be_kept(src)\n        keep_dest = self._path_to_be_kept(dest)\n        if keep_src and keep_dest:\n            fc.src_path = self._adjust_for_new_root(src)\n            fc.dest_path = self._adjust_for_new_root(dest)\n            return fc\n        elif keep_src:\n            # The file has been copied to a non-interesting location.\n            # Ignore it!\n            return None\n        elif keep_dest:\n            # The file has been copied into an interesting location\n            # We really ought to add it but we don't currently buffer\n            # the contents of all previous files and probably never want\n            # to. Maybe fast-import-info needs to be extended to\n            # remember all copies and a config file can be passed\n            # into here ala fast-import?\n            self.warning(\"cannot turn copy of %s into an add of %s yet\" %\n                (src, dest))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the latest bundle version.", "response": "def bundle(context, yes, bundle_name):\n    \"\"\"Delete the latest bundle version.\"\"\"\n    bundle_obj = context.obj['store'].bundle(bundle_name)\n    if bundle_obj is None:\n        click.echo(click.style('bundle not found', fg='red'))\n        context.abort()\n    version_obj = bundle_obj.versions[0]\n    if version_obj.included_at:\n        question = f\"remove bundle version from file system and database: {version_obj.full_path}\"\n    else:\n        question = f\"remove bundle version from database: {version_obj.created_at.date()}\"\n    if yes or click.confirm(question):\n        if version_obj.included_at:\n            shutil.rmtree(version_obj.full_path, ignore_errors=True)\n        version_obj.delete()\n        context.obj['store'].commit()\n        click.echo(f\"version deleted: {version_obj.full_path}\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef files(context, yes, tag, bundle, before, notondisk):\n    file_objs = []\n\n    if not tag and not bundle:\n        click.echo(\"I'm afraid I can't let you do that.\")\n        context.abort()\n\n    if bundle:\n        bundle_obj = context.obj['store'].bundle(bundle)\n        if bundle_obj is None:\n            click.echo(click.style('bundle not found', fg='red'))\n            context.abort()\n\n    query = context.obj['store'].files_before(bundle = bundle, tags = tag, before = before)\n\n    if notondisk:\n        file_objs = set(query) - context.obj['store'].files_ondisk(query)\n    else:\n        file_objs = query.all()\n\n    if len(file_objs) > 0 and len(yes) < 2:\n        if not click.confirm(f\"Are you sure you want to delete {len(file_objs)} files?\"):\n            context.abort()\n\n    for file_obj in file_objs:\n        if yes or click.confirm(f\"remove file from disk and database: {file_obj.full_path}\"):\n            file_obj_path = Path(file_obj.full_path)\n            if file_obj.is_included and (file_obj_path.exists() or file_obj_path.is_symlink()):\n                file_obj_path.unlink()\n            file_obj.delete()\n            context.obj['store'].commit()\n            click.echo(f'{file_obj.full_path} deleted')", "response": "Delete files based on tags."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a line from a sam control socket", "response": "def sam_readline(sock, partial = None):\n    \"\"\"read a line from a sam control socket\"\"\"\n    response = b''\n    exception = None\n    while True:\n        try:\n            c = sock.recv(1)\n            if not c:\n                raise EOFError('SAM connection died. Partial response %r %r' % (partial, response))\n            elif c == b'\\n':\n                break\n            else:\n                response += c\n        except (BlockingIOError, pysocket.timeout) as e:\n            if partial is None:\n                raise e\n            else:\n                exception = e\n                break\n\n    if partial is None:\n        # print('<--', response)\n        return response.decode('ascii')\n    else:\n        # print('<--', repr(partial), '+', response, exception)\n        return (partial + response.decode('ascii'), exception)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sam_parse_reply(line):\n    parts = line.split(' ')\n    opts = {k: v for (k, v) in split_kv(parts[2:])}\n    return SAMReply(parts[0], opts)", "response": "parse a reply line into a dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sam_send(sock, line_and_data):\n    if isinstance(line_and_data, tuple):\n        line, data = line_and_data\n    else:\n        line, data = line_and_data, b''\n\n    line = bytes(line, encoding='ascii') + b' \\n'\n    # print('-->', line, data)\n    sock.sendall(line + data)", "response": "Send a line to the SAM controller but don t read it"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a line to the SAM controller returning the parsed response", "response": "def sam_cmd(sock, line, parse=True):\n    \"\"\"Send a line to the SAM controller, returning the parsed response\"\"\"\n    sam_send(sock, line)\n    reply_line = sam_readline(sock)\n    if parse:\n        return sam_parse_reply(reply_line)\n    else:\n        return reply_line"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a table with custom name and fields.", "response": "async def create_table(**data):\n    \"\"\"\n    RPC method for creating table with custom name and fields\n    :return event id\n    \"\"\"\n\n    table = data.get('table')\n\n    try:\n        clickhouse_queries.create_table(table, data)\n        return 'Table was successfully created'\n\n    except ServerException as e:\n        exception_code = int(str(e)[5:8].strip())\n\n        if exception_code == 57:\n            return 'Table already exists'\n        elif exception_code == 50:\n            return 'Invalid params'"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def insert(**data):\n\n    table = data.get('table')\n\n    try:\n        clickhouse_queries.insert_into_table(table, data)\n        return 'Data was successfully inserted into table'\n\n    except ServerException as e:\n        exception_code = int(str(e)[5:8].strip())\n\n        if exception_code == 60:\n            return 'Table does not exists'\n        elif exception_code == 50:\n            return 'Invalid params'", "response": "Insert data into the table\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def select(**data):\n\n    try:\n        select_data = clickhouse_queries.select_from_table(table=data['table'], query=data['query'], fields=data['fields'])\n        return str(select_data)\n\n    except ServerException as e:\n        exception_code = int(str(e)[5:8].strip())\n\n        if exception_code == 60:\n            return 'Table does not exists'\n        elif exception_code == 50:\n            return 'Invalid params'", "response": "This method selects data from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling a POST request.", "response": "async def post(self):\n        \"\"\"\n        Accepts json-rpc post request.\n        Retrieves data from request body.\n        Calls defined method in field 'method_name'\n        \"\"\"\n\n        request = self.request.body.decode()\n        response = await methods.dispatch(request)\n        if not response.is_notification:\n            self.write(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_file(filename):\n    p = path.abspath(path.dirname(__file__))\n    filepath = path.join(p, filename)\n    try:\n        return open(filepath).read()\n    except IOError:\n        return ''", "response": "Read a file into a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes sure path takes the form of some url.", "response": "def _format_as_url(path):\n    \"\"\"Make sure ``path`` takes the form of ``/some/url/``.\"\"\"\n    path = sub(r\"\\.html$\", '', path)  # remove any ending .html\n\n    # Make sure it starts/ends with a slash.\n    if not path.startswith(\"/\"):\n        path = \"/{0}\".format(path)\n    if not path.endswith(\"/\"):\n        path = \"{0}/\".format(path)\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a list of URL strings that would match each staticflatpage.", "response": "def urls_from_file_tree(template_dir):\n    \"\"\"Generates a list of URL strings that would match each staticflatpage.\"\"\"\n    urls = []  # keep a list of of all the files/paths\n\n    # Should be somethign like:\n    # /path/to/myproject/templates/staticflatpages\n    root_dir = join(template_dir, 'staticflatpages')\n\n    for root, dirs, files in walk(template_dir):\n        # Only do this for the ``staticflatpages`` directory or sub-directories\n        if \"staticflatpages\" in root:\n            root = root.replace(root_dir, '')\n            for f in files:\n                path = join(root, f)\n                path = _format_as_url(path)\n                urls.append(path)\n    return urls"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_terminal_size(defaultw=80):\n    if hasattr(shutil_get_terminal_size, \"__call__\"):\n        return shutil_get_terminal_size()\n    else:\n        try:\n            import fcntl, termios, struct\n            fd = 0\n            hw = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,\n                                                 '1234'))\n            return (hw[1], hw[0])\n        except:\n            try:\n                out = sp.check_output([\"tput\", \"cols\"])\n                width = int(out.decode(\"utf-8\").strip())\n                return (width, None)\n            except:\n                try:\n                    hw = (os.environ['LINES'], os.environ['COLUMNS'])\n                    return (hw[1], hw[0])\n                except:\n                    return (defaultw, None)", "response": "Returns the size of the current terminal in the order they were used."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering the terminal (stdout) for printing. Useful to prevent multiple processes from writing progress bars to stdout. One process (server) prints to stdout and a couple of subprocesses do not print to the same stdout, because the server has reserved it. Of course, the clients have to be nice and check with terminal_reserve first if they should (not) print. Nothing is locked. Returns ------- True if reservation was successful (or if we have already reserved this tty), False if there already is a reservation from another instance.", "response": "def terminal_reserve(progress_obj, terminal_obj=None, identifier=None):\n    \"\"\" Registers the terminal (stdout) for printing.\n\n    Useful to prevent multiple processes from writing progress bars\n    to stdout.\n\n    One process (server) prints to stdout and a couple of subprocesses\n    do not print to the same stdout, because the server has reserved it.\n    Of course, the clients have to be nice and check with\n    terminal_reserve first if they should (not) print.\n    Nothing is locked.\n\n    Returns\n    -------\n    True if reservation was successful (or if we have already reserved this tty),\n    False if there already is a reservation from another instance.\n    \"\"\"\n    if terminal_obj is None:\n        terminal_obj = sys.stdout\n\n    if identifier is None:\n        identifier = ''\n\n    if terminal_obj in TERMINAL_RESERVATION:  # terminal was already registered\n        log.debug(\"this terminal %s has already been added to reservation list\", terminal_obj)\n\n        if TERMINAL_RESERVATION[terminal_obj] is progress_obj:\n            log.debug(\"we %s have already reserved this terminal %s\", progress_obj, terminal_obj)\n            return True\n        else:\n            log.debug(\"someone else %s has already reserved this terminal %s\", TERMINAL_RESERVATION[terminal_obj],\n                      terminal_obj)\n            return False\n    else:  # terminal not yet registered\n        log.debug(\"terminal %s was reserved for us %s\", terminal_obj, progress_obj)\n        TERMINAL_RESERVATION[terminal_obj] = progress_obj\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the cleaned_data of the form everything should already be valid", "response": "def compress(self, data_list):\n        \"\"\"\n        Return the cleaned_data of the form, everything should already be valid\n        \"\"\"\n        data = {}\n        if data_list:\n            return dict(\n                (f.name, data_list[i]) for i, f in enumerate(self.form))\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls the form is_valid to ensure every value supplied is valid", "response": "def clean(self, value):\n        \"\"\"\n        Call the form is_valid to ensure every value supplied is valid\n        \"\"\"\n        if not value:\n            raise ValidationError(\n                'Error found in Form Field: Nothing to validate')\n\n        data = dict((bf.name, value[i]) for i, bf in enumerate(self.form))\n        self.form = form = self.form.__class__(data)\n        if not form.is_valid():\n            error_dict = list(form.errors.items())\n            raise ValidationError([\n                ValidationError(mark_safe('{} {}'.format(\n                    k.title(), v)), code=k) for k, v in error_dict])\n\n        # This call will ensure compress is called as expected.\n        return super(FormField, self).clean(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_moc(self, filename):\n\n        if self.moc is None:\n            self.moc = MOC(filename=filename)\n\n        else:\n            self.moc.read(filename)", "response": "Read a file into the current running MOC object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef catalog(self):\n\n        from .catalog import catalog_to_moc, read_ascii_catalog\n\n        filename = self.params.pop()\n        order = 12\n        radius = 3600\n        unit = None\n        format_ = 'commented_header'\n        kwargs = {}\n\n        while self.params:\n            if self.params[-1] == 'order':\n                self.params.pop()\n                order = int(self.params.pop())\n            elif self.params[-1] == 'radius':\n                self.params.pop()\n                radius = float(self.params.pop())\n            elif self.params[-1] == 'unit':\n                self.params.pop()\n                unit_x = self.params.pop()\n                unit_y = self.params.pop()\n                unit = (unit_x, unit_y)\n            elif self.params[-1] == 'format':\n                self.params.pop()\n                format_ = self.params.pop()\n            elif self.params[-1] == 'inclusive':\n                self.params.pop()\n                kwargs['inclusive'] = True\n            else:\n                break\n\n        coords = read_ascii_catalog(filename, format_=format_, unit=unit)\n        catalog_moc = catalog_to_moc(coords, radius, order, **kwargs)\n\n        if self.moc is None:\n            self.moc = catalog_moc\n        else:\n            self.moc += catalog_moc", "response": "This command creates a MOC from an ASCII catalog file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay command usage information.", "response": "def help(self):\n        \"\"\"Display command usage information.\"\"\"\n\n        if self.params:\n            command = self.params.pop().lstrip('-')\n\n            if command in self.command.documentation:\n                (aliases, doc) = self.command.documentation[command]\n                (synopsis, body) = self._split_docstring(doc)\n\n                print(synopsis)\n                if body:\n                    print()\n                    print(body)\n\n            else:\n                raise CommandError('command {0} not known'.format(command))\n        else:\n            (synopsis, body) = self._split_docstring(__doc__)\n\n            print(synopsis)\n            print()\n            print(body)\n            print()\n            print('Commands:')\n            for command in sorted(self.command.documentation.keys()):\n                print('   ', ', '.join(self.command.documentation[command][0]))\n            print()\n            print('Use \"pymoctool --help COMMAND\" for additional '\n                  'information about a command.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef identifier(self):\n\n        if self.moc is None:\n            self.moc = MOC()\n\n        self.moc.id = self.params.pop()", "response": "Set the identifier of the current MOC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisplaying basic information about the running MOC.", "response": "def display_info(self):\n        \"\"\"Display basic information about the running MOC.\"\"\"\n\n        if self.moc is None:\n            print('No MOC information present')\n            return\n\n        if self.moc.name is not None:\n            print('Name:', self.moc.name)\n        if self.moc.id is not None:\n            print('Identifier:', self.moc.id)\n        print('Order:', self.moc.order)\n        print('Cells:', self.moc.cells)\n        print('Area:', self.moc.area_sq_deg, 'square degrees')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef intersection(self):\n\n        if self.moc is None:\n            raise CommandError('No MOC information present for intersection')\n\n        filename = self.params.pop()\n        self.moc = self.moc.intersection(MOC(filename=filename))", "response": "Compute the intersection with the given MOC."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the name of the current MOC.", "response": "def name(self):\n        \"\"\"Set the name of the current MOC.\n\n        The new name should be given after this option.\n\n        ::\n\n            pymoctool ... --name 'New MOC name' --output new_moc.fits\n        \"\"\"\n\n        if self.moc is None:\n            self.moc = MOC()\n\n        self.moc.name = self.params.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nnormalize the MOC to a given order. This command takes a MOC order (0-29) and normalizes the MOC so that its maximum order is the given order. :: pymoctool a.fits --normalize 10 --output a_10.fits", "response": "def normalize(self):\n        \"\"\"Normalize the MOC to a given order.\n\n        This command takes a MOC order (0-29) and normalizes the MOC so that\n        its maximum order is the given order.\n\n        ::\n\n            pymoctool a.fits --normalize 10 --output a_10.fits\n        \"\"\"\n\n        if self.moc is None:\n            raise CommandError('No MOC information present for normalization')\n\n        order = int(self.params.pop())\n        self.moc.normalize(order)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the MOC to a given file.", "response": "def write_moc(self):\n        \"\"\"Write the MOC to a given file.\"\"\"\n\n        if self.moc is None:\n            raise CommandError('No MOC information present for output')\n\n        filename = self.params.pop()\n        self.moc.write(filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subtract(self):\n\n        if self.moc is None:\n            raise CommandError('No MOC information present for subtraction')\n\n        filename = self.params.pop()\n        self.moc -= MOC(filename=filename)", "response": "Subtract the given MOC from the running MOC"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows the running MOC on an all-sky map. This command requires that the Healpy and matplotlib libraries be available. It plots the running MOC, which should be normalized to a lower order first if it would generate an excessively large pixel array. :: pymoctool a.moc --normalize 8 --plot It also accepts additional arguments which can be used to control the plot. The 'order' option can be used instead of normalizing the MOC before plotting. The 'antialias' option specifies an additional number of MOC orders which should be used to smooth the edges as plotted -- 1 or 2 is normally sufficient. The 'file' option can be given to specify a file to which the plot should be saved. :: pymoctool ... --plot [order <order>] [antialias <level>] [file <filename>] ...", "response": "def plot(self):\n        \"\"\"Show the running MOC on an all-sky map.\n\n        This command requires that the Healpy and matplotlib libraries be\n        available.  It plots the running MOC, which should be normalized to\n        a lower order first if it would generate an excessively large pixel\n        array.\n\n        ::\n\n            pymoctool a.moc --normalize 8 --plot\n\n        It also accepts additional arguments which can be used to control\n        the plot.  The 'order' option can be used instead of normalizing the\n        MOC before plotting.  The 'antialias' option specifies an additional\n        number of MOC orders which should be used to smooth the edges as\n        plotted -- 1 or 2 is normally sufficient.  The 'file' option can\n        be given to specify a file to which the plot should be saved.\n\n        ::\n\n            pymoctool ... --plot [order <order>] [antialias <level>] [file <filename>] ...\n        \"\"\"\n\n        if self.moc is None:\n            raise CommandError('No MOC information present for plotting')\n\n        from .plot import plot_moc\n\n        order = self.moc.order\n        antialias = 0\n        filename = None\n\n        while self.params:\n            if self.params[-1] == 'order':\n                self.params.pop()\n                order = int(self.params.pop())\n            elif self.params[-1] == 'antialias':\n                self.params.pop()\n                antialias = int(self.params.pop())\n            elif self.params[-1] == 'file':\n                self.params.pop()\n                filename = self.params.pop()\n            else:\n                break\n\n        plot_moc(self.moc, order=order, antialias=antialias,\n                 filename=filename, projection='moll')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nseparating a docstring into the synopsis and body.", "response": "def _split_docstring(self, docstring):\n        \"\"\"Separate a docstring into the synopsis (first line) and body.\"\"\"\n\n        lines = docstring.strip().splitlines()\n\n        synopsis = lines[0].strip()\n        body = textwrap.dedent('\\n'.join(lines[2:]))\n\n        # Remove RST preformatted text markers.\n        body = body.replace('\\n::\\n', '')\n        body = body.replace('::\\n', ':')\n\n        return (synopsis, body)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef default(self, obj):\n        if isinstance(obj, (datetime.date, datetime.time, datetime.datetime)):\n            return '\"%s\"' % obj.isoformat()\n        elif isinstance(obj, unicode):\n            return '\"%s\"' % unicodedata.normalize('NFD', obj).encode('utf-8')\n        elif isinstance(obj, decimal.Decimal):\n            return str(obj)\n        return super(Encoder, self).default(obj)", "response": "JSON encoder for the\n        parameter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_synapses(path=HOME + \"/Downloads/pinky100_final.df\",\n                  scaling=(1, 1, 1)):\n    \"\"\" Test scenario using real synapses \"\"\"\n\n    scaling = np.array(list(scaling))\n\n    df = pd.read_csv(path)\n\n    locs = np.array(df[[\"presyn_x\", \"centroid_x\", \"postsyn_x\"]])\n\n    mask = ~np.any(np.isnan(locs), axis=1)\n\n    df = df[mask]\n\n    df['pre_pt.position'] = list((np.array(df[['presyn_x', 'presyn_y', 'presyn_z']]) / scaling).astype(np.int))\n    df['ctr_pt.position'] = list((np.array(df[['centroid_x', 'centroid_y', 'centroid_z']]) / scaling).astype(np.int))\n    df['post_pt.position'] = list((np.array(df[['postsyn_x', 'postsyn_y', 'postsyn_z']]) / scaling).astype(np.int))\n\n    df = df[['pre_pt.position', 'ctr_pt.position', 'post_pt.position', 'size']]\n\n    return df", "response": "Test scenario using real synapses"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nincludes a bundle of files into the internal space.", "response": "def include(context, bundle_name, version):\n    \"\"\"Include a bundle of files into the internal space.\n\n    Use bundle name if you simply want to inlcude the latest version.\n    \"\"\"\n    store = Store(context.obj['database'], context.obj['root'])\n    if version:\n        version_obj = store.Version.get(version)\n        if version_obj is None:\n            click.echo(click.style('version not found', fg='red'))\n    else:\n        bundle_obj = store.bundle(bundle_name)\n        if bundle_obj is None:\n            click.echo(click.style('bundle not found', fg='red'))\n        version_obj = bundle_obj.versions[0]\n\n    try:\n        include_version(context.obj['root'], version_obj)\n    except VersionIncludedError as error:\n        click.echo(click.style(error.message, fg='red'))\n        context.abort()\n\n    version_obj.included_at = dt.datetime.now()\n    store.commit()\n    click.echo(click.style('included all files!', fg='green'))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ingress_filter(self, response):\n        data = self.data_getter(response)\n        if isinstance(data, dict):\n            data = m_data.DictResponse(data)\n        elif isinstance(data, list):\n            data = m_data.ListResponse(data)\n        else:\n            return data\n        data.meta = self.meta_getter(response)\n        return data", "response": "Flatten a response with meta and data keys into an object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_pager(self, *path, **kwargs):\n        page_arg = kwargs.pop('page_size', None)\n        limit_arg = kwargs.pop('limit', None)\n        kwargs['limit'] = page_arg or limit_arg or self.default_page_size\n        return self.adapter.get_pager(self.get, path, kwargs)", "response": "A generator for all the results a resource can provide."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef track_heads(self, cmd):\n        # Get the true set of parents\n        if cmd.from_ is not None:\n            parents = [cmd.from_]\n        else:\n            last_id = self.last_ids.get(cmd.ref)\n            if last_id is not None:\n                parents = [last_id]\n            else:\n                parents = []\n        parents.extend(cmd.merges)\n\n        # Track the heads\n        self.track_heads_for_ref(cmd.ref, cmd.id, parents)\n        return parents", "response": "Track the heads given a CommitCommand."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef metasay(ctx, inputfile, item):\n    with rasterio.open(inputfile) as src:\n        meta = src.profile\n    click.echo(moothedata(meta, key=item))", "response": "Moo some dataset metadata to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a PDB file into an AMPAL object.", "response": "def load_pdb(pdb, path=True, pdb_id='', ignore_end=False):\n    \"\"\"Converts a PDB file into an AMPAL object.\n\n    Parameters\n    ----------\n    pdb : str\n        Either a path to a PDB file or a string containing PDB\n        format structural data.\n    path : bool, optional\n        If `true`, flags `pdb` as a path and not a PDB string.\n    pdb_id : str, optional\n        Identifier for the `Assembly`.\n    ignore_end : bool, optional\n        If `false`, parsing of the file will stop when an \"END\"\n        record is encountered.\n\n    Returns\n    -------\n    ampal : ampal.Assembly or ampal.AmpalContainer\n        AMPAL object that contains the structural information from\n        the PDB file provided. If the PDB file has a single state\n        then an `Assembly` will be returned, otherwise an\n        `AmpalContainer` will be returned.\n    \"\"\"\n    pdb_p = PdbParser(pdb, path=path, pdb_id=pdb_id, ignore_end=ignore_end)\n    return pdb_p.make_ampal()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef proc_line_coordinate(self, line):\n        at_type = line[0:6].strip()  # 0\n        at_ser = int(line[6:11].strip())  # 1\n        at_name = line[12:16].strip()  # 2\n        alt_loc = line[16].strip()  # 3\n        res_name = line[17:20].strip()  # 4\n        chain_id = line[21].strip()  # 5\n        res_seq = int(line[22:26].strip())  # 6\n        i_code = line[26].strip()  # 7\n        x = float(line[30:38].strip())  # 8\n        y = float(line[38:46].strip())  # 9\n        z = float(line[46:54].strip())  # 10\n        occupancy = float(line[54:60].strip())  # 11\n        temp_factor = float(line[60:66].strip())  # 12\n        element = line[76:78].strip()  # 13\n        charge = line[78:80].strip()  # 14\n        if at_name not in PDB_ATOM_COLUMNS:\n            PDB_ATOM_COLUMNS[at_name] = line[12:16]\n            self.new_labels = True\n        return (at_type, at_ser, at_name, alt_loc, res_name, chain_id, res_seq,\n                i_code, x, y, z, occupancy, temp_factor, element, charge)", "response": "Extracts data from columns in ATOM record."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates the states dictionary for a Monomer.", "response": "def gen_states(self, monomer_data, parent):\n        \"\"\"Generates the `states` dictionary for a `Monomer`.\n\n        monomer_data : list\n            A list of atom data parsed from the input PDB.\n        parent : ampal.Monomer\n            `Monomer` used to assign `parent` on created\n            `Atoms`.\n        \"\"\"\n        states = {}\n        for atoms in monomer_data:\n            for atom in atoms:\n                state = 'A' if not atom[3] else atom[3]\n                if state not in states:\n                    states[state] = OrderedDict()\n                states[state][atom[2]] = Atom(\n                    tuple(atom[8:11]), atom[13], atom_id=atom[1],\n                    res_label=atom[2], occupancy=atom[11], bfactor=atom[12],\n                    charge=atom[14], state=state, parent=parent)\n\n        # This code is to check if there are alternate states and populate any\n        # both states with the full complement of atoms\n        states_len = [(k, len(x)) for k, x in states.items()]\n        if (len(states) > 1) and (len(set([x[1] for x in states_len])) > 1):\n            for t_state, t_state_d in states.items():\n                new_s_dict = OrderedDict()\n                for k, v in states[sorted(states_len,\n                                          key=lambda x: x[0])[0][0]].items():\n                    if k not in t_state_d:\n                        c_atom = Atom(\n                            v._vector, v.element, atom_id=v.id,\n                            res_label=v.res_label,\n                            occupancy=v.tags['occupancy'],\n                            bfactor=v.tags['bfactor'], charge=v.tags['charge'],\n                            state=t_state[0], parent=v.parent)\n                        new_s_dict[k] = c_atom\n                    else:\n                        new_s_dict[k] = t_state_d[k]\n                states[t_state] = new_s_dict\n        return states"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_for_non_canonical(residue):\n        res_label = list(residue[0])[0][2]\n        atom_labels = {x[2] for x in itertools.chain(\n            *residue[1].values())}  # Used to find unnatural aas\n        if (all(x in atom_labels for x in ['N', 'CA', 'C', 'O'])) and (\n                len(res_label) == 3):\n            return Residue, True\n        return None", "response": "Checks to see if the residue is non - canonical."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_inst_info(qry_string):\n    qry_prefix = \"EC2C.describe_instances(\"\n    qry_real = qry_prefix + qry_string + \")\"\n    qry_results = eval(qry_real)     # pylint: disable=eval-used\n    return qry_results", "response": "Execute a query against the AWS EC2 client object that matches the given string and return the raw information returned from AWS."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_aminames(i_info):\n    for i in i_info:\n        try:\n            # pylint: disable=maybe-no-member\n            i_info[i]['aminame'] = EC2R.Image(i_info[i]['ami']).name\n        except AttributeError:\n            i_info[i]['aminame'] = \"Unknown\"\n    return i_info", "response": "Get Image_Name for each instance in i_info."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_one_aminame(inst_img_id):\n    try:\n        aminame = EC2R.Image(inst_img_id).name\n    except AttributeError:\n        aminame = \"Unknown\"\n    return aminame", "response": "Get the name of the image_id specified."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef startstop(inst_id, cmdtodo):\n    tar_inst = EC2R.Instance(inst_id)\n    thecmd = getattr(tar_inst, cmdtodo)\n    response = thecmd()\n    return response", "response": "Start or Stop the Specified Instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a JSON file and read the users.", "response": "def addCity(self, fileName):\n        \"\"\"Add a JSON file and read the users.\n\n        :param fileName: path to the JSON file. This file has to have a list of\n        users, called users.\n        :type fileName: str.\n        \"\"\"\n        with open(fileName) as data_file:\n            data = load(data_file)\n        for u in data[\"users\"]:\n            if not any(d[\"name\"] == u[\"name\"] for d in self.__users):\n                self.__users.append(u)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef export(self, template_file_name, output_file_name,\n               sort=\"public\", data=None, limit=0):\n        \"\"\"Export ranking to a file.\n\n        Args:\n            template_file_name (str): where is the template\n                (moustache template)\n            output_file_name (str): where create the file with the ranking\n            sort (str): field to sort the users\n        \"\"\"\n        exportedData = {}\n        exportedUsers = self.getSortedUsers()\n        template = self.__getTemplate(template_file_name)\n        position = 1\n\n        if not limit:\n            exportedData[\"users\"] = exportedUsers\n        else:\n            exportedData[\"users\"] = exportedUsers[:limit]\n\n        for u in exportedData[\"users\"]:\n            u[\"position\"] = position\n            u[\"comma\"] = position < len(exportedData[\"users\"])\n            position += 1\n\n        exportedData[\"extraData\"] = data\n\n        renderer = Renderer()\n        output = renderer.render(template, exportedData)\n\n        with open(output_file_name, \"w\") as text_file:\n            text_file.write(output)", "response": "Export the ranking to a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __getTemplate(template_file_name):\n        with open(template_file_name) as template_file:\n            template_raw = template_file.read()\n\n        template = parse(template_raw)\n        return template", "response": "Get the template for the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getSortedUsers(self, order=\"public\"):\n        if order == \"contributions\":\n            self.__users.sort(key=lambda u: u[\"contributions\"],\n                              reverse=True)\n        elif order == \"public\":\n            self.__users.sort(key=lambda u: u[\"public\"],\n                              reverse=True)\n        elif order == \"private\":\n            self.__users.sort(key=lambda u: u[\"private\"],\n                              reverse=True)\n        elif order == \"name\":\n            self.__users.sort(key=lambda u: u[\"name\"], reverse=True)\n        elif order == \"followers\":\n            self.__users.sort(key=lambda u: u[\"followers\"], reverse=True)\n        elif order == \"join\":\n            self.__users.sort(key=lambda u: u[\"join\"], reverse=True)\n        elif order == \"organizations\":\n            self.__users.sort(key=lambda u: u[\"organizations\"],\n                              reverse=True)\n        elif order == \"repositories\":\n            self.__users.sort(key=lambda u: u[\"repositories\"],\n                              reverse=True)\n        return self.__users", "response": "Return a list with sorted users."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef loop(sock, config=None):\n\n    \"\"\"Loops over all docker events and executes subscribed callbacks with an\n    optional config value.\n\n    :param config: a dictionary with external config values\n    \"\"\"\n\n    if config is None:\n        config = {}\n\n    client = docker.Client(base_url=sock)\n\n    # fake a running event for all running containers\n    for container in client.containers():\n        event_data = {\n            'status': \"running\",\n            'id': container['Id'],\n            'from': container['Image'],\n            'time': container['Created'],\n        }\n\n        LOG.debug(\"incomming event: %s\", event_data)\n\n        callbacks = event.filter_callbacks(client, event_data)\n\n        # spawn all callbacks\n        gevent.joinall([gevent.spawn(cb, event_data, config) for cb in callbacks])\n\n    # listen for further events\n    for raw_data in client.events():\n\n        event_data = json.loads(raw_data)\n\n        LOG.debug(\"incomming event: %s\", event_data)\n\n        callbacks = event.filter_callbacks(client, event_data)\n\n        # spawn all callbacks\n        gevent.joinall([gevent.spawn(cb, client, event_data, config) for cb in callbacks])", "response": "Loop over all docker events and executes subscribed callbacks with an\nAttributeNames optional config value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef join_configs(configs):\n\n    \"\"\"Join all config files into one config.\"\"\"\n\n    joined_config = {}\n\n    for config in configs:\n        joined_config.update(yaml.load(config))\n\n    return joined_config", "response": "Join all config files into one config."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload and execute a python file.", "response": "def load_files(files):\n    \"\"\"Load and execute a python file.\"\"\"\n\n    for py_file in files:\n        LOG.debug(\"exec %s\", py_file)\n        execfile(py_file, globals(), locals())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef type(self, value):\n\n        self._type = None\n        if value is None:\n            return\n\n        value = value.upper()\n        if value in MOC_TYPES:\n            self._type = value\n        else:\n            raise ValueError('MOC type must be one of ' + ', '.join(MOC_TYPES))", "response": "Set the type of the MOC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding cells at a given order to the MOC.", "response": "def add(self, order, cells, no_validation=False):\n        \"\"\"Add cells at a given order to the MOC.\n\n        The cells are inserted into the MOC at the specified order.  This\n        leaves the MOC in an un-normalized state.  The cells are given\n        as a collection of integers (or types which can be converted\n        to integers).\n\n        >>> m = MOC()\n        >>> m.add(4, (20, 21))\n        >>> m.cells\n        2\n\n        >>> m.add(5, (88, 89))\n        >>> m.cells\n        4\n\n        The `no_validation` option can be given to skip validation of the\n        cell numbers.  They must already be integers in the correct range.\n        \"\"\"\n\n        self._normalized = False\n\n        order = self._validate_order(order)\n\n        if no_validation:\n            # Simply add the given cells to the set with no validation.\n            self._orders[order].update(cells)\n\n        else:\n            # Collect validated cell numbers in a set for addition.\n            cell_set = set()\n\n            for cell in cells:\n                cell = self._validate_cell(order, cell)\n                cell_set.add(cell)\n\n            self._orders[order].update(cell_set)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(self, order, cells):\n\n        self._normalized = False\n\n        order = self._validate_order(order)\n\n        for cell in cells:\n            cell = self._validate_cell(order, cell)\n\n            self._compare_operation(order, cell, True, 'remove')", "response": "Removes cells at a given order from the MOC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear all cells from a MOC.", "response": "def clear(self):\n        \"\"\"Clears all cells from a MOC.\n\n        >>> m = MOC(4, (5, 6))\n        >>> m.clear()\n        >>> m.cells\n        0\n        \"\"\"\n\n        for order in range(0, MAX_ORDER + 1):\n            self._orders[order].clear()\n\n        self._normalized = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy(self):\n\n        copy = MOC(name=self.name, mocid=self.id,\n                   origin=self.origin, moctype=self.type)\n\n        copy += self\n\n        return copy", "response": "Return a copy of a MOC."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef contains(self, order, cell, include_smaller=False):\n\n        order = self._validate_order(order)\n        cell = self._validate_cell(order, cell)\n\n        return self._compare_operation(order, cell, include_smaller, 'check')", "response": "Test whether the given MOC contains the given cell."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _compare_operation(self, order, cell, include_smaller, operation):\n\n        # Check for a larger cell (lower order) which contains the\n        # given cell.\n        for order_i in range(0, order):\n            shift = 2 * (order - order_i)\n            cell_i = cell >> shift\n\n            if cell_i in self._orders[order_i]:\n                if operation == 'check':\n                    return True\n                elif operation == 'remove':\n                    # Remove the cell and break it into its 4 constituent\n                    # cells.  Those which actually match the area we are\n                    # trying to remove will be removed at the next stage.\n                    self._orders[order_i].remove(cell_i)\n                    self.add(order_i + 1,\n                             range(cell_i << 2, (cell_i + 1) << 2))\n                elif operation == 'inter':\n                    return [(order, (cell,))]\n\n        # Check for the specific cell itself, but only after looking at larger\n        # cells because for the \"remove\" operation we may have broken up\n        # one of the large cells so that it subsequently matches.\n        if cell in self._orders[order]:\n            if operation == 'check':\n                return True\n            elif operation == 'remove':\n                self._orders[order].remove(cell)\n            elif operation == 'inter':\n                return [(order, (cell,))]\n\n        result = []\n\n        if include_smaller:\n            # Check for a smaller cell (higher order) which is part\n            # of the given cell.\n            for order_i in range(order + 1, MAX_ORDER + 1):\n                shift = 2 * (order_i - order)\n\n                cells = []\n\n                for cell_i in self._orders[order_i]:\n                    if (cell_i >> shift) == cell:\n                        if operation == 'check':\n                            return True\n                        elif operation == 'remove' or operation == 'inter':\n                            cells.append(cell_i)\n\n                if operation == 'remove':\n                    for cell_i in cells:\n                        self._orders[order_i].remove(cell_i)\n                elif operation == 'inter':\n                    if cells:\n                        result.append((order_i, cells))\n\n        if operation == 'check':\n            return False\n        elif operation == 'inter':\n            return result", "response": "Internal method for comparison - based operations."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef intersection(self, other):\n\n        inter = MOC()\n\n        for (order, cells) in other:\n            for cell in cells:\n                for i in self._compare_operation(order, cell, True, 'inter'):\n                    inter.add(*i)\n\n        return inter", "response": "Returns a MOC representing the intersection with another MOC."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef normalize(self, max_order=MAX_ORDER):\n\n        max_order = self._validate_order(max_order)\n\n        # If the MOC is already normalized and we are not being asked\n        # to reduce the order, then do nothing.\n        if self.normalized and max_order >= self.order:\n            return\n\n        # Group the pixels by iterating down from the order.  At each\n        # order, where all 4 adjacent pixels are present (or we are above\n        # the maximum order) they are replaced with a single pixel in the\n        # next lower order.  Otherwise the pixel should appear in the MOC\n        # unless it is already represented at a lower order.\n        for order in range(self.order, 0, -1):\n            pixels = self._orders[order]\n\n            next_pixels = self._orders[order - 1]\n\n            new_pixels = set()\n\n            while pixels:\n                pixel = pixels.pop()\n\n                # Look to lower orders to ensure this pixel isn't\n                # already covered.\n                check_pixel = pixel\n                already_contained = True\n                for check_order in range(order - 1, -1, -1):\n                    check_pixel >>= 2\n                    if check_pixel in self._orders[check_order]:\n                        break\n                else:\n                    already_contained = False\n\n                # Check whether this order is above the maximum, or\n                # if we have all 4 adjacent pixels.  Also do this if\n                # the pixel was already contained at a lower level\n                # so that we can avoid checking the adjacent pixels.\n                if (already_contained or (order > max_order) or\n                        (((pixel ^ 1) in pixels) and\n                         ((pixel ^ 2) in pixels) and\n                         ((pixel ^ 3) in pixels))):\n\n                    pixels.discard(pixel ^ 1)\n                    pixels.discard(pixel ^ 2)\n                    pixels.discard(pixel ^ 3)\n\n                    if not already_contained:\n                        # Group these pixels by placing the equivalent pixel\n                        # for the next order down in the set.\n                        next_pixels.add(pixel >> 2)\n\n                else:\n                    new_pixels.add(pixel)\n\n            if new_pixels:\n                self._orders[order].update(new_pixels)\n\n        self._normalized = True", "response": "Normalizes the MOC and returns the MOC in the specified order."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a flattened pixel collection at a single order.", "response": "def flattened(self, order=None, include_smaller=True):\n        \"\"\"Return a flattened pixel collection at a single order.\"\"\"\n\n        if order is None:\n            order = self.order\n        else:\n            order = self._validate_order(order)\n\n        # Start with the cells which are already at this order.\n        flat = set(self[order])\n\n        # Look at lower orders and expand them into this set.\n        # Based on the \"map\" algorithm from Appendix A of the\n        # MOC recommendation.\n        for order_i in range(0, order):\n            shift = 2 * (order - order_i)\n\n            for cell in self[order_i]:\n                flat.update(range(cell << shift, (cell + 1) << shift))\n\n        # Look at higher orders unless we have been told to exclude\n        # them.\n        if include_smaller:\n            for order_i in range(order + 1, MAX_ORDER + 1):\n                shift = 2 * (order_i - order)\n\n                for cell in self[order_i]:\n                    flat.add(cell >> shift)\n\n        return flat"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self, filename, filetype=None, include_meta=False, **kwargs):\n\n        if filetype is not None:\n            filetype = filetype.lower()\n        else:\n            filetype = self._guess_file_type(filename)\n\n        if filetype == 'fits':\n            from .io.fits import read_moc_fits\n            read_moc_fits(self, filename, include_meta, **kwargs)\n\n        elif filetype == 'json':\n            from .io.json import read_moc_json\n            read_moc_json(self, filename, **kwargs)\n\n        elif filetype == 'ascii' or filetype == 'text':\n            from .io.ascii import read_moc_ascii\n            read_moc_ascii(self, filename, **kwargs)\n\n        else:\n            raise ValueError('Unknown MOC file type {0}'.format(filetype))", "response": "Read data from the given file into the MOC object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, filename, filetype=None, **kwargs):\n\n        if filetype is not None:\n            filetype = filetype.lower()\n        else:\n            filetype = self._guess_file_type(filename)\n\n        if filetype == 'fits':\n            from .io.fits import write_moc_fits\n            write_moc_fits(self, filename, **kwargs)\n\n        elif filetype == 'json':\n            from .io.json import write_moc_json\n            write_moc_json(self, filename, **kwargs)\n\n        elif filetype == 'ascii' or filetype == 'text':\n            from .io.ascii import write_moc_ascii\n            write_moc_ascii(self, filename, **kwargs)\n\n        else:\n            raise ValueError('Unknown MOC file type {0}'.format(filetype))", "response": "Write the coverage data in the MOC object to a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattempting to guess the type of a MOC file. Returns fits json or ascii if successful and raised a ValueError otherwise.", "response": "def _guess_file_type(self, filename):\n        \"\"\"Attempt to guess the type of a MOC file.\n\n        Returns \"fits\", \"json\" or \"ascii\" if successful and raised\n        a ValueError otherwise.\n        \"\"\"\n\n        # First attempt to guess from the file name.\n        namelc = filename.lower()\n\n        if namelc.endswith('.fits') or namelc.endswith('.fit'):\n            return 'fits'\n        elif namelc.endswith('.json'):\n            return 'json'\n        elif namelc.endswith('.txt') or namelc.endswith('.ascii'):\n            return 'ascii'\n\n        # Otherwise, if the file exists, look at the first character.\n        if isfile(filename):\n            with open(filename, 'r') as f:\n                c = f.read(1)\n\n            if c == 'S':\n                return 'fits'\n            elif c == '{':\n                return 'json'\n            elif c.isdigit():\n                return 'ascii'\n\n        raise ValueError('Unable to determine format of {0}'.format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that the given order is valid.", "response": "def _validate_order(self, order):\n        \"\"\"Check that the given order is valid.\"\"\"\n\n        try:\n            order = int(order)\n        except ValueError as e:\n            raise TypeError('MOC order must be convertable to int')\n\n        if not 0 <= order <= MAX_ORDER:\n            raise ValueError(\n                'MOC order must be in range 0-{0}'.format(MAX_ORDER))\n\n        return order"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate_cell(self, order, cell):\n\n        max_cells = self._order_num_cells(order)\n\n        try:\n            cell = int(cell)\n        except ValueError as e:\n            raise TypeError('MOC cell must be convertable to int')\n\n        if not 0 <= cell < max_cells:\n            raise ValueError(\n                'MOC cell order {0} must be in range 0-{1}'.format(\n                    order, max_cells - 1))\n\n        return cell", "response": "Check that the given cell is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the list of queues to publish to for a given endpoint", "response": "def queues_for_endpoint(event):\n    \"\"\"\n    Return the list of queues to publish to for a given endpoint.\n\n    :param event: Lambda event that triggered the handler\n    :type event: dict\n    :return: list of queues for endpoint\n    :rtype: :std:term:`list`\n    :raises: Exception\n    \"\"\"\n    global endpoints  # endpoint config that's templated in by generator\n    # get endpoint config\n    try:\n        ep_name = event['context']['resource-path'].lstrip('/')\n        return endpoints[ep_name]['queues']\n    except:\n        raise Exception('Endpoint not in configuration: /%s' % ep_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef msg_body_for_event(event, context):\n    # find the actual input data - this differs between GET and POST\n    http_method = event.get('context', {}).get('http-method', None)\n    if http_method == 'GET':\n        data = event.get('params', {}).get('querystring', {})\n    else:  # POST\n        data = event.get('body-json', {})\n    # build the message to enqueue\n    msg_dict = {\n        'data': serializable_dict(data),\n        'event': serializable_dict(event),\n        'context': serializable_dict(vars(context))\n    }\n    msg = json.dumps(msg_dict, sort_keys=True)\n    logger.debug('Message to enqueue: %s', msg)\n    return msg", "response": "Generate the JSON - serialized message body for an event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_event(event, context):\n    queues = queues_for_endpoint(event)\n    # store some state\n    msg_ids = []\n    failed = 0\n    # get the message to enqueue\n    msg = msg_body_for_event(event, context)\n    # connect to SQS API\n    conn = boto3.client('sqs')\n    for queue_name in queues:\n        try:\n            msg_ids.append(try_enqueue(conn, queue_name, msg))\n        except Exception:\n            failed += 1\n            logger.error('Failed enqueueing message in %s:', queue_name,\n                         exc_info=1)\n    fail_str = ''\n    status = 'success'\n    if failed > 0:\n        fail_str = '; %d failed' % failed\n        status = 'partial'\n    return {\n        'status': status,\n        'message': 'enqueued %s messages%s' % (len(msg_ids), fail_str),\n        'SQSMessageIds': msg_ids\n    }", "response": "This function handles the Lambda event and returns the JSON - serialized success response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef try_enqueue(conn, queue_name, msg):\n    logger.debug('Getting Queue URL for queue %s', queue_name)\n    qurl = conn.get_queue_url(QueueName=queue_name)['QueueUrl']\n    logger.debug('Sending message to queue at: %s', qurl)\n    resp = conn.send_message(\n        QueueUrl=qurl,\n        MessageBody=msg,\n        DelaySeconds=0\n    )\n    logger.debug('Enqueued message in %s with ID %s', queue_name,\n                 resp['MessageId'])\n    return resp['MessageId']", "response": "Try to enqueue a message in a non - blocking queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serializable_dict(d):\n    newd = {}\n    for k in d.keys():\n        if isinstance(d[k], type({})):\n            newd[k] = serializable_dict(d[k])\n            continue\n        try:\n            json.dumps({'k': d[k]})\n            newd[k] = d[k]\n        except:\n            pass  # unserializable\n    return newd", "response": "Return a dict like d but with any un - json - serializable elements removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmdline(argv=sys.argv[1:]):\n    parser = ArgumentParser(\n        description='Rebase a text from his stop words')\n    parser.add_argument('language', help='The language used to rebase')\n    parser.add_argument('source', help='Text file to rebase')\n    options = parser.parse_args(argv)\n\n    factory = StopWordFactory()\n    language = options.language\n    stop_words = factory.get_stop_words(language, fail_safe=True)\n    content = open(options.source, 'rb').read().decode('utf-8')\n    print(stop_words.rebase(content))", "response": "This command is used to rebas a text file from his stop words."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate new entry in mongo database", "response": "def create(self, data):\n\t\t\"\"\"Creates new entry in mongo database\n\t\t\"\"\"\t\t\n\t\tq = self.history.insert_one(data).inserted_id\n\t\tlogging.debug(self.history.find_one({\"_id\":q}))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an absolute url relative to the request associated with this table. Any keyword arguments provided are passed to the build method of the base class.", "response": "def get_url(self, **kwargs):\n        \"\"\"\n        Return an url, relative to the request associated with this\n        table. Any keywords arguments provided added to the query\n        string, replacing existing values.\n        \"\"\"\n\n        return build(\n            self._request.path,\n            self._request.GET,\n            self._meta.prefix,\n            **kwargs )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef object_list(self):\n\n        def _sort(ob, ol):\n            reverse = ob.startswith(\"-\")\n            ob = ob[1:] if reverse else ob\n            for column in self.columns:\n                if column.sort_key_fn is not None and column.name == ob:\n                    return sorted(ol, key=column.sort_key_fn, reverse=reverse)\n            if self._meta.order_by and hasattr(ol, \"order_by\"):\n                return list(ol.order_by(*self._meta.order_by.split(\"|\")))\n            return ol\n\n        ol = self._object_list\n        ob = self._meta.order_by\n        if not ob: return ol\n        if isinstance(ob, basestring):\n            return _sort(ob, ol)\n        elif isinstance(ob, list):\n            ob.reverse()\n            for fn in ob:\n                ol = _sort(fn, ol)\n        return ol", "response": "Return this table s object_list transformed according to its meta options."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of objects on the active page.", "response": "def rows(self):\n        \"\"\"Return the list of object on the active page.\"\"\"\n\n        return map(\n            lambda o: self._meta.row_class(self, o),\n            self.paginator.page(self._meta.page).object_list )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def spawn(self):\n        self._server._pending_set.add(self)\n        await self._server._sem.acquire()\n        self._subprocess = await asyncio.create_subprocess_shell(\n            self._cmd,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE)\n        self._began_at = datetime.now()\n        if self in self._server._pending_set:\n            self._server._pending_set.remove(self)\n        self._server._running_set.add(self)\n        self._began_running_evt.set()", "response": "Spawn the command wrapped in this object as a subprocess."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck the status of the wrapped running subprocess.", "response": "def _poll(self) -> None:\n        \"\"\"Check the status of the wrapped running subprocess.\n\n        Note:\n            This should only be called on currently-running tasks.\n\n        \"\"\"\n        if self._subprocess is None:\n            raise SublemonLifetimeError(\n                'Attempted to poll a non-active subprocess')\n        elif self._subprocess.returncode is not None:\n            self._exit_code = self._subprocess.returncode\n            self._done_running_evt.set()\n            self._server._running_set.remove(self)\n            self._server._sem.release()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def stderr(self) -> AsyncGenerator[str, None]:\n        await self.wait_running()\n        async for line in self._subprocess.stderr:  # type: ignore\n            yield line", "response": "Asynchronous generator for lines from subprocess stderr."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbinding this column to a table and assign it a name.", "response": "def bind_to(self, table, name):\n        \"\"\"\n        Bind this column to a table, and assign it a name. This method\n        can only be called once per instance, because a Column cannot be\n        bound to multiple tables. (The sort order would be ambiguous.)\n        \"\"\"\n        if self.bound_to is not None:\n            raise AttributeError(\n                \"Column is already bound to '%s' as '%s'\" %\\\n                    self.bound_to)\n\n        self.bound_to = (table, name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef value(self, cell):\n\n        if self._value is not None:\n            return self._value(cell)\n\n        else:\n            return cell.value", "response": "Extract the value of this column from the cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef css_class(self, cell):\n        if isinstance(self._css_class, basestring):\n            return self._css_class\n        else:\n            return self._css_class(cell)", "response": "Return the CSS class for this column."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sort_url(self):\n\n        prefix = (self.sort_direction == \"asc\") and \"-\" or \"\"\n        return self.table.get_url(order_by=prefix + self.name)", "response": "Return the canonical URL to sort the linked table by this column."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the direction in which the linked table is sorted by this column.", "response": "def sort_direction(self):\n        \"\"\"\n        Return the direction in which the linked table is is sorted by\n        this column (\"asc\" or \"desc\"), or None this column is unsorted.\n        \"\"\"\n\n        if self.table._meta.order_by == self.name:\n            return \"asc\"\n\n        elif self.table._meta.order_by == (\"-\" + self.name):\n            return \"desc\"\n\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the file_name is OK to proceed and checks if overwrite is needed. Returns True if OK to proceed False otherwise.", "response": "def check_or_confirm_overwrite(file_name):\n    \"\"\"\n    Returns True if OK to proceed, False otherwise\n    \"\"\"\n    try:\n        with open(file_name) as fd:\n            header = next(fd)\n            if header.find(':sedge:') == -1:\n                okay = ask_overwrite(file_name)\n                if okay:\n                    backup_file(file_name)\n                else:\n                    return False\n\n    except FileNotFoundError:\n        click.echo(\"{} not found\".format(file_name), err=True)\n    except StopIteration as e:\n        click.echo(repr(e), err=True)\n    else:\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the sedge s language tree.", "response": "def init(config):\n    \"\"\"\n    Initialise ~./sedge/config file if none exists.\n    Good for first time sedge usage\n    \"\"\"\n    from pkg_resources import resource_stream\n    import shutil\n\n    config_file = Path(config.config_file)\n    if config_file.is_file():\n        click.echo('{} already exists, maybe you want $ sedge update'.format(config_file))\n        sys.exit()\n\n    config_file.parent.mkdir(parents=True, exist_ok=True)\n    with resource_stream(__name__, 'sedge_template.conf') as src_stream:\n        with open(config.config_file, 'wb') as target_stream:\n            shutil.copyfileobj(src_stream, target_stream)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(config):\n\n    def write_to(out):\n        engine.output(out)\n\n    config_file = Path(config.config_file)\n    if not config_file.is_file():\n        click.echo('No file {} '.format(config_file), err=True)\n        sys.exit()\n\n    library = KeyLibrary(config.key_directory)\n    with config_file.open() as fd:\n        engine = SedgeEngine(library, fd, not config.no_verify, url=config.config_file)\n\n    if config.output_file == '-':\n        write_to(ConfigOutput(sys.stdout))\n        return\n\n    if not check_or_confirm_overwrite(config.output_file):\n        click.echo('Aborting.', err=True)\n        sys.exit(1)\n\n    tmp_file = NamedTemporaryFile(mode='w', dir=os.path.dirname(config.output_file), delete=False)\n    try:\n        tmp_file.file.write(sedge_config_header.format(config.config_file))\n        write_to(ConfigOutput(tmp_file.file))\n        tmp_file.close()\n        if config.verbose:\n            diff_config_changes(config.output_file, tmp_file.name)\n        os.rename(tmp_file.name, config.output_file)\n    except:\n        os.unlink(tmp_file.name)\n        raise", "response": "Update ssh config from sedge specification"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading the Five Filters config from centralized repositories.", "response": "def ftr_get_config(website_url, exact_host_match=False):\n    \"\"\" Download the Five Filters config from centralized repositories.\n\n    Repositories can be local if you need to override siteconfigs.\n\n    The first entry found is returned. If no configuration is found,\n    `None` is returned. If :mod:`cacheops` is installed, the result will\n    be cached with a default expiration delay of 3 days.\n\n    :param exact_host_match: If ``False`` (default), we will look for\n        wildcard config matches. For example if host is\n        ``www.test.example.org``, we will try looking up\n        ``test.example.org`` and ``example.org``.\n    :param exact_host_match: bool\n\n    :param website_url: either a full web URI (eg.\n        ``http://www.website.com:PORT/path/to/a/page.html``) or simply\n        a domain name (eg. ``www.website.com``). In case of a domain name,\n        no check is performed yet, be careful of what you pass.\n    :type website_url: str or unicode\n\n    :returns: tuple -- the loaded site config (as unicode string) and\n        the hostname matched (unicode string too).\n    :raises: :class:`SiteConfigNotFound` if no config could be found.\n\n    .. note:: Whatever ``exact_host_match`` value is, the ``www`` part is\n        always removed from the URL or domain name.\n\n    .. todo:: there is currently no merging/cascading of site configs. In\n        the original Five Filters implementation, primary and secondary\n        configurations were merged. We could eventually re-implement this\n        part if needed by someone. PRs welcome as always.\n    \"\"\"\n\n    def check_requests_result(result):\n        return (\n            u'text/plain' in result.headers.get('content-type')\n            and u'<!DOCTYPE html>' not in result.text\n            and u'<html ' not in result.text\n            and u'</html>' not in result.text\n        )\n\n    repositories = [\n        x.strip() for x in os.environ.get(\n            'PYTHON_FTR_REPOSITORIES',\n            os.path.expandvars(u'${HOME}/sources/ftr-site-config') + u' '\n            + u'https://raw.githubusercontent.com/1flow/ftr-site-config/master/ '  # NOQA\n            + u'https://raw.githubusercontent.com/fivefilters/ftr-site-config/master/'  # NOQA\n        ).split() if x.strip() != u'']\n\n    try:\n        proto, host_and_port, remaining = split_url(website_url)\n\n    except:\n        host_and_port = website_url\n\n    host_domain_parts = host_and_port.split(u'.')\n\n    # we don't store / use the \u201cwww.\u201d part of domain name in siteconfig.\n    if host_domain_parts[0] == u'www':\n        host_domain_parts = host_domain_parts[1:]\n\n    if exact_host_match:\n        domain_names = [u'.'.join(host_domain_parts)]\n\n    else:\n        domain_names = [\n            u'.'.join(host_domain_parts[-i:])\n            for i in reversed(range(2, len(host_domain_parts) + 1))\n        ]\n\n    LOGGER.debug(u'Gathering configurations for domains %s from %s.',\n                 domain_names, repositories)\n\n    for repository in repositories:\n        # try, in turn:\n        #   website.ext.txt\n        #   .website.ext.txt\n\n        for domain_name in domain_names:\n\n            skip_repository = False\n\n            for txt_siteconfig_name in (\n                u'{0}.txt'.format(domain_name),\n                u'.{0}.txt'.format(domain_name),\n            ):\n                if repository.startswith('http'):\n                    siteconfig_url = repository + txt_siteconfig_name\n\n                    result = requests.get(siteconfig_url)\n\n                    if result.status_code == requests.codes.ok:\n                        if not check_requests_result(result):\n                            LOGGER.error(u'\u201c%s\u201d repository URL does not '\n                                         u'return text/plain results.',\n                                         repository)\n                            skip_repository = True\n                            break\n\n                        LOGGER.info(u'Using remote siteconfig for domain '\n                                    u'%s from %s.', domain_name,\n                                    siteconfig_url, extra={\n                                        'siteconfig': domain_name})\n                        return result.text, txt_siteconfig_name[:-4]\n\n                else:\n                    filename = os.path.join(repository, txt_siteconfig_name)\n\n                    if os.path.exists(filename):\n                        LOGGER.info(u'Using local siteconfig for domain '\n                                    u'%s from %s.', domain_name,\n                                    filename, extra={\n                                        'siteconfig': domain_name})\n\n                        with codecs.open(filename, 'rb', encoding='utf8') as f:\n                            return f.read(), txt_siteconfig_name[:-4]\n\n                if skip_repository:\n                    break\n\n            if skip_repository:\n                break\n\n    raise SiteConfigNotFound(\n        u'No configuration found for domains {0} in repositories {1}'.format(\n            u', '.join(domain_names), u', '.join(repositories)\n        )\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ftr_string_to_instance(config_string):\n\n    config = SiteConfig()\n\n    for line_number, line_content in enumerate(\n            config_string.strip().split(u'\\n'), start=1):\n\n        line_content = line_content.strip()\n\n        # Skip empty lines & comments.\n        if not line_content or line_content.startswith(u'#'):\n            continue\n\n        try:\n            key, value = [\n                x.strip() for x in line_content.strip().split(u':', 1)\n            ]\n\n        except:\n            LOGGER.warning(u'Unrecognized syntax \u201c%s\u201d on line #%s.',\n                           line_content, line_number)\n            continue\n\n        # handle some very rare title()d directives.\n        key = key.lower()\n\n        if not key or (not value and key != 'replace_string'):\n            LOGGER.warning(u'Empty key or value in \u201c%s\u201d on line #%s.',\n                           line_content, line_number)\n            continue\n\n        # Commands for which we accept multiple statements.\n        elif key in (\n            'title', 'body', 'author', 'date',\n            'strip', 'strip_id_or_class', 'strip_image_src',\n            'single_page_link', 'single_page_link_in_feed',\n            'next_page_link',\n            'http_header',\n\n            'find_string',\n            'replace_string',\n\n            'test_url',\n            'test_contains',\n            'test_title',\n            'test_date',\n            'test_author',\n            'test_language',\n        ):\n\n            if key.endswith(u'_string'):\n                # Append to list. Duplicites are allowed.\n                getattr(config, key).append(value)\n\n            else:\n                # Add to set, preserving order but squashing duplicates.\n                getattr(config, key).add(value)\n\n        # Single statement commands that evaluate to True or False.\n        elif key in ('tidy', 'prune', 'autodetect_on_failure', ):\n\n            if value.lower() in ('no', 'false', '0', ):\n                setattr(config, key, False)\n\n            else:\n                setattr(config, key, bool(value))\n\n        # Single statement commands stored as strings.\n        elif key in ('parser', ):\n            setattr(config, key, value)\n\n        # The \u201creplace_string(\u2026\u2026\u2026): replace_value\u201d one-liner syntax.\n        elif key.startswith('replace_string(') and key.endswith(')'):\n            # These 2 are lists, not sets.\n            config.find_string.append(key[15:-1])\n            config.replace_string.append(value)\n\n        else:\n            LOGGER.warning(u'Unsupported directive \u201c%s\u201d on line #%s.',\n                           line_content, line_number)\n\n    find_count = len(config.find_string)\n    replace_count = len(config.replace_string)\n\n    if find_count != replace_count:\n        raise InvalidSiteConfig(u'find_string and remplace_string do not '\n                                u'correspond ({0} != {1})'.format(\n                                    find_count, replace_count))\n\n    return config", "response": "Return a SiteConfig instance from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nresets all attributes to their default values.", "response": "def reset(self):\n        \"\"\" (re)set all attributes to defaults (eg. empty sets or ``None``). \"\"\"\n\n        # Use first matching element as title (0 or more xpath expressions)\n        self.title = OrderedSet()\n\n        # Use first matching element as body (0 or more xpath expressions)\n        self.body = OrderedSet()\n\n        # Use first matching element as author (0 or more xpath expressions)\n        self.author = OrderedSet()\n\n        # Use first matching element as date (0 or more xpath expressions)\n        self.date = OrderedSet()\n\n        # Put language here. It's not supported in siteconfig syntax,\n        # but having it here allows more generic handling in extractor.\n        self.language = (\n            '//html[@lang]/@lang',\n            '//meta[@name=\"DC.language\"]/@content',\n        )\n\n        # Strip elements matching these xpath expressions (0 or more)\n        self.strip = OrderedSet()\n\n        # Strip 0 or more elements which contain these\n        # strings in the id or class attribute.\n        self.strip_id_or_class = OrderedSet()\n\n        # Strip 0 or more images which contain\n        # these strings in the src attribute.\n        self.strip_image_src = OrderedSet()\n\n        # Additional HTTP headers to send\n        # NOT YET USED\n        self.http_header = OrderedSet()\n\n        # For those 3, None means that default will be used. But we need\n        # None to distinguish from False during multiple configurations\n        # merges.\n        self.tidy = None\n        self.prune = None\n        self.autodetect_on_failure = None\n\n        # Test URL - if present, can be used to test the config above\n        self.test_url = OrderedSet()\n        self.test_contains = OrderedSet()\n\n        # Single-page link should identify a link element or URL pointing\n        # to the page holding the entire article.\n        #\n        # This is useful for sites which split their articles across\n        # multiple pages. Links to such pages tend to display the first\n        # page with links to the other pages at the bottom.\n        #\n        # Often there is also a link to a page which displays the entire\n        # article on one page (e.g. 'print view').\n        #\n        # `single_page_link` should be an XPath expression identifying the\n        # link to that single page. If present and we find a match, we will\n        # retrieve that page and the rest of the options in this config will\n        # be applied to the new page.\n        self.single_page_link = OrderedSet()\n\n        self.next_page_link = OrderedSet()\n\n        # Single-page link in feed? - same as above, but patterns applied\n        # to item description HTML taken from feed. XXX\n        self.single_page_link_in_feed = OrderedSet()\n\n        # Which parser to use for turning raw HTML into a DOMDocument,\n        # either `libxml` (PHP) / `lxml` (Python) or `html5lib`. Defaults\n        # to `lxml` if None.\n        self.parser = None\n\n        # Strings to search for in HTML before processing begins. Goes by\n        # pairs with `replace_string`. Not a set because we can have more\n        # than one of the same, to be replaced by different values.\n        self.find_string = []\n\n        # Strings to replace those found in `find_string` before HTML\n        # processing begins.\n        self.replace_string = []"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a config for a hostname or url.", "response": "def load(self, host, exact_host_match=False):\n        \"\"\" Load a config for a hostname or url.\n\n        This method calls :func:`ftr_get_config` and :meth`append`\n        internally. Refer to their docs for details on parameters.\n        \"\"\"\n\n        # Can raise a SiteConfigNotFound, intentionally bubbled.\n        config_string, host_string = ftr_get_config(host, exact_host_match)\n\n        if config_string is None:\n            LOGGER.error(u'Error while loading configuration.',\n                         extra={'siteconfig': host_string})\n            return\n\n        self.append(ftr_string_to_instance(config_string))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends another site config to current instance.", "response": "def append(self, newconfig):\n        \"\"\" Append another site config to current instance.\n\n        All ``newconfig`` attributes are appended one by one to ours.\n        Order matters, eg. current instance values will come first when\n        merging.\n\n        Thus, if you plan to use some sort of global site config with\n        more generic directives, append it last for specific directives\n        to be tried first.\n\n        .. note:: this method is also aliased to :meth:`merge`.\n        \"\"\"\n\n        # Check for commands where we accept multiple statements (no test_url)\n        for attr_name in (\n            'title', 'body', 'author', 'date',\n            # `language` is fixed in reset() and\n            # not supported in siteconfig syntax.\n            'strip', 'strip_id_or_class', 'strip_image_src',\n            'single_page_link', 'single_page_link_in_feed',\n            'next_page_link', 'http_header'\n        ):\n            # Append to ordered set. We keep ordering, but no duplicates.\n            current_set = getattr(self, attr_name)\n            for val in getattr(newconfig, attr_name):\n                # Too bad ordered set has no .union() method.\n                current_set.add(val)\n            setattr(self, attr_name, current_set)\n\n        # Check for single statement commands;\n        # we do not overwrite existing values.\n        for attr_name in (\n            'parser', 'tidy', 'prune', 'autodetect_on_failure'\n        ):\n            if getattr(self, attr_name) is None:\n                if getattr(newconfig, attr_name) is None:\n                    setattr(self, attr_name, self.defaults[attr_name])\n                else:\n                    setattr(self, attr_name, getattr(newconfig, attr_name))\n\n        # HEADS UP: PHP \u2192 Python port.\n        if self.parser == 'libxml':\n            self.parser = 'lxml'\n\n        for attr_name in ('find_string', 'replace_string', ):\n            # Find/replace strings are lists, we extend.\n            getattr(self, attr_name).extend(getattr(newconfig, attr_name))\n\n        if self.find_string:\n            # This will ease replacements in the extractor.\n            self.replace_patterns = zip(\n                self.find_string, self.replace_string)\n\n        else:\n            self.replace_patterns = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_moc_json(moc, filename=None, file=None):\n\n    moc.normalize()\n\n    obj = {}\n\n    for (order, cells) in moc:\n        obj['{0}'.format(order)] = sorted(cells)\n\n    if file is not None:\n        _write_json(obj, file)\n    else:\n        with open(filename, 'wb') as f:\n            _write_json(obj, f)", "response": "Write a MOC in JSON encoding."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_moc_json(moc, filename=None, file=None):\n\n    if file is not None:\n        obj = _read_json(file)\n    else:\n        with open(filename, 'rb') as f:\n            obj = _read_json(f)\n\n    for (order, cells) in obj.items():\n        moc.add(order, cells)", "response": "Read JSON encoded data into a MOC."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize(xs):\n    '''\n    Restrict xs into the interval (0, 1) via a linear transformation\n    as long as len(xs) > 1, 0 and 1 will be elements of the resulting array\n    '''\n    x_min, x_max = np.min(xs), np.max(xs)\n    return (xs - x_min) / (x_max - x_min)", "response": "Normalizes xs into the interval 0 1."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gloss(alignments, prefixes=None, postfixes=None, width=None, toksep=' ', linesep='\\n', groupsep='\\n'):\n    '''\n    Creates an interlinear gloss (for pairs of tokens/types, POS-tags, labels, etc.)\n\n    Take a list of [('a', 'DET'), ('beluga', 'N')] and return a string covering multiples lines, like:\n        a   beluga\n        DET N\n    each item in `alignments` should have the same length, N\n    `prefixes`, if provided, should be N-long\n    `postfixes`, if provided, should be N-long\n    '''\n    if width is None:\n        width = terminal.width()\n    toksep_len = len(toksep)\n\n    # a \"group\" is a N-line string, each line of which is at most `width` characters\n    # `groups` is a list of such groups\n    groups = []\n\n    def flush_buffer(line_buffer):\n        if len(line_buffer) > 0:\n            lines = [toksep.join(tokens) for tokens in line_buffer]\n            if prefixes:\n                lines = [prefix + line for prefix, line in zip(prefixes, lines)]\n            if postfixes:\n                lines = [line + postfix for postfix, line in zip(postfixes, lines)]\n            groups.append(linesep.join(lines))\n        return [[] for _ in alignments[0]]\n\n    # the line_buffer is an N-long list of lists of tokens (strings)\n    # [[e1, e2, e3], [f1, f2, f3], [g1, g2, g3]]\n    line_buffer = flush_buffer([])\n    # the line_buffer_width is just the cumulative width of the current line_buffer\n    line_buffer_width = 0\n\n    for aligned in alignments:\n        aligned = map(unicode, aligned)\n        length = max(map(len, aligned))\n        line_buffer_width += toksep_len + length\n        if line_buffer_width >= width:\n            line_buffer = flush_buffer(line_buffer)\n            line_buffer_width = length\n        for i, token in enumerate(aligned):\n            line_buffer[i].append(token.ljust(length))\n\n    flush_buffer(line_buffer)\n\n    return groupsep.join(groups)", "response": "Generates an interlinear gloss for a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_queryset(self):\n        self.queryset = super(CustomFieldsMixin, self).get_queryset()\n        serializer_class = self.get_serializer_class()\n        if hasattr(serializer_class.Meta, 'nested_fields'):\n            nested_fields = serializer_class.Meta.nested_fields\n            fields = serializer_class.Meta.fields\n            self._expand_queryset(fields, nested_fields, self.queryset.model)\n        return self.queryset", "response": "For reducing the query count the queryset is expanded with prefetch_related and select_related depending on the serializer_class. Meta. nested_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads data from database table.", "response": "async def read(self, *_id):\n\t\t\"\"\"Read data from database table.\n\t\tAccepts ids of entries.\n\t\tReturns list of results if success\n\t\t\tor string with error code and explanation.\n\n\t\tread(*id) => [(result), (result)] (if success)\n\t\tread(*id) => [] (if missed)\n\t\tread() => {\"error\":400, \"reason\":\"Missed required fields\"}\n\t\t\"\"\"\n\t\tif not _id:\n\t\t\treturn {\"error\":400, \n\t\t\t\t\t\"reason\":\"Missed required fields\"}\n\n\t\tresult = []\n\t\tfor i in _id:\n\t\t\tdocument = await self.collection.find_one({\"id\":i})\n\t\t\ttry:\n\t\t\t\tresult.append({i:document[i] for i in document\n\t\t\t\t\t\t\t\t\t\t\t\tif i != \"_id\"})\n\t\t\texcept:\n\t\t\t\tcontinue\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def insert(self, **kwargs):\n\t\t\n\t\tif kwargs:\n\t\t\t# Create autoincrement for account\n\t\t\tpk = await self.autoincrement()\n\t\t\tkwargs.update({\"id\": pk})\n\n\t\t\t# Create account with received data and autoincrement\n\t\t\tawait self.collection.insert_one(kwargs)\n\n\t\t\trow = await self.collection.find_one({\"id\": pk})\n\n\t\telse:\n\t\t\trow = None\n\n\t\tif row:\n\t\t\treturn {i:row[i] for i in row if i != \"_id\"}\n\t\telse:\n\t\t\treturn {\"error\":500, \n\t\t\t\t\t\"reason\":\"Not created\"}", "response": "Creates new account with received data and returns new account."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def find(self, **kwargs):\n\t\tif not isinstance(kwargs, dict) and len(kwargs) != 1:\n\t\t\treturn {\"error\":400, \n\t\t\t\t\t\"reason\":\"Bad request\"}\n\t\tdocument = await self.collection.find_one(kwargs)\n\t\tif document:\n\t\t\treturn document\n\t\telse:\n\t\t\treturn {\"error\":404, \"reason\":\"Not found\"}", "response": "Find all entries with given search key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def update(self, _id=None, **new_data):\n\t\tif not _id or not new_data:\n\t\t\treturn {\"error\":400, \n\t\t\t\t\t\"reason\":\"Missed required fields\"}\n\n\t\tdocument = await self.collection.find_one({\"id\":_id})\n\t\tif not document:\n\t\t\treturn {\"error\":404, \n\t\t\t\t\t\"reason\":\"Not found\"}\n\n\t\tfor key in new_data:\n\t\t\tawait self.collection.find_one_and_update(\n\t\t\t\t\t\t\t{\"id\": _id},\n\t\t\t\t\t\t\t{\"$set\": {key: new_data[key]}}\n\t\t\t\t\t\t)\n\t\tupdated = await self.collection.find_one({\"id\":_id})\n\t\treturn {\"success\":200, \"reason\": \"Updated\", **updated}", "response": "Updates fields values.\n\t\tAccepts id of sigle entry and \n\t\t\tfields with values.\n\n\t\tupdate(id, **kwargs) => {\"success\":200, \"reason\":\"Updated\"} (if success)\n\t\tupdate(id, **kwargs) => {\"error\":400, \"reason\":\"Missed required fields\"} (if error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes entry from database table.", "response": "async def delete(self, _id=None):\n\t\t\"\"\"Delete entry from database table.\n\t\tAccepts id.\n\t\tdelete(id) => 1 (if exists)\n\t\tdelete(id) => {\"error\":404, \"reason\":\"Not found\"} (if does not exist)\n\t\tdelete() => {\"error\":400, \"reason\":\"Missed required fields\"}\n\t\t\"\"\"\n\t\tif not _id:\n\t\t\treturn {\"error\":400, \n\t\t\t\t\t\"reason\":\"Missed required fields\"}\n\n\t\tdocument = await self.collection.find_one({\"id\": _id})\n\n\t\tif not document:\n\t\t\treturn {\"error\":404, \n\t\t\t\t\t\"reason\":\"Not found\"}\n\n\t\tdeleted_count = await self.collection.delete_one(\n\t\t\t\t\t\t\t{\"id\": _id}).deleted_count\n\n\t\treturn deleted_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_refresh_header(self, refresh):\n        ii = refresh.find(\";\")\n        if ii != -1:\n            pause, newurl_spec = float(refresh[:ii]), refresh[ii+1:]\n            jj = newurl_spec.find(\"=\")\n            key = None\n            if jj != -1:\n                key, newurl = newurl_spec[:jj], newurl_spec[jj+1:]\n                newurl = self.clean_refresh_url(newurl)\n            if key is None or key.strip().lower() != \"url\":\n                raise ValueError()\n        else:\n            pause, newurl = float(refresh), None\n        return pause, newurl", "response": "Parse the refresh header."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract(self, html):\n        \"Extract http-equiv refresh url to follow.\"\n        extracted = {}\n        soup = BeautifulSoup(html, parser)\n        for meta_tag in soup.find_all('meta'):\n            if self.key_attr in meta_tag.attrs and 'content' in meta_tag.attrs and \\\n                meta_tag[self.key_attr].lower() == self.val_attr:\n                refresh = meta_tag.attrs['content']\n                try:\n                    pause, newurl = self.parse_refresh_header(refresh)\n                    if newurl:\n                        extracted['urls'] = [newurl]\n                        break # one is enough\n                except:\n                    pass # nevermind\n        return extracted", "response": "Extract http - equiv refresh url to follow."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverride method. Returns jsonrpc response? fetches exception? returns appropriate data to client and response mail to administrator.", "response": "def request(self, *args, **kwargs):\n\t\t\"\"\"Overrided method. Returns jsonrpc response\n\t\tor fetches exception? returns appropriate data to client\n\t\tand response mail to administrator.\n\t\t\"\"\"\n\t\ttry:\n\t\t\timport settings\n\n\t\t\twith open(os.path.join(settings.BASE_DIR, \"keys.json\")) as f:\n\t\t\t\tkeys = json.load(f)\n\t\t\t\tprivkey = keys[\"privkey\"]\n\n\t\t\tmessage = json.dumps(kwargs)\n\t\t\tsignature = Bip32Keys.sign_message(message, privkey)\n\t\t\tresult = super().request(method_name=kwargs[\"method_name\"],\n\t\t\t\t\t\t\t\t\t\t\t\tmessage=message, signature=signature)\n\t\t\treturn result\n\t\texcept ConnectionRefusedError:\n\t\t\treturn {\"error\":500, \n\t\t\t\t\t\"reason\": \"Service connection error.\"}\n\t\texcept Exception as e:\n\t\t\treturn {\"error\":500, \"reason\": str(e)}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify(self):\n\t\tlogging.debug(\"\\n\\n\")\n\t\tlogging.debug(\"[+] -- Verify debugging\")\n\t\tlogging.debug(\"\\n\\n\")\n\n\t\tif self.request.body:\n\t\t\tlogging.debug(\"\\n Request body\")\n\t\t\tlogging.debug(self.request.body)\n\t\t\tdata = json.loads(self.request.body)\n\t\t\tmessage = json.dumps(data.get(\"message\")).replace(\" \", \"\")\n\t\t\tlogging.debug(\"\\n\")\n\t\t\tlogging.debug(message)\n\n\t\telif self.request.arguments:\n\t\t\tlogging.debug(\"\\n Arguments\")\n\t\t\tlogging.debug(self.request.arguments)\n\t\t\tdata = {i:self.get_argument(i) for i in self.request.arguments}\n\t\t\tmessage = data.get(\"message\", \"{}\")\n\t\t\tlogging.debug(message)\n\n\t\ttry:\n\t\t\t# Check if required fields exist\n\t\t\tassert \"public_key\" in data.keys(), \"Missed public key in parameters\"\n\t\t\tassert \"message\" in data.keys(), \"Missed message in parameters\"\n\t\t\tassert \"signature\" in data.keys(),\"Missed signature in parameters\"\n\t\t\tpublic_key = data[\"public_key\"]\n\t\t\tsignature = data[\"signature\"]\n\t\t\ttimestamp = data.get(\"timestamp\", None)\n\t\t\t\n\t\t\t# Check if\n\t\t\t#assert ManagementSystemHandler.get_time_stamp() == timestamp, \"Timestamps does not match. Try again.\"\n\n\t\texcept Exception as e:\n\t\t\tself.set_status(403)\n\t\t\tself.write({\"error\":403, \"reason\": \"Missing signature \" + str(e)})\n\t\t\traise tornado.web.Finish\n\n\t\telse:\n\t\t\t# Check if message and signature exist\n\t\t\t# If not - return 403 error code\n\t\t\tif not all([message, public_key, signature]):\n\t\t\t\traise tornado.web.HTTPError(403)\n\t\t# If exist - call verifying static method\n\t\ttry:\n\t\t\tlogging.debug(\"\\n[] Try block. Verifying\")\n\t\t\tlogging.debug(message)\n\t\t\tlogging.debug(signature)\n\t\t\tlogging.debug(public_key)\n\t\t\tflag = Qtum.verify_message(message, signature, public_key)\n\t\texcept Exception as e:\n\t\t\t# If public key is not valid or it`s missing - return 404 error\n\t\t\t#self.set_status(403)\n\t\t\t#self.write({\"error\":403, \n\t\t\t#\t\t\t\"reason\":\"Forbidden. Invalid signature.\" + str(e)})\n\t\t\t#raise tornado.web.Finish\n\t\t\tlogging.debug(\"\\n Exception\")\n\t\t\tlogging.debug(str(e))\n\t\t\tpass", "response": "Abstract method.\n\tSignature verifying logic."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cli_frontend(ctx, verbose):\n    printout = True\n    if verbose == 0:\n        verbose = 1\n        printout = False\n\n    # Verbosity is the inverse of logging levels\n    levels = [item for item in BOUSSOLE_LOGGER_CONF]\n    levels.reverse()\n    # Init the logger config\n    root_logger = init_logger(levels[verbose], printout=printout)\n\n    # Init the default context that will be passed to commands\n    ctx.obj = {\n        'verbosity': verbose,\n        'logger': root_logger,\n    }", "response": "This is the main CLI interface for building Sass projects using libsass."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_backend_engine(self, name, **kwargs):\n        if name not in self._engines:\n            msg = \"Given settings backend is unknowed: {}\"\n            raise SettingsBackendError(msg.format(name))\n\n        return self._engines[name](**kwargs)", "response": "Get backend engine from given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates that given paths are not the same.", "response": "def valid_paths(self, *args):\n        \"\"\"\n        Validate that given paths are not the same.\n\n        Args:\n            (string): Path to validate.\n\n        Raises:\n            boussole.exceptions.SettingsInvalidError: If there is more than one\n                occurence of the same path.\n\n        Returns:\n            bool: ``True`` if paths are validated.\n        \"\"\"\n        for i, path in enumerate(args, start=0):\n            cp = list(args)\n            current = cp.pop(i)\n            if current in cp:\n                raise SettingsInvalidError(\"Multiple occurences finded for \"\n                                           \"path: {}\".format(current))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expand(self, basedir, config, sourcedir, targetdir, cwd):\n\n        # Expand home directory if any\n        expanded_basedir = os.path.expanduser(basedir)\n        expanded_config = os.path.expanduser(config)\n        expanded_sourcedir = os.path.expanduser(sourcedir)\n        expanded_targetdir = os.path.expanduser(targetdir)\n\n        # If not absolute, base dir is prepended with current directory\n        if not os.path.isabs(expanded_basedir):\n            expanded_basedir = os.path.join(cwd, expanded_basedir)\n        # Prepend paths with base dir if they are not allready absolute\n        if not os.path.isabs(expanded_config):\n            expanded_config = os.path.join(expanded_basedir,\n                                           expanded_config)\n        if not os.path.isabs(expanded_sourcedir):\n            expanded_sourcedir = os.path.join(expanded_basedir,\n                                              expanded_sourcedir)\n        if not os.path.isabs(expanded_targetdir):\n            expanded_targetdir = os.path.join(expanded_basedir,\n                                              expanded_targetdir)\n\n        # Normalize paths\n        expanded_basedir = os.path.normpath(expanded_basedir)\n        expanded_config = os.path.normpath(expanded_config)\n        expanded_sourcedir = os.path.normpath(expanded_sourcedir)\n        expanded_targetdir = os.path.normpath(expanded_targetdir)\n\n        return (expanded_basedir, expanded_config, expanded_sourcedir,\n                expanded_targetdir)", "response": "Expand paths in the same order as the base directory and configuration files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef commit(self, sourcedir, targetdir, abs_config, abs_sourcedir,\n               abs_targetdir):\n        \"\"\"\n        Commit project structure and configuration file\n\n        Args:\n            sourcedir (string): Source directory path.\n            targetdir (string): Compiled files target directory path.\n            abs_config (string): Configuration file absolute path.\n            abs_sourcedir (string): ``sourcedir`` expanded as absolute path.\n            abs_targetdir (string): ``targetdir`` expanded as absolute path.\n        \"\"\"\n        config_path, config_filename = os.path.split(abs_config)\n\n        if not os.path.exists(config_path):\n            os.makedirs(config_path)\n        if not os.path.exists(abs_sourcedir):\n            os.makedirs(abs_sourcedir)\n        if not os.path.exists(abs_targetdir):\n            os.makedirs(abs_targetdir)\n\n        # Dump settings file\n        self.backend_engine.dump({\n            'SOURCES_PATH': sourcedir,\n            'TARGET_PATH': targetdir,\n            \"LIBRARY_PATHS\": [],\n            \"OUTPUT_STYLES\": \"nested\",\n            \"SOURCE_COMMENTS\": False,\n            \"EXCLUDES\": []\n        }, abs_config, indent=4)", "response": "Commits the project structure and configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the project structure and configuration from given arguments.", "response": "def init(self, basedir, config, sourcedir, targetdir, cwd='', commit=True):\n        \"\"\"\n        Init project structure and configuration from given arguments\n\n        Args:\n            basedir (string): Project base directory used to prepend relative\n                paths. If empty or equal to '.', it will be filled with current\n                directory path.\n            config (string): Settings file path.\n            sourcedir (string): Source directory path.\n            targetdir (string): Compiled files target directory path.\n\n        Keyword Arguments:\n            cwd (string): Current directory path to prepend base dir if empty.\n            commit (bool): If ``False``, directory structure and settings file\n                won't be created.\n\n        Returns:\n            dict: A dict containing expanded given paths.\n        \"\"\"\n        if not basedir:\n            basedir = '.'\n\n        # Expand home directory if any\n        abs_basedir, abs_config, abs_sourcedir, abs_targetdir = self.expand(\n            basedir, config,\n            sourcedir, targetdir,\n            cwd\n        )\n\n        # Valid every paths are ok\n        self.valid_paths(abs_config, abs_sourcedir, abs_targetdir)\n\n        # Create required directory structure\n        if commit:\n            self.commit(sourcedir, targetdir, abs_config, abs_sourcedir,\n                        abs_targetdir)\n\n        return {\n            'basedir': abs_basedir,\n            'config': abs_config,\n            'sourcedir': abs_sourcedir,\n            'targetdir': abs_targetdir,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprepares 1 selenium driver instance per request browsers", "response": "def get_web_drivers(cls, conf, global_capabilities=None):\n        \"\"\"Prepare 1 selenium driver instance per request browsers\n\n        :param conf:\n        :param global_capabilities:\n        :return:\n        \"\"\"\n        web_drivers = []\n        if not global_capabilities:\n            global_capabilities = {}\n        else:\n            global_capabilities = deepcopy(global_capabilities)\n        grid_conf = deepcopy(conf)\n        grid_conf.pop('class', None)\n        request_drivers = grid_conf.pop('request_drivers', [])\n        capabilities = grid_conf.pop('capabilities', {})\n        global_capabilities.update(capabilities)\n        for browser_req in request_drivers:\n            name = 'grid'\n            name = '%s_%s' % (name, browser_req.get('browserName'))\n            name = '%s_%s' % (name, browser_req.get('version', 'lastest'))\n            name = '%s_%s' % (name, browser_req.get('platform', 'ANY'))\n            web_drivers.append(Grid(grid_conf, browser_req, name=name,\n                                    global_capabilities=global_capabilities))\n        return web_drivers"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes app logger to configure its level handler and formatter.", "response": "def init_logger(level, printout=True):\n    \"\"\"\n    Initialize app logger to configure its level/handler/formatter/etc..\n\n    Todo:\n        * A mean to raise click.Abort or sys.exit when CRITICAL is used;\n\n    Args:\n        level (str): Level name (``debug``, ``info``, etc..).\n\n    Keyword Arguments:\n        printout (bool): If False, logs will never be outputed.\n\n    Returns:\n        logging.Logger: Application logger.\n    \"\"\"\n    root_logger = logging.getLogger(\"boussole\")\n    root_logger.setLevel(level)\n\n    # Redirect outputs to the void space, mostly for usage within unittests\n    if not printout:\n        from io import StringIO\n        dummystream = StringIO()\n        handler = logging.StreamHandler(dummystream)\n    # Standard output with colored messages\n    else:\n        handler = logging.StreamHandler()\n        handler.setFormatter(\n            colorlog.ColoredFormatter(\n                '%(asctime)s - %(log_color)s%(message)s',\n                datefmt=\"%H:%M:%S\"\n            )\n        )\n\n    root_logger.addHandler(handler)\n\n    return root_logger"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a lambda function that checks that the original day does not fall on the given weekday.", "response": "def move_if_not_on_dow(original, replacement, dow_not_orig, dow_replacement):\n    \"\"\"\n    Return a lambda function.\n\n    Lambda checks that either the original day does not fall on a given\n    weekday, or that the replacement day does fall on the expected weekday.\n    \"\"\"\n    return lambda x: (\n        (x.hdate.day == original and x.gdate.weekday() != dow_not_orig) or\n        (x.hdate.day == replacement and x.gdate.weekday() == dow_replacement))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_table(table, data):\n\n    fields = data['fields']\n    query = '('\n    indexed_fields = ''\n\n    for key, value in fields.items():\n        non_case_field = value[0][0:value[0].find('(')]\n\n        if non_case_field == 'int':\n            sign = value[0][value[0].find(',') + 1:-1:].strip()\n            if sign == 'signed':\n                field_type = 'Int'\n            else:\n                field_type = 'UInt'\n\n            bits = re.findall('\\d+', value[0])[0]\n            field = key + ' ' + field_type + bits\n            query += field + ','\n\n        elif non_case_field == 'strin':\n            field_type = 'String'\n            field = key + ' ' + field_type\n            query += field + ','\n\n        elif non_case_field == 'float':\n            field_type = 'Float'\n            bits = re.findall('\\d+', value[0])[0]\n            field = key + ' ' + field_type + bits\n            query += field + ','\n\n        if value[1] == 'yes':\n            indexed_fields += key + ','\n\n    query = query[:-1:] + f\",date Date) ENGINE = MergeTree(date, ({indexed_fields} date), 8192)\"\n\n    client.execute(f\"CREATE TABLE {table} {query}\")", "response": "Create table with defined name and fields\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert_into_table(table, data):\n\n    fields = data['fields']\n    fields['date'] = datetime.datetime.now().date()\n\n    query = '('\n\n    for key in fields.keys():\n        query += key + ','\n\n    query = query[:-1:] + \")\"\n\n    client.execute(f\"INSERT INTO {table} {query} VALUES\", [tuple(fields.values())])", "response": "SQL query for inserting data into table\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_moc(moc, order=None, antialias=0, filename=None,\n             projection='cart', color='blue', title='', coord_sys='C',\n             graticule=True, **kwargs):\n    \"\"\"Plot a MOC using Healpy.\n\n    This generates a plot of the MOC at the specified order, or the MOC's\n    current order if this is not specified.  The MOC is flattened at an order\n    of `order + antialias` to generate intermediate color levels.\n\n    :param order: HEALPix order at which to generate the plot.\n\n    :param antialias: number of additional HEALPix orders to use for\n        intermediate color levels.  (There can be `4 ** antialias` levels.)\n\n    :param filename: file in which to save plot.  If not specified then\n        the plot is shown with `plt.show()`.\n\n    :param projection: map projection to be used --- can be shortened to\n        4 characters.  One of:\n\n            * `'cart[esian]'` (uses `healpy.visufunc.cartview`)\n            * `'moll[weide]'` (uses `healpy.visufunc.mollview`)\n            * `'gnom[onic]'` (uses `healpy.visufunc.gnomview`)\n\n    :param color: color scheme.\n        One of:\n\n            * `'blue'`\n            * `'green'`\n            * `'red'`\n            * `'black'`\n\n    :param title: title of the plot.\n\n    :param coord_sys: Healpy coordinate system code for the desired plot\n        coordinates.  One of:\n\n            * `'C'` --- Celestial (equatorial)\n            * `'G'` --- Galactic\n            * `'E'` --- Ecliptic\n\n    :param graticule: whether or not to draw a graticule.\n\n    :param \\*\\*kwargs: passed to the selected Healpy plotting function.\n    \"\"\"\n\n    # Process arguments.\n    plotargs = {'xsize': 3200, 'cbar': False, 'notext': True}\n\n    if order is None:\n        order = moc.order\n\n    if projection.startswith('cart'):\n        plotter = healpy.visufunc.cartview\n    elif projection.startswith('moll'):\n        plotter = healpy.visufunc.mollview\n    elif projection.startswith('gnom'):\n        plotter = healpy.visufunc.gnomview\n    else:\n        raise ValueError('Unknown projection: {0}'.format(projection))\n\n    if color == 'blue':\n        plotargs['cmap'] = LinearSegmentedColormap.from_list(\n            'white-blue', ['#FFFFFF', '#0000AA'])\n    elif color == 'green':\n        plotargs['cmap'] = LinearSegmentedColormap.from_list(\n            'white-green', ['#FFFFFF', '#008800'])\n    elif color == 'red':\n        plotargs['cmap'] = LinearSegmentedColormap.from_list(\n            'white-red', ['#FFFFFF', '#FF0000'])\n    elif color == 'black':\n        plotargs['cmap'] = LinearSegmentedColormap.from_list(\n            'white-black', ['#FFFFFF', '#000000'])\n    else:\n        raise ValueError('Unknown color: {0}'.format(color))\n\n    if coord_sys == 'C':\n        pass\n    elif coord_sys == 'G':\n        plotargs['coord'] = ('C', 'G')\n    elif coord_sys == 'E':\n        plotargs['coord'] = ('C', 'E')\n    else:\n        raise ValueError('Unknown coordinate system: {0}'.format(coord_sys))\n\n    # Any other arguments are passed the Healpy plotter directly.\n    plotargs.update(kwargs)\n\n    # Create a Numpy array which is zero for points outside the MOC and one\n    # for points inside the MOC.\n    map = np.zeros(12 * 4 ** order)\n    antialias_shift = 2 * antialias\n\n    for cell in moc.flattened(order + antialias):\n        map[cell >> antialias_shift] += 1.0\n\n    # Plot the Numpy array using Healpy.\n    plotter(map, nest=True, title=title, **plotargs)\n\n    if graticule:\n        healpy.visufunc.graticule()\n\n    if filename is not None:\n        plt.savefig(filename)\n    else:\n        plt.show()", "response": "Plot a MOC using Healpy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list containing first n digits of Pi", "response": "def getTauLambert(n):\n    \"\"\"Returns a list containing first n digits of Pi\n    \"\"\"\n    myTau = tauGenLambert()\n    result = []\n    if n > 0:\n        result += [next(myTau) for i in range(n)]\n    myTau.close()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccepting jsorpc post request.", "response": "def post(self):\n        \"\"\"Accepts jsorpc post request.\n        Retrieves data from request body.\n        \"\"\"\n        # type(data) = dict\n        data = json.loads(self.request.body.decode())\n        # type(method) = str\n        method = data[\"method\"]\n        # type(params) = dict\n        params = data[\"params\"]\n        if method == \"sendmail\":\n            response = dispatch([sendmail],{'jsonrpc': '2.0', 'method': 'sendmail', 'params': [params], 'id': 1})\n            #self.write(response)\n        else:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_server(function, port, authkey, qsize=None):\n    QueueManager.register('get_job_q',\n        callable=partial(return_arg, Queue(maxsize=qsize)))\n    QueueManager.register('get_result_q',\n        callable=partial(return_arg, Queue(maxsize=qsize)))\n    QueueManager.register('get_function',\n        callable=partial(return_arg, function))\n    QueueManager.register('q_closed',\n        callable=partial(return_arg, SharedConst(False)))\n\n    # on windows host='' doesn't work, but 'localhost' breaks\n    #   remote connections. Documentation terrible in this respect.\n    #   So we're not supporting distributed compute on windows.\n    host = 'localhost' if os.name == 'nt' else ''\n    manager = QueueManager(address=(host, port), authkey=authkey)\n    manager.start()\n    return manager", "response": "Create a server that can read the stored function and apply it to items in the output queue and post back to the input queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_client(ip, port, authkey):\n    QueueManager.register('get_job_q')\n    QueueManager.register('get_result_q')\n    QueueManager.register('get_function')\n    QueueManager.register('q_closed')\n\n    manager = QueueManager(address=(ip, port), authkey=authkey)\n    manager.connect()\n    return manager", "response": "Create a manager to connect to our server manager"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompile Sass project sources to CSS", "response": "def compile_command(context, backend, config):\n    \"\"\"\n    Compile Sass project sources to CSS\n    \"\"\"\n    logger = logging.getLogger(\"boussole\")\n    logger.info(u\"Building project\")\n\n    # Discover settings file\n    try:\n        discovering = Discover(backends=[SettingsBackendJson,\n                                         SettingsBackendYaml])\n        config_filepath, config_engine = discovering.search(\n            filepath=config,\n            basedir=os.getcwd(),\n            kind=backend\n        )\n\n        project = ProjectBase(backend_name=config_engine._kind_name)\n        settings = project.backend_engine.load(filepath=config_filepath)\n    except BoussoleBaseException as e:\n        logger.critical(six.text_type(e))\n        raise click.Abort()\n\n    logger.debug(u\"Settings file: {} ({})\".format(\n                 config_filepath, config_engine._kind_name))\n    logger.debug(u\"Project sources directory: {}\".format(\n                 settings.SOURCES_PATH))\n    logger.debug(u\"Project destination directory: {}\".format(\n                 settings.TARGET_PATH))\n    logger.debug(u\"Exclude patterns: {}\".format(\n                 settings.EXCLUDES))\n\n    # Find all sources with their destination path\n    try:\n        compilable_files = ScssFinder().mirror_sources(\n            settings.SOURCES_PATH,\n            targetdir=settings.TARGET_PATH,\n            excludes=settings.EXCLUDES\n        )\n    except BoussoleBaseException as e:\n        logger.error(six.text_type(e))\n        raise click.Abort()\n\n    # Build all compilable stylesheets\n    compiler = SassCompileHelper()\n    errors = 0\n    for src, dst in compilable_files:\n        logger.debug(u\"Compile: {}\".format(src))\n\n        output_opts = {}\n        success, message = compiler.safe_compile(settings, src, dst)\n\n        if success:\n            logger.info(u\"Output: {}\".format(message), **output_opts)\n        else:\n            errors += 1\n            logger.error(message)\n\n    # Ensure correct exit code if error has occured\n    if errors:\n        raise click.Abort()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the XOR checksum of a packet in string format", "response": "def _checksum(self, packet):\n        '''calculate the XOR checksum of a packet in string format'''\n        xorsum = 0\n        for s in packet:\n            xorsum ^= ord(s)\n        return xorsum"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef was_packet_accepted(self, packet):\n        '''parse the \"command\" byte from the response packet to get a \"response code\"'''\n        self._validatepacket(packet)\n        cmd = ord(packet[2])\n        if cmd == Vendapin.ACK: # Accepted/Positive Status\n            return True\n        elif cmd == Vendapin.NAK: # Rejected/Negative Status\n            print('NAK - Rejected/Negative Status')\n            return False\n        elif cmd == Vendapin.INC: # Incomplete Command Packet\n            raise Exception('INC - Incomplete Command Packet')\n        elif cmd == Vendapin.UNR: # Unrecognized Command Packet\n            raise Exception('UNR - Unrecognized Command Packet')\n        elif cmd == Vendapin.CER: # Data Packet Checksum Error\n            raise Exception('CER - Data Packet Checksum Error')\n        else:\n            raise Exception('Received bad CMD in response from card dispenser')", "response": "parse the command byte from the response packet to get a response code"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parsedata(self, packet):\n        '''parse the data section of a packet, it can range from 0 to many bytes'''\n        data = []\n        datalength = ord(packet[3])\n        position = 4\n        while position < datalength + 4:\n            data.append(packet[position])\n            position += 1\n        return data", "response": "parse the data section of a packet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sendcommand(self, command, datalength=0, data=None):\n        '''send a packet in the vendapin format'''\n        packet = chr(Vendapin.STX) + chr(Vendapin.ADD) + chr(command) + chr(datalength)\n        if datalength > 0:\n            packet += chr(data)\n        packet += chr(Vendapin.ETX)\n        sendpacket = packet + chr(self._checksum(packet))\n        self._printpacket(sendpacket)\n        self.serial.write(sendpacket)", "response": "send a packet in the vendapin format"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequest the status of the card dispenser and return the status code", "response": "def request_status(self):\n        '''request the status of the card dispenser and return the status code'''\n        self.sendcommand(Vendapin.REQUEST_STATUS)\n        # wait for the reply\n        time.sleep(1)\n        response = self.receivepacket()\n        if self.was_packet_accepted(response):\n            return Vendapin.READY\n        else:\n            return self.parsedata(response)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dispense(self):\n        '''dispense a card if ready, otherwise throw an Exception'''\n        self.sendcommand(Vendapin.DISPENSE)\n        # wait for the reply\n        time.sleep(1)\n        # parse the reply\n        response = self.receivepacket()\n        print('Vendapin.dispense(): ' + str(response))\n        if not self.was_packet_accepted(response):\n            raise Exception('DISPENSE packet not accepted: ' + str(response))\n        return self.parsedata(response)[0]", "response": "dispense a card if ready return the ID of the card otherwise throw an Exception"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting the card dispense either soft or hard based on boolean 2nd arg", "response": "def reset(self, hard=False):\n        '''reset the card dispense, either soft or hard based on boolean 2nd arg'''\n        if hard:\n            self.sendcommand(Vendapin.RESET, 1, 0x01)\n            time.sleep(2)\n        else:\n            self.sendcommand(Vendapin.RESET)\n            time.sleep(2)\n            # parse the reply\n            response = self.receivepacket()\n            print('Vendapin.reset(soft): ' + str(response))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating the terraform configuration.", "response": "def _validate(self):\n        \"\"\"\n        Confirm that we can run terraform (by calling its version action)\n        and then validate the configuration.\n        \"\"\"\n        try:\n            out = self._run_tf('version')\n        except:\n            raise Exception('ERROR: executing \\'%s version\\' failed; is '\n                            'terraform installed and is the path to it (%s) '\n                            'correct?' % (self.tf_path, self.tf_path))\n        res = re.search(r'Terraform v(\\d+)\\.(\\d+)\\.(\\d+)', out)\n        if res is None:\n            logger.error('Unable to determine terraform version; will not '\n                         'validate config. Note that this may cause problems '\n                         'when using older Terraform versions. This program '\n                         'requires Terraform >= 0.6.16.')\n            return\n        self.tf_version = (\n            int(res.group(1)), int(res.group(2)), int(res.group(3))\n        )\n        logger.debug('Terraform version: %s', self.tf_version)\n        if self.tf_version < (0, 6, 16):\n            raise Exception('This program requires Terraform >= 0.6.16, as '\n                            'that version introduces a bug fix for working '\n                            'with api_gateway_integration_response resources; '\n                            'see: https://github.com/hashicorp/terraform/pull'\n                            '/5893')\n        try:\n            self._run_tf('validate', ['.'])\n        except Exception as ex:\n            logger.critical(\"Terraform config validation failed. \"\n                            \"This is almost certainly a bug in \"\n                            \"webhook2lambda2sqs; please re-run with '-vv' and \"\n                            \"open a bug at <https://github.com/jantman/\"\n                            \"webhook2lambda2sqs/issues>. Exception: %s\", ex)\n            raise Exception(\n                'ERROR: Terraform config validation failed: %s' % ex\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate arguments for the remote config.", "response": "def _args_for_remote(self):\n        \"\"\"\n        Generate arguments for 'terraform remote config'. Return None if\n        not present in configuration.\n\n        :return: list of args for 'terraform remote config' or None\n        :rtype: :std:term:`list`\n        \"\"\"\n        conf = self.config.get('terraform_remote_state')\n        if conf is None:\n            return None\n        args = ['-backend=%s' % conf['backend']]\n        for k, v in sorted(conf['config'].items()):\n            args.append('-backend-config=\"%s=%s\"' % (k, v))\n        return args"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the terraform remote config.", "response": "def _set_remote(self, stream=False):\n        \"\"\"\n        Call :py:meth:`~._args_for_remote`; if the return value is not None,\n        execute 'terraform remote config' with those arguments and ensure it\n        exits 0.\n\n        :param stream: whether or not to stream TF output in realtime\n        :type stream: bool\n        \"\"\"\n        args = self._args_for_remote()\n        if args is None:\n            logger.debug('_args_for_remote() returned None; not configuring '\n                         'terraform remote')\n            return\n        logger.warning('Setting terraform remote config: %s', ' '.join(args))\n        args = ['config'] + args\n        self._run_tf('remote', cmd_args=args, stream=stream)\n        logger.info('Terraform remote configured.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _run_tf(self, cmd, cmd_args=[], stream=False):\n        args = [self.tf_path, cmd] + cmd_args\n        arg_str = ' '.join(args)\n        logger.info('Running terraform command: %s', arg_str)\n        out, retcode = run_cmd(arg_str, stream=stream)\n        if retcode != 0:\n            logger.critical('Terraform command (%s) failed with exit code '\n                            '%d:\\n%s', arg_str, retcode, out)\n            raise Exception('terraform %s failed' % cmd)\n        return out", "response": "Run a single terraform command via py. utils. run_cmd"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun terraform taint to taint the resource.", "response": "def _taint_deployment(self, stream=False):\n        \"\"\"\n        Run 'terraform taint aws_api_gateway_deployment.depl' to taint the\n        deployment resource. This is a workaround for\n        https://github.com/hashicorp/terraform/issues/6613\n\n        :param stream: whether or not to stream TF output in realtime\n        :type stream: bool\n        \"\"\"\n        args = ['aws_api_gateway_deployment.depl']\n        logger.warning('Running terraform taint: %s as workaround for '\n                       '<https://github.com/hashicorp/terraform/issues/6613>',\n                       ' '.join(args))\n        out = self._run_tf('taint', cmd_args=args, stream=stream)\n        if stream:\n            logger.warning('Terraform taint finished successfully.')\n        else:\n            logger.warning(\"Terraform taint finished successfully:\\n%s\", out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply(self, stream=False):\n        self._setup_tf(stream=stream)\n        try:\n            self._taint_deployment(stream=stream)\n        except Exception:\n            pass\n        args = ['-input=false', '-refresh=true', '.']\n        logger.warning('Running terraform apply: %s', ' '.join(args))\n        out = self._run_tf('apply', cmd_args=args, stream=stream)\n        if stream:\n            logger.warning('Terraform apply finished successfully.')\n        else:\n            logger.warning(\"Terraform apply finished successfully:\\n%s\", out)\n        self._show_outputs()", "response": "Run a terraform apply command"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _show_outputs(self):\n        outs = self._get_outputs()\n        print(\"\\n\\n\" + '=> Terraform Outputs:')\n        for k in sorted(outs):\n            print('%s = %s' % (k, outs[k]))", "response": "Print the terraform outputs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dict of the terraform outputs.", "response": "def _get_outputs(self):\n        \"\"\"\n        Return a dict of the terraform outputs.\n\n        :return: dict of terraform outputs\n        :rtype: dict\n        \"\"\"\n        if self.tf_version >= (0, 7, 0):\n            logger.debug('Running: terraform output')\n            res = self._run_tf('output', cmd_args=['-json'])\n            outs = json.loads(res.strip())\n            res = {}\n            for k in outs.keys():\n                if isinstance(outs[k], type({})):\n                    res[k] = outs[k]['value']\n                else:\n                    res[k] = outs[k]\n            logger.debug('Terraform outputs: %s', res)\n            return res\n        logger.debug('Running: terraform output')\n        res = self._run_tf('output')\n        outs = {}\n        for line in res.split(\"\\n\"):\n            line = line.strip()\n            if line == '':\n                continue\n            parts = line.split(' = ', 1)\n            outs[parts[0]] = parts[1]\n        logger.debug('Terraform outputs: %s', outs)\n        return outs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a terraform destroy", "response": "def destroy(self, stream=False):\n        \"\"\"\n        Run a 'terraform destroy'\n\n        :param stream: whether or not to stream TF output in realtime\n        :type stream: bool\n        \"\"\"\n        self._setup_tf(stream=stream)\n        args = ['-refresh=true', '-force', '.']\n        logger.warning('Running terraform destroy: %s', ' '.join(args))\n        out = self._run_tf('destroy', cmd_args=args, stream=stream)\n        if stream:\n            logger.warning('Terraform destroy finished successfully.')\n        else:\n            logger.warning(\"Terraform destroy finished successfully:\\n%s\", out)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new connection to rethinkdb", "response": "def new_conn(self):\n        \"\"\"\n        Create a new ConnectionWrapper instance\n        :return:\n        \"\"\"\n        \"\"\"\n        :return:\n        \"\"\"\n        logger.debug(\"Opening new connection to rethinkdb with args=%s\" % self._conn_args)\n        return ConnectionWrapper(self._pool, **self._conn_args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef acquire(self, timeout=None):\n        self._pool_lock.acquire()\n        if timeout is None:\n            conn_wrapper = self._pool.get_nowait()\n        else:\n            conn_wrapper = self._pool.get(True, timeout)\n        self._current_acquired += 1\n        self._pool_lock.release()\n        return conn_wrapper.connection", "response": "Acquire a connection from the pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef release(self, conn):\n        self._pool_lock.acquire()\n        self._pool.put(ConnectionWrapper(self._pool, conn))\n        self._current_acquired -= 1\n        self._pool_lock.release()", "response": "Release a previously acquired connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef release_pool(self):\n        if self._current_acquired > 0:\n            raise PoolException(\"Can't release pool: %d connection(s) still acquired\" % self._current_acquired)\n        while not self._pool.empty():\n            conn = self.acquire()\n            conn.close()\n        if self._cleanup_thread is not None:\n            self._thread_event.set()\n            self._cleanup_thread.join()\n        self._pool = None", "response": "Release all the connection to the pool and all its connections."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef index(self):\n        self._event_error = False\n\n        try:\n            compilable_files = self.finder.mirror_sources(\n                self.settings.SOURCES_PATH,\n                targetdir=self.settings.TARGET_PATH,\n                excludes=self.settings.EXCLUDES\n            )\n            self.compilable_files = dict(compilable_files)\n            self.source_files = self.compilable_files.keys()\n\n            # Init inspector and do first inspect\n            self.inspector.reset()\n            self.inspector.inspect(\n                *self.source_files,\n                library_paths=self.settings.LIBRARY_PATHS\n            )\n        except BoussoleBaseException as e:\n            self._event_error = True\n            self.logger.error(six.text_type(e))", "response": "Index all sources in the current project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compile_source(self, sourcepath):\n        relpath = os.path.relpath(sourcepath, self.settings.SOURCES_PATH)\n\n        conditions = {\n            'sourcedir': None,\n            'nopartial': True,\n            'exclude_patterns': self.settings.EXCLUDES,\n            'excluded_libdirs': self.settings.LIBRARY_PATHS,\n        }\n        if self.finder.match_conditions(sourcepath, **conditions):\n            destination = self.finder.get_destination(\n                relpath,\n                targetdir=self.settings.TARGET_PATH\n            )\n\n            self.logger.debug(u\"Compile: {}\".format(sourcepath))\n            success, message = self.compiler.safe_compile(\n                self.settings,\n                sourcepath,\n                destination\n            )\n\n            if success:\n                self.logger.info(u\"Output: {}\".format(message))\n            else:\n                self.logger.error(message)\n\n            return sourcepath, destination\n\n        return None", "response": "Compile a source file to its destination using the current project settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compile_dependencies(self, sourcepath, include_self=False):\n        items = self.inspector.parents(sourcepath)\n\n        # Also add the current event related path\n        if include_self:\n            items.add(sourcepath)\n\n        return filter(None, [self.compile_source(item) for item in items])", "response": "Applies compile on all dependencies of a given sourcepath."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when a file or a directory is moved or renamed.", "response": "def on_moved(self, event):\n        \"\"\"\n        Called when a file or a directory is moved or renamed.\n\n        Many editors don't directly change a file, instead they make a\n        transitional file like ``*.part`` then move it to the final filename.\n\n        Args:\n            event: Watchdog event, either ``watchdog.events.DirMovedEvent`` or\n                ``watchdog.events.FileModifiedEvent``.\n        \"\"\"\n        if not self._event_error:\n            # We are only interested for final file, not transitional file\n            # from editors (like *.part)\n            pathtools_options = {\n                'included_patterns': self.patterns,\n                'excluded_patterns': self.ignore_patterns,\n                'case_sensitive': self.case_sensitive,\n            }\n            # Apply pathtool matching on destination since Watchdog only\n            # automatically apply it on source\n            if match_path(event.dest_path, **pathtools_options):\n                self.logger.info(u\"Change detected from a move on: %s\",\n                                 event.dest_path)\n                self.compile_dependencies(event.dest_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when a new file or directory is created.", "response": "def on_created(self, event):\n        \"\"\"\n        Called when a new file or directory is created.\n\n        Todo:\n            This should be also used (extended from another class?) to watch\n            for some special name file (like \".boussole-watcher-stop\" create to\n            raise a KeyboardInterrupt, so we may be able to unittest the\n            watcher (click.CliRunner is not able to send signal like CTRL+C\n            that is required to watchdog observer loop)\n\n        Args:\n            event: Watchdog event, either ``watchdog.events.DirCreatedEvent``\n                or ``watchdog.events.FileCreatedEvent``.\n        \"\"\"\n        if not self._event_error:\n            self.logger.info(u\"Change detected from a create on: %s\",\n                             event.src_path)\n\n            self.compile_dependencies(event.src_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when a file or directory is modified.", "response": "def on_modified(self, event):\n        \"\"\"\n        Called when a file or directory is modified.\n\n        Args:\n            event: Watchdog event, ``watchdog.events.DirModifiedEvent`` or\n                ``watchdog.events.FileModifiedEvent``.\n        \"\"\"\n        if not self._event_error:\n            self.logger.info(u\"Change detected from an edit on: %s\",\n                             event.src_path)\n\n            self.compile_dependencies(event.src_path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_deleted(self, event):\n        if not self._event_error:\n            self.logger.info(u\"Change detected from deletion of: %s\",\n                             event.src_path)\n            # Never try to compile the deleted source\n            self.compile_dependencies(event.src_path, include_self=False)", "response": "Called when a file or directory is deleted."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile_dependencies(self, sourcepath, include_self=True):\n        return super(SassProjectEventHandler, self).compile_dependencies(\n            sourcepath,\n            include_self=include_self\n        )", "response": "A base method that returns a list of sources that are dependencies of the specified sourcepath."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning requests. get in a cache wrapper.", "response": "def requests_get(url):\n    \"\"\" Run :func:`requests.get` in a ``cached()`` wrapper.\n\n    The cache wrapper uses the default timeout (environment variable\n    ``PYTHON_FTR_CACHE_TIMEOUT``, 3 days by default).\n\n    It is used in :func:`ftr_process`.\n    \"\"\"\n\n    LOGGER.info(u'Fetching %s\u2026', url)\n    return requests.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sanitize_next_page_link(next_page_link, base_url):\n\n    if not next_page_link.startswith(u'http'):\n        if next_page_link.startswith(u'?'):\n            # We have some \"?current_page=2\" scheme.\n            next_page_link = base_url + next_page_link\n\n        if next_page_link.startswith(u'/'):\n            # We have a server-relative path.\n\n            try:\n                proto, host_and_port, remaining = split_url(base_url)\n\n            except:\n                LOGGER.error(u'Could not split \u201c%s\u201d to get schema/host parts, '\n                             u'next_page_link \u201c%s\u201d will be unusable.',\n                             base_url, next_page_link)\n\n            else:\n                next_page_link = '{0}://{1}{2}'.format(proto,\n                                                       host_and_port,\n                                                       next_page_link)\n        else:\n            LOGGER.warning(u'Unimplemented scheme in '\n                           u'next_page_link %s',\n                           next_page_link)\n\n    return next_page_link", "response": "Convert relative links or query_string only links to absolute URLs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ftr_process(url=None, content=None, config=None, base_url=None):\n\n    if url is None and content is None and config is None:\n        raise RuntimeError('At least one of url or the couple content/config '\n                           'argument must be present.')\n\n    if content is not None and url is None and config is None:\n        raise RuntimeError('Passing content only will not give any result.')\n\n    if content is None:\n        if url is None:\n            raise RuntimeError('When content is unset, url must be set.')\n\n        try:\n            result = requests_get(url)\n\n            if result.status_code != requests.codes.ok:\n                LOGGER.error(u'Wrong status code in return while getting '\n                             u'\u201c%s\u201d.', url)\n                return None\n\n            # Override before accessing result.text\u00a0; see `requests` doc.\n            result.encoding = detect_encoding_from_requests_response(result)\n\n            LOGGER.info(u'Downloaded %s bytes as %s text.',\n                        len(result.text), result.encoding)\n\n            # result.text is always unicode\n            content = result.text\n\n        except:\n            LOGGER.error(u'Content could not be fetched from URL %s.', url)\n            raise\n\n    if config is None:\n        # This can eventually raise SiteConfigNotFound\n        config_string, matched_host = ftr_get_config(url)\n        config = SiteConfig(site_config_text=config_string, host=matched_host)\n\n    extractor = ContentExtractor(config)\n\n    if base_url is None:\n        base_url = url\n\n    if extractor.process(html=content):\n\n        # This is recursive. Yeah.\n        if extractor.next_page_link is not None:\n\n            next_page_link = sanitize_next_page_link(extractor.next_page_link,\n                                                     base_url)\n\n            next_extractor = ftr_process(url=next_page_link,\n                                         base_url=base_url)\n\n            extractor.body += next_extractor.body\n\n            extractor.next_page_link = [next_page_link]\n\n            if next_extractor.next_page_link is not None:\n                extractor.next_page_link.extend(next_extractor.next_page_link)\n\n        return extractor\n\n    return None", "response": "u Process an URL content and config."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hebrew_number(num, hebrew=True, short=False):\n    if not hebrew:\n        return str(num)\n    if not 0 <= num < 10000:\n        raise ValueError('num must be between 0 to 9999, got:{}'.format(num))\n    hstring = u\"\"\n    if num >= 1000:\n        hstring += htables.DIGITS[0][num // 1000]\n        hstring += u\"' \"\n        num = num % 1000\n    while num >= 400:\n        hstring += htables.DIGITS[2][4]\n        num = num - 400\n    if num >= 100:\n        hstring += htables.DIGITS[2][num // 100]\n        num = num % 100\n    if num >= 10:\n        if num in [15, 16]:\n            num = num - 9\n        hstring += htables.DIGITS[1][num // 10]\n        num = num % 10\n    if num > 0:\n        hstring += htables.DIGITS[0][num]\n    # possibly add the ' and \" to hebrew numbers\n    if not short:\n        if len(hstring) < 2:\n            hstring += u\"'\"\n        else:\n            hstring = hstring[:-1] + u'\"' + hstring[-1]\n    return hstring", "response": "Return a string representation of a HEBWW number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_omer_string(omer):  # pylint: disable=too-many-branches\n    # TODO: The following function should be simplified (see pylint)\n    tens = [u\"\", u\"\u05e2\u05e9\u05e8\u05d4\", u\"\u05e2\u05e9\u05e8\u05d9\u05dd\", u\"\u05e9\u05dc\u05d5\u05e9\u05d9\u05dd\", u\"\u05d0\u05e8\u05d1\u05e2\u05d9\u05dd\"]\n    ones = [u\"\", u\"\u05d0\u05d7\u05d3\", u\"\u05e9\u05e0\u05d9\u05dd\", u\"\u05e9\u05dc\u05d5\u05e9\u05d4\", u\"\u05d0\u05e8\u05d1\u05e2\u05d4\", u\"\u05d7\u05de\u05e9\u05d4\",\n            u\"\u05e9\u05e9\u05d4\", u\"\u05e9\u05d1\u05e2\u05d4\", u\"\u05e9\u05de\u05d5\u05e0\u05d4\", u\"\u05ea\u05e9\u05e2\u05d4\"]\n    if not 0 < omer < 50:\n        raise ValueError('Invalid Omer day: {}'.format(omer))\n    ten = omer // 10\n    one = omer % 10\n    omer_string = u'\u05d4\u05d9\u05d5\u05dd '\n    if 10 < omer < 20:\n        omer_string += ones[one] + u' \u05e2\u05e9\u05e8'\n    elif omer > 9:\n        omer_string += ones[one]\n        if one:\n            omer_string += u' \u05d5'\n    if omer > 2:\n        if omer > 20 or omer in [10, 20]:\n            omer_string += tens[ten]\n        if omer < 11:\n            omer_string += ones[one] + u' \u05d9\u05de\u05d9\u05dd '\n        else:\n            omer_string += u' \u05d9\u05d5\u05dd '\n    elif omer == 1:\n        omer_string += u'\u05d9\u05d5\u05dd \u05d0\u05d7\u05d3 '\n    else:  # omer == 2\n        omer_string += u'\u05e9\u05e0\u05d9 \u05d9\u05de\u05d9\u05dd '\n    if omer > 6:\n        omer_string += u'\u05e9\u05d4\u05dd '\n        weeks = omer // 7\n        days = omer % 7\n        if weeks > 2:\n            omer_string += ones[weeks] + u' \u05e9\u05d1\u05d5\u05e2\u05d5\u05ea '\n        elif weeks == 1:\n            omer_string += u'\u05e9\u05d1\u05d5\u05e2 \u05d0\u05d7\u05d3 '\n        else:  # weeks == 2\n            omer_string += u'\u05e9\u05e0\u05d9 \u05e9\u05d1\u05d5\u05e2\u05d5\u05ea '\n        if days:\n            omer_string += u'\u05d5'\n            if days > 2:\n                omer_string += ones[days] + u' \u05d9\u05de\u05d9\u05dd '\n            elif days == 1:\n                omer_string += u'\u05d9\u05d5\u05dd \u05d0\u05d7\u05d3 '\n            else:  # days == 2\n                omer_string += u'\u05e9\u05e0\u05d9 \u05d9\u05de\u05d9\u05dd '\n    omer_string += u'\u05dc\u05e2\u05d5\u05de\u05e8'\n    return omer_string", "response": "Return a string representing the count of the Omer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the hebrew date.", "response": "def hdate(self):\n        \"\"\"Return the hebrew date.\"\"\"\n        if self._last_updated == \"hdate\":\n            return self._hdate\n        return conv.jdn_to_hdate(self._jdn)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the dates of the HDate object based on a given Hebrew date.", "response": "def hdate(self, date):\n        \"\"\"Set the dates of the HDate object based on a given Hebrew date.\"\"\"\n        # Sanity checks\n        if date is None and isinstance(self.gdate, datetime.date):\n            # Calculate the value since gdate has been set\n            date = self.hdate\n\n        if not isinstance(date, HebrewDate):\n            raise TypeError('date: {} is not of type HebrewDate'.format(date))\n        if not 0 < date.month < 15:\n            raise ValueError(\n                'month ({}) legal values are 1-14'.format(date.month))\n        if not 0 < date.day < 31:\n            raise ValueError('day ({}) legal values are 1-31'.format(date.day))\n\n        self._last_updated = \"hdate\"\n        self._hdate = date"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gdate(self):\n        if self._last_updated == \"gdate\":\n            return self._gdate\n        return conv.jdn_to_gdate(self._jdn)", "response": "Return the Gregorian date for the given Hebrew date object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _jdn(self):\n        if self._last_updated == \"gdate\":\n            return conv.gdate_to_jdn(self.gdate)\n        return conv.hdate_to_jdn(self.hdate)", "response": "Return the Julian date number for the given date."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the hebrew date string.", "response": "def hebrew_date(self):\n        \"\"\"Return the hebrew date string.\"\"\"\n        return u\"{} {} {}\".format(\n            hebrew_number(self.hdate.day, hebrew=self.hebrew),   # Day\n            htables.MONTHS[self.hdate.month - 1][self.hebrew],   # Month\n            hebrew_number(self.hdate.year, hebrew=self.hebrew))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef holiday_description(self):\n        entry = self._holiday_entry()\n        desc = entry.description\n        return desc.hebrew.long if self.hebrew else desc.english", "response": "Return the holiday description."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _holiday_entry(self):\n        holidays_list = self.get_holidays_for_year()\n        holidays_list = [\n            holiday for holiday, holiday_hdate in holidays_list if\n            holiday_hdate.hdate == self.hdate\n        ]\n        assert len(holidays_list) <= 1\n\n        # If anything is left return it, otherwise return the \"NULL\" holiday\n        return holidays_list[0] if holidays_list else htables.HOLIDAYS[0]", "response": "Return the abstract holiday information from holidays table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rosh_hashana_dow(self):\n        jdn = conv.hdate_to_jdn(HebrewDate(self.hdate.year, Months.Tishrei, 1))\n        return (jdn + 1) % 7 + 1", "response": "Return the Hebrew day of week for Rosh Hashana."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pesach_dow(self):\n        jdn = conv.hdate_to_jdn(HebrewDate(self.hdate.year, Months.Nisan, 15))\n        return (jdn + 1) % 7 + 1", "response": "Return the first day of week for Pesach."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef omer_day(self):\n        first_omer_day = HebrewDate(self.hdate.year, Months.Nisan, 16)\n        omer_day = self._jdn - conv.hdate_to_jdn(first_omer_day) + 1\n        if not 0 < omer_day < 50:\n            return 0\n        return omer_day", "response": "Return the day of the Omer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef next_day(self):\n        return HDate(self.gdate + datetime.timedelta(1), self.diaspora,\n                     self.hebrew)", "response": "Return the HDate for the next day."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the HDate for the previous day.", "response": "def previous_day(self):\n        \"\"\"Return the HDate for the previous day.\"\"\"\n        return HDate(self.gdate + datetime.timedelta(-1), self.diaspora,\n                     self.hebrew)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the HDate for either the upcoming or current Shabbat.", "response": "def upcoming_shabbat(self):\n        \"\"\"Return the HDate for either the upcoming or current Shabbat.\n\n        If it is currently Shabbat, returns the HDate of the Saturday.\n        \"\"\"\n        if self.is_shabbat:\n            return self\n        # If it's Sunday, fast forward to the next Shabbat.\n        saturday = self.gdate + datetime.timedelta(\n            (12 - self.gdate.weekday()) % 7)\n        return HDate(saturday, diaspora=self.diaspora, hebrew=self.hebrew)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the HDate for the upcoming or current Shabbat or Yom Tov.", "response": "def upcoming_shabbat_or_yom_tov(self):\n        \"\"\"Return the HDate for the upcoming or current Shabbat or Yom Tov.\n\n        If it is currently Shabbat, returns the HDate of the Saturday.\n        If it is currently Yom Tov, returns the HDate of the first day\n        (rather than \"leil\" Yom Tov). To access Leil Yom Tov, use\n        upcoming_shabbat_or_yom_tov.previous_day.\n        \"\"\"\n        if self.is_shabbat or self.is_yom_tov:\n            return self\n\n        if self.upcoming_yom_tov < self.upcoming_shabbat:\n            return self.upcoming_yom_tov\n        return self.upcoming_shabbat"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef first_day(self):\n        day_iter = self\n        while (day_iter.previous_day.is_yom_tov or\n               day_iter.previous_day.is_shabbat):\n            day_iter = day_iter.previous_day\n        return day_iter", "response": "Return the first day of the HDate."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef last_day(self):\n        day_iter = self\n        while day_iter.next_day.is_yom_tov or day_iter.next_day.is_shabbat:\n            day_iter = day_iter.next_day\n        return day_iter", "response": "Return the last day of the HDate."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_holidays_for_year(self, types=None):\n        # Filter any non-related holidays depending on Israel/Diaspora only\n        holidays_list = [\n            holiday for holiday in htables.HOLIDAYS if\n            (holiday.israel_diaspora == \"\") or\n            (holiday.israel_diaspora == \"ISRAEL\" and not self.diaspora) or\n            (holiday.israel_diaspora == \"DIASPORA\" and self.diaspora)]\n\n        if types:\n            # Filter non-matching holiday types.\n            holidays_list = [\n                holiday for holiday in holidays_list if\n                holiday.type in types\n            ]\n\n        # Filter any special cases defined by True/False functions\n        holidays_list = [\n            holiday for holiday in holidays_list if\n            all(func(self) for func in holiday.date_functions_list)]\n\n        def holiday_dates_cross_product(holiday):\n            \"\"\"Given a (days, months) pair, compute the cross product.\n\n            If days and/or months are singletons, they are converted to a list.\n            \"\"\"\n            return product(*([x] if isinstance(x, int) else x\n                             for x in holiday.date))\n\n        # Compute out every actual Hebrew date on which a holiday falls for\n        # this year by exploding out the possible days for each holiday.\n        holidays_list = [\n            (holiday, HDate(\n                heb_date=HebrewDate(self.hdate.year, date_instance[1],\n                                    date_instance[0]),\n                diaspora=self.diaspora,\n                hebrew=self.hebrew))\n            for holiday in holidays_list\n            for date_instance in holiday_dates_cross_product(holiday)\n            if len(holiday.date) >= 2\n        ]\n        return holidays_list", "response": "Get all the actual holidays for a given year."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upcoming_yom_tov(self):\n        if self.is_yom_tov:\n            return self\n        this_year = self.get_holidays_for_year([HolidayTypes.YOM_TOV])\n        next_rosh_hashana = HDate(\n            heb_date=HebrewDate(self.hdate.year + 1, Months.Tishrei, 1),\n            diaspora=self.diaspora,\n            hebrew=self.hebrew)\n        next_year = next_rosh_hashana.get_holidays_for_year(\n            [HolidayTypes.YOM_TOV])\n\n        # Filter anything that's past.\n        holidays_list = [\n            holiday_hdate for _, holiday_hdate in chain(this_year, next_year)\n            if holiday_hdate >= self\n        ]\n\n        holidays_list.sort(key=lambda h: h.gdate)\n\n        return holidays_list[0]", "response": "Return the next upcoming yom tov."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_reading(self):\n        _year_type = (self.year_size() % 10) - 3\n        year_type = (\n            self.diaspora * 1000 +\n            self.rosh_hashana_dow() * 100 +\n            _year_type * 10 +\n            self.pesach_dow())\n\n        _LOGGER.debug(\"Year type: %d\", year_type)\n\n        # Number of days since rosh hashana\n        rosh_hashana = HebrewDate(self.hdate.year, Months.Tishrei, 1)\n        days = self._jdn - conv.hdate_to_jdn(rosh_hashana)\n        # Number of weeks since rosh hashana\n        weeks = (days + self.rosh_hashana_dow() - 1) // 7\n        _LOGGER.debug(\"Days: %d, Weeks %d\", days, weeks)\n\n        # If it's currently Simchat Torah, return VeZot Haberacha.\n        if weeks == 3:\n            if (days <= 22 and self.diaspora and self.dow != 7 or\n                    days <= 21 and not self.diaspora):\n                return 54\n\n        # Special case for Simchat Torah in diaspora.\n        if weeks == 4 and days == 22 and self.diaspora:\n            return 54\n\n        # Return the indexes for the readings of the given year\n        def unpack_readings(readings):\n            return list(chain(\n                *([x] if isinstance(x, int) else x for x in readings)))\n\n        reading_for_year = htables.READINGS[year_type]\n        readings = unpack_readings(reading_for_year)\n        # Maybe recompute the year type based on the upcoming shabbat.\n        # This avoids an edge case where today is before Rosh Hashana but\n        # Shabbat is in a new year afterwards.\n        if (weeks >= len(readings)\n                and self.hdate.year < self.upcoming_shabbat.hdate.year):\n            return self.upcoming_shabbat.get_reading()\n        return readings[weeks]", "response": "Return the number of hebrew parasha."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ls(ctx, available):\n    \"List installed datasets on path\"\n\n    path = ctx.obj['path']\n    global_ = ctx.obj['global_']\n\n    _ls(available=available, **ctx.obj)", "response": "List installed datasets on path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the dataset s pip requirements", "response": "def reqs(ctx, dataset, kwargs):\n    \"Get the dataset's pip requirements\"\n\n    kwargs = parse_kwargs(kwargs)\n    (print)(data(dataset, **ctx.obj).reqs(**kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform the operations download extract rm_compressed processes and rm_raw in sequence. KWARGS must be in the form key = value and are fowarded to all opeartions.", "response": "def get(ctx, dataset, rm, keep_compressed, dont_process, dont_download, keep_raw, kwargs):\n    \"performs the operations download, extract, rm_compressed, processes and rm_raw, in sequence. KWARGS must be in the form: key=value, and are fowarded to all opeartions.\"\n\n    kwargs = parse_kwargs(kwargs)\n\n    process = not dont_process\n    rm_raw = not keep_raw\n    rm_compressed = not keep_compressed\n    download = not dont_download\n\n    data(dataset, **ctx.obj).get(download=download, rm=rm, rm_compressed=rm_compressed, process=process, rm_raw=rm_raw, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rm(ctx, dataset, kwargs):\n    \"removes the dataset's folder if it exists\"\n\n    kwargs = parse_kwargs(kwargs)\n    data(dataset, **ctx.obj).rm(**kwargs)", "response": "removes the dataset s folder if it exists"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the dataset s training - set and test - set folders if they exists", "response": "def rm_subsets(ctx, dataset, kwargs):\n    \"removes the dataset's training-set and test-set folders if they exists\"\n\n    kwargs = parse_kwargs(kwargs)\n    data(dataset, **ctx.obj).rm_subsets(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extract(ctx, dataset, kwargs):\n    \"extracts the files from the compressed archives\"\n\n    kwargs = parse_kwargs(kwargs)\n    data(dataset, **ctx.obj).extract(**kwargs)", "response": "extracts the files from the compressed archives"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the compressed files", "response": "def rm_compressed(ctx, dataset, kwargs):\n    \"removes the compressed files\"\n\n    kwargs = parse_kwargs(kwargs)\n    data(dataset, **ctx.obj).rm_compressed(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess the data to a friendly format", "response": "def process(ctx, dataset, kwargs):\n    \"processes the data to a friendly format\"\n\n    kwargs = parse_kwargs(kwargs)\n    data(dataset, **ctx.obj).process(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rm_raw(ctx, dataset, kwargs):\n    \"removes the raw unprocessed data\"\n\n    kwargs = parse_kwargs(kwargs)\n    data(dataset, **ctx.obj).rm_raw(**kwargs)", "response": "removes the raw unprocessed data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hist(xs, range=None, margin=10, width=None):\n    '''\n    xs: array of numbers, preferably an np.array, can contain nans, infinities\n    range: (minimum, maximum) tuple of numbers (defaults to (min, max) of xs)\n    margin: number of characters to use for the min-max labels (default: 10)\n    width: number of characters that will fit in a row (defaults to your terminal width)\n\n    Example:\n\n    >>> import scipy.stats\n    >>> draws = scipy.stats.norm.rvs(size=100, loc=100, scale=10)\n    >>> hist(draws, margin=5)\n    '''\n    if width is None:\n        width = terminal.width()\n\n    # add 1 to each margin for the [ and ] brackets\n    n_bins = width - (2 * (margin + 1))\n    # wrap it up as an array so we can index into it with a bool array. most likely it'll be a numpy array already\n    xs = np.array(xs)\n    finite = np.isfinite(xs)\n    # don't copy it unless we need to (we don't need to if there are only finite numbers)\n    # but if there are some nans / infinities, remove them\n    finite_xs = xs[finite]  # if nonfinite.any() else xs\n    # compute the histogram values as floats, which is easier, even though we renormalize anyway\n    hist_values, bin_edges = np.histogram(finite_xs, bins=n_bins, density=True, range=range)\n    # we want the highest hist_height to be 1.0\n    hist_heights = hist_values / max(hist_values)\n    # np.array(...).astype(int) will floor each value, if we wanted\n    hist_chars = (hist_heights * (len(terminal.bars) - 1)).astype(int)\n    cells = [terminal.bars[hist_char] for hist_char in hist_chars]\n\n    print format_number_line(cells, bin_edges[0], bin_edges[-1], margin=margin)\n    if not finite.all():\n        # if we took any out, report it:\n        nonfinite_xs = xs[~finite]\n        neginf = np.isneginf(nonfinite_xs)\n        nan = np.isnan(nonfinite_xs)\n        posinf = np.isposinf(nonfinite_xs)\n        print '%s %s %s' % (\n            ('(%d) -inf' % np.count_nonzero(neginf) if neginf.any() else '').rjust(margin),\n            ('(%d) nan' % np.count_nonzero(nan) if nan.any() else '').center(len(cells)),\n            ('(%d) +inf' % np.count_nonzero(posinf) if posinf.any() else '').ljust(margin)\n        )", "response": "Generate a histogram of xs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef points(ys, width=None):\n    '''Usage:\n    import scipy.stats\n    def walk(steps, position=0):\n        for step in steps:\n            position += step\n            yield position\n    positions = list(walk(scipy.stats.norm.rvs(size=1000)))\n    points(positions)\n    '''\n    if width is None:\n        width = terminal.width()\n\n    ys = np.array(ys)\n    n = len(ys)\n    y_min, y_max = np.min(ys), np.max(ys)\n    n_bins = min(width, n)\n    bins_per_n = float(n_bins) / float(n)\n    # print n, n_bins, n_per_bin, bins_per_n\n    sums = np.zeros(n_bins)\n    counts = np.zeros(n_bins)\n    for i, y in enumerate(ys):\n        bin = int(i * bins_per_n)\n        sums[bin] += y\n        counts[bin] += 1\n    bin_means = sums / counts\n    # we want the lowest bin_height to be 0.0, and highest bin_height to be 1.0\n    bin_heights = normalize(bin_means)\n    bin_chars = (bin_heights * (len(terminal.bars) - 1)).astype(int)\n    # print sums, counts, bin_means\n    cells = [terminal.bars[bin_char] for bin_char in bin_chars]\n    print '[%+f]' % y_max\n    print u''.join(cells)\n    print '[%+f]' % y_min", "response": "Print the points of a single object in a single window."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_moc_fits_hdu(moc):\n\n    # Ensure data are normalized.\n    moc.normalize()\n\n    # Determine whether a 32 or 64 bit column is required.\n    if moc.order < 14:\n        moc_type = np.int32\n        col_type = 'J'\n    else:\n        moc_type = np.int64\n        col_type = 'K'\n\n    # Convert to the NUNIQ value which guarantees that one of the\n    # top two bits is set so that the order of the value can be\n    # determined.\n    nuniq = []\n    for (order, cells) in moc:\n        uniq_prefix = 4 * (4 ** order)\n        for npix in cells:\n            nuniq.append(npix + uniq_prefix)\n\n    # Prepare the data, and sort into numerical order.\n    nuniq = np.array(nuniq, dtype=moc_type)\n    nuniq.sort()\n\n    # Create the FITS file.\n    col = fits.Column(name='UNIQ', format=col_type, array=nuniq)\n\n    cols = fits.ColDefs([col])\n    rec = fits.FITS_rec.from_columns(cols)\n    tbhdu = fits.BinTableHDU(rec)\n\n    # Mandatory Keywords.\n    tbhdu.header['PIXTYPE'] = 'HEALPIX'\n    tbhdu.header['ORDERING'] = 'NUNIQ'\n    tbhdu.header['COORDSYS'] = 'C'\n    tbhdu.header['MOCORDER'] = moc.order\n    tbhdu.header.comments['PIXTYPE'] = 'HEALPix magic code'\n    tbhdu.header.comments['ORDERING'] = 'NUNIQ coding method'\n    tbhdu.header.comments['COORDSYS'] = 'ICRS reference frame'\n    tbhdu.header.comments['MOCORDER'] = 'MOC resolution (best order)'\n\n    # Optional Keywords.\n    tbhdu.header['MOCTOOL'] = 'PyMOC ' + version\n    tbhdu.header.comments['MOCTOOL'] = 'Name of MOC generator'\n    if moc.type is not None:\n        tbhdu.header['MOCTYPE'] = moc.type\n        tbhdu.header.comments['MOCTYPE'] = 'Source type (IMAGE or CATALOG)'\n    if moc.id is not None:\n        tbhdu.header['MOCID'] = moc.id\n        tbhdu.header.comments['MOCID'] = 'Identifier of the collection'\n    if moc.origin is not None:\n        tbhdu.header['ORIGIN'] = moc.origin\n        tbhdu.header.comments['ORIGIN'] = 'MOC origin'\n    tbhdu.header['DATE'] = datetime.utcnow().replace(\n        microsecond=0).isoformat()\n    tbhdu.header.comments['DATE'] = 'MOC creation date'\n    if moc.name is not None:\n        tbhdu.header['EXTNAME'] = moc.name\n        tbhdu.header.comments['EXTNAME'] = 'MOC name'\n\n    return tbhdu", "response": "Create a FITS table HDU representation of a MOC."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_moc_fits(moc, filename, **kwargs):\n\n    tbhdu = write_moc_fits_hdu(moc)\n    prihdr = fits.Header()\n    prihdu = fits.PrimaryHDU(header=prihdr)\n    hdulist = fits.HDUList([prihdu, tbhdu])\n    hdulist.writeto(filename, **kwargs)", "response": "Write a MOC as a FITS file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_moc_fits(moc, filename, include_meta=False, **kwargs):\n\n    hl = fits.open(filename, mode='readonly', **kwargs)\n\n    read_moc_fits_hdu(moc, hl[1], include_meta)", "response": "Read data from a FITS file into a MOC."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_moc_fits_hdu(moc, hdu, include_meta=False):\n\n    if include_meta:\n        header = hdu.header\n\n        if 'MOCTYPE' in header:\n            moc.type = header['MOCTYPE']\n        if 'MOCID' in header:\n            moc.id = header['MOCID']\n        if 'ORIGIN' in header:\n            moc.origin = header['ORIGIN']\n        if 'EXTNAME' in header:\n            moc.name = header['EXTNAME']\n\n    current_order = None\n    current_cells = []\n\n    # Determine type to use for orders: 32 bit if column type is J,\n    # otherwise assume we need 64 bit.\n    moc_type = np.int32 if (hdu.data.formats[0] == 'J') else np.int64\n\n    nuniqs = hdu.data.field(0)\n    orders = (np.log2(nuniqs / 4) / 2).astype(moc_type)\n    cells = nuniqs - 4 * (4 ** orders)\n\n    for (order, cell) in izip(orders, cells):\n        if order != current_order:\n            if current_cells:\n                moc.add(current_order, current_cells)\n\n            current_order = order\n            current_cells = [cell]\n\n        else:\n            current_cells.append(cell)\n\n    if current_cells:\n        moc.add(current_order, current_cells)", "response": "Read data from a FITS table HDU into a MOC."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the tracebacks for traceback_matrix starting at index idx.", "response": "def tracebacks(score_matrix, traceback_matrix, idx):\n    \"\"\"Calculate the tracebacks for `traceback_matrix` starting at index `idx`.\n\n    Returns: An iterable of tracebacks where each traceback is sequence of\n      (index, direction) tuples. Each `index` is an index into\n      `traceback_matrix`. `direction` indicates the direction into which the\n      traceback \"entered\" the index.\n    \"\"\"\n    return filter(lambda tb: tb != (),\n                  _tracebacks(score_matrix,\n                              traceback_matrix,\n                              idx))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_score_matrix(a, b, score_func, gap_penalty):\n    score_matrix = Matrix(rows=len(a) + 1, cols=len(b) + 1)\n    traceback_matrix = Matrix(rows=len(a) + 1, cols=len(b) + 1, type_code='B')\n\n    for row in range(1, score_matrix.rows):\n        for col in range(1, score_matrix.cols):\n            match_score = score_func(a[row - 1], b[col - 1])\n\n            scores = sorted(\n                ((score_matrix[(row - 1, col - 1)] + match_score,\n                  Direction.DIAG),\n                 (score_matrix[(row - 1, col)] - gap_penalty(1),\n                  Direction.UP),\n                 (score_matrix[(row, col - 1)] - gap_penalty(1),\n                  Direction.LEFT),\n                 (0, Direction.NONE)),\n                key=lambda x: x[0],\n                reverse=True)\n            max_score = scores[0][0]\n            scores = itertools.takewhile(\n                lambda x: x[0] == max_score,\n                scores)\n\n            score_matrix[row, col] = max_score\n            for _, direction in scores:\n                traceback_matrix[row, col] = traceback_matrix[row, col] | direction.value\n\n    return score_matrix, traceback_matrix", "response": "Builds the score and traceback matrix for two input sequences and a score function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a traceback into an alignment.", "response": "def _traceback_to_alignment(tb, a, b):\n    \"\"\"Convert a traceback (i.e. as returned by `tracebacks()`) into an alignment\n    (i.e. as returned by `align`).\n\n    Arguments:\n      tb: A traceback.\n      a: the sequence defining the rows in the traceback matrix.\n      b: the sequence defining the columns in the traceback matrix.\n\n    Returns: An iterable of (index, index) tupless where ether (but not both)\n      tuples can be `None`.\n    \"\"\"\n    # We subtract 1 from the indices here because we're translating from the\n    # alignment matrix space (which has one extra row and column) to the space\n    # of the input sequences.\n    for idx, direction in tb:\n        if direction == Direction.DIAG:\n            yield (idx[0] - 1, idx[1] - 1)\n        elif direction == Direction.UP:\n            yield (idx[0] - 1, None)\n        elif direction == Direction.LEFT:\n            yield (None, idx[1] - 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef align(a, b, score_func, gap_penalty):\n    score_matrix, tb_matrix = build_score_matrix(a, b, score_func, gap_penalty)\n    max_score = max(score_matrix.values())\n    max_indices = (index\n                   for index, score in score_matrix.items()\n                   if score == max_score)\n    alignments = (\n        tuple(_traceback_to_alignment(tb, a, b))\n        for idx in max_indices\n        for tb in tracebacks(score_matrix, tb_matrix, idx))\n\n    return (max_score, alignments)", "response": "Calculates the best alignment of two sequences a and b."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unsubscribe(user_id, from_all=False, campaign_ids=None, on_error=None, on_success=None):\n    __subscription(\n        user_id,\n        unsubscribe=True,\n        all_campaigns=from_all,\n        campaign_ids=campaign_ids,\n        on_error=on_error,\n        on_success=on_success,\n    )", "response": "Unsubscribe a user from some or all campaigns."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsubscribe a user to one or more campaigns.", "response": "def subscribe(user_id, to_all=False, campaign_ids=None, on_error=None, on_success=None):\n    \"\"\" Resubscribe a user to some or all campaigns.\n\n    :param str | number user_id: the id you use to identify a user. this should\n    be static for the lifetime of a user.\n\n    :param bool to_all True to reubscribe to all campaigns. Take precedence over\n    campaigns IDs if both are given.\n\n    :param list of str campaign_ids List of campaign IDs to resubscribe the user to.\n\n    :param func on_error: An optional function to call in the event of an error.\n    on_error callback should take 2 parameters: `code` and `error`. `code` will be\n    one of outbound.ERROR_XXXXXX. `error` will be the corresponding message.\n\n    :param func on_success: An optional function to call if/when the API call succeeds.\n    on_success callback takes no parameters.\n    \"\"\"\n    __subscription(\n        user_id,\n        unsubscribe=False,\n        all_campaigns=to_all,\n        campaign_ids=campaign_ids,\n        on_error=on_error,\n        on_success=on_success,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisabling all device tokens for the given user on the specified platform.", "response": "def disable_all_tokens(platform, user_id, on_error=None, on_success=None):\n    \"\"\" Disable ALL device tokens for the given user on the specified platform.\n\n    :param str platform The platform which to disable token on. One of either\n    Google Cloud Messaging (outbound.GCM) or Apple Push Notification Service\n    (outbound.APNS).\n\n    :param str | number user_id: the id you use to identify a user. this should\n    be static for the lifetime of a user.\n\n    :param func on_error: An optional function to call in the event of an error.\n    on_error callback should take 2 parameters: `code` and `error`. `code` will be\n    one of outbound.ERROR_XXXXXX. `error` will be the corresponding message.\n\n    :param func on_success: An optional function to call if/when the API call succeeds.\n    on_success callback takes no parameters.\n    \"\"\"\n    __device_token(platform, False, user_id, all=True, on_error=on_error, on_success=on_success)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef disable_token(platform, user_id, token, on_error=None, on_success=None):\n    __device_token(platform, False, user_id, token=token, on_error=on_error, on_success=on_success)", "response": "Disable a device token for a user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering a device token for a user.", "response": "def register_token(platform, user_id, token, on_error=None, on_success=None):\n    \"\"\" Register a device token for a user.\n\n    :param str platform The platform which to register token on. One of either\n    Google Cloud Messaging (outbound.GCM) or Apple Push Notification Service\n    (outbound.APNS).\n\n    :param str | number user_id: the id you use to identify a user. this should\n    be static for the lifetime of a user.\n\n    :param str token: the token to register.\n\n    :param func on_error: An optional function to call in the event of an error.\n    on_error callback should take 2 parameters: `code` and `error`. `code` will be\n    one of outbound.ERROR_XXXXXX. `error` will be the corresponding message.\n\n    :param func on_success: An optional function to call if/when the API call succeeds.\n    on_success callback takes no parameters.\n    \"\"\"\n    __device_token(platform, True, user_id, token=token, on_error=on_error, on_success=on_success)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alias(user_id, previous_id, on_error=None, on_success=None):\n    if not __is_init():\n        on_error(ERROR_INIT, __error_message(ERROR_INIT))\n        return\n\n    if not isinstance(user_id, six.string_types + (Number,)):\n        on_error(ERROR_USER_ID, __error_message(ERROR_USER_ID))\n        return\n\n    if not isinstance(previous_id, six.string_types + (Number,)):\n        on_error(ERROR_PREVIOUS_ID, __error_message(ERROR_PREVIOUS_ID))\n        return\n\n    data = dict(\n        user_id=user_id,\n        previous_id=previous_id,\n    )\n\n    try:\n        resp = requests.post(\n            \"%s/identify\" % __BASE_URL,\n            data=json.dumps(data),\n            headers=__HEADERS,\n        )\n\n        if resp.status_code >= 200 and resp.status_code < 400:\n            on_success()\n        else:\n            on_error(ERROR_UNKNOWN, resp.text)\n    except requests.exceptions.ConnectionError:\n        on_error(ERROR_CONNECTION, __error_message(ERROR_CONNECTION))", "response": "Alias one user id to another."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef identify(user_id, previous_id=None, group_id=None, group_attributes=None,\n            first_name=None, last_name=None, email=None,\n            phone_number=None, apns_tokens=None, gcm_tokens=None,\n            attributes=None, on_error=None, on_success=None):\n    \"\"\" Identifying a user creates a record of your user in Outbound. Identify\n    calls should be made prior to sending any track events for a user.\n\n    :param str | number user_id: the id you use to identify a user. this should\n    be static for the lifetime of a user.\n\n    :param str | number previous_id: OPTIONAL the id you previously used to identify the user.\n\n    :param str | number group_id: OPTIONAL  the id that identifies a group of users the current user\n    belongs to.\n\n    :param dict group_attributes: OPTIONAL An optional dictionary of attributes that are shared\n    among the group this user belongs to.\n\n    :param str first_name: OPTIONAL the user's first name.\n\n    :param str last_name: OPTIONAL the user's last name.\n\n    :param str email: OPTIONAL the user's email address.\n\n    :param str phone_number: OPTIONAL the user's phone number.\n\n    :param str | list apns_tokens: OPTIONAL the device tokens for the user's iOS\n    devices. If a single string is given it is put into a list.\n\n    :param str | list gcm_tokens: OPTIONAL the device tokens for the user's Android\n    devices. If a single string is given it is put into a list.\n\n    :param dict attributes: An optional dictionary with any additional freeform\n    attributes describing the user.\n\n    :param func on_error: An optional function to call in the event of an error.\n    on_error callback should take 2 parameters: `code` and `error`. `code` will be\n    one of outbound.ERROR_XXXXXX. `error` will be the corresponding message.\n\n    :param func on_success: An optional function to call if/when the API call succeeds.\n    on_success callback takes no parameters.\n    \"\"\"\n\n    on_error = on_error or __on_error\n    on_success = on_success or __on_success\n\n    if not __is_init():\n        on_error(ERROR_INIT, __error_message(ERROR_INIT))\n        return\n\n    if not isinstance(user_id, six.string_types + (Number,)):\n        on_error(ERROR_USER_ID, __error_message(ERROR_USER_ID))\n        return\n\n    data = __user(\n        first_name,\n        last_name,\n        email,\n        phone_number,\n        apns_tokens,\n        gcm_tokens,\n        attributes,\n        previous_id,\n        group_id,\n        group_attributes,)\n    data['user_id'] = user_id\n\n    try:\n        resp = requests.post(\n            \"%s/identify\" % __BASE_URL,\n            data=json.dumps(data),\n            headers=__HEADERS,\n        )\n\n        if resp.status_code >= 200 and resp.status_code < 400:\n            on_success()\n        else:\n            on_error(ERROR_UNKNOWN, resp.text)\n    except requests.exceptions.ConnectionError:\n        on_error(ERROR_CONNECTION, __error_message(ERROR_CONNECTION))", "response": "Creates a record of a user in Outbound."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef track(user_id, event, first_name=None, last_name=None, email=None,\n        phone_number=None, apns_tokens=None, gcm_tokens=None,\n        user_attributes=None, properties=None, on_error=None, on_success=None, timestamp=None):\n    \"\"\" For any event you want to track, when a user triggers that event you\n    would call this function.\n\n    You can do an identify and track call simultaneously by including all the\n    identifiable user information in the track call.\n\n    :param str | number user_id: the id you user who triggered the event.\n\n    :param str first_name: OPTIONAL the user's first name.\n\n    :param str last_name: OPTIONAL the user's last name.\n\n    :param str email: OPTIONAL the user's email address.\n\n    :param str phone_number: OPTIONAL the user's phone number.\n\n    :param str | list apns_tokens: OPTIONAL the device tokens for the user's iOS\n    devices. If a single string is given it is put into a list.\n\n    :param str | list gcm_tokens: OPTIONAL the device tokens for the user's Android\n    devices. If a single string is given it is put into a list.\n\n    :param dict user_attributes: An optional dictionary with any additional\n    freeform attributes describing the user.\n\n    :param dict properties: An optional dictionary with any properties that\n    describe the event being track. Example: if the event were \"added item to\n    cart\", you might include a properties named \"item\" that is the name\n    of the item added to the cart.\n\n    :param func on_error: An optional function to call in the event of an error.\n    on_error callback should take 1 parameter which will be the error message.\n\n    :param func on_success: An optional function to call if/when the API call succeeds.\n    on_success callback takes no parameters.\n    \"\"\"\n\n    on_error = on_error or __on_error\n    on_success = on_success or __on_success\n\n    if not __is_init():\n        on_error(ERROR_INIT, __error_message(ERROR_INIT))\n        return\n\n    if not isinstance(user_id, six.string_types + (Number,)):\n        on_error(ERROR_USER_ID, __error_message(ERROR_USER_ID))\n        return\n    if not isinstance(event, six.string_types):\n        on_error(ERROR_EVENT_NAME, __error_message(ERROR_EVENT_NAME))\n        return\n\n    data = dict(user_id=user_id, event=event)\n    user = __user(\n        first_name,\n        last_name,\n        email,\n        phone_number,\n        apns_tokens,\n        gcm_tokens,\n        user_attributes,\n        None, None, None)\n    if user:\n        data['user'] = user\n\n    if properties:\n        if isinstance(properties, dict):\n            if len(properties) > 0:\n                data['properties'] = properties\n        else:\n            sys.stderr.write('Invalid event properties given. Expected dictionary. ' +\n                        'Got %s' % type(properties).__name__)\n\n    if timestamp:\n        data['timestamp'] = timestamp\n    else:\n        data['timestamp'] = int(time.time())\n\n    try:\n        resp = requests.post(\n            \"%s/track\" % __BASE_URL,\n            data=json.dumps(data),\n            headers=__HEADERS,\n        )\n\n        if resp.status_code >= 200 and resp.status_code < 400:\n            on_success()\n        else:\n            on_error(ERROR_UNKNOWN, resp.text)\n    except requests.exceptions.ConnectionError:\n        on_error(ERROR_CONNECTION, __error_message(ERROR_CONNECTION))", "response": "This function is used to track a user s freeform."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump(self, content, filepath, indent=4):\n        with open(filepath, 'w') as fp:\n            json.dump(content, fp, indent=indent)", "response": "Dump settings content to filepath."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse opened settings content using JSON parser.", "response": "def parse(self, filepath, content):\n        \"\"\"\n        Parse opened settings content using JSON parser.\n\n        Args:\n            filepath (str): Settings object, depends from backend\n            content (str): Settings content from opened file, depends from\n                backend.\n\n        Raises:\n            boussole.exceptions.SettingsBackendError: If parser can not decode\n                a valid JSON object.\n\n        Returns:\n            dict: Dictionnary containing parsed setting elements.\n\n        \"\"\"\n        try:\n            parsed = json.loads(content)\n        except ValueError:\n            msg = \"No JSON object could be decoded from file: {}\"\n            raise SettingsBackendError(msg.format(filepath))\n        return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_client(ip, port, authkey, max_items=None, timeout=2):\n\n    manager = make_client(ip, port, authkey)\n    job_q = manager.get_job_q()\n    job_q_closed = manager.q_closed()\n    result_q = manager.get_result_q()\n    function = manager.get_function()._getvalue()\n\n    processed = 0\n    while True:\n        try:\n            job = job_q.get_nowait()\n            result = function(job)\n            result_q.put(result)\n        except Queue.Empty:\n            if job_q_closed._getvalue().value:\n                break\n        else:\n            processed += 1\n            if max_items is not None and processed == max_items:\n                break\n        sleep(timeout)", "response": "Connect to a SwarmServer and do its dirty work."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nspend some time calculating exponentials.", "response": "def worker(n):\n    \"\"\"Spend some time calculating exponentials.\"\"\"\n    for _ in xrange(999999):\n        a = exp(n)\n        b = exp(2*n)\n    return n, a"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef imap_unordered(self, jobs, timeout=0.5):\n        timeout = max(timeout, 0.5)\n        jobs_iter = iter(jobs)\n        out_jobs = 0\n        job = None\n        while True:\n            if not self.closed and job is None:\n                # Get a job\n                try:\n                    job = jobs_iter.next()\n                except StopIteration:\n                    job = None\n                    self.close()\n            if job is not None:\n                # Put any job\n                try:\n                    self.put(job, True, timeout)\n                except Queue.Full:\n                    pass # we'll try again next time around\n                else:\n                    job = None\n            for result in self.get_finished():\n                yield result\n                \n            # Input and yielded everything?\n            if self.closed and self._items == 0:\n                break\n            sleep(timeout)", "response": "A generator over a set of jobs and yield the results in the output queues."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef primitive(self):\n        cas = self.get_reference_coords()\n        primitive_coords = make_primitive_extrapolate_ends(\n            cas, smoothing_level=self.sl)\n        primitive = Primitive.from_coordinates(primitive_coords)\n        primitive.relabel_monomers([x.id for x in self])\n        primitive.id = self.id\n        primitive.parent = self\n        return primitive", "response": "Primitive of the backbone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the sequence data for the protein in FASTA format.", "response": "def fasta(self):\n        \"\"\"Generates sequence data for the protein in FASTA format.\"\"\"\n        max_line_length = 79\n        fasta_str = '>{0}:{1}|PDBID|CHAIN|SEQUENCE\\n'.format(\n            self.parent.id.upper(), self.id)\n        seq = self.sequence\n        split_seq = [seq[i: i + max_line_length]\n                     for i in range(0, len(seq), max_line_length)]\n        for seq_part in split_seq:\n            fasta_str += '{0}\\n'.format(seq_part)\n        return fasta_str"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the centroid of the residue. Returns None if the residue is not available.", "response": "def centroid(self):\n        \"\"\"Calculates the centroid of the residue.\n\n        Returns\n        -------\n        centroid : numpy.array or None\n            Returns a 3D coordinate for the residue unless a CB\n            atom is not available, in which case `None` is\n            returned.\n\n        Notes\n        -----\n        Uses the definition of the centroid from Huang *et al* [2]_.\n\n        References\n        ----------\n        .. [2] Huang ES, Subbiah S and Levitt M (1995) Recognizing Native\n           Folds by the Arrangement of Hydrophobic and Polar Residues, J. Mol.\n           Biol return., **252**, 709-720.\n        \"\"\"\n        if 'CB' in self.atoms:\n            cb_unit_vector = unit_vector(\n                self['CB']._vector - self['CA']._vector)\n            return self['CA']._vector + (3.0 * cb_unit_vector)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list containing first n digits of Pi", "response": "def getPiLeibniz(n):\n    \"\"\"Returns a list containing first n digits of Pi\n    \"\"\"\n    mypi = piGenLeibniz()\n    result = []\n    if n > 0:\n        result += [next(mypi) for i in range(n)]\n    mypi.close()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshut down the application.", "response": "def shutdown(server, graceful=True):\n    \"\"\"Shut down the application.\n\n    If a graceful stop is requested, waits for all of the IO loop's\n    handlers to finish before shutting down the rest of the process.\n    We impose a 10 second timeout.\n\n    Based on http://tornadogists.org/3428652/\n    \"\"\"\n    ioloop = IOLoop.instance()\n\n    logging.info(\"Stopping server...\")\n    # Stop listening for new connections\n    server.stop()\n\n    def final_stop():\n        ioloop.stop()\n        logging.info(\"Stopped.\")\n        sys.exit(0)\n\n    def poll_stop(counts={'remaining': None, 'previous': None}):\n        remaining = len(ioloop._handlers)\n        counts['remaining'], counts['previous'] = remaining, counts['remaining']\n        previous = counts['previous']\n        # Wait until we only have only one IO handler remaining.  That\n        # final handler will be our PeriodicCallback polling task.\n        if remaining == 1:\n            final_stop()\n        if previous is None or remaining != previous:\n            logging.info(\"Waiting on IO %d remaining handlers\", remaining)\n\n    if graceful:\n        # Callback to check on remaining handlers.\n        poller = PeriodicCallback(poll_stop, 250, io_loop=ioloop)\n        poller.start()\n\n        # Give up after 10 seconds of waiting.\n        ioloop.add_timeout(time.time() + 10, final_stop)\n    else:\n        final_stop()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef most_similar(self, keyword, num):\n        try:\n            result = self.model.most_similar(keyword, topn = num) # most_similar return a list\n            return {'key':keyword, 'value':result, 'similarity':1}\n        except KeyError as e:\n            kemKeyword = self.kemNgram.find(keyword)\n            if kemKeyword:\n                result = self.model.most_similar(kemKeyword, topn = num)\n                return {'key':kemKeyword, 'value':result, 'similarity':self.kemNgram.compare(kemKeyword, keyword)}\n            return {'key':keyword, 'value':[], 'similarity':0}", "response": "function to get the most similar n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlooks through a SCSS file and find all involved files through the base source path and add them to the internal list of _CHILDREN_MAP and _PARENTS_MAP.", "response": "def look_source(self, sourcepath, library_paths=None):\n        \"\"\"\n        Open a SCSS file (sourcepath) and find all involved file through\n        imports.\n\n        This will fill internal buffers ``_CHILDREN_MAP`` and ``_PARENTS_MAP``.\n\n        Args:\n            sourcepath (str): Source file path to start searching for imports.\n\n        Keyword Arguments:\n            library_paths (list): List of directory paths for libraries to\n                resolve paths if resolving fails on the base source path.\n                Default to None.\n        \"\"\"\n        # Don't inspect again source that has allready be inspected as a\n        # children of a previous source\n        if sourcepath not in self._CHILDREN_MAP:\n            with io.open(sourcepath, 'r', encoding='utf-8') as fp:\n                finded_paths = self.parse(fp.read())\n\n            children = self.resolve(sourcepath, finded_paths,\n                                    library_paths=library_paths)\n\n            # Those files that are imported by the sourcepath\n            self._CHILDREN_MAP[sourcepath] = children\n\n            # Those files that import the sourcepath\n            for p in children:\n                self._PARENTS_MAP[p].add(sourcepath)\n\n            # Start recursive finding through each resolved path that has not\n            # been collected yet\n            for path in children:\n                if path not in self._CHILDREN_MAP:\n                    self.look_source(path, library_paths=library_paths)\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all dependencies of a source recursively searching through its base directory tree.", "response": "def _get_recursive_dependancies(self, dependencies_map, sourcepath,\n                                    recursive=True):\n        \"\"\"\n        Return all dependencies of a source, recursively searching through its\n        dependencies.\n\n        This is a common method used by ``children`` and ``parents`` methods.\n\n        Args:\n            dependencies_map (dict): Internal buffer (internal buffers\n                ``_CHILDREN_MAP`` or ``_PARENTS_MAP``) to use for searching.\n            sourcepath (str): Source file path to start searching for\n                dependencies.\n\n        Keyword Arguments:\n            recursive (bool): Switch to enable recursive finding (if True).\n                Default to True.\n\n        Raises:\n            CircularImport: If circular error is detected from a source.\n\n        Returns:\n            set: List of dependencies paths.\n        \"\"\"\n        # Direct dependencies\n        collected = set([])\n        collected.update(dependencies_map.get(sourcepath, []))\n\n        # Sequence of 'dependencies_map' items to explore\n        sequence = collected.copy()\n        # Exploration list\n        walkthrough = []\n\n        # Recursive search starting from direct dependencies\n        if recursive:\n            while True:\n                if not sequence:\n                    break\n                item = sequence.pop()\n\n                # Add current source to the explorated source list\n                walkthrough.append(item)\n\n                # Current item children\n                current_item_dependancies = dependencies_map.get(item, [])\n\n                for dependency in current_item_dependancies:\n                    # Allready visited item, ignore and continue to the new\n                    # item\n                    if dependency in walkthrough:\n                        continue\n                    # Unvisited item yet, add its children to dependencies and\n                    # item to explore\n                    else:\n                        collected.add(dependency)\n                        sequence.add(dependency)\n\n                # Sourcepath has allready been visited but present itself\n                # again, assume it's a circular import\n                if sourcepath in walkthrough:\n                    msg = \"A circular import has occured by '{}'\"\n                    raise CircularImport(msg.format(current_item_dependancies))\n\n                # No more item to explore, break loop\n                if not sequence:\n                    break\n\n        return collected"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef children(self, sourcepath, recursive=True):\n        return self._get_recursive_dependancies(\n            self._CHILDREN_MAP,\n            sourcepath,\n            recursive=True\n        )", "response": "Recursively find all children that are imported from the given sourcepath."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef selectize_tags_media(media_type='css',name=''):\n\tif media_type=='js':\n\t\tstr_script='<script src=\"{url}\"></script>\\n'\n\t\thtml=str_script.format(url=static('selectize/selectize.min.js'))\n\t\tif name=='jquery':\n\t\t\thtml=str_script.format(url=static('selectize/jquery.min.js'))+html\n\t\treturn html\n\n\tif name:name+='.'\n\tfpath='selectize/css/selectize.{name}css'.format(name=name)\n\treturn '<link rel=\"stylesheet\" href=\"{url}\">'.format(url=static(fpath))", "response": "Return selectize tags media."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_cloudwatch_logs(self, count=10, grp_name=None):\n        if grp_name is None:\n            grp_name = '/aws/lambda/%s' % self.config.func_name\n        logger.debug('Log Group Name: %s', grp_name)\n        logger.debug('Connecting to AWS Logs API')\n        conn = client('logs')\n        logger.debug('Getting log streams')\n        streams = conn.describe_log_streams(\n            logGroupName=grp_name,\n            orderBy='LastEventTime',\n            descending=True,\n            limit=count  # at worst, we have 1 event per stream\n        )\n        logger.debug('Found %d log streams', len(streams['logStreams']))\n        shown = 0\n        for stream in streams['logStreams']:\n            if (count - shown) < 1:\n                break\n            shown += self._show_log_stream(conn, grp_name,\n                                           stream['logStreamName'],\n                                           (count - shown))", "response": "Show count CloudWatch Logs entries for our lambda function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _show_log_stream(self, conn, grp_name, stream_name, max_count=10):\n        logger.debug('Showing up to %d events from stream %s',\n                     max_count, stream_name)\n        events = conn.get_log_events(\n            logGroupName=grp_name,\n            logStreamName=stream_name,\n            limit=max_count,\n            startFromHead=False\n        )\n        if len(events['events']) > 0:\n            print('## Log Group \\'%s\\'; Log Stream \\'%s\\'' % (\n                grp_name, stream_name))\n        shown = 0\n        for evt in events['events']:\n            if shown >= max_count:\n                break\n            shown += 1\n            dt = datetime.fromtimestamp(evt['timestamp'] / 1000.0)\n            print(\"%s => %s\" % (dt, evt['message'].strip()))\n        logger.debug('displayed %d events from stream', shown)\n        return shown", "response": "Show up to max events from a specified log stream ; return the number of events shown."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _url_for_queue(self, conn, name):\n        res = conn.get_queue_url(QueueName=name)\n        return res['QueueUrl']", "response": "Given a queue name return the URL for it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _delete_msg(self, conn, queue_url, receipt_handle):\n        resp = conn.delete_message(QueueUrl=queue_url,\n                                   ReceiptHandle=receipt_handle)\n        if resp['ResponseMetadata']['HTTPStatusCode'] != 200:\n            logger.error('Error: message with receipt handle %s in queue %s '\n                         'was not successfully deleted (HTTP %s)',\n                         receipt_handle, queue_url,\n                         resp['ResponseMetadata']['HTTPStatusCode'])\n            return\n        logger.info('Message with receipt handle %s deleted from queue %s',\n                    receipt_handle, queue_url)", "response": "Delete the message specified by receipt_handle in the queue_url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _show_one_queue(self, conn, name, count, delete=False):\n        url = self._url_for_queue(conn, name)\n        logger.debug(\"Queue '%s' url: %s\", name, url)\n        logger.warning('Receiving %d messages from queue\\'%s\\'; this may take '\n                       'up to 20 seconds.', count, name)\n        if not delete:\n            logger.warning(\"WARNING: Displayed messages will be invisible in \"\n                           \"queue for 60 seconds!\")\n        seen_ids = []\n        all_msgs = []\n        empty_polls = 0\n        # continue getting messages until we get 2 empty polls in a row\n        while empty_polls < 2 and len(all_msgs) < count:\n            logger.debug('Polling queue %s for messages (empty_polls=%d)',\n                         name, empty_polls)\n            msgs = conn.receive_message(\n                QueueUrl=url,\n                AttributeNames=['All'],\n                MessageAttributeNames=['All'],\n                MaxNumberOfMessages=count,\n                VisibilityTimeout=60,\n                WaitTimeSeconds=20\n            )\n            if 'Messages' in msgs and len(msgs['Messages']) > 0:\n                empty_polls = 0\n                logger.debug(\"Queue %s - got %d messages\", name,\n                             len(msgs['Messages']))\n                for m in msgs['Messages']:\n                    if m['MessageId'] in seen_ids:\n                        continue\n                    seen_ids.append(m['MessageId'])\n                    all_msgs.append(m)\n                continue\n            # no messages found\n            logger.debug('Queue %s - got no messages', name)\n            empty_polls += 1\n        logger.debug('received %d messages', len(all_msgs))\n        if len(all_msgs) == 0:\n            print('=> Queue \\'%s\\' appears empty.' % name)\n            return\n        print(\"=> Queue '%s' (%s)\" % (name, url))\n        if len(all_msgs) > count:\n            all_msgs = all_msgs[:count]\n        for m in all_msgs:\n            try:\n                m['Body'] = json.loads(m['Body'])\n            except Exception:\n                pass\n            print(pretty_json(m))\n            if delete:\n                self._delete_msg(conn, url, m['ReceiptHandle'])", "response": "Show count messages from a SQS queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _all_queue_names(self):\n        queues = set()\n        endpoints = self.config.get('endpoints')\n        for e in endpoints:\n            for q in endpoints[e]['queues']:\n                queues.add(q)\n        return sorted(queues)", "response": "Return a list of all unique queue names in our config."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_queue(self, name=None, count=10, delete=False):\n        logger.debug('Connecting to SQS API')\n        conn = client('sqs')\n        if name is not None:\n            queues = [name]\n        else:\n            queues = self._all_queue_names\n        for q_name in queues:\n            try:\n                self._show_one_queue(conn, q_name, count, delete=delete)\n            except Exception:\n                logger.error(\"Error showing queue '%s'\", q_name, exc_info=1)", "response": "Show up to count messages from the specified queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the API ID.", "response": "def get_api_id(self):\n        \"\"\"\n        Return the API ID.\n\n        :return: API ID\n        :rtype: str\n        \"\"\"\n        logger.debug('Connecting to AWS apigateway API')\n        conn = client('apigateway')\n        apis = conn.get_rest_apis()\n        api_id = None\n        for api in apis['items']:\n            if api['name'] == self.config.func_name:\n                api_id = api['id']\n                logger.debug('Found API id: %s', api_id)\n                break\n        if api_id is None:\n            raise Exception('Unable to find ReST API named %s' %\n                            self.config.func_name)\n        return api_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the method settings on our API Gateway Stage.", "response": "def set_method_settings(self):\n        \"\"\"\n        Set the Method settings <https://docs.aws.amazon.com/apigateway/api-\\\nreference/resource/stage/#methodSettings> on our Deployment Stage.\n        This is currently not supported by Terraform; see <https://github.com/\\\njantman/webhook2lambda2sqs/issues/7> and <https://github.com/hashicorp\\\n/terraform/issues/6612>.\n\n        Calls :py:meth:`~._add_method_setting` for each setting that is not\n        currently correct.\n        \"\"\"\n        settings = self.config.get('api_gateway_method_settings')\n        if settings is None:\n            logger.debug('api_gateway_method_settings not set in config')\n            return\n        logger.info('Setting API Gateway Stage methodSettings')\n        api_id = self.get_api_id()\n        stage_name = self.config.stage_name\n        logger.debug('Connecting to AWS apigateway API')\n        conn = client('apigateway')\n        logger.debug('Getting Stage configuration: api_id=%s stage_name=%s',\n                     api_id, stage_name)\n        stage = conn.get_stage(restApiId=api_id, stageName=stage_name)\n        logger.debug(\"Got stage config: \\n%s\", pformat(stage))\n        # hack for stages that have had no method settings applied yet\n        if '*/*' not in stage['methodSettings']:\n            stage['methodSettings']['*/*'] = {}\n        curr_settings = stage['methodSettings']['*/*']\n        for k, v in sorted(settings.items()):\n            if k in curr_settings and curr_settings[k] == v:\n                logger.debug('methodSetting \"%s\" is correct (%s)', k, v)\n                continue\n            # else update the value; note that the API doesn't actually follow\n            # https://tools.ietf.org/html/rfc6902#section-4 and doesn't seem\n            # to actually accept 'add' for these.\n            op = 'replace'\n            if k not in curr_settings:\n                logger.debug('Adding new methodSetting \"%s\" value %s', k, v)\n            else:\n                logger.debug('Updating methodSetting \"%s\" from %s to %s',\n                             k, curr_settings[k], v)\n            self._add_method_setting(conn, api_id, stage_name,\n                                     self._method_setting_paths[k] % '*/*',\n                                     k, v, op)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_method_setting(self, conn, api_id, stage_name, path, key, value,\n                            op):\n        \"\"\"\n        Update a single method setting on the specified stage. This uses the\n        'add' operation to PATCH the resource.\n\n        :param conn: APIGateway API connection\n        :type conn: :py:class:`botocore:APIGateway.Client`\n        :param api_id: ReST API ID\n        :type api_id: str\n        :param stage_name: stage name\n        :type stage_name: str\n        :param path: path to patch (see https://docs.aws.amazon.com/apigateway/\\\napi-reference/resource/stage/#methodSettings)\n        :type path: str\n        :param key: the dictionary key this should update\n        :type key: str\n        :param value: new value to set\n        :param op: PATCH operation to perform, 'add' or 'replace'\n        :type op: str\n        \"\"\"\n        logger.debug('update_stage PATCH %s on %s; value=%s',\n                     op, path, str(value))\n        res = conn.update_stage(\n            restApiId=api_id,\n            stageName=stage_name,\n            patchOperations=[\n                {\n                    'op': op,\n                    'path': path,\n                    'value': str(value)\n                }\n            ]\n        )\n        if res['methodSettings']['*/*'][key] != value:\n            logger.error('methodSettings PATCH expected to update %s to %s,'\n                         'but instead found value as %s', key, value,\n                         res['methodSettings']['*/*'][key])\n        else:\n            logger.info('Successfully updated methodSetting %s to %s',\n                        key, value)", "response": "Adds a method setting to a specific stage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initialize_repository(path, spor_dir='.spor'):\n    path = pathlib.Path(path)\n    spor_path = path / spor_dir\n    if spor_path.exists():\n        raise ValueError('spor directory already exists: {}'.format(spor_path))\n    spor_path.mkdir()\n\n    return Repository(path, spor_dir)", "response": "Initialize a spor repository in path if one doesn t already exist."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef open_repository(path, spor_dir='.spor'):\n    root = _find_root_dir(path, spor_dir)\n    return Repository(root, spor_dir)", "response": "Open an existing repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for a spor repo containing path.", "response": "def _find_root_dir(path, spor_dir):\n    \"\"\"Search for a spor repo containing `path`.\n\n    This searches for `spor_dir` in directories dominating `path`. If a\n    directory containing `spor_dir` is found, then that directory is returned\n    as a `pathlib.Path`.\n\n    Returns: The dominating directory containing `spor_dir` as a\n      `pathlib.Path`.\n\n    Raises:\n      ValueError: No repository is found.\n\n    \"\"\"\n\n    start_path = pathlib.Path(os.getcwd() if path is None else path)\n    paths = [start_path] + list(start_path.parents)\n\n    for path in paths:\n        data_dir = path / spor_dir\n        if data_dir.exists() and data_dir.is_dir():\n            return path\n\n    raise ValueError('No spor repository found')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, anchor):\n        anchor_id = uuid.uuid4().hex\n        anchor_path = self._anchor_path(anchor_id)\n        with anchor_path.open(mode='wt') as f:\n            save_anchor(f, anchor, self.root)\n\n        return anchor_id", "response": "Add a new anchor to the repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log(**data):\n\t# Get data from request body\n\tentry = {\n\t\t\"module\": data[\"params\"][\"module\"],\n\t\t\"event\": data[\"params\"][\"event\"],\n\t\t\"timestamp\": data[\"params\"][\"timestamp\"],\n\t\t\"arguments\": data[\"params\"][\"arguments\"]\n\t}\n\t# Call create metod for writing data to database\n\thistory.create(entry)", "response": "RPC method for logging events\n\tMakes entry with new account creating\n\tReturn None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post(self):\n\t\tdata = json.loads(self.request.body.decode())\n\t\tresponse = dispatch([log],{'jsonrpc': '2.0', \n\t\t\t\t\t'method': 'log', 'params': data, 'id': 1})", "response": "Accepts jsorpc post request. Returns data from request body."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_optimisation(self, rounds: int, max_angle: float,\n                           max_distance: float, temp: float=298.15,\n                           stop_when=None, verbose=None):\n        \"\"\"Starts the loop fitting protocol.\n\n        Parameters\n        ----------\n        rounds : int\n            The number of Monte Carlo moves to be evaluated.\n        max_angle : float\n            The maximum variation in rotation that can moved per\n            step.\n        max_distance : float\n            The maximum distance the can be moved per step.\n        temp : float, optional\n            Temperature used during fitting process.\n        stop_when : float, optional\n            Stops fitting when energy is less than or equal to this value.\n        \"\"\"\n        self._generate_initial_score()\n        self._mmc_loop(rounds, max_angle, max_distance, temp=temp,\n                       stop_when=stop_when, verbose=verbose)\n        return", "response": "Starts the loop fitting protocol."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the evaluation function for the initial pose.", "response": "def _generate_initial_score(self):\n        \"\"\"Runs the evaluation function for the initial pose.\"\"\"\n        self.current_energy = self.eval_fn(self.polypeptide, *self.eval_args)\n        self.best_energy = copy.deepcopy(self.current_energy)\n        self.best_model = copy.deepcopy(self.polypeptide)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine if a model will be accepted.", "response": "def check_move(new, old, t):\n        \"\"\"Determines if a model will be accepted.\"\"\"\n        if (t <= 0) or numpy.isclose(t, 0.0):\n            return False\n        K_BOLTZ = 1.9872041E-003  # kcal/mol.K\n        if new < old:\n            return True\n        else:\n            move_prob = math.exp(-(new - old) / (K_BOLTZ * t))\n            if move_prob > random.uniform(0, 1):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate and return engine filename and extension indexes from given backend engines.", "response": "def scan_backends(self, backends):\n        \"\"\"\n        From given backends create and return engine, filename and extension\n        indexes.\n\n        Arguments:\n            backends (list): List of backend engines to scan. Order does matter\n                since resulted indexes are stored in an ``OrderedDict``. So\n                discovering will stop its job if it meets the first item.\n\n        Returns:\n            tuple: Engine, filename and extension indexes where:\n\n            * Engines are indexed on their kind name with their backend object\n              as value;\n            * Filenames are indexed on their filename with engine kind name as\n              value;\n            * Extensions are indexed on their extension with engine kind name\n              as value;\n        \"\"\"\n        engines = OrderedDict()\n        filenames = OrderedDict()\n        extensions = OrderedDict()\n\n        for item in backends:\n            engines[item._kind_name] = item\n            filenames[item._default_filename] = item._kind_name\n            extensions[item._file_extension] = item._kind_name\n\n        return engines, filenames, extensions"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a backend class object from given filepath and optional kind.", "response": "def get_engine(self, filepath, kind=None):\n        \"\"\"\n        From given filepath try to discover which backend format to use.\n\n        Discovering is pretty naive as it find format from file extension.\n\n        Args:\n            filepath (str): Settings filepath or filename.\n\n        Keyword Arguments:\n            kind (str): A format name to enforce a specific backend. Can be any\n                value from attribute ``_kind_name`` of available backend\n                engines.\n\n        Raises:\n            boussole.exceptions.SettingsDiscoveryError: If extension is\n            unknowed or if given format name is unknowed.\n\n        Returns:\n            object: Backend engine class.\n\n        \"\"\"\n        if not kind:\n            extension = os.path.splitext(filepath)[1]\n            if not extension:\n                msg = (\"Unable to discover settings format from an empty file \"\n                       \"extension: {}\")\n                raise SettingsDiscoveryError(msg.format(filepath))\n            elif extension[1:] not in self.extensions:\n                msg = (\"Settings file extension is unknowed from available \"\n                       \"backends: {}\")\n                raise SettingsDiscoveryError(msg.format(filepath))\n            kind = self.extensions[extension[1:]]\n        elif kind not in self.engines:\n            msg = \"Given settings format is unknow: {}\"\n            raise SettingsDiscoveryError(msg.format(kind))\n\n        return self.engines[kind]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to find existing settings filename from base directory using default settings filename from available engines.", "response": "def guess_filename(self, basedir, kind=None):\n        \"\"\"\n        Try to find existing settings filename from base directory using\n        default filename from available engines.\n\n        First finded filename from available engines win. So registred engines\n        order matter.\n\n        Arguments:\n            basedir (string): Directory path where to search for.\n\n        Keyword Arguments:\n            kind (string): Backend engine kind name to search for default\n                settings filename. If not given, search will be made for\n                default settings filename from all available backend engines.\n\n        Returns:\n            tuple: Absolute filepath and backend engine class.\n        \"\"\"\n        if kind:\n            filepath = os.path.join(basedir,\n                                    self.engines[kind]._default_filename)\n            if os.path.exists(filepath):\n                return filepath, self.engines[kind]\n\n        for filename, kind in self.filenames.items():\n            filepath = os.path.join(basedir, filename)\n            if os.path.exists(filepath):\n                return filepath, self.engines[kind]\n\n        msg = \"Unable to find any settings in directory: {}\"\n        raise SettingsDiscoveryError(msg.format(basedir))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching for a config file and return the absolute filepath and backend engine class.", "response": "def search(self, filepath=None, basedir=None, kind=None):\n        \"\"\"\n        Search for a settings file.\n\n        Keyword Arguments:\n            filepath (string): Path to a config file, either absolute or\n                relative. If absolute set its directory as basedir (omitting\n                given basedir argument). If relative join it to basedir.\n            basedir (string): Directory path where to search for.\n            kind (string): Backend engine kind name (value of attribute\n                ``_kind_name``) to help discovering with empty or relative\n                filepath. Also if explicit absolute filepath is given, this\n                will enforce the backend engine (such as yaml kind will be\n                forced for a ``foo.json`` file).\n\n        Returns:\n            tuple: Absolute filepath and backend engine class.\n        \"\"\"\n        # None values would cause trouble with path joining\n        if filepath is None:\n            filepath = ''\n        if basedir is None:\n            basedir = '.'\n\n        if not basedir and not filepath:\n            msg = \"Either basedir or filepath is required for discovering\"\n            raise SettingsDiscoveryError(msg)\n\n        if kind and kind not in self.engines:\n            msg = \"Given settings format is unknow: {}\"\n            raise SettingsDiscoveryError(msg.format(kind))\n\n        # Implicit filename to find from backend\n        if not filepath:\n            filename, engine = self.guess_filename(basedir, kind)\n            filepath = os.path.join(basedir, filename)\n        # Explicit filename dont have to search for default backend file and\n        # blindly force given backend if any\n        else:\n            if os.path.isabs(filepath):\n                basedir, filename = os.path.split(filepath)\n            else:\n                filepath = os.path.join(basedir, filepath)\n\n            if not os.path.exists(filepath):\n                msg = \"Given settings file does not exists: {}\"\n                raise SettingsDiscoveryError(msg.format(filepath))\n\n            engine = self.get_engine(filepath, kind)\n\n        return filepath, engine"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new entry point for a new module.", "response": "def create(python, env_dir, system, prompt, bare, virtualenv_py=None):\n    \"\"\"Main entry point to use this as a module.\n    \"\"\"\n    if not python or python == sys.executable:\n        _create_with_this(\n            env_dir=env_dir, system=system, prompt=prompt,\n            bare=bare, virtualenv_py=virtualenv_py,\n        )\n    else:\n        _create_with_python(\n            python=python,\n            env_dir=env_dir, system=system, prompt=prompt,\n            bare=bare, virtualenv_py=virtualenv_py,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if all filters are matching.", "response": "def matches(self, client, event_data):\n        \"\"\"True if all filters are matching.\"\"\"\n\n        for f in self.filters:\n            if not f(client, event_data):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter_events(cls, client, event_data):\n\n        for event in cls.events:\n            # try event filters\n            if event.matches(client, event_data):\n                yield event", "response": "Filter registered events and yield them."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_callbacks(cls, client, event_data):\n\n        for event in cls.filter_events(client, event_data):\n            for cb in event.callbacks:\n                yield cb", "response": "Filter registered events and yield all of their callbacks."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates that the parameters are correctly specified.", "response": "def validate_parameters(self):\n        \"\"\"Validate that the parameters are correctly specified.\"\"\"\n        for p in self.params:\n            if p not in self.known_params:\n                raise errors.UnknownParameter(p, self.known_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(argv):\n    p = argparse.ArgumentParser(\n        description='webhook2lambda2sqs - Generate code and manage '\n                    'infrastructure for receiving webhooks with AWS API '\n                    'Gateway and pushing to SQS via Lambda - <%s>' % PROJECT_URL\n    )\n    p.add_argument('-c', '--config', dest='config', type=str,\n                   action='store', default='config.json',\n                   help='path to config.json (default: ./config.json)')\n    p.add_argument('-v', '--verbose', dest='verbose', action='count',\n                   default=0,\n                   help='verbose output. specify twice for debug-level output.')\n    p.add_argument('-V', '--version', action='version',\n                   version='webhook2lambda2sqs v%s <%s>' % (\n                       VERSION, PROJECT_URL\n                   ))\n    p.add_argument('-T', '--tf-version', dest='tf_ver', action='store',\n                   type=str, default='0.9.0',\n                   help='terraform version to generate configurations for')\n    subparsers = p.add_subparsers(title='Action (Subcommand)', dest='action',\n                                  metavar='ACTION', description='Action to '\n                                  'perform; each action may take further '\n                                  'parameters. Use ACTION -h for subcommand-'\n                                  'specific options and arguments.')\n    subparsers.add_parser(\n        'generate', help='generate lambda function and terraform configs in ./'\n    )\n    tf_parsers = [\n        ('genapply', 'generate function and terraform configs in ./, then run '\n                     'terraform apply'),\n        ('plan', 'run terraform plan to show changes which will be made'),\n        ('apply', 'run terraform apply to apply changes/create infrastructure'),\n        ('destroy',\n         'run terraform destroy to completely destroy infrastructure')\n    ]\n    tf_p_objs = {}\n    for cname, chelp in tf_parsers:\n        tf_p_objs[cname] = subparsers.add_parser(cname, help=chelp)\n        tf_p_objs[cname].add_argument('-t', '--terraform-path', dest='tf_path',\n                                      action='store', default='terraform',\n                                      type=str, help='path to terraform '\n                                                     'binary, if not in PATH')\n        tf_p_objs[cname].add_argument('-S', '--no-stream-tf', dest='stream_tf',\n                                      action='store_false', default=True,\n                                      help='DO NOT stream Terraform output to '\n                                           'STDOUT (combined) in realtime')\n    apilogparser = subparsers.add_parser('apilogs', help='show last 10 '\n                                         'CloudWatch Logs entries for the '\n                                         'API Gateway')\n    apilogparser.add_argument('-c', '--count', dest='log_count', type=int,\n                              default=10, help='number of log entries to show '\n                              '(default 10')\n    logparser = subparsers.add_parser('logs', help='show last 10 CloudWatch '\n                                      'Logs entries for the function')\n    logparser.add_argument('-c', '--count', dest='log_count', type=int,\n                           default=10, help='number of log entries to show '\n                                            '(default 10')\n    queueparser = subparsers.add_parser('queuepeek', help='show messages from '\n                                        'one or all of the SQS queues')\n    queueparser.add_argument('-n', '--name', type=str, dest='queue_name',\n                             default=None, help='queue name to read (defaults '\n                                                'to None to read all)')\n    queueparser.add_argument('-d', '--delete', action='store_true',\n                             dest='queue_delete', default=False,\n                             help='delete messages after reading')\n    queueparser.add_argument('-c', '--count', dest='msg_count', type=int,\n                             default=10, help='number of messages to read from '\n                                              'each queue (default 10)')\n    testparser = subparsers.add_parser('test', help='send test message to '\n                                                    'one or more endpoints')\n    testparser.add_argument('-t', '--terraform-path', dest='tf_path',\n                            action='store', default='terraform',\n                            type=str, help='path to terraform '\n                            'binary, if not in PATH')\n    testparser.add_argument('-n', '--endpoint-name', dest='endpoint_name',\n                            type=str, default=None,\n                            help='endpoint name (default: None, to send to '\n                                 'all endpoints)')\n    subparsers.add_parser(\n        'example-config', help='write example config to STDOUT and description '\n                               'of it to STDERR, then exit'\n    )\n    args = p.parse_args(argv)\n    if args.action is None:\n        # for py3, which doesn't raise on this\n        sys.stderr.write(\"ERROR: too few arguments\\n\")\n        raise SystemExit(2)\n    return args", "response": "Parse command - line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the base url of the current base url of the current base url.", "response": "def get_base_url(config, args):\n    \"\"\"\n    Get the API base url. Try Terraform state first, then\n    :py:class:`~.AWSInfo`.\n\n    :param config: configuration\n    :type config: :py:class:`~.Config`\n    :param args: command line arguments\n    :type args: :py:class:`argparse.Namespace`\n    :return: API base URL\n    :rtype: str\n    \"\"\"\n    try:\n        logger.debug('Trying to get Terraform base_url output')\n        runner = TerraformRunner(config, args.tf_path)\n        outputs = runner._get_outputs()\n        base_url = outputs['base_url']\n        logger.debug(\"Terraform base_url output: '%s'\", base_url)\n    except Exception:\n        logger.info('Unable to find API base_url from Terraform state; '\n                    'querying AWS.', exc_info=1)\n        aws = AWSInfo(config)\n        base_url = aws.get_api_base_url()\n        logger.debug(\"AWS api_base_url: '%s'\", base_url)\n    if not base_url.endswith('/'):\n        base_url += '/'\n    return base_url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the API ID from Terraform or AWS.", "response": "def get_api_id(config, args):\n    \"\"\"\n    Get the API ID from Terraform, or from AWS if that fails.\n\n    :param config: configuration\n    :type config: :py:class:`~.Config`\n    :param args: command line arguments\n    :type args: :py:class:`argparse.Namespace`\n    :return: API Gateway ID\n    :rtype: str\n    \"\"\"\n    try:\n        logger.debug('Trying to get Terraform rest_api_id output')\n        runner = TerraformRunner(config, args.tf_path)\n        outputs = runner._get_outputs()\n        depl_id = outputs['rest_api_id']\n        logger.debug(\"Terraform rest_api_id output: '%s'\", depl_id)\n    except Exception:\n        logger.info('Unable to find API rest_api_id from Terraform state;'\n                    ' querying AWS.', exc_info=1)\n        aws = AWSInfo(config)\n        depl_id = aws.get_api_id()\n        logger.debug(\"AWS API ID: '%s'\", depl_id)\n    return depl_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(args=None):\n    # parse args\n    if args is None:\n        args = parse_args(sys.argv[1:])\n\n    # dump example config if that action\n    if args.action == 'example-config':\n        conf, doc = Config.example_config()\n        print(conf)\n        sys.stderr.write(doc + \"\\n\")\n        return\n\n    # set logging level\n    if args.verbose > 1:\n        set_log_debug()\n    elif args.verbose == 1:\n        set_log_info()\n\n    # get our config\n    config = Config(args.config)\n\n    if args.action == 'logs':\n        aws = AWSInfo(config)\n        aws.show_cloudwatch_logs(count=args.log_count)\n        return\n\n    if args.action == 'apilogs':\n        api_id = get_api_id(config, args)\n        aws = AWSInfo(config)\n        aws.show_cloudwatch_logs(\n            count=args.log_count,\n            grp_name='API-Gateway-Execution-Logs_%s/%s' % (\n                api_id, config.stage_name\n            )\n        )\n        return\n\n    if args.action == 'queuepeek':\n        aws = AWSInfo(config)\n        aws.show_queue(name=args.queue_name, delete=args.queue_delete,\n                       count=args.msg_count)\n        return\n\n    if args.action == 'test':\n        run_test(config, args)\n        return\n\n    if args.action in ['apply', 'genapply', 'plan', 'destroy']:\n        runner = TerraformRunner(config, args.tf_path)\n        tf_ver = runner.tf_version\n    else:\n        tf_ver = tuple(\n            [int(x) for x in args.tf_ver.split('.')]\n        )\n\n    # if generate or genapply, generate the configs\n    if args.action == 'generate' or args.action == 'genapply':\n        func_gen = LambdaFuncGenerator(config)\n        func_src = func_gen.generate()\n        # @TODO: also write func_source to disk\n        tf_gen = TerraformGenerator(config, tf_ver=tf_ver)\n        tf_gen.generate(func_src)\n\n    # if only generate, exit now\n    if args.action == 'generate':\n        return\n\n    # run the terraform action\n    if args.action == 'apply' or args.action == 'genapply':\n        runner.apply(args.stream_tf)\n        # conditionally set API Gateway Method settings\n        if config.get('api_gateway_method_settings') is not None:\n            aws = AWSInfo(config)\n            aws.set_method_settings()\n    elif args.action == 'plan':\n        runner.plan(args.stream_tf)\n    else:  # destroy\n        runner.destroy(args.stream_tf)", "response": "Entry point for the main function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscripting for merging different collections of stop words.", "response": "def cmdline(argv=sys.argv[1:]):\n    \"\"\"\n    Script for merging different collections of stop words.\n    \"\"\"\n    parser = ArgumentParser(\n        description='Create and merge collections of stop words')\n    parser.add_argument(\n        'language', help='The language used in the collection')\n    parser.add_argument('sources', metavar='FILE', nargs='+',\n                        help='Source files to parse')\n    options = parser.parse_args(argv)\n\n    factory = StopWordFactory()\n    language = options.language\n    stop_words = factory.get_stop_words(language, fail_safe=True)\n\n    for filename in options.sources:\n        stop_words += StopWord(language, factory.read_collection(filename))\n\n    filename = factory.get_collection_filename(stop_words.language)\n    factory.write_collection(filename, stop_words.collection)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a muddle instance with API key and url set for requests.", "response": "def authenticate(api_key, api_url, **kwargs):\n    \"\"\"Returns a muddle instance, with API key and url set for requests.\"\"\"\n\n    muddle = Muddle(**kwargs)\n\n    # Login.\n    muddle.authenticate(api_key, api_url)\n    return muddle"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract handler names from job_conf. xml", "response": "def get_job_config(conf):\n        \"\"\" Extract handler names from job_conf.xml\n        \"\"\"\n        rval = []\n        root = elementtree.parse(conf).getroot()\n        for handler in root.find('handlers'):\n            rval.append({'service_name' : handler.attrib['id']})\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __load_state(self):\n        try:\n            return ConfigState(json.load(open(self.config_state_path)))\n        except (OSError, IOError) as exc:\n            if exc.errno == errno.ENOENT:\n                self.__dump_state({})\n                return json.load(open(self.config_state_path))\n            raise", "response": "Read persisted state from the JSON statefile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _register_config_file(self, key, val):\n        state = self.__load_state()\n        if 'config_files' not in state:\n            state['config_files'] = {}\n        state['config_files'][key] = val\n        self.__dump_state(state)", "response": "Persist a newly added config file or update the value\n        of a previously persisted config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _deregister_config_file(self, key):\n        state = self.__load_state()\n        if 'remove_configs' not in state:\n            state['remove_configs'] = {}\n        state['remove_configs'][key] = (state['config_files'].pop(key))\n        self.__dump_state(state)", "response": "Deregisters a previously registered config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nforgetting a previously deregister config file.", "response": "def _purge_config_file(self, key):\n        \"\"\" Forget a previously deregister config file.  The caller should\n        ensure that it was previously deregistered.\n        \"\"\"\n        state = self.__load_state()\n        del state['remove_configs'][key]\n        self.__dump_state(state)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining what has changed since the last time.", "response": "def determine_config_changes(self):\n        \"\"\" The magic: Determine what has changed since the last time.\n\n        Caller should pass the returned config to register_config_changes to persist.\n        \"\"\"\n        # 'update' here is synonymous with 'add or update'\n        instances = set()\n        new_configs = {}\n        meta_changes = { 'changed_instances' : set(),\n                         'remove_instances' : [],\n                         'remove_configs' : self.get_remove_configs() }\n        for config_file, stored_config in self.get_registered_configs().items():\n            new_config = stored_config\n            try:\n                ini_config = ConfigManager.get_ini_config(config_file, defaults=stored_config.defaults)\n            except (OSError, IOError) as exc:\n                log.warning('Unable to read %s (hint: use `rename` or `remove` to fix): %s', config_file, exc)\n                new_configs[config_file] = stored_config\n                instances.add(stored_config['instance_name'])\n                continue\n            if ini_config['instance_name'] is not None:\n                # instance name is explicitly set in the config\n                instance_name = ini_config['instance_name']\n                if ini_config['instance_name'] != stored_config['instance_name']:\n                    # instance name has changed\n                    # (removal of old instance will happen later if no other config references it)\n                    new_config['update_instance_name'] = instance_name\n                meta_changes['changed_instances'].add(instance_name)\n            else:\n                # instance name is dynamically generated\n                instance_name = stored_config['instance_name']\n            if ini_config['attribs'] != stored_config['attribs']:\n                # Ensure that dynamically generated virtualenv is not lost\n                if ini_config['attribs']['virtualenv'] is None:\n                    ini_config['attribs']['virtualenv'] = stored_config['attribs']['virtualenv']\n                # Recheck to see if dynamic virtualenv was the only change.\n                if ini_config['attribs'] != stored_config['attribs']:\n                    self.create_virtualenv(ini_config['attribs']['virtualenv'])\n                    new_config['update_attribs'] = ini_config['attribs']\n                    meta_changes['changed_instances'].add(instance_name)\n            # make sure this instance isn't removed\n            instances.add(instance_name)\n            services = []\n            for service in ini_config['services']:\n                if service not in stored_config['services']:\n                    # instance has a new service\n                    if 'update_services' not in new_config:\n                        new_config['update_services'] = []\n                    new_config['update_services'].append(service)\n                    meta_changes['changed_instances'].add(instance_name)\n                # make sure this service isn't removed\n                services.append(service)\n            for service in stored_config['services']:\n                if service not in services:\n                    if 'remove_services' not in new_config:\n                        new_config['remove_services'] = []\n                    new_config['remove_services'].append(service)\n                    meta_changes['changed_instances'].add(instance_name)\n            new_configs[config_file] = new_config\n        # once finished processing all configs, find any instances which have been deleted\n        for instance_name in self.get_registered_instances(include_removed=True):\n            if instance_name not in instances:\n                meta_changes['remove_instances'].append(instance_name)\n        return new_configs, meta_changes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_config_changes(self, configs, meta_changes):\n        for config_file in meta_changes['remove_configs'].keys():\n            self._purge_config_file(config_file)\n        for config_file, config in configs.items():\n            if 'update_attribs' in config:\n                config['attribs'] = config.pop('update_attribs')\n            if 'update_instance_name' in config:\n                config['instance_name'] = config.pop('update_instance_name')\n            if 'update_services' in config or 'remove_services' in config:\n                remove = config.pop('remove_services', [])\n                services = config.pop('update_services', [])\n                # need to prevent old service defs from overwriting new ones\n                for service in config['services']:\n                    if service not in remove and service not in services:\n                        services.append(service)\n                config['services'] = services\n            self._register_config_file(config_file, config)", "response": "Persist config changes to the JSON state file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the persisted values of all config files registered with the config manager.", "response": "def get_registered_configs(self, instances=None):\n        \"\"\" Return the persisted values of all config files registered with the config manager.\n        \"\"\"\n        configs = self.state.get('config_files', {})\n        if instances is not None:\n            for config_file, config in configs.items():\n                if config['instance_name'] not in instances:\n                    configs.pop(config_file)\n        return configs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_registered_instances(self, include_removed=False):\n        rval = []\n        configs = self.state.get('config_files', {}).values()\n        if include_removed:\n            configs.extend(self.state.get('remove_configs', {}).values())\n        for config in configs:\n            if config['instance_name'] not in rval:\n                rval.append(config['instance_name'])\n        return rval", "response": "Return the persisted names of all instances across all registered configs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds config files to the state.", "response": "def add(self, config_files, galaxy_root=None):\n        \"\"\" Public method to add (register) config file(s).\n        \"\"\"\n        for config_file in config_files:\n            config_file = abspath(expanduser(config_file))\n            if self.is_registered(config_file):\n                log.warning('%s is already registered', config_file)\n                continue\n            defaults = None\n            if galaxy_root is not None:\n                defaults={ 'galaxy_root' : galaxy_root }\n            conf = ConfigManager.get_ini_config(config_file, defaults=defaults)\n            if conf is None:\n                raise Exception('Cannot add %s: File is unknown type' % config_file)\n            if conf['instance_name'] is None:\n                conf['instance_name'] = conf['config_type'] + '-' + hashlib.md5(os.urandom(32)).hexdigest()[:12]\n            if conf['attribs']['virtualenv'] is None:\n                conf['attribs']['virtualenv'] = abspath(join(expanduser(self.state_dir), 'virtualenv-' + conf['instance_name']))\n            # create the virtualenv if necessary\n            self.create_virtualenv(conf['attribs']['virtualenv'])\n            conf_data = { 'config_type' : conf['config_type'],\n                          'instance_name' : conf['instance_name'],\n                          'attribs' : conf['attribs'],\n                          'services' : [] } # services will be populated by the update method\n            self._register_config_file(config_file, conf_data)\n            log.info('Added %s config: %s', conf['config_type'], config_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def one(s: Sublemon):\n    shell_cmds = [\n        'sleep 1 && echo subprocess 1 in coroutine one',\n        'sleep 1 && echo subprocess 2 in coroutine one']\n    async for line in s.iter_lines(*shell_cmds):\n        print(line)", "response": "Spin up some subprocesses sleep and echo a message for this coro."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nspin up some subprocesses sleep and echo a message for this coro.", "response": "async def two(s: Sublemon):\n    \"\"\"Spin up some subprocesses, sleep, and echo a message for this coro.\"\"\"\n    subprocess_1, subprocess_2 = s.spawn(\n        'sleep 1 && echo subprocess 1 in coroutine two',\n        'sleep 1 && echo subprocess 2 in coroutine two')\n    async for line in amerge(subprocess_1.stdout, subprocess_2.stdout):\n        print(line.decode('utf-8'), end='')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets lines from a file.", "response": "def get_lines_from_file(filename, lineno, context_lines, loader=None, module_name=None):\n    \"\"\"\n    Returns context_lines before and after lineno from file.\n    Returns (pre_context_lineno, pre_context, context_line, post_context).\n    \"\"\"\n    source = None\n    if loader is not None and hasattr(loader, \"get_source\"):\n        try:\n            source = loader.get_source(module_name)\n        except ImportError:\n            # Traceback (most recent call last):\n            #   File \"/Users/dcramer/Development/django-sentry/sentry/client/handlers.py\", line 31, in emit\n            #     get_client().create_from_record(record, request=request)\n            #   File \"/Users/dcramer/Development/django-sentry/sentry/client/base.py\", line 325, in create_from_record\n            #     data['__sentry__']['frames'] = varmap(shorten, get_stack_info(stack))\n            #   File \"/Users/dcramer/Development/django-sentry/sentry/utils/stacks.py\", line 112, in get_stack_info\n            #     pre_context_lineno, pre_context, context_line, post_context = get_lines_from_file(filename, lineno, 7, loader, module_name)\n            #   File \"/Users/dcramer/Development/django-sentry/sentry/utils/stacks.py\", line 24, in get_lines_from_file\n            #     source = loader.get_source(module_name)\n            #   File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pkgutil.py\", line 287, in get_source\n            #     fullname = self._fix_name(fullname)\n            #   File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pkgutil.py\", line 262, in _fix_name\n            #     \"module %s\" % (self.fullname, fullname))\n            # ImportError: Loader for module cProfile cannot handle module __main__\n            source = None\n        if source is not None:\n            source = source.splitlines()\n\n    if source is None:\n        try:\n            f = open(filename)\n            try:\n                source = f.readlines()\n            finally:\n                f.close()\n        except (OSError, IOError):\n            pass\n\n    if source is None:\n        return []\n\n    encoding = 'ascii'\n    for line in source[:2]:\n        # File coding may be specified. Match pattern from PEP-263\n        # (http://www.python.org/dev/peps/pep-0263/)\n        match = _coding_re.search(line)\n        if match:\n            encoding = match.group(1)\n            break\n    source = [unicode(sline, encoding, 'replace') for sline in source]\n\n    lower_bound = max(0, lineno - context_lines)\n    upper_bound = min(lineno + context_lines + 1, len(source))\n\n    try:\n        return [(lineno + 1, source[lineno].strip('\\n')) for lineno in xrange(lower_bound, upper_bound)]\n    except IndexError:\n        # the file may have changed since it was loaded into memory\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a list of frames returns a list of stack information dictionary objects that are JSON - ready.", "response": "def get_stack_info(frames):\n    \"\"\"\n    Given a list of frames, returns a list of stack information\n    dictionary objects that are JSON-ready.\n\n    We have to be careful here as certain implementations of the\n    _Frame class do not contain the nescesary data to lookup all\n    of the information we want.\n    \"\"\"\n    __traceback_hide__ = True  # NOQA\n\n    results = []\n    for frame_info in frames:\n        # Old, terrible API\n        if isinstance(frame_info, (list, tuple)):\n            frame, lineno = frame_info\n\n        else:\n            frame = frame_info\n            lineno = frame_info.f_lineno\n\n        # Support hidden frames\n        f_locals = getattr(frame, 'f_locals', {})\n        if _getitem_from_frame(f_locals, '__traceback_hide__'):\n            continue\n\n        f_globals = getattr(frame, 'f_globals', {})\n        loader = _getitem_from_frame(f_globals, '__loader__')\n        module_name = _getitem_from_frame(f_globals, '__name__')\n\n        f_code = getattr(frame, 'f_code', None)\n        if f_code:\n            abs_path = frame.f_code.co_filename\n            function = frame.f_code.co_name\n        else:\n            abs_path = None\n            function = None\n\n        if lineno:\n            lineno -= 1\n\n        if lineno is not None and abs_path:\n            context = get_lines_from_file(abs_path, lineno, 3, loader, module_name)\n        else:\n            context = []\n\n        # Try to pull a relative file path\n        # This changes /foo/site-packages/baz/bar.py into baz/bar.py\n        try:\n            base_filename = sys.modules[module_name.split('.', 1)[0]].__file__\n            filename = abs_path.split(base_filename.rsplit('/', 2)[0], 1)[-1][1:]\n        except:\n            filename = abs_path\n\n        if not filename:\n            filename = abs_path\n\n        frame_result = {\n            'abs_path': abs_path,\n            'filename': filename,\n            'module': module_name,\n            'function': function,\n            'lineno': lineno + 1,\n            'context': context,\n        }\n        results.append(frame_result)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a catalog to a MOC.", "response": "def catalog_to_moc(catalog, radius, order, **kwargs):\n    \"\"\"\n    Convert a catalog to a MOC.\n\n    The catalog is given as an Astropy SkyCoord object containing\n    multiple coordinates.  The radius of catalog entries can be\n    given as an Astropy Quantity (with units), otherwise it is assumed\n    to be in arcseconds.\n\n    Any additional keyword arguments are passed on to `catalog_to_cells`.\n    \"\"\"\n\n    # Generate list of MOC cells.\n    cells = catalog_to_cells(catalog, radius, order, **kwargs)\n\n    # Create new MOC object using our collection of cells.\n    moc = MOC(moctype='CATALOG')\n    moc.add(order, cells, no_validation=True)\n    return moc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a catalog to a list of cells.", "response": "def _catalog_to_cells_neighbor(catalog, radius, order):\n    \"\"\"\n    Convert a catalog to a list of cells.\n\n    This is the original implementation of the `catalog_to_cells`\n    function which does not make use of the Healpy `query_disc` routine.\n\n    Note: this function uses a simple flood-filling approach and is\n    very slow, especially when used with a large radius for catalog objects\n    or a high resolution order.\n    \"\"\"\n\n    if not isinstance(radius, Quantity):\n        radius = radius * arcsecond\n\n    nside = 2 ** order\n\n    # Ensure catalog is in ICRS coordinates.\n    catalog = catalog.icrs\n\n    # Determine central cell for each catalog entry.\n    phi = catalog.ra.radian\n    theta = (pi / 2) - catalog.dec.radian\n\n    cells = np.unique(ang2pix(nside, theta, phi, nest=True))\n\n    # Iteratively consider the neighbors of cells within our\n    # catalog regions.\n    new_cells = cells\n    rejected = np.array((), dtype=np.int64)\n    while True:\n        # Find new valid neighboring cells which we didn't already\n        # consider.\n        neighbors = np.unique(np.ravel(\n            get_all_neighbours(nside, new_cells, nest=True)))\n\n        neighbors = np.extract(\n            [(x != -1) and (x not in cells) and (x not in rejected)\n             for x in neighbors], neighbors)\n\n        # Get the coordinates of each of these neighbors and compare them\n        # to the catalog entries.\n        (theta, phi) = pix2ang(nside, neighbors, nest=True)\n\n        coords = SkyCoord(phi, (pi / 2) - theta, frame='icrs', unit='rad')\n\n        (idx, sep2d, dist3d) = coords.match_to_catalog_sky(catalog)\n\n        within_range = (sep2d < radius)\n\n        # If we didn't find any new cells within range,\n        # end the iterative process.\n        if not np.any(within_range):\n            break\n\n        new_cells = neighbors[within_range]\n        cells = np.concatenate((cells, new_cells))\n        rejected = np.concatenate((\n            rejected, neighbors[np.logical_not(within_range)]))\n\n    return cells"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a catalog to a set of cells.", "response": "def catalog_to_cells(catalog, radius, order, include_fallback=True, **kwargs):\n    \"\"\"\n    Convert a catalog to a set of cells.\n\n    This function is intended to be used via `catalog_to_moc` but\n    is available for separate usage.  It takes the same arguments\n    as that function.\n\n    This function uses the Healpy `query_disc` function to get a list\n    of cells for each item in the catalog in turn.  Additional keyword\n    arguments, if specified, are passed to `query_disc`.  This can include,\n    for example, `inclusive` (set to `True` to include cells overlapping\n    the radius as well as those with centers within it) and `fact`\n    (to control sampling when `inclusive` is specified).\n\n    If cells at the given order are bigger than the given radius, then\n    `query_disc` may find none inside the radius.  In this case,\n    if `include_fallback` is `True` (the default), the cell at each\n    position is included.\n\n    If the given radius is zero (or smaller) then Healpy `query_disc`\n    is not used -- instead the fallback position is used automatically.\n    \"\"\"\n\n    nside = 2 ** order\n\n    # Ensure catalog is in ICRS coordinates.\n    catalog = catalog.icrs\n\n    # Ensure radius is in radians.\n    if isinstance(radius, Quantity):\n        radius = radius.to(radian).value\n    else:\n        radius = radius * pi / (180.0 * 3600.0)\n\n    # Convert coordinates to position vectors.\n    phi = catalog.ra.radian\n    theta = (pi / 2) - catalog.dec.radian\n\n    vectors = ang2vec(theta, phi)\n\n    # Ensure we can iterate over vectors (it might be a single position).\n    if catalog.isscalar:\n        vectors = [vectors]\n\n    # Query for a list of cells for each catalog position.\n    cells = set()\n    for vector in vectors:\n        if radius > 0.0:\n            # Try \"disc\" query.\n            vector_cells = query_disc(nside, vector, radius, nest=True, **kwargs)\n\n            if vector_cells.size > 0:\n                cells.update(vector_cells.tolist())\n                continue\n\n            elif not include_fallback:\n                continue\n\n        # The query didn't find anything -- include the cell at the\n        # given position at least.\n        cell = vec2pix(nside, vector[0], vector[1], vector[2], nest=True)\n        cells.add(cell.item())\n\n    return cells"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_ascii_catalog(filename, format_, unit=None):\n\n    catalog = ascii.read(filename, format=format_)\n    columns = catalog.columns\n\n    if 'RA' in columns and 'Dec' in columns:\n        if unit is None:\n            unit = (hour, degree)\n\n        coords = SkyCoord(catalog['RA'],\n                          catalog['Dec'],\n                          unit=unit,\n                          frame='icrs')\n\n    elif 'Lat' in columns and 'Lon' in columns:\n        if unit is None:\n            unit = (degree, degree)\n\n        coords = SkyCoord(catalog['Lon'],\n                          catalog['Lat'],\n                          unit=unit,\n                          frame='galactic')\n\n    else:\n        raise Exception('columns RA,Dec or Lon,Lat not found')\n\n    return coords", "response": "Reads an ASCII catalog file using Astropy."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_application(self, team_id, name, url=None):\n        params = {'name': name}\n        if url:\n            params['url'] = url\n        return self._request('POST', 'rest/teams/' + str(team_id) + '/applications/new', params)", "response": "Creates an application under a given team."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving an application by name.", "response": "def get_application_by_name(self, team_name, application_name):\n        \"\"\"\n        Retrieves an application using the given team name and application name.\n        :param team_name: The name of the team of the application to be retrieved.\n        :param application_name: The name of the application to be retrieved.\n        \"\"\"\n        return self._request('GET', 'rest/applications/' + str(team_name) + '/lookup?name=' + str(application_name))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the parameters for the Hybrid Analysis Mapping ThreadFix functionality.", "response": "def set_application_parameters(self, application_id, framework_type, repository_url):\n        \"\"\"\n        Sets parameters for the Hybrid Analysis Mapping ThreadFix functionality.\n        :param application_id: Application identifier.\n        :param framework_type: The web framework the app was built on. ('None', 'DETECT', 'JSP', 'SPRING_MVC')\n        :param repository_url: The git repository where the source code for the application can be found.\n        \"\"\"\n        params = {\n            'frameworkType': framework_type,\n            'repositoryUrl': repository_url\n        }\n        return self._request('POST', 'rest/applications/' + str(application_id) + '/setParameters', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_manual_finding(self, application_id, vulnerability_type, description, severity, full_url=None,\n                              native_id=None, path=None):\n        \"\"\"\n        Creates a manual finding with given properties.\n        :param application_id: Application identification.\n        :param vulnerability_type: Name of CWE vulnerability.\n        :param description: General description of the issue.\n        :param severity: Severity level from 0-8.\n        :param full_url: Absolute URL to the page with the vulnerability.\n        :param native_id: Specific identifier for vulnerability.\n        :param path: Relative path to vulnerability page.\n        \"\"\"\n\n        params = {\n            'isStatic': False,\n            'vulnType': vulnerability_type,\n            'longDescription': description,\n            'severity': severity\n        }\n\n        if full_url:\n            params['fullUrl'] = full_url\n        if native_id:\n            params['nativeId'] = native_id\n        if path:\n            params['path'] = path\n\n        return self._request('POST', 'rest/applications/' + str(application_id) + '/addFinding', params)", "response": "Creates a manual finding with given properties."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a static finding with given properties.", "response": "def create_static_finding(self, application_id, vulnerability_type, description, severity, parameter=None,\n                              file_path=None, native_id=None, column=None, line_text=None, line_number=None):\n        \"\"\"\n        Creates a static finding with given properties.\n        :param application_id: Application identifier number.\n        :param vulnerability_type: Name of CWE vulnerability.\n        :param description: General description of the issue.\n        :param severity: Severity level from 0-8.\n        :param parameter: Request parameter for vulnerability.\n        :param file_path: Location of source file.\n        :param native_id: Specific identifier for vulnerability.\n        :param column: Column number for finding vulnerability source.\n        :param line_text: Specific line text to finding vulnerability.\n        :param line_number: Specific source line number to finding vulnerability.\n        \"\"\"\n\n        if not parameter and not file_path:\n            raise AttributeError('Static findings require either parameter or file_path to be present.')\n\n        params = {\n            'isStatic': True,\n            'vulnType': vulnerability_type,\n            'longDescription': description,\n            'severity': severity\n        }\n\n        if native_id:\n            params['nativeId'] = native_id\n        if column:\n            params['column'] = column\n        if line_text:\n            params['lineText'] = line_text\n        if line_number:\n            params['lineNumber'] = line_number\n\n        return self._request('POST', 'rest/applications/' + str(application_id) + '/addFinding', params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upload_scan(self, application_id, file_path):\n        return self._request(\n            'POST', 'rest/applications/' + str(application_id) + '/upload',\n            files={'file': open(file_path, 'rb')}\n        )", "response": "Uploads and processes a scan file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_waf(self, name, waf_type):\n        params = {\n            'name': name,\n            'type': waf_type\n        }\n        return self._request('POST', 'rest/wafs/new', params)", "response": "Creates a WAF with the given name and type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the WAF rules for one or all of the applications in a WAF.", "response": "def get_waf_rules_by_application(self, waf_id, application_id):\n        \"\"\"\n        Returns the WAF rule text for one or all of the applications in a WAF. If the application id is -1, it will get\n        rules for all apps. If the application is a valid application id, rules will be generated for that application.\n        :param waf_id: WAF identifier.\n        :param application_id: Application identifier.\n        \"\"\"\n        return self._request('GET', 'rest/wafs/' + str(waf_id) + '/rules/app/' + str(application_id))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads and processes a WAF log file.", "response": "def upload_waf_log(self, waf_id, file_path):\n        \"\"\"\n        Uploads and processes a WAF log.\n        :param waf_id: WAF identifier.\n        :param file_path: Path to the WAF log file to be uploaded.\n        \"\"\"\n        return self._request('POST', 'rest/wafs/' + str(waf_id) + '/uploadLog', files={'file': open(file_path, 'rb')})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of vulnerabilities for a given scan.", "response": "def get_vulnerabilities(self, teams=None, applications=None, channel_types=None, start_date=None, end_date=None,\n                            generic_severities=None, generic_vulnerabilities=None, number_merged=None,\n                            number_vulnerabilities=None, parameter=None, path=None, show_open=None, show_closed=None,\n                            show_defect_open=None, show_defect_closed=None, show_defect_present=None,\n                            show_defect_not_present=None, show_false_positive=None, show_hidden=None):\n        \"\"\"\n        Returns filtered list of vulnerabilities.\n        :param teams: List of team ids.\n        :param applications: List of application ids.\n        :param channel_types: List of scanner names.\n        :param start_date: Lower bound on scan dates.\n        :param end_date: Upper bound on scan dates.\n        :param generic_severities: List of generic severity values.\n        :param generic_vulnerabilities: List of generic vulnerability ids.\n        :param number_merged: Number of vulnerabilities merged from different scans.\n        :param number_vulnerabilities: Number of vulnerabilities to return.\n        :param parameter: Application input that the vulnerability affects.\n        :param path: Path to the web page where the vulnerability was found.\n        :param show_open: Flag to show all open vulnerabilities.\n        :param show_closed: Flag to show all closed vulnerabilities.\n        :param show_defect_open: Flag to show any vulnerabilities with open defects.\n        :param show_defect_closed: Flag to show any vulnerabilities with closed defects.\n        :param show_defect_present: Flag to show any vulnerabilities with a defect.\n        :param show_defect_not_present: Flag to show any vulnerabilities without a defect.\n        :param show_false_positive: Flag to show any false positives from vulnerabilities.\n        :param show_hidden: Flag to show all hidden vulnerabilities.\n        \"\"\"\n        params = {}\n\n        # Build parameter list\n        if teams:\n            params.update(self._build_list_params('teams', 'id', teams))\n        if applications:\n            params.update(self._build_list_params('applications', 'id', applications))\n        if channel_types:\n            params.update(self._build_list_params('channelTypes', 'name', channel_types))\n        if start_date:\n            params['startDate'] = start_date\n        if end_date:\n            params['endDate'] = end_date\n        if generic_severities:\n            params.update(self._build_list_params('genericSeverities', 'intValue', generic_severities))\n        if generic_vulnerabilities:\n            params.update(self._build_list_params('genericVulnerabilities', 'id', generic_vulnerabilities))\n        if number_merged:\n            params['numberMerged'] = number_merged\n        if number_vulnerabilities:\n            params['numberVulnerabilities'] = number_vulnerabilities\n        if parameter:\n            params['parameter'] = parameter\n        if path:\n            params['path'] = path\n        if show_open:\n            params['showOpen'] = show_open\n        if show_closed:\n            params['showClosed'] = show_closed\n        if show_defect_open:\n            params['showDefectOpen'] = show_defect_open\n        if show_defect_closed:\n            params['showDefectClosed'] = show_defect_closed\n        if show_defect_present:\n            params['showDefectPresent'] = show_defect_present\n        if show_defect_not_present:\n            params['showDefectNotPresent'] = show_defect_not_present\n        if show_false_positive:\n            params['showFalsePositive'] = show_false_positive\n        if show_hidden:\n            params['showHidden'] = show_hidden\n\n        return self._request('POST', 'rest/vulnerabilities', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _build_list_params(param_name, key, values):\n        params = {}\n        if hasattr(values, '__iter__'):\n            index = 0\n            for value in values:\n                params[str(param_name) + '[' + str(index) + '].' + str(key)] = str(value)\n                index += 1\n        else:\n            params[str(param_name) + '[0].' + str(key)] = str(values)\n        return params", "response": "Builds a list of POST parameters from a list or single value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _request(self, method, url, params=None, files=None):\n        if not params:\n            params = {}\n        params['apiKey'] = self.api_key\n\n        headers = {\n            'User-Agent': self.user_agent,\n            'Accept': 'application/json'\n        }\n\n        try:\n            if self.debug:\n                print(method + ' ' + url)\n                print(params)\n\n            response = requests.request(method=method, url=self.host + url, params=params, files=files, headers=headers,\n                                        timeout=self.timeout, verify=self.verify_ssl, cert=self.cert)\n\n            if self.debug:\n                print(response.status_code)\n                print(response.text)\n\n            try:\n                json_response = response.json()\n\n                message = json_response['message']\n                success = json_response['success']\n                response_code = json_response['responseCode']\n                data = json_response['object']\n\n                return ThreadFixResponse(message=message, success=success, response_code=response_code, data=data)\n            except ValueError:\n                return ThreadFixResponse(message='JSON response could not be decoded.', success=False)\n        except requests.exceptions.SSLError:\n            return ThreadFixResponse(message='An SSL error occurred.', success=False)\n        except requests.exceptions.ConnectionError:\n            return ThreadFixResponse(message='A connection error occurred.', success=False)\n        except requests.exceptions.Timeout:\n            return ThreadFixResponse(message='The request timed out after ' + str(self.timeout) + ' seconds.',\n                                     success=False)\n        except requests.exceptions.RequestException:\n            return ThreadFixResponse(message='There was an error while handling the request.', success=False)", "response": "Common handler for all HTTP requests."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef data_json(self, pretty=False):\n        if pretty:\n            return json.dumps(self.data, sort_keys=True, indent=4, separators=(',', ': '))\n        else:\n            return json.dumps(self.data)", "response": "Returns the data as a valid JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_anchor_diff(anchor):\n    new_anchor = make_anchor(\n        file_path=anchor.file_path,\n        offset=anchor.context.offset,\n        width=len(anchor.context.topic),\n        context_width=anchor.context.width,\n        metadata=anchor.metadata)\n\n    assert anchor.file_path == new_anchor.file_path\n    assert anchor.context.offset == new_anchor.context.offset\n    assert len(anchor.context.topic) == len(new_anchor.context.topic)\n    assert anchor.metadata == new_anchor.metadata\n\n    return tuple(\n        _context_diff(\n            anchor.file_path,\n            anchor.context,\n            new_anchor.context))", "response": "Get the get_anchor_diff between an anchor and the current state of its source."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a new anchor from a file - like object.", "response": "def make_anchor(file_path: pathlib.Path,\n                offset: int,\n                width: int,\n                context_width: int,\n                metadata,\n                encoding: str = 'utf-8',\n                handle=None):\n    \"\"\"Construct a new `Anchor`.\n\n    Args:\n        file_path: The absolute path to the target file for the anchor.\n        offset: The offset of the anchored text in codepoints in `file_path`'s\n            contents.\n        width: The width in codepoints of the anchored text.\n        context_width: The width in codepoints of context on either side of the\n            anchor.\n        metadata: The metadata to attach to the anchor. Must be json-serializeable.\n        encoding: The encoding of the contents of `file_path`.\n        handle: If not `None`, this is a file-like object the contents of which\n            are used to calculate the context of the anchor. If `None`, then\n            the file indicated by `file_path` is opened instead.\n\n    Raises:\n        ValueError: `width` characters can't be read at `offset`.\n        ValueError: `file_path` is not absolute.\n\n    \"\"\"\n\n    @contextmanager\n    def get_handle():\n        if handle is None:\n            with file_path.open(mode='rt', encoding=encoding) as fp:\n                yield fp\n        else:\n            yield handle\n\n    with get_handle() as fp:\n        context = _make_context(fp, offset, width, context_width)\n\n    return Anchor(\n        file_path=file_path,\n        encoding=encoding,\n        context=context,\n        metadata=metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rgba_to_int(cls, red, green, blue, alpha):\n        red = unwrap(red)\n        green = unwrap(green)\n        blue = unwrap(blue)\n        alpha = unwrap(alpha)\n        if red is None or green is None or blue is None:\n            return None\n        if alpha is None:\n            alpha = 255\n        r = red << 24\n        g = green << 16\n        b = blue << 8\n        a = alpha << 0\n        rgba_int = r+g+b+a\n        if (rgba_int > (2**31-1)):       # convert to signed 32-bit int\n            rgba_int = rgba_int - 2**32\n        return rgba_int", "response": "Converts a color in RGBA encoding to an Integer in RGBA encoding."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def amerge(*agens) -> AsyncGenerator[Any, None]:\n    xs = stream.merge(*agens)\n    async with xs.stream() as streamer:\n        async for x in streamer:\n            yield x", "response": "A generator that yields all the elements in the iterable agens."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncrossing - platform method for running a subprocess - spawning coroutine.", "response": "def crossplat_loop_run(coro) -> Any:\n    \"\"\"Cross-platform method for running a subprocess-spawning coroutine.\"\"\"\n    if sys.platform == 'win32':\n        signal.signal(signal.SIGINT, signal.SIG_DFL)\n        loop = asyncio.ProactorEventLoop()\n    else:\n        loop = asyncio.new_event_loop()\n\n    asyncio.set_event_loop(loop)\n    with contextlib.closing(loop):\n        return loop.run_until_complete(coro)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef quantiles(xs, qs=None, step=25, width=None, cellspacing=3):\n    '''\n    Use stats.quantiles to get quantile-value pairs, and then print them to fit.\n    >>> import numpy as np\n    >>> quantiles(np.random.normal(size=10000), qs=[0, 5, 50, 95, 100])\n     0% < -3.670    5% < -1.675   50% < -0.002   95% < 1.6500   100% < 3.4697\n    (Or something like that)\n    '''\n\n    if width is None:\n        width = terminal.width()\n\n    qs_values = stats.quantiles(xs, qs=qs, step=step)\n\n    ncells = len(qs_values)\n    cellspacing_total = (ncells - 1) * cellspacing\n    cell_width = int((width - cellspacing_total) / ncells)\n\n    cells = ['%2d%% < %s' % (q, format_float(value, cell_width - 6)) for q, value in qs_values]\n\n    print (' '*cellspacing).join(cells)", "response": "Print quantiles for a list of values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse an argument string Reliability http://stackoverflow. com/questions/18160078/is_a_config_file - a configuration file - a log - level - a log level - a log level - a log level - a log level", "response": "def parse_args(args):\n    ''' Parse an argument string\n\n        http://stackoverflow.com/questions/18160078/\n        how-do-you-write-tests-for-the-argparse-portion-of-a-python-module\n    '''\n    parser = argparse.ArgumentParser()\n    parser.add_argument('config_file', nargs='?',\n                        help='Configuration yaml file', default=None)\n    parser.add_argument(\n        '--log', '-l',\n        help='Logging level (e.g. DEBUG, INFO, WARNING, ERROR, CRITICAL)',\n        default='INFO')\n    args_parsed = parser.parse_args(args)\n    if not args_parsed.config_file:\n        parser.error(\"You have to specify \"\n                     \"a configuration file\")  # pragma: no cover, sysexit\n    return args_parsed"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a module of a given base class type Parameter -------- importname: string Name of the module, etc. converter base_class_type: class type E.g converter path: Absoulte path of the module Neede for extensions. If not given module is in online_monitor package *args, **kargs: Arguments to pass to the object init Return ------ Object of given base class type", "response": "def _factory(importname, base_class_type, path=None, *args, **kargs):\n    ''' Load a module of a given base class type\n\n        Parameter\n        --------\n        importname: string\n            Name of the module, etc. converter\n        base_class_type: class type\n            E.g converter\n        path: Absoulte path of the module\n            Neede for extensions. If not given module is in online_monitor\n            package\n        *args, **kargs:\n            Arguments to pass to the object init\n\n        Return\n        ------\n        Object of given base class type\n    '''\n\n    def is_base_class(item):\n        return isclass(item) and item.__module__ == importname\n\n    if path:\n        # Needed to find the module in forked processes; if you know a better\n        # way tell me!\n        sys.path.append(path)\n        # Absolute full path of python module\n        absolute_path = os.path.join(path, importname) + '.py'\n        module = imp.load_source(importname, absolute_path)\n    else:\n        module = import_module(importname)\n\n    # Get the defined base class in the loaded module to be name indendend\n    clsmembers = getmembers(module, is_base_class)\n    if not len(clsmembers):\n        raise ValueError('Found no matching class in %s.' % importname)\n    else:\n        cls = clsmembers[0][1]\n    return cls(*args, **kargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef json_numpy_obj_hook(dct):\n    if isinstance(dct, dict) and '__ndarray__' in dct:\n        array = dct['__ndarray__']\n        # http://stackoverflow.com/questions/24369666/typeerror-b1-is-not-json-serializable\n        if sys.version_info >= (3, 0):\n            array = array.encode('utf-8')\n        data = base64.b64decode(array)\n        if has_blosc:\n            data = blosc.decompress(data)\n\n        try:\n            dtype = np.dtype(ast.literal_eval(dct['dtype']))\n        except ValueError:  # If the array is not a recarray\n            dtype = dct['dtype']\n\n        return np.frombuffer(data, dtype).reshape(dct['shape'])\n\n    return dct", "response": "Decodes a previously encoded numpy ndarray with proper shape and dtype."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a default dictionary for the object.", "response": "def default(self, obj):\n        \"\"\"If input object is an ndarray it will be converted into a dict\n        holding dtype, shape and the data, base64 encoded and blosc compressed.\n        \"\"\"\n        if isinstance(obj, np.ndarray):\n            if obj.flags['C_CONTIGUOUS']:\n                obj_data = obj.data\n            else:\n                cont_obj = np.ascontiguousarray(obj)\n                assert(cont_obj.flags['C_CONTIGUOUS'])\n                obj_data = cont_obj.data\n            if has_blosc:\n                obj_data = blosc.compress(obj_data, typesize=8)\n            data_b64 = base64.b64encode(obj_data)\n            # http://stackoverflow.com/questions/24369666/typeerror-b1-is-not-json-serializable\n            if sys.version_info >= (3, 0):\n                data_b64 = data_b64.decode('utf-8')\n            return dict(__ndarray__=data_b64,\n                        dtype=str(obj.dtype),\n                        shape=obj.shape)\n        return json.JSONEncoder.default(self, obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse DSSP to find helices and extracts helices from a pdb file or string.", "response": "def run_dssp(pdb, path=True):\n    \"\"\"Uses DSSP to find helices and extracts helices from a pdb file or string.\n    Parameters\n    ----------\n    pdb : str\n        Path to pdb file or string.\n    path : bool, optional\n        Indicates if pdb is a path or a string.\n\n    Returns\n    -------\n    dssp_out : str\n        Std out from DSSP.\n    \"\"\"\n    if not path:\n        if isinstance(pdb, str):\n            pdb = pdb.encode()\n        with tempfile.NamedTemporaryFile() as temp_pdb:\n            temp_pdb.write(pdb)\n            temp_pdb.seek(0)\n            dssp_out = subprocess.check_output(\n                ['mkdssp', temp_pdb.name])\n    else:\n        dssp_out = subprocess.check_output(\n            ['mkdssp', pdb])\n    dssp_out = dssp_out.decode()\n    return dssp_out"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract_all_ss_dssp(in_dssp, path=True):\n\n    if path:\n        with open(in_dssp, 'r') as inf:\n            dssp_out = inf.read()\n    else:\n        dssp_out = in_dssp[:]\n    dssp_residues = []\n    active = False\n    for line in dssp_out.splitlines():\n        if active:\n            try:\n                res_num = int(line[5:10].strip())\n                chain = line[10:12].strip()\n                residue = line[13]\n                ss_type = line[16]\n                phi = float(line[103:109].strip())\n                psi = float(line[109:116].strip())\n                acc = int(line[35:38].strip())\n                dssp_residues.append(\n                    (res_num, ss_type, chain, residue, phi, psi, acc))\n            except ValueError:\n                pass\n        else:\n            if line[2] == '#':\n                active = True\n    return dssp_residues", "response": "Uses DSSP to extract secondary structure information on every residue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a list of DSSP residues and a list of loop assignments find the continuous regions of secondary structure.", "response": "def find_ss_regions(dssp_residues, loop_assignments=(' ', 'B', 'S', 'T')):\n    \"\"\"Separates parsed DSSP data into groups of secondary structure.\n\n    Notes\n    -----\n    Example: all residues in a single helix/loop/strand will be gathered\n    into a list, then the next secondary structure element will be\n    gathered into a separate list, and so on.\n\n    Parameters\n    ----------\n    dssp_residues : [tuple]\n        Each internal list contains:\n            [0] int Residue number\n            [1] str Secondary structure type\n            [2] str Chain identifier\n            [3] str Residue type\n            [4] float Phi torsion angle\n            [5] float Psi torsion angle\n            [6] int dssp solvent accessibility\n\n    Returns\n    -------\n    fragments : [[list]]\n        Lists grouped in continuous regions of secondary structure.\n        Innermost list has the same format as above.\n    \"\"\"\n\n    loops = loop_assignments\n    previous_ele = None\n    fragment = []\n    fragments = []\n    for ele in dssp_residues:\n        if previous_ele is None:\n            fragment.append(ele)\n        elif ele[2] != previous_ele[2]:\n            fragments.append(fragment)\n            fragment = [ele]\n        elif previous_ele[1] in loops:\n            if ele[1] in loops:\n                fragment.append(ele)\n            else:\n                fragments.append(fragment)\n                fragment = [ele]\n        else:\n            if ele[1] == previous_ele[1]:\n                fragment.append(ele)\n            else:\n                fragments.append(fragment)\n                fragment = [ele]\n        previous_ele = ele\n    fragments.append(fragment)\n    return fragments"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tag_dssp_data(assembly, loop_assignments=(' ', 'B', 'S', 'T')):\n    dssp_out = run_dssp(assembly.pdb, path=False)\n    dssp_data = extract_all_ss_dssp(dssp_out, path=False)\n    for record in dssp_data:\n        rnum, sstype, chid, _, phi, psi, sacc = record\n        assembly[chid][str(rnum)].tags['dssp_data'] = {\n            'ss_definition': sstype,\n            'solvent_accessibility': sacc,\n            'phi': phi,\n            'psi': psi\n        }\n    ss_regions = find_ss_regions(dssp_data, loop_assignments)\n    for region in ss_regions:\n        chain = region[0][2]\n        ss_type = ' ' if region[0][1] in loop_assignments else region[0][1]\n        first_residue = str(region[0][0])\n        last_residue = str(region[-1][0])\n        if not 'ss_regions' in assembly[chain].tags:\n            assembly[chain].tags['ss_regions'] = []\n        assembly[chain].tags['ss_regions'].append(\n            (first_residue, last_residue, ss_type))\n    return", "response": "Adds output data from DSSP to an Assembly."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an Assembly containing Polymers for each region of secondary structure.", "response": "def get_ss_regions(assembly, ss_types):\n    \"\"\"Returns an Assembly containing Polymers for each region of structure.\n\n    Parameters\n    ----------\n    assembly : ampal.Assembly\n        `Assembly` object to be searched secondary structure regions.\n    ss_types : list\n        List of secondary structure tags to be separate i.e. ['H']\n        would return helices, ['H', 'E'] would return helices\n        and strands.\n\n    Returns\n    -------\n    fragments : Assembly\n        `Assembly` containing a `Polymer` for each region of specified\n        secondary structure.\n    \"\"\"\n    if not any(map(lambda x: 'ss_regions' in x.tags, assembly)):\n        raise ValueError(\n            'This assembly does not have any tagged secondary structure '\n            'regions. Use `ampal.dssp.tag_dssp_data` to add the tags.'\n        )\n    fragments = Assembly()\n    for polypeptide in assembly:\n        if 'ss_regions' in polypeptide.tags:\n            for start, end, ss_type in polypeptide.tags['ss_regions']:\n                if ss_type in ss_types:\n                    fragment = polypeptide.get_slice_from_res_id(start, end)\n                    fragments.append(fragment)\n    if not fragments:\n        raise ValueError('No regions matching that secondary structure type'\n                         ' have been found. Use standard DSSP labels.')\n    return fragments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract(query_dict, prefix=\"\"):\n\n    strs = ['order_by']\n    ints = ['per_page', 'page']\n\n    extracted = { }\n\n    for key in (strs + ints):\n        if (prefix + key) in query_dict:\n            val = query_dict.get(prefix + key)\n\n            extracted[key] = (val\n                if not key in ints\n                else int(val))\n\n    return extracted", "response": "Extract the order_by per_page and page parameters from a Django QueryDict and return a dict suitable for instantiating a preconfigured Table object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a mutable copy of query_dict.", "response": "def _copy(query_dict):\n    \"\"\"\n    Return a mutable copy of `query_dict`. This is a workaround to\n    Django bug #13572, which prevents QueryDict.copy from working.\n    \"\"\"\n\n    memo = { }\n\n    result = query_dict.__class__('',\n        encoding=query_dict.encoding,\n        mutable=True)\n\n    memo[id(query_dict)] = result\n\n    for key, value in dict.items(query_dict):\n        dict.__setitem__(result,\n            copy.deepcopy(key, memo),\n            copy.deepcopy(value, memo))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snaql_migration(ctx, db_uri, migrations, app, config):\n\n    if config:\n        migrations_config = _parse_config(config)\n    else:\n        if db_uri and migrations and app:\n            migrations_config = _generate_config(db_uri, migrations, app)\n        else:\n            raise click.ClickException('If --config is not set, then --db-uri, --migrations and --app must be provided')\n\n    ctx.obj = {\n        'config': migrations_config\n    }\n\n    try:\n        ctx.obj['db'] = DBWrapper(ctx.obj['config']['db_uri'])\n    except Exception as e:\n        raise click.ClickException('Unable to connect to database, exception is \"{0}\"'.format(str(e)))", "response": "Lightweight SQL Schema migration tool based on Snaql queries"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply(ctx, name, verbose):\n\n    if name != 'all':  # specific migration\n        try:\n            app_name, target_migration = name.split('/', 2)\n        except ValueError:\n            raise click.ClickException(\"NAME format is <app>/<migration> or 'all'\")\n\n        apps = ctx.obj['config']['apps']\n        if app_name not in apps.keys():\n            raise click.ClickException('unknown app \"{0}\"'.format(app_name))\n\n        app = apps[app_name]\n        migrations = app['migrations']\n        if target_migration not in migrations:\n            raise click.ClickException('unknown migration \"{0}\"'.format(name))\n\n        migrations = migrations[:migrations.index(target_migration) + 1]  # including all prevoius migrations\n        for migration in migrations:\n            click.echo(click.style('Applying {0}...'.format(click.style(migration, bold=True)), fg='blue'))\n\n            if ctx.obj['db'].is_migration_applied(app_name, migration):\n                click.echo(click.style('  SKIPPED.', fg='green'))\n                continue\n\n            try:\n                snaql_factory = Snaql(app['path'], '')\n                queries = snaql_factory.load_queries(migration + '.apply.sql').ordered_blocks\n\n                for query in queries:\n                    if verbose:\n                        click.echo('    ' + query())\n\n                    ctx.obj['db'].query(query())\n\n            except Exception as e:\n                click.echo(click.style('  FAILED.', fg='red'))\n                ctx.obj['db'].rollback()\n                raise click.ClickException('migration execution failed\\n{0}'.format(e))\n\n            click.echo(click.style('  OK.', fg='green'))\n\n            ctx.obj['db'].commit()\n\n            ctx.obj['db'].fix_migration(app_name, migration)\n\n    else:  # migrate everything\n        for app_name, app in ctx.obj['config']['apps'].items():\n            click.echo(click.style('Migrating {0}...'.format(click.style(app_name, bold=True)), fg='blue'))\n\n            for migration in app['migrations']:\n                click.echo('  Applying {0}...'.format(click.style(migration, bold=True)))\n\n                if ctx.obj['db'].is_migration_applied(app_name, migration):\n                    click.echo(click.style('    SKIPPED.', fg='green'))\n                    continue\n\n                try:\n                    snaql_factory = Snaql(app['path'], '')\n                    queries = snaql_factory.load_queries(migration + '.apply.sql').ordered_blocks\n\n                    for query in queries:\n                        if verbose:\n                            click.echo('    ' + query())\n\n                        ctx.obj['db'].query(query())\n\n                except Exception as e:\n                    click.echo(click.style('    FAILED.', fg='red'))\n                    ctx.obj['db'].rollback()\n                    raise click.ClickException('migration execution failed\\n{0}'.format(e))\n\n                click.echo(click.style('  OK.', fg='green'))\n\n                ctx.obj['db'].commit()\n\n                ctx.obj['db'].fix_migration(app_name, migration)", "response": "Apply a migration to a single language."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bundle(self, name: str) -> models.Bundle:\n        return self.Bundle.filter_by(name=name).first()", "response": "Fetch a bundle from the store."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef version(self, bundle: str, date: dt.datetime) -> models.Version:\n        return (self.Version.query\n                            .join(models.Version.bundle)\n                            .filter(models.Bundle.name == bundle,\n                                    models.Version.created_at == date)\n                            .first())", "response": "Fetch a version from the store."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a tag from the database.", "response": "def tag(self, name: str) -> models.Tag:\n        \"\"\"Fetch a tag from the database.\"\"\"\n        return self.Tag.filter_by(name=name).first()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new file bundle.", "response": "def new_bundle(self, name: str, created_at: dt.datetime=None) -> models.Bundle:\n        \"\"\"Create a new file bundle.\"\"\"\n        new_bundle = self.Bundle(name=name, created_at=created_at)\n        return new_bundle"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_version(self, created_at: dt.datetime, expires_at: dt.datetime=None) -> models.Version:\n        new_version = self.Version(created_at=created_at, expires_at=expires_at)\n        return new_version", "response": "Create a new version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_file(self, path: str, checksum: str=None, to_archive: bool=False,\n                 tags: List[models.Tag]=None) -> models.File:\n        \"\"\"Create a new file.\"\"\"\n        new_file = self.File(path=path, checksum=checksum, to_archive=to_archive, tags=tags)\n        return new_file", "response": "Create a new file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_tag(self, name: str, category: str=None) -> models.Tag:\n        new_tag = self.Tag(name=name, category=category)\n        return new_tag", "response": "Create a new tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef files(self, *, bundle: str=None, tags: List[str]=None, version: int=None,\n              path: str=None) -> models.File:\n        \"\"\"Fetch files from the store.\"\"\"\n        query = self.File.query\n        if bundle:\n            query = (query.join(self.File.version, self.Version.bundle)\n                          .filter(self.Bundle.name == bundle))\n\n        if tags:\n            # require records to match ALL tags\n            query = (\n                query.join(self.File.tags)\n                .filter(self.Tag.name.in_(tags))\n                .group_by(models.File.id)\n                .having(func.count(models.Tag.name) == len(tags))\n            )\n\n        if version:\n            query = query.join(self.File.version).filter(self.Version.id == version)\n\n        if path:\n            query = query.filter_by(path=path)\n\n        return query", "response": "Fetch files from the store."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef files_before(self, *, bundle: str=None, tags: List[str]=None, before:\n                     str=None) -> models.File:\n        \"\"\"Fetch files before date from store\"\"\"\n        query = self.files(tags=tags, bundle=bundle)\n        if before:\n            before_dt = parse_date(before)\n            query = query.join(models.Version).filter(models.Version.created_at < before_dt)\n\n        return query", "response": "Fetch files before date"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of files that are not on disk.", "response": "def files_ondisk(self, file_objs: models.File) -> set:\n        \"\"\"Returns a list of files that are not on disk.\"\"\"\n\n        return set([ file_obj for file_obj in file_objs if Path(file_obj.full_path).is_file() ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _unquote_c_string(s):\n\n     # doing a s.encode('utf-8').decode('unicode_escape') can return an\n     # incorrect output with unicode string (both in py2 and py3) the safest way\n     # is to match the escape sequences and decoding them alone.\n     def decode_match(match):\n          return utf8_bytes_string(\n               codecs.decode(match.group(0), 'unicode-escape')\n          )\n\n     if sys.version_info[0] >= 3 and isinstance(s, bytes):\n          return ESCAPE_SEQUENCE_BYTES_RE.sub(decode_match, s)\n     else:\n          return ESCAPE_SEQUENCE_RE.sub(decode_match, s)", "response": "replace C - style escape sequences (\\ n etc. with real chars."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef readline(self):\n        self.lineno += 1\n        if self._buffer:\n            return self._buffer.pop()\n        else:\n            return self.input.readline()", "response": "Get the next line including the newline or '' on EOF."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef push_line(self, line):\n        self.lineno -= 1\n        self._buffer.append(line + b'\\n')", "response": "Push a line back onto the line buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a given number of bytes from the input stream.", "response": "def read_bytes(self, count):\n        \"\"\"Read a given number of bytes from the input stream.\n\n        Throws MissingBytes if the bytes are not found.\n\n        Note: This method does not read from the line buffer.\n\n        :return: a string\n        \"\"\"\n        result = self.input.read(count)\n        found = len(result)\n        self.lineno += result.count(b'\\n')\n        if found != count:\n            self.abort(errors.MissingBytes, count, found)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the input stream until the terminator is found.", "response": "def read_until(self, terminator):\n        \"\"\"Read the input stream until the terminator is found.\n\n        Throws MissingTerminator if the terminator is not found.\n\n        Note: This method does not read from the line buffer.\n\n        :return: the bytes read up to but excluding the terminator.\n        \"\"\"\n\n        lines = []\n        term = terminator + b'\\n'\n        while True:\n            line = self.input.readline()\n            if line == term:\n                break\n            else:\n                lines.append(line)\n        return b''.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating over the commands in order of likelihood.", "response": "def iter_commands(self):\n        \"\"\"Iterator returning ImportCommand objects.\"\"\"\n        while True:\n            line = self.next_line()\n            if line is None:\n                if b'done' in self.features:\n                    raise errors.PrematureEndOfStream(self.lineno)\n                break\n            elif len(line) == 0 or line.startswith(b'#'):\n                continue\n            # Search for commands in order of likelihood\n            elif line.startswith(b'commit '):\n                yield self._parse_commit(line[len(b'commit '):])\n            elif line.startswith(b'blob'):\n                yield self._parse_blob()\n            elif line.startswith(b'done'):\n                break\n            elif line.startswith(b'progress '):\n                yield commands.ProgressCommand(line[len(b'progress '):])\n            elif line.startswith(b'reset '):\n                yield self._parse_reset(line[len(b'reset '):])\n            elif line.startswith(b'tag '):\n                yield self._parse_tag(line[len(b'tag '):])\n            elif line.startswith(b'checkpoint'):\n                yield commands.CheckpointCommand()\n            elif line.startswith(b'feature'):\n                yield self._parse_feature(line[len(b'feature '):])\n            else:\n                self.abort(errors.InvalidCommand, line)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iter_file_commands(self):\n        while True:\n            line = self.next_line()\n            if line is None:\n                break\n            elif len(line) == 0 or line.startswith(b'#'):\n                continue\n            # Search for file commands in order of likelihood\n            elif line.startswith(b'M '):\n                yield self._parse_file_modify(line[2:])\n            elif line.startswith(b'D '):\n                path = self._path(line[2:])\n                yield commands.FileDeleteCommand(path)\n            elif line.startswith(b'R '):\n                old, new = self._path_pair(line[2:])\n                yield commands.FileRenameCommand(old, new)\n            elif line.startswith(b'C '):\n                src, dest = self._path_pair(line[2:])\n                yield commands.FileCopyCommand(src, dest)\n            elif line.startswith(b'deleteall'):\n                yield commands.FileDeleteAllCommand()\n            else:\n                self.push_line(line)\n                break", "response": "Iterate over the file commands in order of likelihood."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a blob command.", "response": "def _parse_blob(self):\n        \"\"\"Parse a blob command.\"\"\"\n        lineno = self.lineno\n        mark = self._get_mark_if_any()\n        data = self._get_data(b'blob')\n        return commands.BlobCommand(mark, data, lineno)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_commit(self, ref):\n        lineno  = self.lineno\n        mark = self._get_mark_if_any()\n        author = self._get_user_info(b'commit', b'author', False)\n        more_authors = []\n        while True:\n            another_author = self._get_user_info(b'commit', b'author', False)\n            if another_author is not None:\n                more_authors.append(another_author)\n            else:\n                break\n        committer = self._get_user_info(b'commit', b'committer')\n        message = self._get_data(b'commit', b'message')\n        from_ = self._get_from()\n        merges = []\n        while True:\n            merge = self._get_merge()\n            if merge is not None:\n                # while the spec suggests it's illegal, git-fast-export\n                # outputs multiple merges on the one line, e.g.\n                # merge :x :y :z\n                these_merges = merge.split(b' ')\n                merges.extend(these_merges)\n            else:\n                break\n        properties = {}\n        while True:\n            name_value = self._get_property()\n            if name_value is not None:\n                name, value = name_value\n                properties[name] = value\n            else:\n                break\n        return commands.CommitCommand(ref, mark, author, committer, message,\n            from_, merges, list(self.iter_file_commands()), lineno=lineno,\n            more_authors=more_authors, properties=properties)", "response": "Parse a commit command."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a feature command.", "response": "def _parse_feature(self, info):\n        \"\"\"Parse a feature command.\"\"\"\n        parts = info.split(b'=', 1)\n        name = parts[0]\n        if len(parts) > 1:\n            value = self._path(parts[1])\n        else:\n            value = None\n        self.features[name] = value\n        return commands.FeatureCommand(name, value, lineno=self.lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_file_modify(self, info):\n        params = info.split(b' ', 2)\n        path = self._path(params[2])\n        mode = self._mode(params[0])\n        if params[1] == b'inline':\n            dataref = None\n            data = self._get_data(b'filemodify')\n        else:\n            dataref = params[1]\n            data = None\n        return commands.FileModifyCommand(path, mode, dataref,\n            data)", "response": "Parse a filemodify command within a commit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_reset(self, ref):\n        from_ = self._get_from()\n        return commands.ResetCommand(ref, from_)", "response": "Parse a reset command."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a tag command.", "response": "def _parse_tag(self, name):\n        \"\"\"Parse a tag command.\"\"\"\n        from_ = self._get_from(b'tag')\n        tagger = self._get_user_info(b'tag', b'tagger',\n                accept_just_who=True)\n        message = self._get_data(b'tag', b'message')\n        return commands.TagCommand(name, from_, tagger, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a mark section.", "response": "def _get_mark_if_any(self):\n        \"\"\"Parse a mark section.\"\"\"\n        line = self.next_line()\n        if line.startswith(b'mark :'):\n            return line[len(b'mark :'):]\n        else:\n            self.push_line(line)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a from section.", "response": "def _get_from(self, required_for=None):\n        \"\"\"Parse a from section.\"\"\"\n        line = self.next_line()\n        if line is None:\n            return None\n        elif line.startswith(b'from '):\n            return line[len(b'from '):]\n        elif required_for:\n            self.abort(errors.MissingSection, required_for, 'from')\n        else:\n            self.push_line(line)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a merge section.", "response": "def _get_merge(self):\n        \"\"\"Parse a merge section.\"\"\"\n        line = self.next_line()\n        if line is None:\n            return None\n        elif line.startswith(b'merge '):\n            return line[len(b'merge '):]\n        else:\n            self.push_line(line)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_property(self):\n        line = self.next_line()\n        if line is None:\n            return None\n        elif line.startswith(b'property '):\n            return self._name_value(line[len(b'property '):])\n        else:\n            self.push_line(line)\n            return None", "response": "Parse a property section."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a user section.", "response": "def _get_user_info(self, cmd, section, required=True,\n        accept_just_who=False):\n        \"\"\"Parse a user section.\"\"\"\n        line = self.next_line()\n        if line.startswith(section + b' '):\n            return self._who_when(line[len(section + b' '):], cmd, section,\n                accept_just_who=accept_just_who)\n        elif required:\n            self.abort(errors.MissingSection, cmd, section)\n        else:\n            self.push_line(line)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_data(self, required_for, section=b'data'):\n        line = self.next_line()\n        if line.startswith(b'data '):\n            rest = line[len(b'data '):]\n            if rest.startswith(b'<<'):\n                return self.read_until(rest[2:])\n            else:\n                size = int(rest)\n                read_bytes = self.read_bytes(size)\n                # optional LF after data.\n                next_line = self.input.readline()\n                self.lineno += 1\n                if len(next_line) > 1 or next_line != b'\\n':\n                    self.push_line(next_line[:-1])\n                return read_bytes\n        else:\n            self.abort(errors.MissingSection, required_for, section)", "response": "Parse a data section."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _who_when(self, s, cmd, section, accept_just_who=False):\n        match = _WHO_AND_WHEN_RE.search(s)\n        if match:\n            datestr = match.group(3).lstrip()\n            if self.date_parser is None:\n                # auto-detect the date format\n                if len(datestr.split(b' ')) == 2:\n                    date_format = 'raw'\n                elif datestr == b'now':\n                    date_format = 'now'\n                else:\n                    date_format = 'rfc2822'\n                self.date_parser = dates.DATE_PARSERS_BY_NAME[date_format]\n            try:\n                when = self.date_parser(datestr, self.lineno)\n            except ValueError:\n                print(\"failed to parse datestr '%s'\" % (datestr,))\n                raise\n            name = match.group(1).rstrip()\n            email = match.group(2)\n        else:\n            match = _WHO_RE.search(s)\n            if accept_just_who and match:\n                # HACK around missing time\n                # TODO: output a warning here\n                when = dates.DATE_PARSERS_BY_NAME['now']('now')\n                name = match.group(1)\n                email = match.group(2)\n            elif self.strict:\n                self.abort(errors.BadFormat, cmd, section, s)\n            else:\n                name = s\n                email = None\n                when = dates.DATE_PARSERS_BY_NAME['now']('now')\n        if len(name) > 0:\n            if name.endswith(b' '):\n                name = name[:-1]\n        # While it shouldn't happen, some datasets have email addresses\n        # which contain unicode characters. See bug 338186. We sanitize\n        # the data at this level just in case.\n        if self.user_mapper:\n            name, email = self.user_mapper.map_name_and_email(name, email)\n\n        return Authorship(name, email, when[0], when[1])", "response": "Parse who and when information from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a ( name value ) tuple from name value - length value", "response": "def _name_value(self, s):\n        \"\"\"Parse a (name,value) tuple from 'name value-length value'.\"\"\"\n        parts = s.split(b' ', 2)\n        name = parts[0]\n        if len(parts) == 1:\n            value = None\n        else:\n            size = int(parts[1])\n            value = parts[2]\n            still_to_read = size - len(value)\n            if still_to_read > 0:\n                read_bytes = self.read_bytes(still_to_read)\n                value += b'\\n' + read_bytes[:still_to_read - 1]\n        return (name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse two paths separated by a space.", "response": "def _path_pair(self, s):\n        \"\"\"Parse two paths separated by a space.\"\"\"\n        # TODO: handle a space in the first path\n        if s.startswith(b'\"'):\n            parts = s[1:].split(b'\" ', 1)\n        else:\n            parts = s.split(b' ', 1)\n        if len(parts) != 2:\n            self.abort(errors.BadFormat, '?', '?', s)\n        elif parts[1].startswith(b'\"') and parts[1].endswith(b'\"'):\n            parts[1] = parts[1][1:-1]\n        elif parts[1].startswith(b'\"') or parts[1].endswith(b'\"'):\n            self.abort(errors.BadFormat, '?', '?', s)\n        return [_unquote_c_string(s) for s in parts]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _mode(self, s):\n        # Note: Output from git-fast-export slightly different to spec\n        if s in [b'644', b'100644', b'0100644']:\n            return 0o100644\n        elif s in [b'755', b'100755', b'0100755']:\n            return 0o100755\n        elif s in [b'040000', b'0040000']:\n            return 0o40000\n        elif s in [b'120000', b'0120000']:\n            return 0o120000\n        elif s in [b'160000', b'0160000']:\n            return 0o160000\n        else:\n            self.abort(errors.BadFormat, 'filemodify', 'mode', s)", "response": "Check file mode format and parse into an integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef common_directory(paths):\n    import posixpath\n    def get_dir_with_slash(path):\n        if path == b'' or path.endswith(b'/'):\n            return path\n        else:\n            dirname, basename = posixpath.split(path)\n            if dirname == b'':\n                return dirname\n            else:\n                return dirname + b'/'\n\n    if not paths:\n        return None\n    elif len(paths) == 1:\n        return get_dir_with_slash(paths[0])\n    else:\n        common = common_path(paths[0], paths[1])\n        for path in paths[2:]:\n            common = common_path(common, path)\n        return get_dir_with_slash(common)", "response": "Find the deepest common directory of a list of paths."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if fname is inside directory.", "response": "def is_inside(directory, fname):\n    \"\"\"True if fname is inside directory.\n\n    The parameters should typically be passed to osutils.normpath first, so\n    that . and .. and repeated slashes are eliminated, and the separators\n    are canonical for the platform.\n\n    The empty string as a dir name is taken as top-of-tree and matches\n    everything.\n    \"\"\"\n    # XXX: Most callers of this can actually do something smarter by\n    # looking at the inventory\n    if directory == fname:\n        return True\n\n    if directory == b'':\n        return True\n\n    if not directory.endswith(b'/'):\n        directory += b'/'\n\n    return fname.startswith(directory)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntruing if fname is inside any of given dirs.", "response": "def is_inside_any(dir_list, fname):\n    \"\"\"True if fname is inside any of given dirs.\"\"\"\n    for dirname in dir_list:\n        if is_inside(dirname, fname):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string to a bytes string ( if necessary encode in utf8", "response": "def utf8_bytes_string(s):\n    \"\"\"Convert a string to a bytes string (if necessary, encode in utf8)\"\"\"\n    if sys.version_info[0] == 2:\n        if isinstance(s, str):\n            return s\n        else:\n            return s.encode('utf8')\n    else:\n        if isinstance(s, str):\n            return bytes(s, encoding='utf8')\n        else:\n            return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef binary_stream(stream):\n    try:\n        import os\n        if os.name == 'nt':\n            fileno = getattr(stream, 'fileno', None)\n            if fileno:\n                no = fileno()\n                if no >= 0:     # -1 means we're working as subprocess\n                    import msvcrt\n                    msvcrt.setmode(no, os.O_BINARY)\n    except ImportError:\n        pass\n    return stream", "response": "Ensure a stream is binary on Windows."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef invert_dictset(d):\n    # Based on recipe from ASPN\n    result = {}\n    for k, c in d.items():\n        for v in c:\n            keys = result.setdefault(v, [])\n            keys.append(k)\n    return result", "response": "Invert a dictionary with keys matching a set of values turned into lists."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef invert_dict(d):\n    # Based on recipe from ASPN\n    result = {}\n    for k, v in d.items():\n        keys = result.setdefault(v, [])\n        keys.append(k)\n    return result", "response": "Invert a dictionary with keys matching each value turned into a list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef defines_to_dict(defines):\n    if defines is None:\n        return None\n    result = {}\n    for define in defines:\n        kv = define.split('=', 1)\n        if len(kv) == 1:\n            result[define.strip()] = 1\n        else:\n            result[kv[0].strip()] = kv[1].strip()\n    return result", "response": "Convert a list of definition strings to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the instance with the given instance names.", "response": "def start(self, instance_names):\n        \"\"\" If start is called from the root of a Galaxy source directory with\n        no args, automatically add this instance.\n        \"\"\"\n        if not instance_names:\n            configs = (os.path.join('config', 'galaxy.ini'),\n                    os.path.join('config', 'galaxy.ini.sample'))\n            for config in configs:\n                if os.path.exists(config):\n                    if not self.config_manager.is_registered(os.path.abspath(config)):\n                        self.config_manager.add([config])\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crypt(self, data, crypt_type):\n\n        # Error check the data\n        if not data:\n            return ''\n        if len(data) % self.block_size != 0:\n            if crypt_type == des.DECRYPT: # Decryption must work on 8 byte blocks\n                raise ValueError(\"Invalid data length, data must be a multiple of \" + str(self.block_size) + \" bytes\\n\" + data + \".\")\n            if not self.getPadding():\n                raise ValueError(\"Invalid data length, data must be a multiple of \" + str(self.block_size) + \" bytes\\n. Try setting the optional padding character\")\n            else:\n                data += (self.block_size - (len(data) % self.block_size)) * self.getPadding()\n            # print \"Len of data: %f\" % (len(data) / self.block_size)\n\n        if self.getMode() == CBC:\n            if self.getIV():\n                iv = self.__String_to_BitList(self.getIV())\n            else:\n                raise ValueError(\"For CBC mode, you must supply the Initial Value (IV) for ciphering\")\n\n        # Split the data into blocks, crypting each one seperately\n        i = 0\n        result = []\n        while i < len(data):\n            block = self.__String_to_BitList(data[i:i+8])\n\n            # Xor with IV if using CBC mode\n            if self.getMode() == CBC:\n                if crypt_type == des.ENCRYPT:\n                    block = list(map(lambda x, y: x ^ y, block, iv))\n\n                processed_block = self.__des_crypt(block, crypt_type)\n\n                if crypt_type == des.DECRYPT:\n                    processed_block = list(map(lambda x, y: x ^ y, processed_block, iv))\n                    iv = block\n                else:\n                    iv = processed_block\n            else:\n                processed_block = self.__des_crypt(block, crypt_type)\n\n\n            # Add the resulting crypted block to our list\n            result.append(self.__BitList_to_String(processed_block))\n            i += 8\n\n        # Return the full crypted string\n        if _pythonMajorVersion < 3:\n            return ''.join(result)\n        else:\n            return bytes.fromhex('').join(result)", "response": "Crypt the data in blocks running it through des_crypt"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setQuery(self, query):\n        self.queryType = self._parseQueryType(query)\n        self.queryString = self.injectPrefixes(query)\n        self.addParameter('email', self.email)\n        self.addParameter('password', self.password)", "response": "Set the SPARQL query text and set the VIVO customizable query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef post_process(self, settings):\n        for k in settings:\n            # Search for post process rules for setting in manifest\n            if k in self.settings_manifesto and \\\n               self.settings_manifesto[k].get('postprocess', None) is not None:\n                rules = self.settings_manifesto[k]['postprocess']\n\n                # Chain post process rules from each setting\n                for method_name in rules:\n                    settings[k] = getattr(self, method_name)(\n                        settings,\n                        k,\n                        settings[k]\n                    )\n\n        return settings", "response": "Perform post processing methods on the given settings according to their\nMimeType definition in manifest."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npatches a path to expand home directory and make absolute path.", "response": "def _patch_expand_path(self, settings, name, value):\n        \"\"\"\n        Patch a path to expand home directory and make absolute path.\n\n        Args:\n            settings (dict): Current settings.\n            name (str): Setting name.\n            value (str): Path to patch.\n\n        Returns:\n            str: Patched path to an absolute path.\n\n        \"\"\"\n        if os.path.isabs(value):\n            return os.path.normpath(value)\n\n        # Expand home directory if any\n        value = os.path.expanduser(value)\n\n        # If the path is not yet an absolute directory, make it so from base\n        # directory if not empty\n        if not os.path.isabs(value) and self.projectdir:\n            value = os.path.join(self.projectdir, value)\n\n        return os.path.normpath(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying _patch_expand_path to each element in value.", "response": "def _patch_expand_paths(self, settings, name, value):\n        \"\"\"\n        Apply ``SettingsPostProcessor._patch_expand_path`` to each element in\n        list.\n\n        Args:\n            settings (dict): Current settings.\n            name (str): Setting name.\n            value (list): List of paths to patch.\n\n        Returns:\n            list: Patched path list to an absolute path.\n\n        \"\"\"\n        return [self._patch_expand_path(settings, name, item)\n                for item in value]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate path exists in the current object", "response": "def _validate_path(self, settings, name, value):\n        \"\"\"\n        Validate path exists\n\n        Args:\n            settings (dict): Current settings.\n            name (str): Setting name.\n            value (str): Path to validate.\n\n        Raises:\n            boussole.exceptions.SettingsInvalidError: If path does not exists.\n\n        Returns:\n            str: Validated path.\n\n        \"\"\"\n        if not os.path.exists(value):\n            raise SettingsInvalidError(\"Path from setting '{name}' does not \"\n                                       \"exists: {value}\".format(\n                                           name=name,\n                                           value=value\n                                       ))\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_paths(self, settings, name, value):\n        return [self._validate_path(settings, name, item)\n                for item in value]", "response": "Apply _validate_path to each element in value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate a required setting.", "response": "def _validate_required(self, settings, name, value):\n        \"\"\"\n        Validate a required setting (value can not be empty)\n\n        Args:\n            settings (dict): Current settings.\n            name (str): Setting name.\n            value (str): Required value to validate.\n\n        Raises:\n            boussole.exceptions.SettingsInvalidError: If value is empty.\n\n        Returns:\n            str: Validated value.\n\n        \"\"\"\n        if not value:\n            raise SettingsInvalidError((\"Required value from setting '{name}' \"\n                                        \"must not be \"\n                                        \"empty.\").format(name=name))\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(template, **kwargs):\r\n    import jinja2\r\n    import os.path as path\r\n\r\n    searchpath = path.join(path.dirname(__file__), \r\n        \"templates\") \r\n    loader = jinja2.FileSystemLoader(searchpath=searchpath)\r\n    env = jinja2.Environment(loader=loader)\r\n    temp = env.get_template(template)\r\n\r\n    return temp.render(**kwargs)", "response": "Renders the given template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summarize(urls):\r\n    import time\r\n    from summary import Summary\r\n\r\n\r\n    fails = 0\r\n    err = lambda e: e.__class__.__name__\r\n\r\n    summaries = []\r\n    start = time.time()\r\n    for url in urls:\r\n        try:\r\n            print \"-> %s\" % url\r\n            summary = Summary(url)\r\n            summary.extract()\r\n        except KeyboardInterrupt:\r\n            break\r\n        except Exception, e:\r\n            fails += 1\r\n            summary = {\r\n                'titles': [\"[%s]\" % err(e)],\r\n                'urls': [url],\r\n                'descriptions': [str(e)],\r\n                'source': url,\r\n                }\r\n            print \"[%s] (%s): %s\" % (err(e), e, url)\r\n        summaries.append(summary)\r\n        end = time.time()\r\n\r\n    result = fails and \"Fails: %s out of %s.\" % (fails, len(summaries)) \\\r\n        or \"Success: %s.\" % len(summaries)\r\n    print result\r\n\r\n    duration = end - start\r\n    speed = \"%.2f\" % (duration/len(summaries))\r\n\r\n    return summaries, result, speed", "response": "Calls extract for each of the URLs and prints the summary of each of the instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef initMazeFromJSON(jsonString, cellClass=Cell, gridClass=Grid):\n    '''Init a maze from JSON string.'''\n    \n    jsonObj = json.loads(jsonString)\n    rows=jsonObj[\"rows\"]\n    columns=jsonObj[\"columns\"]\n    grid=gridClass(rows,columns,cellClass)\n    grid.algorithm=jsonObj[\"algorithm\"]\n    grid.algorithm_key=jsonObj[\"algorithm_key\"]\n    grid.braid=jsonObj[\"braid\"]\n\n    #init cells\n    #for each cell link those that are neigbors\n    for _cell in jsonObj[\"cells\"]:\n        cell=json.loads(_cell)\n        gridCell=grid.getCell(cell[\"row\"],cell[\"column\"])\n        if \"content\" in cell:\n            gridCell.content=cell[\"content\"]\n        else:\n            gridCell.setContent(\" \")\n        \n        if cell[\"north\"]:\n            gridCell.link(gridCell.north)\n        if cell[\"east\"]:\n            gridCell.link(gridCell.east)\n        if cell[\"south\"]:\n            gridCell.link(gridCell.south)\n        if cell[\"west\"]:\n            gridCell.link(gridCell.west)\n\n    return grid", "response": "Init a maze from a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_json_file(fpath):\n    if not os.path.exists(fpath):\n        raise Exception('ERROR: file %s does not exist.' % fpath)\n    with open(fpath, 'r') as fh:\n        raw = fh.read()\n    res = json.loads(raw)\n    return res", "response": "Read a JSON file from fpath ; raise an exception if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_cmd(args, stream=False, shell=True):\n    s = ''\n    if stream:\n        s = ' and streaming output'\n    logger.info('Running command%s: %s', s, args)\n    outbuf = ''\n    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                         shell=shell)\n    logger.debug('Started process; pid=%s', p.pid)\n    for c in iter(lambda: p.stdout.read(1), ''):\n        outbuf += c\n        if stream:\n            sys.stdout.write(c)\n    p.poll()  # set returncode\n    logger.info('Command exited with code %d', p.returncode)\n    logger.debug(\"Command output:\\n%s\", outbuf)\n    return outbuf, p.returncode", "response": "Execute a command via subprocess. Popen and return its output and exit code."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load(self, titles=[], descriptions=[], images=[], urls=[], **kwargs):\n        enough = lambda items: items # len(items) >= MAX_ITEMS\n\n        if config.GET_ALL_DATA or not enough(self.titles):\n            titles = filter(None, map(self._clean_text, titles))\n            self.titles.extend(titles)\n\n        if config.GET_ALL_DATA or not enough(self.descriptions):\n            descriptions = filter(None, map(self._clean_text, descriptions))\n            self.descriptions.extend(descriptions)\n\n        ## Never mind the urls, they can be bad not worth it\n        # if config.GET_ALL_DATA or not enough(self.urls):\n            # # urls = [self._clean_url(u) for u in urls]\n            # urls = filter(None, map(self._clean_url, urls))\n            # self.urls.extend(urls)\n\n        if config.GET_ALL_DATA:\n            # images = [i for i in [self._filter_image(i) for i in images] if i]\n            images = filter(None, map(self._filter_image, images))\n            self.images.extend(images)\n        elif not enough(self.images):\n            for i in images:\n                image = self._filter_image(i)\n                if image:\n                    self.images.append(image)\n                if enough(self.images):\n                    break", "response": "Loads extracted data into Summary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _clean_url(self, url):\n        # TODO: Turn this into regex\n        if not url.startswith('http') or url.endswith('}}') or 'nojs_router' in url:\n            return None\n        if site(norm(url).lower()) in config.NONCANONIC_SITES:\n            clean_url = canonicalize_url(url, keep_params=True)\n        else:\n            clean_url = canonicalize_url(url)\n        return clean_url", "response": "Canonicalizes the url and keeps only USEFUL_QUERY_KEYS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_tag(self, response, tag_name=\"html\", encoding=\"utf-8\"):\n        def find_tag(tag_name):\n            tag_start = tag_end = None\n            found = lambda: \\\n                tag_start is not None and tag_end is not None\n            html = self._html.lower()\n            start = html.find(\"<%s\" % tag_name)\n            if start >= 0:\n                tag_start = start\n            else:\n                return None # no tag\n            end = html.find(\"</%s>\" % tag_name)\n            if end > tag_start:\n                tag_end = end+len(tag_name)+3\n            elif consumed:\n                tag_end = -1 # till the end\n            if found():\n                return self._html[tag_start:tag_end]\n            return None\n        consumed = getattr(response, 'consumed', False)\n        if not consumed:\n            stream = getattr(response, 'stream', None)\n            if stream is None:\n                stream = response.iter_content(config.CHUNK_SIZE) # , decode_unicode=True\n                response.stream = stream\n            while True:\n                try:\n                    chunk = next(stream)\n                    self._html += chunk\n                    tag = find_tag(tag_name)\n                    if tag:\n                        return tag\n                    if len(self._html) > config.HTML_MAX_BYTESIZE:\n                        raise HTMLParseError('Maximum response size reached.')\n                except StopIteration:\n                    response.consumed = True\n        tag = find_tag(tag_name)\n        return decode(tag, encoding)", "response": "Returns the tag from the response content."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts data from the HTML file.", "response": "def extract(self, check_url=None, http_equiv_refresh=True):\n        \"\"\"\n        Downloads HTML <head> tag first, extracts data from it using\n        specific head techniques, loads it and checks if is complete. \n        Otherwise downloads the HTML <body> tag as well and loads data \n        extracted by using appropriate semantic techniques.\n\n        Eagerly calls check_url(url) if any, before parsing the HTML.\n        Provided function should raise an exception to break extraction.\n        E.g.: URL has been summarized before; URL points to off limits\n        websites like foursquare.com, facebook.com, bitly.com and so on.\n        \"\"\"\n        # assert self._is_clear()\n        logger = logging.getLogger(__name__)\n        logger.info(\"Extract: %s\", self.clean_url)\n        with closing(request.get(self.clean_url, stream=True)) as response:\n            response.raise_for_status()\n            mime = response.headers.get('content-type')\n            if mime and not ('html' in mime.lower()):\n                raise HTMLParseError('Invalid Content-Type: %s' % mime)\n            self.clean_url = self._clean_url(response.url)\n            if self.clean_url is None:\n                raise URLError('Bad url: %s' % response.url)\n            if check_url is not None:\n                check_url(url=self.clean_url)\n\n            encoding = config.ENCODING or response.encoding\n\n            self._html = \"\"\n            if config.PHANTOMJS_BIN and \\\n                site(self.clean_url) in config.PHANTOMJS_SITES:\n                self._html = request.phantomjs_get(self.clean_url)\n                response.consumed = True\n\n            head = self._get_tag(response, tag_name=\"head\", encoding=encoding)\n\n            if http_equiv_refresh:\n                # Check meta http-equiv refresh tag\n                html = head or decode(self._html, encoding)\n                self._extract(html, self.clean_url, [\n                    \"summary.techniques.HTTPEquivRefreshTags\",\n                ])\n                new_url = self.urls and self.urls[0]\n                if new_url and new_url != self.clean_url:\n                    logger.warning(\"Refresh: %s\", new_url)\n                    self._clear()\n                    self.clean_url = new_url\n                    return self.extract(check_url=check_url, http_equiv_refresh=False)\n\n            if head:\n                logger.debug(\"Got head: %s\", len(head))\n                self._extract(head, self.clean_url, [\n                    \"extraction.techniques.FacebookOpengraphTags\",\n                    \"extraction.techniques.TwitterSummaryCardTags\",\n                    \"extraction.techniques.HeadTags\"\n                ])\n            else:\n                logger.debug(\"No head: %s\", self.clean_url)\n\n            if config.GET_ALL_DATA or not self._is_complete():\n                body = self._get_tag(response, tag_name=\"body\", encoding=encoding)\n                if body:\n                    logger.debug(\"Got body: %s\", len(body))\n                    self._extract(body, self.clean_url, [\n                        \"extraction.techniques.HTML5SemanticTags\",\n                        \"extraction.techniques.SemanticTags\"                \n                    ])\n                else:\n                    logger.debug(\"No body: %s\", self.clean_url)\n\n            if not head and not body:\n                raise HTMLParseError('No head nor body tags found.')\n\n            del self._html"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list containing first n digits of Pi", "response": "def getPiGosper(n):\n    \"\"\"Returns a list containing first n digits of Pi\n    \"\"\"\n    mypi = piGenGosper()\n    result = []\n    if n > 0:\n        result += [next(mypi) for i in range(n)]\n    mypi.close()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef of_think(self, think):\n        return self._compute(\n            duration=think.duration,\n            after=self.continuation)", "response": "Simulate the worker processing the task for the specified amount of time."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def freeze(self, *args, **kwargs):\n\n\t\t# Get data from request\n\t\tuid = kwargs.get(\"uid\", 0)\n\t\tcoinid = kwargs.get(\"coinid\")\n\t\tamount = kwargs.get(\"amount\")\n\t\taddress = kwargs.get(\"address\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\ttry:\n\t\t\tuid = int(uid)\n\t\texcept:\n\t\t\treturn await self.error_400(\"User id must be integer. \")\n\n\t\ttry:\n\t\t\tamount = int(amount)\n\t\texcept:\n\t\t\treturn await self.error_400(\"Amount must be integer. \")\n\n\t\ttry:\n\t\t\tassert amount > 0\n\t\texcept:\n\t\t\treturn await self.error_400(\"Amount must be positive integer. \")\n\n\n\t\t# Check if required fields exists\n\t\tif not uid and address:\n\t\t\tuid = await self.get_uid_by_address(address=address, coinid=coinid)\n\t\t\tif isinstance(uid, dict):\n\t\t\t\treturn uid\n\n\t\t# Connect to appropriate database\n\t\tdatabase = self.client[self.collection]\n\t\tcollection = database[coinid]\n\n\t\t# Check if balance exists\n\t\tbalance = await collection.find_one({\"uid\":uid})\n\t\tif not balance:\n\t\t\treturn await self.error_404(\n\t\t\t\t\"Freeze. Balance with uid:%s and type:%s not found.\" % (uid, coinid))\n\n\t\t# Check if amount is enough\n\t\tdifference = int(balance[\"amount_active\"]) - int(amount)\n\t\tif difference < 0:\n\t\t\treturn await self.error_403(\"Freeze. Insufficient amount in the account\")\n\t\t# Decrement active amount and increment frozen amount\n\t\tamount_frozen = int(balance[\"amount_frozen\"]) + int(amount) \n\t\tawait collection.find_one_and_update({\"uid\":uid},\n\t\t\t\t\t\t{\"$set\":{\"amount_active\":str(difference), \n\t\t\t\t\t\t\t\t\t\"amount_frozen\":str(amount_frozen)}})\n\t\t\n\t\t# Return updated balance with excluded mongo _id field\n\t\tresult = await collection.find_one({\"uid\":uid})\n\t\tresult[\"amount_frozen\"] = int(result[\"amount_frozen\"])\n\t\tresult[\"amount_active\"] = int(result[\"amount_active\"])\n\t\tdel result[\"_id\"]\n\n\t\treturn result", "response": "Freeze users balance\n\n\t\tAccepts:\n\t\t\t- uid [integer] (users id from main server)\n\t\t\t- coinid [string] (blockchain type in uppercase)\n\t\t\t- amount [integer] (amount for freezing)\n\n\t\tReturns:\n\t\t\t- uid [integer] (users id from main server)\n\t\t\t- coinid [string] (blockchain type in uppercase)\n\t\t\t- amount_active [integer] (activae users amount)\n\t\t\t- amount_frozen [integer] (frozen users amount)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_active(self, *args, **kwargs):\n\n\t\t# Get daya from request\n\t\tcoinids = kwargs.get(\"coinids\")\n\t\tuid = kwargs.get(\"uid\",0)\n\t\taddress = kwargs.get(\"address\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\ttry:\n\t\t\tuid = int(uid)\n\t\texcept:\n\t\t\treturn await self.error_400(\"User id must be integer. \")\n\n\t\tif not uid and address:\n\t\t\tuid = await self.get_uid_by_address(address=address, coinid=coinid)\n\t\t\tif isinstance(uid, dict):\n\t\t\t\treturn uid\n\n\t\t# Check if required fields exists\n\t\tif not all([coinids, uid]):\n\t\t\treturn await self.error_400(\"Get active. Missed required fields.\")\n\t\tif isinstance(coinids, list):\n\t\t\tactives = {}\n\t\t\tfor coinid in coinids:\n\t\t\t\tdatabase = self.client[self.collection]\n\t\t\t\tcollection = database[coinid]\n\t\t\t\t# Get current balance\n\t\t\t\tbalance = await collection.find_one({\"uid\":uid})\n\t\t\t\tif not balance:\n\t\t\t\t\treturn await self.error_404(\n\t\t\t\t\t\t\"Get active. Balance with uid:%s and type:%s not found\" % (uid, coinid))\n\t\t\t\t# Collect actives\n\t\t\t\tactives[coinid] = int(balance[\"amount_active\"])\n\n\t\tif isinstance(coinids, str):\n\t\t\tactives = {}\n\t\t\tfor coinid in self.coinids:\n\t\t\t\tdatabase = self.client[coinid]\n\t\t\t\tcollection = database[self.collection]\n\t\t\t\t# Get current balance\n\t\t\t\tbalance = await collection.find_one({\"uid\":uid})\n\t\t\t\tif not balance:\n\t\t\t\t\treturn await self.error_404(\n\t\t\t\t\t\t\"Get active. Balance with uid:%s and type:%s not found\" % (uid, coinid))\n\t\t\t\t# Collect actives\n\t\t\t\tactives[coinid] = int(balance[\"amount_active\"])\n\t\treturn actives", "response": "Get active users balance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting frozen users balance", "response": "async def get_frozen(self, *args, **kwargs):\n\t\t\"\"\"\n\t\tGet frozen users balance\n\n\t\tAccepts:\n\t\t\t- uid [integer] (users id)\n\t\t\t- types [list | string] (array with needed types or \"all\")\n\n\t\tReturns:\n\t\t\t{\n\t\t\t\ttype [string] (blockchain type): amount\n\t\t\t}\n\t\t\"\"\"\n\t\tsuper().validate(*args, **kwargs)\n\n\t\tif kwargs.get(\"message\"):\n\t\t\tkwargs = json.loads(kwargs.get(\"message\"))\n\n\t\t# Get daya from request\n\t\tcoinids = kwargs.get(\"coinids\")\n\t\tuid = kwargs.get(\"uid\")\n\t\taddress = kwargs.get(\"address\")\n\t\t# Check if required fields exists\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\ttry:\n\t\t\tuid = int(uid)\n\t\texcept:\n\t\t\treturn await self.error_400(\"User id must be integer. \")\n\n\t\tif not uid and address:\n\t\t\tuid = await self.get_uid_by_address(address=address, coinid=coinid)\n\t\t\tif isinstance(uid, dict):\n\t\t\t\treturn uid\n\n\t\tif not all([types, uid]):\n\t\t\treturn await self.error_400(\"Get frozen. Missed required fields.\")\n\t\tif isinstance(types, list):\n\t\t\tactives = {}\n\t\t\tfor coinid in coinids:\n\t\t\t\tdatabase = self.client[self.collection]\n\t\t\t\tcollection = database[coinid]\n\t\t\t\t# Get current balance\n\t\t\t\tbalance = await collection.find_one({\"uid\":uid})\n\t\t\t\tif not balance:\n\t\t\t\t\treturn await self.error_404(\n\t\t\t\t\t\t\"Get frozen. Balance with uid:%s and type:%s not found\" % (uid, coinid))\n\t\t\t\t# Collect actives\n\t\t\t\tactives[coinid] = int(balance[\"amount_frozen\"])\n\n\t\tif isinstance(coinids, str):\n\t\t\tactives = {}\n\t\t\tfor coinid in self.types:\n\t\t\t\tdatabase = self.client[coinid]\n\t\t\t\tcollection = database[self.collection]\n\t\t\t\t# Get current balance\n\t\t\t\tbalance = await collection.find_one({\"uid\":uid})\n\t\t\t\tif not balance:\n\t\t\t\t\treturn await self.error_404(\n\t\t\t\t\t\t\"Get frozen. Balance with uid:%s and type:%s not found\" % (uid, coinid))\n\t\t\t\t# Collect actives\n\t\t\t\tactives[coinid] = int(balance[\"amount_frozen\"])\n\t\treturn actives"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncollects wallets by uid", "response": "async def collect_wallets(self, uid):\n\t\t\"\"\"\n\t\tAsynchronous generator\n\t\t\"\"\"\n\t\tlogging.debug(self.types)\n\t\tlogging.debug(uid)\n\t\tfor coinid in self.types:\n\t\t\tlogging.debug(coinid)\n\t\t\tawait asyncio.sleep(0.5)\n\t\t\t# Connect to appropriate database\n\t\t\tdatabase = self.client[self.collection]\n\t\t\tlogging.debug(database)\n\t\t\tcollection = database[coinid]\n\t\t\tlogging.debug(collection)\n\t\t\t# Get wallets\n\t\t\twallet = await collection.find_one({\"uid\":int(uid)})\n\t\t\tlogging.debug(wallet)\n\n\t\t\twallet[\"amount_active\"] = int(wallet[\"amount_active\"])\n\t\t\twallet[\"amount_frozen\"] = int(wallet[\"amount_frozen\"])\n\t\t\tdel wallet[\"_id\"]\n\t\t\tyield wallet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting users wallets by uid", "response": "async def get_wallets(self, *args, **kwargs):\n\t\t\"\"\"\n\t\tGet users wallets by uid\n\n\t\tAccepts:\n\t\t\t- uid [integer] (users id)\n\n\t\tReturns a list:\n\t\t\t- [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"address\": [string],\n\t\t\t\t\t\t\"uid\": [integer],\n\t\t\t\t\t\t\"amount_active\": [integer],\n\t\t\t\t\t\t\"amount_frozen\": [integer]\n\t\t\t\t\t},\n\t\t\t\t]\n\t\t\"\"\"\n\t\tlogging.debug(\"\\n [+] -- Get wallets debugging.\")\n\t\tif kwargs.get(\"message\"):\n\t\t\tkwargs = json.loads(kwargs.get(\"message\"))\n\t\tlogging.debug(kwargs)\n\t\tuid = kwargs.get(\"uid\",0)\n\t\taddress = kwargs.get(\"address\")\n\t\tcoinid = kwargs.get(\"coinid\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\ttry:\n\t\t\tuid = int(uid)\n\t\texcept:\n\t\t\treturn await self.error_400(\"User id must be integer. \")\n\n\t\tif not uid and address:\n\t\t\tuid = await self.get_uid_by_address(address=address, coinid=coinid)\n\t\t\tif isinstance(uid, dict):\n\t\t\t\treturn uid\n\n\t\twallets = [i async for i in self.collect_wallets(uid)]\n\n\t\treturn {\"wallets\":wallets}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def confirmbalance(self, *args, **kwargs):\n\t\t# Get data from request\n\t\tif kwargs.get(\"message\"):\n\t\t\tkwargs = json.loads(kwargs.get(\"message\", \"{}\"))\n\n\t\ttxid = kwargs.get(\"txid\")\n\t\tcoinid = kwargs.get(\"coinid\")\n\t\tbuyer_address = kwargs.get(\"buyer_address\")\n\t\tcid = kwargs.get(\"cid\")\n\t\taddress = kwargs.get(\"buyer_address\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\t# Check if required fields exists\n\t\tif not all([coinid, cid, buyer_address, txid]):\n\t\t    return {\"error\":400, \"reason\": \"Confirm balance. Missed required fields\"}\n\n\t\tif not coinid in settings.bridges.keys():\n\t\t\treturn await self.error_400(\"Confirm balance. Invalid coinid: %s\" % coinid)\n\n\t\t# Get offers price\t\n\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\toffer = await self.account.blockchain.getoffer(cid=cid, \n\t\t\t\t\t\t\t\t\t\t\tbuyer_address=buyer_address)\n\t\t# Get offers price for updating balance\n\t\tamount = int(offer[\"price\"])\n\n\t\tcoinid = \"PUT\"\n\t\t# Get sellers account\n\t\thistory_database = self.client[settings.HISTORY]\n\t\thistory_collection = history_database[coinid]\n\t\thistory = await history_collection.find_one({\"txid\":txid})\n\n\t\ttry:\n\t\t\taccount = await self.account.getaccountdata(public_key=history[\"public_key\"])\n\t\texcept:\n\t\t\treturn await self.error_404(\"Confirm balance. Not found current deal.\")\n\n\t\t# Connect to balance database\n\t\tdatabase = self.client[self.collection]\n\t\tbalance_collection = database[coinid]\n\n\t\t# Try to update balance if exists\n\t\tbalance = await balance_collection.find_one({\"uid\":account[\"id\"]})\n\t\t# Decrement unconfirmed\n\t\tsubmitted = int(balance[\"amount_frozen\"]) - int(amount)\n\t\tif submitted < 0:\n\t\t\treturn await self.error_400(\"Not enough frozen amount.\")\n\n\t\tdecremented = await balance_collection.find_one_and_update(\n\t\t                        {\"uid\":account[\"id\"]}, \n\t\t                        {\"$set\":{\"amount_frozen\": str(submitted)}})\n\n\t\tdifference = int(balance[\"amount_active\"]) + int(amount)\n\t\tupdated = await balance_collection.find_one_and_update(\n\t\t                        {\"uid\":account[\"id\"]}, \n\t\t                        {\"$set\":{\"amount_active\":str(difference)}})\n\t\tif not updated:\n\t\t    return {\"error\":404, \n\t\t            \"reason\":\"Confirm balance. Not found current transaction id\"}\n\n\t\t# Delete transaction id field\n\t\tawait history_collection.find_one_and_update({\"txid\":txid}, \n\t\t\t\t\t\t\t\t\t\t\t\t{\"$unset\":{\"txid\":1}})\n\n\n\t\tif int(account[\"level\"]) == 2:\n\t\t    await self.account.updatelevel(**{\"id\":account[\"id\"], \"level\":3})\n\n\t\treturn {i:updated[i] for i in updated if i != \"_id\" and i != \"txid\"}", "response": "Confirm balance after trading"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the configuration file.", "response": "def _validate_config(self):\n        \"\"\"\n        Validate configuration file.\n        :raises: RuntimeError\n        \"\"\"\n        # while set().issubset() is easier, we want to tell the user the names\n        # of any invalid keys\n        bad_keys = []\n        for k in self._config.keys():\n            if k not in self._example.keys():\n                bad_keys.append(k)\n        if len(bad_keys) > 0:\n            raise InvalidConfigError('Invalid keys: %s' % bad_keys)\n        # endpoints\n        if 'endpoints' not in self._config or len(\n                self._config['endpoints']) < 1:\n            raise InvalidConfigError('configuration must have '\n                                     'at least one endpoint')\n        for ep in self._config['endpoints']:\n            if sorted(\n                    self._config['endpoints'][ep].keys()\n            ) != ['method', 'queues']:\n                raise InvalidConfigError('Endpoint %s configuration keys must '\n                                         'be \"method\" and \"queues\".' % ep)\n            meth = self._config['endpoints'][ep]['method']\n            if meth not in self._allowed_methods:\n                raise InvalidConfigError('Endpoint %s method %s not allowed '\n                                         '(allowed methods: %s'\n                                         ')' % (ep, meth,\n                                                self._allowed_methods))\n        levels = ['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG', 'NOTSET']\n        if ('logging_level' in self._config and\n                self._config['logging_level'] not in levels):\n            raise InvalidConfigError('logging_level must be one of %s' % levels)\n        \"\"\"\n        'api_gateway_method_settings': {\n            'throttlingBurstLimit': None,\n            'throttlingRateLimit': None\n        },\n        \"\"\"\n        if 'api_gateway_method_settings' not in self._config:\n            return\n        ms = self._config['api_gateway_method_settings']\n        bad_keys = []\n        for k in ms.keys():\n            if k not in self._example['api_gateway_method_settings'].keys():\n                bad_keys.append(k)\n        if len(bad_keys) > 0:\n            raise InvalidConfigError(\n                'Invalid keys in \"api_gateway_method_settings\": %s' % bad_keys)\n        if 'metricsEnabled' in ms and ms['metricsEnabled'] not in [True, False]:\n            raise InvalidConfigError(\n                'api_gateway_method_settings metricsEnabled key must be omitted'\n                ' or a boolean')\n        if ('loggingLevel' in ms and\n                ms['loggingLevel'] not in ['OFF', 'INFO', 'ERROR']):\n            raise InvalidConfigError(\n                'api_gateway_method_settings loggingLevel must be omitted or '\n                'one of \"OFF\", \"INFO\" or \"ERROR\"'\n            )\n        if ('metricsEnabled' in ms and\n                ms['dataTraceEnabled'] not in [True, False]):\n            raise InvalidConfigError(\n                'api_gateway_method_settings dataTraceEnabled key must be '\n                'omitted or a boolean')\n        if ('throttlingBurstLimit' in ms and\n                ms['throttlingBurstLimit'] is not None):\n            try:\n                assert ms['throttlingBurstLimit'] == int(\n                    ms['throttlingBurstLimit'])\n            except (AssertionError, ValueError, TypeError):\n                raise InvalidConfigError(\n                    'api_gateway_method_settings throttlingBurstLimit key must '\n                    'be omitted, null or an integer'\n                )\n        if ('throttlingRateLimit' in ms and\n                ms['throttlingRateLimit'] is not None):\n            try:\n                assert ms['throttlingRateLimit'] == float(\n                    ms['throttlingRateLimit'])\n            except (AssertionError, ValueError, TypeError):\n                raise InvalidConfigError(\n                    'api_gateway_method_settings throttlingRateLimit key must '\n                    'be omitted, null or a Number (float/double)'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads configuration from JSON file", "response": "def _load_config(self, path):\n        \"\"\"\n        Load configuration from JSON\n\n        :param path: path to the JSON config file\n        :type path: str\n        :return: config dictionary\n        :rtype: dict\n        \"\"\"\n        p = os.path.abspath(os.path.expanduser(path))\n        logger.debug('Loading configuration from: %s', p)\n        return read_json_file(p)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __add_min_max_value(\n        parser,\n        basename,\n        default_min,\n        default_max,\n        initial,\n        help_template):\n    \"\"\"\n    Generates parser entries for options\n    with a min, max, and default value.\n\n    Args:\n        parser: the parser to use.\n        basename: the base option name. Generated options will have flags\n            --basename-min, --basename-max, and --basename.\n        default_min: the default min value\n        default_max: the default max value\n        initial: the default initial value\n        help_template: the help string template.\n            $mmi will be replaced with min, max, or initial.\n            $name will be replaced with basename.\n    \"\"\"\n    help_template = Template(help_template)\n\n    parser.add(\n        '--{0}-min'.format(basename),\n        default=default_min,\n        type=float,\n        required=False,\n        help=help_template.substitute(mmi='min', name=basename))\n\n    parser.add(\n        '--{0}-max'.format(basename),\n        default=default_max,\n        type=float,\n        required=False,\n        help=help_template.substitute(mmi='max', name=basename))\n\n    parser.add(\n        '--{0}'.format(basename),\n        default=initial,\n        type=float,\n        required=False,\n        help=help_template.substitute(mmi='initial', name=basename))", "response": "Adds min and max values to the specified parser."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the full path to the configuration file.", "response": "def get_config_file(basename):\n    \"\"\" Looks for a configuration file in 3 locations:\n\n        - the current directory\n        - the user config directory (~/.config/scriptabit)\n        - the version installed with the package (using setuptools resource API)\n\n    Args:\n        basename (str): The base filename.\n\n    Returns:\n        str: The full path to the configuration file.\n    \"\"\"\n    locations = [\n        os.path.join(os.curdir, basename),\n        os.path.join(\n            os.path.expanduser(\"~\"),\n            \".config\",\n            \"scriptabit\",\n            basename),\n        resource_filename(\n            Requirement.parse(\"scriptabit\"),\n            os.path.join('scriptabit', basename))\n    ]\n\n    for location in locations:\n        if os.path.isfile(location):\n            return location"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy the default configuration file into the user config directory.", "response": "def copy_default_config_to_user_directory(\n        basename,\n        clobber=False,\n        dst_dir='~/.config/scriptabit'):\n    \"\"\" Copies the default configuration file into the user config directory.\n\n    Args:\n        basename (str): The base filename.\n        clobber (bool): If True, the default will be written even if a user\n            config already exists.\n        dst_dir (str): The destination directory.\n    \"\"\"\n    dst_dir = os.path.expanduser(dst_dir)\n    dst = os.path.join(dst_dir, basename)\n    src = resource_filename(\n        Requirement.parse(\"scriptabit\"),\n        os.path.join('scriptabit', basename))\n\n    if not os.path.exists(dst_dir):\n        os.makedirs(dst_dir)\n\n    if clobber or not os.path.isfile(dst):\n        shutil.copy(src, dst)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_configuration(basename='scriptabit.cfg', parents=None):\n    copy_default_config_to_user_directory(basename)\n\n    parser = configargparse.ArgParser(\n        formatter_class=configargparse.ArgumentDefaultsRawHelpFormatter,\n        add_help=False,\n        parents=parents or [],\n        default_config_files=[\n            resource_filename(\n                Requirement.parse(\"scriptabit\"),\n                os.path.join('scriptabit', basename)),\n            os.path.join(\n                os.path.expanduser(\"~/.config/scriptabit\"),\n                basename),\n            os.path.join(os.curdir, basename)])\n\n    # logging config file\n    parser.add(\n        '-lc',\n        '--logging-config',\n        required=False,\n        default='scriptabit_logging.cfg',\n        metavar='FILE',\n        env_var='SCRIPTABIT_LOGGING_CONFIG',\n        help='Logging configuration file')\n\n    # Authentication file section\n    parser.add(\n        '-as',\n        '--auth-section',\n        required=False,\n        default='habitica',\n        help='''Name of the authentication file section containing the Habitica\ncredentials''')\n\n    parser.add(\n        '-url',\n        '--habitica-api-url',\n        required=False,\n        default='https://habitica.com/api/v3/',\n        help='''The base Habitica API URL''')\n\n    # plugins\n    parser.add(\n        '-r',\n        '--run',\n        required=False,\n        help='''Select the plugin to run. Note you can only run a single\nplugin at a time. If you specify more than one, then only the\nlast one will be executed. To chain plugins together, create a\nnew plugin that combines the effects as required.''')\n\n    parser.add(\n        '-ls',\n        '--list-plugins',\n        required=False,\n        action='store_true',\n        help='''List available plugins''')\n\n    parser.add(\n        '-v',\n        '--version',\n        required=False,\n        action='store_true',\n        help='''Display scriptabit version''')\n\n    parser.add(\n        '-dr',\n        '--dry-run',\n        required=False,\n        action='store_true',\n        help='''Conduct a dry run. No changes are written to online services''')\n\n    parser.add(\n        '-n',\n        '--max-updates',\n        required=False,\n        type=int,\n        default=0,\n        help='''If > 0, this sets a limit on the number of plugin updates.\nNote that plugins can still exit before the limit is reached.''')\n\n    parser.add(\n        '-uf',\n        '--update-frequency',\n        required=False,\n        type=int,\n        default=-1,\n        help='''If > 0, this specifies the preferred update frequency in minutes\nfor plugins that run in the update loop. Note that plugins may ignore or limit\nthis setting if the value is inappropriate for the specific plugin.''')\n\n    parser.add(\n        '-h',\n        '--help',\n        required=False,\n        action='store_true',\n        help='''Print help''')\n\n    return parser.parse_known_args()[0], parser.print_help", "response": "Parses and returns the program configuration options and command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef authenticate(self, token):\n        if self.verify_token_callback:\n            # Specified verify function overrides below\n            return self.verify_token_callback(token)\n\n        if not token:\n            return False\n\n        name = self.token_manager.verify(token)\n        if not name:\n            return False\n\n        return True", "response": "Authenticate a token\n\n        :param token:"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a date from a raw string.", "response": "def parse_raw(s, lineno=0):\n    \"\"\"Parse a date from a raw string.\n\n    The format must be exactly \"seconds-since-epoch offset-utc\".\n    See the spec for details.\n    \"\"\"\n    timestamp_str, timezone_str = s.split(b' ', 1)\n    timestamp = float(timestamp_str)\n    try:\n        timezone = parse_tz(timezone_str)\n    except ValueError:\n        raise errors.InvalidTimezone(lineno, timezone_str)\n    return timestamp, timezone"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_tz(tz):\n    # from git_repository.py in bzr-git\n    sign_byte = tz[0:1]\n    # in python 3 b'+006'[0] would return an integer,\n    # but b'+006'[0:1] return a new bytes string.\n    if sign_byte not in (b'+', b'-'):\n        raise ValueError(tz)\n\n    sign = {b'+': +1, b'-': -1}[sign_byte]\n    hours = int(tz[1:-2])\n    minutes = int(tz[-2:])\n\n    return sign * 60 * (60 * hours + minutes)", "response": "Parse a timezone specification in the [ + - ] HHMM format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_define_service(p):\n    if len(p) == 7:\n        body = p[4] + p[5]\n    else:\n        body = p[4]\n    p[0] = DefineService(p[2], body)", "response": "A function to define a service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_setting_list(p):\n    if len(p) == 3:\n        p[0] = merge_map(p[1], p[2])\n    elif len(p) == 2:\n        p[0] = p[1]\n    else:\n        raise RuntimeError(\"Invalid production rules 'p_setting_list'\")", "response": "Merge the list of production rules into a single list of production rules."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_queue(p):\n    if p[3] == \"LIFO\":\n        p[0] = {\"queue\": LIFO()}\n\n    elif p[3] == \"FIFO\":\n        p[0] = {\"queue\": FIFO()}\n\n    else:\n        raise RuntimeError(\"Queue discipline '%s' is not supported!\" % p[1])", "response": "Set the queue property of a resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nthrottling : THROTTLING COLON NONE | THROTTLING COLON TAIL_DROP OPEN_BRACKET NUMBER CLOSE_BRACKET", "response": "def p_throttling(p):\n    \"\"\"\n    throttling : THROTTLING COLON NONE\n               | THROTTLING COLON TAIL_DROP OPEN_BRACKET NUMBER CLOSE_BRACKET\n    \"\"\"\n    throttling = NoThrottlingSettings()\n    if len(p) == 7:\n        throttling = TailDropSettings(int(p[5]))\n    p[0] = {\"throttling\": throttling}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_autoscaling_setting_list(p):\n    if len(p) == 3:\n        p[0] = merge_map(p[1], p[2])\n    elif len(p) == 2:\n        p[0] = p[1]\n    else:\n        raise RuntimeError(\"Invalid production in 'autoscaling_setting_list'\")", "response": "A list of autoscaling_setting tuples."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the autoscaling setting into a dict.", "response": "def p_autoscaling_setting(p):\n    \"\"\"\n    autoscaling_setting : PERIOD COLON NUMBER\n                        | LIMITS COLON OPEN_SQUARE_BRACKET NUMBER COMMA NUMBER CLOSE_SQUARE_BRACKET\n    \"\"\"\n    if len(p) == 8:\n        p[0] = {\"limits\": (int(p[4]), int(p[6]))}\n    elif len(p) == 4:\n        p[0] = {\"period\": int(p[3])}\n    else:\n        raise RuntimeError(\"Invalid product in 'autoscaling_setting'\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_action_list(p):\n    if len(p) == 3:\n        p[0] = p[1] + p[2]\n    elif len(p) == 2:\n        p[0] = p[1]\n    else:\n        raise RuntimeError(\"Invalid production rules 'p_action_list'\")", "response": "The action list is a list of actions that are part of the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_fail(p):\n    if len(p) > 2:\n        p[0] = Fail(float(p[2]))\n    else:\n        p[0] = Fail()", "response": "fail - set fail to Fail"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a query into a sequence of Query objects.", "response": "def p_query(p):\n    \"\"\"\n    query : QUERY IDENTIFIER SLASH IDENTIFIER\n          | QUERY IDENTIFIER SLASH IDENTIFIER OPEN_CURLY_BRACKET query_option_list CLOSE_CURLY_BRACKET\n    \"\"\"\n    parameters = {\"service\": p[2], \"operation\": p[4]}\n    if len(p) > 5:\n        parameters = merge_map(parameters, p[6])\n    p[0] = Query(**parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_query_option_list(p):\n    if len(p) == 2:\n        p[0] = p[1]\n    elif len(p) == 4:\n        p[0] = merge_map(p[1], p[3])\n    else:\n        raise RuntimeError(\"Invalid product rules for 'query_option_list'\")", "response": "Parse the query option list into a single entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninvoke : INVOKE IDENTIFIER SLASH IDENTIFIER | INVOKE IDENTIFIER SLASH IDENTIFIER OPEN_CURLY_BRACKET PRIORITY COLON NUMBER CLOSE_CURLY_BRACKET", "response": "def p_invoke(p):\n    \"\"\"\n    invoke : INVOKE IDENTIFIER SLASH IDENTIFIER\n           | INVOKE IDENTIFIER SLASH IDENTIFIER OPEN_CURLY_BRACKET PRIORITY COLON NUMBER CLOSE_CURLY_BRACKET\n    \"\"\"\n    priority = None\n    if len(p) > 5:\n        priority = int(p[8])\n    p[0] = Trigger(p[2], p[4], priority)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef p_retry(p):\n    if len(p) == 5:\n        p[0] = Retry(p[3])\n    elif len(p) == 8:\n        p[0] = Retry(p[6], **p[3])\n    else:\n        raise RuntimeError(\"Invalid product rules for 'retry_option_list'\")", "response": "Parse the retry option list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the retry option list.", "response": "def p_retry_option_list(p):\n    \"\"\"\n    retry_option_list : retry_option COMMA retry_option_list\n                      | retry_option\n    \"\"\"\n    if len(p) == 4:\n        p[0] = merge_map(p[1], p[3])\n    elif len(p) == 2:\n        p[0] = p[1]\n    else:\n        raise RuntimeError(\"Invalid production in 'retry_option_list'\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the retry_option production.", "response": "def p_retry_option(p):\n    \"\"\"\n    retry_option : LIMIT COLON NUMBER\n                 | DELAY COLON IDENTIFIER OPEN_BRACKET NUMBER CLOSE_BRACKET\n    \"\"\"\n    if len(p) == 4:\n        p[0] = {\"limit\": int(p[3]) }\n    elif len(p) == 7:\n        p[0] = {\"delay\": Delay(int(p[5]), p[3])}\n    else:\n        raise RuntimeError(\"Invalid production in 'retry_option'\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the given address is valid for the current blockchain.", "response": "def is_valid_address(self, *args, **kwargs):\n        \"\"\"\n        check address\n\n        Accepts:\n            - address [hex string] (withdrawal address in hex form)\n            - coinid [string] (blockchain id (example: BTCTEST, LTCTEST))\n        Returns dictionary with following fields:\n            - bool [Bool]\n        \"\"\"\n\n        client = HTTPClient(self.withdraw_server_address + self.withdraw_endpoint)\n\n        return client.request('is_valid_address', kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a token with the blockchain", "response": "def register_token(self, *args, **kwargs):\n        \"\"\"\n        Register token\n\n        Accepts:\n            - token_name [string]\n            - contract_address [hex string]\n            - blockchain [string]  token's blockchain (QTUMTEST, ETH)\n        Returns dictionary with following fields:\n            - success [Bool]\n         \"\"\"\n        client = HTTPClient(self.withdraw_server_address + self.withdraw_endpoint)\n        if check_sig:\n            return client.request('register_token', self.signature_validator.sign(kwargs))\n        else:\n            return client.request('register_token', kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lines(self, config_access, visited_set):\n        if self in visited_set:\n            return []\n        lines = self.lines.copy()\n        visited_set.add(self)\n        for identity in self.identities:\n            if config_access.get_keyfile(identity):\n                lines.append(('IdentitiesOnly', ['yes']))\n                lines.append(('IdentityFile', [pipes.quote(config_access.get_keyfile(identity))]))\n        for section_name in self.types:\n            section = config_access.get_section(section_name)\n            lines += section.get_lines(config_access, visited_set)\n        return lines", "response": "get the lines for this section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef variable_iter(self, base):\n        base_substs = dict(('<' + t + '>', u) for (t, u) in base.items())\n        substs = []\n        vals = []\n        for with_defn in self.with_exprs:\n            substs.append('<' + with_defn[0] + '>')\n            vals.append(Host.expand_with(with_defn[1:]))\n        for val_tpl in product(*vals):\n            r = base_substs.copy()\n            r.update(dict(zip(substs, val_tpl)))\n            yield r", "response": "returns an iterator over the cross product of the variables\n        for this stanza"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of host definitions", "response": "def host_stanzas(self, config_access):\n        \"\"\"\n        returns a list of host definitions\n        \"\"\"\n        defn_lines = self.resolve_defn(config_access)\n        for val_dict in self.variable_iter(config_access.get_variables()):\n            subst = list(self.apply_substitutions(defn_lines, val_dict))\n            host = subst[0]\n            lines = [ConfigOutput.to_line('Host', [host])] + subst[1:]\n            yield host, lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef showpath(path):\n        try:\n            retval = os.path.relpath(path, os.getcwd())\n        except ValueError:\n            retval = path\n        else:\n            if retval.startswith('..'):\n                retval = path\n        return retval", "response": "Return path in form most convenient for user to read."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists of file lines.", "response": "def lines(self):\n        \"\"\"List of file lines.\"\"\"\n        if self._lines is None:\n            with io.open(self.path, 'r', encoding='utf-8') as fh:\n                self._lines = fh.read().split('\\n')\n\n        return self._lines"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplacing individual baseline representation.", "response": "def replace_baseline_repr(self, linenum, update):\n        \"\"\"Replace individual baseline representation.\n\n        :param int linenum: location of baseline representation\n        :param str update: new baseline representation text (with delimiters)\n\n        \"\"\"\n        # use property to access lines to read them from file if necessary\n        lines = self.lines\n\n        count = 0\n        delimiter = None\n        for index in range(linenum - 1, -1, -1):\n            line = lines[index]\n            if delimiter is None:\n                single_quote_index = line.rfind(\"'''\")\n                double_quote_index = line.rfind('\"\"\"')\n                if double_quote_index >= 0:\n                    if double_quote_index > single_quote_index:\n                        delimiter = '\"\"\"'\n                    else:\n                        delimiter = \"'''\"\n                elif single_quote_index >= 0:\n                    delimiter = \"'''\"\n                else:\n                    continue\n            count += lines[index].count(delimiter)\n            if count >= 2:\n                linenum = index\n                break\n        else:\n            docstr_not_found = (\n                '{}:{}: could not find baseline docstring'\n                ''.format(self.showpath(self.path), linenum))\n            raise RuntimeError(docstr_not_found)\n\n        old_content = '\\n'.join(lines[linenum:])\n\n        match = self.REGEX.match(old_content)\n\n        if match is None:\n            docstr_not_found = (\n                '{}:{}: could not find docstring'.format(self.path, linenum))\n            raise RuntimeError(docstr_not_found)\n\n        new_content = match.group('prefix') + update + match.group('suffix')\n\n        lines[linenum:] = new_content.split('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self):\n        for linenum in reversed(sorted(self.updates)):\n            self.replace_baseline_repr(linenum, self.updates[linenum])\n\n        if not self.TEST_MODE:\n            path = '{}.update{}'.format(*os.path.splitext(self.path))\n            with io.open(path, 'w', encoding='utf-8') as fh:\n                fh.write('\\n'.join(self.lines))\n            print('UPDATE: {}'.format(self.showpath(path)))", "response": "Update the baseline representation of the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _sum(data):\n    data = iter(data)\n    n = _first(data)\n\n    if n is not None:\n        data = chain([n], data)\n        if isinstance(n, F):\n            return math.fsum(data)\n        return sum(data)\n    return 0", "response": "Return a high - precision sum of the given numeric data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mean(data):\n    if iter(data) is data:\n        data = list(data)\n    n = len(data)\n    if n < 1:\n        raise StatisticsError('mean requires at least one data point')\n    return _sum(data)/n", "response": "Return the sample arithmetic mean of data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef median_grouped(data, interval=1):\n    data = sorted(data)\n    n = len(data)\n    if n == 0:\n        raise StatisticsError(\"no median for empty data\")\n    elif n == 1:\n        return data[0]\n    # Find the value at the midpoint. Remember this corresponds to the\n    # centre of the class interval.\n    x = data[n//2]\n    for obj in (x, interval):\n        if isinstance(obj, (str, bytes)):\n            raise TypeError('expected number but got %r' % obj)\n    try:\n        L = x - interval/2  # The lower limit of the median interval.\n    except TypeError:\n        # Mixed type. For now we just coerce to float.\n        L = float(x) - float(interval)/2\n    cf = data.index(x)  # Number of values below the median interval.\n    # FIXME The following line could be more efficient for big lists.\n    f = data.count(x)  # Number of data points in the median interval.\n    return L + interval*(n/2 - cf)/f", "response": "Return the 50th percentile of grouped continuous data."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the most common data point from discrete or nominal data.", "response": "def mode(data):\n    \"\"\"Return the most common data point from discrete or nominal data.\n\n    ``mode`` assumes discrete data, and returns a single value. This is the\n    standard treatment of the mode as commonly taught in schools:\n\n    >>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n    3\n\n    This also works with nominal (non-numeric) data:\n\n    >>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"])\n    'red'\n    \"\"\"\n\n    # Generate a table of sorted (value, frequency) pairs.\n    hist = collections.Counter(data)\n    top = hist.most_common(2)\n\n    if len(top) == 1:\n        return top[0][0]\n    elif not top:\n        raise StatisticsError('no mode for empty data')\n    elif top[0][1] == top[1][1]:\n        raise StatisticsError(\n            'no unique mode; found %d equally common values' % len(hist)\n            )\n    else:\n        return top[0][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ss(data, c=None):\n    if c is None:\n        c = mean(data)\n    #print(data)\n    ss = _sum((x-c)**2 for x in data)\n    # The following sum should mathematically equal zero, but due to rounding\n    # error may not.\n    ss -= _sum((x-c) for x in data)**2/len(data)\n    assert not ss < 0, 'negative sum of square deviations: %f' % ss\n    return ss", "response": "Return sum of square deviations of sequence data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unicode_to_str(text, encoding=None, errors='strict'):\n\n    if encoding is None:\n        encoding = 'utf-8'\n    if isinstance(text, unicode):\n        return text.encode(encoding, errors)\n    elif isinstance(text, str):\n        return text\n    else:\n        raise TypeError('unicode_to_str must receive a unicode or str object, got %s' % type(text).__name__)", "response": "Return the str representation of text in the given encoding."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the url belongs to any of the given domains", "response": "def url_is_from_any_domain(url, domains):\n    \"\"\"Return True if the url belongs to any of the given domains\"\"\"\n    host = parse_url(url).netloc.lower()\n\n    if host:\n        return any(((host == d.lower()) or (host.endswith('.%s' % d.lower())) for d in domains))\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef canonicalize_url(url, keep_params=False, keep_fragments=False):\n    if keep_params:\n        # Preserve all query params\n        parsed = extract(norm(url))\n    else:\n        # Remove unwanted params\n        parsed = extract(url_query_cleaner(normalize(url), parameterlist=config.USEFUL_QUERY_KEYS))\n\n    # Sort params, remove blank if not wanted\n    query = urllib.urlencode(sorted(urlparse.parse_qsl(parsed.query, keep_blank_values=keep_params)))\n    fragment = getFragment(url, keep_fragments)\n\n    # The following is to remove orphaned '=' from query string params with no values\n    query = re.sub(r\"=$\", \"\", query.replace(\"=&\", \"&\"))\n\n    # Reconstruct URL, escaping apart from safe chars\n    # See http://stackoverflow.com/questions/2849756/list-of-valid-characters-for-the-fragment-identifier-in-an-url\n    # http://stackoverflow.com/questions/4669692/valid-characters-for-directory-part-of-a-url-for-short-links\n    safe = \"/.-_~!$&'()*+,;=:@\"\n    newurl = construct(URL(parsed.scheme, '', '', parsed.subdomain, parsed.domain, parsed.tld, parsed.port, quote(parsed.path, safe=safe), query, quote(fragment, safe=safe), ''))\n    return newurl.rstrip('/')", "response": "Canonicalize the given url by applying the following procedures."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning urlparsed url from the given argument", "response": "def parse_url(url, encoding=None):\n    \"\"\"Return urlparsed url from the given argument (which could be an already\n    parsed url)\n    \"\"\"\n    return url if isinstance(url, urlparse.ParseResult) else \\\n        urlparse.urlparse(unicode_to_str(url, encoding))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _iterable_as_config_list(s):\n    items = sorted(s)\n    if len(items) == 1:\n        return \"%s,\" % (items[0],)\n    else:\n        return \", \".join(items)", "response": "Format an iterable as a sequence of comma - separated strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps a statistics group.", "response": "def _dump_stats_group(self, title, items, normal_formatter=None,\n        verbose_formatter=None):\n        \"\"\"Dump a statistics group.\n        \n        In verbose mode, do so as a config file so\n        that other processors can load the information if they want to.\n        :param normal_formatter: the callable to apply to the value\n          before displaying it in normal mode\n        :param verbose_formatter: the callable to apply to the value\n          before displaying it in verbose mode\n        \"\"\"\n        if self.verbose:\n            self.outf.write(\"[%s]\\n\" % (title,))\n            for name, value in items:\n                if verbose_formatter is not None:\n                    value = verbose_formatter(value)\n                if type(name) == str:\n                    name = name.replace(' ', '-')\n                self.outf.write(\"%s = %s\\n\" % (name, value))\n            self.outf.write(\"\\n\")\n        else:\n            self.outf.write(\"%s:\\n\" % (title,))\n            for name, value in items:\n                if normal_formatter is not None:\n                    value = normal_formatter(value)\n                self.outf.write(\"\\t%s\\t%s\\n\" % (value, name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_search(self, max_page=1):\n        for page in range(1, (max_page + 1)):\n            start = \"start={0}\".format(str((page - 1) * 10))\n            url = \"{0}{1}&{2}\".format(self.google, self.query, start)\n            self._execute_search_request(url)\n            self.current_page += 1", "response": "start search from page 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _execute_search_request(self, url):\n        try:\n            self.request_page = requests.get(url)\n        except requests.ConnectionError:\n            print(\"Connection to {0} failed\".format(str(url)))\n        self.current_html_page = self.request_page.text\n        soup = BeautifulSoup(self.current_html_page, \"html5lib\")\n        results = soup.find_all('a', class_=False)\n        links = []  # store the final url of search result, 10 links\n        # this loop filter the search result links inside the search page\n        for target in results:\n            # filter only link from search result should be appended\n            if target.get('href').find(\"/url?q\") == 0 \\\n                    and not \\\n                    target.get('href').find(\n                            \"/url?q=http://webcache.googleusercontent.com\"\n                    ) == 0 \\\n                    and not \\\n                    target.get('href').find(\"/url?q=/settings/\") == 0:\n                start_index = target.get('href').find('http')\n                end_index = target.get('href').find('&sa')\n                # slice the desired url into ideal link, and append\n                # it to reserved list variable\n                links.append(target.get('href')[start_index:end_index])\n        # this loop inspect if the current page is the final page\n        for href in results:\n            fnl = 'repeat the search with the omitted results included'\n            if href.get_text() == fnl:\n                self.is_final_page = True\n            else:\n                pass\n        # send the final url link to class reserved variable\n        for link in links:\n            self.search_result.append(link)", "response": "method to execute the search request to google."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readConfig(self, configuration):\n        self.__logger.debug(\"Reading configuration\")\n        self.city = configuration[\"name\"]\n        self.__logger.info(\"City name: \" + self.city)\n        if \"intervals\" in configuration:\n            self.__intervals = configuration[\"intervals\"]\n            self.__logger.debug(\"Intervals: \" +\n                                str(self.__intervals))\n\n        if \"last_date\" in configuration:\n            self.__lastDay = configuration[\"last_date\"]\n            self.__logger.debug(\"Last day: \" + self.__lastDay)\n\n        if \"locations\" in configuration:\n            self.__locations = configuration[\"locations\"]\n            self.__logger.debug(\"Locations: \" +\n                                str(self.__locations))\n            self.__addLocationsToURL(self.__locations)\n\n        if \"excludedUsers\" in configuration:\n            self.__excludedUsers= set()\n            self.__excludedLocations = set()\n\n            excluded = configuration[\"excludedUsers\"]\n            for e in excluded:\n                self.__excludedUsers.add(e)\n            self.__logger.debug(\"Excluded users \" +\n                                str(self.__excludedUsers))\n\n        if \"excludedLocations\" in configuration:\n            excluded = configuration[\"excludedLocations\"]\n            for e in excluded:\n                self.__excludedLocations.add(e)\n\n            self.__logger.debug(\"Excluded locations \" +\n                                str(self.__excludedLocations))", "response": "Read configuration from a JSON configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readConfigFromJSON(self, fileName):\n        self.__logger.debug(\"readConfigFromJSON: reading from \" + fileName)\n        with open(fileName) as data_file:\n            data = load(data_file)\n        self.readConfig(data)", "response": "Read the configuration from a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configToJson(self, fileName):\n        config = self.getConfig()\n        with open(fileName, \"w\") as outfile:\n            dump(config, outfile, indent=4, sort_keys=True)", "response": "Save the configuration of the city in a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getConfig(self):\n        config = {}\n        config[\"name\"] = self.city\n        config[\"intervals\"] = self.__intervals\n        config[\"last_date\"] = self.__lastDay\n        config[\"excludedUsers\"] = []\n        config[\"excludedLocations\"] = []\n\n        for e in self.__excludedUsers:\n            config[\"excludedUsers\"].append(e)\n\n        for e in self.__excludedLocations:\n            config[\"excludedLocations\"].append(e)\n\n        config[\"locations\"] = self.__locations\n        return config", "response": "Return the configuration of the city."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addFilter(self, field, value):\n        if \"<\" not in value or \">\" not in value or \"..\" not in value:\n            value = \":\" + value\n\n        if self.__urlFilters:\n            self.__urlFilters += \"+\" + field + str(quote(value))\n        else:\n            self.__urlFilters += field + str(quote(value))", "response": "Add a filter to the seach."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __processUsers(self):\n        while self.__usersToProccess.empty() and not self.__end:\n            pass\n\n        while not self.__end or not self.__usersToProccess.empty():\n            self.__lockGetUser.acquire()\n            try:\n                new_user = self.__usersToProccess.get(False)\n            except Empty:\n                self.__lockGetUser.release()\n                return\n            else:\n                self.__lockGetUser.release()\n                self.__addUser(new_user)\n                self.__logger.info(\"__processUsers:\" +\n                                   str(self.__usersToProccess.qsize()) +\n                                   \" users to  process\")", "response": "Process users of the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new user to the list.", "response": "def __addUser(self, new_user):\n        \"\"\"Add new users to the list.\n\n        :param new_user: name of a GitHub user to include in\n            the ranking\n        :type new_user: str.\n        \"\"\"\n        self.__lockReadAddUser.acquire()\n        if new_user not in self.__cityUsers and \\\n                new_user not in self.__excludedUsers:\n            self.__lockReadAddUser.release()\n            self.__logger.debug(\"__addUser: Adding \" + new_user)\n            self.__cityUsers.add(new_user)\n\n            myNewUser = GitHubUser(new_user)\n            myNewUser.getData()\n            myNewUser.getRealContributions()\n\n            userLoc = myNewUser.location\n            if not any(s in userLoc for s in self.__excludedLocations):\n                self.__processedUsers.append(myNewUser)\n        else:\n            self.__logger.debug(\"__addUser: Excluding \" + new_user)\n            self.__lockReadAddUser.release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __getPeriodUsers(self, start_date, final_date):\n        self.__logger.info(\"Getting users from \" + start_date +\n                           \" to \" + final_date)\n\n        url = self.__getURL(1, start_date, final_date)\n        data = self.__readAPI(url)\n        users = []\n\n        total_pages = 10000\n        page = 1\n\n        while total_pages >= page:\n            url = self.__getURL(page, start_date, final_date)\n            data = self.__readAPI(url)\n            self.__logger.debug(str(len(data['items'])) +\n                                \" users found\")\n            for u in data['items']:\n                users.append(u[\"login\"])\n                self.__usersToProccess.put(u[\"login\"])\n            total_count = data[\"total_count\"]\n            total_pages = int(total_count / 100) + 1\n            page += 1\n        return users", "response": "Get all the users given a period."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all the users from the city.", "response": "def getCityUsers(self, numberOfThreads=20):\n        \"\"\"Get all the users from the city.\n\n        :param numberOfThreads: number of threads to run.\n        :type numberOfThreads: int.\n        \"\"\"\n        if not self.__intervals:\n            self.__logger.debug(\"Calculating best intervals\")\n            self.calculateBestIntervals()\n\n        self.__end = False\n        self.__threads = set()\n\n        comprobationURL = self.__getURL()\n        self.__readAPI(comprobationURL)\n\n        self.__launchThreads(numberOfThreads)\n        self.__logger.debug(\"Launching threads\")\n        for i in self.__intervals:\n            self.__getPeriodUsers(i[0], i[1])\n\n        self.__end = True\n\n        for t in self.__threads:\n            t.join()\n        self.__logger.debug(\"Threads joined\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculateBestIntervals(self):\n        self.__intervals = []\n        self.__readAPI(self.__getURL())\n        today = datetime.datetime.now().date()\n\n        self.__validInterval(datetime.date(2008, 1, 1), today)\n        self.__logger.info(\"Total number of intervals: \" +\n                           str(len(self.__intervals)))\n        self.__lastDay = today.strftime(\"%Y-%m-%d\")", "response": "Calcule valid intervals of a city."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __validInterval(self, start, finish):\n        url = self.__getURL(1,\n                            start.strftime(\"%Y-%m-%d\"),\n                            finish.strftime(\"%Y-%m-%d\"))\n\n        data = self.__readAPI(url)\n\n        if data[\"total_count\"] >= 1000:\n            middle = start + (finish - start)/2\n            self.__validInterval(start, middle)\n            self.__validInterval(middle, finish)\n        else:\n            self.__intervals.append([start.strftime(\"%Y-%m-%d\"),\n                                     finish.strftime(\"%Y-%m-%d\")])\n            self.__logger.info(\"New valid interval: \" +\n                               start.strftime(\"%Y-%m-%d\") +\n                               \" to \" +\n                               finish.strftime(\"%Y-%m-%d\"))", "response": "Check if the interval is correct."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexporting the ranking to a file.", "response": "def export(self, template_file_name, output_file_name,\n               sort=\"public\", data=None, limit=0):\n        \"\"\"Export ranking to a file.\n\n        Args:\n            template_file_name (str): where is the template\n                (moustache template)\n            output_file_name (str): where create the file with the ranking\n            sort (str): field to sort the users\n        \"\"\"\n        exportedData = {}\n        exportedUsers = self.__exportUsers(sort, limit)\n\n        exportedData[\"users\"] = exportedUsers\n        exportedData[\"extraData\"] = data\n\n        with open(template_file_name) as template_file:\n            template_raw = template_file.read()\n\n        template = parse(template_raw)\n        renderer = Renderer()\n\n        output = renderer.render(template, exportedData)\n\n        with open(output_file_name, \"w\") as text_file:\n            text_file.write(output)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list with sorted users.", "response": "def getSortedUsers(self, order=\"public\"):\n        \"\"\"Return a list with sorted users.\n\n        :param order: the field to sort the users.\n            - contributions (total number of contributions)\n            - public (public contributions)\n            - private (private contributions)\n            - name\n            - followers\n            - join\n            - organizations\n            - repositories\n        :type order: str.\n        :return: a list of the github users sorted by the selected field.\n        :rtype: str.\n        \"\"\"\n        try:\n            self.__processedUsers.sort(key=lambda u: getattr(u, order), reverse=True)\n        except AttributeError:\n            pass\n        return self.__processedUsers"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexporting the users to a dictionary.", "response": "def __exportUsers(self, sort, limit=0):\n        \"\"\"Export the users to a dictionary.\n\n        :param sort: field to sort the users\n        :type sort: str.\n        :return: exported users.\n        :rtype: dict.\n        \"\"\"\n        position = 1\n        dataUsers = self.getSortedUsers(sort)\n\n        if limit:\n            dataUsers = dataUsers[:limit]\n\n        exportedUsers = []\n\n        for u in dataUsers:\n            userExported = u.export()\n            userExported[\"position\"] = position\n            exportedUsers.append(userExported)\n\n            if position < len(dataUsers):\n                userExported[\"comma\"] = True\n\n            position += 1\n        return exportedUsers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculeToday(self):\n        self.__logger.debug(\"Add today\")\n        last = datetime.datetime.strptime(self.__lastDay, \"%Y-%m-%d\")\n        today = datetime.datetime.now().date()\n        self.__validInterval(last, today)", "response": "Calcule the intervals from the last date."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting all locations to GitHub s URL API.", "response": "def __addLocationsToURL(self, locations):\n        \"\"\"Format all locations to GitHub's URL API.\n\n        :param locations: locations where to search users.\n        :type locations: list(str).\n        \"\"\"\n        for l in self.__locations:\n            self.__urlLocations += \"+location:\\\"\"\\\n             + str(quote(l)) + \"\\\"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __launchThreads(self, numThreads):\n        i = 0\n        while i < numThreads:\n            self.__logger.debug(\"Launching thread number \" +\n                                str(i))\n            i += 1\n            newThr = Thread(target=self.__processUsers)\n            newThr.setDaemon(True)\n            self.__threads.add(newThr)\n            newThr.start()", "response": "Launch some threads and start to process users."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a petition to the GitHub API.", "response": "def __readAPI(self, url):\n        \"\"\"Read a petition to the GitHub API (private).\n\n        :param url: URL to query.\n        :type url: str.\n        :return: the response of the API -a dictionary with\n            these fields-:\n            * total_count (int): number of total\n            users that match with the search\n            * incomplete_results (bool):\n            https://developer.github.com/v3/search/#timeouts-and-incomplete-results\n            * items (List[dict]): a list with the\n            users that match with the search\n        :rtype: dict.\n        \"\"\"\n        code = 0\n        hdr = {'User-Agent': 'curl/7.43.0 (x86_64-ubuntu) \\\n               libcurl/7.43.0 OpenSSL/1.0.1k zlib/1.2.8 gh-rankings-grx',\n               'Accept': 'application/vnd.github.v3.text-match+json',\n               'Accept-Encoding': 'gzip'}\n        while code != 200:\n            req = Request(url, headers=hdr)\n            try:\n                self.__logger.debug(\"Getting \" + url)\n                response = urlopen(req)\n                code = response.code\n            except HTTPError as error:\n                if error.code == 404:\n                    self.__logger.exception(\"_readAPI: ERROR 404\")\n                    self.__logger.exception(str(error))\n                    break\n                headers = error.headers.items()\n                reset = -1\n                for header in headers:\n                    if header[0] == \"X-RateLimit-Reset\":\n                        reset = int(header[1])\n                if reset < 0:\n                    log_message = \"Error when reading response. Wait: 30 secs\"\n                    sleep_duration = 30\n                else:\n                    utcAux = datetime.datetime.utcnow()\n                    utcAux = utcAux.utctimetuple()\n                    now_sec = timegm(utcAux)\n                    sleep_duration = reset - now_sec\n                    log_message = \"Limit of API. Wait: \"\n                    log_message += str(sleep_duration)\n                    log_message += \" secs\"\n                self.__logger.warning(log_message)\n                sleep(sleep_duration)\n                code = 0\n            except URLError as error:\n                self.__logger.exception(str(error))\n                self.__logger.exception(\"_readAPI: waiting 15 secs\")\n                sleep(15)\n        responseBody = response.read()\n\n        if response.getheader('Content-Encoding') == 'gzip':\n            with GzipFile(fileobj=BytesIO(responseBody)) as gzFile:\n                responseBody = gzFile.read()\n\n        data = loads(responseBody.decode('utf-8'))\n        response.close()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __getURL(self, page=1, start_date=None,\n                 final_date=None, order=\"asc\"):\n        \"\"\"Get the API's URL to query to get data about users.\n\n        :param page: number of the page.\n        :param start_date: start date of the range to search\n            users (Y-m-d).\n        \"param final_date: final date of the range to search\n            users (Y-m-d).\n        :param order: order of the query. Valid values are\n            'asc' or 'desc'. Default: asc\n        :return: formatted URL.\n        :rtype: str.\n        \"\"\"\n        if not start_date or not final_date:\n            url = self.__server + \"search/users?client_id=\" + \\\n                self.__githubID + \"&client_secret=\" + \\\n                self.__githubSecret + \\\n                \"&order=desc&q=sort:joined+type:user\" + \\\n                self.__urlLocations + \\\n                self.__urlFilters + \\\n                \"&sort=joined&order=asc&per_page=100&page=\" + \\\n                str(page)\n        else:\n            url = self.__server + \"search/users?client_id=\" + \\\n                self.__githubID + \"&client_secret=\" + \\\n                self.__githubSecret + \\\n                \"&order=desc&q=sort:joined+type:user\" + \\\n                self.__urlLocations + \\\n                self.__urlFilters + \\\n                \"+created:\" + \\\n                start_date + \"..\" + final_date + \\\n                \"&sort=joined&order=\" + order + \\\n                \"&per_page=100&page=\" + str(page)\n        return url", "response": "Get the API s URL to query to get data about users."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mentions(self):\n        if self._mentions is None:\n            self._mentions = []\n            for mention_element in self._element.xpath('mention'):\n                this_mention = Mention(self, mention_element)\n                self._mentions.append(this_mention)\n                if this_mention.representative:\n                    self._representative = this_mention\n        return self._mentions", "response": "Returns a list of Mention objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the sentence related to this mention", "response": "def sentence(self):\n        \"\"\"\n        The sentence related to this mention\n\n        :getter: returns the sentence this mention relates to\n        :type: corenlp_xml.document.Sentence\n\n        \"\"\"\n        if self._sentence is None:\n            sentences = self._element.xpath('sentence/text()')\n            if len(sentences) > 0:\n                self._sentence = self._coref.document.get_sentence_by_id(int(sentences[0]))\n        return self._sentence"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef head(self):\n        if self._head is None:\n            self._head = self.sentence.tokens[self._head_id-1]\n        return self._head", "response": "Returns the token serving as the head of the mention"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enbase64(byte_str):\n\n    # Python 3: base64.b64encode() expects type byte\n    if isinstance(byte_str, str) and not PYTHON2:\n        byte_str = bytes(byte_str, 'utf-8')\n    return base64.b64encode(byte_str)", "response": "Encode bytes or strings to base64."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef debase64(byte_str):\n    # Python 3: base64.b64decode() expects type byte\n    if isinstance(byte_str, str) and not PYTHON2:\n        byte_str = bytes(byte_str, 'utf-8')\n    return base64.b64decode(byte_str)", "response": "Decode base64 encoded bytes or strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a random password hash for a set of logins.", "response": "def generate_password_hash(password, salt, N=1 << 14, r=8, p=1, buflen=64):\n    \"\"\"\n    Generate password hash givin the password string and salt.\n\n    Args:\n        - ``password``: Password string.\n        - ``salt`` : Random base64 encoded string.\n\n    Optional args:\n        - ``N`` : the CPU cost, must be a power of 2 greater than 1, defaults to 1 << 14.\n        - ``r`` : the memory cost, defaults to 8.\n        - ``p`` : the parallelization parameter, defaults to 1.\n\n    The parameters r, p, and buflen must satisfy r * p < 2^30 and\n    buflen <= (2^32 - 1) * 32.\n\n    The recommended parameters for interactive logins as of 2009 are N=16384,\n    r=8, p=1. Remember to use a good random salt.\n\n    Returns:\n        - base64 encoded scrypt hash.\n    \"\"\"\n    if PYTHON2:\n        password = password.encode('utf-8')\n        salt = salt.encode('utf-8')\n    pw_hash = scrypt_hash(password, salt, N, r, p, buflen)\n    return enbase64(pw_hash)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a password, hash, salt this function verifies the password is equal to hash/salt. Args: - ``password``: The password to perform check on. Returns: - ``bool``", "response": "def check_password_hash(password, password_hash, salt, N=1 << 14, r=8, p=1, buflen=64):\n    \"\"\"\n    Given a password, hash, salt this function verifies the password is equal to hash/salt.\n\n    Args:\n       - ``password``: The password to perform check on.\n\n    Returns:\n       - ``bool``\n    \"\"\"\n    candidate_hash = generate_password_hash(password, salt, N, r, p, buflen)\n\n    return safe_str_cmp(password_hash, candidate_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a MOC to an ASCII file.", "response": "def write_moc_ascii(moc, filename=None, file=None):\n    \"\"\"Write a MOC to an ASCII file.\n\n    Either a filename, or an open file object can be specified.\n    \"\"\"\n\n    orders = []\n\n    for (order, cells) in moc:\n        ranges = []\n        rmin = rmax = None\n\n        for cell in sorted(cells):\n            if rmin is None:\n                rmin = rmax = cell\n            elif rmax == cell - 1:\n                rmax = cell\n            else:\n                ranges.append(_format_range(rmin, rmax))\n                rmin = rmax = cell\n\n        ranges.append(_format_range(rmin, rmax))\n\n        orders.append('{0}'.format(order) + '/' + ','.join(ranges))\n\n    if file is not None:\n        _write_ascii(orders, file)\n    else:\n        with open(filename, 'w') as f:\n            _write_ascii(orders, f)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread from an ASCII file into a MOC.", "response": "def read_moc_ascii(moc, filename=None, file=None):\n    \"\"\"Read from an ASCII file into a MOC.\n\n    Either a filename, or an open file object can be specified.\n    \"\"\"\n\n    if file is not None:\n        orders = _read_ascii(file)\n    else:\n        with open(filename, 'r') as f:\n            orders = _read_ascii(f)\n\n    for text in orders:\n        if not text:\n            continue\n\n        cells = []\n        (order, ranges) = text.split('/')\n        for r in ranges.split(','):\n            try:\n                cells.append(int(r))\n            except ValueError as e:\n                (rmin, rmax) = r.split('-')\n                cells.extend(range(int(rmin), int(rmax) + 1))\n\n        moc.add(order, cells)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef emit(self, record):\n\n        if bool(self.store_only):\n            do_not_store = True\n            for extra in self.store_only:\n                if bool(getattr(record, extra, None)):\n                    do_not_store = False\n                    break\n\n            if do_not_store:\n                return\n\n        self.db = sqlite3.connect(self.filename)\n\n        self.db.execute(\n            \"\"\"\n                INSERT INTO log(\n                    log_level,\n                    log_level_name,\n\n                    name,\n                    message,\n                    args,\n\n                    module,\n                    func_name,\n                    line_no,\n                    filename,\n\n                    exception,\n                    process,\n                    thread,\n                    thread_name,\n\n                    siteconfig\n                )\n                VALUES(\n                    ?,?,\n                    ?,?,?,\n                    ?,?,?,?,\n                    ?,?,?,?,\n                    ?\n                );\"\"\",\n            (\n                record.levelno,\n                record.levelname,\n\n                record.name,\n                record.msg,\n                json.dumps(record.args, cls=OrderedEncoder),\n\n                record.module,\n                record.funcName,\n                record.lineno,\n                os.path.abspath(record.filename),\n\n                record.exc_text,\n                record.process,\n                record.thread,\n                record.threadName,\n\n                getattr(record, 'siteconfig', None),\n            )\n        )\n        self.db.commit()\n        self.db.close()", "response": "Handle the logging call."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecorating a function by optimizing it for iterator recursion.", "response": "def recursive_iterator(func):\n    \"\"\"Decorates a function by optimizing it for iterator recursion.\n    Requires function arguments to be pickleable.\"\"\"\n    tee_store = {}\n    @_coconut.functools.wraps(func)\n    def recursive_iterator_func(*args, **kwargs):\n        hashable_args_kwargs = _coconut.pickle.dumps((args, kwargs), _coconut.pickle.HIGHEST_PROTOCOL)\n        try:\n            to_tee = tee_store[hashable_args_kwargs]\n        except _coconut.KeyError:\n            to_tee = func(*args, **kwargs)\n        tee_store[hashable_args_kwargs], to_return = _coconut_tee(to_tee)\n        return to_return\n    return recursive_iterator_func"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addpattern(base_func):\n    def pattern_adder(func):\n        @_coconut.functools.wraps(func)\n        @_coconut_tco\n        def add_pattern_func(*args, **kwargs):\n            try:\n                return base_func(*args, **kwargs)\n            except _coconut_MatchError:\n                raise _coconut_tail_call(func, *args, **kwargs)\n        return add_pattern_func\n    return pattern_adder", "response": "Decorator to add a new case to a pattern - matching function where the new case is checked last."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fmap(func, obj):\n    if _coconut.hasattr(obj, \"__fmap__\"):\n        return obj.__fmap__(func)\n    args = _coconut_map(func, obj)\n    if _coconut.isinstance(obj, _coconut.dict):\n        args = _coconut_zip(args, obj.values())\n    if _coconut.isinstance(obj, _coconut.tuple) and _coconut.hasattr(obj, \"_make\"):\n        return obj._make(args)\n    if _coconut.isinstance(obj, (_coconut.map, _coconut.range)):\n        return args\n    if _coconut.isinstance(obj, _coconut.str):\n        return \"\".join(args)\n    return obj.__class__(args)", "response": "Creates a copy of obj with func applied to its contents."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the index of elem in the reversed iterator.", "response": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the index of elem in the count.", "response": "def index(self, elem):\n        \"\"\"Find the index of elem in the count.\"\"\"\n        if elem not in self:\n            raise _coconut.ValueError(_coconut.repr(elem) + \" is not in count\")\n        return (elem - self._start) // self._step"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nnormalizes the path component according to RFC 3986.", "response": "def normalize_uri_path_component(path_component):\n    \"\"\"\n    normalize_uri_path_component(path_component) -> str\n\n    Normalize the path component according to RFC 3986.  This performs the\n    following operations:\n    * Alpha, digit, and the symbols '-', '.', '_', and '~' (unreserved\n      characters) are left alone.\n    * Characters outside this range are percent-encoded.\n    * Percent-encoded values are upper-cased ('%2a' becomes '%2A')\n    * Percent-encoded values in the unreserved space (%41-%5A, %61-%7A,\n      %30-%39, %2D, %2E, %5F, %7E) are converted to normal characters.\n\n    If a percent encoding is incomplete, the percent is encoded as %25.\n\n    A ValueError exception is thrown if a percent encoding includes non-hex\n    characters (e.g. %3z).\n    \"\"\"\n    result = BytesIO()\n\n    i = 0\n    path_component = path_component.encode(\"utf-8\")\n    while i < len(path_component):\n        c = indexbytes(path_component, i)\n        if c in _rfc3986_unreserved:\n            result.write(int2byte(c))\n            i += 1\n        elif c == _ascii_percent: # percent, '%', 0x25, 37\n            if i + 2 >= len(path_component):\n                result.write(b\"%25\")\n                i += 1\n                continue\n            try:\n                value = int(path_component[i+1:i+3], 16)\n            except ValueError:\n                raise ValueError(\"Invalid %% encoding at position %d\" % i)\n            \n            if value in _rfc3986_unreserved:\n                result.write(int2byte(value))\n            else:\n                result.write(b\"%%%02X\" % value)\n            \n            i += 3\n        elif c == _ascii_plus:\n            # Plus-encoded space.  Convert this to %20.\n            result.write(b\"%20\")\n            i += 1\n        else:\n            result.write(b\"%%%02X\" % c)\n            i += 1\n    \n    result = result.getvalue()\n    if not isinstance(result, string_types):\n        result = str(result, \"utf-8\")\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a canonicalized version of the given URI path.", "response": "def get_canonical_uri_path(uri_path):\n    \"\"\"\n    get_canonical_uri_path(uri_path) -> str\n\n    Normalizes the specified URI path component, removing redundant slashes\n    and relative path components.\n\n    A ValueError exception is raised if:\n    * The URI path is not empty and not absolute (does not start with '/').\n    * A parent relative path element ('..') attempts to go beyond the top.\n    * An invalid percent-encoding is encountered.\n    \"\"\"\n    # Special case: empty path is converted to '/'\n    if uri_path == \"\" or uri_path == \"/\":\n        return \"/\"\n\n    # All other paths must be absolute.\n    if not uri_path.startswith(\"/\"):\n        raise ValueError(\"URI path is not absolute.\")\n\n    # Replace double slashes; this makes it easier to handle slashes at the\n    # end.\n    uri_path = _multislash.sub(\"/\", uri_path)\n    \n    # Examine each path component for relative directories.\n    components = uri_path.split(\"/\")[1:]\n    i = 0\n    while i < len(components):\n        # Fix % encodings.\n        component = normalize_uri_path_component(components[i])\n        components[i] = component\n        \n        if components[i] == \".\":\n            # Relative current directory.  Remove this.\n            del components[i]\n\n            # Don't increment i; with the deletion, we're now pointing to\n            # the next element in the path.\n        elif components[i] == \"..\":\n            # Relative path: parent directory.  Remove this and the previous\n            # component.\n            if i == 0:\n                # Not allowed at the beginning!\n                raise ValueError(\"URI path attempts to go beyond root\")\n            del components[i-1:i+1]\n\n            # Since we've deleted two components, we need to back up one to\n            # examine what's now the next component.\n            i -= 1\n        else:\n            # Leave it alone; proceed to the next component.\n            i += 1\n    \n    return \"/\" + \"/\".join(components)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnormalize a query string into a dictionary mapping parameter names to sorted values.", "response": "def normalize_query_parameters(query_string):\n    \"\"\"\n    normalize_query_parameters(query_string) -> dict\n\n    Converts a query string into a dictionary mapping parameter names to a\n    list of the sorted values.  This ensurses that the query string follows\n    % encoding rules according to RFC 3986 and checks for duplicate keys.\n\n    A ValueError exception is raised if a percent encoding is invalid.\n    \"\"\"\n    if query_string == \"\":\n        return {}\n\n    components = query_string.split(\"&\")\n    result = {}\n\n    for component in components:\n        try:\n            key, value = component.split(\"=\", 1)\n        except ValueError:\n            key = component\n            value = \"\"\n\n        if component == \"\":\n            # Empty component; skip it.\n            continue\n        \n        key = normalize_uri_path_component(key)\n        value = normalize_uri_path_component(value)\n\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n\n    return dict([(key, sorted(values))\n                 for key, values in iteritems(result)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the canonical query string from the query parameters.", "response": "def canonical_query_string(self):\n        \"\"\"\n        The canonical query string from the query parameters.\n\n        This takes the query string from the request and orders the parameters\n        in \n        \"\"\"\n        results = []\n        for key, values in iteritems(self.query_parameters):\n            # Don't include the signature itself.\n            if key == _x_amz_signature:\n                continue\n            \n            for value in values:\n                results.append(\"%s=%s\" % (key, value))\n\n        return \"&\".join(sorted(results))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authorization_header_parameters(self):\n        result = getattr(self, \"_authorization_header_parameters\", None)\n        if result is None:\n            auth = self.headers.get(_authorization)\n            if auth is None:\n                raise AttributeError(\"Authorization header is not present\")\n            \n            if not auth.startswith(AWS4_HMAC_SHA256 + \" \"):\n                raise AttributeError(\"Authorization header is not AWS SigV4\")\n\n            result = {}\n            for parameter in auth[len(AWS4_HMAC_SHA256)+1:].split(\",\"):\n                parameter = parameter.strip()\n                try:\n                    key, value = parameter.split(\"=\", 1)\n                except ValueError:\n                    raise AttributeError(\n                        \"Invalid Authorization header: missing '='\")\n\n                if key in result:\n                    raise AttributeError(\n                        \"Invalid Authorization header: duplicate key %r\" % key)\n                \n                result[key] = value\n            \n            self._authorization_header_parameters = result\n        return result", "response": "Returns the parameters from the Authorization header."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary containing the signed header names and values.", "response": "def signed_headers(self):\n        \"\"\"\n        An ordered dictionary containing the signed header names and values.\n        \"\"\"\n        # See if the signed headers are listed in the query string\n        signed_headers = self.query_parameters.get(_x_amz_signedheaders)\n        if signed_headers is not None:\n            signed_headers = url_unquote(signed_headers[0])\n        else:\n            # Get this from the authentication header\n            signed_headers = self.authorization_header_parameters[\n                _signedheaders]\n\n        # Header names are separated by semicolons.\n        parts = signed_headers.split(\";\")\n\n        # Make sure the signed headers list is canonicalized.  For security\n        # reasons, we consider it an error if it isn't.\n        canonicalized = sorted([sh.lower() for sh in parts])\n        if parts != canonicalized:\n            raise AttributeError(\"SignedHeaders is not canonicalized: %r\" %\n                                 (signed_headers,))\n\n        # Allow iteration in-order.\n        return OrderedDict([(header, self.headers[header])\n                            for header in signed_headers.split(\";\")])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the timestamp of the request in ISO8601 YYYYMMDDTHHMMSSZ format.", "response": "def request_timestamp(self):\n        \"\"\"\n        The timestamp of the request in ISO8601 YYYYMMDD'T'HHMMSS'Z' format.\n\n        If this is not available in the query parameters or headers, or the\n        value is not a valid format for AWS SigV4, an AttributeError exception\n        is raised.\n        \"\"\"\n        amz_date = self.query_parameters.get(_x_amz_date)\n        if amz_date is not None:\n            amz_date = amz_date[0]\n        else:\n            amz_date = self.headers.get(_x_amz_date)\n            if amz_date is None:\n                date = self.headers.get(_date)\n                if date is None:\n                    raise AttributeError(\"Date was not passed in the request\")\n\n                # This isn't really valid -- seems to be a bug in the AWS\n                # documentation.\n                if _iso8601_timestamp_regex.match(date):\n                    amz_date = date # pragma: nocover\n                else:\n                    # Parse this as an HTTP date and reformulate it.\n                    amz_date = (datetime.strptime(date, _http_date_format)\n                                .strftime(\"%Y%m%dT%H%M%SZ\"))\n        if not _iso8601_timestamp_regex.match(amz_date):\n            raise AttributeError(\"X-Amz-Date parameter is not a valid ISO8601 \"\n                                 \"string: %r\" % amz_date)\n\n        return amz_date"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef access_key(self):\n        credential = self.query_parameters.get(_x_amz_credential)\n        if credential is not None:\n            credential = url_unquote(credential[0])\n        else:\n            credential = self.authorization_header_parameters.get(_credential)\n\n            if credential is None:\n                raise AttributeError(\"Credential was not passed in the request\")\n        try:\n            key, scope = credential.split(\"/\", 1)\n        except ValueError:\n            raise AttributeError(\"Invalid request credential: %r\" % credential)\n\n        if scope != self.credential_scope:\n            raise AttributeError(\"Incorrect credential scope: %r (wanted %r)\" %\n                                 (scope, self.credential_scope))\n\n        return key", "response": "Returns the access key used to sign the request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef request_signature(self):\n        signature = self.query_parameters.get(_x_amz_signature)\n        if signature is not None:\n            signature = signature[0]\n        else:\n            signature = self.authorization_header_parameters.get(_signature)\n            if signature is None:\n                raise AttributeError(\"Signature was not passed in the request\")\n            \n        return signature", "response": "Returns the signature passed in the request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef canonical_request(self):\n        signed_headers = self.signed_headers\n        header_lines = \"\".join(\n            [\"%s:%s\\n\" % item for item in iteritems(signed_headers)])\n        header_keys = \";\".join([key for key in iterkeys(self.signed_headers)])\n        \n        return (self.request_method + \"\\n\" +\n                self.canonical_uri_path + \"\\n\" +\n                self.canonical_query_string + \"\\n\" +\n                header_lines + \"\\n\" +\n                header_keys + \"\\n\" +\n                sha256(self.body).hexdigest())", "response": "Returns the AWS SigV4 canonical request given parameters from an HTTP request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef string_to_sign(self):\n        return (AWS4_HMAC_SHA256 + \"\\n\" +\n                self.request_timestamp + \"\\n\" +\n                self.credential_scope + \"\\n\" +\n                sha256(self.canonical_request.encode(\"utf-8\")).hexdigest())", "response": "Returns the string that is used to sign this request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expected_signature(self):\n        k_secret = b\"AWS4\" + self.key_mapping[self.access_key].encode(\"utf-8\")\n        k_date = hmac.new(k_secret, self.request_date.encode(\"utf-8\"),\n                          sha256).digest()\n        k_region = hmac.new(k_date, self.region.encode(\"utf-8\"),\n                            sha256).digest()\n        k_service = hmac.new(k_region, self.service.encode(\"utf-8\"),\n                             sha256).digest()\n        k_signing = hmac.new(k_service, _aws4_request_bytes, sha256).digest()\n\n        return hmac.new(k_signing, self.string_to_sign.encode(\"utf-8\"),\n                        sha256).hexdigest()", "response": "The AWS SigV4 signature expected from the request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify(self):\n        try:\n            if self.timestamp_mismatch is not None:\n                m = _iso8601_timestamp_regex.match(self.request_timestamp)\n                year = int(m.group(\"year\"))\n                month = int(m.group(\"month\"))\n                day = int(m.group(\"day\"))\n                hour = int(m.group(\"hour\"))\n                minute = int(m.group(\"minute\"))\n                second = int(m.group(\"second\"))\n\n                req_ts = datetime(year, month, day, hour, minute, second)\n                now = datetime.utcnow()\n\n                if abs(req_ts - now) > timedelta(0, self.timestamp_mismatch):\n                    raise InvalidSignatureError(\"Timestamp mismatch\")\n\n            if self.expected_signature != self.request_signature:\n                raise InvalidSignatureError(\n                    \"Signature mismatch: expected %r, got %r\" % (\n                        self.expected_signature, self.request_signature))\n        except (AttributeError, KeyError, ValueError) as e:\n            raise InvalidSignatureError(str(e))\n\n        return True", "response": "Verifies that the request timestamp is not beyond our allowable\n        timestamp mismatch and that the request signature matches our expectations."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getTauLeibniz(n):\n    myTau = tauGenLeibniz()\n    result = []\n    if n > 0:\n        result += [next(myTau) for i in range(n)]\n    myTau.close()\n    return result", "response": "Returns a list containing first n digits of Pi\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef moothedata(data, key=None):\n    if not key:\n        key = choice(list(data.keys()))\n        logger.debug(\"Using randomly chosen key: %s\", key)\n    msg = cow.Moose().milk(\"{0}: {1}\".format(key.capitalize(), data[key]))\n    return msg", "response": "Return an amusing picture containing an item from a dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeprecate method to get a resource collection response. Please use get_collection", "response": "def resource_collection_response(cls, offset=0, limit=20):\n        \"\"\"\n        This method is deprecated for version 1.1.0.  Please use get_collection\n        \"\"\"\n        request_args = {'page[offset]': offset, 'page[limit]': limit}\n        return cls.get_collection(request_args)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_relationship(cls, request_args, id, related_collection_name, related_resource=None):\n        try:\n            included = request_args.get('include').split(',')\n        except (SyntaxError, AttributeError):\n            included = []\n        try:\n            offset = request_args.get('page[offset]', 0)\n            limit = request_args.get('page[limit]', 20)\n            this_resource = cls.nodes.get(id=id, active=True)\n            if not related_resource:\n                if request_args.get('include'):\n                    r = application_codes.error_response([application_codes.PARAMETER_NOT_SUPPORTED_VIOLATION])\n                else:\n                    r = this_resource.relationship_collection_response(related_collection_name, offset, limit)\n            else:  # deprecated for version 1.1.0\n                r = this_resource.individual_relationship_response(related_collection_name, related_resource, included)\n\n        except DoesNotExist:\n            r = application_codes.error_response([application_codes.RESOURCE_NOT_FOUND])\n        return r", "response": "Get a relationship from a node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disconnect_relationship(cls, id, related_collection_name, request_json):\n        try:\n            this_resource = cls.nodes.get(id=id, active=True)\n            related_collection = getattr(this_resource, related_collection_name)\n            rsrc_identifier_list = request_json['data']\n            if not isinstance(rsrc_identifier_list, list):\n                raise WrongTypeError\n\n            for rsrc_identifier in rsrc_identifier_list:\n                connected_resource = cls.get_class_from_type(rsrc_identifier['type']).nodes.get(\n                    id=rsrc_identifier['id']\n                )\n                related_collection.disconnect(connected_resource)\n            r = make_response('')\n            r.status_code = http_error_codes.NO_CONTENT\n            r.headers['Content-Type'] = CONTENT_TYPE\n        except DoesNotExist:\n            r = application_codes.error_response([application_codes.RESOURCE_NOT_FOUND])\n        except (KeyError, WrongTypeError):\n            r = application_codes.error_response([application_codes.BAD_FORMAT_VIOLATION])\n        return r", "response": "Disconnect one or more relationships in a collection with cardinality Many."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_relationship(cls, id, related_collection_name, related_resource=None):\n        try:\n            this_resource = cls.nodes.get(id=id, active=True)\n            if not related_resource:\n                r = this_resource.delete_relationship_collection(related_collection_name)\n            else:\n                r = this_resource.delete_individual_relationship(related_collection_name, related_resource)\n        except DoesNotExist:\n            r = application_codes.error_response([application_codes.RESOURCE_NOT_FOUND])\n        return r", "response": "Deprecated for version 1. 0. Please use update_relationship\n "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_relationship(cls, id, related_collection_name, request_json):\n        try:\n            this_resource = cls.nodes.get(id=id, active=True)\n            related_collection = getattr(this_resource, related_collection_name)\n            data = request_json['data']\n\n            if type(related_collection) in (One, ZeroOrOne):  # Cardinality <= 1 so is a single obj\n                if not data and related_collection.single():  # disconnect the resource\n                    related_collection.disconnect(related_collection.single())\n                elif not data:\n                    pass  # There is already no connected resource\n                else:\n                    the_new_node = cls.get_class_from_type(data['type']).nodes.get(id=data['id'])\n                    if related_collection.single():  # update the relationship\n                        related_collection.reconnect(related_collection.single(), the_new_node)\n                        the_rel = eval('related_collection.relationship(the_new_node)'.format(\n                            start_node=this_resource, relname=related_collection_name)\n                        )\n                        meta = data.get('meta')\n                        if meta:\n                            for k in meta.keys():\n                                setattr(the_rel, k, meta[k])\n                        the_rel.save()\n\n                    else:  # create the relationship\n                        related_collection.connect(the_new_node, data.get('meta'))\n\n            else:  # Cardinality > 1 so this is a collection of objects\n                old_nodes = related_collection.all()\n                for item in old_nodes:  # removes all old connections\n                    related_collection.disconnect(item)\n                for identifier in data:  # adds all new connections\n                    the_new_node = cls.get_class_from_type(identifier['type']).nodes.get(id=identifier['id'])\n                    the_rel = related_collection.connect(the_new_node)\n                    meta = identifier.get('meta')\n                    if meta:\n                        for k in meta.keys():\n                            setattr(the_rel, k, meta[k])\n                    the_rel.save()\n\n            r = make_response('')\n            r.status_code = http_error_codes.NO_CONTENT\n            r.headers['Content-Type'] = CONTENT_TYPE\n\n        except DoesNotExist:\n            r = application_codes.error_response([application_codes.RESOURCE_NOT_FOUND])\n        except (KeyError, TypeError):\n            r = application_codes.error_response([application_codes.BAD_FORMAT_VIOLATION])\n        except AttemptedCardinalityViolation:\n            r = application_codes.error_response([application_codes.ATTEMPTED_CARDINALITY_VIOLATION])\n        except MultipleNodesReturned:\n            r = application_codes.error_response([application_codes.MULTIPLE_NODES_WITH_ID_VIOLATION])\n        return r", "response": "r Updates the relationship between two nodes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a StopWord object initialized with the stop words collection for the requested language.", "response": "def get_stop_words(self, language, fail_safe=False):\n        \"\"\"\n        Returns a StopWord object initialized with the stop words collection\n        requested by ``language``.\n        If the requested language is not available a StopWordError is raised.\n        If ``fail_safe`` is set to True, an empty StopWord object is returned.\n        \"\"\"\n        try:\n            language = self.language_codes[language]\n        except KeyError:\n            pass\n\n        collection = self.LOADED_LANGUAGES_CACHE.get(language)\n\n        if collection is None:\n            try:\n                collection = self._get_stop_words(language)\n                self.LOADED_LANGUAGES_CACHE[language] = collection\n            except StopWordError as error:\n                if not fail_safe:\n                    raise error\n                collection = []\n\n        stop_words = StopWord(language, collection)\n        return stop_words"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef available_languages(self):\n        available_languages = getattr(self, '_available_languages', None)\n        if available_languages:\n            return available_languages\n        try:\n            languages = os.listdir(self.data_directory)\n        except OSError:\n            raise StopWordError(\n                \"'datas' directory is unreadable, check your installation.\")\n        languages = sorted(map(lambda x: x.replace('.txt', ''), languages))\n        setattr(self, '_available_languages', languages)\n        return languages", "response": "Returns a list of stop words that are available in the data directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_collection_filename(self, language):\n        filename = os.path.join(self.data_directory, '%s.txt' % language)\n        return filename", "response": "Returns the filename containing the stop words collection\n        for a specific language."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_collection(self, filename):\n        with open(filename, 'rb') as fd:\n            lines = fd.read().decode('utf-8-sig').splitlines()\n        collection = list(filter(bool, [line.strip() for line in lines]))\n        return collection", "response": "Reads and returns a collection of stop words into a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a collection of stop words into a file.", "response": "def write_collection(self, filename, collection):\n        \"\"\"\n        Writes a collection of stop words into a file.\n        \"\"\"\n        collection = sorted(list(collection))\n        with open(filename, 'wb+') as fd:\n            fd.truncate()\n            fd.write('\\n'.join(collection).encode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef startproject_command(context, basedir, sourcedir, targetdir,\n                         backend, config):\n    \"\"\"\n    Create a new Sass project\n\n    This will prompt you to define your project configuration in a settings\n    file then create needed directory structure.\n\n    Arguments 'basedir', 'config', 'sourcedir', 'targetdir' can not be empty.\n\n    'backend' argument is optionnal, its value can be \"json\" or \"yaml\" and its\n    default value is \"json\".\n\n    If \"backend\" is given and 'config' is empty, this will change the default\n    value for 'config' argument such as with \"json\" filename will be\n    \"settings.json\" and for \"yaml\" it will be \"settings.yml\".\n    \"\"\"\n    logger = logging.getLogger(\"boussole\")\n\n    starter = ProjectStarter(backend_name=backend)\n\n    # If not given, config file name is setted from backend default filename\n    if not config:\n        config = starter.backend_engine._default_filename\n\n    try:\n        results = starter.init(*(\n            basedir,\n            config,\n            sourcedir,\n            targetdir,\n        ), cwd=os.getcwd())\n    except SettingsInvalidError as e:\n        logger.critical(six.text_type(e))\n        raise click.Abort()\n    else:\n        logger.info(u\"Project directory structure and configuration file have \"\n                    \"been created.\")\n\n        logger.info(u\"Now you should start to create some Sass sources into \"\n                    \"'{}', then compile them \"\n                    \"using:\".format(results['sourcedir']))\n\n        logger.info(u\"    boussole compile \"\n                    \"--config={}\".format(results['config']))", "response": "Start a new Sass project"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(cls, graph, element):\n        node = graph.get_node_by_idx(id(element.get(\"idx\")))\n        if node is None:\n            node = cls(graph, element)\n            graph.register_node(node)\n        return node", "response": "Loads a node from the dependency graph if it s not already stored in the graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef governor(self, dep_type, node):\n        self._governors[dep_type] = self._governors.get(dep_type, []) + [node]\n        return self", "response": "Registers a node as governing this node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a node as dependent on this node", "response": "def dependent(self, dep_type, node):\n        \"\"\"\n        Registers a node as dependent on this node\n\n        :param dep_type: The dependency type\n        :type dep_type: str\n        :param node: The node to be registered as a dependent\n        :type node: corenlp_xml.dependencies.DependencyNode\n\n        :return: self, provides fluent interface\n        :rtype: corenlp_xml.dependencies.DependencyNode\n\n        \"\"\"\n        self._dependents[dep_type] = self._dependents.get(dep_type, []) + [node]\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the Governor node", "response": "def governor(self):\n        \"\"\"\n        Accesses the governor node\n\n        :getter: Returns the Governor node\n        :type: corenlp_xml.dependencies.DependencyNode\n\n        \"\"\"\n        if self._governor is None:\n            governors = self._element.xpath('governor')\n            if len(governors) > 0:\n                self._governor = DependencyNode.load(self._graph, governors[0])\n        return self._governor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dependent(self):\n        if self._dependent is None:\n            dependents = self._element.xpath('dependent')\n            if len(dependents) > 0:\n                self._dependent = DependencyNode.load(self._graph, dependents[0])\n        return self._dependent", "response": "Gets the Dependent node that contains this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strip_quotes(self, content):\n        error_msg = \"Following rule is badly quoted: {}\"\n        if (content.startswith('\"') and content.endswith('\"')) or \\\n           (content.startswith(\"'\") and content.endswith(\"'\")):\n            return content[1:-1]\n        # Quote starting but not ended\n        elif (content.startswith('\"') and not content.endswith('\"')) or \\\n             (content.startswith(\"'\") and not content.endswith(\"'\")):\n            raise InvalidImportRule(error_msg.format(content))\n        # Quote ending but not started\n        elif (not content.startswith('\"') and content.endswith('\"')) or \\\n             (not content.startswith(\"'\") and content.endswith(\"'\")):\n            raise InvalidImportRule(error_msg.format(content))\n\n        return content", "response": "Removes quotes from the given rule."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flatten_rules(self, declarations):\n        rules = []\n\n        for protocole, paths in declarations:\n            # If there is a protocole (like 'url), drop it\n            if protocole:\n                continue\n            # Unquote and possibly split multiple rule in the same declaration\n            rules.extend([self.strip_quotes(v.strip())\n                          for v in paths.split(',')])\n\n        return list(filter(self.filter_rules, rules))", "response": "Flatten imports rules from regex."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, content):\n        # Remove all comments before searching for import rules, to not catch\n        # commented breaked import rules\n        declarations = self.REGEX_IMPORT_RULE.findall(\n            self.remove_comments(content)\n        )\n        return self.flatten_rules(declarations)", "response": "Parse a stylesheet document with a regex to extract all import rules and return them."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntruing if naccess is available on the path.", "response": "def naccess_available():\n    \"\"\"True if naccess is available on the path.\"\"\"\n    available = False\n    try:\n        subprocess.check_output(['naccess'], stderr=subprocess.DEVNULL)\n    except subprocess.CalledProcessError:\n        available = True\n    except FileNotFoundError:\n        print(\"naccess has not been found on your path. If you have already \"\n              \"installed naccess but are unsure how to add it to your path, \"\n              \"check out this: https://stackoverflow.com/a/14638025\")\n    return available"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_naccess(pdb, mode, path=True, include_hetatms=False, outfile=None,\n                path_to_ex=None):\n    \"\"\"Uses naccess to run surface accessibility calculations.\n\n    Notes\n    -----\n    Requires the naccess program, with a path to its executable\n    provided in global_settings. For information on the Naccess program,\n    see: http://www.bioinf.manchester.ac.uk/naccess/\n    This includes information on the licensing, which is not free for\n    Industrial and Profit-making instituions.\n\n    Parameters\n    ----------\n    pdb : str\n        Path to pdb file or string.\n    mode : str\n        Return mode of naccess. One of 'asa', 'rsa' or 'log'.\n    path : bool, optional\n        Indicates if pdb is a path or a string.\n    outfile : str, optional\n        Filepath for storing the naccess output.\n    path_to_ex : str or None\n        Path to the binary for naccess, if none then it is assumed\n        that the binary is available on the path as `naccess`.\n\n    Returns\n    -------\n    naccess_out : str\n        naccess output file for given mode as a string.\n    \"\"\"\n    if mode not in ['asa', 'rsa', 'log']:\n        raise ValueError(\n            \"mode {} not valid. Must be \\'asa\\', \\'rsa\\' or \\'log\\'\"\n            .format(mode))\n    if path_to_ex:\n        naccess_exe = path_to_ex\n    else:\n        naccess_exe = 'naccess'\n\n    if not path:\n        if type(pdb) == str:\n            pdb = pdb.encode()\n    else:\n        with open(pdb, 'r') as inf:\n            pdb = inf.read().encode()\n\n    this_dir = os.getcwd()\n    # temp pdb file in temp dir.\n    temp_dir = tempfile.TemporaryDirectory()\n    temp_pdb = tempfile.NamedTemporaryFile(dir=temp_dir.name)\n    temp_pdb.write(pdb)\n    temp_pdb.seek(0)\n    # run naccess in the temp_dir. Files created will be written here.\n    os.chdir(temp_dir.name)\n\n    if include_hetatms:\n        naccess_args = '-h'\n        subprocess.check_output([naccess_exe, naccess_args, temp_pdb.name])\n    else:\n        subprocess.check_output([naccess_exe, temp_pdb.name])\n    temp_pdb.close()\n    with open('.{}'.format(mode), 'r') as inf:\n        naccess_out = inf.read()\n    # navigate back to initial directory and clean up.\n    os.chdir(this_dir)\n    if outfile:\n        with open(outfile, 'w') as inf:\n            inf.write(naccess_out)\n    temp_dir.cleanup()\n\n    return naccess_out", "response": "Uses naccess to run surface accessibility calculations on a given PDB file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_residue_accessibility(in_rsa, path=True, get_total=False):\n\n    if path:\n        with open(in_rsa, 'r') as inf:\n            rsa = inf.read()\n    else:\n        rsa = in_rsa[:]\n\n    residue_list = [x for x in rsa.splitlines()]\n    rel_solv_acc_all_atoms = [\n        float(x[22:28])\n        for x in residue_list\n        if x[0:3] == \"RES\" or x[0:3] == \"HEM\"]\n\n    if get_total:\n        (all_atoms, _, _, _, _) = total_accessibility(\n            rsa, path=False)\n        return rel_solv_acc_all_atoms, all_atoms\n    return rel_solv_acc_all_atoms, None", "response": "Parses the NACCESS rsa file and returns a list of solvent accessibility of all residues in each amino acid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the instance of webdriver it starts the browser", "response": "def selenium(self):\n        \"\"\"Get the instance of webdriver, it starts the browser if the\n        webdriver is not yet instantied\n\n        :return: a `selenium instance <http://selenium-python.readthedocs.org/\n        api.html#module-selenium.webdriver.remote.webdriver>`\n        \"\"\"\n        if not self._web_driver:\n            self._web_driver = self._start_driver()\n        return self._web_driver"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normalize(self):\n\t\ttotal = sum(self.values())\n\t\tstats = {k: (v / float(total)) for k, v in self.items()}\n\t\treturn StatsCounter(stats)", "response": "This function is used to normalize the values in a Counter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_weighted_random_value(self):\n\t\tfrom bisect import bisect\n\t\tfrom random import random\n\t\t#http://stackoverflow.com/questions/4437250/choose-list-variable-given-probability-of-each-variable\n\t\t\n\t\ttotal = sum(self.values())\n\t\t\n\t\tP = [(k, (v / float(total))) for k, v in self.items()]\n\t\t\n\t\tcdf = [P[0][1]]\n\t\tfor i in range(1, len(P)):\n\t\t\tcdf.append(cdf[-1] + P[i][1])\n\t\t\t\n\t\treturn P[bisect(cdf, random())][0]", "response": "This function generates a value from the dictionary and returns it with the weighted random number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef paths_by_depth(paths):\n    return sorted(\n            paths,\n            key=lambda path: path.count(os.path.sep),\n            reverse=True\n    )", "response": "Sort list of paths by number of directories in it\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_relative_from_paths(self, filepath, paths):\n        for systempath in paths_by_depth(paths):\n            if filepath.startswith(systempath):\n                return os.path.relpath(filepath, systempath)\n\n        raise FinderException(\"'Finder.get_relative_from_paths()' could not \"\n                              \"find filepath start from '{}'\".format(filepath))", "response": "Find the relative filepath from the most relevant multiple paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if a file is a Sass partial source.", "response": "def is_partial(self, filepath):\n        \"\"\"\n        Check if file is a Sass partial source (see\n        `Sass partials Reference`_).\n\n        Args:\n            filepath (str): A file path. Can be absolute, relative or just a\n            filename.\n\n        Returns:\n            bool: True if file is a partial source, else False.\n        \"\"\"\n        path, filename = os.path.split(filepath)\n        return filename.startswith('_')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if a given filepath is allowed for a given list of excludes patterns.", "response": "def is_allowed(self, filepath, excludes=[]):\n        \"\"\"\n        Check from exclude patterns if a relative filepath is allowed\n\n        Args:\n            filepath (str): A relative file path. (exclude patterns are\n                allways based from the source directory).\n\n        Keyword Arguments:\n            excludes (list): A list of excluding (glob) patterns. If filepath\n                matchs one of patterns, filepath is not allowed.\n\n        Raises:\n            boussole.exception.FinderException: If given filepath is absolute.\n\n        Returns:\n            str: Filepath with new extension.\n        \"\"\"\n        if os.path.isabs(filepath):\n            raise FinderException(\"'Finder.is_allowed()' only accept relative\"\n                                  \" filepath\")\n\n        if excludes:\n            for pattern in excludes:\n                if fnmatch.fnmatch(filepath, pattern):\n                    return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if a filepath matches all required conditions.", "response": "def match_conditions(self, filepath, sourcedir=None, nopartial=True,\n                         exclude_patterns=[], excluded_libdirs=[]):\n        \"\"\"\n        Find if a filepath match all required conditions.\n\n        Available conditions are (in order):\n\n        * Is allowed file extension;\n        * Is a partial source;\n        * Is from an excluded directory;\n        * Is matching an exclude pattern;\n\n        Args:\n            filepath (str): Absolute filepath to match against conditions.\n\n        Keyword Arguments:\n            sourcedir (str or None): Absolute sources directory path. Can be\n                ``None`` but then the exclude_patterns won't be matched against\n                (because this method require to distinguish source dir from lib\n                dirs).\n            nopartial (bool): Accept partial sources if ``False``. Default is\n                ``True`` (partial sources fail matchind condition). See\n                ``Finder.is_partial()``.\n            exclude_patterns (list): List of glob patterns, if filepath match\n                one these pattern, it wont match conditions. See\n                ``Finder.is_allowed()``.\n            excluded_libdirs (list): A list of directory to match against\n                filepath, if filepath starts with one them, it won't\n                match condtions.\n\n        Returns:\n            bool: ``True`` if match all conditions, else ``False``.\n        \"\"\"\n        # Ensure libdirs ends with / to avoid missmatching with\n        # 'startswith' usage\n        excluded_libdirs = [os.path.join(d, \"\") for d in excluded_libdirs]\n\n        # Match an filename extension admitted as compilable stylesheet\n        filename, ext = os.path.splitext(filepath)\n        ext = ext[1:]\n        if ext not in self.FINDER_STYLESHEET_EXTS:\n            return False\n\n        # Not a partial source\n        if nopartial and self.is_partial(filepath):\n            return False\n\n        # Not in an excluded directory\n        if any(\n            filepath.startswith(excluded_path)\n            for excluded_path in paths_by_depth(excluded_libdirs)\n        ):\n            return False\n\n        # Not matching an exclude pattern\n        if sourcedir and exclude_patterns:\n            candidates = [sourcedir]+excluded_libdirs\n            relative_path = self.get_relative_from_paths(filepath, candidates)\n            if not self.is_allowed(relative_path, excludes=exclude_patterns):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges the filename extension.", "response": "def change_extension(self, filepath, new_extension):\n        \"\"\"\n        Change final filename extension.\n\n        Args:\n            filepath (str): A file path (relative or absolute).\n            new_extension (str): New extension name (without leading dot) to\n                apply.\n\n        Returns:\n            str: Filepath with new extension.\n        \"\"\"\n        filename, ext = os.path.splitext(filepath)\n        return '.'.join([filename, new_extension])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the destination path from given source file path.", "response": "def get_destination(self, filepath, targetdir=None):\n        \"\"\"\n        Return destination path from given source file path.\n\n        Destination is allways a file with extension ``.css``.\n\n        Args:\n            filepath (str): A file path. The path is allways relative to\n                sources directory. If not relative, ``targetdir`` won't be\n                joined.\n            absolute (bool): If given will be added at beginning of file\n                path.\n\n        Returns:\n            str: Destination filepath.\n        \"\"\"\n        dst = self.change_extension(filepath, 'css')\n        if targetdir:\n            dst = os.path.join(targetdir, dst)\n        return dst"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compilable_sources(self, sourcedir, absolute=False, recursive=True,\n                           excludes=[]):\n        \"\"\"\n        Find all scss sources that should be compiled, aka all sources that\n        are not \"partials\" Sass sources.\n\n\n        Args:\n            sourcedir (str): Directory path to scan.\n\n        Keyword Arguments:\n            absolute (bool): Returned paths will be absolute using\n                ``sourcedir`` argument (if True), else return relative paths.\n            recursive (bool): Switch to enabled recursive finding (if True).\n                Default to True.\n            excludes (list): A list of excluding patterns (glob patterns).\n                Patterns are matched against the relative filepath (from its\n                sourcedir).\n\n        Returns:\n            list: List of source paths.\n        \"\"\"\n        filepaths = []\n\n        for root, dirs, files in os.walk(sourcedir):\n            # Sort structure to avoid arbitrary order\n            dirs.sort()\n            files.sort()\n            for item in files:\n                # Store relative directory but drop it if at root ('.')\n                relative_dir = os.path.relpath(root, sourcedir)\n                if relative_dir == '.':\n                    relative_dir = ''\n\n                # Matching all conditions\n                absolute_filepath = os.path.join(root, item)\n                conditions = {\n                    'sourcedir': sourcedir,\n                    'nopartial': True,\n                    'exclude_patterns': excludes,\n                    'excluded_libdirs': [],\n                }\n                if self.match_conditions(absolute_filepath, **conditions):\n                    relative_filepath = os.path.join(relative_dir, item)\n\n                    if absolute:\n                        filepath = absolute_filepath\n                    else:\n                        filepath = relative_filepath\n\n                    filepaths.append(filepath)\n\n            # For non recursive usage, break from the first entry\n            if not recursive:\n                break\n\n        return filepaths", "response": "Returns a list of source paths that should be compiled from the source directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mirror_sources(self, sourcedir, targetdir=None, recursive=True,\n                       excludes=[]):\n        \"\"\"\n        Mirroring compilable sources filepaths to their targets.\n\n        Args:\n            sourcedir (str): Directory path to scan.\n\n        Keyword Arguments:\n            absolute (bool): Returned paths will be absolute using\n                ``sourcedir`` argument (if True), else return relative paths.\n            recursive (bool): Switch to enabled recursive finding (if True).\n                Default to True.\n            excludes (list): A list of excluding patterns (glob patterns).\n                Patterns are matched against the relative filepath (from its\n                sourcedir).\n\n        Returns:\n            list: A list of pairs ``(source, target)``. Where ``target`` is the\n                ``source`` path but renamed with ``.css`` extension. Relative\n                directory from source dir is left unchanged but if given,\n                returned paths will be absolute (using ``sourcedir`` for\n                sources and ``targetdir`` for targets).\n        \"\"\"\n        sources = self.compilable_sources(\n            sourcedir,\n            absolute=False,\n            recursive=recursive,\n            excludes=excludes\n        )\n        maplist = []\n\n        for filepath in sources:\n            src = filepath\n            dst = self.get_destination(src, targetdir=targetdir)\n\n            # In absolute mode\n            if targetdir:\n                src = os.path.join(sourcedir, src)\n\n            maplist.append((src, dst))\n\n        return maplist", "response": "Mirroring compilable sources filepaths to their targets."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a new bundle version of files.", "response": "def add_bundle(self, data: dict) -> models.Bundle:\n        \"\"\"Build a new bundle version of files.\n\n        The format of the input dict is defined in the `schema` module.\n        \"\"\"\n        bundle_obj = self.bundle(data['name'])\n        if bundle_obj and self.version(bundle_obj.name, data['created']):\n            LOG.debug('version of bundle already added')\n            return None\n\n        if bundle_obj is None:\n            bundle_obj = self.new_bundle(name=data['name'], created_at=data['created'])\n\n        version_obj = self.new_version(created_at=data['created'], expires_at=data.get('expires'))\n\n        tag_names = set(tag_name for file_data in data['files'] for tag_name in file_data['tags'])\n        tag_map = self._build_tags(tag_names)\n\n        for file_data in data['files']:\n            LOG.debug(f\"adding file: {file_data['path']}\")\n            if not Path(file_data['path']).exists():\n                raise FileNotFoundError(file_data['path'])\n            tags = [tag_map[tag_name] for tag_name in file_data['tags']]\n            new_file = self.new_file(file_data['path'], to_archive=file_data['archive'], tags=tags)\n            version_obj.files.append(new_file)\n\n        version_obj.bundle = bundle_obj\n        return bundle_obj, version_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a list of tag objects.", "response": "def _build_tags(self, tag_names: List[str]) -> dict:\n        \"\"\"Build a list of tag objects.\"\"\"\n        tags = {}\n        for tag_name in tag_names:\n            tag_obj = self.tag(tag_name)\n            if tag_obj is None:\n                LOG.debug(f\"create new tag: {tag_name}\")\n                tag_obj = self.new_tag(tag_name)\n            tags[tag_name] = tag_obj\n        return tags"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_comment_commit(self, body, commit_id, path, position, pr_id):\n        comments_url = f\"{self.GITHUB_API_URL}/repos/{self.user}/{self.repo}/pulls/{pr_id}/comments\"\n        data = {'body': body, 'commit_id': commit_id, 'path': path, 'position': position}\n\n        return requests.post(comments_url, json=data, headers=self.auth_header)", "response": "Post a comment to a given commit at a certain pull request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_svg_transform(self, transform):\n\n        tr, args = transform[:-1].split('(')\n        a = map(float, args.split(' '))\n\n        # Handle various string tranformations\n        if tr == 'matrix':\n            pass\n        elif tr == 'translate':\n            a = [1.0, 0.0, 0.0, 1.0, a[0], a[1] if len(a) > 1 else 0.0]\n        elif tr == 'scale':\n            a = [a[0], 0.0, 0.0, a[-1], 0.0, 0.0]\n        elif tr == 'rotate':\n            x = a[1] if len(a) > 1 else 0.0\n            y = a[2] if len(a) > 1 else 0.0\n            rad = radians(a[0])\n            s = sin(rad)\n            c = cos(rad)\n            a = [\n                c,\n                s,\n                -s,\n                c,\n                x * (1 - c) + y * s,\n                -x * s + y * (1 - c),\n            ]\n        else:\n            raise ValueError('Unknown transformation \"%s\"' % transform)\n\n        self._svg_transform = transform\n        self._a00 = a[0]\n        self._a10 = a[1]\n        self._a01 = a[2]\n        self._a11 = a[3]\n        self._a02 = a[4]\n        self._a12 = a[5]", "response": "Converts a string representing a SVG transform into AffineTransform fields."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning prospector in the input files and returns a json with the analysis", "response": "def run(self):\n        \"\"\"\n        Runs prospector in the input files and returns a json with the analysis\n        \"\"\"\n        arg_prospector = f'prospector --output-format json {self.repo.diff_files()}'\n        analysis = subprocess.run(arg_prospector, stdout=subprocess.PIPE, shell=True)\n        return json.loads(analysis.stdout)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, operation, parameters=()):\n        __traceback_hide__ = True  # NOQ\n\n        # Time the exection of the query\n\n        start = time.time()\n        try:\n            return self.cursor.execute(operation, parameters)\n        finally:\n            end = time.time()\n\n            # Save the data\n            data = {\n                'name': operation,\n                'args': parameters,\n                'start': start,\n                'end': end,\n            }\n            self._record(data)", "response": "Wraps execute method to record the query execution duration and stackframe."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncollect user args and call command funct. Collect command line args and setup environment then call function for command specified in args.", "response": "def main():\n    \"\"\"Collect user args and call command funct.\n\n    Collect command line args and setup environment then call\n    function for command specified in args.\n\n    \"\"\"\n    parser = parser_setup()\n    options = parser.parse_args()\n\n    debug = bool(options.debug > 0)\n    debugall = bool(options.debug > 1)\n\n    awsc.init()\n    debg.init(debug, debugall)\n    print(C_NORM)\n\n    options.func(options)\n\n    sys.exit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a parser object to parse command line arguments.", "response": "def parser_setup():\n    \"\"\"Create ArgumentParser object to parse command line arguments.\n\n    Returns:\n        parser (object): containing ArgumentParser data and methods.\n    Raises:\n        SystemExit: if the user enters invalid args.\n\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Control AWS instances from\"\n                                     \" the command line with: list, start,\"\n                                     \" stop or ssh.\", prog='awss',\n                                     usage=\"\\tawss {command} [ 'NAME' ] \"\n                                     \"[ '-i ID' ] [ OPTIONS ]\\n\\t{command} =\"\n                                     \" list | start | stop | ssh\")\n    parser.add_argument('-v', '--version', action=\"version\",\n                        version=\"awss {0}\".format(__version__))\n\n    subparsers = parser.add_subparsers(title=\"For additional help on\"\n                                       \" command parameters\", dest='command',\n                                       description=\"type 'awss {command} -h',\"\n                                       \" where {command} is: list, start,\"\n                                       \" stop or ssh\")\n\n    # Parser for LIST command\n    parser_list = subparsers.add_parser('list', description=\"List AWS \"\n                                        \"instances from the command line. \"\n                                        \"'awss list' will list instances\"\n                                        \" specified using combinations of \"\n                                        \"NAME, instance-id and current-state.\"\n                                        \"  If no specifications are given, \"\n                                        \" all instances will be listed.\"\n                                        \"  ex: 'awss list TEST \"\n                                        \"-r' will list instances named 'TEST'\"\n                                        \" that are currently running.\",\n                                        usage=\"\\tawss list [none] [NAME] [-i \"\n                                        \"ID] [-r] [-s] [OPTIONS]\")\n    parser_list.add_argument('instname', nargs='?', metavar='NAME',\n                             help='specify instance by name')\n    parser_list.add_argument('-i', '--id', action=\"store\",\n                             help='specify instance by id')\n    parser_list.add_argument('-s', '--stopped', action='store_const',\n                             dest=\"inst_state\", const=\"stopped\",\n                             help='list stopped instances')\n    parser_list.add_argument('-r', '--running', action='store_const',\n                             dest=\"inst_state\", const=\"running\",\n                             help='list running instances')\n    parser_list.add_argument('-d', '--debug', action=\"count\",\n                             default=0, help=argparse.SUPPRESS)\n    parser_list.set_defaults(func=cmd_list)\n\n    # Parser for START command\n    parser_start = subparsers.add_parser('start', usage=\"\\tawss start [NAME]\"\n                                         \" [-i ID] [-h]\",\n                                         description=\"Start an AWS instance\"\n                                         \" from the command line.\")\n    parser_start.add_argument('instname', nargs='?', metavar='NAME',\n                              help='specify instance by name')\n    parser_start.add_argument('-i', '--id', action=\"store\",\n                              help='specify instance-id')\n    parser_start.add_argument('-d', '--debug', action=\"count\",\n                              default=0, help=argparse.SUPPRESS)\n    parser_start.set_defaults(func=cmd_startstop)\n\n    # Parser for STOP command\n    parser_stop = subparsers.add_parser('stop', usage=\"\\tawss stop [NAME]\"\n                                        \" [-i ID] [-h]\",\n                                        description=\"Stop an AWS instance\"\n                                        \" from the command line.\")\n    parser_stop.add_argument('instname', nargs='?', metavar='NAME',\n                             help='specify instance by name')\n    parser_stop.add_argument('-i', '--id', action=\"store\",\n                             help='specify instance-id')\n    parser_stop.add_argument('-d', '--debug', action=\"count\",\n                             default=0, help=argparse.SUPPRESS)\n    parser_stop.set_defaults(func=cmd_startstop)\n\n    # Parser for SSH command\n    parser_ssh = subparsers.add_parser('ssh', usage=\"\\tawss ssh [NAME]\"\n                                       \" [-i ID] [-u USER] [-p] [-h]\",\n                                       description=\"Connect to an AWS i\"\n                                       \"nstance via ssh.\")\n    parser_ssh.add_argument('instname', nargs='?', metavar='NAME',\n                            help='specify instance by name')\n    parser_ssh.add_argument('-i', '--id', action=\"store\",\n                            help='specify instance-id')\n    parser_ssh.add_argument('-u', '--user', action=\"store\",\n                            help='override default username for ssh')\n    parser_ssh.add_argument('-p', '--nopem', action=\"store_true\",\n                            default=False, help='connect without PEM key')\n    parser_ssh.add_argument('-d', '--debug', action=\"count\",\n                            default=0, help=argparse.SUPPRESS)\n    parser_ssh.set_defaults(func=cmd_ssh)\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_list(options):\n    (i_info, param_str) = gather_data(options)\n    if i_info:\n        awsc.get_all_aminames(i_info)\n        param_str = \"Instance List - \" + param_str + \"\\n\"\n        list_instances(i_info, param_str)\n    else:\n        print(\"No instances found with parameters: {}\".format(param_str))", "response": "List all the instances in the current node"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart or Stop the specified instance.", "response": "def cmd_startstop(options):\n    \"\"\"Start or Stop the specified instance.\n\n    Finds instances that match args and instance-state expected by the\n    command.  Then, the target instance is determined, the action is\n    performed on the instance, and the eturn information is displayed.\n\n    Args:\n        options (object): contains args and data from parser.\n\n    \"\"\"\n    statelu = {\"start\": \"stopped\", \"stop\": \"running\"}\n    options.inst_state = statelu[options.command]\n    debg.dprint(\"toggle set state: \", options.inst_state)\n    (i_info, param_str) = gather_data(options)\n    (tar_inst, tar_idx) = determine_inst(i_info, param_str, options.command)\n    response = awsc.startstop(tar_inst, options.command)\n    responselu = {\"start\": \"StartingInstances\", \"stop\": \"StoppingInstances\"}\n    filt = responselu[options.command]\n    resp = {}\n    state_term = ('CurrentState', 'PreviousState')\n    for i, j in enumerate(state_term):\n        resp[i] = response[\"{0}\".format(filt)][0][\"{0}\".format(j)]['Name']\n    print(\"Current State: {}{}{}  -  Previous State: {}{}{}\\n\".\n          format(C_STAT[resp[0]], resp[0], C_NORM,\n                 C_STAT[resp[1]], resp[1], C_NORM))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_ssh(options):\n    import os\n    import subprocess\n    from os.path import expanduser\n    options.inst_state = \"running\"\n    (i_info, param_str) = gather_data(options)\n    (tar_inst, tar_idx) = determine_inst(i_info, param_str, options.command)\n    home_dir = expanduser(\"~\")\n    if options.user is None:\n        tar_aminame = awsc.get_one_aminame(i_info[tar_idx]['ami'])\n        options.user = cmd_ssh_user(tar_aminame,\n                                    i_info[tar_idx]['tag']['Name'])\n    else:\n        debg.dprint(\"LoginUser set by user: \", options.user)\n    os_spec = {\"nt\": [\"powershell plink\", \"\\\\\", \"ppk\"]}\n    c_itm = os_spec.get(os.name, [\"ssh\", \"/\", \"pem\"])\n    cmd_ssh_run = c_itm[0]\n    if not options.nopem:\n        cmd_ssh_run += (\" -i {0}{1}.aws{1}{2}.{3}\".\n                        format(home_dir, c_itm[1], i_info[tar_idx]['ssh_key'],\n                               c_itm[2]))\n    else:\n        debg.dprint(\"Connect string: \", \"ssh {}@{}\".\n                    format(options.user, i_info[tar_idx]['pub_dns_name']))\n    cmd_ssh_run += \" {0}@{1}\".format(options.user,\n                                     i_info[tar_idx]['pub_dns_name'])\n    print(cmd_ssh_run)\n    subprocess.call(cmd_ssh_run, shell=True)", "response": "Connect to the specified instance via ssh."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_ssh_user(tar_aminame, inst_name):\n    if tar_aminame == \"Unknown\":\n        tar_aminame = inst_name\n    # first 5 chars of AMI-name can be anywhere in AMI-Name\n    userlu = {\"ubunt\": \"ubuntu\", \"debia\": \"admin\", \"fedor\": \"root\",\n              \"cento\": \"centos\", \"openb\": \"root\"}\n    usertemp = ['name'] + [value for key, value in list(userlu.items())\n                           if key in tar_aminame.lower()]\n    usertemp = dict(zip(usertemp[::2], usertemp[1::2]))\n    username = usertemp.get('name', 'ec2-user')\n    debg.dprint(\"loginuser Calculated: \", username)\n    return username", "response": "Calculate instance login - username based on image - name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting data specific for command selected.", "response": "def gather_data(options):\n    \"\"\"Get Data specific for command selected.\n\n    Create ec2 specific query and output title based on\n    options specified, retrieves the raw response data\n    from aws, then processes it into the i_info dict,\n    which is used throughout this module.\n\n    Args:\n        options (object): contains args and data from parser,\n                          that has been adjusted by the command\n                          specific functions as appropriate.\n    Returns:\n        i_info (dict): information on instances and details.\n        param_str (str): the title to display before the list.\n\n    \"\"\"\n    (qry_string, param_str) = qry_create(options)\n    qry_results = awsc.get_inst_info(qry_string)\n    i_info = process_results(qry_results)\n    return (i_info, param_str)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_results(qry_results):\n    i_info = {}\n    for i, j in enumerate(qry_results['Reservations']):\n        i_info[i] = {'id': j['Instances'][0]['InstanceId']}\n        i_info[i]['state'] = j['Instances'][0]['State']['Name']\n        i_info[i]['ami'] = j['Instances'][0]['ImageId']\n        i_info[i]['ssh_key'] = j['Instances'][0]['KeyName']\n        i_info[i]['pub_dns_name'] = j['Instances'][0]['PublicDnsName']\n        try:\n            i_info[i]['tag'] = process_tags(j['Instances'][0]['Tags'])\n        except KeyError:\n            i_info[i]['tag'] = {\"Name\": \"\"}\n    debg.dprint(\"numInstances: \", len(i_info))\n    debg.dprintx(\"Details except AMI-name\")\n    debg.dprintx(i_info, True)\n    return i_info", "response": "Generate dictionary of results from the AWS query."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate dict of instance tags as only name : value pairs.", "response": "def process_tags(inst_tags):\n    \"\"\"Create dict of instance tags as only name:value pairs.\"\"\"\n    tag_dict = {}\n    for k in range(len(inst_tags)):\n        tag_dict[inst_tags[k]['Key']] = inst_tags[k]['Value']\n    return tag_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qry_create(options):\n    qry_string = filt_end = param_str = \"\"\n    filt_st = \"Filters=[\"\n    param_str_default = \"All\"\n\n    if options.id:\n        qry_string += \"InstanceIds=['%s']\" % (options.id)\n        param_str += \"id: '%s'\" % (options.id)\n        param_str_default = \"\"\n\n    if options.instname:\n        (qry_string, param_str) = qry_helper(bool(options.id),\n                                             qry_string, param_str)\n        filt_end = \"]\"\n        param_str_default = \"\"\n        qry_string += filt_st + (\"{'Name': 'tag:Name', 'Values': ['%s']}\"\n                                 % (options.instname))\n        param_str += \"name: '%s'\" % (options.instname)\n\n    if options.inst_state:\n        (qry_string, param_str) = qry_helper(bool(options.id),\n                                             qry_string, param_str,\n                                             bool(options.instname), filt_st)\n        qry_string += (\"{'Name': 'instance-state-name',\"\n                       \"'Values': ['%s']}\" % (options.inst_state))\n        param_str += \"state: '%s'\" % (options.inst_state)\n        filt_end = \"]\"\n        param_str_default = \"\"\n\n    qry_string += filt_end\n    param_str += param_str_default\n    debg.dprintx(\"\\nQuery String\")\n    debg.dprintx(qry_string, True)\n    debg.dprint(\"param_str: \", param_str)\n    return(qry_string, param_str)", "response": "Create a query string that incorporates the args and data from the options\n    object and creates the title for the list function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying a list of all instances and their details.", "response": "def list_instances(i_info, param_str, numbered=False):\n    \"\"\"Display a list of all instances and their details.\n\n    Iterates through all the instances in the dict, and displays\n    information for each instance.\n\n    Args:\n        i_info (dict): information on instances and details.\n        param_str (str): the title to display before the list.\n        numbered (bool): optional - indicates wheter the list should be\n                         displayed with numbers before each instance.\n                         This is used when called from user_picklist.\n\n    \"\"\"\n    print(param_str)\n\n    for i in i_info:\n        if numbered:\n            print(\"Instance {}#{}{}\".format(C_WARN, i + 1, C_NORM))\n\n        print(\"  {6}Name: {1}{3:<22}{1}ID: {0}{4:<20}{1:<18}Status: {2}{5}{1}\".\n              format(C_TI, C_NORM, C_STAT[i_info[i]['state']],\n                     i_info[i]['tag']['Name'], i_info[i]['id'],\n                     i_info[i]['state'], C_HEAD2))\n        print(\"  AMI: {0}{2:<23}{1}AMI Name: {0}{3:.41}{1}\".\n              format(C_TI, C_NORM, i_info[i]['ami'], i_info[i]['aminame']))\n        list_tags(i_info[i]['tag'])\n    debg.dprintx(\"All Data\")\n    debg.dprintx(i_info, True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_tags(tags):\n    tags_sorted = sorted(list(tags.items()), key=operator.itemgetter(0))\n    tag_sec_spacer = \"\"\n    c = 1\n    ignored_keys = [\"Name\", \"aws:ec2spot:fleet-request-id\"]\n    pad_col = {1: 38, 2: 49}\n    for k, v in tags_sorted:\n        # if k != \"Name\":\n        if k not in ignored_keys:\n            if c < 3:\n                padamt = pad_col[c]\n                sys.stdout.write(\"  {2}{0}:{3} {1}\".\n                                 format(k, v, C_HEAD2, C_NORM).ljust(padamt))\n                c += 1\n                tag_sec_spacer = \"\\n\"\n            else:\n                sys.stdout.write(\"{2}{0}:{3} {1}\\n\".format(k, v, C_HEAD2,\n                                                           C_NORM))\n                c = 1\n                tag_sec_spacer = \"\"\n    print(tag_sec_spacer)", "response": "Print tags in dict so they allign with listing above."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef determine_inst(i_info, param_str, command):\n    qty_instances = len(i_info)\n    if not qty_instances:\n        print(\"No instances found with parameters: {}\".format(param_str))\n        sys.exit(1)\n\n    if qty_instances > 1:\n        print(\"{} instances match these parameters:\".format(qty_instances))\n        tar_idx = user_picklist(i_info, command)\n\n    else:\n        tar_idx = 0\n    tar_inst = i_info[tar_idx]['id']\n    print(\"{0}{3}ing{1} instance id {2}{4}{1}\".\n          format(C_STAT[command], C_NORM, C_TI, command, tar_inst))\n    return (tar_inst, tar_idx)", "response": "Determine the instance - id of the target instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay list of instances matching args and ask user to select target.", "response": "def user_picklist(i_info, command):\n    \"\"\"Display list of instances matching args and ask user to select target.\n\n    Instance list displayed and user asked to enter the number corresponding\n    to the desired target instance, or '0' to abort.\n\n    Args:\n        i_info (dict): information on instances and details.\n        command (str): command specified on the command line.\n    Returns:\n        tar_idx (int): the dictionary index number of the targeted instance.\n\n    \"\"\"\n    valid_entry = False\n    awsc.get_all_aminames(i_info)\n    list_instances(i_info, \"\", True)\n    msg_txt = (\"Enter {0}#{1} of instance to {3} ({0}1{1}-{0}{4}{1})\"\n               \" [{2}0 aborts{1}]: \".format(C_WARN, C_NORM, C_TI,\n                                            command, len(i_info)))\n    while not valid_entry:\n        entry_raw = obtain_input(msg_txt)\n        try:\n            entry_int = int(entry_raw)\n        except ValueError:\n            entry_int = 999\n        (tar_idx, valid_entry) = user_entry(entry_int, len(i_info), command)\n    return tar_idx"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate user entry and returns index and validity flag.", "response": "def user_entry(entry_int, num_inst, command):\n    \"\"\"Validate user entry and returns index and validity flag.\n\n    Processes the user entry and take the appropriate action: abort\n    if '0' entered, set validity flag and index is valid entry, else\n    return invalid index and the still unset validity flag.\n\n    Args:\n        entry_int (int): a number entered or 999 if a non-int was entered.\n        num_inst (int): the largest valid number that can be entered.\n        command (str): program command to display in prompt.\n    Returns:\n        entry_idx(int): the dictionary index number of the targeted instance\n        valid_entry (bool): specifies if entry_idx is valid.\n    Raises:\n        SystemExit: if the user enters 0 when they are choosing from the\n                    list it triggers the \"abort\" option offered to the user.\n\n    \"\"\"\n    valid_entry = False\n    if not entry_int:\n        print(\"{}aborting{} - {} instance\\n\".\n              format(C_ERR, C_NORM, command))\n        sys.exit()\n    elif entry_int >= 1 and entry_int <= num_inst:\n        entry_idx = entry_int - 1\n        valid_entry = True\n    else:\n        print(\"{}Invalid entry:{} enter a number between 1\"\n              \" and {}.\".format(C_ERR, C_NORM, num_inst))\n        entry_idx = entry_int\n    return (entry_idx, valid_entry)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(args):\n    is_property = '-property' in args\n\n    args = [get_vswhere_path(), '-utf8'] + args\n\n    if not is_property:\n        args.extend(['-format', 'json'])\n\n    output = subprocess.check_output(args)\n\n    if is_property:\n        return output.decode('utf-8').splitlines()\n    else:\n        return json.loads(output, encoding='utf-8')", "response": "Calls vswhere with the given arguments and returns an array of results."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(find_all=False, latest=False, legacy=False, prerelease=False, products=None, prop=None, requires=None, requires_any=False, version=None):\n    args = []\n\n    if find_all:\n        args.append('-all')\n\n    if latest:\n        args.append('-latest')\n\n    if legacy:\n        args.append('-legacy')\n\n    if prerelease:\n        args.append('-prerelease')\n\n    if products:\n        args.append('-products')\n        args.extend(products)\n\n    if prop:\n        args.append('-property')\n        args.append(prop)\n\n    if requires:\n        args.append('-requires')\n        args.extend(requires)\n\n    if requires_any:\n        args.append('-requiresAny')\n\n    if version:\n        args.append('-version')\n        args.append(version)\n\n    return execute(args)", "response": "Find a set of workload components."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the path to vshwere. exe.", "response": "def get_vswhere_path():\n    \"\"\"\n    Get the path to vshwere.exe.\n\n    If vswhere is not already installed as part of Visual Studio, and no\n    alternate path is given using `set_vswhere_path()`, the latest release will\n    be downloaded and stored alongside this script.\n    \"\"\"\n    if alternate_path and os.path.exists(alternate_path):\n        return alternate_path\n\n    if DEFAULT_PATH and os.path.exists(DEFAULT_PATH):\n        return DEFAULT_PATH\n\n    if os.path.exists(DOWNLOAD_PATH):\n        return DOWNLOAD_PATH\n\n    _download_vswhere()\n    return DOWNLOAD_PATH"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading vswhere to DOWNLOAD_PATH.", "response": "def _download_vswhere():\n    \"\"\"\n    Download vswhere to DOWNLOAD_PATH.\n    \"\"\"\n    print('downloading from', _get_latest_release_url())\n    try:\n        from urllib.request import urlopen\n        with urlopen(_get_latest_release_url()) as response, open(DOWNLOAD_PATH, 'wb') as outfile:\n            shutil.copyfileobj(response, outfile)\n    except ImportError:\n        # Python 2\n        import urllib\n        urllib.urlretrieve(_get_latest_release_url(), DOWNLOAD_PATH)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_source(self):\n        logger.debug('Getting module source for webhook2lambda2sqs.lambda_func')\n        orig = getsourcelines(lambda_func)\n        src = ''\n        in_docstr = False\n        have_docstr = False\n        for line in orig[0]:\n            if line.strip() == '\"\"\"' and not in_docstr and not have_docstr:\n                in_docstr = True\n                continue\n            if line.strip() == '\"\"\"' and in_docstr:\n                in_docstr = False\n                have_docstr = True\n                continue\n            if not in_docstr:\n                src += line\n        return src", "response": "Get the lambda function source template. Strip the leading docstring."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _docstring(self):\n        s = '\"\"\"' + \"\\n\"\n        s += \"webhook2lambda2sqs generated function source\\n\"\n        s += \"this code was generated by webhook2lambda2sqs v%s\\n\" % VERSION\n        s += \"<%s>\\n\" % PROJECT_URL\n        s += \"this project is licensed under the AGPLv3 open source license.\\n\"\n        s += \"\\n\"\n        s += \"DO NOT MODIFY this function; modifications should be made by \"\n        s += \"re-running\\n\"\n        s += \"the project with an updated configuration.\\n\"\n        s += '\"\"\"' + \"\\n\"\n        return s", "response": "Generate a docstring for the generated source file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate(self):\n        s = self._docstring\n        s += self._get_source().replace(\n            'endpoints = {}',\n            'endpoints = ' + self._config_src\n        ).replace(\n            'logger.setLevel(logging.INFO)',\n            'logger.setLevel(logging.%s)' % self.config.logging_level\n        )\n        return s", "response": "Generate Lambda function source ; return it as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef kem(request):\n\tkeyword = request.GET['keyword']\n\tlang = request.GET['lang']\n\tontology = 'ontology' if 'ontology' in request.GET and bool(json.loads(request.GET['ontology'].lower())) else 'origin'\n\tresult = multilanguage_model[lang][ontology].most_similar(keyword, int(request.GET['num']) if 'num' in request.GET else 10)\n\treturn JsonResponse(result, safe=False)", "response": "Return a list of most similar models for a given keyword."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normalize_date(date):\n        '''normalize the specified date to milliseconds since the epoch\n\n        If it is a string, it is assumed to be some sort of datetime such as\n        \"2015-12-27\" or \"2015-12-27T11:01:20.954\". If date is a naive datetime,\n        it is assumed to be UTC.\n\n        If numeric arguments are beyond 5138-11-16 (100,000,000,000 seconds\n        after epoch), they are interpreted as milliseconds since the epoch.\n        '''\n\n        if isinstance(date, datetime):\n            pass\n        elif date == \"now\":\n            date = datetime.now(pytz.UTC)\n        elif isinstance(date, (basestring, int, float, long)):\n            try:\n                ts = float(date)\n                if ts > MAX_TS_SECONDS:\n                    # ts was provided in ms\n                    ts = ts / 1000.0\n                # For unix timestamps on command line\n                date = datetime.utcfromtimestamp(float(ts))\n            except ValueError:\n                try:\n                    date = dateparse(date)\n                except ValueError as e:\n                    raise InvalidDatalakeMetadata(str(e))\n        else:\n            msg = 'could not parse a date from {!r}'.format(date)\n            raise InvalidDatalakeMetadata(msg)\n\n        return Metadata._from_datetime(date)", "response": "normalize the specified date to milliseconds since the epoch"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef union_sql(view_name, *tables):\n\n    if not tables:\n        raise Exception(\"no tables given\")\n\n    ret = \"\"\n    pre = \"CREATE VIEW %s AS SELECT * FROM \" % view_name\n\n    for table in tables:\n        ret += pre + table\n        pre = \" UNION SELECT * FROM \"\n\n    return ret", "response": "This function creates a big VIEW that consists of many SELECTs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_output_nodes(self, output_path, error_path):\n        from pymatgen.io.nwchem import NwOutput\n        from aiida.orm.data.structure import StructureData\n        from aiida.orm.data.array.trajectory import TrajectoryData\n\n        ret_dict = []\n        nwo = NwOutput(output_path)\n        for out in nwo.data:\n            molecules = out.pop('molecules', None)\n            structures = out.pop('structures', None)\n            if molecules:\n                structlist = [StructureData(pymatgen_molecule=m)\n                              for m in molecules]\n                ret_dict.append(('trajectory',\n                                 TrajectoryData(structurelist=structlist)))\n            if structures:\n                structlist = [StructureData(pymatgen_structure=s)\n                              for s in structures]\n                ret_dict.append(('trajectory',\n                                 TrajectoryData(structurelist=structlist)))\n            ret_dict.append(('output', ParameterData(dict=out)))\n\n        # Since ParameterData rewrites it's properties (using _set_attr())\n        # with keys from the supplied dictionary, ``source`` has to be\n        # moved to another key. See issue #9 for details:\n        # (https://bitbucket.org/epfl_theos/aiida_epfl/issues/9)\n        nwo.job_info['program_source'] = nwo.job_info.pop('source', None)\n        ret_dict.append(('job_info', ParameterData(dict=nwo.job_info)))\n        \n        return ret_dict", "response": "Extracts output nodes from the standard output and standard error files."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend sockets facing services (e.g. online monitor, other forwarders)", "response": "def _setup_backend(self):\n        ''' Send sockets facing services (e.g. online monitor, other forwarders)\n        '''\n        self.backends = []\n        self.be_poller = zmq.Poller()\n        for actual_backend_address in self.backend_address:\n            # publisher or client socket\n            actual_backend = (actual_backend_address,\n                              self.context.socket(self.backend_socket_type))\n            # Wait 0.5 s before termating socket\n            actual_backend[1].setsockopt(zmq.LINGER, 500)\n            # Buffer only 100 meassages, then throw data away\n            actual_backend[1].set_hwm(10)\n            actual_backend[1].bind(actual_backend_address)\n            self.backends.append(actual_backend)\n            if self.backend_socket_type != zmq.DEALER:\n                self.be_poller.register(actual_backend[1], zmq.POLLIN)\n        self.be_stop = threading.Event()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_data(self, data):\n        ''' This function can be overwritten in derived class\n\n            Std. function is to broadcast all receiver data to all backends\n        '''\n        for frontend_data in data:\n            serialized_data = self.serialize_data(frontend_data)\n            if sys.version_info >= (3, 0):\n                serialized_data = serialized_data.encode('utf-8')\n            for actual_backend in self.backends:\n                actual_backend[1].send(serialized_data)", "response": "This function is overwritten in derived class\n            Std. function is to send all data to all backends and all backend data to all backends."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the configuration file into the environment and returns the object that represents the new configuration file.", "response": "def load_config(config_file, default_config_file, **kwargs):\n    '''load the configuration\n\n    Configuration variables are delivered to applications exclusively through\n    the environment. They get into the environment either from a specified\n    configuration file, from a default configuration file, from an environment\n    variable, or from a kwarg specified to this function.\n\n    Configuration variables are applied with the following precedence (lowest\n    to highest):\n\n    - config file: the format of the config file is a typical environment file\n      with individual lines like DATALAKE_FOO=bar. By convention, all variables\n      start with either DATALAKE_ or AWS_.\n\n    - environment variables: The variable names are the same as what would be\n      written in a config file.\n\n    - kwargs: additional configuration variables to apply, subject to some\n      conventions. Specifically, kwargs are lowercase. A kwarg called `foo`\n      maps to a configuration variable called `DATALAKE_FOO`. The only\n      exception to this is a kwarg that starts with `aws_`. That is, a kwarg\n      called `aws_baz` would map to a configuration variable called `AWS_BAZ`.\n\n\n    Args:\n\n    - config_file: the configuration file to load. If it is None,\n      default_config_file will be examined. If it is not None and does not\n      exist an InsufficientConfiguration exception is thrown.\n\n    - default_config_file: the file to try if config_file is None. If\n      default_config_file is None or does not exist, it is simply ignored. No\n      exceptions are thrown.\n\n    - kwargs: key=value pairs.\n\n    '''\n    if config_file and not os.path.exists(config_file):\n        msg = 'config file {} does not exist'.format(config_file)\n        raise InsufficientConfiguration(msg)\n\n    if config_file is None and \\\n       default_config_file is not None and \\\n       os.path.exists(default_config_file):\n        config_file = default_config_file\n\n    if config_file is not None:\n        load_dotenv(config_file)\n\n    _update_environment(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pre_handler(self, cmd):\n        if self._finished:\n            return\n        if self.interesting_commit and cmd.name == 'commit':\n            if cmd.mark == self.interesting_commit:\n                print(cmd.to_string())\n                self._finished = True\n            return\n        if cmd.name in self.parsed_params:\n            fields = self.parsed_params[cmd.name]\n            str = cmd.dump_str(fields, self.parsed_params, self.verbose)\n            print(\"%s\" % (str,))", "response": "Hook for logic before each handler starts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_object(updates):\n    \"Update same name (or prefixed) settings.\"\n    import sys\n    config = sys.modules[__name__]\n    \n    prefix = config.__name__.split('.')[0].upper()\n    keys = [k for k in config.__dict__ if \\\n        k != from_object.__name__ and not k.startswith('_')]\n    get_value = lambda c, k: hasattr(c, k) and getattr(c, k) or None\n    for key in keys:\n        prefix_key = '%s_%s' % (prefix, key)\n        value = get_value(updates, prefix_key) or get_value(updates, key)\n        if value: setattr(config, key, value)", "response": "Update same name ( or prefixed ) settings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef commit_format(self):\n        formatted_analyses = []\n        for analyze in self.analysis['messages']:\n            formatted_analyses.append({\n                'message': f\"{analyze['source']}: {analyze['message']}. Code: {analyze['code']}\",\n                'file': analyze['location']['path'],\n                'line': analyze['location']['line'],\n            })\n\n        return formatted_analyses", "response": "Formats the analysis into a simpler dictionary with the line file and message values to\n            be commented on a commit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef int_to_rgba(cls, rgba_int):\n        if rgba_int is None:\n            return None, None, None, None\n        alpha = rgba_int % 256\n        blue = rgba_int / 256 % 256\n        green = rgba_int / 256 / 256 % 256\n        red = rgba_int / 256 / 256 / 256 % 256\n        return (red, green, blue, alpha)", "response": "Converts a color Integer into r g b a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef radii_of_curvature(self):\n        rocs = []\n        for i, _ in enumerate(self):\n            if 0 < i < len(self) - 1:\n                rocs.append(radius_of_circumcircle(\n                    self[i - 1]['CA'], self[i]['CA'], self[i + 1]['CA']))\n            else:\n                rocs.append(None)\n        return rocs", "response": "Returns the radius of curvature at each point on the Polymer primitive."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting a float into a string.", "response": "def format_float(x, max_width):\n    '''format_float will ensure that a number's decimal part is truncated to\n    fit within some bounds, unless the whole part is wider than max_width,\n    which is a problem you need to sort out yourself.\n    '''\n    # width of (whole part + 1 (to avoid zero)) + 1 because int floors, not ceils\n    whole_width = int(math.log10(abs(x) + 1)) + 1\n    # for +/- sign\n    sign_width = 1 if x < 0 else 0\n    # for . if we show it\n    decimal_point_width = 1 if max_width >= whole_width else 0\n    return '%.*f' % (max_width - whole_width - sign_width - decimal_point_width, x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef monkey_patch_issue_25593():\n    save = asyncio.selector_events.BaseSelectorEventLoop._sock_connect_cb\n\n    @functools.wraps(save)\n    def patched(instance, fut, sock, address):\n        if not fut.done():\n            save(instance, fut, sock, address)\n    asyncio.selector_events.BaseSelectorEventLoop._sock_connect_cb = patched", "response": "Monkey patch asyncio. selector_events. BaseSelectorEventLoop. _sock_connect_cb to handle async connection errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompiles the CSS file at sourcepath to destination and return a boolean with a message.", "response": "def safe_compile(self, settings, sourcepath, destination):\n        \"\"\"\n        Safe compile\n\n        It won't raise compile error and instead return compile success state\n        as a boolean with a message.\n\n        It will create needed directory structure first if it contain some\n        directories that does not allready exists.\n\n        Args:\n            settings (boussole.conf.model.Settings): Project settings.\n            sourcepath (str): Source file path to compile to CSS.\n            destination (str): Destination path for compiled CSS.\n\n        Returns:\n            tuple: A tuple of (success state, message).\n\n            * success state: is boolean weither the compile is a success\n              or not;\n            * message: Message accorded to success. If compile fails, the\n              message will contains returned error from libsass, if success\n              just the destination path.\n        \"\"\"\n        source_map_destination = None\n        if settings.SOURCE_MAP:\n            source_map_destination = self.change_extension(destination, \"map\")\n\n        try:\n            content = sass.compile(\n                filename=sourcepath,\n                output_style=settings.OUTPUT_STYLES,\n                source_comments=settings.SOURCE_COMMENTS,\n                include_paths=settings.LIBRARY_PATHS,\n                custom_import_extensions=settings.CUSTOM_IMPORT_EXTENSIONS,\n                # Sourcemap is allways in the same directory than compiled\n                # CSS file\n                output_filename_hint=destination,\n                source_map_filename=source_map_destination,\n            )\n        except sass.CompileError as e:\n            return False, six.text_type(e)\n        else:\n            # Compiler return a tuple (css, map) if sourcemap is\n            # enabled\n            sourcemap = None\n            if settings.SOURCE_MAP:\n                content, sourcemap = content\n\n            self.write_content(content, destination)\n\n            # Write sourcemap if any\n            if sourcemap:\n                self.write_content(sourcemap, source_map_destination)\n\n            return True, destination"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting given content to destination path.", "response": "def write_content(self, content, destination):\n        \"\"\"\n        Write given content to destination path.\n\n        It will create needed directory structure first if it contain some\n        directories that does not allready exists.\n\n        Args:\n            content (str): Content to write to target file.\n            destination (str): Destination path for target file.\n\n        Returns:\n            str: Path where target file has been written.\n        \"\"\"\n        directory = os.path.dirname(destination)\n\n        if directory and not os.path.exists(directory):\n            os.makedirs(directory)\n\n        with io.open(destination, 'w', encoding='utf-8') as f:\n            f.write(content)\n\n        return destination"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit a n sized graph into n sized chunks.", "response": "def make_batch(size, graph):\n        \"\"\"\n        Split graphs into n sized chunks.\n        See: http://stackoverflow.com/a/1915307/758157\n\n        :param size: int\n        :param graph: graph\n        :return: graph\n        \"\"\"\n        i = iter(graph)\n        chunk = list(islice(i, size))\n        while chunk:\n            yield chunk\n            chunk = list(islice(i, size))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nt_yielder(self, graph, size):\n        for grp in self.make_batch(size, graph):\n            tmpg = Graph()\n            # Add statements as list to tmp graph\n            tmpg += grp\n            yield (len(tmpg), tmpg.serialize(format='nt'))", "response": "Yields n sized ntriples for a given graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbulking adds or deletes Triples are chunked into n size groups before sending to API endpoint.", "response": "def bulk_update(self, named_graph, graph, size, is_add=True):\n        \"\"\"\n        Bulk adds or deletes. Triples are chunked into n size groups before\n        sending to API. This prevents the API endpoint from timing out.\n        \"\"\"\n        context = URIRef(named_graph)\n        total = len(graph)\n        if total > 0:\n            for set_size, nt in self.nt_yielder(graph, size):\n                if is_add is True:\n                    logger.info(\"Adding {} statements to <{}>.\".format(set_size, named_graph))\n                    self.update(u'INSERT DATA { GRAPH %s { %s } }' % (context.n3(), nt.decode('utf-8')))\n                else:\n                    logger.info(\"Removing {} statements from <{}>.\".format(set_size, named_graph))\n                    self.update(u'DELETE DATA { GRAPH %s { %s } }' % (context.n3(), nt.decode('utf-8')))\n        return total"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bulk_add(self, named_graph, add, size=DEFAULT_CHUNK_SIZE):\n        return self.bulk_update(named_graph, add, size)", "response": "Bulk add a set of statements into the named_graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bulk_remove(self, named_graph, add, size=DEFAULT_CHUNK_SIZE):\n        return self.bulk_update(named_graph, add, size, is_add=False)", "response": "Bulk remove a set of statements from the named graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating statements to merge two URIs in a specified graph.", "response": "def merge_uris(self, uri1, uri2, graph=DEFAULT_GRAPH):\n        \"\"\"\n        Generate statements to merge two URIS in a specified graph.\n        \"\"\"\n        rq = \"\"\"\n        CONSTRUCT {\n            ?uri ?p ?o .\n            ?other ?p2 ?uri .\n        }\n        WHERE {\n          GRAPH ?g {\n            {\n                ?uri ?p ?o\n            } UNION {\n                ?other ?p2 ?uri\n            }\n          }\n        }\n        \"\"\"\n        for var in [uri1, uri2, graph]:\n            assert type(var) == URIRef\n        addg = Graph()\n        removeg = Graph()\n        rsp2 = self.query(rq, initBindings=dict(uri=uri2, g=graph))\n\n        # reassign triples were the merged uri is the subject\n        for pred, obj in rsp2.graph.predicate_objects(subject=uri2):\n            addg.add((uri1, pred, obj))\n            removeg.add((uri2, pred, obj))\n\n        # reassign triples were the merged uri is the object\n        for subj, pred in rsp2.graph.subject_predicates(object=uri2):\n            addg.add((subj, pred, uri1))\n            removeg.add((subj, pred, uri2))\n\n        return addg, removeg"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef blend(c1, c2):\n    return [c1[i] * (0xFF - c2[3]) + c2[i] * c2[3] >> 8 for i in range(3)]", "response": "Alpha blends two colors using the alpha given by c2"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a row of RGB bytes and convert to a row of RGBA bytes.", "response": "def rgb2rgba(rgb):\n    \"\"\"Take a row of RGB bytes, and convert to a row of RGBA bytes.\"\"\"\n    rgba = []\n    for i in range(0, len(rgb), 3):\n        rgba += rgb[i:i+3]\n        rgba.append(255)\n\n    return rgba"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading num_bytes from the compressed data chunks.", "response": "def read(self, num_bytes):\n        \"\"\"Read `num_bytes` from the compressed data chunks.\n\n        Data is returned as `bytes` of length `num_bytes`\n\n        Will raise an EOFError if data is unavailable.\n\n        Note: Will always return `num_bytes` of data (unlike the file read method).\n\n        \"\"\"\n        while len(self.decoded) < num_bytes:\n            try:\n                tag, data = next(self.chunks)\n            except StopIteration:\n                raise EOFError()\n            if tag != b'IDAT':\n                continue\n            self.decoded += self.decompressor.decompress(data)\n\n        r = self.decoded[:num_bytes]\n        self.decoded = self.decoded[num_bytes:]\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _offset(self, x, y):\n        x, y = force_int(x, y)\n        return y * self.width * 4 + x * 4", "response": "Helper for internal data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vertical_gradient(self, x0, y0, x1, y1, start, end):\n        x0, y0, x1, y1 = self.rect_helper(x0, y0, x1, y1)\n        grad = gradient_list(start, end, y1 - y0)\n        for x in range(x0, x1 + 1):\n            for y in range(y0, y1 + 1):\n                self.point(x, y, grad[y - y0])", "response": "Draw a vertical gradient"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filled_rectangle(self, x0, y0, x1, y1):\n        x0, y0, x1, y1 = self.rect_helper(x0, y0, x1, y1)\n        for x in range(x0, x1 + 1):\n            for y in range(y0, y1 + 1):\n                self.point(x, y, self.color)", "response": "Draw a filled rectangle"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy_rect(self, x0, y0, x1, y1, dx, dy, destination):\n        x0, y0, x1, y1 = self.rect_helper(x0, y0, x1, y1)\n        dx, dy = force_int(dx, dy)\n\n        for x in range(x0, x1 + 1):\n            for y in range(y0, y1 + 1):\n                d = destination._offset(dx + x - x0, dy + y - y0)\n                o = self._offset(x, y)\n                destination.canvas[d:d + 4] = self.canvas[o:o + 4]", "response": "Copy a rectangle onto another part of the image"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nblending a rectangle onto the image", "response": "def blend_rect(self, x0, y0, x1, y1, dx, dy, destination, alpha=0xff):\n        \"\"\"Blend a rectangle onto the image\"\"\"\n        x0, y0, x1, y1 = self.rect_helper(x0, y0, x1, y1)\n        for x in range(x0, x1 + 1):\n            for y in range(y0, y1 + 1):\n                o = self._offset(x, y)\n                rgba = self.canvas[o:o + 4]\n                rgba[3] = alpha\n                destination.point(dx + x - x0, dy + y - y0, rgba)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef line(self, x0, y0, x1, y1):\n        # clean params\n        x0, y0, x1, y1 = int(x0), int(y0), int(x1), int(y1)\n        if y0 > y1:\n            y0, y1, x0, x1 = y1, y0, x1, x0\n        dx = x1 - x0\n        if dx < 0:\n            sx = -1\n        else:\n            sx = 1\n        dx *= sx\n        dy = y1 - y0\n\n        # 'easy' cases\n        if dy == 0:\n            for x in range(x0, x1, sx):\n                self.point(x, y0)\n            return\n        if dx == 0:\n            for y in range(y0, y1):\n                self.point(x0, y)\n            self.point(x1, y1)\n            return\n        if dx == dy:\n            for x in range(x0, x1, sx):\n                self.point(x, y0)\n                y0 += 1\n            return\n\n        # main loop\n        self.point(x0, y0)\n        e_acc = 0\n        if dy > dx:  # vertical displacement\n            e = (dx << 16) // dy\n            for i in range(y0, y1 - 1):\n                e_acc_temp, e_acc = e_acc, (e_acc + e) & 0xFFFF\n                if e_acc <= e_acc_temp:\n                    x0 += sx\n                w = 0xFF-(e_acc >> 8)\n                self.point(x0, y0, intensity(self.color, w))\n                y0 += 1\n                self.point(x0 + sx, y0, intensity(self.color, (0xFF - w)))\n            self.point(x1, y1)\n            return\n\n        # horizontal displacement\n        e = (dy << 16) // dx\n        for i in range(x0, x1 - sx, sx):\n            e_acc_temp, e_acc = e_acc, (e_acc + e) & 0xFFFF\n            if e_acc <= e_acc_temp:\n                y0 += 1\n            w = 0xFF-(e_acc >> 8)\n            self.point(x0, y0, intensity(self.color, w))\n            x0 += sx\n            self.point(x0, y0 + 1, intensity(self.color, (0xFF-w)))\n        self.point(x1, y1)", "response": "Draw a line using Xiaolin Wu s antialiasing technique"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndraws a set of lines", "response": "def polyline(self, arr):\n        \"\"\"Draw a set of lines\"\"\"\n        for i in range(0, len(arr) - 1):\n            self.line(arr[i][0], arr[i][1], arr[i + 1][0], arr[i + 1][1])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump(self):\n        scan_lines = bytearray()\n        for y in range(self.height):\n            scan_lines.append(0)  # filter type 0 (None)\n            scan_lines.extend(\n                self.canvas[(y * self.width * 4):((y + 1) * self.width * 4)]\n            )\n        # image represented as RGBA tuples, no interlacing\n        return SIGNATURE + \\\n            self.pack_chunk(b'IHDR', struct.pack(b\"!2I5B\",\n                                                 self.width, self.height,\n                                                 8, 6, 0, 0, 0)) + \\\n            self.pack_chunk(b'IDAT', zlib.compress(bytes(scan_lines), 9)) + \\\n            self.pack_chunk(b'IEND', b'')", "response": "Dump the image data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npacks a PNG chunk for serializing to disk", "response": "def pack_chunk(tag, data):\n        \"\"\"Pack a PNG chunk for serializing to disk\"\"\"\n        to_check = tag + data\n        return (struct.pack(b\"!I\", len(data)) + to_check +\n                struct.pack(b\"!I\", zlib.crc32(to_check) & 0xFFFFFFFF))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a PNG image into the internal memory.", "response": "def load(self, f):\n        \"\"\"Load a PNG image\"\"\"\n        SUPPORTED_COLOR_TYPES = (COLOR_TYPE_TRUECOLOR, COLOR_TYPE_TRUECOLOR_WITH_ALPHA)\n        SAMPLES_PER_PIXEL = { COLOR_TYPE_TRUECOLOR: 3,\n                              COLOR_TYPE_TRUECOLOR_WITH_ALPHA: 4 }\n\n        assert f.read(8) == SIGNATURE\n\n        chunks = iter(self.chunks(f))\n        header = next(chunks)\n        assert header[0] == b'IHDR'\n\n        (width, height, bit_depth, color_type, compression,\n         filter_type, interlace) = struct.unpack(b\"!2I5B\", header[1])\n\n        if bit_depth != 8:\n            raise ValueError('Unsupported PNG format (bit depth={}; must be 8)'.format(bit_depth))\n        if compression != 0:\n            raise ValueError('Unsupported PNG format (compression={}; must be 0)'.format(compression))\n        if filter_type != 0:\n            raise ValueError('Unsupported PNG format (filter_type={}; must be 0)'.format(filter_type))\n        if interlace != 0:\n            raise ValueError('Unsupported PNG format (interlace={}; must be 0)'.format(interlace))\n        if color_type not in SUPPORTED_COLOR_TYPES:\n            raise ValueError('Unsupported PNG format (color_type={}; must one of {})'.format(SUPPORTED_COLOR_TYPES))\n\n        self.width = width\n        self.height = height\n        self.canvas = bytearray(self.bgcolor * width * height)\n        bytes_per_pixel = SAMPLES_PER_PIXEL[color_type]\n        bytes_per_row = bytes_per_pixel * width\n        bytes_per_rgba_row = SAMPLES_PER_PIXEL[COLOR_TYPE_TRUECOLOR_WITH_ALPHA] * width\n        bytes_per_scanline = bytes_per_row + 1\n\n        # Python 2 requires the encode for struct.unpack\n        scanline_fmt = ('!%dB' % bytes_per_scanline).encode('ascii')\n\n        reader = ByteReader(chunks)\n\n        old_row = None\n        cursor = 0\n        for row in range(height):\n            scanline = reader.read(bytes_per_scanline)\n            unpacked = list(struct.unpack(scanline_fmt, scanline))\n            old_row = self.defilter(unpacked[1:], old_row, unpacked[0], bpp=bytes_per_pixel)\n            rgba_row = old_row if color_type == COLOR_TYPE_TRUECOLOR_WITH_ALPHA else rgb2rgba(old_row)\n            self.canvas[cursor:cursor + bytes_per_rgba_row] = rgba_row\n            cursor += bytes_per_rgba_row"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef defilter(cur, prev, filter_type, bpp=4):\n        if filter_type == 0:  # No filter\n            return cur\n        elif filter_type == 1:  # Sub\n            xp = 0\n            for xc in range(bpp, len(cur)):\n                cur[xc] = (cur[xc] + cur[xp]) % 256\n                xp += 1\n        elif filter_type == 2:  # Up\n            for xc in range(len(cur)):\n                cur[xc] = (cur[xc] + prev[xc]) % 256\n        elif filter_type == 3:  # Average\n            xp = 0\n            for i in range(bpp):\n                cur[i] = (cur[i] + prev[i] // 2) % 256\n            for xc in range(bpp, len(cur)):\n                cur[xc] = (cur[xc] + ((cur[xp] + prev[xc]) // 2)) % 256\n                xp += 1\n        elif filter_type == 4:  # Paeth\n            xp = 0\n            for i in range(bpp):\n                cur[i] = (cur[i] + prev[i]) % 256\n            for xc in range(bpp, len(cur)):\n                a = cur[xp]\n                b = prev[xc]\n                c = prev[xp]\n                p = a + b - c\n                pa = abs(p - a)\n                pb = abs(p - b)\n                pc = abs(p - c)\n                if pa <= pb and pa <= pc:\n                    value = a\n                elif pb <= pc:\n                    value = b\n                else:\n                    value = c\n                cur[xc] = (cur[xc] + value) % 256\n                xp += 1\n        else:\n            raise ValueError('Unrecognized scanline filter type: {}'.format(filter_type))\n        return cur", "response": "Decode a chunk of a scanline."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef chunks(f):\n        while 1:\n            try:\n                length = struct.unpack(b\"!I\", f.read(4))[0]\n                tag = f.read(4)\n                data = f.read(length)\n                crc = struct.unpack(b\"!I\", f.read(4))[0]\n            except struct.error:\n                return\n            if zlib.crc32(tag + data) & 0xFFFFFFFF != crc:\n                raise IOError('Checksum fail')\n            yield tag, data", "response": "Split PNG image data into chunks"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def start(self) -> None:\n        if self._is_running:\n            raise SublemonRuntimeError(\n                'Attempted to start an already-running `Sublemon` instance')\n\n        self._poll_task = asyncio.ensure_future(self._poll())\n        self._is_running = True", "response": "Coroutine to run this server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def stop(self) -> None:\n        if not self._is_running:\n            raise SublemonRuntimeError(\n                'Attempted to stop an already-stopped `Sublemon` instance')\n\n        await self.block()\n        self._poll_task.cancel()\n        self._is_running = False\n        with suppress(asyncio.CancelledError):\n            await self._poll_task", "response": "Coroutine to stop execution of this server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def block(self) -> None:\n        await asyncio.gather(\n            *itertools.chain(\n                (sp.wait_done() for sp in self._running_set),\n                (sp.wait_done() for sp in self._pending_set)))", "response": "Block until all running and pending subprocesses have finished."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef spawn(self, *cmds: str) -> List[SublemonSubprocess]:\n        if not self._is_running:\n            raise SublemonRuntimeError(\n                'Attempted to spawn subprocesses from a non-started server')\n\n        subprocs = [SublemonSubprocess(self, cmd) for cmd in cmds]\n        for sp in subprocs:\n            asyncio.ensure_future(sp.spawn())\n        return subprocs", "response": "Coroutine to spawn subprocesses."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_filepath(self, filepath=None):\n        filepath = filepath or self._default_filename\n\n        path, filename = os.path.split(filepath)\n\n        if not path:\n            path = self.basedir\n        elif not os.path.isabs(path):\n            path = os.path.join(self.basedir, path)\n\n        return os.path.normpath(path), filename", "response": "Parse given filepath and return path directory and filename."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_filepath(self, path, filename):\n        settings_path = os.path.join(path, filename)\n\n        if not os.path.exists(settings_path) or \\\n           not os.path.isfile(settings_path):\n            msg = \"Unable to find settings file: {}\"\n            raise SettingsBackendError(msg.format(settings_path))\n\n        return settings_path", "response": "Checks and returns the final filepath to settings file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef open(self, filepath):\n        with io.open(filepath, 'r', encoding='utf-8') as fp:\n            content = fp.read()\n        return content", "response": "Open settings backend to return its content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(self, filepath=None):\n        self.projectdir, filename = self.parse_filepath(filepath)\n\n        settings_path = self.check_filepath(self.projectdir, filename)\n\n        parsed = self.parse(settings_path, self.open(settings_path))\n\n        settings = self.clean(parsed)\n\n        return Settings(initial=settings)", "response": "Load settings file from given filepath and return a new Settings object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwithdrawing funds requests to user wallet", "response": "async def withdraw_bulk(self, *args, **kwargs):\n        \"\"\"\n       Withdraw funds requests to user wallet\n\n       Accepts:\n           - coinid [string] (blockchain id (example: BTCTEST, LTCTEST))\n           - address [string] withdrawal address (in hex for tokens)\n           - amount [int]     withdrawal amount multiplied by decimals_k (10**8)\n       Returns dictionary with following fields:\n           - success [bool]\n       \"\"\"\n        await self.db.withdraw_requests.insert_one({\n            'coinid': kwargs.get(\"coinid\"),\n            'address': kwargs.get(\"address\"),\n            'amount': int(kwargs.get(\"amount\")),\n            'timestamp': datetime.datetime.utcnow()\n        })\n\n        return {'success': True}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def withdraw(self, *args, **kwargs):\n        try:\n            super().reload_connections()\n        except Exception as e:\n            return WithdrawValidator.error_500(str(e))\n\n        coinid = kwargs.get(\"coinid\")\n        address = kwargs.get(\"address\")\n        amount = int(kwargs.get(\"amount\"))\n        txid = None\n        connection = self.connections[coinid]\n\n        if coinid in ['BTCTEST', 'LTCTEST', 'QTUMTEST', 'BTC', 'LTC', 'QTUM']:\n            try:\n                txid = connection.sendtoaddress(address, str(amount / decimals_k))\n            except Exception as e:\n                return WithdrawValidator.error_400(str(e))\n        elif coinid in ['ETH', 'ETHRINKEBY', 'ETHROPSTEN']:\n            address = Web3.toChecksumAddress(address)\n            try:\n                txid = connection.eth.sendTransaction(\n                    {'to': address, 'from': hot_wallets[coinid], 'value': Web3.toWei(amount / decimals_k, 'ether')}\n                )\n                txid = encode_hex(txid)[0].decode()\n            except Exception as e:\n                return WithdrawValidator.error_500(str(e))\n        else:\n            token = await self.db.available_tokens.find_one({'_id': coinid})\n            if token is None:\n                return WithdrawValidator.error_500('Unsupported coinid')\n\n            elif token['blockchain'] in ('QTUM', 'QTUMTEST'):\n                connection = self.connections[coinid]\n                address = Bip32Addresses.address_to_hex(address)\n                handler = Qrc20.from_connection(\n                    connection,\n                    token['contract_address'],\n                    erc20_abi\n                )\n                handler.set_send_params({\n                    'gasLimit': transfer_settings[token['blockchain']]['gasLimit'],\n                    'gasPrice': transfer_settings[token['blockchain']]['gasPrice'],\n                    'sender': hot_wallets[coinid]\n                })\n                print(hot_wallets[coinid])\n                try:\n                    txid = handler.transfer(address, amount)['txid']\n                except Exception as e:\n                    return WithdrawValidator.error_500(str(e))\n\n            elif token['blockchain'] in ('ETHRINKEBY', 'ETH'):\n                connection = self.connections[coinid]\n                address = Web3.toChecksumAddress(address)\n                handler = Erc20.from_connection(\n                    connection,\n                    token['contract_address'],\n                    erc20_abi\n                )\n                handler.set_send_params({\n                    'gasLimit': transfer_settings[token['blockchain']]['gasLimit'],\n                    'gasPrice': transfer_settings[token['blockchain']]['gasPrice'],\n                    'sender': hot_wallets[coinid]})\n                try:\n                    txid = handler.transfer(address, amount)['txid']\n                except Exception as e:\n                    return WithdrawValidator.error_500(str(e))\n\n        await self.db.executed_withdraws.insert_one({\n            'coinid': coinid,\n            'address': address,\n            'amount': amount,\n            'txid': txid,\n            'timestamp': datetime.datetime.utcnow(),\n            'execution_time': datetime.datetime.utcnow()\n        })\n        return {'txid': txid}", "response": "Withdraw funds to user wallet"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwithdraws custom token to user wallet", "response": "async def withdraw_custom_token(self, *args, **kwargs):\n        \"\"\"\n        Withdraw custom token to user wallet\n\n        Accepts:\n            - address [hex string] (withdrawal address in hex form)\n            - amount [int] withdrawal amount multiplied by decimals_k (10**8)\n            - blockchain [string]  token's blockchain (QTUMTEST, ETH)\n            - contract_address [hex string] token contract address\n        Returns dictionary with following fields:\n            - txid [string]\n        \"\"\"\n        try:\n            super().reload_connections()\n        except Exception as e:\n            return WithdrawValidator.error_500(str(e))\n\n        address = kwargs.get(\"address\")\n        amount = kwargs.get(\"amount\")\n        blockchain = kwargs.get(\"blockchain\")\n        contract_address = kwargs.get(\"contract_address\")\n\n        await self.db.withdraw_custom_token_requests.insert_one({\n            'address': address,\n            'amount': amount,\n            'blockchain': blockchain,\n            'contract_address': contract_address,\n            'timestamp': datetime.datetime.utcnow()\n        })\n\n        connection = self.connections[blockchain]\n\n        if blockchain in ['QTUMTEST', 'QTUM']:\n            address = Bip32Addresses.address_to_hex(address)\n            handler = Qrc20.from_connection(connection, contract_address, erc20_abi)\n            handler.set_send_params({\n                'gasLimit': transfer_settings[blockchain]['gasLimit'],\n                'gasPrice': transfer_settings[blockchain]['gasPrice'],\n                'sender': hot_wallets[blockchain]\n            })\n            try:\n                txid = handler.transfer(address, amount)['txid']\n            except Exception as e:\n                return WithdrawValidator.error_500(str(e))\n\n        elif blockchain in ['ETH', 'ETHRINKEBY', 'ETHROPSTEN']:\n            address = Web3.toChecksumAddress(address)\n            contract_address = Web3.toChecksumAddress(contract_address)\n            handler = Erc20.from_connection(connection, contract_address, erc20_abi)\n            handler.set_send_params({\n                'gasLimit': transfer_settings[blockchain]['gasLimit'],\n                'gasPrice': transfer_settings[blockchain]['gasPrice'],\n                'sender': hot_wallets[blockchain]\n            })\n            try:\n                txid = handler.transfer(address, amount)['txid']\n            except Exception as e:\n                return WithdrawValidator.error_500(str(e))\n        else:\n            return WithdrawValidator.error_403('Unsupported blockchain')\n\n        return {'txid': txid}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef relative_root_dir(self):\n        return Path(self.bundle.name) / str(self.created_at.date())", "response": "Build the relative root dir path for the bundle version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the full path to the file.", "response": "def full_path(self):\n        \"\"\"Return the full path to the file.\"\"\"\n        if Path(self.path).is_absolute():\n            return self.path\n        else:\n            return str(self.app_root / self.path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multiline_repr(text, special_chars=('\\n', '\"')):\n    try:\n        char = special_chars[0]\n    except IndexError:\n        text = ascii(text)[2 if PY2 else 1:-1]\n    else:\n        text = char.join(\n            multiline_repr(s, special_chars[1:]) for s in text.split(char))\n\n    return text", "response": "Return a string representation of a multiline string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove common indentation from each line in a text block.", "response": "def _dedent(text):\n        \"\"\"Remove common indentation from each line in a text block.\n\n        When text block is a single line, return text block. Otherwise\n        determine common indentation from last line, strip common\n        indentation from each line, and return text block consisting of\n        inner lines (don't include first and last lines since they either\n        empty or contain whitespace and are present in baselined\n        string to make them pretty and delineate the common indentation).\n\n        :param str text: text block\n        :returns: text block with common indentation removed\n        :rtype: str\n        :raises ValueError: when text block violates whitespace rules\n\n        \"\"\"\n        lines = text.split('\\n')\n\n        if len(lines) == 1:\n            indent = 0\n\n        elif lines[0].strip():\n            raise ValueError('when multiple lines, first line must be blank')\n\n        elif lines[-1].strip():\n            raise ValueError('last line must only contain indent whitespace')\n\n        else:\n            indent = len(lines[-1])\n\n            if any(line[:indent].strip() for line in lines):\n                raise ValueError(\n                    'indents must equal or exceed indent in last line')\n\n            lines = [line[indent:] for line in lines][1:-1]\n\n        return indent, '\\n'.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef z__update(self):\n        updates = []\n\n        for text in self._updates:\n\n            if self._AVOID_RAW_FORM:\n                text_repr = multiline_repr(text)\n                raw_char = ''\n            else:\n                text_repr = multiline_repr(text, RAW_MULTILINE_CHARS)\n\n                if len(text_repr) == len(text):\n                    raw_char = 'r' if '\\\\' in text_repr else ''\n                else:\n                    # must have special characters that required added backslash\n                    # escaping, use normal representation to get backslashes right\n                    text_repr = multiline_repr(text)\n                    raw_char = ''\n\n            # use triple double quote, except use triple single quote when\n            # triple double quote is present to avoid syntax errors\n            quotes = '\"\"\"'\n            if quotes in text:\n                quotes = \"'''\"\n\n            # Wrap with blank lines when multi-line or when text ends with\n            # characters that would otherwise result in a syntax error in\n            # the formatted representation.\n            multiline = self._indent or ('\\n' in text)\n            if multiline or text.endswith('\\\\') or text.endswith(quotes[0]):\n                update = raw_char + quotes + '\\n' + text_repr + '\\n' + quotes\n            else:\n                update = raw_char + quotes + text_repr + quotes\n\n            updates.append(update)\n\n        # sort updates so Python hash seed has no impact on regression test\n        update = '\\n'.join(sorted(updates))\n\n        indent = ' ' * self._indent\n\n        lines = ((indent + line) if line else '' for line in update.split('\\n'))\n\n        return '\\n'.join(lines).lstrip()", "response": "Return string with multiple triple quoted baseline strings when baseline had been compared multiple times against varying strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _atexit_callback(cls):\n        updated_scripts = {}\n\n        for baseline in cls._baselines_to_update:\n\n            if baseline.z__path.endswith('<stdin>'):\n                continue\n\n            try:\n                script = updated_scripts[baseline.z__path]\n            except KeyError:\n                script = Script(baseline.z__path)\n                updated_scripts[baseline.z__path] = script\n\n            script.add_update(baseline.z__linenum, baseline.z__update)\n\n        for key in sorted(updated_scripts):\n            script = updated_scripts[key]\n            script.update()\n\n        return updated_scripts", "response": "Create Python script copies with updated baselines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bundle(context, name):\n    if context.obj['db'].bundle(name):\n        click.echo(click.style('bundle name already exists', fg='yellow'))\n        context.abort()\n    new_bundle = context.obj['db'].new_bundle(name)\n    context.obj['db'].add_commit(new_bundle)\n\n    # add default version\n    new_version = context.obj['db'].new_version(created_at=new_bundle.created_at)\n    new_version.bundle = new_bundle\n    context.obj['db'].add_commit(new_version)\n\n    click.echo(click.style(f\"new bundle added: {new_bundle.name} ({new_bundle.id})\", fg='green'))", "response": "Add a new bundle."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a file to a bundle.", "response": "def file_cmd(context, tags, archive, bundle_name, path):\n    \"\"\"Add a file to a bundle.\"\"\"\n    bundle_obj = context.obj['db'].bundle(bundle_name)\n    if bundle_obj is None:\n        click.echo(click.style(f\"unknown bundle: {bundle_name}\", fg='red'))\n        context.abort()\n    version_obj = bundle_obj.versions[0]\n    new_file = context.obj['db'].new_file(\n        path=str(Path(path).absolute()),\n        to_archive=archive,\n        tags=[context.obj['db'].tag(tag_name) if context.obj['db'].tag(tag_name) else\n              context.obj['db'].new_tag(tag_name) for tag_name in tags]\n    )\n    new_file.version = version_obj\n    context.obj['db'].add_commit(new_file)\n    click.echo(click.style(f\"new file added: {new_file.path} ({new_file.id})\", fg='green'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tag(context: click.Context, file_id: int, tags: List[str]):\n    file_obj = context.obj['db'].file_(file_id)\n    if file_obj is None:\n        print(click.style('unable to find file', fg='red'))\n        context.abort()\n    for tag_name in tags:\n        tag_obj = context.obj['db'].tag(tag_name)\n        if tag_obj is None:\n            tag_obj = context.obj['db'].new_tag(tag_name)\n        elif tag_obj in file_obj.tags:\n            print(click.style(f\"{tag_name}: tag already added\", fg='yellow'))\n            continue\n        file_obj.tags.append(tag_obj)\n    context.obj['db'].commit()\n    all_tags = (tag.name for tag in file_obj.tags)\n    print(click.style(f\"file tags: {', '.join(all_tags)}\", fg='blue'))", "response": "Add tags to an existing file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nincluding files in existing bundle version.", "response": "def include_version(global_root: str, version_obj: models.Version, hardlink:bool=True):\n    \"\"\"Include files in existing bundle version.\"\"\"\n    global_root_dir = Path(global_root)\n    if version_obj.included_at:\n        raise VersionIncludedError(f\"version included on {version_obj.included_at}\")\n\n    # generate root directory\n    version_root_dir = global_root_dir / version_obj.relative_root_dir\n    version_root_dir.mkdir(parents=True, exist_ok=True)\n    log.info(f\"created new bundle version dir: {version_root_dir}\")\n\n    for file_obj in version_obj.files:\n        # hardlink file to the internal structure\n        file_obj_path = Path(file_obj.path)\n        new_path = version_root_dir / file_obj_path.name\n        if hardlink:\n            os.link(file_obj_path.resolve(), new_path)\n        else:\n            os.symlink(file_obj_path.resolve(), new_path)\n        log.info(f\"linked file: {file_obj.path} -> {new_path}\")\n        file_obj.path = str(new_path).replace(f\"{global_root_dir}/\", '', 1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate a checksum for a file.", "response": "def checksum(path):\n    \"\"\"Calculcate checksum for a file.\"\"\"\n    hasher = hashlib.sha1()\n    with open(path, 'rb') as stream:\n        buf = stream.read(BLOCKSIZE)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = stream.read(BLOCKSIZE)\n    return hasher.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef kwargs_only(func):\n    if hasattr(inspect, 'signature'):  # pragma: no cover\n        # Python 3\n        signature = inspect.signature(func)\n        first_arg_name = list(signature.parameters.keys())[0]\n    else:  # pragma: no cover\n        # Python 2\n        signature = inspect.getargspec(func)\n        first_arg_name = signature.args[0]\n\n    if first_arg_name in ('self', 'cls'):\n        allowable_args = 1\n    else:\n        allowable_args = 0\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if len(args) > allowable_args:\n            raise TypeError(\"{} should only be called with keyword args\".format(func.__name__))\n        return func(*args, **kwargs)\n\n    return wrapper", "response": "A decorator that ensures a function only accepts keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform preliminary non - db specific lookup checks and conversions", "response": "def get_prep_lookup(self, lookup_name, rhs):\n        \"\"\"\n        Perform preliminary non-db specific lookup checks and conversions\n        \"\"\"\n        if lookup_name == 'exact':\n            if not isinstance(rhs, Model):\n                raise FilteredGenericForeignKeyFilteringException(\n                    \"For exact lookup, please pass a single Model instance.\")\n\n        elif lookup_name in ['in', 'in_raw']:\n            if type(rhs) == QuerySet:\n                return rhs, None\n\n            if not is_iterable(rhs):\n                raise FilteredGenericForeignKeyFilteringException(\n                    \"For 'in' lookup, please pass an iterable or a QuerySet.\")\n\n        else:\n            raise FilteredGenericForeignKeyFilteringException(\n                \"Lookup %s not supported.\" % lookup_name)\n\n        return rhs, None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreceiving account by wallet", "response": "async def getaccountbywallet(**params):\n\t\"\"\"Receives account by wallet\n\tAccepts:\n\t- public key hex or checksum format\n\t\"\"\"\n\tif params.get(\"message\"):\n\t\tparams = json.loads(params.get(\"message\"))\n\n\tfor coinid in coin_ids:\n\n\t\tdatabase = client[coinid]\n\t\twallet_collection = database[settings.WALLET]\n\t\twallet = await wallet_collection.find_one({\"wallet\":params[\"wallet\"]})\n\t\tif not wallet:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdatabase = client[settings.DBNAME]\n\t\t\taccounts_collection = database[settings.ACCOUNTS]\n\t\t\taccount = await accounts_collection.find_one({\"id\":wallet[\"account_id\"]})\n\t\t\tif not account:\n\t\t\t\treturn {\"error\":404, \"reason\":\"Account was not found\"}\n\t\t\treturn {i:account[i] for i in account if i != \"_id\"}\n\telse:\n\t\treturn {\"error\":404, \"reason\":\"Account was not found\"}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def find_recent_news(self, **params):\n\t\t# Check if params is not empty\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required parameter does exist\n\t\tpublic_key = params.get(\"public_key\", None)\n\t\tif not public_key:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if current public_key does exist in database\n\t\taccount = await self.collection.find_one({\"public_key\": public_key})\n\t\tif not account:\n\t\t\treturn {\"error\":404, \"reason\":\"Current user not found\"}\n\n\t\t\n\t\t# Connect to news collection\n\t\tnews_db = client[settings.DBNAME]\n\t\tnews_collection = news_db[settings.NEWS]\n\t\t\n\t\tnews = [{i:new[i] for i in new if i != \"_id\"} \n\t\t\t\t\tasync for new in news_collection.find(\n\t\t\t\t\t\t{\"account_id\":account[\"id\"]}).sort([(\"$natural\", -1)])]\n\n\t\t\n\t\t# Set news amount to zero.\n\t\taccounts_collection = news_db[settings.ACCOUNTS]\n\t\tawait accounts_collection.find_one_and_update(\n\t\t\t\t\t\t{\"public_key\": params[\"public_key\"]},\n\t\t\t\t\t\t{\"$set\": {\"news_count\": 0}})\n\t\treturn news", "response": "Find recent news for account."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert news for account", "response": "async def insert_news(self, **params):\n\t\t\"\"\"Inserts news for account\n\t\tAccepts:\n\t\t\t- event_type\n\t\t\t- cid\n\t\t\t- access_string (of buyer)\n\t\t\t- buyer_pubkey\n\t\t\t- buyer address\n\t\t\t- owner address\n\t\t\t- price\n\t\t\t- offer type\n\t\t\t- coin ID\n\t\tReturns:\n\t\t\t- dict with result\n\t\t\"\"\"\n\t\tlogging.debug(\"\\n\\n [+] -- Setting news debugging.  \")\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\t\tlogging.debug(\"   ***      Params\")\n\t\tevent_type = params.get(\"event_type\")\n\t\tcid = params.get(\"cid\")\n\n\t\taccess_string = params.get(\"access_string\")\n\n\t\tbuyer_pubkey = params.get(\"buyer_pubkey\")\n\n\t\tbuyer_address = params.get(\"buyer_address\")\n\n\t\towneraddr = params.get(\"owneraddr\")\n\n\t\tprice = params.get(\"price\")\n\n\t\toffer_type = int(params.get(\"offer_type\", -1))\n\n\t\tcoinid = params.get(\"coinid\").upper()\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\tlogging.debug(\"\\n **   Coinid\")\n\t\tlogging.debug(coinid)\n\n\t\t# Get address of content owner and check if it exists\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\telse:\n\t\t\treturn {\"error\":400, \"reason\": \"Invalid coin ID\"}\n\n\t\towneraddr = await self.account.blockchain.ownerbycid(cid=cid)\n\n\t\t# Get sellers account\n\t\tseller = await getaccountbywallet(wallet=owneraddr)\n\t\tif \"error\" in seller.keys():\n\t\t\treturn seller\n\n\t\t# Connect to news table \n\t\tnews_collection = self.database[settings.NEWS]\n\n\t\t# Get sellers price\n\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\tif offer_type == 1:\n\t\t\tseller_price = await self.account.blockchain.getwriteprice(cid=cid)\n\t\telif offer_type == 0:\n\t\t\tseller_price = await self.account.blockchain.getreadprice(cid=cid)\n\n\t\t\n\t\trow = {\"offer_type\": self.account.ident_offer[offer_type], \n\t\t\t\t\"buyer_address\":buyer_address,\n\t\t\t\t\"cid\":cid,\n\t\t\t\t\"access_string\":access_string,\n\t\t\t\t\"buyer_pubkey\": buyer_pubkey,\n\t\t\t\t\"seller_price\": seller_price,\n\t\t\t\t\"buyer_price\": price,\n\t\t\t\t\"account_id\": seller[\"id\"],\n\t\t\t\t\"event_type\": event_type,\n\t\t\t\t\"coinid\":coinid}\n\n\t\tlogging.debug(\"\\n **  Inserting row\")\n\t\tlogging.debug(row)\n\t\t\n\t\t# Update counter inside accounts table\n\t\tdatabase = client[settings.DBNAME]\n\t\tcollection = database[settings.ACCOUNTS]\n\t\tawait collection.find_one_and_update(\n\t\t\t\t\t\t{\"id\": int(seller[\"id\"])},\n\t\t\t\t\t\t{\"$inc\": {\"news_count\": 1}})\n\t\tawait collection.find_one({\"id\":int(seller[\"id\"])})\n\t\t\n\t\t# Insert data to news table\n\t\tawait news_collection.insert_one(row)\n\n\t\tlogging.debug(\"\\n ** Fresh news\")\n\t\tfresh = await collection.find_one({\"buyer_address\":buyer_address,\n\t\t\t\t\t\t\t\t\t\t\t\t\"cid\":cid})\n\t\tlogging.debug(fresh)\n\n\t\treturn {\"result\":\"ok\"}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def insert_offer(self, **params):\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required fields exists\n\t\tcid = int(params.get(\"cid\", 0))\n\t\ttxid = params.get(\"txid\")\n\t\tcoinid = params.get(\"coinid\")\n\t\tpublic_key = params.get(\"public_key\")\n\n\t\tdatabase = client[coinid]\n\t\toffer_collection = database[settings.OFFER]\n\t\tawait offer_collection.insert_one({\"cid\":cid, \"txid\":txid, \n\t\t\t\t\t\t\t\t\t\t\t\"confirmed\":None, \"coinid\":coinid, \n\t\t\t\t\t\t\t\t\t\t\t\"public_key\":public_key})\n\n\t\treturn {\"result\":\"ok\"}", "response": "Inserts new offer to database"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an offer by account id and cid", "response": "async def get_offer(self, **params):\n\t\t\"\"\"Receives offer data if exists\n\t\tAccepts:\n\t\t\t- cid\n\t\t\t- buyer address\n\t\t\t- coin ID\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required fields exists\n\t\tcid = int(params.get(\"cid\", 0))\n\t\tcoinid = params.get(\"coinid\")\n\t\tbuyer_address = params.get(\"buyer_address\")\n\t\t\n\t\t# Check if required fileds \n\t\tif not all([cid, buyer_address, coinid]):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\t\t\n\t\t# Get buyer address row from database\n\t\tdatabase = client[coinid]\n\t\twallet_collection = database[settings.WALLET]\n\t\twallet = await wallet_collection.find_one({\"wallet\":buyer_address})\n\t\tif not wallet:\n\t\t\treturn {\"error\":404, \"reason\":\"Buyer address not found\"}\n\t\t\n\t\t# Try to find offer with account id and cid\n\t\toffer_collection = database[settings.OFFER]\n\t\toffer = await offer_collection.find_one(\n\t\t\t\t\t\t\t{\"account_id\":int(wallet[\"account_id\"]),\n\t\t\t\t\t\t\t\"cid\":int(cid)})\n\n\t\t# If current offer exists avoid creating a new one\n\t\tif not offer:\n\t\t\treturn {\"error\":404, \"reason\": \"Current offer not found\"}\n\t\telse:\n\t\t\toffer[\"coinid\"] = coinid\n\t\t\treturn {i:offer[i] for i in offer if i != \"_id\"}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get_offers(self, **params):\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tcid = params.get(\"cid\")\n\t\tpublic_key = params.get(\"public_key\")\n\t\tcoinid = params.get(\"coinid\")\n\n\n\t\t# Get all input offers by cid\n\t\tif cid and coinid:\n\t\t\tcid = int(cid)\n\t\t\tdatabase = client[coinid]\n\t\t\toffer_collection = database[settings.OFFER]\n\t\t\tcontent_collection = database[settings.CONTENT]\n\n\t\t\toffers = [{i:document[i] for i in document if i == \"confirmed\"} \n\t\t\t\t\t\tasync for document in offer_collection.find({\"cid\":cid, \"confirmed\":None})]\n\n\t\t# Get all output users offers\n\t\telif not cid:\n\t\t\tdatabase = client[coinid]\n\t\t\toffer_collection = database[settings.OFFER]\n\t\t\toffers = [{i:document[i] for i in document if i == \"confirmed\"} \n\t\t\t\t\t\tasync for document in offer_collection.find({\"public_key\":public_key, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"confirmed\":None})]\n\n\t\t# Return list with offers\n\t\treturn offers", "response": "Receives all users input by cid or output offers \n\tAccepts : public_key cid coinid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving an offer from the database", "response": "async def remove_offer(self, **params):\n\t\t\"\"\"Receives offfer after have deal\n\t\tAccepts:\n\t\t\t- cid\n\t\t\t- buyer address\n\t\t\t- coin ID\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required fields exists\n\t\tcid = int(params.get(\"cid\", 0))\n\t\tbuyer_address = params.get(\"buyer_address\")\n\t\tcoinid = params.get(\"coinid\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\t\n\t\t# Check if required fileds \n\t\tif not all([cid, buyer_address]):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\t\t\n\t\t# Try to find offer with account id and cid\t\n\t\toffer = await self.get_offer(cid=cid, buyer_address=buyer_address, coinid=coinid)\n\t\tif \"error\" in offer.keys():\n\t\t\treturn offer\n\n\t\t# Remove offer\n\t\tdatabase = client[coinid]\n\t\toffer_collection = database[settings.OFFER]\n\t\tawait offer_collection.delete_one(\n\t\t\t\t\t\t\t{\"account_id\":offer[\"account_id\"],\n\t\t\t\t\t\t\t\"cid\":cid})\n\t\treturn {\"result\": \"ok\"}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def update_offer(self, **params):\n\t\tlogging.debug(\"\\n\\n -- Update offer. \")\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required fields exists\n\t\ttxid = params.get(\"txid\")\n\t\tcoinid = params.get(\"coinid\").upper()\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\t# Try to find offer with account id and cid\n\t\tdatabase = client[coinid]\n\t\toffer_db = database[settings.OFFER]\n\t\toffer = await offer_db.find_one({\"txid\":txid})\n\t\tlogging.debug(\"\\n\\n -- Try to get offer. \")\n\t\tlogging.debug(offer)\n\t\tif not offer:\n\t\t\treturn {\"error\":404, \n\t\t\t\t\t\"reason\":\"Offer with txid %s not found\" % txid }\n\n\t\t# Update offer\n\t\tawait offer_db.find_one_and_update(\n\t\t\t\t\t\t\t{\"txid\":txid}, {\"$set\":{\"confirmed\":1}})\n\n\t\t# Get updated offer\n\t\tupdated = await offer_db.find_one({\"txid\":txid})\n\n\t\treturn {i:updated[i] for i in updated if i != \"_id\"}", "response": "Update an offer after transaction confirmation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def mailed_confirm(self, **params):\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required fields exists\n\t\tcid = params.get(\"cid\")\n\t\tbuyer_address = params.get(\"buyer_address\")\n\t\tprice = params.get(\"price\")\n\t\toffer_type = params.get(\"offer_type\")\n\t\tcoinid = params.get(\"coinid\").upper()\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\t\t# Check if required fileds \n\t\tif not all([cid, buyer_address, price]):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\n\n\n\t\t# Get content owner address\n\t\t#if coinid in settings.AVAILABLE_COIN_ID:\n\t\t#\tclient_bridge.endpoint = settings.bridges[coinid]\n\t\t#else:\n\t\t#\treturn {\"error\":400, \"reason\":\"Invalid coin ID\"}\n\t\t#owneraddr = await client_bridge.request(method_name=\"ownerbycid\", cid=cid)\n\n\n\t\t# Send appropriate mail to seller if exists\n\t\t#seller = await getaccountbywallet(wallet=owneraddr)\n\t\t#logging.debug(seller)\n\t\t#if \"error\" in seller.keys():\n\t\t#\treturn seller\n\t\t#if seller.get(\"email\"):\n\t\t#\temaildata = {\n\t\t#\t\t\"to\": seller[\"email\"],\n\t\t#\t\t\"subject\": \"Robin8 support\",\n\t \t#\t\t\"optional\": \"You`ve got a new offer from %s\" % seller[\"public_key\"]\n\t \t#\n\t\t#\t}\n\t\t#\tawait client_email.request(method_name=\"sendmail\", **emaildata)\n\n\t\t# Send news for seller\n\t\tbuyer = await getaccountbywallet(wallet=buyer_address) \n\t\tif \"error\" in buyer.keys():\n\t\t\tbuyer[\"public_key\"] = None\n\n\t\tnewsdata = {\n\t\t\t\"event_type\":\"made offer\",\n\t\t\t\"cid\": cid,\n\t\t\t\"access_string\":buyer[\"public_key\"],\n\t\t\t\"buyer_pubkey\":buyer[\"public_key\"],\n\t\t\t\"buyer_address\":buyer_address,\n\t\t\t#\"owneraddr\":owneraddr,\n\t\t\t\"price\": price,\n\t\t\t\"offer_type\": offer_type,\n\t\t\t\"coinid\":coinid\n\t\t}\n\t\tnews = await self.insert_news(**newsdata)\n\t\treturn {\"result\":\"ok\"}", "response": "Send appropriate mail to user after offer receiveing"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def get_contents(self, **params):\n\t\tlogging.debug(\"[+] -- Get contents\")\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\n\t\tif not params or not params.get(\"public_key\"):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Try to get account\n\t\taccount = await self.collection.find_one({\"public_key\":params[\"public_key\"]})\n\t\t# Return error if does not exist the one\n\t\tif not account:\n\t\t\treturn {\"error\":404, \"reason\":\"Get contents. Not found account\"}\n\n\t\tcontents = {i:[] for i in settings.AVAILABLE_COIN_ID}\n\t\tfor coinid in settings.AVAILABLE_COIN_ID:\n\t\t\tlogging.debug(coinid)\n\t\t\tdatabase = client[coinid]\n\t\t\tcontent_collection = database[settings.CONTENT]\n\t\t\tasync for document in content_collection.find({\"owner\":account[\"public_key\"]}):\n\t\t\t\tcontents[coinid].append((document[\"cid\"], document[\"txid\"]))\n\n\t\treturn contents", "response": "Retrieves all users content"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites users content to database", "response": "async def set_contents(self, **params):\n\t\t\"\"\"Writes users content to database\n\t\tAccepts:\n\t\t- public key (required)\n\t\t- content (required)\n\t\t- description\n\t\t- price\n\t\t- address\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\ttxid = params.get(\"txid\")\n\t\tpublic_key = params.get(\"public_key\")\n\t\t_hash = params.get(\"hash\")\n\t\tcoinid = params.get(\"coinid\")\n\t\taccess = params.get(\"access\")\n\t\tcid = params.get(\"cid\")\n\n\t\t# Try to get account\n\t\taccount = await self.collection.find_one({\"public_key\":public_key})\n\t\t# Return error if does not exist the one\n\t\tif not account:\n\t\t\treturn {\"error\":404, \"reason\":\"Account was not found\"}\n\n\t\tdatabase = client[coinid]\n\t\tcontent_collection = database[access]\n\t\tawait content_collection.insert_one({\n\t\t\t\t\t\t\t\t\"owner\": public_key,\n\t\t\t\t\t\t\t\t\"cid\":cid,\n\t\t\t\t\t\t\t\t\"txid\": txid, \n\t\t\t\t\t\t\t\t\"hash\": _hash\n\t\t\t\t\t\t})\n\t\tsuccess = await content_collection.find_one({\"txid\":txid})\n\t\tif not success:\n\t\t\treturn {\"error\":500, \"reason\":\"Error while writing content to database\"}\n\n\t\telse:\n\t\t\treturn {\"result\":\"ok\"}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating users content row Accepts: - txid - cid - description - write_price - read_price - confirmed - coinid", "response": "async def update_contents(self, **params):\n\t\t\"\"\"Updates users content row\n\t\tAccepts:\n\t\t- txid\n\t\t- cid\n\t\t- description\n\t\t- write_price\n\t\t- read_price\n\t\t- confirmed\n\t\t- coinid\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\ttxid = params.get(\"txid\")\n\n\t\tcoinid = params.get(\"coinid\").upper()\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\tdatabase = client[coinid]\n\t\tcontent_collection = database[settings.CONTENT]\n\n\t\tcontent = await content_collection.find_one({\"txid\":txid})\n\n\t\tif not content:\n\t\t\treturn {\"error\":404, \n\t\t\t\t\t\"reason\":\"Update content. Content with txid %s not found\" % txid}\n\n\t\tif content.get(\"hash\"):\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\t\tcid = await self.account.blockchain.getcid(hash=content[\"hash\"])\n\n\t\t\tawait content_collection.find_one_and_update({\"txid\":txid}, {\"$set\":{\"cid\":int(cid)}})\n\t\t\tawait content_collection.find_one_and_update({\"txid\":txid}, {\"$set\":{\"hash\":None}})\n\n\n\t\tupdated = await content_collection.find_one({\"txid\":txid})\n\n\t\treturn {i:updated[i] for i in updated if i != \"_id\"}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def set_access_string(self, **params):\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\n\t\tcid = int(params.get(\"cid\", \"0\"))\n\t\tseller_access_string = params.get(\"seller_access_string\")\n\t\tseller_pubkey = params.get(\"seller_pubkey\")\n\t\tcoinid = params.get(\"coinid\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\tdatabase = client[coinid]\n\t\tcollection = database[settings.CONTENT]\n\t\tcontent = await collection.find_one({\"cid\":cid})\n\n\t\tif not content:\n\t\t\treturn {\"error\":404, \"reason\":\"Content not found\"}\n\n\t\tif not all([cid, seller_access_string, seller_pubkey]):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tawait collection.find_one_and_update({\"cid\":cid},\n\t\t\t\t\t\t{\"$set\":{\"seller_access_string\":seller_access_string}})\n\n\t\tawait collection.find_one_and_update({\"cid\":cid},\n\t\t\t\t\t\t{\"$set\":{\"seller_pubkey\":seller_pubkey}})\n\n\t\tcontent = await collection.find_one({\"cid\":cid})\n\t\treturn {i:content[i] for i in content if i != \"_id\"}", "response": "Writes content access string to database \n\t"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreceiving all reviews by cid Accepts : cid - coinid - cid Accepts : cid - cid - coinid - cid - coinid - cid - cid - coinid - cid - cid - coinid - cid - cid - coinid", "response": "async def get_reviews(self, **params):\n\t\t\"\"\"Receives all reviews by cid\n\t\tAccepts:\n\t\t- cid\n\t\t- coinid\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tcid = params.get(\"cid\", 0)\n\t\tcoinid = params.get(\"coinid\")\n\t\tif not cid and not coinid:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed cid\"}\n\n\t\treviews = []\n\t\tdatabase = client[coinid]\n\t\tcollection = database[settings.REVIEW]\n\t\tasync for document in collection.find({\"confirmed\":None, \"cid\":int(cid)}):\n\t\t\treviews.append({i:document[i] for i in document if i == \"confirmed\"})\n\n\t\treturn reviews"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite review for content for content", "response": "async def set_review(self, **params):\n\t\t\"\"\"Writes review for content\n\t\tAccepts:\n\t\t- cid\n\t\t- review\n\t\t- public_key\n\t\t- rating\n\t\t- txid\n\t\t- coinid\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tcid = int(params.get(\"cid\", 0))\n\t\ttxid = params.get(\"txid\")\n\t\tcoinid = params.get(\"coinid\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\t\t\n\t\t# Get content\n\t\tdatabase = client[coinid]\n\t\tcontent_collection = database[settings.CONTENT]\n\t\tcontent = await content_collection.find_one({\"cid\":cid})\n\t\tif not content:\n\t\t\treturn {\"error\":404, \"reason\":\"Not found current content\"}\n\n\t\tdatabase = client[coinid]\n\t\treview_collection = database[settings.REVIEW]\t\t\n\t\tawait review_collection.insert_one({\"cid\":cid, \"confirmed\":None, \n\t\t\t\t\t\t\t\t\t\t\t\"txid\":txid, \"coinid\":coinid})\n\t\treturn {\"result\":\"ok\"}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates review after transaction confirmation", "response": "async def update_review(self, **params):\n\t\t\"\"\"Update review after transaction confirmation\n\t\tAccepts:\n\t\t\t- txid\n\t\t\t- coinid\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\t\t\n\t\t# Check if required fields exists\n\t\ttxid = params.get(\"txid\")\n\t\tcoinid = params.get(\"coinid\").upper()\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\t# Try to find offer with account id and cid\n\t\tdatabase = client[coinid]\n\t\tcollection = database[settings.REVIEW]\n\t\treview = await collection.find_one({\"txid\":txid})\n\t\tif not review:\n\t\t\treturn {\"error\":404, \n\t\t\t\t\t\"reason\":\"Review with txid %s not found\" % txid }\n\t\t\n\t\t# Update review\n\t\tawait collection.find_one_and_update(\n\t\t\t\t\t\t\t{\"txid\":txid}, {\"$set\":{\"confirmed\":1}})\n\t\t\n\t\t# Get updated offer\n\t\tupdated = await collection.find_one({\"txid\":txid})\n\n\t\treturn {i:updated[i] for i in updated if i != \"_id\"}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite deal to database", "response": "async def write_deal(self, **params):\n\t\t\"\"\"Writes deal to database\n\t\tAccepts:\n\t\t- cid\n\t\t- access_type\n\t\t- buyer public key\n\t\t- seller public key\n\t\t- price\n\t\t- coinid\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tcid = int(params.get(\"cid\", 0))\n\t\taccess_type = params.get(\"access_type\")\n\t\tbuyer = params.get(\"buyer\")\n\t\tseller = params.get(\"seller\")\n\t\tprice = params.get(\"price\")\n\t\tcoinid = params.get(\"coinid\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\tif not all([cid, access_type, buyer, seller, price]):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tdatabase = client[coinid]\n\t\tcollection = database[settings.DEAL]\n\t\tawait collection.insert_one({\n\t\t\t\t\"cid\":cid,\n\t\t\t\t\"access_type\": access_type,\n\t\t\t\t\"buyer\":buyer,\n\t\t\t\t\"seller\":seller,\n\t\t\t\t\"price\":price,\n\t\t\t\t\"coinid\":coinid\n\t\t\t})\n\t\tresult = await collection.find_one({\"cid\":cid, \"buyer\":buyer})\n\n\t\treturn {i:result[i] for i in result if i != \"_id\"}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def update_description(self, **params):\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Check if required fields exists\n\t\tcid = params.get(\"cid\")\n\t\tdescription = params.get(\"description\")\n\t\ttxid = params.get(\"txid\")\n\t\tcoinid = params.get(\"coinid\")\n\n\t\ttry:\n\t\t\tcoinid = coinid.replace(\"TEST\", \"\")\n\t\texcept:\n\t\t\tpass\n\n\t\t# Check if required fileds \n\t\tif not all([cid, description, txid, coinid]):\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Try to find offer with account id and cid\n\t\tdatabase = client[coinid]\n\t\tcollection = database[settings.CONTENT]\n\t\tcontent = await collection.find_one({\"cid\":int(cid)})\n\t\tif not content:\n\t\t\treturn {\"error\":404, \n\t\t\t\t\t\"reason\":\"Content with cid %s not found\" % cid }\n\n\t\t# Update offer\n\t\tawait collection.find_one_and_update(\n\t\t\t\t\t\t\t{\"cid\":int(cid)}, {\"$set\":{\"description\":description}})\n\t\tawait collection.find_one_and_update(\n\t\t\t\t\t\t\t{\"cid\":int(cid)}, {\"$set\":{\"confirmed\":None}})\n\t\tawait collection.find_one_and_update(\n\t\t\t\t\t\t\t{\"cid\":int(cid)}, {\"$set\":{\"txid\":txid}})\n\n\t\t# Get updated offer\n\t\tupdated = await collection.find_one({\"cid\":int(cid)})\n\n\t\treturn {i:updated[i] for i in updated if i != \"_id\"}", "response": "Update description of an offer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get_deals(self, **params):\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tbuyer = params.get(\"buyer\")\n\n\t\tif not buyer:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed public key\"}\n\n\t\tdeals = {i:[] for i in list(settings.bridges.keys())}\n\n\t\tfor coinid in list(settings.bridges.keys()):\n\t\t\tdatabase = client[coinid]\n\t\t\tcollection = database[settings.DEAL]\n\t\t\tasync for document in collection.find({\"owner\":buyer}):\n\t\t\t\tdeals[coinid].append((document[\"cid\"],document.get(\"txid\")))\n\t\treturn deals", "response": "Receives all users deals\n\tAccepts : buyer public key\n\t - buyer public key\n\t - buyer public key\n\tif not buyer public key\n\tif not buyer public key\n\tif not params. get"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def log_source(self, **params):\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\t# Insert new source if does not exists the one\n\n\t\tdatabase = client[settings.DBNAME]\n\t\tsource_collection = database[settings.SOURCE]\n\t\tawait source_collection.update({\"public_key\":params.get(\"public_key\")}, \n\t\t\t\t\t\t {\"$addToSet\":{\"source\":params.get(\"source\")}},\n\t\t\t\t\t\t upsert=True)\n\n\t\treturn {\"result\": \"ok\"}", "response": "Logging users request sources"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting transaction to database if message is not empty", "response": "async def log_transaction(self, **params):\n\t\t\"\"\"Writing transaction to database\n\t\t\"\"\"\n\t\tif params.get(\"message\"):\n\t\t\tparams = json.loads(params.get(\"message\", \"{}\"))\n\t\t\n\t\tif not params:\n\t\t\treturn {\"error\":400, \"reason\":\"Missed required fields\"}\n\n\t\tcoinid = params.get(\"coinid\")\n\n\t\tif not coinid in [\"QTUM\", \"PUT\"]:\n\t\t\treturn {\"error\":400, \"reason\": \"Missed or invalid coinid\"}\n\n\t\tdatabase = client[settings.TXS]\n\t\tsource_collection = database[coinid]\n\n\t\tawait source_collection.find_one_and_update({\"txid\":params.get(\"txid\")},{\"$set\":{\n\t\t\t\t\"blocknumber\":params.get(\"blocknumber\"),\n\t\t\t\t\"blockhash\":params.get(\"blockhash\"),\n\t\t\t\t\"gasLimit\":params.get(\"gasLimit\"),\n\t\t\t\t\"gasPrice\":params.get(\"gasPrice\"),\n\t\t\t}})\n\t\treturn {\"success\":True}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck a list of nodes e. g. function body", "response": "def _check_node_list(path, sample, template, start_enumerate=0):\n    \"\"\"Check a list of nodes, e.g. function body\"\"\"\n    if len(sample) != len(template):\n        raise ASTNodeListMismatch(path, sample, template)\n\n    for i, (sample_node, template_node) in enumerate(zip(sample, template), start=start_enumerate):\n        if callable(template_node):\n            # Checker function inside a list\n            template_node(sample_node, path+[i])\n        else:\n            assert_ast_like(sample_node, template_node, path+[i])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assert_ast_like(sample, template, _path=None):\n    if _path is None:\n        _path = ['tree']\n\n    if callable(template):\n        # Checker function at the top level\n        return template(sample, _path)\n\n    if not isinstance(sample, type(template)):\n        raise ASTNodeTypeMismatch(_path, sample, template)\n\n    for name, template_field in ast.iter_fields(template):\n        sample_field = getattr(sample, name)\n        field_path = _path + [name]\n        \n        if isinstance(template_field, list):\n            if template_field and (isinstance(template_field[0], ast.AST)\n                                     or callable(template_field[0])):\n                _check_node_list(field_path, sample_field, template_field)\n            else:\n                # List of plain values, e.g. 'global' statement names\n                if sample_field != template_field:\n                    raise ASTPlainListMismatch(field_path, sample_field, template_field)\n\n        elif isinstance(template_field, ast.AST):\n            assert_ast_like(sample_field, template_field, field_path)\n        \n        elif callable(template_field):\n            # Checker function\n            template_field(sample_field, field_path)\n\n        else:\n            # Single value, e.g. Name.id\n            if sample_field != template_field:\n                raise ASTPlainObjMismatch(field_path, sample_field, template_field)", "response": "Check that the sample AST matches the template."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all content for all bridges", "response": "async def get(self):\n\t\t\"\"\"\n\t\tAccepts:\n\t\t\twithout parameters\n\n\t\tReturns:\n\t\t\tlist of dictionaries with following fields:\n\t\t\t\t- \"description\" - str\n\t\t\t\t- \"read_access\" - int\n\t\t\t\t- \"write_access\" - int\n\t\t\t\t- \"cid\" - int\n\t\t\t\t- \"owneraddr\" - str\n\t\t\t\t- \"coinid\" - str\n\n\t\tVerified: False\n\t\t\"\"\"\n\t\tlogging.debug(\"\\n\\n All Content debugging --- \")\n\n\t\tpage = self.get_query_argument(\"page\", 1)\n\n\t\tcontents = []\n\n\t\tcoinids = list(settings.bridges.keys())\n\n\t\tlogging.debug(\"\\n\\n Coinids \")\n\t\tlogging.debug(coinids)\n\n\t\tfor coinid in coinids:\n\t\t\tlogging.debug(\"\\n [=] -- coinid\")\n\t\t\tlogging.debug(coinid)\n\n\t\t\tif coinids.index(coinid) == len(coinids) - 1:\n\t\t\t\tpaginator = Paginator(coinid=coinid, page=page, \n\t\t\t\t\tlimit=(settings.LIMIT//len(coinids))+(settings.LIMIT%len(coinids)))\n\t\t\telse:\n\t\t\t\tpaginator = Paginator(coinid=coinid, page=page, \n\t\t\t\t\t\t\t\t\tlimit=settings.LIMIT // len(coinids))\n\n\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\n\t\t\t\n\t\t\tcontent = await self.account.blockchain.getallcontent(\n\t\t\t\t\t\t\t\t\t\trange_=paginator.get_range())\n\n\t\t\tif isinstance(content, dict):\n\t\t\t\tif \"error\" in content.keys():\n\t\t\t\t\tcontinue\n\t\t\tcontents.extend(content)\n\t\t\n\t\tresponse = {\n\t\t\t\"profiles\":json.dumps(contents),\n\t\t}\n\t\ttry:\n\t\t\tresponse.update(paginator.get_pages())\n\t\texcept:\n\t\t\tpass\n\n\t\tself.write(json.dumps(response))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get(self, cid, coinid):\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\n\t\tmessage = json.loads(self.get_argument(\"message\", \"{}\"))\n\n\t\tpublic_key = message.get(\"public_key\")\n\n\t\t# Set bridge url\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\t# Get content\n\t\tcontent = await self.account.blockchain.getsinglecontent(cid=cid)\n\n\t\tif \"error\" in content.keys():\n\t\t\tself.set_status(content[\"error\"])\n\t\t\tself.write(content)\n\t\t\traise tornado.web.Finish \n\t\t# Get owners account\n\t\taccount = await self.account.getaccountbywallet(wallet=content[\"owneraddr\"])\n\t\tif \"error\" in account.keys():\n\t\t\tself.set_status(account[\"error\"])\n\t\t\tself.write(account)\n\t\t\traise tornado.web.Finish\n\n\t\t# Check if it is write or read access for content\n\t\tcids = await self.account.getuserscontent(public_key=public_key)\n\n\t\tdeals = await self.account.getdeals(buyer=public_key)\n\n\n\t\tif int(content[\"cid\"]) in [i[0] for i in cids.get(coinid,[])]:\n\t\t\tcontent[\"access_type\"] = \"write_access\"\n\n\t\telif int(content[\"cid\"]) in [i[0] for i in deals.get(coinid,[])]:\n\t\t\tcontent[\"access_type\"] = \"read_access\"\n\n\t\ttry:\n\t\t\toffer = await self.account.blockchain.getoffer(cid=cid, \n\t\t\t\t\t\t\tbuyer_address=self.account.validator[coinid](public_key))\n\n\t\t\tcontent[\"owner\"] = account.get(\"public_key\")\n\t\t\tcontent[\"seller_access_string\"] = offer.get(\"seller_access_string\")\n\t\t\tcontent[\"seller_pubkey\"] = offer.get(\"seller_public_key\")\n\t\texcept:\n\t\t\tpass\n\n\t\tself.write(content)", "response": "Receives content by content id and coin id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def post(self, public_key, coinid):\n\t\tlogging.debug(\"[+] -- Post content debugging. \")\n\t\t#if settings.SIGNATURE_VERIFICATION:\n\t\t#\tsuper().verify()\n\n\t\t# Define genesis variables\n\t\tif coinid in settings.bridges.keys():     # Define bridge url\n\t\t\towneraddr = self.account.validator[coinid](public_key)    # Define owner address\n\t\t\tlogging.debug(\"\\n\\n          Owner address\")\n\t\t\tlogging.debug(coinid)\n\t\t\tlogging.debug(owneraddr)\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\telse:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Invalid coinid\"})\n\t\t\traise tornado.web.Finish \n\n\n\t\t# Check if account exists\n\t\taccount = await self.account.getaccountdata(public_key=public_key)\n\t\tlogging.debug(\"\\n            Users account \")\n\t\tlogging.debug(account)\n\t\tif \"error\" in account.keys():\n\t\t\tself.set_status(account[\"error\"])\n\t\t\tself.write(account)\n\t\t\traise tornado.web.Finish\n\n\n\n\t\t# Get message from request \n\t\ttry:\n\t\t\tdata = json.loads(self.request.body)\n\t\texcept:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unexpected data format. JSON required\"})\n\t\t\traise tornado.web.Finish\n\n\t\tif isinstance(data[\"message\"], str):\n\t\t\tmessage = json.loads(data[\"message\"])\n\t\telif isinstance(data[\"message\"], dict):\n\t\t\tmessage = data[\"message\"]\n\t\tcus = message.get(\"cus\")\n\t\tdescription = message.get(\"description\")\n\t\tread_access = message.get(\"read_access\")\n\t\twrite_access = message.get(\"write_access\")\n\n\t\tif sys.getsizeof(cus) > 1000000:\n\t\t\tself.set_status(403)\n\t\t\tself.write({\"error\":400, \"reason\":\"Exceeded the content size limit.\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Set fee\n\t\tfee = await billing.upload_content_fee(cus=cus, owneraddr=owneraddr, \n\t\t\t\t\t\t\t\t\t\t\tdescription=description)\n\t\t\n\t\tif \"error\" in fee.keys():\n\t\t\tself.set_status(fee[\"error\"])\n\t\t\tself.write(fee)\n\t\t\traise tornado.web.Finish\n\n\t\t# Send request to bridge\n\t\tdata = {\"cus\":cus, \n\t\t\t\t\"owneraddr\":owneraddr, \n\t\t\t\t\"description\":description, \n\t\t\t\t\"read_price\":read_access,\n\t\t\t\t\"write_price\":write_access\n\t\t\t\t}\n\t\tresponse = await self.account.blockchain.makecid(**data)\n\t\tlogging.debug(\"\\n     Bridge makecid\")\n\t\tlogging.debug(response)\n\t\tif \"error\" in response.keys():\n\t\t\tself.set_status(400)\n\t\t\tself.write(response)\n\t\t\traise tornado.web.Finish\n\n\t\t# Write cid to database\n\t\tdb_content = await self.account.setuserscontent(public_key=public_key,hash=response[\"cus_hash\"],\n\t\t\t\t\t\t\tcoinid=coinid, txid=response[\"result\"][\"txid\"],access=\"content\")\n\t\tlogging.debug(\"\\n               Database content\")\n\t\tlogging.debug(db_content)\n\n\n\t\tresponse = {i:data[i] for i in data if i != \"cus\"}\n\t\tself.write(response)", "response": "This function is used to send a request to blockchain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating description for content", "response": "async def put(self, cid):\n\t\t\"\"\"Update description for content\n\n\t\tAccepts:\n\t\t\tQuery string args:\n\t\t\t\t- \"cid\" - int\n\t\t\tRequest body parameters:\n\t\t\t\t- message (signed dict):\n\t\t\t\t\t- \"description\" - str\n\t\t\t\t\t- \"coinid\" - str\n\n\t\tReturns:\n\t\t\tdict with following fields:\n\t\t\t\t- \"confirmed\": None\n\t\t\t\t- \"txid\" - str\n\t\t\t\t- \"description\" - str\n\t\t\t\t- \"content\" - str\n\t\t\t\t- \"read_access\" - int\n\t\t\t\t- \"write_access\" - int\n\t\t\t\t- \"cid\" - int\n\t\t\t\t- \"txid\" - str\n\t\t\t\t- \"seller_pubkey\" - str\n\t\t\t\t- \"seller_access_string\": None or str\n\t\t\n\t\tVerified: True\n\n\t\t\"\"\"\n\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\ttry:\n\t\t\tbody = json.loads(self.request.body)\n\t\texcept:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unexpected data format. JSON required\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Get data from signed message\n\t\tpublic_key = body.get(\"public_key\", None)\n\t\tif isinstance(body[\"message\"], str):\n\t\t\tmessage = json.loads(body[\"message\"])\n\t\telif isinstance(body[\"message\"], dict):\n\t\t\tmessage = body[\"message\"]\n\t\tdescr = message.get(\"description\")\n\t\tcoinid = message.get(\"coinid\")\n\n\t\tif not coinid in settings.bridges.keys():\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unknown coin id\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Check if all required data exists\n\t\tif not all([public_key, descr, coinid]):\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Missed required fields\"})\n\t\t\traise tornado.web.Finish\n\t\t\n\t\towneraddr = self.account.validator[coinid](public_key)\n\n\t\t# Get content owner\n\t\tresponse = await self.account.blockchain.ownerbycid(cid=cid)\n\t\tif isinstance(response, dict):\n\t\t\tif \"error\" in response.keys():\n\t\t\t\terror_code = response[\"error\"]\n\t\t\t\tself.set_status(error_code)\n\t\t\t\tself.write({\"error\":error_code, \"reason\":response[\"error\"]})\n\t\t\t\traise tornado.web.Finish\n\n\t\t# Check if current content belongs to current user\n\t\tif response != owneraddr:\n\t\t\tself.set_status(403)\n\t\t\tself.write({\"error\":403, \"reason\":\"Owner does not match.\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Set fee\n\t\tfee = await billing.update_description_fee(owneraddr=owneraddr,cid=cid, \n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription=descr)\n\n\t\t# Set bridge url\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\telse:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Invalid coinid\"})\n\t\t\traise tornado.web.Finish \n\t\t\n\t\t# Set description for content. Make request to the bridge\n\t\trequest = await self.account.blockchain.setdescrforcid(cid=cid, descr=descr, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\towneraddr=owneraddr)\n\t\tif \"error\" in request.keys():\n\t\t\tself.set_status(request[\"error\"])\n\t\t\tself.write(request)\n\t\t\traise tornado.web.Finish\n\n\t\tself.write({\"cid\":cid, \"description\":descr, \n\t\t\t\t\t\"coinid\":coinid, \"owneraddr\": owneraddr})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates price of current content", "response": "async def put(self, cid):\n\t\t\"\"\"Update price of current content\n\n\t\tAccepts:\n\t\t\tQuery string args:\n\t\t\t\t- \"cid\" - int\n\t\t\tRequest body params: \n\t\t\t\t- \"access_type\" - str\n\t\t\t\t- \"price\" - int\n\t\t\t\t- \"coinid\" - str\n\n\t\tReturns:\n\t\t\tdict with following fields:\n\t\t\t\t- \"confirmed\": None\n\t\t\t\t- \"txid\" - str\n\t\t\t\t- \"description\" - str\n\t\t\t\t- \"content\" - str\n\t\t\t\t- \"read_access\" - int\n\t\t\t\t- \"write_access\" - int\n\t\t\t\t- \"cid\" - int\n\t\t\t\t- \"txid\" - str\n\t\t\t\t- \"seller_pubkey\" - str\n\t\t\t\t- \"seller_access_string\": None or str\n\n\t\tVerified: True\n\n\t\t\"\"\" \n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\ttry:\n\t\t\tbody = json.loads(self.request.body)\n\t\texcept:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unexpected data format. JSON required\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Get data from signed message\t\n\t\tpublic_key = body.get(\"public_key\", None)\n\t\tif isinstance(body[\"message\"], str):\n\t\t\tmessage = json.loads(body[\"message\"])\n\t\telif isinstance(body[\"message\"], dict):\n\t\t\tmessage = body[\"message\"]\n\t\tprice = message.get(\"price\")\n\t\taccess_type = message.get(\"access_type\")\n\t\tcoinid = message.get(\"coinid\")\n\n\t\t# Check if required fields exists\n\t\tif not any([price, access_type, coinid]):\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Missed price and access type for content\"})\n\n\t\t# Set bridges url\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\telse:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Invalid coin ID\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Get public key hex or checksum format\n\t\tcheck = self.account.validator[coinid](public_key)\n\n\t\t# Get content owner address\n\t\towneraddr = await self.account.blockchain.ownerbycid(cid=cid)\n\t\tif isinstance(owneraddr, dict):\n\t\t\tif \"error\" in owneraddr.keys():\n\t\t\t\tself.set_status(404)\n\t\t\t\tself.write({\"error\":404, \"reason\":\"Owner not found.\"})\n\t\t\t\traise tornado.web.Finish\n\n\t\t# Check if current content belongs to current user\n\t\tif owneraddr != check:\n\t\t\tself.set_status(403)\n\t\t\tself.write({\"error\":403, \"reason\":\"Owner does not match.\"})\n\t\t\traise tornado.web.Finish\n\n\t\tresponse = {\"cid\":cid, \"coinid\":coinid}\n\n\t\t# Make setprice request to the bridge\n\t\tif access_type == \"write_price\":\n\t\t\tresult = await self.account.blockchain.setwriteprice(cid=cid, write_price=price)\n\t\t\tresponse[\"write_access\"] = result[\"price\"]\n\n\t\telif access_type == \"read_price\":\n\t\t\tresult = await self.account.blockchain.setreadprice(cid=cid, read_price=price)\n\t\t\tresponse[\"read_access\"] = result[\"price\"]\n\n\n\t\t# Fee\n\t\tfee = await billing.set_price_fee(cid=cid, price=price, owneraddr=owneraddr)\n\t\tif \"error\" in fee.keys():\n\t\t\tself.set_status(fee[\"error\"])\n\t\t\tself.write(fee)\n\t\t\traise tornado.web.Finish\n\n\t\tself.write(response)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def put(self, public_key):\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\t# Check if message contains required data\n\t\ttry:\n\t\t\tbody = json.loads(self.request.body)\n\t\texcept:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unexpected data format. JSON required\"})\n\t\t\traise tornado.web.Finish\n\t\t\t\n\t\tif isinstance(body[\"message\"], str):\n\t\t\tmessage = json.loads(body[\"message\"])\n\t\telif isinstance(body[\"message\"], dict):\n\t\t\tmessage = body[\"message\"]\n\t\tcid = int(message[\"offer_id\"].get(\"cid\", 0))\n\t\tbuyer_address = message[\"offer_id\"].get(\"buyer_address\")\n\t\tcoinid = message.get(\"coinid\")\n\n\t\tif not all([cid, buyer_address, coinid]):\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\": \"Missed required fields.\"})\n\t\t\traise tornado.web.Finish\n\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\telse:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Invalid coin ID\"})\n\t\t\traise tornado.web.Finish\n\n\t\tcheck = self.account.validator[coinid](public_key)\n\n\t\taccount = await self.account.getaccountdata(public_key=public_key)\n\t\tif \"error\" in account.keys():\n\t\t\terror_code = account[\"error\"]\n\t\t\tself.set_status(error_code)\n\t\t\tself.write(account)\n\t\t\traise tornado.web.Finish\n\t\n\t\t# Check if one of sellers or buyers rejects offer\n\t\towneraddr = await self.account.blockchain.ownerbycid(cid=cid)\n\t\thex_ = check\n\t\tif buyer_address != hex_ and owneraddr != hex_:\n\t\t\t# Avoid rejecting offer\n\t\t\tself.set_status(403)\n\t\t\tself.write({\"error\": 403, \"reason\":\"Forbidden. Offer does not belong to user.\"})\n\t\t\n\t\t# Reject offer\n\t\tresponse = await self.account.blockchain.rejectoffer(coinid=coinid, cid=cid, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuyer_address=buyer_address)\n\t\tif \"error\" in response.keys():\n\t\t\tself.set_status(response[\"error\"])\n\t\t\tself.write(response)\n\t\t\traise tornado.web.Finish\n\n\t\t# Get buyer for email sending\n\t\tbuyer = await self.account.getaccountbywallet(wallet=buyer_address)\n\t\tif \"error\" in buyer.keys():\n\t\t\tself.set_status(buyer[\"error\"])\n\t\t\tself.write(buyer)\n\t\t\traise tornado.web.Finish\n\t\n\t\tif buyer.get(\"email\"):\n\t\t\temaildata = {\n\t\t\t\t\"to\": buyer.get(\"email\"),\n\t\t\t\t\"subject\": \"Robin8 support\",\n     \t\t\t\"optional\": \"Your offer with cid %s was rejected.\" % cid\n\t\t\t}\n\t\t\tawait self.account.mailer.sendmail(**emaildata)\n\t\t\n\t\t# Undeposit balance\n\t\tprice = await self.account.blockchain.getwriteprice(cid=cid)\n\t\tcoinid = \"PUT\"\n\t\tawait self.account.balance.unfreeze(uid=buyer[\"id\"],coinid=coinid, \n\t\t\t\t\t\t\t\t\t\t\t\t\tamount=price)\n\n\t\tdel response[\"result\"]\n\t\tself.write(response)", "response": "Reject offer and unfreeze balance\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating new offer in blockchain", "response": "async def post(self, public_key=None):\n\t\t\"\"\"Creates new offer\n\n\t\tAccepts:\n\t\t\t- buyer public key\n\t\t\t- cid\n\t\t\t- buyer access string\n\t\tReturns:\n\t\t\t- offer parameters as dictionary\n\t\t\"\"\"\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\ttry:\n\t\t\tbody = json.loads(self.request.body)\n\t\texcept:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unexpected data format. JSON required\"})\n\t\t\traise tornado.web.Finish\n\t\tif isinstance(body[\"message\"], str):\n\t\t\tmessage = json.loads(body[\"message\"])\n\t\telif isinstance(body[\"message\"], dict):\n\t\t\tmessage = body[\"message\"]\n\t\tcid = message.get(\"cid\")\n\t\tread_price = message.get(\"price\")\n\t\tcoinid = message.get(\"coinid\")\n\t\tbuyer_access_string = message.get(\"buyer_access_string\")\n\t\n\t\tif not all([buyer_access_string, coinid, str(cid).isdigit()]):\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Missed required fields\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Set bridge url\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\telse:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Invalid coinid\"})\n\t\t\traise tornado.web.Finish \n\n\t\t# Get cid price from bridge\n\t\tif not read_price:\n\t\t\tread_price = await self.account.blockchain.getreadprice(cid=cid)\n\n\t\tbuyer_address = self.account.validator[coinid](public_key)\n\t\towneraddr = await self.account.blockchain.ownerbycid(cid=cid)\n\n\t\t# Check if public key exists\n\t\taccount = await self.account.getaccountdata(public_key=public_key)\n\t\tif \"error\" in account.keys():\n\t\t\t# If account does not exist\n\t\t\tself.set_status(account[\"error\"])\n\t\t\tself.write(account)\n\t\t\traise tornado.web.Finish\n\n\t\t#Get sellers balance\n\t\tbalances = await self.account.balance.get_wallets(coinid=coinid, uid=account[\"id\"])\n\n\t\t# Check if current content does not belong to current user\n\t\tif owneraddr == buyer_address:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \n\t\t\t\t\t\t\"reason\":\"Content belongs to current user\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Get difference with balance and price\n\t\tfor w in balances[\"wallets\"]:\n\t\t\tif \"PUT\" in w.values() or \"PUTTEST\" in w.values():\n\t\t\t\tbalance = w\n\n\t\tdifference = int(balance[\"amount_active\"]) - int(read_price)\n\t\tif difference < 0:\n\t\t\t# If Insufficient funds\n\t\t\tself.set_status(402)\n\t\t\tself.write({\"error\":402, \"reason\":\"Balance is not enough\"})\n\t\t\traise tornado.web.Finish\n\n\t\t# Send request to bridge\n\t\toffer_data = {\n\t\t\t\"cid\":cid,\n\t\t\t\"read_price\":read_price,\n\t\t\t\"offer_type\":0,\n\t\t\t\"buyer_address\": buyer_address,\n\t\t\t\"buyer_access_string\":buyer_access_string\n\t\t}\n\t\tresponse = await self.account.blockchain.makeoffer(**offer_data)\n\t\ttry:\n\t\t\tresponse[\"error\"]\n\t\texcept:\n\t\t\tpass\n\t\telse:\n\t\t\tself.set_status(response[\"error\"])\n\t\t\tself.write(response)\n\t\t\traise tornado.web.Finish\n\n\t\tawait self.account.insertoffer(cid=cid, txid=response[\"result\"][\"txid\"], \n\t\t\t\t\t\t\t\t\t\t\tcoinid=coinid, public_key=public_key)\n\t\t# Send e-mail to seller\n\t\tseller = await self.account.getaccountbywallet(wallet=owneraddr)\n\t\tif \"error\" in seller.keys():\n\t\t\tself.set_status(seller[\"error\"])\n\t\t\tself.write(seller)\n\t\t\traise tornado.web.Finish\n\n\t\tif seller.get(\"email\"):\n\t\t\temaildata = {\n\t\t\t\t\"to\": seller[\"email\"],\n\t\t\t\t\"subject\": \"Robin8 support\",\n     \t\t\t\"optional\": \"You`ve got an offer for content %s.\" % cid\n\t\t\t}\n\t\t\tawait self.account.mailer.sendmail(**emaildata)\n\n\n\t\t# Freeze price at balance\n\t\tcoinid = \"PUT\"\n\t\tawait self.account.balance.freeze(uid=account[\"id\"],coinid=coinid, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tamount=read_price)\n\n\t\t# Set fee\n\t\tfee = await billing.set_make_offer_fee(buyer_address=buyer_address)\n\t\tif \"error\" in fee.keys():\n\t\t\tself.set_status(fee[\"error\"])\n\t\t\tself.write(fee)\n\t\t\traise tornado.web.Finish\n\n\t\tresponse[\"offer_type\"] = \"read_access\"\n\t\tdel response[\"result\"]\t\t\n\n\t\tself.write(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get(self, cid, coinid):\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\n\n\t\treviews = await self.account.blockchain.getreviews(cid=cid)\n\t\tif isinstance(reviews, dict):\n\t\t\tif \"error\" in reviews:\n\t\t\t\tself.set_status(500)\n\t\t\t\tself.write(reviews)\n\t\t\t\traise tornado.web.Finish\n\n\t\tfor review in reviews:\n\t\t\treview[\"confirmed\"] = 1\n\n\t\tstorage_reviews = await self.account.getreviews(coinid=coinid, cid=cid)\n\n\t\tif isinstance(reviews, dict):\n\t\t\tif \"error\" in reviews.keys():\n\t\t\t\tself.set_status(reviews[\"error\"])\n\t\t\t\tself.write(reviews)\n\t\t\t\traise tornado.web.Finish\n\t\t\n\t\tself.write(json.dumps(reviews + storage_reviews))", "response": "Receives all contents reviews for a given coinid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sendmail(array):\n    username = 'root@robin8.io'\n    FROM = username\n    TO = [array[\"to\"]]\n    SUBJECT = array[\"subject\"]\n    # check on correct data in optional\n    if type(array[\"optional\"]) == str and array[\"optional\"]:\n        TEXT = array[\"optional\"]\n    else:\n        return \"Error: missed argument\"\n    # make template\n    message = \"\"\"From: %s\\nTo: %s\\nSubject: %s\\n\\n%s\"\"\" % (FROM, \", \".join(TO), SUBJECT, TEXT)\n    try:\n        server = smtplib.SMTP('localhost')\n        logging.info(server)\n        #server.ehlo()\n        #server.starttls()\n        # authorizing user, must setup your account\n        #server.login(username, password)\n        # send mail\n        server.sendmail(FROM, TO, message)\n        server.quit()\n        logging.info(message)\n        return \"Success\"\n    except:\n        return \"Error\"", "response": "function for read data in db and send mail\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def post(self):\n\t\tlogging.debug(\"\\n\\n[+] -- Account debugging. \")\n\t\t# Include signature verification mechanism\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\t# Save data at storage database\n\t\ttry:\n\t\t\tdata = json.loads(self.request.body)\n\t\texcept:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Unexpected data format. JSON required\"})\n\t\t\traise tornado.web.Finish\n\t\tmessage = data[\"message\"]\n\n\t\t# Create account\n\t\tnew_account = await self.account.createaccount(**data)\n\t\tlogging.debug(\"\\n\\n [+] -- New account debugging.\")\n\t\tlogging.debug(new_account[\"id\"])\n\t\tif \"error\" in new_account.keys():\n\t\t\t# Raise error if the one does exist\n\t\t\tself.set_status(new_account[\"error\"])\n\t\t\tself.write(new_account)\n\t\t\traise tornado.web.Finish\n\n\t\t# Receive balance from balance host\n\t\twallets = await self.account.balance.get_wallets(uid=new_account[\"id\"])\n\t\tif isinstance(wallets, dict):\n\t\t\tif \"error\" in wallets.keys():\n\t\t\t\tself.set_status(wallets[\"error\"])\n\t\t\t\tself.write(wallets)\n\t\t\t\traise tornado.web.Finish\n\n\t\t#Prepare response \n\t\tnew_account.update({\"href\": settings.ENDPOINTS[\"ams\"]+\"/\"+ new_account[\"public_key\"],\n\t\t\t\t\t\t\t\"wallets\": json.dumps(wallets[\"wallets\"])})\n\t\t# Send mail to user\n\t\tif new_account.get(\"email\"):\n\t\t\temail_data = {\n\t\t\t\t\"to\": new_account[\"email\"],\n\t        \t\"subject\": \"Robin8 Support\",\n\t         \t\"optional\": \"Your account was created on %s\" % settings.domain + new_account[\"href\"]\n\t        }\n\t\t\tawait self.account.mailer.sendmail(**email_data)\n\t\t# Response\n\t\tself.write(new_account)", "response": "Create new account and send it to the server"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def get(self, public_key):\n\t\t# Signature verification\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\t# Get users request source\n\t\tcompiler = re.compile(r\"\\((.*?)\\)\")\n\t\tmatch = compiler.search(self.request.headers.get(\"User-Agent\"))\n\t\ttry:\n\t\t\tsource = match.group(1)\n\t\texcept:\n\t\t\tsource = None\n\t\t# Write source to database\n\t\tawait self.account.logsource(public_key=public_key, source=source)\n\n\t\t# Get account\n\t\tlogging.debug(\"\\n\\n [+] -- Get account data.\")\n\t\tresponse = await self.account.getaccountdata(public_key=public_key)\n\t\tlogging.debug(\"\\n\")\n\t\tlogging.debug(response)\n\t\tlogging.debug(\"\\n\")\n\t\tif \"error\" in response.keys():\n\t\t\tself.set_status(response[\"error\"])\n\t\t\tself.write(response)\n\t\t\traise tornado.web.Finish\n\n\t\t# Receive balances from balance host\n\t\twallets = await self.account.balance.get_wallets(uid=response[\"id\"])\n\t\tif isinstance(wallets, dict):\n\t\t\tif \"error\" in wallets.keys():\n\t\t\t\tself.set_status(wallets[\"error\"])\n\t\t\t\tself.write(wallets)\n\t\t\t\traise tornado.web.Finish\n\t\t\n\t\t# Filter wallets\n\t\tresponse.update({\"wallets\":json.dumps(\n\t\t\t\t\t[i for i in wallets[\"wallets\"] \n\t\t\t\t\tif i.get(\"coinid\") not in [\"BTC\", \"LTC\", \"ETH\"]])})\n\t\t# Return account data\n\t\tself.write(response)", "response": "Receive account data\n\n\t\tAccepts:\n\t\t\tQuery string:\n\t\t\t\t- \"public_key\" - str\n\t\t\tQuery string params:\n\t\t\t\t- message ( signed dictionary ):\n\t\t\t\t\t- \"timestamp\" - str\n\t\n\t\tReturns:\n\t\t\t\t- \"device_id\" - str\n\t\t\t\t- \"phone\" - str\n\t\t\t\t- \"public_key\" - str\n\t\t\t\t- \"count\" - int  ( wallets amount )\n\t\t\t\t- \"level\" - int (2 by default)\n\t\t\t\t- \"news_count\" - int (0 by default)\n\t\t\t\t- \"email\" - str\n\t\t\t\t- \"wallets\" - list\n\t\t\n\t\tVerified: True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get(self, public_key):\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\tresponse = await self.account.getnews(public_key=public_key)\n\t\t# If we`ve got a empty or list with news \n\t\tif isinstance(response, list):\n\t\t\tself.write(json.dumps(response))\n\t\t\traise tornado.web.Finish\n\t\t# If we`ve got a message with error\n\t\telif isinstance(response, dict):\n\t\t\ttry:\n\t\t\t\terror_code = response[\"error\"]\n\t\t\texcept:\n\t\t\t\tdel response[\"account_id\"]\n\n\t\t\t\tself.write(response)\n\t\t\telse:\n\t\t\t\tself.set_status(error_code)\n\t\t\t\tself.write(response)\n\t\t\t\traise tornado.web.Finish", "response": "Receives public key looking up document id at storage and sending it to the balance server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get(self, public_key):\n\t\t# Sign-verifying functional\n\t\t#super().verify()\n\t\t# Get coinid\n\t\taccount = await self.account.getaccountdata(public_key=public_key)\n\t\tif \"error\" in account.keys():\n\t\t\tself.set_status(account[\"error\"])\n\t\t\tself.write(account)\n\t\t\traise tornado.web.Finish\n\n\n\n\t\toffers_collection = []\n\t\tfor coinid in settings.AVAILABLE_COIN_ID:\n\n\t\t\ttry:\n\t\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\t\texcept:\n\t\t\t\tcontinue\n\n\t\t\ttry:\n\t\t\t\toffers = await self.account.blockchain.getbuyeroffers( \n\t\t\t\t\t\t\t\tbuyer_address=self.account.validator[coinid](public_key))\n\t\t\t\tfor offer in offers:\n\t\t\t\t\toffer[\"type\"] = self.account.ident_offer[offer[\"type\"]]\n\t\n\t\t\t\tstorage_offers = await self.account.getoffers(coinid=coinid, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic_key=public_key)\n\n\t\t\texcept:\n\t\t\t\tcontinue\n\n\t\t\toffers_collection.extend(offers + storage_offers)\n\n\n\t\tself.write(json.dumps(offers_collection))", "response": "Get all users input and output offers for a given public key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve all users input and output offers for a given public key.", "response": "async def get(self, public_key):\n\t\t\"\"\"Retrieves all users input and output offers\n\t\tAccepts:\n\t\t- public key\n\t\t\"\"\"\n\t\t# Sign-verifying functional\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\tlogging.debug(\"\\n\\n --  Input offers debugging\")\n\n\t\tmessage = json.loads(self.get_argument(\"message\"))\n\t\tcid = message.get(\"cid\")\n\t\tcoinid = message.get(\"coinid\")\n\t\tif not cid:\n\t\t\tself.set_status(400)\n\t\t\tself.write({\"error\":400, \"reason\":\"Missed required fields.\"})\n\t\t\traise tornado.web.Finish\n\n\n\t\taccount = await self.account.getaccountdata(public_key=public_key)\n\t\tif \"error\" in account.keys():\n\t\t\tself.set_status(account[\"error\"])\n\t\t\tself.write(account)\n\t\t\traise tornado.web.Finish\n\n\t\tif coinid in settings.bridges.keys():\n\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\t\toffers = await self.account.blockchain.getcidoffers(cid=cid)\n\t\tlogging.debug(\"\\n\\n -- Offers\")\n\t\tlogging.debug(offers)\n\n\t\tif isinstance(offers, dict):\n\t\t\tself.set_status(offers[\"error\"])\n\t\t\tself.write(offers)\n\t\t\traise tornado.web.Finish\n\n\t\tfor offer in offers:\n\t\t\toffer[\"type\"] = self.account.ident_offer[offer[\"type\"]]\n\n\t\tstorage_offers = await self.account.getoffers(cid=cid, coinid=coinid)\n\t\tlogging.debug(\"\\n\\n -- Storage offers. \")\n\t\tlogging.debug(storage_offers)\n\n\t\tself.write(json.dumps(offers + storage_offers))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def get(self, public_key):\n\t\t# Sign-verifying functional\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\tpage = self.get_query_argument(\"page\", 1)\n\n\t\tcids = await self.account.getuserscontent(public_key=public_key)\n\n\t\tlogging.debug(\"\\n\\n Users cids\")\n\t\tlogging.debug(cids)\n\t\t\n\t\tif isinstance(cids, dict):\n\t\t\tif \"error\" in cids.keys():\n\t\t\t\tself.set_status(cids[\"error\"])\n\t\t\t\tself.write(cids)\n\t\t\t\traise tornado.web.Finish\n\n\t\tcontainer = []\n\n\t\tfor coinid in cids:\n\n\t\t\tlogging.debug(\"\\n [] -- coinid\")\n\t\t\tlogging.debug(coinid)\n\n\t\t\t#if list(cids.keys()).index(coinid) == len(cids) - 1:\n\t\t\t#\tpaginator = Paginator(coinid=coinid, page=page, \n\t\t\t#\t\tlimit=(settings.LIMIT//len(cids))+(settings.LIMIT%len(cids)), cids=cids)\n\t\t\t#else:\n\t\t\t#paginator = Paginator(coinid=coinid, page=page, \n\t\t\t#\t\t\t\t\t\tlimit=settings.LIMIT // len(cids), cids=cids)\n\n\t\t\tif coinid in settings.bridges.keys():\n\t\t\t\tlogging.debug(\" -- Coinid in \")\n\t\t\t\tlogging.debug(settings.bridges.keys())\n\t\t\t\tself.account.blockchain.setendpoint(settings.bridges[coinid])\n\n\t\t\t\tcontents = await self.account.blockchain.getuserscontent(\n\t\t\t\t\t\t\t\t\t\t\t\tcids=json.dumps(cids[coinid]))\n\t\t\t\tlogging.debug(\"\\n\\n -- Contents\")\n\t\t\t\tlogging.debug(contents)\n\t\t\t\tif isinstance(contents, dict):\n\t\t\t\t\tif \"error\" in contents.keys():\n\t\t\t\t\t\tcontinue\n\t\t\t\tcontainer.extend(contents)\n\n\t\t\t\tlogging.debug(\"\\n\\n -- Container 1\")\n\n\n\t\t\t\tlogging.debug(\"\\n\\n -- Container 2\")\n\t\t\t\tlogging.debug(container)\n\n\t\tresponse = {\n\t\t\t\"profiles\":json.dumps(container),\n\t\t\t}\n\t\ttry:\n\t\t\tresponse.update(paginator.get_pages())\n\t\texcept:\n\t\t\tpass\n\t\n\t\tself.write(json.dumps(response))", "response": "Retrieves all users contents"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend request to Balances server.", "response": "async def post(self):\n\t\t\"\"\"\n\t\tFunds from account to given address.\n\t\t1. Verify signature\n\t\t2. Freeze senders amount.\n\t\t3. Request to withdraw server.\n\t\t4. Call balances sub_frozen method.\n\n\t\tAccepts:\n\t\t\t- message [dict]:\n\t\t\t\t- coinid [string]\n\t\t\t\t- amount [integer]\n\t\t\t\t- address [string]\n\t\t\t\t- timestamp [float]\n\t\t\t\t- recvWindow [float]\n\t\t\t- public_key\n\t\t\t- signature\n\n\t\tReturns:\n\t\t\t- message [dict]:\n\t\t\t\t- coinid [string]\n\t\t\t\t- amount [integer]\n\t\t\t\t- address [string]\n\t\t\t\t- timestamp [float]\n\t\t\t\t- recvWindow [float]\n\t\t\t- public_key\n\t\t\t- signature\n\t\t\t- txid [string]\n\t\t\"\"\"\n\t\t# Sign-verifying functional\n\t\tif settings.SIGNATURE_VERIFICATION:\n\t\t\tsuper().verify()\n\n\t\tlogging.debug(\"\\n\\n[+] -- Withdraw debugging\")\n\t\t# Get data from requests body\n\t\tdata = json.loads(self.request.body)\n\t\tpublic_key = data.get(\"public_key\")\n\t\tsignature = data.get(\"signature\")\n\n\t\tif isinstance(data.get(\"message\"), str):\n\t\t\tmessage = json.loads(data[\"message\"])\n\t\telif isinstance(data.get(\"message\"), dict):\n\t\t\tmessage = data[\"message\"]\n\n\t\t# Get data from signed message\n\t\tcoinid = message.get(\"coinid\")\n\t\tamount = message.get(\"amount\")\n\t\taddress = message.get(\"address\")\n\t\ttimestamp = message.get(\"timestamp\")\n\t\trecvWindow = message.get(\"recvWindow\")\n\t\t# \n\t\tif not all([coinid, amount, address, public_key, \n\t\t\t\t\tsignature, timestamp, recvWindow]):\n\t\t\tdata.update({\"error\":400, \"reason\":\"Missed required fields. \"})\n\t\t\tself.set_status(400)\n\t\t\tself.write(data)\n\t\t\traise tornado.web.Finish\n\t\tlogging.debug(data)\n\n\t\t# Get account\n\t\taccount = await self.account.getaccountdata(public_key=public_key)\n\t\tif \"error\" in account.keys():\n\t\t\tdata.update(account)\n\t\t\tself.set_status(404)\n\t\t\tself.write(data)\n\t\t\traise tornado.web.Finish\n\t\tlogging.debug(\"\\n                Senders account\")\n\t\tlogging.debug(account)\n\n\n\t\t# Request to balance and call freeze method\n\t\tfee = await self.account.withdraw_fee(coinid)\n\n\t\tfreeze = await self.account.balance.freeze(uid=account[\"id\"], coinid=coinid,\n\t\t\t\t\t\t\t\t\t\t\t\t\tamount=amount + fee)\n\t\tlogging.debug(\"\\n           Frozen balance\")\n\t\tlogging.debug(freeze)\n\t\tif \"error\" in freeze.keys():\n\t\t\tdata.update(freeze)\n\t\t\tself.set_status(freeze[\"error\"])\n\t\t\tself.write(data)\n\t\t\traise tornado.web.Finish\n\n\t\t# Request to withdraw server\n\t\ttxid = await self.account.withdraw(amount=amount, coinid=coinid, \n\t\t\t\t\t\t\taddress=address)\n\t\tlogging.debug(\"\\n      Withdraw server response\")\n\t\tlogging.debug(txid)\n\n\t\t# Check if txid exists\n\t\tif \"error\" in txid.keys():\n\t\t\tawait self.account.balance.unfreeze(uid=account[\"id\"], coinid=coinid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tamount=amount + fee)\n\t\t\tdata.update(txid)\n\t\t\tself.set_status(500)\n\t\t\tself.write(data)\n\t\t\traise tornado.web.Finish\n\n\t\t# Add balance to recepient\n\t\t#add_active = await self.account.balance.add_active(address=address, coinid=coinid,\n\t\t#\t\t\t\t\t\t\t\t\t\t\t\t\tamount=amount)\n\t\t#if \"error\" in add_active.keys():\n\t\t#\tawait self.account.balance.unfreeze(uid=account[\"id\"], coinid=coinid,\n\t\t#\t\t\t\t\t\t\t\t\t\t\t\tamount=amount + fee)\n\t\t#\tdata.update(add_active)\n\t\t#\tself.set_status(add_active[\"error\"])\n\t\t#\tself.write(data)\n\t\t#\traise tornado.web.Finish\n\n\t\t# Submit amount from frozen balance\n\t\tsub_frozen = await self.account.balance.sub_frozen(uid=account[\"id\"], \n\t\t\t\t\t\t\t\t\t\t\t\t\tcoinid=coinid, amount=amount + fee)\n\t\tif \"error\" in sub_frozen.keys():\t\t\t\n\t\t\n\t\t\tdata.update(sub_frozen)\n\t\t\tself.set_status(sub_frozen[\"error\"])\n\t\t\tself.write(data)\n\t\t\traise tornado.web.Finish\n\t\tlogging.debug(\"\\n               Sub frozen\")\n\t\tlogging.debug(sub_frozen)\n\n\t\tawait self.account.save_transaction(txid=txid.get(\"txid\"), coinid=coinid,\n\t\t\t\t\t\t\t\t\t\t\t\t\tamount=amount, address=address)\n\n\t\t# Return txid\n\t\tdata.update(txid)\n\t\tself.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __get_supervisor(self):\n        options = supervisorctl.ClientOptions()\n        options.realize(args=['-c', self.supervisord_conf_path])\n        return supervisorctl.Controller(options).get_supervisor()", "response": "Return the supervisor proxy object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self):\n        configs, meta_changes = self.config_manager.determine_config_changes()\n        self._process_config_changes(configs, meta_changes)\n        self.supervisorctl('update')", "response": "Update the configuration of the server manager."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_object(self, data):\n        for key, value in data.items():\n            if isinstance(value, (str, type(u''))) and \\\n               self.strict_iso_match.match(value):\n                data[key] = dateutil.parser.parse(value)\n        return data", "response": "Parse the object data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getPiLambert(n):\n    mypi = piGenLambert()\n    result = []\n    if n > 0:\n        result += [next(mypi) for i in range(n)]\n    mypi.close()\n    return result", "response": "Returns a list containing first n digits of Pi\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract the contents of the archive to the specified directory.", "response": "def extract(self, destination):\n        \"\"\"Extracts the contents of the archive to the specifed directory.\n\n        Args:\n            destination (str):\n                Path to an empty directory to extract the files to.\n        \"\"\"\n\n        if os.path.exists(destination):\n            raise OSError(20, 'Destination exists', destination)\n\n        self.__extract_directory(\n            '.',\n            self.files['files'],\n            destination\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract a single directory to the specified directory on disk. Args: path (str): Relative (to the root of the archive) path of the directory to extract. files (dict): A dictionary of files from a *.asar file header. destination (str): The path to extract the files to.", "response": "def __extract_directory(self, path, files, destination):\n        \"\"\"Extracts a single directory to the specified directory on disk.\n\n        Args:\n            path (str):\n                Relative (to the root of the archive) path of the directory\n                to extract.\n\n            files (dict):\n                A dictionary of files from a *.asar file header.\n\n            destination (str):\n                The path to extract the files to.\n        \"\"\"\n\n        # assures the destination directory exists\n        destination_path = os.path.join(destination, path)\n        if not os.path.exists(destination_path):\n            os.makedirs(destination_path)\n\n        for name, contents in files.items():\n            item_path = os.path.join(path, name)\n\n            # objects that have a 'files' member are directories,\n            # recurse into them\n            if 'files' in contents:\n                self.__extract_directory(\n                    item_path,\n                    contents['files'],\n                    destination\n                )\n\n                continue\n\n            self.__extract_file(item_path, contents, destination)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __extract_file(self, path, fileinfo, destination):\n\n        if 'offset' not in fileinfo:\n            self.__copy_extracted(path, destination)\n            return\n\n        self.asarfile.seek(\n            self.__absolute_offset(fileinfo['offset'])\n        )\n\n        # TODO: read in chunks, ain't going to read multiple GB's in memory\n        contents = self.asarfile.read(\n            self.__absolute_offset(fileinfo['size'])\n        )\n\n        destination_path = os.path.join(destination, path)\n\n        with open(destination_path, 'wb') as fp:\n            fp.write(contents)\n\n        LOGGER.debug('Extracted %s to %s', path, destination_path)", "response": "Extracts the specified file to the specified destination directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __copy_extracted(self, path, destination):\n\n        unpacked_dir = self.filename + '.unpacked'\n        if not os.path.isdir(unpacked_dir):\n            LOGGER.warn(\n                'Failed to copy extracted file %s, no extracted dir',\n                path\n            )\n\n            return\n\n        source_path = os.path.join(unpacked_dir, path)\n\n        if not os.path.exists(source_path):\n            LOGGER.warn(\n                'Failed to copy extracted file %s, does not exist',\n                path\n            )\n\n            return\n\n        destination_path = os.path.join(destination, path)\n        shutil.copyfile(source_path, destination_path)", "response": "Copies a file that was already extracted to the destination directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(cls, filename):\n\n        asarfile = open(filename, 'rb')\n\n        # uses google's pickle format, which prefixes each field\n        # with its total length, the first field is a 32-bit unsigned\n        # integer, thus 4 bytes, we know that, so we skip it\n        asarfile.seek(4)\n\n        header_size = struct.unpack('I', asarfile.read(4))\n        if len(header_size) <= 0:\n            raise IndexError()\n\n        # substract 8 bytes from the header size, again because google's\n        # pickle format uses some padding here\n        header_size = header_size[0] - 8\n\n        # read the actual header, which is a json string, again skip 8\n        # bytes because of pickle padding\n        asarfile.seek(asarfile.tell() + 8)\n        header = asarfile.read(header_size).decode('utf-8')\n\n        files = json.loads(header)\n        return cls(filename, asarfile, files, asarfile.tell())", "response": "Opens a. asar file and creates a new instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures the payload is a list of values.", "response": "def value_from_datadict(self, data, files, name):\n        \"\"\"Ensure the payload is a list of values. In the case of a sub\n        form, we need to ensure the data is returned as a list and not a\n        dictionary.\n\n        When a dict is found in the given data, we need to ensure the data\n        is converted to a list perseving the field order.\n\n        \"\"\"\n        if name in data:\n            payload = data.get(name)\n            if isinstance(payload, (dict,)):\n                # Make sure we get the data in the correct roder\n                return [payload.get(f.name) for f in self.fields]\n            return payload\n        return super(FormFieldWidget, self).value_from_datadict(data, files, name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndecompress the value into a list of values.", "response": "def decompress(self, value):\n        \"\"\"\n        Retreieve each field value or provide the initial values\n        \"\"\"\n        if value:\n            return [value.get(field.name, None) for field in self.fields]\n        return [field.field.initial for field in self.fields]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_label(self, field, counter):\n        return '<label for=\"id_formfield_%s\" %s>%s</label>' % (\n            counter, field.field.required and 'class=\"required\"', field.label)", "response": "Format the label for each field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_output(self, rendered_widgets):\n        ret = [u'<ul class=\"formfield\">']\n        for i, field in enumerate(self.fields):\n            label = self.format_label(field, i)\n            help_text = self.format_help_text(field, i)\n            ret.append(u'<li>%s %s %s</li>' % (\n                label, rendered_widgets[i], field.help_text and help_text))\n\n        ret.append(u'</ul>')\n        return ''.join(ret)", "response": "This method will yeild all widgets grouped in a un - ordered list of all available modules"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the average sentiment of the document.", "response": "def sentiment(self):\n        \"\"\"\n        Returns average sentiment of document. Must have sentiment enabled in XML output.\n\n        :getter: returns average sentiment of the document\n        :type: float\n\n        \"\"\"\n        if self._sentiment is None:\n            results = self._xml.xpath('/root/document/sentences')\n            self._sentiment = float(results[0].get(\"averageSentiment\", 0)) if len(results) > 0 else None\n        return self._sentiment"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_sentences_dict(self):\n        if self._sentences_dict is None:\n            sentences = [Sentence(element) for element in self._xml.xpath('/root/document/sentences/sentence')]\n            self._sentences_dict = OrderedDict([(s.id, s) for s in sentences])\n        return self._sentences_dict", "response": "Returns sentence objects\n\n        :return: order dict of sentences\n        :rtype: collections.OrderedDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of Coreference classes", "response": "def coreferences(self):\n        \"\"\"\n        Returns a list of Coreference classes\n\n        :getter: Returns a list of coreferences\n        :type: list of corenlp_xml.coreference.Coreference\n\n        \"\"\"\n        if self._coreferences is None:\n            coreferences = self._xml.xpath('/root/document/coreference/coreference')\n            if len(coreferences) > 0:\n                self._coreferences = [Coreference(self, element) for element in coreferences]\n        return self._coreferences"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef id(self):\n        if self._id is None:\n            self._id = int(self._element.get('id'))\n        return self._id", "response": "get the ID attribute of the sentence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the sentiment of this sentence.", "response": "def sentiment(self):\n        \"\"\"\n        The sentiment of this sentence\n\n        :getter: Returns the sentiment value of this sentence\n        :type: int\n\n        \"\"\"\n        if self._sentiment is None:\n            self._sentiment = int(self._element.get('sentiment'))\n        return self._sentiment"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_tokens_dict(self):\n        if self._tokens_dict is None:\n            tokens = [Token(element) for element in self._element.xpath('tokens/token')]\n            self._tokens_dict = OrderedDict([(t.id, t) for t in tokens])\n        return self._tokens_dict", "response": "Accesses the tokens dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of subtrees corresponding all phrases matching a given phrase type", "response": "def subtrees_for_phrase(self, phrase_type):\n        \"\"\"\n        Returns subtrees corresponding all phrases matching a given phrase type\n\n        :param phrase_type: POS such as \"NP\", \"VP\", \"det\", etc.\n        :type phrase_type: str\n\n        :return: a list of NLTK.Tree.Subtree instances\n        :rtype: list of NLTK.Tree.Subtree\n\n        \"\"\"\n        return [subtree for subtree in self.parse.subtrees() if subtree.node.lower() == phrase_type.lower()]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef phrase_strings(self, phrase_type):\n        return [u\" \".join(subtree.leaves()) for subtree in self.subtrees_for_phrase(phrase_type)]", "response": "Returns a list of strings corresponding all phrases matching a given phrase type"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the parse string stored on the XML document", "response": "def parse_string(self):\n        \"\"\"\n        Accesses the S-Expression parse string stored on the XML document\n\n        :getter: Returns the parse string\n        :type: str\n\n        \"\"\"\n        if self._parse_string is None:\n            parse_text = self._element.xpath('parse/text()')\n            if len(parse_text) > 0:\n                self._parse_string = parse_text[0]\n        return self._parse_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the parse tree based on the S - expression parse string in the XML", "response": "def parse(self):\n        \"\"\"\n        Accesses the parse tree based on the S-expression parse string in the XML\n\n        :getter: Returns the NLTK parse tree\n        :type: nltk.Tree\n\n        \"\"\"\n        if self.parse_string is not None and self._parse is None:\n            self._parse = Tree.parse(self._parse_string)\n        return self._parse"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef basic_dependencies(self):\n        if self._basic_dependencies is None:\n            deps = self._element.xpath('dependencies[@type=\"basic-dependencies\"]')\n            if len(deps) > 0:\n                self._basic_dependencies = DependencyGraph(deps[0])\n        return self._basic_dependencies", "response": "Accesses basic dependencies from the XML output\n\n        is the name of the class that is used to access the basic dependencies of the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collapsed_dependencies(self):\n        if self._basic_dependencies is None:\n            deps = self._element.xpath('dependencies[@type=\"collapsed-dependencies\"]')\n            if len(deps) > 0:\n                self._basic_dependencies = DependencyGraph(deps[0])\n        return self._basic_dependencies", "response": "Gets the dependency graph for the collapsed dependencies for this sentence."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the dependency graph for collapsed and CC - processed dependencies.", "response": "def collapsed_ccprocessed_dependencies(self):\n        \"\"\"\n        Accesses collapsed, CC-processed dependencies\n\n        :getter: Returns the dependency graph for collapsed and cc processed dependencies\n        :type: corenlp_xml.dependencies.DependencyGraph\n\n        \"\"\"\n        if self._basic_dependencies is None:\n            deps = self._element.xpath('dependencies[@type=\"collapsed-ccprocessed-dependencies\"]')\n            if len(deps) > 0:\n                self._basic_dependencies = DependencyGraph(deps[0])\n        return self._basic_dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lemma(self):\n        if self._lemma is None:\n            lemmata = self._element.xpath('lemma/text()')\n            if len(lemmata) > 0:\n                self._lemma = lemmata[0]\n        return self._lemma", "response": "Lazy - loads the lemma for this word"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef character_offset_begin(self):\n        if self._character_offset_begin is None:\n            offsets = self._element.xpath('CharacterOffsetBegin/text()')\n            if len(offsets) > 0:\n                self._character_offset_begin = int(offsets[0])\n        return self._character_offset_begin", "response": "Gets the value of the beginning of the character offset in the xml."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef character_offset_end(self):\n        if self._character_offset_end is None:\n            offsets = self._element.xpath('CharacterOffsetEnd/text()')\n            if len(offsets) > 0:\n                self._character_offset_end = int(offsets[0])\n        return self._character_offset_end", "response": "Lazy - loads the character offset end node and returns the value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pos(self):\n        if self._pos is None:\n            poses = self._element.xpath('POS/text()')\n            if len(poses) > 0:\n                self._pos = poses[0]\n        return self._pos", "response": "Lazy - loads the part of speech tag for this word"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef speaker(self):\n        if self._speaker is None:\n            speakers = self._element.xpath('Speaker/text()')\n            if len(speakers) > 0:\n                self._speaker = speakers[0]\n        return self._speaker", "response": "Lazy - loads the speaker tag for this word"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _generate_iam_role_policy(self):\n        endpoints = self.config.get('endpoints')\n        queue_arns = []\n        for ep in endpoints:\n            for qname in endpoints[ep]['queues']:\n                qarn = 'arn:aws:sqs:%s:%s:%s' % (self.aws_region,\n                                                 self.aws_account_id, qname)\n                if qarn not in queue_arns:\n                    queue_arns.append(qarn)\n        pol = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Action\": \"logs:CreateLogGroup\",\n                    \"Resource\": \"arn:aws:logs:%s:%s:*\" % (\n                        self.aws_region, self.aws_account_id\n                    )\n                },\n                {\n                    \"Effect\": \"Allow\",\n                    \"Action\": [\n                        \"logs:CreateLogStream\",\n                        \"logs:PutLogEvents\"\n                    ],\n                    \"Resource\": [\n                        \"arn:aws:logs:%s:%s:log-group:%s:*\" % (\n                            self.aws_region, self.aws_account_id,\n                            '/aws/lambda/%s' % self.resource_name\n                        )\n                    ]\n                },\n                {\n                    'Effect': 'Allow',\n                    'Action': [\n                        'sqs:ListQueues'\n                    ],\n                    'Resource': '*'\n                },\n                {\n                    \"Effect\": \"Allow\",\n                    \"Action\": [\n                        \"sqs:GetQueueUrl\",\n                        \"sqs:SendMessage\"\n                    ],\n                    \"Resource\": sorted(queue_arns)\n                }\n            ]\n        }\n        self.tf_conf['resource']['aws_iam_role_policy']['role_policy'] = {\n            'name': self.resource_name,\n            'role': '${aws_iam_role.lambda_role.id}',\n            'policy': json.dumps(pol)\n        }", "response": "Generate the IAM Role policy for the Lambda role."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _generate_iam_invoke_role_policy(self):\n        invoke_pol = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Resource\": [\"*\"],\n                    \"Action\": [\"lambda:InvokeFunction\"]\n                }\n            ]\n        }\n        self.tf_conf['resource']['aws_iam_role_policy']['invoke_policy'] = {\n            'name': self.resource_name + '-invoke',\n            'role': '${aws_iam_role.invoke_role.id}',\n            'policy': json.dumps(invoke_pol)\n        }", "response": "Generate the IAM Role Invoke Policy for the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the IAM Role needed by the Lambda function.", "response": "def _generate_iam_role(self):\n        \"\"\"\n        Generate the IAM Role needed by the Lambda function.\n\n        Terraform name: aws_iam_role.lambda_role\n        \"\"\"\n        pol = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Action\": \"sts:AssumeRole\",\n                    \"Principal\": {\n                        \"Service\": \"lambda.amazonaws.com\"\n                    },\n                    \"Effect\": \"Allow\",\n                    \"Sid\": \"\"\n                }\n            ]\n        }\n\n        self.tf_conf['resource']['aws_iam_role'] = {}\n        self.tf_conf['resource']['aws_iam_role']['lambda_role'] = {\n            'name': self.resource_name,\n            'assume_role_policy': json.dumps(pol),\n        }\n        self.tf_conf['output']['iam_role_arn'] = {\n            'value': '${aws_iam_role.lambda_role.arn}'\n        }\n        self.tf_conf['output']['iam_role_unique_id'] = {\n            'value': '${aws_iam_role.lambda_role.unique_id}'\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the IAM Role for API Gateway to invoke the function.", "response": "def _generate_iam_invoke_role(self):\n        \"\"\"\n        Generate the IAM Role for API Gateway to use to invoke the function.\n\n        Terraform name: aws_iam_role.invoke_role\n        :return:\n        \"\"\"\n\n        invoke_assume = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Action\": \"sts:AssumeRole\",\n                    \"Principal\": {\n                        \"Service\": \"apigateway.amazonaws.com\"\n                    },\n                    \"Effect\": \"Allow\",\n                    \"Sid\": \"\"\n                }\n            ]\n        }\n        self.tf_conf['resource']['aws_iam_role']['invoke_role'] = {\n            'name': self.resource_name + '-invoke',\n            'assume_role_policy': json.dumps(invoke_assume),\n        }\n        self.tf_conf['output']['iam_invoke_role_arn'] = {\n            'value': '${aws_iam_role.invoke_role.arn}'\n        }\n        self.tf_conf['output']['iam_invoke_role_unique_id'] = {\n            'value': '${aws_iam_role.invoke_role.unique_id}'\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the lambda function and its IAM role and add to self. tf_conf", "response": "def _generate_lambda(self):\n        \"\"\"\n        Generate the lambda function and its IAM role, and add to self.tf_conf\n        \"\"\"\n        self.tf_conf['resource']['aws_lambda_function']['lambda_func'] = {\n            'filename': 'webhook2lambda2sqs_func.zip',\n            'function_name': self.resource_name,\n            'role': '${aws_iam_role.lambda_role.arn}',\n            'handler': 'webhook2lambda2sqs_func.webhook2lambda2sqs_handler',\n            'source_code_hash': '${base64sha256(file('\n                                '\"webhook2lambda2sqs_func.zip\"))}',\n            'description': self.description,\n            'runtime': 'python2.7',\n            'timeout': 120\n        }\n        self.tf_conf['output']['lambda_func_arn'] = {\n            'value': '${aws_lambda_function.lambda_func.arn}'\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects to the AWS IAM API and set the account ID and region name.", "response": "def _set_account_info(self):\n        \"\"\"\n        Connect to the AWS IAM API via boto3 and run the GetUser operation\n        on the current user. Use this to set ``self.aws_account_id`` and\n        ``self.aws_region``.\n        \"\"\"\n        if 'AWS_DEFAULT_REGION' in os.environ:\n            logger.debug('Connecting to IAM with region_name=%s',\n                         os.environ['AWS_DEFAULT_REGION'])\n            kwargs = {'region_name': os.environ['AWS_DEFAULT_REGION']}\n        elif 'AWS_REGION' in os.environ:\n            logger.debug('Connecting to IAM with region_name=%s',\n                         os.environ['AWS_REGION'])\n            kwargs = {'region_name': os.environ['AWS_REGION']}\n        else:\n            logger.debug('Connecting to IAM without specified region')\n            kwargs = {}\n        conn = client('iam', **kwargs)\n        self.aws_account_id = conn.get_user()['User']['Arn'].split(':')[4]\n        # region\n        conn = client('lambda', **kwargs)\n        self.aws_region = conn._client_config.region_name\n        logger.info('Found AWS account ID as %s; region: %s',\n                    self.aws_account_id, self.aws_region)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the full configuration for the API Gateway and add to self. tf_conf", "response": "def _generate_api_gateway(self):\n        \"\"\"\n        Generate the full configuration for the API Gateway, and add to\n        self.tf_conf\n        \"\"\"\n        self.tf_conf['resource']['aws_api_gateway_rest_api']['rest_api'] = {\n            'name': self.resource_name,\n            'description': self.description\n        }\n        self.tf_conf['output']['rest_api_id'] = {\n            'value': '${aws_api_gateway_rest_api.rest_api.id}'\n        }\n        # finally, the deployment\n        \"\"\"\n        @NOTE Currently, Terraform can't enable metrics collection,\n        request logging or rate limiting on API Gateway services.\n\n        @TODO update this when\n        <https://github.com/hashicorp/terraform/issues/6612> is fixed.\n\n        @see https://github.com/jantman/webhook2lambda2sqs/issues/7\n        @see https://github.com/jantman/webhook2lambda2sqs/issues/16\n        \"\"\"\n        self.tf_conf['output']['base_url'] = {\n            'value': 'https://${aws_api_gateway_rest_api.rest_api.id}.'\n                     'execute-api.%s.amazonaws.com/%s/' % (\n                         self.aws_region, self.config.stage_name)\n        }\n        # generate the endpoint configs\n        endpoints = self.config.get('endpoints')\n        for ep in sorted(endpoints.keys()):\n            self._generate_endpoint(ep, endpoints[ep]['method'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate the API Gateway Deployment and Stage", "response": "def _generate_api_gateway_deployment(self):\n        \"\"\"\n        Generate the API Gateway Deployment/Stage, and add to self.tf_conf\n        \"\"\"\n        # finally, the deployment\n        # this resource MUST come last\n        dep_on = []\n        for rtype in sorted(self.tf_conf['resource'].keys()):\n            for rname in sorted(self.tf_conf['resource'][rtype].keys()):\n                dep_on.append('%s.%s' % (rtype, rname))\n        self.tf_conf['resource']['aws_api_gateway_deployment']['depl'] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'description': self.description,\n            'stage_name': self.config.stage_name,\n            'depends_on': dep_on\n        }\n        self.tf_conf['output']['deployment_id'] = {\n            'value': '${aws_api_gateway_deployment.depl.id}'\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the configuration for a single endpoint.", "response": "def _generate_endpoint(self, ep_name, ep_method):\n        \"\"\"\n        Generate configuration for a single endpoint (this is many resources)\n\n        Terraform Names:\n\n        - aws_api_gateway_resource: {ep_name}\n        - aws_api_gateway_method: {ep_name}_{ep_method}\n\n        :param ep_name: endpoint name (path component)\n        :type ep_name: str\n        :param ep_method: HTTP method for the endpoint\n        :type ep_method: str\n        \"\"\"\n        ep_method = ep_method.upper()\n        self.tf_conf['resource']['aws_api_gateway_resource'][ep_name] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'parent_id':\n                '${aws_api_gateway_rest_api.rest_api.root_resource_id}',\n            'path_part': ep_name\n        }\n        self.tf_conf['output']['%s_path' % ep_name] = {\n            'value': '${aws_api_gateway_resource.%s.path}' % ep_name\n        }\n        self.tf_conf['resource']['aws_api_gateway_method'][\n            '%s_%s' % (ep_name, ep_method)] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'resource_id': '${aws_api_gateway_resource.%s.id}' % ep_name,\n            'http_method': ep_method,\n            'authorization': 'NONE',\n            # @TODO: request_models ?\n            # @TODO: request_parameters_in_json ?\n        }\n        self.tf_conf['resource']['aws_api_gateway_method_response'][\n            '%s_%s_202' % (ep_name, ep_method)] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'resource_id': '${aws_api_gateway_resource.%s.id}' % ep_name,\n            'http_method': ep_method,\n            'status_code': 202,\n            'response_models': {\n                'application/json':\n                    '${aws_api_gateway_model.successmessage.name}',\n            },\n            'depends_on': [\n                'aws_api_gateway_method.%s_%s' % (ep_name, ep_method)\n            ]\n        }\n        self.tf_conf['resource']['aws_api_gateway_method_response'][\n            '%s_%s_500' % (ep_name, ep_method)] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'resource_id': '${aws_api_gateway_resource.%s.id}' % ep_name,\n            'http_method': ep_method,\n            'status_code': 500,\n            'response_models': {\n                'application/json':\n                    '${aws_api_gateway_model.errormessage.name}',\n            },\n            'depends_on': [\n                'aws_api_gateway_method.%s_%s' % (ep_name, ep_method)\n            ]\n        }\n\n        self.tf_conf['resource']['aws_api_gateway_integration'][\n            '%s_%s_integration' % (ep_name, ep_method)] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'resource_id': '${aws_api_gateway_resource.%s.id}' % ep_name,\n            'http_method': ep_method,\n            'type': 'AWS',\n            'uri': 'arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/'\n                   'functions/${aws_lambda_function.lambda_func.arn}'\n                   '/invocations',\n            'credentials': '${aws_iam_role.invoke_role.arn}',\n            'integration_http_method': 'POST',\n            'request_templates': request_model_mapping\n            # @TODO:\n            # request_parameters_in_json\n            # integrationResponses\n        }\n\n        self.tf_conf['resource']['aws_api_gateway_integration_response'][\n            '%s_%s_successResponse' % (ep_name, ep_method)] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'resource_id': '${aws_api_gateway_resource.%s.id}' % ep_name,\n            'http_method': ep_method,\n            'status_code': 202,\n            'response_templates': response_model_mapping['success'],\n            'depends_on': [\n                'aws_api_gateway_method_response.%s_%s_202' % (\n                    ep_name, ep_method),\n                'aws_api_gateway_integration.%s_%s_integration' % (\n                    ep_name, ep_method)\n            ]\n        }\n        self.tf_conf['resource']['aws_api_gateway_integration_response'][\n            '%s_%s_errorResponse' % (ep_name, ep_method)] = {\n            'rest_api_id': '${aws_api_gateway_rest_api.rest_api.id}',\n            'resource_id': '${aws_api_gateway_resource.%s.id}' % ep_name,\n            'http_method': ep_method,\n            'status_code': 500,\n            'selection_pattern': '(^Failed.*)|(.*([Ee]xception|[Ee]rror).*)',\n            'response_templates': response_model_mapping['error'],\n            'depends_on': [\n                'aws_api_gateway_method_response.%s_%s_500' % (\n                    ep_name, ep_method),\n                'aws_api_gateway_integration.%s_%s_integration' % (\n                    ep_name, ep_method)\n            ]\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the full terraform configuration as a JSON string", "response": "def _get_config(self, func_src):\n        \"\"\"\n        Return the full terraform configuration as a JSON string\n\n        :param func_src: lambda function source\n        :type func_src: str\n        :return: terraform configuration\n        :rtype: str\n        \"\"\"\n        self._set_account_info()\n        self._generate_iam_role()\n        self._generate_iam_role_policy()\n        self._generate_iam_invoke_role()\n        self._generate_iam_invoke_role_policy()\n        self._generate_lambda()\n        self._generate_response_models()\n        self._generate_api_gateway()\n        self._generate_api_gateway_deployment()\n        self._generate_saved_config()\n        return pretty_json(self.tf_conf)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the function source to a zip file suitable for upload to Lambda.", "response": "def _write_zip(self, func_src, fpath):\n        \"\"\"\n        Write the function source to a zip file, suitable for upload to\n        Lambda.\n\n        Note there's a bit of undocumented magic going on here; Lambda needs\n        the execute bit set on the module with the handler in it (i.e. 0755\n        or 0555 permissions). There doesn't seem to be *any* documentation on\n        how to do this in the Python docs. The only real hint comes from the\n        source code of ``zipfile.ZipInfo.from_file()``, which includes:\n\n            st = os.stat(filename)\n            ...\n            zinfo.external_attr = (st.st_mode & 0xFFFF) << 16  # Unix attributes\n\n        :param func_src: lambda function source\n        :type func_src: str\n        :param fpath: path to write the zip file at\n        :type fpath: str\n        \"\"\"\n        # get timestamp for file\n        now = datetime.now()\n        zi_tup = (now.year, now.month, now.day, now.hour, now.minute,\n                  now.second)\n        logger.debug('setting zipinfo date to: %s', zi_tup)\n        # create a ZipInfo so we can set file attributes/mode\n        zinfo = zipfile.ZipInfo('webhook2lambda2sqs_func.py', zi_tup)\n        # set file mode\n        zinfo.external_attr = 0x0755 << 16\n        logger.debug('setting zipinfo file mode to: %s', zinfo.external_attr)\n        logger.debug('writing zip file at: %s', fpath)\n        with zipfile.ZipFile(fpath, 'w') as z:\n            z.writestr(zinfo, func_src)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate(self, func_src):\n        # write function source for reference\n        logger.warning('Writing lambda function source to: '\n                       './webhook2lambda2sqs_func.py')\n        with open('./webhook2lambda2sqs_func.py', 'w') as fh:\n            fh.write(func_src)\n        logger.debug('lambda function written')\n        # write upload zip\n        logger.warning('Writing lambda function source zip file to: '\n                       './webhook2lambda2sqs_func.zip')\n        self._write_zip(func_src, './webhook2lambda2sqs_func.zip')\n        logger.debug('lambda zip written')\n        # write terraform\n        logger.warning('Writing terraform configuration JSON to: '\n                       './webhook2lambda2sqs.tf.json')\n        with open('./webhook2lambda2sqs.tf.json', 'w') as fh:\n            fh.write(self._get_config(func_src))\n        logger.debug('terraform configuration written')\n        logger.warning('Completed writing lambda function and TF config.')", "response": "Generate TF config and write to. / webhook2lambda2sqs. tf. json and lambda function to. / webhook2lambda2sqs_func. py"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassert that there are no missing values in the DataFrame.", "response": "def none_missing(df, columns=None):\n    \"\"\"\n    Asserts that there are no missing values (NaNs) in the DataFrame.\n    \"\"\"\n    if columns is None:\n        columns = df.columns\n    assert not df[columns].isnull().any().any()\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef within_set(df, items=None):\n    for k, v in items.items():\n        if not df[k].isin(v).all():\n            raise AssertionError\n    return df", "response": "Assert that df is a subset of items\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef within_range(df, items=None):\n    for k, (lower, upper) in items.items():\n        if (lower > df[k]).any() or (upper < df[k]).any():\n            raise AssertionError\n    return df", "response": "Assert that a DataFrame is within a range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary of the zmanim the object represents.", "response": "def zmanim(self):\n        \"\"\"Return a dictionary of the zmanim the object represents.\"\"\"\n        return {key: self.utc_minute_timezone(value) for\n                key, value in self.get_utc_sun_time_full().items()}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef candle_lighting(self):\n        today = HDate(gdate=self.date, diaspora=self.location.diaspora)\n\n        tomorrow = HDate(gdate=self.date + dt.timedelta(days=1),\n                         diaspora=self.location.diaspora)\n\n        # If today is a Yom Tov or Shabbat, and tomorrow is a Yom Tov or\n        # Shabbat return the havdalah time as the candle lighting time.\n        if ((today.is_yom_tov or today.is_shabbat)\n                and (tomorrow.is_yom_tov or tomorrow.is_shabbat)):\n            return self._havdalah_datetime\n\n        # Otherwise, if today is Friday or erev Yom Tov, return candle\n        # lighting.\n        if tomorrow.is_shabbat or tomorrow.is_yom_tov:\n            return (self.zmanim[\"sunset\"]\n                    - dt.timedelta(minutes=self.candle_lighting_offset))\n        return None", "response": "Return the time for candle lighting or None if not applicable."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _havdalah_datetime(self):\n        if self.havdalah_offset == 0:\n            return self.zmanim[\"three_stars\"]\n        # Otherwise, use the offset.\n        return (self.zmanim[\"sunset\"]\n                + dt.timedelta(minutes=self.havdalah_offset))", "response": "Compute the havdalah time based on settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef havdalah(self):\n        today = HDate(gdate=self.date, diaspora=self.location.diaspora)\n        tomorrow = HDate(gdate=self.date + dt.timedelta(days=1),\n                         diaspora=self.location.diaspora)\n\n        # If today is Yom Tov or Shabbat, and tomorrow is Yom Tov or Shabbat,\n        # then there is no havdalah value for today. Technically, there is\n        # havdalah mikodesh l'kodesh, but that is represented in the\n        # candle_lighting value to avoid misuse of the havdalah API.\n        if today.is_shabbat or today.is_yom_tov:\n            if tomorrow.is_shabbat or tomorrow.is_yom_tov:\n                return None\n            return self._havdalah_datetime\n        return None", "response": "Return the time for havdalah."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the number of days since January 1 of the given year.", "response": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the local time for a given time UTC.", "response": "def utc_minute_timezone(self, minutes_from_utc):\n        \"\"\"Return the local time for a given time UTC.\"\"\"\n        from_zone = tz.gettz('UTC')\n        to_zone = self.location.timezone\n        utc = dt.datetime.combine(self.date, dt.time()) + \\\n            dt.timedelta(minutes=minutes_from_utc)\n        utc = utc.replace(tzinfo=from_zone)\n        local = utc.astimezone(to_zone)\n        return local"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_utc_sun_time_deg(self, deg):\n        gama = 0        # location of sun in yearly cycle in radians\n        eqtime = 0      # difference betwen sun noon and clock noon\n        decl = 0        # sun declanation\n        hour_angle = 0  # solar hour angle\n        sunrise_angle = math.pi * deg / 180.0  # sun angle at sunrise/set\n\n        # get the day of year\n        day_of_year = self.gday_of_year()\n\n        # get radians of sun orbit around earth =)\n        gama = 2.0 * math.pi * ((day_of_year - 1) / 365.0)\n\n        # get the diff betwen suns clock and wall clock in minutes\n        eqtime = 229.18 * (0.000075 + 0.001868 * math.cos(gama) -\n                           0.032077 * math.sin(gama) -\n                           0.014615 * math.cos(2.0 * gama) -\n                           0.040849 * math.sin(2.0 * gama))\n\n        # calculate suns declanation at the equater in radians\n        decl = (0.006918 - 0.399912 * math.cos(gama) +\n                0.070257 * math.sin(gama) -\n                0.006758 * math.cos(2.0 * gama) +\n                0.000907 * math.sin(2.0 * gama) -\n                0.002697 * math.cos(3.0 * gama) +\n                0.00148 * math.sin(3.0 * gama))\n\n        # we use radians, ratio is 2pi/360\n        latitude = math.pi * self.location.latitude / 180.0\n\n        # the sun real time diff from noon at sunset/rise in radians\n        try:\n            hour_angle = (math.acos(\n                math.cos(sunrise_angle) /\n                (math.cos(latitude) * math.cos(decl)) -\n                math.tan(latitude) * math.tan(decl)))\n        # check for too high altitudes and return negative values\n        except ValueError:\n            return -720, -720\n\n        # we use minutes, ratio is 1440min/2pi\n        hour_angle = 720.0 * hour_angle / math.pi\n\n        # get sunset/rise times in utc wall clock in minutes from 00:00 time\n        # sunrise / sunset\n        longitude = self.location.longitude\n        return int(720.0 - 4.0 * longitude - hour_angle - eqtime), \\\n            int(720.0 - 4.0 * longitude + hour_angle - eqtime)", "response": "Return the times in minutes from 00 : 00 ( utc ) for a given sun altitude in sunrise degrees."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_utc_sun_time_full(self):\n        # sunset and rise time\n        sunrise, sunset = self._get_utc_sun_time_deg(90.833)\n\n        # shaa zmanit by gara, 1/12 of light time\n        sun_hour = (sunset - sunrise) // 12\n        midday = (sunset + sunrise) // 2\n\n        # get times of the different sun angles\n        first_light, _ = self._get_utc_sun_time_deg(106.1)\n        talit, _ = self._get_utc_sun_time_deg(101.0)\n        _, first_stars = self._get_utc_sun_time_deg(96.0)\n        _, three_stars = self._get_utc_sun_time_deg(98.5)\n        mga_sunhour = (midday - first_light) / 6\n\n        res = dict(sunrise=sunrise, sunset=sunset, sun_hour=sun_hour,\n                   midday=midday, first_light=first_light, talit=talit,\n                   first_stars=first_stars, three_stars=three_stars,\n                   plag_mincha=sunset - 1.25 * sun_hour,\n                   stars_out=sunset + 18. * sun_hour / 60.,\n                   small_mincha=sunrise + 9.5 * sun_hour,\n                   big_mincha=sunrise + 6.5 * sun_hour,\n                   mga_end_shma=first_light + mga_sunhour * 3.,\n                   gra_end_shma=sunrise + sun_hour * 3.,\n                   mga_end_tfila=first_light + mga_sunhour * 4.,\n                   gra_end_tfila=sunrise + sun_hour * 4.,\n                   midnight=midday + 12 * 60.)\n        return res", "response": "Return a list of Jewish times for the given location."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cutoff(s, length=120):\n    if length < 5:\n        raise ValueError('length must be >= 5')\n    if len(s) <= length:\n        return s\n    else:\n        i = (length - 2) / 2\n        j = (length - 3) / 2\n        return s[:i] + '...' + s[-j:]", "response": "Cuts a given string if it is longer than a given length."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave changes to the file.", "response": "def save(self, reload=False):\n        \"\"\"Save changes to the file.\"\"\"\n        self.wrapper.raw.save()\n        if reload:\n            self.reload()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pprint(self, raw=False):\n        tags = self.wrapper if not raw else self.wrapper.raw\n        print u'{}:'.format(self.path)\n        names = tags.keys()\n        names.sort()\n        w = max(len(k) for k in names)\n        fmt = u'    {{:<{}}} : {{}}'.format(w)\n        for k in names:\n            v = tags[k]\n            try:\n                v = unicode(v)\n            except UnicodeDecodeError:\n                v = repr(v)\n            print fmt.format(k, cutoff(v, 100))", "response": "Print the metadata in a human - friendly form."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rebase(self, text, char='X'):\n        regexp = re.compile(r'\\b(%s)\\b' % '|'.join(self.collection),\n                            re.IGNORECASE | re.UNICODE)\n\n        def replace(m):\n            word = m.group(1)\n            return char * len(word)\n\n        return regexp.sub(replace, text)", "response": "Rebas text with stop words removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _loop_wrapper_func(func, args, shared_mem_run, shared_mem_pause, interval, sigint, sigterm, name,\n                       logging_level, conn_send, func_running, log_queue):\n    \"\"\"\n        to be executed as a separate process (that's why this functions is declared static)\n    \"\"\"\n    prefix = get_identifier(name) + ' '\n\n    global log\n    log = logging.getLogger(__name__+\".log_{}\".format(get_identifier(name, bold=False)))\n    log.setLevel(logging_level)\n    log.addHandler(QueueHandler(log_queue))\n  \n    sys.stdout = StdoutPipe(conn_send)\n\n    log.debug(\"enter wrapper_func\")\n\n    SIG_handler_Loop(sigint, sigterm, log, prefix)\n    func_running.value = True\n    \n    error = False\n\n    while shared_mem_run.value:\n        try:\n            # in pause mode, simply sleep\n            if shared_mem_pause.value:\n                quit_loop = False\n            else:\n                # if not pause mode -> call func and see what happens\n                try:\n                    quit_loop = func(*args)\n                except LoopInterruptError:\n                    raise\n                except Exception as e:\n                    log.error(\"error %s occurred in loop calling 'func(*args)'\", type(e))\n                    log.info(\"show traceback.print_exc()\\n%s\", traceback.format_exc())\n                    error = True\n                    break\n \n                if quit_loop is True:\n                    log.debug(\"loop stooped because func returned True\")\n                    break\n \n            time.sleep(interval)\n        except LoopInterruptError:\n            log.debug(\"quit wrapper_func due to InterruptedError\")\n            break\n\n    func_running.value = False\n    if error:\n        sys.exit(-1)\n    else:\n        log.debug(\"wrapper_func terminates gracefully\")\n    \n    # gets rid of the following warnings\n    #   Exception ignored in: <_io.FileIO name='/dev/null' mode='rb'>\n    #   ResourceWarning: unclosed file <_io.TextIOWrapper name='/dev/null' mode='r' encoding='UTF-8'>\n    try:\n        if mp.get_start_method() == \"spawn\":\n            sys.stdin.close()\n    except AttributeError:\n        pass", "response": "wrapper function for loop_wrapper_func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_stat_base(count_value, max_count_value, prepend, speed, tet, ttg, width, **kwargs):\n    raise NotImplementedError", "response": "A function that formats the progress information base of the current state of the current state of the current progress"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping for the show_stat_function function that is called by the show_stat_wrapper_timer function.", "response": "def _show_stat_wrapper_Progress(count, last_count, start_time, max_count, speed_calc_cycles, \n                                width, q, last_speed, prepend, show_stat_function, add_args,\n                                i, lock):\n    \"\"\"\n        calculate \n    \"\"\"\n    count_value, max_count_value, speed, tet, ttg, = Progress._calc(count, \n                                                                    last_count, \n                                                                    start_time, \n                                                                    max_count, \n                                                                    speed_calc_cycles, \n                                                                    q,\n                                                                    last_speed, \n                                                                    lock) \n    return show_stat_function(count_value, max_count_value, prepend, speed, tet, ttg, width, i, **add_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _show_stat_wrapper_multi_Progress(count, last_count, start_time, max_count, speed_calc_cycles, \n                                      width, q, last_speed, prepend, show_stat_function, len_, \n                                      add_args, lock, info_line, no_move_up=False):\n    \"\"\"\n        call the static method show_stat_wrapper for each process\n    \"\"\"\n#         print(ESC_BOLD, end='')\n#         sys.stdout.flush()\n    for i in range(len_):\n        _show_stat_wrapper_Progress(count[i], last_count[i], start_time[i], max_count[i], speed_calc_cycles, \n                                    width, q[i], last_speed[i], prepend[i], show_stat_function,\n                                    add_args, i, lock[i])\n    n = len_\n    if info_line is not None:\n        s = info_line.value.decode('utf-8')\n        s = s.split('\\n')\n        n += len(s)\n        for si in s:\n            if width == 'auto':\n                width = get_terminal_width()\n            if len(si) > width:\n                si = si[:width]\n            print(\"{0:<{1}}\".format(si, width))\n    \n    if no_move_up:\n        n = 0\n                                # this is only a hack to find the end\n                                # of the message in a stream\n                                # so ESC_HIDDEN+ESC_NO_CHAR_ATTR is a magic ending\n    print(terminal.ESC_MOVE_LINE_UP(n) + terminal.ESC_MY_MAGIC_ENDING, end='')\n    sys.stdout.flush()", "response": "show_stat_wrapper is a wrapper for the show_stat_wrapper method for each process"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getCountKwargs(func):\n    # Get all arguments of the function\n    if hasattr(func, \"__code__\"):\n        func_args = func.__code__.co_varnames[:func.__code__.co_argcount]\n        for pair in validCountKwargs:\n            if ( pair[0] in func_args and pair[1] in func_args ):\n                return pair\n    # else\n    return None", "response": "Returns a list of count kwarg count_max kwarg for a given function. Valid combinations are defined in \n    progress. validCountKwargs. Returns None if no valid combinations are found."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef humanize_speed(c_per_sec):\n    scales = [60, 60, 24]\n    units = ['c/s', 'c/min', 'c/h', 'c/d']\n    speed = c_per_sec\n    i = 0\n    if speed > 0:\n        while (speed < 1) and (i < len(scales)):\n            speed *= scales[i]\n            i += 1\n        \n    return \"{:.1f}{}\".format(speed, units[i])", "response": "convert a speed in counts per second to counts per [ s min h d )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef humanize_time(secs):\n    if secs is None:\n        return '--'\n\n    if secs < 1:\n        return \"{:.2f}ms\".format(secs*1000)\n    elif secs < 10:\n        return \"{:.2f}s\".format(secs)\n    else:\n        mins, secs = divmod(secs, 60)\n        hours, mins = divmod(mins, 60)\n        return '{:02d}:{:02d}:{:02d}'.format(int(hours), int(mins), int(secs))", "response": "convert second in to hh : mm : ss format\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self, timeout=None):\n\n        if self.is_alive():\n            log.warning(\"a process with pid %s is already running\", self._proc.pid)\n            return\n            \n        self._run.value = True\n        self._func_running.value = False\n        name = self.__class__.__name__\n        \n        self.conn_recv, self.conn_send = mp.Pipe(False)\n        self._monitor_thread = threading.Thread(target = self._monitor_stdout_pipe)\n        self._monitor_thread.daemon=True\n        self._monitor_thread.start()\n        log.debug(\"started monitor thread\")\n        self._log_queue = mp.Queue()\n        self._log_queue_listener = QueueListener(self._log_queue, *log.handlers)\n        self._log_queue_listener.start()\n\n        args = (self.func, self.args, self._run, self._pause, self.interval,\n                self._sigint, self._sigterm, name, log.level, self.conn_send, \n                self._func_running, self._log_queue)\n        \n        self._proc = mp.Process(target = _loop_wrapper_func,\n                                args   = args)\n        self._proc.start()\n        log.info(\"started a new process with pid %s\", self._proc.pid)\n        log.debug(\"wait for loop function to come up\")\n        t0 = time.time()\n        while not self._func_running.value:\n            if self._proc.exitcode is not None:\n                exc = self._proc.exitcode\n                self._proc = None\n                if exc == 0:\n                    log.warning(\"wrapper function already terminated with exitcode 0\\nloop is not running\")\n                    return\n                else:\n                    raise LoopExceptionError(\"the loop function return non zero exticode ({})!\\n\".format(exc)+\n                                             \"see log (INFO level) for traceback information\")\n            \n            time.sleep(0.1)           \n            if (timeout is not None) and ((time.time() - t0) > timeout):\n                err_msg = \"could not bring up function on time (timeout: {}s)\".format(timeout)\n                log.error(err_msg)\n                log.info(\"either it takes too long to spawn the subprocess (increase the timeout)\\n\"+\n                         \"or an internal error occurred before reaching the function call\")\n                raise LoopTimeoutError(err_msg)\n            \n        log.debug(\"loop function is up ({})\".format(humanize_time(time.time()-t0)))", "response": "uses multiprocess Process to call _wrapper_func in subprocess"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stop(self):\n        if self.is_alive():\n            self._proc.terminate()\n            \n        if self._proc is not None:\n            self.__cleanup()\n                   \n            if self.raise_error:\n                if self._proc.exitcode == 255:\n                    raise LoopExceptionError(\"the loop function return non zero exticode ({})!\\n\".format(self._proc.exitcode)+\n                                             \"see log (INFO level) for traceback information\")\n        self.pipe_handler.close()\n        self._proc = None", "response": "Stops the process and cleans up the shared memory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndoing the pre calculations in order to get TET, speed, TTG :param count: count :param last_count: count at the last call, allows to treat the case of no progress between sequential calls :param start_time: the time when start was triggered :param max_count: the maximal value count :type max_count: :param speed_calc_cycles: :type speed_calc_cycles: :param q: :type q: :param last_speed: :type last_speed: :param lock: :type lock:", "response": "def _calc(count, \n              last_count, \n              start_time, \n              max_count, \n              speed_calc_cycles, \n              q, \n              last_speed,\n              lock):\n        \"\"\"do the pre calculations in order to get TET, speed, TTG\n        \n        :param count:               count \n        :param last_count:          count at the last call, allows to treat the case of no progress\n            between sequential calls\n        :param start_time:          the time when start was triggered\n        :param max_count:           the maximal value count \n        :type max_count:\n        :param speed_calc_cycles:\n        :type speed_calc_cycles:\n        :param q:\n        :type q:\n        :param last_speed:\n        :type last_speed:\n        :param lock:\n        :type lock:\n        \"\"\"\n        count_value = count.value\n        start_time_value = start_time.value\n        current_time = time.time()\n        \n        if last_count.value != count_value:\n            # some progress happened\n        \n            with lock:\n                # save current state (count, time) to queue\n                \n                q.put((count_value, current_time))\n    \n                # get older state from queue (or initial state)\n                # to to speed estimation                \n                if q.qsize() > speed_calc_cycles:\n                    old_count_value, old_time = q.get()\n                else:\n                    old_count_value, old_time = 0, start_time_value\n            \n            last_count.value = count_value\n            #last_old_count.value = old_count_value\n            #last_old_time.value = old_time\n            \n            speed = (count_value - old_count_value) / (current_time - old_time)\n            last_speed.value = speed \n        else:\n            # progress has not changed since last call\n            # use also old (cached) data from the queue\n            #old_count_value, old_time = last_old_count.value, last_old_time.value\n            speed = last_speed.value  \n\n        if (max_count is None):\n            max_count_value = None\n        else:\n            max_count_value = max_count.value\n            \n        tet = (current_time - start_time_value)\n        \n        if (speed == 0) or (max_count_value is None) or (max_count_value == 0):\n            ttg = None\n        else:\n            ttg = math.ceil((max_count_value - count_value) / speed)\n            \n        return count_value, max_count_value, speed, tet, ttg"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _reset_i(self, i):\n        self.count[i].value=0\n        log.debug(\"reset counter %s\", i)\n        self.lock[i].acquire()\n        for x in range(self.q[i].qsize()):\n            self.q[i].get()\n        \n        self.lock[i].release()\n        self.start_time[i].value = time.time()", "response": "reset i - th progress information"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _show_stat(self):\n        _show_stat_wrapper_multi_Progress(self.count,\n                                          self.last_count, \n                                          self.start_time, \n                                          self.max_count, \n                                          self.speed_calc_cycles,\n                                          self.width,\n                                          self.q,\n                                          self.last_speed,\n                                          self.prepend,\n                                          self.show_stat,\n                                          self.len, \n                                          self.add_args,\n                                          self.lock,\n                                          self.info_line,\n                                          no_move_up=True)", "response": "This is a wrapper for the static show_stat_wrapper_multi method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        # before printing any output to stout, we can now check this\n        # variable to see if any other ProgressBar has reserved that\n        # terminal.\n        \n        if (self.__class__.__name__ in terminal.TERMINAL_PRINT_LOOP_CLASSES):\n            if not terminal.terminal_reserve(progress_obj=self):\n                log.warning(\"tty already reserved, NOT starting the progress loop!\")\n                return\n        \n        super(Progress, self).start()\n        self.show_on_exit = True", "response": "start the progress loop"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop the process and print the current state of the current object.", "response": "def stop(self):\n        \"\"\"\n            trigger clean up by hand, needs to be done when not using\n            context management via 'with' statement\n        \n            - will terminate loop process\n            - show a last progress -> see the full 100% on exit\n            - releases terminal reservation\n        \"\"\"\n        super(Progress, self).stop()\n        terminal.terminal_unreserve(progress_obj=self, verbose=self.verbose)\n\n        if self.show_on_exit:\n            if not isinstance(self.pipe_handler, PipeToPrint):\n                myout = inMemoryBuffer()\n                stdout = sys.stdout\n                sys.stdout = myout\n                self._show_stat()\n                self.pipe_handler(myout.getvalue())\n                sys.stdout = stdout\n            else:\n                self._show_stat()\n                print()\n        self.show_on_exit = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting output nodes from the standard output and standard error files.", "response": "def _get_output_nodes(self, output_path, error_path):\n        \"\"\"\n        Extracts output nodes from the standard output and standard error\n        files.\n        \"\"\"\n        from aiida.orm.data.array.trajectory import TrajectoryData\n        import re\n\n        state = None\n        step = None\n        scale = None\n        with open(output_path) as f:\n            lines = [x.strip('\\n') for x in f.readlines()]\n\n        result_dict = dict()\n        trajectory = None\n        for line in lines:\n            if state is None and re.match('^\\s*NWChem SCF Module\\s*$',line):\n                state = 'nwchem-scf-module'\n                continue\n            if state is None and re.match('^\\s*NWChem Geometry Optimization\\s*$',line):\n                state = 'nwchem-geometry-optimisation'\n                trajectory = TrajectoryData()\n                continue\n            if state == 'nwchem-scf-module' and re.match('^\\s*Final RHF \\s*results\\s*$',line):\n                state = 'final-rhf-results'\n                continue\n            if re.match('^\\s*\\-*\\s*$',line):\n                continue\n            if state == 'final-rhf-results':\n                result = re.match('^\\s*([^=]+?)\\s*=\\s*([\\-\\d\\.]+)$',line)\n                if result:\n                    key = re.sub('[^a-zA-Z0-9]+', '_', result.group(1).lower())\n                    result_dict[key] = result.group(2)\n                else:\n                    state = 'nwchem-scf-module'\n            if state == 'nwchem-geometry-optimisation' and re.match('^\\s*Step\\s+\\d+\\s*$',line):\n                result = re.match('^\\s*Step\\s+(\\d+)\\s*$',line)\n                step = result.group(1)\n                continue\n            if state == 'nwchem-geometry-optimisation' and \\\n                re.match('^\\s*Output coordinates in a.u.',line):\n                state = 'nwchem-geometry-optimisation-coordinates'\n                result = re.match('scale by \\s(*[\\-\\d\\.]+)',line)\n                scale = result.group(1)\n                continue\n        return [('parameters', ParameterData(dict=result_dict))]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of candidate paths for given filepath.", "response": "def candidate_paths(self, filepath):\n        \"\"\"\n        Return candidates path for given path\n\n        * If Filename does not starts with ``_``, will build a candidate for\n          both with and without ``_`` prefix;\n        * Will build For each available extensions if filename does not have\n          an explicit extension;\n        * Leading path directory is preserved;\n\n        Args:\n            filepath (str): Relative path as finded in an import rule from a\n                SCSS source.\n\n        Returns:\n            list: Builded candidate paths (as relative paths).\n        \"\"\"\n        filelead, filetail = os.path.split(filepath)\n        name, extension = os.path.splitext(filetail)\n        # Removed leading dot from extension\n        if extension:\n            extension = extension[1:]\n\n        filenames = [name]\n        # If underscore prefix is present, dont need to double underscore\n        if not name.startswith('_'):\n            filenames.append(\"_{}\".format(name))\n\n        # If explicit extension, dont need to add more candidate extensions\n        if extension and extension in self.CANDIDATE_EXTENSIONS:\n            filenames = [\".\".join([k, extension]) for k in filenames]\n        # Else if no extension or not candidate, add candidate extensions\n        else:\n            # Restore uncandidate extensions if any\n            if extension:\n                filenames = [\".\".join([k, extension]) for k in filenames]\n            new = []\n            for ext in self.CANDIDATE_EXTENSIONS:\n                new.extend([\".\".join([k, ext]) for k in filenames])\n            filenames = new\n\n        # Return candidates with restored leading path if any\n        return [os.path.join(filelead, v) for v in filenames]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck that at least one candidate exist into a directory.", "response": "def check_candidate_exists(self, basepath, candidates):\n        \"\"\"\n        Check that at least one candidate exist into a directory.\n\n        Args:\n            basepath (str): Directory path where to search for candidate.\n            candidates (list): List of candidate file paths.\n\n        Returns:\n            list: List of existing candidates.\n        \"\"\"\n        checked = []\n        for item in candidates:\n            abspath = os.path.join(basepath, item)\n            if os.path.exists(abspath):\n                checked.append(abspath)\n\n        return checked"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresolving given paths from given base paths and returns a list of resolved paths.", "response": "def resolve(self, sourcepath, paths, library_paths=None):\n        \"\"\"\n        Resolve given paths from given base paths\n\n        Return resolved path list.\n\n        Note:\n            Resolving strategy is made like libsass do, meaning paths in\n            import rules are resolved from the source file where the import\n            rules have been finded.\n\n            If import rule is not explicit enough and two file are candidates\n            for the same rule, it will raises an error. But contrary to\n            libsass, this happen also for files from given libraries in\n            ``library_paths`` (oposed to libsass just silently taking the\n            first candidate).\n\n        Args:\n            sourcepath (str): Source file path, its directory is used to\n                resolve given paths. The path must be an absolute path to\n                avoid errors on resolving.\n            paths (list): Relative paths (from ``sourcepath``) to resolve.\n            library_paths (list): List of directory paths for libraries to\n                resolve paths if resolving fails on the base source path.\n                Default to None.\n\n        Raises:\n            UnresolvablePath: If a path does not exist and\n                ``STRICT_PATH_VALIDATION`` attribute is ``True``.\n\n        Returns:\n            list: List of resolved path.\n        \"\"\"\n        # Split basedir/filename from sourcepath, so the first resolving\n        # basepath is the sourcepath directory, then the optionnal\n        # given libraries\n        basedir, filename = os.path.split(sourcepath)\n        basepaths = [basedir]\n        resolved_paths = []\n\n        # Add given library paths to the basepaths for resolving\n        # Accept a string if not allready in basepaths\n        if library_paths and isinstance(library_paths, string_types) and \\\n           library_paths not in basepaths:\n            basepaths.append(library_paths)\n        # Add path item from list if not allready in basepaths\n        elif library_paths:\n            for k in list(library_paths):\n                if k not in basepaths:\n                    basepaths.append(k)\n\n        for import_rule in paths:\n            candidates = self.candidate_paths(import_rule)\n\n            # Search all existing candidates:\n            # * If more than one candidate raise an error;\n            # * If only one, accept it;\n            # * If no existing candidate raise an error;\n            stack = []\n            for i, basepath in enumerate(basepaths):\n                checked = self.check_candidate_exists(basepath, candidates)\n                if checked:\n                    stack.extend(checked)\n\n            # More than one existing candidate\n            if len(stack) > 1:\n                raise UnclearResolution(\n                    \"rule '{}' This is not clear for these paths: {}\".format(\n                        import_rule, ', '.join(stack)\n                    )\n                )\n            # Accept the single one\n            elif len(stack) == 1:\n                resolved_paths.append(os.path.normpath(stack[0]))\n            # No validated candidate\n            else:\n                if self.STRICT_PATH_VALIDATION:\n                    raise UnresolvablePath(\n                        \"Imported path '{}' does not exist in '{}'\".format(\n                            import_rule, basedir\n                        )\n                    )\n\n        return resolved_paths"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump(self, content, filepath, indent=4):\n        with open(filepath, 'w') as fp:\n            pyaml.dump(content, dst=fp, indent=indent)", "response": "Dump settings content to filepath."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, filepath, content):\n        try:\n            parsed = yaml.load(content)\n        except yaml.YAMLError as exc:\n            msg = \"No YAML object could be decoded from file: {}\\n{}\"\n            raise SettingsBackendError(msg.format(filepath, exc))\n        return parsed", "response": "Parses opened settings content using YAML parser."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter the slaves that are not in an ODOWN or SDOWN state", "response": "def filter_slaves(selfie, slaves):\n        \"\"\"\n        Remove slaves that are in an ODOWN or SDOWN state\n        also remove slaves that do not have 'ok' master-link-status\n        \"\"\"\n        return [(s['ip'], s['port']) for s in slaves\n                if not s['is_odown'] and\n                not s['is_sdown'] and\n                s['master-link-status'] == 'ok']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets one message from the list of available items", "response": "def get_message(zelf):\n        \"\"\"\n        get one message if available else return None\n        if message is available returns the result of handler(message)\n        does not block!\n\n        if you would like to call your handler manually, this is the way to\n        go. don't pass in a handler to Listener() and the default handler will\n        log and return the message for your own manual processing\n        \"\"\"\n        try:\n            message = zelf.r.master.rpoplpush(zelf.lijst, zelf._processing)\n            if message:\n                # NOTE(tr3buchet): got a message, process it\n                LOG.debug('received: |%s|' % message)\n                return zelf._call_handler(message)\n        except zelf.r.generic_error:\n            LOG.exception('')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlisten indefinitely handling messages as they come", "response": "def listen(zelf):\n        \"\"\"\n        listen indefinitely, handling messages as they come\n\n        all redis specific exceptions are handled, anything your handler raises\n        will not be handled. setting active to False on the Listener object\n        will gracefully stop the listen() function\n        \"\"\"\n        while zelf.active:\n            try:\n                msg = zelf.r.master.brpoplpush(zelf.lijst, zelf._processing,\n                                               zelf.read_time)\n                if msg:\n                    # NOTE(tr3buchet): got a message, process it\n                    LOG.debug('received: |%s|' % msg)\n                    zelf._call_handler(msg)\n            except zelf.r.generic_error:\n                LOG.exception('')\n            finally:\n                time.sleep(0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_op(self, op, sched):\r\n        if op is self:\r\n            import warnings\r\n            warnings.warn(\"Running coro %s with itself. Something is fishy.\"%op)\r\n        assert self.state < self.STATE_COMPLETED, \\\r\n            \"%s called with %s op %r, coroutine state (%s) should be less than %s!\" % (\r\n                self, isinstance(op, CoroutineException) and op or\r\n                (hasattr(op, 'state') and {0:'RUNNING', 1:'FINALIZED', 2:'ERRORED'}[op.state] or 'NOP'), op,\r\n                self._state_names[self.state],\r\n                self._state_names[self.STATE_COMPLETED]\r\n            )\r\n        #~ assert self.state < self.STATE_COMPLETED, \\\r\n            #~ \"%s called with:%s, last one:%s, expected state less than %s!\" % (\r\n                #~ self,\r\n                #~ op,\r\n                #~ isinstance(self.lastop, CoroutineException) and ''.join(traceback.format_exception(*self.lastop.message)) or self.lastop,\r\n                #~ self._state_names[self.STATE_COMPLETED]\r\n            #~ )\r\n        #~ self.lastop = op\r\n        if self.debug:\r\n            print\r\n            if isinstance(op, CoroutineException):\r\n                print 'Running %r with exception:' % self,\r\n                if len(op.args) == 3:\r\n                    print '[[['\r\n                    traceback.print_exception(*op.args)\r\n                    print ']]]'\r\n                else:\r\n                    print op.args\r\n            else:\r\n                print 'Running %r with: %r' % (self, op)\r\n        global ident\r\n        ident = self\r\n        try:\r\n            if self.state == self.STATE_RUNNING:\r\n                if self.debug:\r\n                    traceback.print_stack(self.coro.gi_frame)\r\n                if isinstance(op, CoroutineException):\r\n                    rop = self.coro.throw(*op.args)\r\n                else:\r\n                    rop = self.coro.send(op and op.finalize(sched))\r\n            elif self.state == self.STATE_NEED_INIT:\r\n                assert op is None\r\n                self.coro = self.coro(*self.f_args, **self.f_kws)\r\n                del self.f_args\r\n                del self.f_kws\r\n                if self._valid_gen(self.coro):\r\n                    self.state = self.STATE_RUNNING\r\n                    rop = None\r\n                else:\r\n                    self.state = self.STATE_COMPLETED\r\n                    self.result = self.coro\r\n                    self.coro = None\r\n                    rop = self\r\n            else:\r\n                return None\r\n\r\n        except StopIteration, e:\r\n            self.state = self.STATE_COMPLETED\r\n            self.result = e.args and e.args[0]\r\n            if hasattr(self.coro, 'close'):\r\n                self.coro.close()\r\n            rop = self\r\n        except (KeyboardInterrupt, GeneratorExit, SystemExit):\r\n            raise\r\n        except:\r\n            self.state = self.STATE_FAILED\r\n            self.result = None\r\n            self.exception = sys.exc_info()\r\n            if hasattr(self.coro, 'close'):\r\n                self.coro.close()\r\n            if not self.caller:\r\n                self.handle_error(op)\r\n            rop = self\r\n            sys.exc_clear()\r\n        finally:\r\n            ident = None\r\n        if self.debug:\r\n            print \"Yields %s.\" % rop\r\n        return rop", "response": "This method runs the given operation and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering a single field in a base language.", "response": "def render_field(field):\n    \"\"\"\n    \u6e32\u67d3\u5b57\u6bb5\u9a8c\u8bc1\u4ee3\u7801\n    :param field:\n     :type field: django.forms.Field\n    :return:\n    \"\"\"\n    field = field.field if isinstance(field, forms.BoundField) else field\n    validators = {}\n\n    def no_compare_validator():\n        return not ('lessThan' in validators or 'greaterThan' in validators or 'between' in validators)\n\n    if field.required:\n        validators['notEmpty'] = {}\n    validator_codes = [item.code for item in field.validators]\n    for v in field.validators:\n        if isinstance(v, MinLengthValidator):\n            vc = validators.get('stringLength', {})\n            vc['min'] = field.min_length\n            validators.update({'stringLength': vc})\n        elif isinstance(v, MaxLengthValidator):\n            vc = validators.get('stringLength', {})\n            vc['max'] = field.max_length\n            validators.update({'stringLength': vc})\n        elif isinstance(v, (MinValueValidator, MaxValueValidator)):\n            if 'min_value' in validator_codes and 'max_value' in validator_codes:\n                vc = validators.get('between', {})\n                if v.code == 'min_value':\n                    vc['min'] = field.min_value\n                else:\n                    vc['max'] = field.max_value\n                validators.update({'between': vc})\n            elif v.code == 'min_value':\n                validators['greaterThan'] = {'value': field.min_value}\n            elif v.code == 'max_value':\n                validators['lessThan'] = {'value': field.max_value}\n        elif isinstance(v, BaseBV):\n            validators.update(v.get_validator_code())\n\n    if isinstance(field, (fields.DecimalField, fields.FloatField)) and no_compare_validator():\n        validators['numeric'] = {}\n    elif isinstance(field, fields.IntegerField) and no_compare_validator():\n        validators['integer'] = {}\n    elif isinstance(field, (fields.DateField, fields.DateTimeField)):\n        formats = field.input_formats\n        if formats:\n            validators['date'] = {'format': convert_datetime_python_to_javascript(formats[0])}\n    elif isinstance(field, fields.TimeField):\n        validators['regexp'] = {'regexp': '^((([0-1]?[0-9])|([2][0-3])):)(([0-5][0-9]):)([0-5][0-9])$',\n        }\n    elif isinstance(field, fields.URLField):\n        validators['uri'] = {}\n    elif isinstance(field, fields.EmailField):\n        validators['emailAddress'] = {}\n    elif isinstance(field, fields.ImageField):\n        if 'file' not in validators:\n            validators.update(ImageFileValidator().get_validator_code())\n    return {'validators': validators}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the header lines of a vcf file", "response": "def get_vcf_header(source):\n    \"\"\"Get the header lines of a vcf file\n    \n        Args:\n            source(iterable): A vcf file\n        \n        Returns:\n            head (HeaderParser): A headerparser object\n    \"\"\"\n    head = HeaderParser()\n    #Parse the header lines\n    for line in source:\n        line = line.rstrip()\n        if line.startswith('#'):\n            if line.startswith('##'):\n                logger.debug(\"Found metadata line {0}\".format(line))\n                head.parse_meta_data(line)\n            else:\n                logger.debug(\"Found header line {0}\".format(line))\n                head.parse_header_line(line)\n        else:\n            break\n    \n    return head"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_config(command, filename, section, vars):\r\n    conf = appconfig('config:' + filename)\r\n    load_environment(conf.global_conf, conf.local_conf)", "response": "Place any commands to setup cogenircapp here"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _split_scheme(expression):\n        match = re.search(r'^([a-z]+):(.*)$', expression)\n        if not match:\n            scheme = 'plain'\n            actual = expression\n        else:\n            scheme = match.group(1)\n            actual = match.group(2)\n\n        return scheme, actual", "response": "Splits the scheme and actual from the expression."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_scheme(scheme, constructor):\n        if not re.search(r'^[a-z]+$', scheme):\n            raise ValueError('{0!s} is not a valid scheme'.format(scheme))\n\n        if scheme in SimpleConditionFactory._constructors:\n            raise ValueError('Scheme {0!s} is registered already'.format(scheme))\n\n        SimpleConditionFactory._constructors[scheme] = constructor", "response": "Registers a scheme.\n\n        :param str scheme: The scheme.\n        :param callable constructor: The SimpleCondition constructor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create():\n    def creator(group):\n        \"\"\"Helper function applied to each symbol group of the raw isotope table.\"\"\"\n        symbol = group['symbol'].values[0]\n        try:    # Ghosts and custom atoms don't necessarily have an abundance fraction\n            mass = (group['mass']*group['af']).sum()\n            afm = group['af'].sum()\n            if afm > 0.0:\n                mass /= afm\n        except ZeroDivisionError:\n            mass = group['mass'].mean()\n        znum = group['Z'].max()\n        cov_radius = group['cov_radius'].mean()\n        van_radius = group['van_radius'].mean()\n        try:\n            color = group.loc[group['af'].idxmax(), 'color']\n        except TypeError:\n            color = group['color'].values[0]\n        name = group['name'].values[0]\n        ele = Element(symbol, name, mass, znum, cov_radius, van_radius, color)\n        # Attached isotopes\n        for tope in group.apply(lambda s: Isotope(*s.tolist()), axis=1):\n            setattr(ele, \"_\"+str(tope.A), tope)\n        return ele\n\n    iso = _rj(_E(_path).to_stream())\n    iso.columns = _columns\n    setattr(_this, \"iso\", iso)\n    for element in iso.groupby(\"symbol\").apply(creator):\n        setattr(_this, element.symbol, element)", "response": "Globally called function for creating the isotope table API."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_df():\n    records = []\n    for sym, ele in vars(_this).items():\n        if sym not in [\"Element\", \"Isotope\"] and not sym.startswith(\"_\"):\n            for k, v in vars(ele).items():\n                if k.startswith(\"_\") and k[1].isdigit():\n                    records.append({kk: vv for kk, vv in vars(v).items() if not kk.startswith(\"_\")})\n    return _DF.from_records(records)", "response": "Return a dataframe of isotopes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute one step of the simulation.", "response": "def _compute_one_step(self, t, fields, pars):\n        \"\"\"\n        Compute one step of the simulation, then update the timers.\n        \"\"\"\n        fields, pars = self._hook(t, fields, pars)\n        self.dt = (self.tmax - t\n                   if self.tmax and (t + self.dt >= self.tmax)\n                   else self.dt)\n        before_compute = time.process_time()\n        t, fields = self._scheme(t, fields, self.dt,\n                                 pars, hook=self._hook)\n        after_compute = time.process_time()\n        self._last_running = after_compute - before_compute\n        self._total_running += self._last_running\n        self._last_timestamp = self._actual_timestamp\n        self._actual_timestamp = pendulum.now()\n        return t, fields, pars"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing all steps of the simulation.", "response": "def run(self, progress=True, verbose=False):\n        \"\"\"Compute all steps of the simulation. Be careful: if tmax is not set,\n        this function will result in an infinit loop.\n\n        Returns\n        -------\n\n        (t, fields):\n            last time and result fields.\n        \"\"\"\n        total_iter = int((self.tmax // self.user_dt) if self.tmax else None)\n        log = logging.info if verbose else logging.debug\n        if progress:\n            with tqdm(initial=(self.i if self.i < total_iter else total_iter),\n                      total=total_iter) as pbar:\n                for t, fields in self:\n                    pbar.update(1)\n                    log(\"%s running: t: %g\" % (self.id, t))\n                try:\n                    return t, fields\n                except UnboundLocalError:\n                    warnings.warn(\"Simulation already ended\")\n        for t, fields in self:\n            log(\"%s running: t: %g\" % (self.id, t))\n        try:\n            return t, fields\n        except UnboundLocalError:\n            warnings.warn(\"Simulation already ended\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a Container to the simulation which allows persistance to the simulation.", "response": "def attach_container(self, path=None, save=\"all\",\n                         mode=\"w\", nbuffer=50, force=False):\n        \"\"\"add a Container to the simulation which allows some\n        persistance to the simulation.\n\n        Parameters\n        ----------\n        path : str or None (default: None)\n            path for the container. If None (the default), the data lives only\n            in memory (and are available with `simulation.container`)\n        mode : str, optional\n            \"a\" or \"w\" (default \"w\")\n        save : str, optional\n            \"all\" will save every time-step,\n            \"last\" will only get the last time step\n        nbuffer : int, optional\n            wait until nbuffer data in the Queue before save on disk.\n        timeout : int, optional\n            wait until timeout since last flush before save on disk.\n        force : bool, optional (default False)\n            if True, remove the target folder if not empty. if False, raise an\n            error.\n        \"\"\"\n        self._container = TriflowContainer(\"%s/%s\" % (path, self.id)\n                                           if path else None,\n                                           save=save,\n                                           mode=mode, metadata=self.parameters,\n                                           force=force, nbuffer=nbuffer)\n        self._container.connect(self.stream)\n        return self._container"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a post - process to the list of post - processes for this modifield.", "response": "def add_post_process(self, name, post_process, description=\"\"):\n        \"\"\"add a post-process\n\n        Parameters\n        ----------\n        name : str\n            name of the post-traitment\n        post_process : callback (function of a class with a __call__ method\n                                 or a streamz.Stream).\n            this callback have to accept the simulation state as parameter\n            and return the modifield simulation state.\n            if a streamz.Stream is provided, it will me plugged_in with the\n            previous streamz (and ultimately to the initial_stream). All these\n            stream accept and return the simulation state.\n        description : str, optional, Default is \"\".\n            give extra information about the post-processing\n        \"\"\"\n\n        self._pprocesses.append(PostProcess(name=name,\n                                            function=post_process,\n                                            description=description))\n        self._pprocesses[-1].function(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a post - process from the set of post - processes.", "response": "def remove_post_process(self, name):\n        \"\"\"remove a post-process\n\n        Parameters\n        ----------\n        name : str\n            name of the post-process to remove.\n        \"\"\"\n        self._pprocesses = [post_process\n                            for post_process in self._pprocesses\n                            if post_process.name != name]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new QDone object with the most recent items in the items", "response": "def task_done(self, **kws):\r\n        \"\"\"Indicate that a formerly enqueued task is complete.\r\n\r\n        Used by Queue consumer threads.  For each get() used to fetch a task,\r\n        a subsequent call to task_done() tells the queue that the processing\r\n        on the task is complete.\r\n\r\n        If a join() is currently blocking, it will resume when all items\r\n        have been processed (meaning that a task_done() call was received\r\n        for every item that had been put() into the queue).\r\n\r\n        Raises a ValueError if called more times than there were items\r\n        placed in the queue.\r\n        \"\"\"\r\n        unfinished = self.unfinished_tasks - 1\r\n        op = None\r\n        if unfinished <= 0:\r\n            if unfinished < 0:\r\n                raise ValueError('task_done() called too many times')\r\n            op = QDone(self, **kws)\r\n        self.unfinished_tasks = unfinished\r\n        return op"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nput an item into the queue.", "response": "def put(self, item, block=True, **kws):\r\n        \"\"\"Put an item into the queue.\r\n\r\n        If optional args 'block' is true and 'timeout' is None (the default),\r\n        block if necessary until a free slot is available. If 'timeout' is\r\n        a positive number, it blocks at most 'timeout' seconds and raises\r\n        the Full exception if no free slot was available within that time.\r\n        Otherwise ('block' is false), put an item on the queue if a free slot\r\n        is immediately available, else raise the Full exception ('timeout'\r\n        is ignored in that case).\r\n        \"\"\"\r\n        return QPut(self, item, block, **kws)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield a file-like object for the purpose of writing to or reading from the cache. The code: with cache_file(...) as f: # do stuff with f is guaranteed to convert any exceptions to warnings (*), both in the cache_file(...) call and the 'do stuff with f' block. The file is automatically closed upon exiting the with block. If getting an actual file fails, yields a DummyFile. :param package: the name of the package being checked as a string :param mode: the mode to open the file in, either 'r' or 'w'", "response": "def cache_file(package, mode):\n    \"\"\"\n    Yields a file-like object for the purpose of writing to or\n    reading from the cache.\n\n    The code:\n\n        with cache_file(...) as f:\n            # do stuff with f\n\n    is guaranteed to convert any exceptions to warnings (*),\n    both in the cache_file(...) call and the 'do stuff with f'\n    block.\n\n    The file is automatically closed upon exiting the with block.\n\n    If getting an actual file fails, yields a DummyFile.\n\n    :param package: the name of the package being checked as a string\n    :param mode: the mode to open the file in, either 'r' or 'w'\n    \"\"\"\n\n    f = DummyFile()\n\n    # We have to wrap the whole function body in this block to guarantee\n    # catching all exceptions. In particular the yield needs to be inside\n    # to catch exceptions coming from the with block.\n    with exception_to_warning('use cache while checking for outdated package',\n                              OutdatedCacheFailedWarning):\n        try:\n            cache_path = os.path.join(tempfile.gettempdir(),\n                                      get_cache_filename(package))\n            if mode == 'w' or os.path.exists(cache_path):\n                f = open(cache_path, mode)\n        finally:\n            # Putting the yield in the finally section ensures that exactly\n            # one thing is yielded once, otherwise @contextmanager would\n            # raise an exception.\n            with f:  # closes the file afterards\n                yield f"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncatches any exceptions that occur in the block and emits a warning of the given category.", "response": "def exception_to_warning(description, category, always_raise=False):\n    \"\"\"\n    Catches any exceptions that happen in the corresponding with block\n    and instead emits a warning of the given category,\n    unless always_raise is True or the environment variable\n    OUTDATED_RAISE_EXCEPTION is set to 1, in which caise the exception\n    will not be caught.\n    \"\"\"\n\n    try:\n        yield\n    except Exception:\n        # We check for the presence of various globals because we may be seeing the death\n        # of the process if this is in a background thread, during which globals\n        # get 'cleaned up' and set to None\n        if always_raise or os and os.environ and os.environ.get('OUTDATED_RAISE_EXCEPTION') == '1':\n            raise\n\n        if warn_with_ignore:\n            warn_with_ignore(\n                'Failed to %s.\\n'\n                'Set the environment variable OUTDATED_RAISE_EXCEPTION=1 for a full traceback.'\n                % description,\n                category,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the sampling volume.", "response": "def sampling_volume(self, val):\n        \"\"\"Sets sampling volume.\"\"\"\n        if self.instrument == \"Vectrino\" and type(val) is float:\n            if val == 2.5:\n                self.pdx.SamplingVolume = 0\n            elif val == 4.0:\n                self.pdx.SamplingVolume = 1\n            elif val == 5.5:\n                self.pdx.SamplingVolume = 2\n            elif val == 7.0:\n                self.pdx.SamplingVolume = 3\n            elif val == 8.5:\n                self.pdx.SamplingVolume = 4\n            else:\n                raise ValueError(\"Invalid sampling volume specified\")\n        elif val in range(5):\n            self.pdx.SamplingVolume = val\n        else:\n            raise ValueError(\"Invalid sampling volume specified\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sound_speed_mode(self, mode):\n        if mode == \"measured\":\n            mode = 0\n        if mode == \"fixed\":\n            mode = 1\n        self.pdx.SoundSpeedMode = mode", "response": "Sets the sound speed mode ; 0 or measured for fixed ; 1 or measured for fixed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sound_speed(self, value):\n        if not self.sound_speed_mode:\n            self.sound_speed_mode = 1\n        self.pdx.SoundSpeed = float(value)", "response": "Sets the sound speed in m/s. Default is 1525. 0."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the power level according to the index or string.", "response": "def power_level(self, val):\n        \"\"\"Sets the power level according to the index or string.\n        0 = High\n        1 = HighLow\n        2 = LowHigh\n        3 = Low\"\"\"\n        if val in [0, 1, 2, 3]:\n            self.pdx.PowerLevel = val\n        elif type(val) is str:\n            if val.lower() == \"high\":\n                self.pdx.PowerLevel = 0\n            elif val.lower() == \"highlow\":\n                self.pdx.PowerLevel = 1\n            elif val.lower() == \"lowhigh\":\n                self.pdx.PowerLevel = 2\n            elif val.lower() == \"low\":\n                self.pdx.PowerLevel = 3\n        else:\n            raise ValueError(\"Not a valid power level\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef coordinate_system(self, coordsys):\n        if coordsys.upper() == \"ENU\":\n            ncs = 0\n        elif coordsys.upper() == \"XYZ\":\n            ncs = 1\n        elif coordsys.upper() == \"BEAM\":\n            ncs = 2\n        elif coordsys in [0, 1, 2]:\n            ncs = coordsys\n        else:\n            raise ValueError(\"Invalid coordinate system selection\")\n        self.pdx.CoordinateSystem = ncs", "response": "Sets instrument coordinate system. Accepts an int or string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start_disk_recording(self, filename, autoname=False):\n        self.pdx.StartDiskRecording(filename, autoname)", "response": "Starts data recording for the specified object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the device samping volume value in m.", "response": "def sampling_volume_value(self):\n        \"\"\"Returns the device samping volume value in m.\"\"\"\n        svi = self.pdx.SamplingVolume\n        tli = self.pdx.TransmitLength\n        return self._sampling_volume_value(svi, tli)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting an asyncio coroutine into a function which, when called, is evaluted in an event loop, and the return value returned. This is intented to make it easy to write entry points into asyncio coroutines, which otherwise need to be explictly evaluted with an event loop's run_until_complete. If `loop` is given, it is used as the event loop to run the coro in. If it is None (the default), the loop is retreived using asyncio.get_event_loop. This call is defered until the decorated function is called, so that callers can install custom event loops or event loop policies after @autoasync is applied. If `forever` is True, the loop is run forever after the decorated coroutine is finished. Use this for servers created with asyncio.start_server and the like. If `pass_loop` is True, the event loop object is passed into the coroutine as the `loop` kwarg when the wrapper function is called. In this case, the wrapper function's __signature__ is updated to remove this parameter, so that autoparse can still be used on it without generating a parameter for `loop`. This coroutine can be called with ( @autoasync(...) ) or without ( @autoasync ) arguments. Examples: @autoasync def get_file(host, port): reader, writer = yield from asyncio.open_connection(host, port) data = reader.read() sys.stdout.write(data.decode()) get_file(host, port) @autoasync(forever=True, pass_loop=True) def server(host, port, loop): yield_from loop.create_server(Proto, host, port) server('localhost', 8899)", "response": "def autoasync(coro=None, *, loop=None, forever=False, pass_loop=False):\n    '''\n    Convert an asyncio coroutine into a function which, when called, is\n    evaluted in an event loop, and the return value returned. This is intented\n    to make it easy to write entry points into asyncio coroutines, which\n    otherwise need to be explictly evaluted with an event loop's\n    run_until_complete.\n\n    If `loop` is given, it is used as the event loop to run the coro in. If it\n    is None (the default), the loop is retreived using asyncio.get_event_loop.\n    This call is defered until the decorated function is called, so that\n    callers can install custom event loops or event loop policies after\n    @autoasync is applied.\n\n    If `forever` is True, the loop is run forever after the decorated coroutine\n    is finished. Use this for servers created with asyncio.start_server and the\n    like.\n\n    If `pass_loop` is True, the event loop object is passed into the coroutine\n    as the `loop` kwarg when the wrapper function is called. In this case, the\n    wrapper function's __signature__ is updated to remove this parameter, so\n    that autoparse can still be used on it without generating a parameter for\n    `loop`.\n\n    This coroutine can be called with ( @autoasync(...) ) or without\n    ( @autoasync ) arguments.\n\n    Examples:\n\n    @autoasync\n    def get_file(host, port):\n        reader, writer = yield from asyncio.open_connection(host, port)\n        data = reader.read()\n        sys.stdout.write(data.decode())\n\n    get_file(host, port)\n\n    @autoasync(forever=True, pass_loop=True)\n    def server(host, port, loop):\n        yield_from loop.create_server(Proto, host, port)\n\n    server('localhost', 8899)\n\n    '''\n    if coro is None:\n        return lambda c: autoasync(\n            c, loop=loop,\n            forever=forever,\n            pass_loop=pass_loop)\n\n    # The old and new signatures are required to correctly bind the loop\n    # parameter in 100% of cases, even if it's a positional parameter.\n    # NOTE: A future release will probably require the loop parameter to be\n    # a kwonly parameter.\n    if pass_loop:\n        old_sig = signature(coro)\n        new_sig = old_sig.replace(parameters=(\n            param for name, param in old_sig.parameters.items()\n            if name != \"loop\"))\n\n    @wraps(coro)\n    def autoasync_wrapper(*args, **kwargs):\n        # Defer the call to get_event_loop so that, if a custom policy is\n        # installed after the autoasync decorator, it is respected at call time\n        local_loop = get_event_loop() if loop is None else loop\n\n        # Inject the 'loop' argument. We have to use this signature binding to\n        # ensure it's injected in the correct place (positional, keyword, etc)\n        if pass_loop:\n            bound_args = old_sig.bind_partial()\n            bound_args.arguments.update(\n                loop=local_loop,\n                **new_sig.bind(*args, **kwargs).arguments)\n            args, kwargs = bound_args.args, bound_args.kwargs\n\n        if forever:\n            _launch_forever_coro(coro, args, kwargs, local_loop)\n            local_loop.run_forever()\n        else:\n            return local_loop.run_until_complete(coro(*args, **kwargs))\n\n    # Attach the updated signature. This allows 'pass_loop' to be used with\n    # autoparse\n    if pass_loop:\n        autoasync_wrapper.__signature__ = new_sig\n\n    return autoasync_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def report_winner(self, winner: Participant, scores_csv: str):\n        await self._report(scores_csv, winner._id)", "response": "report scores and give a winner |methcoro|"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def reopen(self):\n        res = await self.connection('POST', 'tournaments/{}/matches/{}/reopen'.format(self._tournament_id, self._id))\n        self._refresh_from_json(res)", "response": "Reopens a match that was marked completed automatically resetting matches that follow it\n\n        |methcoro| |\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def change_votes(self, player1_votes: int = None, player2_votes: int = None, add: bool = False):\n        assert_or_raise(player1_votes is not None or player2_votes is not None,\n                        ValueError,\n                        'One of the votes must not be None')\n\n        if add:\n            # order a fresh update of this match\n            res = await self.connection('GET', 'tournaments/{}/matches/{}'.format(self._tournament_id, self._id))\n            self._refresh_from_json(res)\n            if player1_votes is not None:\n                player1_votes += self._player1_votes or 0\n            if player2_votes is not None:\n                player2_votes += self._player2_votes or 0\n\n        params = {}\n        if player1_votes is not None:\n                params.update({'player1_votes': player1_votes})\n        if player2_votes is not None:\n                params.update({'player2_votes': player2_votes})\n        res = await self.connection('PUT',\n                                    'tournaments/{}/matches/{}'.format(self._tournament_id, self._id),\n                                    'match',\n                                    **params)\n        self._refresh_from_json(res)", "response": "Change the votes for either player1_votes or player2_votes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattach a file to the current instance", "response": "async def attach_file(self, file_path: str, description: str = None) -> Attachment:\n        \"\"\" add a file as an attachment\n\n        |methcoro|\n\n        Warning:\n            |unstable|\n\n        Args:\n            file_path: path to the file you want to add\n            description: *optional* description for your attachment\n\n        Returns:\n            Attachment:\n\n        Raises:\n            ValueError: file_path must not be None\n            APIException\n\n        \"\"\"\n        with open(file_path, 'rb') as f:\n            return await self._attach(f.read(), description)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an url as an attachment", "response": "async def attach_url(self, url: str, description: str = None) -> Attachment:\n        \"\"\" add an url as an attachment\n\n        |methcoro|\n\n        Args:\n            url: url you want to add\n            description: *optional* description for your attachment\n\n        Returns:\n            Attachment:\n\n        Raises:\n            ValueError: url must not be None\n            APIException\n\n        \"\"\"\n        return await self._attach(url=url, description=description)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndestroys a match attachment |methcoro|", "response": "async def destroy_attachment(self, a: Attachment):\n        \"\"\" destroy a match attachment\n\n        |methcoro|\n\n        Args:\n            a: the attachment you want to destroy\n\n        Raises:\n            APIException\n\n        \"\"\"\n        await self.connection('DELETE', 'tournaments/{}/matches/{}/attachments/{}'.format(self._tournament_id, self._id, a._id))\n        if a in self.attachments:\n            self.attachments.remove(a)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef class_subobjects(\n        class_: Type) -> Generator[Tuple[str, Type, bool], None, None]:\n    \"\"\"Find the aggregated subobjects of an object.\n\n    These are the public attributes.\n\n    Args:\n        class_: The class whose subobjects to return.\n\n    Yields:\n        Tuples (name, type, required) describing subobjects.\n    \"\"\"\n    argspec = inspect.getfullargspec(class_.__init__)\n    defaults = argspec.defaults if argspec.defaults else []\n    num_optional = len(defaults)\n    first_optional = len(argspec.args) - num_optional\n\n    for i, attr_name in enumerate(argspec.args):\n        if attr_name == 'self':\n            continue\n        if attr_name == 'yatiml_extra':\n            continue\n        attr_type = argspec.annotations.get(attr_name, Any)\n        yield attr_name, attr_type, i < first_optional", "response": "Returns a generator that yields the public attributes of the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_tarball(path, shortkey=False, classes=Editor):\n    editors = {}\n    with tarfile.open(path) as tar:\n        for member in tar.getmembers():\n            f = tar.extractfile(member)\n            if f is None:\n                continue\n            if shortkey:\n                name = os.path.basename(member.name)\n            else:\n                name = member.name\n            if isinstance(classes, type):\n                cls = classes\n            elif isinstance(classes, dict):\n                cls = classes.get(name, Editor)\n            elif callable(classes):\n                cls = classes(name)\n            else:\n                raise TypeError(\"Wrong type for classes argument (with type {})\".format(type(classes)))\n            editors[name] = cls(f, name=name)\n    return editors", "response": "Reads a tarball and returns a dictionary of all the editors in the archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a frameinfo object that is from the inspect module returns a properly formated string", "response": "def format_frameinfo(fi):\n    \"\"\"\n    Takes a frameinfo object (from the inspect module)\n\n    returns a properly formated string\n    \"\"\"\n    s1 = \"{0}:{1}\".format(fi.filename, fi.lineno)\n    s2 = \"function:{0},    code_context:\".format(fi.function)\n    if fi.code_context:\n        s3 = fi.code_context[0]\n    else:\n        s3 = \"<no code context available>\"\n\n    return \"\\n\".join([s1, s2, s3])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_frame_list():\n\n    # TODO: use this function in IPS below (less code duplication)\n\n    frame_info_list = []\n    frame_list = []\n    frame = inspect.currentframe()\n    while frame is not None:\n        frame_list.append(frame)\n        info = inspect.getframeinfo(frame)\n        frame_info_list.append(info)\n        frame = frame.f_back\n\n    frame_info_list.reverse()\n    frame_list.reverse()\n    frame_info_str_list = [format_frameinfo(fi) for fi in frame_info_list]\n\n    return frame_list, frame_info_list, frame_info_str_list", "response": "Create the list of frames\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef IPS(copy_namespaces=True, overwrite_globals=False):\n\n    # let the user know, where this shell is 'waking up'\n    # construct frame list\n    # this will be printed in the header\n    frame_info_list = []\n    frame_list = []\n    frame = inspect.currentframe()\n    while frame is not None:\n        frame_list.append(frame)\n        info = inspect.getframeinfo(frame)\n        frame_info_list.append(info)\n        frame = frame.f_back\n\n    frame_info_list.reverse()\n    frame_list.reverse()\n    frame_info_str_list = [format_frameinfo(fi) for fi in frame_info_list]\n\n    custom_header1 = \"----- frame list -----\\n\\n\"\n    frame_info_str = \"\\n--\\n\".join(frame_info_str_list[:-1])\n    custom_header2 = \"\\n----- end of frame list -----\\n\"\n\n    custom_header = \"{0}{1}{2}\".format(custom_header1, frame_info_str, custom_header2)\n\n    # prevent IPython shell to be launched in IP-Notebook\n    test_str = str(frame_info_list[0]) + str(frame_info_list[1])\n    if 'IPython' in test_str and 'zmq' in test_str:\n        print(\"\\n- Not entering IPython embedded shell  -\\n\")\n        return\n\n    # copied (and modified) from IPython/terminal/embed.py\n    config = load_default_config()\n\n    config.InteractiveShellEmbed = config.TerminalInteractiveShell\n\n    # these two lines prevent problems related to the initialization\n    # of ultratb.FormattedTB below\n    InteractiveShellEmbed.clear_instance()\n    InteractiveShellEmbed._instance = None\n\n    shell = InteractiveShellEmbed.instance()\n\n    # achieve that custom macros are loade in interactive shell\n    shell.magic('load_ext storemagic')\n    if config.StoreMagics.autorestore:\n        shell.magic('store -r')\n        ar_keys = [k.split(\"/\")[-1] for k in shell.db.keys() if k.startswith(\"autorestore/\")]\n    else:\n        ar_keys = []\n\n    # adapt the namespaces to prevent missing names inside the shell\n    # see: https://github.com/ipython/ipython/issues/62\n    # https://github.com/ipython/ipython/issues/10695\n    if copy_namespaces and len(frame_list) >= 2:\n        # callers_frame to IPS()\n        # note that frame_list and frame_info_list were reversed above\n        f1 = frame_list[-2]\n        lns = f1.f_locals\n        gns = f1.f_globals\n\n        l_keys = set(lns)\n        g_keys = set(gns)\n        u_keys = shell.user_ns.keys()\n\n        # those keys which are in local ns but not in global\n        safe_keys = l_keys - g_keys\n        unsafe_keys = l_keys.intersection(g_keys)\n\n        assert safe_keys.union(unsafe_keys) == l_keys\n\n        gns.update({k:lns[k] for k in safe_keys})\n\n        if unsafe_keys and not overwrite_globals:\n            custom_header += \"following local keys have \" \\\n                             \"not been copied:\\n{}\\n\".format(unsafe_keys)\n\n        if unsafe_keys and overwrite_globals:\n            gns.update({k:lns[k] for k in unsafe_keys})\n            custom_header += \"following global keys have \" \\\n                             \"been overwritten:\\n{}\\n\".format(unsafe_keys)\n\n        # now update the gns with stuff from the user_ns (if it will not overwrite anything)\n        # this could be implemented cleaner\n        for k in ar_keys:\n            if k not in gns:\n                gns[k] = shell.user_ns[k]\n            else:\n                print(\"omitting key from user_namespace:\", k)\n\n        dummy_module = DummyMod()\n        dummy_module.__dict__ = gns\n\n    else:\n        # unexpected few frames or no copying desired:\n        lns = None\n        dummy_module = None\n\n    # now execute the shell\n    shell(header=custom_header, stack_depth=2, local_ns=lns, module=dummy_module)\n\n    custom_excepthook = getattr(sys, 'custom_excepthook', None)\n    if custom_excepthook is not None:\n        assert callable(custom_excepthook)\n        sys.excepthook = custom_excepthook", "response": "Starts an IPython embedded shell."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_shell_after_exception(frame):\n\n    # let the user know, where this shell is 'waking up'\n    # construct frame list\n    # this will be printed in the header\n    frame_info_list = []\n    frame_list = []\n    original_frame = frame = frame or inspect.currentframe()\n\n    local_ns = frame.f_locals\n    # global_ns = frame.f_globals  # this is deprecated by IPython\n    dummy_module = DummyMod()\n    dummy_module.__dict__ = frame.f_globals\n\n    while frame is not None:\n        frame_list.append(frame)\n        info = inspect.getframeinfo(frame)\n        frame_info_list.append(info)\n        frame = frame.f_back\n\n    frame_info_list.reverse()\n    frame_info_str_list = [format_frameinfo(fi) for fi in frame_info_list]\n\n    custom_header1 = \"----- frame list -----\\n\\n\"\n    frame_info_str = \"\\n--\\n\".join(frame_info_str_list[:-1])\n    custom_header2 = \"\\n----- ERROR -----\\n\"\n\n    custom_header = \"{0}{1}{2}\".format(custom_header1, frame_info_str, custom_header2)\n\n    # prevent IPython shell to be launched in IP-Notebook\n    if len(frame_info_list) >= 2:\n        test_str = str(frame_info_list[0]) + str(frame_info_list[1])\n        if 'IPython' in test_str and 'zmq' in test_str:\n            print(\"\\n- Not entering IPython embedded shell  -\\n\")\n            return\n\n    # copied (and modified) from IPython/terminal/embed.py\n    config = load_default_config()\n    config.InteractiveShellEmbed = config.TerminalInteractiveShell\n\n    # these two lines prevent problems in related to the initialization\n    # of ultratb.FormattedTB below\n    InteractiveShellEmbedWithoutBanner.clear_instance()\n    InteractiveShellEmbedWithoutBanner._instance = None\n\n    shell = InteractiveShellEmbedWithoutBanner.instance()\n\n    shell(header=custom_header, stack_depth=2, local_ns=local_ns, module=dummy_module)\n\n    # if `diff_index` is not None it will be interpreted as index increment for the frame_list in the except hook\n    # \"__mu\" means \"move up\"\n    diff_index = local_ns.get(\"__mu\")\n    if not isinstance(diff_index, int):\n        diff_index = None\n\n    return diff_index", "response": "Launches an IPython embedded shell in the namespace where an exception occurred."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef color_exepthook(pdb=0, mode=2):\n\n    modus = ['Plain', 'Context', 'Verbose'][mode] # select the mode\n\n    sys.excepthook = ultratb.FormattedTB(mode=modus,\n                                    color_scheme='Linux', call_pdb=pdb)", "response": "Color the tracebacks after exceptions colored and verbose and call pdb\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ip_extra_syshook(fnc, pdb=0, filename=None):\n\n    assert isinstance(fnc, collections.Callable)\n    from IPython.core import ultratb\n    import time\n\n    if not filename == None:\n        assert isinstance(filename, str)\n        pdb = 0\n\n    ip_excepthook = ultratb.FormattedTB(mode='Verbose',\n                                    color_scheme='Linux', call_pdb=pdb)\n\n    fileTraceback = ultratb.FormattedTB(mode='Verbose',\n                                    color_scheme='NoColor', call_pdb=0)\n\n    # define the new excepthook\n    def theexecpthook (type, value, traceback):\n        fnc()\n        ip_excepthook(type, value, traceback)\n        # write this to a File without Colors\n        if not filename == None:\n            outFile = open(filename, \"a\")\n            outFile.write(\"--\" + time.ctime()+\" --\\n\")\n            outFile.write(fileTraceback.text(type, value, traceback))\n            outFile.write(\"\\n-- --\\n\")\n            outFile.close()\n\n    # assign it\n    sys.excepthook = theexecpthook", "response": "Extended system hook for exceptions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_current_nb_as_html(info=False):\n    assert in_ipynb()\n\n    full_path = get_notebook_name()\n    path, filename = os.path.split(full_path)\n\n    wd_save = os.getcwd()\n    os.chdir(path)\n    cmd = 'jupyter nbconvert --to html \"{}\"'.format(filename)\n    os.system(cmd)\n    os.chdir(wd_save)\n\n    if info:\n        print(\"target dir: \", path)\n        print(\"cmd: \", cmd)\n        print(\"working dir: \", wd_save)", "response": "Save the current notebook as html file in the same directory as the notebook in the same directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dirsearch(word, obj, only_keys = True, deep = 0):\n    word = word.lower()\n\n    if isinstance(obj, dict):\n        # only consider keys which are basestrings\n        items = [(key, val) for key, val in list(obj.items()) \\\n                                                if isinstance(key, str)]\n    else:\n        #d = dir(obj)\n\n        items = []\n        for key in dir(obj):\n            try:\n                items.append( (key, getattr(obj, key)) )\n            except AttributeError:\n                continue\n            except NotImplementedError:\n                continue\n\n    def maxlen(s, n):\n        s = s.replace(\"\\n\", \" \")\n        if len(s) > n:\n            s = s[:n-2]+'..'\n        return s\n\n    def match(word, key, value):\n        if only_keys:\n            return word in key.lower()\n        else:\n            # search also in value (if it is of type basestring)\n            if not isinstance(value, str):\n                value = \"\" # only local change\n\n            return (word in key.lower()) or (word in value.lower())\n\n    res = [(k, maxlen(str(v), 20)) for k,v in items if match(word, k, v)]\n    # res is a list of (key,value)-pairs\n\n    if deep > 0:\n\n        def interesting(obj):\n            module = type(sys)\n            deep_types  = (module, type, dict)\n            res = isinstance(type(obj), deep_types)\n            #res = res and not (obj is type)\n            return res\n\n        deeper_items = [(name, obj) for name, obj in items \\\n                                    if interesting(obj)]\n\n        for name, obj in deeper_items:\n            deep_res = dirsearch(word, obj, only_keys=False, deep = deep-1)\n            deep_res = [(\"%s.%s\" %(name, d_name), d_obj)\n                                        for d_name, d_obj in deep_res]\n            res.extend(deep_res)\n\n    if only_keys and len(res) >0:\n        res = list(zip(*res))[0]\n        # now res only contains the keys\n    return res", "response": "search a string in a dict and return a list of tuples"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_whole_assignment_expression(line, varname, seq_type):\n\n    tokens = list(tk.generate_tokens(io.StringIO(line).readline))\n\n    if issubclass(seq_type, tuple):\n        L, R = \"()\"\n    elif issubclass(seq_type, list):\n        L, R = \"[]\"\n    else:\n        raise TypeError(\"Invalid sequence type given: {}\".format(seq_type))\n\n    errmsg = \"Unexpected format to process assignment `{}=...` in line '{}'\".format(varname, line)\n\n    # Delimiter_open_level\n    DOL = 0\n\n    # 0 -> not searching, 1 -> searching for first occurence of `L`, 2 -> searching for last occurence of `R`\n    search_mode = 0\n\n    i_start, i_end = None, None\n\n    for i, t in enumerate(tokens):\n        if t.type == tk.NAME and t.string == varname:\n            search_mode = 1\n            i_start = i\n            assert tokens[i + 1].string == \"=\"\n            assert tokens[i + 2].string == L\n            continue\n\n        if search_mode < 1 or not t.type == tk.OP:\n            continue\n\n        if t.string == L:\n            DOL += 1\n            search_mode = 2\n\n        if t.string == R:\n            DOL -= 1\n\n        if search_mode == 2 and DOL == 0:\n            i_end = i\n            break\n    else:  # no break\n        raise ValueError(errmsg)\n\n    substr = line[tokens[i_start].start[1]: tokens[i_end].end[1]]\n\n    try:\n        assert substr.count(L) == 1\n        assert substr.count(R) == 1\n        assert substr.count('\"') == 0\n        assert substr.count(\"'\") == 0\n    except AssertionError:\n        raise ValueError(errmsg)\n\n    return substr", "response": "Returns the expression that evaluates the given variable in the given line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef publish_attrs(self, upcount=1):\n\n        frame = inspect.currentframe()\n        i = upcount\n        while True:\n            if frame.f_back is None:\n                break\n            frame = frame.f_back\n            i -= 1\n            if i == 0:\n                break\n\n        for k, v in self.__dict__.items():\n            frame.f_globals[k] = v", "response": "This function injects all attributes into the callers namespace"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parsemsg(s): # stolen from twisted.words\r\n    prefix = ''\r\n    trailing = []\r\n    if not s:\r\n        raise Exception(\"Empty line.\")\r\n    if s[0] == ':':\r\n        prefix, s = s[1:].split(' ', 1)\r\n    if s.find(' :') != -1:\r\n        s, trailing = s.split(' :', 1)\r\n        args = s.split()\r\n        args.append(trailing)\r\n    else:\r\n        args = s.split()\r\n    command = args.pop(0)\r\n    return prefix, command, args", "response": "Breaks a message from an IRC server into its prefix command and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a message to the specified connection ( id )", "response": "def push(self, id):\r\n        \"Sends a message to the specified connection (id)\"\r\n        conn = session['connections'].get(id, None)\r\n        if conn:\r\n            msgs = simplejson.loads(request.body)\r\n            for msg in msgs:\r\n                try:\r\n                    cmd = msg.pop(0).upper()\r\n                    assert ' ' not in cmd, \"Bad message\"\r\n                    if cmd in ('USER', ):\r\n                        sufix = \" :\"+msg.pop()\r\n                    else:\r\n                        sufix = ''\r\n                    assert not [i for i in msg if ' ' in i], \"Bad message\"\r\n\r\n                    print 'PUSH:', (cmd, msg, sufix)\r\n\r\n                    if msg:\r\n                        payload = \"%s %s%s\\r\\n\" % (cmd, ' '.join(msg), sufix)\r\n                    else:\r\n                        payload = \"%s%s\\r\\n\" % (cmd, sufix)\r\n                    yield request.environ['cogen.call'](conn.sock.sendall)(\r\n                            payload.encode('utf-8'))\r\n                    if isinstance(request.environ['cogen.wsgi'].result, Exception):\r\n                        yield simplejson.dumps(('', 'ERROR', str(e)))\r\n                    else:\r\n                        yield simplejson.dumps(('', 'PUSH_OK', ''))\r\n                except Exception, e:\r\n                    yield simplejson.dumps(('', 'ERROR', str(e)))\r\n        else:\r\n            yield simplejson.dumps(('', 'ERROR', 'Invalid connection id.'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self, server):\r\n        \"Connects to a server and return a connection id.\"\r\n        if 'connections' not in session:\r\n            session['connections'] = {}\r\n            session.save()\r\n\r\n        conns = session['connections']\r\n        id = str(len(conns))\r\n        conn = Connection(server)\r\n        conns[id] = conn\r\n        yield request.environ['cogen.core'].events.AddCoro(conn.pull)\r\n        yield id", "response": "Connects to a server and return a connection id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pull(self, id):\r\n        conn = session['connections'].get(id, None)\r\n        conn.last_update = time.time()\r\n        if conn:\r\n            ev_list = []\r\n            while 1:\r\n                # ok, so this might look a bit ugly but the concept is very simple\r\n                #  you yield a special object from the environ that does some magic\r\n                #  and the wsgi server will resume the app when it has the result\r\n                yield request.environ['cogen.call'](conn.events.get)(timeout=0.1)\r\n                event = request.environ['cogen.wsgi'].result\r\n                # also, we can't have better exception handling in this wsgi\r\n                # contraption and we need to check the result for exceptions\r\n                if not event:\r\n                    break\r\n                elif isinstance(event, (queue.Empty, events.OperationTimeout)):\r\n                    break\r\n                elif isinstance(event, Exception):\r\n                    ev_list.append(('', 'ERROR', str(event)))\r\n                    break\r\n                else:\r\n                    ev_list.append(event)\r\n            if ev_list:\r\n                print 'PULL:', ev_list\r\n                yield simplejson.dumps(ev_list)\r\n            else:\r\n                # if we don't have any updates atm, we'll wait 30 secs for one\r\n                yield request.environ['cogen.call'](conn.events.get)(timeout=30)\r\n                event = request.environ['cogen.wsgi'].result\r\n                if isinstance(event, events.OperationTimeout):\r\n                    yield simplejson.dumps([])\r\n                elif isinstance(event, Exception):\r\n                    yield simplejson.dumps([('', 'ERROR', str(event))])\r\n                else:\r\n                    print 'PULL1:', event\r\n                    yield simplejson.dumps([event])\r\n        else:\r\n            yield simplejson.dumps(('', 'ERROR', 'Invalid connection id.'))", "response": "Take the messages from the queue and if there are none wait 30 secs till returning an empty message."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(input_filename, songname, format, counter):\n\n    # open the file & convert to wav\n    song_data = AudioSegment.from_file(input_filename, format=format)\n    song_data = song_data.set_channels(1)  # convert to mono\n    wav_tmp = song_data.export(format=\"wav\")  # write to a tmp file buffer\n    wav_tmp.seek(0)\n    rate, wav_data = wavfile.read(wav_tmp)\n\n    # extract peaks and compute constellation hashes & offsets\n    peaks = resound.get_peaks(np.array(wav_data))\n    fingerprints = list(resound.hashes(peaks))  # hash, offset pairs\n\n    if not fingerprints:\n        raise RuntimeError(\"No fingerprints detected in source file - check your parameters passed to Resound.\")\n\n    # Combine duplicate keys\n    for fp, abs_offset in fingerprints:\n        counter[fp].append((abs_offset, songname))\n\n    print \"    Identified {} keypoints in '{}'.\".format(len(counter), songname)\n\n    return counter", "response": "This function is used to calculate the fingerprint hashses of the referenced audio file and save them to disk as a pickle file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecodes the object to the object class", "response": "def decode(cls, root_element):\n        \"\"\"\n        Decode the object to the object\n\n        :param root_element: the parsed xml Element\n        :type root_element: xml.etree.ElementTree.Element\n        :return: the decoded Element as object\n        :rtype: object\n        \"\"\"\n        new_object = cls()\n        field_names_to_attributes = new_object._get_field_names_to_attributes()\n        for child_element in root_element:\n            new_object._set_field(new_object, field_names_to_attributes, child_element)\n        return new_object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a formatted HTML calendar.", "response": "def calendar(format, *args, **kwargs):\n    \"\"\"\n    Creates a formatted ``HTMLCalendar``. \n    Argument ``format`` can be one of ``month``, ``year``, or ``yearpage``\n    Keyword arguments are collected and passed into ``HTMLCalendar.formatmonth``, \n    ``HTMLCalendar.formatyear``, and ``HTMLCalendar.formatyearpage``\n    \n        Syntax::\n            \n            {% calendar month [year] [month] %}\n            {% calendar year [year] %}\n            {% calendar yearpage [year] %}\n            \n        Example::\n        \n            {% calendr month 2009 10 %}\n    \"\"\"\n    cal = HTMLCalendar(kwargs.pop('firstweekday', 0))\n    return getattr(cal, 'format%s' % format)(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef verify_address(self, addr1=\"\", addr2=\"\", city=\"\", fname=\"\", lname=\"\", phone=\"\", province=\"\", postal=\"\", country=\"\", email=\"\", recordID=\"\", freeform= \"\"):\n        data = {\n            \"TransmissionReference\": \"\",\n            \"CustomerID\": self.custID,\n            \"Actions\": \"Check\",\n            \"Options\": \"\",\n            \"Columns\": \"\",\n            \"Records\": [{\n                \"RecordID\": recordID,\n                \"CompanyName\": \"\",\n                \"FullName\": fname + \" \" + lname,\n                \"AddressLine1\": addr1,\n                \"AddressLine2\": addr2,\n                \"Suite\": \"\",\n                \"City\": city,\n                \"State\": province,\n                \"PostalCode\": postal,\n                \"Country\": country,\n                \"PhoneNumber\": phone,\n                \"EmailAddress\": email,\n                \"FreeForm\": freeform,\n            }]\n        }\n        self.country = country\n        data = json.dumps(data)\n        result = requests.post(\"https://personator.melissadata.net/v3/WEB/ContactVerify/doContactVerify\", data=data)\n        result = json.loads(result.text)\n        result = self.parse_results(result)\n        return result", "response": "This function is used to verify that a specific address is in Melissa data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the MelissaData response and returns a list of strings with corrected address info.", "response": "def parse_results(self, data):\n        \"\"\"parse_results\n\n        Parses the MelissaData response.\n\n        Args:\n                data (dict): Contains MelissaData response\n\n        Returns:\n                results, either contains a dict with corrected address info or -1 for an invalid address.\n        \"\"\"\n        results = []\n        if len(data[\"Records\"]) < 1:\n            return -1\n\n        codes = data[\"Records\"][0][\"Results\"]\n        for code in codes.split(\",\"):\n            results.append(str(code))\n\n        self.addr1 = data[\"Records\"][0][\"AddressLine1\"]\n        self.addr2 = data[\"Records\"][0][\"AddressLine2\"]\n        self.city = data[\"Records\"][0][\"City\"]\n        self.name = data[\"Records\"][0][\"NameFull\"]\n        self.phone = data[\"Records\"][0][\"PhoneNumber\"]\n        self.province = data[\"Records\"][0][\"State\"]\n        self.postal = data[\"Records\"][0][\"PostalCode\"]\n        self.recordID = data[\"Records\"][0][\"RecordID\"]\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a coroutine in the scheduler.", "response": "def add(self, coro, args=(), kwargs={}, first=True):\r\n        \"\"\"Add a coroutine in the scheduler. You can add arguments\r\n        (_args_, _kwargs_) to init the coroutine with.\"\"\"\r\n        assert callable(coro), \"'%s' not a callable object\" % coro\r\n        coro = coro(*args, **kwargs)\r\n        if first:\r\n            self.active.append( (None, coro) )\r\n        else:\r\n            self.active.appendleft( (None, coro) )\r\n        return coro"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a timevalue that the proactor will wait on.", "response": "def next_timer_delta(self):\r\n        \"Returns a timevalue that the proactor will wait on.\"\r\n        if self.timeouts and not self.active:\r\n            now = getnow()\r\n            timo = self.timeouts[0].timeout\r\n            if now >= timo:\r\n                #looks like we've exceded the time\r\n                return 0\r\n            else:\r\n                return (timo - now)\r\n        else:\r\n            if self.active:\r\n                return 0\r\n            else:\r\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing a ( op coro ) pair and return another pair. Handles exceptions.", "response": "def process_op(self, op, coro):\r\n        \"Process a (op, coro) pair and return another pair. Handles exceptions.\"\r\n        if op is None:\r\n            if self.active:\r\n                self.active.append((op, coro))\r\n            else:\r\n                return op, coro\r\n        else:\r\n            try:\r\n                result = op.process(self, coro) or (None, None)\r\n            except:\r\n                op.state = events.ERRORED\r\n                result = CoroutineException(*sys.exc_info()), coro\r\n            return result\r\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_run(self):\r\n        self.running = True\r\n        urgent = None\r\n        while self.running and (self.active or self.proactor or self.timeouts or urgent):\r\n            if self.active or urgent:\r\n                op, coro = urgent or self.active.popleft()\r\n                urgent = None\r\n                while True:\r\n                    op, coro = self.process_op(coro.run_op(op, self), coro)\r\n                    if not op and not coro:\r\n                        break\r\n\r\n            if (self.proactor_greedy or not self.active) and self.proactor:\r\n                try:\r\n                    urgent = self.proactor.run(timeout = self.next_timer_delta())\r\n                except (OSError, select.error, IOError), exc:\r\n                    if exc[0] != errno.EINTR:\r\n                        raise\r\n                #~ if urgent:print '>urgent:', urgent\r\n            if self.timeouts:\r\n                self.handle_timeouts()\r\n            yield\r\n            # this could had beed a ordinary function and have the run() call\r\n            #this repeatedly but the _urgent_ operation this is usefull (as it\r\n            #saves us needlessly hammering the active coroutines queue with\r\n            #append and pop calls on the same thing\r\n        self.cleanup()", "response": "A generator that yields the next set of events for the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cleanup(self):\r\n\r\n        if hasattr(self, 'proactor'):\r\n            if hasattr(self.proactor, 'scheduler'):\r\n                del self.proactor.scheduler\r\n            if hasattr(self.proactor, 'close'):\r\n                self.proactor.close()", "response": "Used internally. Cleans up the scheduler references in the proactor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_note(self, body):\n        from highton.models.note import Note\n        created_id = self._post_request(\n            endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Note.ENDPOINT,\n            data=self.element_to_string(\n                Note(body=body).encode()\n            )\n        ).headers.get('Location').replace('.xml', '').split('/')[-1]\n        return Note.get(created_id)", "response": "Create a Note to current object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a string representing a time in seconds into a frame number", "response": "def hms2frame(hms, fps):\n        \"\"\"\n        :param hms: a string, e.g. \"01:23:15\" for one hour, 23 minutes 15 seconds \n        :param fps: framerate \n        :return: frame number\n        \"\"\"\n        import time\n        t = time.strptime(hms, \"%H:%M:%S\")\n        return (t.tm_hour * 60 * 60 + t.tm_min * 60 + t.tm_sec) * fps"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the emails of the current object.", "response": "def list_emails(self, page=0, since=None):\n        \"\"\"\n        Get the emails of current object\n\n        :param page: the page starting at 0\n        :type since: int\n        :param since: get all notes since a datetime\n        :type since: datetime.datetime\n        :return: the emails\n        :rtype: list\n        \"\"\"\n        from highton.models.email import Email\n        params = {'n': int(page) * self.EMAILS_OFFSET}\n\n        if since:\n            params['since'] = since.strftime(self.COLLECTION_DATETIME)\n\n        return fields.ListField(\n            name=self.ENDPOINT,\n            init_class=Email\n        ).decode(\n            self.element_from_string(\n                self._get_request(\n                    endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Email.ENDPOINT,\n                    params=params\n                ).text\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tween2(self, val, frm, to):\n        return self.tween(Mapping.linlin(val, frm, to, 0, 1))", "response": "linearly maps val between frm and to"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _encode_str(self, obj, escape_quotes=True):\n        def replace(match):\n            s = match.group(0)\n            try:\n                if escape_quotes:\n                    return ESCAPE_DCT[s]\n                else:\n                    return BASE_ESCAPE_DCT[s]\n            except KeyError:\n                n = ord(s)\n                if n < 0x10000:\n                    return '\\\\u{0:04x}'.format(n)\n                else:\n                    # surrogate pair\n                    n -= 0x10000\n                    s1 = 0xd800 | ((n >> 10) & 0x3ff)\n                    s2 = 0xdc00 | (n & 0x3ff)\n                    return '\\\\u{0:04x}\\\\u{1:04x}'.format(s1, s2)\n        if escape_quotes:\n            return '\"' + ESCAPE_ASCII.sub(replace, obj) + '\"'\n        else:\n            return BASE_ESCAPE_ASCII.sub(replace, obj)", "response": "Return an ASCII - only JSON representation of a Python string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes a Python number into a JSON string.", "response": "def _encode_numbers(self, obj):\n        \"\"\"Returns a JSON representation of a Python number (int, float or Decimal)\"\"\"\n\n        # strict checks first - for speed\n        if obj.__class__ is int:\n            if abs(obj) > JAVASCRIPT_MAXINT:\n                raise ValueError('Number out of range: {!r}'.format(obj))\n            return str(obj)\n\n        if obj.__class__ is float:\n            if isnan(obj):\n                raise ValueError('NaN is not supported')\n            if isinf(obj):\n                raise ValueError('Infinity is not supported')\n            return repr(obj)\n\n        # more in-depth class analysis last\n        if isinstance(obj, int):\n            obj = int(obj)\n            if abs(obj) > JAVASCRIPT_MAXINT:\n                raise ValueError('Number out of range: {!r}'.format(obj))\n            return str(obj)\n\n        if isinstance(obj, float):\n            if isnan(obj):\n                raise ValueError('NaN is not supported')\n            if isinf(obj):\n                raise ValueError('Infinity is not supported')\n            return repr(obj)\n\n        if isinstance(obj, Decimal):\n            return '\"' + str(obj) + '\"'\n\n        # for complex and other Numbers\n        return self._encode(self.default(obj))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a JSON representation of a Python list", "response": "def _encode_list(self, obj):# do\n        \"\"\"Returns a JSON representation of a Python list\"\"\"\n\n        self._increment_nested_level()\n\n        buffer = []\n        for element in obj:\n            buffer.append(self._encode(element))\n\n        self._decrement_nested_level()\n\n        return '['+ ','.join(buffer) + ']'"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _encode_dict(self, obj):\n\n        self._increment_nested_level()\n\n        buffer = []\n        for key in obj:\n            buffer.append(self._encode_key(key) + ':' + self._encode(obj[key]))\n\n        self._decrement_nested_level()\n\n        return '{'+ ','.join(buffer) + '}'", "response": "Returns a JSON representation of a Python dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _encode_key(self, obj):\n\n        if obj.__class__ is str:\n            return self._encode_str(obj)\n\n        if obj.__class__ is UUID:\n            return '\"' + str(obj) + '\"'\n\n        # __mm_serialize__ is called before any isinstance checks (but after exact type checks)\n        try:\n            sx_encoder = obj.__mm_serialize__\n        except AttributeError:\n            pass\n        else:\n            try:\n                data = sx_encoder()\n            except NotImplementedError:\n                pass\n            else:\n                return self._encode_key(data)\n\n        if isinstance(obj, UUID):\n            return '\"' + str(obj) + '\"'\n\n        if isinstance(obj, str):\n            return self._encode_str(obj)\n\n        # if everything else failed try the default() method and re-raise any TypeError\n        # exceptions as more specific \"not a valid dict key\" TypeErrors\n        try:\n            value = self.default(obj)\n        except TypeError:\n            raise TypeError('{!r} is not a valid dictionary key'.format(obj))\n\n        return self._encode_key(value)", "response": "Encodes a dictionary key - a key can only be a string in std JSON"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding a Python object into a JSON string.", "response": "def _encode(self, obj):\n        \"\"\"Returns a JSON representation of a Python object - see dumps.\n        Accepts objects of any type, calls the appropriate type-specific encoder.\n        \"\"\"\n\n        if self._use_hook:\n            obj = self.encode_hook(obj)\n\n        # first try simple strict checks\n\n        _objtype = obj.__class__\n\n        if _objtype is str:\n            return self._encode_str(obj)\n\n        if _objtype is bool:\n            if obj:\n                return 'true'\n            else:\n                return 'false'\n\n        if _objtype is int or _objtype is float:\n            return self._encode_numbers(obj)\n\n        if _objtype is list or _objtype is tuple:\n            return self._encode_list(obj)\n\n        if obj is None:\n            return 'null'\n\n        if _objtype is dict or obj is OrderedDict:\n            return self._encode_dict(obj)\n\n        if _objtype is UUID:\n            return '\"' + str(obj) + '\"'\n\n        if _objtype is Decimal:\n            return '\"' + str(obj) + '\"'\n\n        # For all non-std types try __mm_json__ and then __mm_serialize__ before any isinstance\n        # checks\n\n        try:\n            sx_json_data = obj.__mm_json__\n        except AttributeError:\n            pass\n        else:\n            try:\n                data = sx_json_data()\n            except NotImplementedError:\n                pass\n            else:\n                if isinstance(data, bytes):\n                    return data.decode('utf-8')\n                else:\n                    return self._encode_str(data, escape_quotes=False)\n        try:\n            sx_encoder = obj.__mm_serialize__\n        except AttributeError:\n            pass\n        else:\n            try:\n                data = sx_encoder()\n            except NotImplementedError:\n                pass\n            else:\n                return self._encode(data)\n\n        # do more in-depth class analysis\n\n        if isinstance(obj, UUID):\n            return '\"' + str(obj) + '\"'\n\n        if isinstance(obj, str):\n            return self._encode_str(obj)\n\n        if isinstance(obj, (list, tuple, set, frozenset, Set)):\n            return self._encode_list(obj)\n\n        if isinstance(obj, Sequence) and not isinstance(obj, (bytes, bytearray)):\n            return self._encode_list(obj)\n\n        if isinstance(obj, (dict, OrderedDict, Mapping)):\n            return self._encode_dict(obj)\n\n        # note: number checks using isinstance should come after True/False checks\n        if isinstance(obj, Number):\n            return self._encode_numbers(obj)\n\n        if isinstance(obj, (date, time)):\n            return '\"' + obj.isoformat() + '\"'\n\n        return self._encode(self.default(obj))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a string representing a JSON - encoding of obj.", "response": "def dumps(self, obj, *, max_nested_level=100):\n        \"\"\"Returns a string representing a JSON-encoding of ``obj``.\n\n           The second optional ``max_nested_level`` argument controls the maximum\n           allowed recursion/nesting level.\n\n           See class description for details.\n        \"\"\"\n        self._max_nested_level = max_nested_level\n        return self._encode(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dumpb(self, obj, *, max_nested_level=100):\n        self._max_nested_level = max_nested_level\n        return self._encode(obj).encode('utf-8')", "response": "Similar to dumps but returns bytes instead of a string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading a file and show progress", "response": "def download_file(url, filename=None, show_progress=draw_pbar):\n    '''\n    Download a file and show progress\n\n    url: the URL of the file to download\n    filename: the filename to download it to (if not given, uses the url's filename part)\n    show_progress: callback function to update a progress bar\n\n    the show_progress function shall take two parameters: `seen` and `size`, and\n    return nothing.\n\n    This function returns the filename it has written the result to.\n    '''\n    if filename is None:\n        filename = url.split('/')[-1]\n    r = requests.get(url, stream=True)\n    size = int(r.headers['Content-Length'].strip())\n    seen = 0\n    show_progress(0, size)\n    seen = 1024\n    with open(filename, 'wb') as f:\n        for chunk in r.iter_content(chunk_size=1024):\n            seen += 1024\n            show_progress(seen, size)\n            if chunk:\n                f.write(chunk)\n                f.flush()\n    return filename"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle the part lookup and search for the given part", "response": "def part_search(self, part_query):\n        '''\n        handles the part lookup/search for the given part query\n\n        part_query: part string to search as product name\n\n        outputs result on stdout\n        '''\n        limit = 100\n        results = self._e.parts_search(q=part_query,\n                                       limit=limit)\n        start = 0\n        hits = results[0]['hits']\n        if hits == 0:\n            print(\"No result\")\n            return ReturnValues.NO_RESULTS\n\n        print(\"Searched for: '{}'\".format(results[0]['request']['q']))\n        def show_result(r):\n            print(' \u2192 {:30} {:30} {}'.format(\n                r['item']['mpn'], r['item']['manufacturer']['name'], r['snippet']\n            ))\n\n        for r in results[1]:\n            show_result(r)\n        while hits - limit > limit:\n            start += limit\n            hits -= limit\n            results = self._e.parts_search(q=part_query, limit=limit,\n                                            start=start)\n            for r in results[1]:\n                show_result(r)\n        if hits-limit > 0:\n            start += limit\n            hits -= limit\n            results = self._e.parts_search(q=part_query,\n                                            limit=hits,\n                                            start=start)\n            for r in results[1]:\n                show_result(r)\n        return ReturnValues.OK"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef part_specs(self, part):\n        '''\n        returns the specifications of the given part. If multiple parts are\n        matched, only the first one will be output.\n\n        part: the productname or sku\n\n        prints the results on stdout\n        '''\n        result = self._e.parts_match(\n            queries=[{'mpn_or_sku': part}],\n            exact_only=True,\n            show_mpn=True,\n            show_manufacturer=True,\n            show_octopart_url=True,\n            show_short_description=True,\n            show_specs=True,\n            show_category_uids=True,\n            show_external_links=True,\n            show_reference_designs=True,\n            show_cad_models=True,\n            show_datasheets=True,\n            include_specs=True,\n            include_category_uids=True,\n            include_external_links=True,\n            include_reference_designs=True,\n            include_cad_models=True,\n            include_datasheets=True\n        )\n        if result[1][0]['hits'] == 0:\n            print(\"No result\")\n            return ReturnValues.NO_RESULTS\n\n        result = result[1][0]['items'][0]\n        print(\"Showing specs for '{}':\".format(result['mpn']))\n        print(\" \u2192 Manufacturer:      {}\".format(result['manufacturer']['name']))\n        print(\"  \u2192 Specifications:    \")\n        for k,v in result['specs'].items():\n            name = v['metadata']['name'] if v['metadata']['name'] else k\n            min_value = v['min_value'] if v['min_value'] else ''\n            max_value = v['max_value'] if v['max_value'] else ''\n            unit = ' ({})'.format(v['metadata']['unit']['name']) if v['metadata']['unit'] else ''\n            value = ','.join(v['value']) if len(v['value']) > 0 else ''\n\n            if value and not (min_value or max_value):\n                print(\"    \u2192 {:20}: {}{}\".format(name, value, unit))\n            elif value and min_value and max_value:\n                print(\"    \u2192 {:20}: {}{} (min: {}, max: {})\".format(name, value, unit, min_value, max_value))\n            elif not value and min_value and max_value:\n                print(\"    \u2192 {:20}:{} min: {}, max: {}\".format(name, unit, min_value, max_value))\n            elif not value and min_value and not max_value:\n                print(\"    \u2192 {:20}:{} min: {}\".format(name, unit, min_value))\n            elif not value and not min_value and max_value:\n                print(\"    \u2192 {:20}:{} max: {}\".format(name, unit, max_value))\n\n        print(\" \u2192 URI:               {}\".format(result['octopart_url']))\n        if result['external_links']['evalkit_url'] \\\n                or result['external_links']['freesample_url'] \\\n                or result['external_links']['product_url']:\n            print(\"  \u2192 External Links\")\n            if result['external_links']['evalkit_url']:\n                print(\"    \u2192 Evaluation kit: {}\".format(result['external_links']['evalkit_url']))\n            if result['external_links']['freesample_url']:\n                print(\"    \u2192 Free Sample: {}\".format(result['external_links']['freesample_url']))\n            if result['external_links']['product_url']:\n                print(\"    \u2192 Product URI: {}\".format(result['external_links']['product_url']))\n        if len(result['datasheets']) > 0:\n            print(\"  \u2192 Datasheets\")\n            for datasheet in result['datasheets']:\n                print(\"    \u2192 URL:      {}\".format(datasheet['url']))\n                if datasheet['metadata']:\n                    print(\"      \u2192 Updated:  {}\".format(datasheet['metadata']['last_updated']))\n                    print(\"      \u2192 Nb Pages: {}\".format(datasheet['metadata']['num_pages']))\n        if len(result['reference_designs']) > 0:\n            print(\"  \u2192 Reference designs: \")\n        if len(result['cad_models']) > 0:\n            print(\"  \u2192 CAD Models:        \")\n        return ReturnValues.OK", "response": "returns the specifications of the given part"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef part_datasheet(self, part, command=None, path=None):\n        '''\n        downloads and/or shows the datasheet of a given part\n\n        command: if set will use it to open the datasheet.\n        path: if set will download the file under that path.\n\n        if path is given alone, the file will only get downloaded,\n        if command is given alone, the file will be downloaded in a temporary\n        folder, which will be destroyed just after being opened.\n        if both path and command are given, the file will be downloaded and\n        stored in the chosen location.\n        '''\n        result = self._e.parts_match(\n            queries=[{'mpn_or_sku': part}],\n            exact_only=True,\n            show_mpn=True,\n            show_datasheets=True,\n            include_datasheets=True\n        )\n        if result[1][0]['hits'] == 0:\n            print(\"No result\")\n            return ReturnValues.NO_RESULTS\n\n        result = result[1][0]['items'][0]\n        print(\"Downloading datasheet for '{}':\".format(result['mpn']))\n        try:\n            if len(result['datasheets']) > 0:\n                for datasheet in result['datasheets']:\n                    if not path:\n                        path = tempfile.mkdtemp()\n                    out = path+'/'+result['mpn']+'-'+datasheet['url'].split('/')[-1]\n                    download_file(datasheet['url'], out)\n                    print('Datasheet file saved as {}.'.format(out))\n                    if command:\n                        subprocess.call([command, out])\n        finally:\n            if not path:\n                shutil.rmtree(path)\n        return ReturnValues.OK", "response": "Downloads and displays the datasheet of a given part."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows the URI for the part.", "response": "def part_show(self, part, printout=False):\n        '''\n        Opens/shows the aggregator's URI for the part.\n\n\n        printout: if set, only printout the URI, do not open the browser.\n        '''\n\n        result = self._e.parts_match(\n            queries=[{'mpn_or_sku': part}],\n            exact_only=True,\n            show_mpn=True,\n            show_octopart_url=True\n        )\n        if result[1][0]['hits'] == 0:\n            print(\"No result\")\n            return ReturnValues.NO_RESULTS\n        result = result[1][0]['items'][0]\n        if not printout:\n            print(\"Opening page for part '{}'.\".format(result['mpn']))\n            webbrowser.open(result['octopart_url'], 2)\n        else:\n            print(\"Webpage for part '{}':\".format(result['mpn']))\n            print(\"    \u2192 URL:      {}\".format(result['octopart_url']))\n        return ReturnValues.OK"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nforce autoescape behaviour for this block.", "response": "def autoescape(context, nodelist, setting):\n    \"\"\"\n    Force autoescape behaviour for this block.\n    \"\"\"\n    old_setting = context.autoescape\n    context.autoescape = setting\n    output = nodelist.render(context)\n    context.autoescape = old_setting\n    if setting:\n        return mark_safe(output)\n    else:\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noutput a whole load of debugging information including the current context and imported modules.", "response": "def debug(context):\n    \"\"\"\n    Outputs a whole load of debugging information, including the current\n    context and imported modules.\n\n    Sample usage::\n\n        <pre>\n            {% debug %}\n        </pre>\n    \"\"\"\n\n    from pprint import pformat\n    output = [pformat(val) for val in context]\n    output.append('\\n\\n')\n    output.append(pformat(sys.modules))\n    return ''.join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter(context, nodelist, filter_exp):\n    output = nodelist.render(context)\n    # Apply filters.\n    context.update({'var': output})\n    filtered = filter_expr.resolve(context)\n    context.pop()\n    return filtered", "response": "Filters the contents of the block through variable filters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef regroup(target, expression):\n    if not target: return ''\n    return [\n        # List of dictionaries in the format:\n        # {'grouper': 'key', 'list': [list of contents]}.\n        {'grouper': key, 'list': list(val)}\n        for key, val in\n        groupby(obj_list, lambda v, f=expression.resolve: f(v, True))\n    ]", "response": "This function regroups a list of alike objects by a common attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef now(format_string):\n    from datetime import datetime\n    from django.utils.dateformat import DateFormat\n    return DateFormat(datetime.now()).format(self.format_string)", "response": "Displays the date formatted according to the given string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spaceless(context, nodelists):\n\n    from django.utils.html import strip_spaces_between_tags\n    return strip_spaces_between_tags(nodelist.render(context).strip())", "response": "This function returns a string that is spaceless."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef widthratio(value, maxvalue, max_width):\n    try:\n        max_width = int(max_width)\n    except ValueError:\n        raise TemplateSyntaxError(\"widthratio final argument must be an number\")\n    try:\n        value = float(value)\n        maxvalue = float(maxvalue)\n        ratio = (value / maxvalue) * max_width\n    except (ValueError, ZeroDivisionError):\n        return ''\n    return str(int(round(ratio)))", "response": "This function calculates the ratio of a given value to a maximum value and then applies that ratio to a constant."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_(context, nodelist, val):\n    context.push()\n    context[self.name] = val\n    output = nodelist.render(context)\n    context.pop()\n    return output", "response": "Adds a value to the context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _intersect(start1, end1, start2, end2):\n        start = max(start1, start2)\n        end = min(end1, end2)\n\n        if start > end:\n            return None, None\n\n        return start, end", "response": "Returns the intersection of two intervals."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreplaces start and end dates of the additional date intervals in the row set with their integer representation.", "response": "def _additional_rows_date2int(self, keys, rows):\n        \"\"\"\n        Replaces start and end dates of the additional date intervals in the row set with their integer representation\n\n        :param list[tuple[str,str]] keys: The other keys with start and end date.\n        :param list[dict[str,T]] rows: The list of rows.\n\n        :rtype: list[dict[str,T]]\n        \"\"\"\n        for row in rows:\n            for key_start_date, key_end_date in keys:\n                if key_start_date not in [self._key_start_date, self._key_end_date]:\n                    row[key_start_date] = self._date2int(row[key_start_date])\n                if key_end_date not in [self._key_start_date, self._key_end_date]:\n                    row[key_end_date] = self._date2int(row[key_end_date])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _intersection(self, keys, rows):\n        # If there are no other keys with start and end date (i.e. nothing to merge) return immediately.\n        if not keys:\n            return rows\n\n        ret = list()\n        for row in rows:\n            start_date = row[self._key_start_date]\n            end_date = row[self._key_end_date]\n            for key_start_date, key_end_date in keys:\n                start_date, end_date = Type2JoinHelper._intersect(start_date,\n                                                                  end_date,\n                                                                  row[key_start_date],\n                                                                  row[key_end_date])\n                if not start_date:\n                    break\n                if key_start_date not in [self._key_start_date, self._key_end_date]:\n                    del row[key_start_date]\n                if key_end_date not in [self._key_start_date, self._key_end_date]:\n                    del row[key_end_date]\n\n            if start_date:\n                row[self._key_start_date] = start_date\n                row[self._key_end_date] = end_date\n                ret.append(row)\n\n        return ret", "response": "Computes the intersection of two or more reference data sets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge(self, keys):\n        deletes = []\n        for pseudo_key, rows in self._rows.items():\n            self._additional_rows_date2int(keys, rows)\n            rows = self._intersection(keys, rows)\n            if rows:\n                rows = self._rows_sort(rows)\n                self._rows[pseudo_key] = self._merge_adjacent_rows(rows)\n            else:\n                deletes.append(pseudo_key)\n\n        for pseudo_key in deletes:\n            del self._rows[pseudo_key]", "response": "Merges the join on pseudo keys of two or more reference data sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, timeout = 0):\r\n        # poll timeout param is a integer number of miliseconds (seconds/1000).\r\n        ptimeout = int(\r\n            timeout.days * 86400000 +\r\n            timeout.microseconds / 1000 +\r\n            timeout.seconds * 1000\r\n            if timeout else (self.m_resolution if timeout is None else 0)\r\n        )\r\n        if self.tokens:\r\n            events = self.poller.poll(ptimeout)\r\n            len_events = len(events)-1\r\n            for nr, (fd, ev) in enumerate(events):\r\n                act = self.shadow.pop(fd)\r\n                if ev & POLLHUP:\r\n                    self.poller.unregister(fd)\r\n                    self.handle_error_event(act, 'Hang up.', ConnectionClosed)\r\n                elif ev & POLLNVAL:\r\n                    self.poller.unregister(fd)\r\n                    self.handle_error_event(act, 'Invalid descriptor.')\r\n                elif ev & POLLERR:\r\n                    self.poller.unregister(fd)\r\n                    self.handle_error_event(act, 'Unknown error.')\r\n                else:\r\n                    if nr == len_events:\r\n                        ret = self.yield_event(act)\r\n                        if ret:\r\n                            self.poller.unregister(fd)\r\n                        else:\r\n                            self.shadow[fd] = act\r\n                        return ret\r\n                    else:\r\n                        if self.handle_event(act):\r\n                            self.poller.unregister(fd)\r\n                        else:\r\n                            self.shadow[fd] = act\r\n\r\n        else:\r\n            sleep(timeout)", "response": "Run a proactor loop and return new socket events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_map():\r\n    map = Mapper(directory=config['pylons.paths']['controllers'],\r\n                 always_scan=config['debug'])\r\n\r\n    # The ErrorController route (handles 404/500 error pages); it should\r\n    # likely stay at the top, ensuring it can always be resolved\r\n    map.connect('error/:action/:id', controller='error')\r\n\r\n    # CUSTOM ROUTES HERE\r\n\r\n    map.connect('connect/:server', controller='irc', action='connect')\r\n    map.connect('pull/:id', controller='irc', action='pull')\r\n    map.connect('push/:id', controller='irc', action='push')\r\n\r\n    map.connect(':controller/:action/:id')\r\n\r\n    return map", "response": "Create and configure and return the routes Mapper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a new frame in the current set", "response": "def make_frame(self, frame, birthframe, startframe, stopframe, deathframe, noiseframe=None):\n        \"\"\"\n        :param frame: current frame \n        :param birthframe: frame where this animation starts returning something other than None\n        :param startframe: frame where animation starts to evolve\n        :param stopframe: frame where animation is completed\n        :param deathframe: frame where animation starts to return None\n        :return: \n        \"\"\"\n        return self.anim.make_frame(frame, birthframe, startframe, stopframe, deathframe, noiseframe)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_serializable_value(self):\n        return {\n            name: field.to_serializable_value()\n            for name, field in self.value.__dict__.items()\n            if isinstance(field, Field) and self.value\n        }", "response": "Return a dictionary of all the keys and values of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode(self):\n        element = ElementTree.Element(\n            self.name,\n            attrib={'type': FieldConstants.ARRAY},\n        )\n        for item in self.value:\n            element.append(item.encode())\n        return element", "response": "This method encodes the current entry into an XML element tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef constraints_stmt(stmt, env=None):\n    env = env or {}\n    \n    if isinstance(stmt, ast.FunctionDef):\n        arg_env = fn_env(stmt.args)\n\n        body_env = extended_env(env, arg_env)\n        constraints = []\n        return_type = None # TODO: should be fresh and constrained?\n        for body_stmt in stmt.body:\n            cs = constraints_stmt(body_stmt, env=body_env)\n            body_env.update(cs.env)\n            constraints += cs.constraints\n            return_type = union(return_type, cs.return_type)\n\n        env[stmt.name] = Function(arg_types=[arg_env[arg.id] for arg in stmt.args.args],\n                                  return_type=return_type)\n\n        return ConstrainedEnv(env=env, constraints=constraints)\n\n    elif isinstance(stmt, ast.Expr):\n        constrained_ty = constraints_expr(stmt.value, env=env)\n        return ConstrainedEnv(env=env, constraints=constrained_ty.constraints)\n        \n    elif isinstance(stmt, ast.Return):\n        if stmt.value:\n            expr_result = constraints_expr(stmt.value, env=env)\n            return ConstrainedEnv(env=env, constraints=expr_result.constraints, return_type=expr_result.type)\n        else:\n            result = fresh()\n            return ConstrainedEnv(env=env, constraints=[Constraint(subtype=result, supertype=NamedType('NoneType'))])\n\n    elif isinstance(stmt, ast.Assign):\n        if len(stmt.targets) > 1:\n            raise NotImplementedError('Cannot generate constraints for multi-target assignments yet')\n\n        expr_result = constraints_expr(stmt.value, env=env)\n        target = stmt.targets[0].id\n        \n        # For an assignment, we actually generate a fresh variable so that it can be the union of all things assigned\n        # to it. We do not do any typestate funkiness.\n        if target not in env:\n            env[target] = fresh()\n            \n        return ConstrainedEnv(env=env, \n                              constraints = expr_result.constraints + [Constraint(subtype=expr_result.type, \n                                                                                  supertype=env[target])])\n\n    else:\n        raise NotImplementedError('Constraint gen for stmt %s' % stmt)", "response": "Returns a ConstrainedEnv for the given statement."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef requires_product_environment(func, *args, **kws):\n    from django_productline import startup\n    startup.select_product()\n    return func(*args, **kws)", "response": "Decorator that makes sure that the product environment is activated"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompiling messages hook for django_productline, this task checks for the activated languages in settings.LANGUAGES. It runs the standard django compilemessages management command with the -l parameter. Example language setting: LANGUAGES = [ ('en', 'English'), ('de', 'Deutsch') ] Remarks: - Each argument for the management command MUST be a single list item, e.g. ['compilemessages', '--locale', 'en'] - The compilemessages command MUST be executed in the projects root dir, so the CWD is adjusted before running this command. :return:", "response": "def djpl_compilemessages():\n    \"\"\"\n    Compile messages hook for django_productline, this task checks for the activated languages\n    in settings.LANGUAGES. It runs the standard django compilemessages management command with the -l parameter.\n    Example language setting:\n        LANGUAGES = [\n            ('en', 'English'),\n            ('de', 'Deutsch')\n        ]\n    Remarks:\n        - Each argument for the management command MUST be a single list item, e.g. ['compilemessages', '--locale', 'en']\n        - The compilemessages command MUST be executed in the projects root dir, so the CWD is adjusted before running this command.\n    :return:\n    \"\"\"\n    from django.conf import settings\n    if hasattr(settings, 'LANGUAGES') and len(settings.LANGUAGES) > 0:\n        # changing cwd to project root\n        os.chdir(os.path.join(os.environ['APE_ROOT_DIR'], os.environ['CONTAINER_NAME']))\n        languages = list()\n        # collect the language abbreviations\n        for language in settings.LANGUAGES:\n            languages.append(language[0])\n        args = ['compilemessages']\n        # extend the arg list by the -locale argument for each language\n        for lang in languages:\n            args.extend(['--locale', str(lang)])\n        tasks.manage(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexporting the data of an application - media file plus database and context to a zip archive.", "response": "def export_data(target_path):\n    \"\"\"\n    Exports the data of an application - media files plus database,\n    :param: target_path:\n    :return: a zip archive\n    \"\"\"\n    tasks.export_data_dir(target_path)\n    tasks.export_database(target_path)\n    tasks.export_context(target_path)\n    return target_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_data(target_zip):\n    from django_productline.context import PRODUCT_CONTEXT\n    tasks.import_data_dir(target_zip)\n    # product context is not reloaded if context file is changed\n    tasks.import_database(target_zip, PRODUCT_CONTEXT.DB_NAME, PRODUCT_CONTEXT.DB_USER)", "response": "Imports data from given zip - arc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexport the media files of the application and bundles a zip archive", "response": "def export_data_dir(target_path):\n    \"\"\"\n    Exports the media files of the application and bundles a zip archive\n    :return: the target path of the zip archive\n    \"\"\"\n    from django_productline import utils\n    from django.conf import settings\n\n    utils.zipdir(settings.PRODUCT_CONTEXT.DATA_DIR, target_path, wrapdir='__data__')\n    print('... wrote {target_path}'.format(target_path=target_path))\n    return target_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_data_dir(target_zip):\n    from django_productline.context import PRODUCT_CONTEXT\n\n    new_data_dir = '{data_dir}_before_import_{ts}'.format(\n        data_dir=PRODUCT_CONTEXT.DATA_DIR,\n        ts=datetime.datetime.now().strftime(\"%Y-%m-%d.%H:%M:%S:%s\")\n    )\n\n    if os.path.exists(PRODUCT_CONTEXT.DATA_DIR):\n        # rename an existing data dir if it exists\n        tasks.mv_data_dir(new_data_dir)\n\n    z = zipfile.ZipFile(target_zip)\n\n    def filter_func(x):\n        return x.startswith('__data__/')\n\n    z.extractall(os.path.dirname(PRODUCT_CONTEXT.DATA_DIR), filter(filter_func, z.namelist()))", "response": "Imports the data specified by param <target_zip >. Renames the data dir if it already exists and unpacks the zip sub dir __data__ directly within the current active product."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mv_data_dir(target):\n    from django_productline.context import PRODUCT_CONTEXT\n    os.rename(PRODUCT_CONTEXT.DATA_DIR, target)", "response": "Move data_dir to target location refineable in case data_dir is a mounted volume or object storage"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef export_context(target_zip):\n    from django_productline import utils\n    context_file = tasks.get_context_path()\n    return utils.create_or_append_to_zip(context_file, target_zip, 'context.json')", "response": "Export the context. json to a zip file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_context(target_zip):\n    context_path = tasks.get_context_path()\n    with zipfile.ZipFile(target_zip) as unzipped_data:\n        with open(context_path, 'w') as context:\n            context.write(unzipped_data.read('context.json'))", "response": "Import the context. json from target_zip into the current context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_context_template():\n    import random\n    return {\n        'SITE_ID': 1,\n        'SECRET_KEY': ''.join(\n            [random.SystemRandom().choice('abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)') for i in range(50)]),\n        'DATA_DIR': os.path.join(os.environ['PRODUCT_DIR'], '__data__'),\n    }", "response": "Returns a dictionary of the product context parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating the DATA_DIR if it does not exist.", "response": "def create_data_dir():\n    \"\"\"\n    Creates the DATA_DIR.\n    :return:\n    \"\"\"\n    from django_productline.context import PRODUCT_CONTEXT\n    if not os.path.exists(PRODUCT_CONTEXT.DATA_DIR):\n        os.mkdir(PRODUCT_CONTEXT.DATA_DIR)\n        print('*** Created DATA_DIR in %s' % PRODUCT_CONTEXT.DATA_DIR)\n    else:\n        print('...DATA_DIR already exists.')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a new context. json file for the current product.", "response": "def generate_context(force_overwrite=False, drop_secret_key=False):\n    \"\"\"\n    Generates context.json\n    \"\"\"\n\n    print('... generating context')\n    context_fp = '%s/context.json' % os.environ['PRODUCT_DIR']\n    context = {}\n\n    if os.path.isfile(context_fp):\n        print('... augment existing context.json')\n\n        with open(context_fp, 'r') as context_f:\n            content = context_f.read().strip() or '{}'\n            try:\n                context = json.loads(content)\n            except ValueError:\n                print('ERROR: not valid json in your existing context.json!!!')\n                return\n\n        if force_overwrite:\n            print('... overwriting existing context.json')\n            if drop_secret_key:\n                print('... generating new SECRET_KEY')\n                context = {}\n            else:\n                print('... using existing SECRET_KEY from existing context.json')\n                context = {'SECRET_KEY': context['SECRET_KEY']}\n\n    with open(context_fp, 'w') as context_f:\n        new_context = tasks.get_context_template()\n\n        new_context.update(context)\n        context_f.write(json.dumps(new_context, indent=4, sort_keys=True))\n    print()\n    print('*** Successfully generated context.json')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear all tables in order to loaddata properly.", "response": "def clear_tables_for_loaddata(confirm=None):\n    \"\"\"\n    Clears al tables in order to loaddata properly.\n    :param string:\n    :return:\n    \"\"\"\n    from django.contrib.contenttypes.models import ContentType\n    from django.contrib.auth.models import Permission\n    from django.contrib.sites.models import Site\n\n    if confirm != 'yes':\n        print('Please enter \"yes\" to confirm that your want to clear ContentTypes, Sites, Permissions')\n    else:\n        Site.objects.all().delete()\n        Permission.objects.all().delete()\n        ContentType.objects.all().delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef inject_context(context):\n    context_path = tasks.get_context_path()\n    try:\n        new_context = json.loads(context)\n    except ValueError:\n        print('Couldn\\'t load context parameter')\n        return\n    with open(context_path) as jsonfile:\n        try:\n            jsondata = json.loads(jsonfile.read())\n            jsondata.update(new_context)\n        except ValueError:\n            print('Couldn\\'t read context.json')\n            return\n    with open(context_path, 'w') as jsoncontent:\n        json.dump(jsondata, jsoncontent, indent=4)", "response": "Updates context. json with data from JSON - string given as param."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the composed operation log from featuremonkey s Composer to a json file.", "response": "def write_composer_operation_log(filename):\n    \"\"\"\n    Writes the composed operation log from featuremonkey's Composer to a json file.\n    :param filename:\n    :return:\n    \"\"\"\n    from featuremonkey.tracing import serializer\n    from featuremonkey.tracing.logger import OPERATION_LOG\n    ol = copy.deepcopy(OPERATION_LOG)\n    ol = serializer.serialize_operation_log(ol)\n    with open(filename, 'w+') as operation_log_file:\n        operation_log_file.write(json.dumps(ol, indent=4, encoding=\"utf8\"))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search(cls, term=None, page=0, **criteria):\n\n        assert (term or criteria and not (term and criteria))\n\n        params = {\n            'n': int(page) * cls.SEARCH_OFFSET,\n        }\n\n        if term:\n            params['term'] = term\n\n        if criteria:\n            for key, value in criteria.items():\n                params['criteria[{}]'.format(key)] = value\n\n        return fields.ListField(name=cls.ENDPOINT, init_class=cls).decode(\n            cls.element_from_string(\n                cls._get_request(\n                    endpoint=cls.ENDPOINT + '/search',\n                    params=params\n                ).text\n            )\n        )", "response": "Search a list of the contacts tab with the specified term and optional criteria."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncombines each file with values from JSON dictionary in same directory as the control_files.", "response": "def _delim_accum(control_files, filename_template, keys=None,\n        exclude_keys=None, separator=DEFAULT_SEP, missing_action='fail'):\n    \"\"\"\n    Accumulator for delimited files\n\n    Combines each file with values from JSON dictionary in same directory\n\n    :param iterable control_files: Iterable of control files\n    :param filename_template: A template for the file to nest_map\n    :param keys: List of keys to select from JSON dictionary. If ``None``, keep\n                 all keys.\n    :param separator: Delimiter\n    \"\"\"\n    def map_fn(d, control, keys=keys):\n        f = os.path.join(d, filename_template.format(**control))\n\n        keys = keys if keys is not None else control.keys()\n        if exclude_keys:\n            keys = list(frozenset(keys) - frozenset(exclude_keys))\n        if frozenset(keys) - frozenset(control):\n            # Unknown keys\n            raise ValueError(\n                    \"The following required key(s) are not present in {1}: {0}\".format(\n                        ', '.join(frozenset(keys) - frozenset(control)),\n                        f))\n        with open(f) as fp:\n            reader = csv.DictReader(fp, delimiter=separator)\n            for row in reader:\n                row_dict = collections.OrderedDict(\n                        itertools.chain(((k, row[k]) for k in reader.fieldnames),\n                        ((k, v) for k, v in control.items() if k in keys)))\n\n                yield row_dict\n    if missing_action == 'warn':\n        map_fn = _warn_on_io(map_fn)\n\n    return itertools.chain.from_iterable(nest_map(control_files, map_fn))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes delim action. :param arguments: Parsed command line arguments from :func:`main`", "response": "def delim(arguments):\n    \"\"\"\n    Execute delim action.\n\n    :param arguments: Parsed command line arguments from :func:`main`\n    \"\"\"\n\n    if bool(arguments.control_files) == bool(arguments.directory):\n        raise ValueError(\n                'Exactly one of control_files and `-d` must be specified.')\n\n    if arguments.directory:\n        arguments.control_files.extend(control_iter(arguments.directory))\n\n    with arguments.output as fp:\n        results = _delim_accum(arguments.control_files,\n                arguments.file_template, arguments.keys,\n                arguments.exclude_keys, arguments.separator,\n                missing_action=arguments.missing_action)\n        r = next(results)\n        writer = csv.DictWriter(fp, r.keys(), delimiter=arguments.separator)\n        writer.writeheader()\n        writer.writerow(r)\n        writer.writerows(results)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(args=sys.argv[1:]):\n    parser = argparse.ArgumentParser(description=\"\"\"Aggregate results of\n            nestly runs\"\"\")\n    subparsers = parser.add_subparsers()\n    delim_parser = subparsers.add_parser('delim', help=\"\"\"Combine control files\n            with delimited files.\"\"\")\n    delim_parser.set_defaults(func=delim)\n    key_group = delim_parser.add_mutually_exclusive_group()\n    key_group.add_argument('-k', '--keys', help=\"\"\"Comma separated list of\n            keys from the JSON file to include [default: all keys]\"\"\",\n            type=comma_separated_values)\n    key_group.add_argument('-x', '--exclude-keys', help=\"\"\"Comma separated\n            list of keys from the JSON file not to include [default:\n            %(default)s]\"\"\", type=comma_separated_values)\n    delim_parser.add_argument('-m', '--missing-action', choices=('fail',\n        'warn'), help=\"\"\"Action to take when a file is missing [default:\n        %(default)s]\"\"\", default='fail')\n    delim_parser.add_argument('file_template', help=\"\"\"Template for the\n            delimited file to read in each directory [e.g. '{run_id}.csv']\"\"\")\n    delim_parser.add_argument('control_files', metavar=\"control.json\",\n            help=\"\"\"Control files\"\"\", nargs=\"*\")\n    delim_parser.add_argument('-d', '--directory', help=\"\"\"Run on all control\n            files under %(metavar)s. May be used in place of specifying control\n            files.\"\"\", metavar='DIR')\n    delim_parser.add_argument('-s', '--separator', default=DEFAULT_SEP,\n            help=\"\"\"Separator [default: %(default)s]\"\"\")\n    delim_parser.add_argument('-t', '--tab', action='store_const',\n            dest='separator', const='\\t', help=\"\"\"Files are tab-separated\"\"\")\n    delim_parser.add_argument('-o', '--output', default=sys.stdout,\n        type=argparse.FileType('w'), help=\"\"\"Output file [default: stdout]\"\"\")\n\n    arguments = parser.parse_args()\n\n    arguments.func(arguments)", "response": "Command - line interface for nestagg\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes the object from the cache.", "response": "def delete(self):\n        \"\"\"\n        Deletes the object\n\n        :return:\n        :rtype: None\n        \"\"\"\n        return self._delete_request(endpoint=self.ENDPOINT + '/' + str(self.id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreceives data from the socket.", "response": "def recv(self, bufsize, **kws):\r\n        \"\"\"Receive data from the socket. The return value is a string\r\n        representing the data received. The amount of data may be less than the\r\n        ammount specified by _bufsize_. \"\"\"\r\n        return Recv(self, bufsize, timeout=self._timeout, **kws)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sendall(self, data, **kws):\r\n        return SendAll(self, data, timeout=self._timeout, **kws)", "response": "Send data to the socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses an OWL resource that s encoded in OWL / RDF into a NetworkX directional graph.", "response": "def parse_owl_rdf(iri):\n    \"\"\"Parses an OWL resource that's encoded in OWL/RDF into a NetworkX directional graph\n    \n    :param str iri: The location of the OWL resource to be parsed by Ontospy\n    :type iri: str\n    :rtype: network.DiGraph\n    \"\"\"\n    g = nx.DiGraph(IRI=iri)\n    o = Ontospy(iri)\n\n    for cls in o.classes:\n        g.add_node(cls.locale, type='Class')\n\n        for parent in cls.parents():\n            g.add_edge(cls.locale, parent.locale, type='SubClassOf')\n\n        for instance in cls.instances():\n            _, frag = urldefrag(instance)\n            g.add_edge(frag, cls.locale, type='ClassAssertion')\n\n    return g"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef linlin(value, in_min, in_max, out_min, out_max, clip=True):\n        if in_min == in_max:\n            if value == in_min and out_min == out_max:\n                return out_min\n            return None\n\n        output = ((out_min + out_max) + (out_max - out_min) * (\n            (2 * value - (in_min + in_max)) / float(in_max - in_min))) / 2.0\n        if clip:\n            output = Mapping.clip_value(output, out_min, out_max)\n        return output", "response": "linearly maps value in input range to output range"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef linexp(value, in_min, in_max, out_min, out_max, clip=True):\n        if out_min == 0:\n            return None\n        if in_min == in_max:\n            if value == in_min and out_min == out_max:\n                return out_min\n            return None\n\n        output = math.pow(out_max / out_min, (value - in_min) / (in_max - in_min)) * out_min\n        if clip:\n            output = Mapping.clip_value(output, out_min, out_max)\n        return output", "response": "This function maps a value in linear input range to an exponential output range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding models to execute and these models exist search indexes are deleted.", "response": "def find_models_and_delete_search_index(self, model, force, exec_models, check_only):\n        \"\"\"\n        Finds models to execute and these models' exist search indexes are deleted.\n        For other operations, necessary models are gathered to list(exec_models)\n\n        Args:\n            model: model to execute\n            force(bool): True or False if True, all given models are executed.\n            exec_models(list): if not force, models to execute are gathered to list.\n            If there is not necessity to migrate operation model doesn't put to exec list.\n            check_only: do not migrate, only report migration is needed or not if True\n\n        Returns:\n\n        \"\"\"\n        ins = model(fake_context)\n        fields = self.get_schema_fields(ins._collect_index_fields())\n        new_schema = self.compile_schema(fields)\n        bucket_name = model._get_bucket_name()\n        bucket_type = client.bucket_type(settings.DEFAULT_BUCKET_TYPE)\n        bucket = bucket_type.bucket(bucket_name)\n        index_name = \"%s_%s\" % (settings.DEFAULT_BUCKET_TYPE, bucket_name)\n        if not force:\n            try:\n                schema = get_schema_from_solr(index_name)\n                if schema == new_schema:\n                    print(\"Schema %s is already up to date, nothing to do!\" % index_name)\n                    return\n                elif check_only and schema != new_schema:\n                    print(\"Schema %s is not up to date, migrate this model!\" % index_name)\n                    return\n            except:\n                import traceback\n                traceback.print_exc()\n        bucket.set_property('search_index', 'foo_index')\n        try:\n            client.delete_search_index(index_name)\n        except RiakError as e:\n            if 'notfound' != e.value:\n                raise\n        wait_for_schema_deletion(index_name)\n        exec_models.append(model)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef creating_schema_and_index(self, models, func):\n        waiting_models = []\n        self.base_thread.do_with_submit(func, models, waiting_models, threads=self.threads)\n        if waiting_models:\n            print(\"WAITING MODELS ARE CHECKING...\")\n            self.creating_schema_and_index(waiting_models, func)", "response": "Executes given functions with given models and indexes the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_schema(self, model, waiting_models):\n        bucket_name = model._get_bucket_name()\n        index_name = \"%s_%s\" % (settings.DEFAULT_BUCKET_TYPE, bucket_name)\n        ins = model(fake_context)\n        fields = self.get_schema_fields(ins._collect_index_fields())\n        new_schema = self.compile_schema(fields)\n        schema = get_schema_from_solr(index_name)\n        if not (schema == new_schema):\n            try:\n                client.create_search_schema(index_name, new_schema)\n                print(\"+ %s (%s) search schema is created.\" % (model.__name__, index_name))\n            except:\n                print(\"+ %s (%s) search schema checking operation is taken to queue.\" % (\n                    model.__name__, index_name))\n                waiting_models.append(model)", "response": "Creates search schema for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_index(self, model, waiting_models):\n        bucket_name = model._get_bucket_name()\n        bucket_type = client.bucket_type(settings.DEFAULT_BUCKET_TYPE)\n        index_name = \"%s_%s\" % (settings.DEFAULT_BUCKET_TYPE, bucket_name)\n        bucket = bucket_type.bucket(bucket_name)\n        try:\n            client.get_search_index(index_name)\n            if not (bucket.get_property('search_index') == index_name):\n                bucket.set_property('search_index', index_name)\n                print(\"+ %s (%s) search index is created.\" % (model.__name__, index_name))\n        except RiakError:\n            try:\n                client.create_search_index(index_name, index_name, self.n_val)\n                bucket.set_property('search_index', index_name)\n                print(\"+ %s (%s) search index is created.\" % (model.__name__, index_name))\n            except RiakError:\n                print(\"+ %s (%s) search index checking operation is taken to queue.\" % (\n                model.__name__, index_name))\n                waiting_models.append(model)", "response": "Creates search indexes for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a text report for the human user", "response": "def create_report(self):\n        \"\"\"\n        creates a text report for the human user\n        :return: str\n        \"\"\"\n\n        if self.report:\n            self.report += \"\\n Operation took %s secs\" % round(\n                time.time() - self.t1)\n        else:\n            self.report = \"Operation failed: %s \\n\" % self.report\n        return self.report"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncompiling schema from base solr schema", "response": "def compile_schema(fields):\n        \"\"\"\n        joins schema fields with base solr schema\n\n        :param list[str] fields: field list\n        :return: compiled schema\n        :rtype: byte\n        \"\"\"\n        path = os.path.dirname(os.path.realpath(__file__))\n        # path = os.path.dirname(\n        #     os.path.abspath(inspect.getfile(inspect.currentframe())))\n        with codecs.open(\"%s/solr_schema_template.xml\" % path, 'r', 'utf-8') as fh:\n            schema_template = fh.read()\n\n        schema = schema_template.format('\\n'.join(fields))\n        if six.PY2:\n            return schema.encode('utf-8')\n\n        return schema"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfunctioning to return the number of times q1 and q2", "response": "def func2(q1, q2):\n    \"\"\"\n    to demonstrate debugging on exception\n    \"\"\"\n\n    a = q1/q2\n    \n    if q2 == 5:\n        z = 100\n        IPS() # start embedded ipython shell in the local scope\n        # -> explore global namespace\n\n    \n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_model(self, model, meta_data=None, index_fields=None):\n        return self.adapter.save_model(model, meta_data, index_fields)", "response": "Saves the model instance to riak\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new instance of the model class with the given data.", "response": "def _make_model(self, data, key=None):\n        \"\"\"\n        Creates a model instance with the given data.\n\n        Args:\n            data: Model data returned from DB.\n            key: Object key\n        Returns:\n            pyoko.Model object.\n        \"\"\"\n        if data['deleted'] and not self.adapter.want_deleted:\n            raise ObjectDoesNotExist('Deleted object returned')\n        model = self._model_class(self._current_context,\n                                  _pass_perm_checks=self._pass_perm_checks)\n\n        model.setattr('key', ub_to_str(key) if key else ub_to_str(data.get('key')))\n        model = model.set_data(data, from_db=True)\n        model._initial_data = model.clean_value()\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies given query filters.", "response": "def filter(self, all_records=False, **filters):\n        \"\"\"\n        Applies given query filters. If wanted result is more than specified size,\n        exception is raised about using all() method instead of filter.\n\n        Args:\n            all_records (bool):\n            **filters: Query filters as keyword arguments.\n\n        Returns:\n            Self. Queryset object.\n\n        Examples:\n            >>> Person.objects.filter(name='John') # same as .filter(name__exact='John')\n            >>> Person.objects.filter(age__gte=16, name__startswith='jo')\n            >>> # Assume u1 and u2 as related model instances.\n            >>> Person.objects.filter(work_unit__in=[u1, u2], name__startswith='jo')\n        \"\"\"\n\n        clone = copy.deepcopy(self)\n        clone.adapter.add_query(filters.items())\n        clone_length = clone.count()\n        if clone_length > self._cfg['row_size'] and not all_records:\n            raise Exception(\"\"\"Your query result count(%s) is more than specified result value(%s).\n            You can narrow your filters, you can apply your own pagination or\n            you can use all() method for getting all filter results.\n            Example Usage: Unit.objects.all()\n            \n            Filters: %s  Model Class: %s \n            \"\"\" % (clone_length, self._cfg['row_size'], filters, self._cfg['model_class']))\n\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exclude(self, **filters):\n        exclude = {'-%s' % key: value for key, value in filters.items()}\n        return self.filter(**exclude)", "response": "Applies query filters for excluding matching records from result set."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new object if it doesn t exist or creates a new one if necessary.", "response": "def get_or_create(self, defaults=None, **kwargs):\n        \"\"\"\n        Looks up an object with the given kwargs, creating a new one if necessary.\n\n        Args:\n            defaults (dict): Used when we create a new object. Must map to fields\n                of the model.\n            \\*\\*kwargs: Used both for filtering and new object creation.\n\n        Returns:\n            A tuple of (object, created), where created is a boolean variable\n            specifies whether the object was newly created or not.\n\n        Example:\n            In the following example, *code* and *name* fields are used to query the DB.\n\n            .. code-block:: python\n\n                obj, is_new = Permission.objects.get_or_create({'description': desc},\n                                                                code=code, name=name)\n\n            {description: desc} dict is just for new creations. If we can't find any\n            records by filtering on *code* and *name*, then we create a new object by\n            using all of the inputs.\n\n\n        \"\"\"\n        try:\n            return self.get(**kwargs), False\n        except ObjectDoesNotExist:\n            pass\n\n        data = defaults or {}\n        data.update(kwargs)\n        return self._model_class(**data).blocking_save(), True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes an object if it exists in database according to given query parameters and returns True otherwise does nothing. Returns False.", "response": "def delete_if_exists(self, **kwargs):\n        \"\"\"\n        Deletes an object if it exists in database according to given query \n        parameters and returns True otherwise does nothing and returns False.\n        \n        Args:\n            **kwargs: query parameters\n\n        Returns(bool): True or False \n\n        \"\"\"\n        try:\n            self.get(**kwargs).blocking_delete()\n            return True\n        except ObjectDoesNotExist:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the matching objects for the specified fields.", "response": "def update(self, **kwargs):\n        \"\"\"\n        Updates the matching objects for specified fields.\n\n        Note:\n            Post/pre save hooks and signals will NOT triggered.\n\n            Unlike RDBMS systems, this method makes individual save calls\n            to backend DB store. So this is exists as more of a comfortable\n            utility method and not a performance enhancement.\n\n        Keyword Args:\n            \\*\\*kwargs: Fields with their corresponding values to be updated.\n\n        Returns:\n            Int. Number of updated objects.\n\n        Example:\n            .. code-block:: python\n\n                Entry.objects.filter(pub_date__lte=2014).update(comments_on=False)\n        \"\"\"\n        do_simple_update = kwargs.get('simple_update', True)\n        no_of_updates = 0\n        for model in self:\n            no_of_updates += 1\n            model._load_data(kwargs)\n            model.save(internal=True)\n        return no_of_updates"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, key=None, **kwargs):\n        clone = copy.deepcopy(self)\n        # If we are in a slice, adjust the start and rows\n        if self._start:\n            clone.adapter.set_params(start=self._start)\n        if self._rows:\n            clone.adapter.set_params(rows=self._rows)\n        if key:\n            data, key = clone.adapter.get(key)\n        elif kwargs:\n            data, key = clone.filter(**kwargs).adapter.get()\n        else:\n            data, key = clone.adapter.get()\n        if clone._cfg['rtype'] == ReturnType.Object:\n            return data, key\n        return self._make_model(data, key)", "response": "Retrieves the object from DB."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self):\n        clone = copy.deepcopy(self)\n        # clone.adapter.want_deleted = True\n        return [item.delete() and item for item in clone]", "response": "Delete all objects that match to the queryset."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of values for given fields.", "response": "def values_list(self, *args, **kwargs):\n        \"\"\"\n        Returns list of values for given fields.\n        Since this will implicitly use data() method,\n        it's more efficient than simply looping through model instances.\n\n\n        Args:\n            flatten (bool): True. Flatten if there is only one field name given.\n             Returns ['one','two', 'three'] instead of\n             [['one'], ['two'], ['three]]\n            \\*args: List of fields to be retured as list.\n\n        Returns:\n            List of deleted objects or None if *confirm* not set.\n\n        Example:\n            >>> Person.objects.filter(age__gte=16).values_list('name', 'lastname')\n\n        \"\"\"\n        results = []\n        for data, key in self.data():\n            results.append([data[val] if val != 'key' else key for val in args])\n        return results if len(args) > 1 or not kwargs.get('flatten', True) else [\n            i[0] for i in results]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef values(self, *args):\n        return [dict(zip(args, values_list))\n                for values_list in self.values_list(flatten=False, *args)]", "response": "Returns list of dicts for given fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump(self):\n        results = []\n        for data in self.data():\n            results.append(data)\n        return results", "response": "Dump raw JSON output of matching queryset objects."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new Queryset object with the given filters joined with OR operator.", "response": "def or_filter(self, **filters):\n        \"\"\"\n        Works like \"filter\" but joins given filters with OR operator.\n\n        Args:\n            **filters: Query filters as keyword arguments.\n\n        Returns:\n            Self. Queryset object.\n\n        Example:\n            >>> Person.objects.or_filter(age__gte=16, name__startswith='jo')\n\n        \"\"\"\n        clone = copy.deepcopy(self)\n        clone.adapter.add_query([(\"OR_QRY\", filters)])\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nswitch default query joiner from AND to OR", "response": "def OR(self):\n        \"\"\"\n        Switches default query joiner from \" AND \" to \" OR \"\n\n        Returns:\n            Self. Queryset object.\n        \"\"\"\n        clone = copy.deepcopy(self)\n        clone.adapter._QUERY_GLUE = ' OR '\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching for query on given fields.", "response": "def search_on(self, *fields, **query):\n        \"\"\"\n        Search for query on given fields.\n\n        Query modifier can be one of these:\n            * exact\n            * contains\n            * startswith\n            * endswith\n            * range\n            * lte\n            * gte\n\n        Args:\n            \\*fields (str): Field list to be searched on\n            \\*\\*query:  Search query. While it's implemented as \\*\\*kwargs\n             we only support one (first) keyword argument.\n\n        Returns:\n            Self. Queryset object.\n\n        Examples:\n            >>> Person.objects.search_on('name', 'surname', contains='john')\n            >>> Person.objects.search_on('name', 'surname', startswith='jo')\n        \"\"\"\n        clone = copy.deepcopy(self)\n        clone.adapter.search_on(*fields, **query)\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply query ordering. Args: **args: Order by fields names. Defaults to ascending, prepend with hypen (-) for desecending ordering. Returns: Self. Queryset object. Examples: >>> Person.objects.order_by('-name', 'join_date')", "response": "def order_by(self, *args):\n        \"\"\"\n        Applies query ordering.\n\n        Args:\n            **args: Order by fields names.\n            Defaults to ascending, prepend with hypen (-) for desecending ordering.\n\n        Returns:\n            Self. Queryset object.\n\n        Examples:\n            >>> Person.objects.order_by('-name', 'join_date')\n        \"\"\"\n        clone = copy.deepcopy(self)\n        clone.adapter.ordered = True\n        if args:\n            clone.adapter.order_by(*args)\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_params(self, **params):\n        clone = copy.deepcopy(self)\n        clone.adapter.set_params(**params)\n        return clone", "response": "add or update solr query parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a copy of the object with the same key.", "response": "def data(self):\n        \"\"\"\n        return (data_dict, key) tuple instead of models instances\n        \"\"\"\n        clone = copy.deepcopy(self)\n        clone._cfg['rtype'] = ReturnType.Object\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a raw query", "response": "def raw(self, query):\n        \"\"\"\n        make a raw query\n\n        Args:\n        query (str): solr query\n        \\*\\*params: solr parameters\n        \"\"\"\n        clone = copy.deepcopy(self)\n        clone.adapter._pre_compiled_query = query\n        clone.adapter.compiled_query = query\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the user for the given certificate.", "response": "def userForCert(store, cert):\n    \"\"\"Gets the user for the given certificate.\n\n    \"\"\"\n    return store.findUnique(User, User.email == emailForCert(cert))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getContext(self):\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_certificate_file(\"cert.pem\")\n        ctx.use_privatekey_file(\"key.pem\")\n        ctx.load_tmp_dh(\"dhparam.pem\")\n        ctx.set_options(OP_SINGLE_DH_USE|OP_NO_SSLv2|OP_NO_SSLv3)\n        ctx.set_verify(VERIFY_PEER, self._verify)\n        return ctx", "response": "Creates a new context."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tablename_from_link(klass, link):\n        arr = link.split(\"/\")\n        i = arr.index(\"table\")\n        tn = arr[i+1]\n        return tn", "response": "Helper method for URL s that look like / api / now / v1 / table"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of links that are used to create the resource.", "response": "def links(self):\n        \"\"\"\n        returns {attr1: href, attr2: href2}\n        \"\"\"\n        dlinks = {}\n        for key, value in self.__dict__.items():\n            if isinstance(value, dict) and value['link']:\n                dlinks[key] = value['link']\n        return dlinks"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(path, code, params=None, ignore=None, select=None, **meta):\n        logger.debug('Start pylint')\n\n        clear_cache = params.pop('clear_cache', False)\n        if clear_cache:\n            MANAGER.astroid_cache.clear()\n\n        class Reporter(BaseReporter):\n\n            def __init__(self):\n                self.errors = []\n                super(Reporter, self).__init__()\n\n            def _display(self, layout):\n                pass\n\n            def handle_message(self, msg):\n                self.errors.append(dict(\n                    lnum=msg.line,\n                    col=msg.column,\n                    text=\"%s %s\" % (msg.msg_id, msg.msg),\n                    type=msg.msg_id[0]\n                ))\n\n        params = _Params(ignore=ignore, select=select, params=params)\n        logger.debug(params)\n\n        reporter = Reporter()\n\n        try:\n            Run([path] + params.to_attrs(), reporter=reporter, do_exit=False)\n        except TypeError:\n            # support pylint<2.0\n            # see https://github.com/PyCQA/pylint/commit/4210ef9b8c5d9e7b33ff0542683f18b8031193fa\n            import pylint\n            if pylint.__version__.split('.')[0] != '1':\n                raise\n            Run([path] + params.to_attrs(), reporter=reporter, exit=False)\n\n        return reporter.errors", "response": "Run a code file and return a list of errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rate_limit(max_interval=20, sampling=3, f=lambda x: x):\n\t'''x rises by 1 from 0 on each iteraton, back to 0 on triggering.\n\t\tf(x) should rise up to f(max_interval) in some way (with default\n\t\t\t\"f(x)=x\" probability rises lineary with 100% chance on \"x=max_interval\").\n\t\t\"sampling\" affect probablility in an \"c=1-(1-c0)*(1-c1)*...*(1-cx)\" exponential way.'''\n\tfrom random import random\n\tval = 0\n\tval_max = float(f(max_interval))\n\twhile True:\n\t\tif val % sampling == 0:\n\t\t\ttrigger = random() > (val_max - f(val)) / val_max\n\t\t\tif trigger: val = 0\n\t\t\tyield trigger\n\t\telse: yield False\n\t\tval += 1", "response": "A generator that yields True if the iteration is over the max_interval."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_line_segments(line):\n    line = line.strip()\n\n    tokens = tk.generate_tokens(io.StringIO(line).readline)\n\n    equality_signs = [-1]\n    comment_tuple = None, \"\"\n    for i, t in enumerate(tokens):\n        if t.type == tk.COMMENT:\n            # store string_index and comment string\n            comment_tuple = t.start[1], t.string\n        if t.type == tk.OP and t.string == \"=\":\n            equality_signs.append(t.start[1])\n\n    if len(equality_signs) > 1:\n        # we have at least one assignment\n        lhs = line[equality_signs[-2]+1:equality_signs[-1]].strip()\n        equality_signs.pop(0)\n    else:\n        lhs = None\n\n    rhs_start_idx = equality_signs[-1] + 1\n\n    # from the last `=` until the beginning of the comment\n    rhs = line[rhs_start_idx:comment_tuple[0]].strip()\n    if rhs == \"\":\n        rhs = None\n    comment = comment_tuple[1].strip()\n\n    return lhs, rhs, comment", "response": "Split up a line into lhs rhs comment flags\n\n    lhs ist defined as the leftmost assignment\n    rhs ist defined as the leftmost assignment\n    comment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collectstatic(force=False):\n    # noise reduction: only collectstatic if not in debug mode\n    from django.conf import settings\n    if force or not settings.DEBUG:\n        tasks.manage('collectstatic', '--noinput')\n        print('... finished collectstatic')\n        print('')\n    else:\n        print('... skipping collectstatic as settings.DEBUG=True; If you want to generate staticfiles anyway, run ape collectstatic instead;')", "response": "collect static files for production httpd"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_manifests(self):\n        for path in self.plugin_paths:\n            for item in os.listdir(path):\n                item_path = os.path.join(path, item)\n                if os.path.isdir(item_path):\n                    self.load_manifest(item_path)", "response": "Loads all plugin manifests on the plugin paths"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload a plugin manifest from a given folder.", "response": "def load_manifest(self, path):\n        \"\"\"\n        Loads a plugin manifest from a given path\n\n        :param path: The folder to load the plugin manifest from\n        \"\"\"\n        manifest_path = os.path.join(path, \"plugin.json\")\n        self._logger.debug(\"Attempting to load plugin manifest from {}.\".format(manifest_path))\n        try:\n            with open(manifest_path) as f:\n                manifest = json.load(f)\n            manifest[\"path\"] = path\n            self._manifests.append(manifest)\n            self._logger.debug(\"Loaded plugin manifest from {}.\".format(manifest_path))\n        except ValueError:\n            self._logger.error(\"Failed to decode plugin manifest at {}.\".format(manifest_path))\n        except (OSError, IOError) as e:\n            self._logger.error(\"Failed to load plugin manifest at {}.\".format(manifest_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a plugin from the given manifest.", "response": "def load_plugin(self, manifest, *args):\n        \"\"\"\n        Loads a plugin from the given manifest\n\n        :param manifest: The manifest to use to load the plugin\n        :param args: Arguments to pass to the plugin\n        \"\"\"\n        if self.get_plugin_loaded(manifest[\"name\"]):\n            self._logger.debug(\"Plugin {} is already loaded.\".format(manifest[\"name\"]))\n            return\n        try:\n            self._logger.debug(\"Attempting to load plugin {}.\".format(manifest[\"name\"]))\n            for dependency in manifest.get(\"dependencies\", []):\n                if not self.get_plugin_loaded(dependency):\n                    self._logger.debug(\"Must load dependency {} first.\".format(dependency))\n                    if self.get_manifest(dependency) is None:\n                        self._logger.error(\"Dependency {} could not be found.\".format(dependency))\n                    else:\n                        self.load_plugin(self.get_manifest(dependency), *args)\n\n            not_loaded = [i for i in manifest.get(\"dependencies\", []) if not self.get_plugin_loaded(i)]\n            if len(not_loaded) != 0:\n                self._logger.error(\"Plugin {} failed to load due to missing dependencies. Dependencies: {}\".format(\n                    manifest[\"name\"], \", \".join(not_loaded)\n                ))\n                return\n\n            if PY3:\n                spec = importlib.util.spec_from_file_location(\n                    manifest.get(\"module_name\", manifest[\"name\"].replace(\" \", \"_\")),\n                    os.path.join(manifest[\"path\"], manifest.get(\"main_path\", \"__init__.py\"))\n                )\n                module = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(module)\n            else:\n                module = imp.load_source(\n                    manifest.get(\"module_name\", manifest[\"name\"].replace(\" \", \"_\")),\n                    os.path.join(manifest[\"path\"], manifest.get(\"main_path\", \"__init__.py\"))\n                )\n\n            module_class = manifest.get(\"main_class\", \"Plugin\")\n            plugin_class = getattr(module, module_class)\n            if issubclass(plugin_class, self._plugin_class):\n                plugin = plugin_class(manifest, *args)\n            else:\n                self._logger.error(\"Failed to load {} due to invalid baseclass.\".format(manifest[\"name\"]))\n                return\n            self._plugins[manifest[\"name\"]] = plugin\n            self._modules[manifest[\"name\"]] = module\n\n            self._logger.debug(\"Plugin {} loaded.\".format(manifest[\"name\"]))\n\n        except:\n            exc_path = os.path.join(manifest[\"path\"], \"error.log\")\n            with open(exc_path, \"w\") as f:\n                f.write(traceback.format_exc(5))\n            self._logger.error(\"Failed to load plugin {}. Error log written to {}.\".format(manifest[\"name\"], exc_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_plugins(self, *args):\n        for manifest in self._manifests:\n            self.load_plugin(manifest, *args)", "response": "Loads all plugins in the order they were registered."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all loaded plugins and modules", "response": "def get_all_plugins(self):\n        \"\"\"\n        Gets all loaded plugins\n\n        :return: List of all plugins\n        \"\"\"\n        return [{\n            \"manifest\": i,\n            \"plugin\": self.get_plugin(i[\"name\"]),\n            \"module\": self.get_module(i[\"name\"])\n        } for i in self._manifests]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reload_manifest(self, manifest):\n        self._logger.debug(\"Reloading manifest for {}.\".format(manifest.get(\"name\", \"Unnamed Plugin\")))\n        self._manifests.remove(manifest)\n        self.load_manifest(manifest[\"path\"])\n        self._logger.debug(\"Manifest reloaded.\")", "response": "Reloads a manifest from the disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reload_all_manifests(self):\n        self._logger.debug(\"Reloading all manifests.\")\n        self._manifests = []\n        self.load_manifests()\n        self._logger.debug(\"All manifests reloaded.\")", "response": "Reloads all loaded manifests and loads any new manifests."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reload_plugin(self, name, *args):\n        self._logger.debug(\"Reloading {}.\".format(name))\n\n        self._logger.debug(\"Disabling {}.\".format(name))\n        self.get_plugin(name).disable()\n\n        self._logger.debug(\"Removing plugin instance.\")\n        del self._plugins[name]\n\n        self._logger.debug(\"Unloading module.\")\n        del self._modules[name]\n\n        self._logger.debug(\"Reloading manifest.\")\n        old_manifest = self.get_manifest(name)\n        self._manifests.remove(old_manifest)\n        self.load_manifest(old_manifest[\"path\"])\n\n        self._logger.debug(\"Loading {}.\".format(name))\n        self.load_plugin(self.get_manifest(name), *args)\n\n        self._logger.debug(\"Enabling {}.\".format(name))\n        self.get_plugin(name).enable()\n\n        self._logger.debug(\"Plugin {} reloaded.\".format(name))", "response": "Reloads a given plugin from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reload_all_plugins(self, *args):\n        for manifest in self._manifests[:]:\n            if self.get_plugin(manifest[\"name\"]) is not None:\n                self.reload_plugin(manifest[\"name\"], *args)", "response": "Reloads all initialized plugins"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunloading a specified plugin from the cache.", "response": "def unload_plugin(self, name):\n        \"\"\"\n        Unloads a specified plugin\n        :param name: The name of the plugin\n        \"\"\"\n        self._logger.debug(\"Unloading {}.\".format(name))\n\n        self._logger.debug(\"Removing plugin instance.\")\n        del self._plugins[name]\n\n        self._logger.debug(\"Unloading module.\")\n        del self._modules[name]\n\n        self._logger.debug(\"Unloading manifest...\")\n        manifest = self.get_manifest(name)\n        self._manifests.remove(manifest)\n\n        self._logger.debug(\"{} unloaded.\".format(name))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef quickload(self, *args):\n        self.load_manifests()\n        self.load_plugins(args)\n        self.enable_all_plugins()", "response": "Loads all manifests loads all plugins and then enables all plugins"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding the next row from the source files.", "response": "def next(self):\n        \"\"\"\n        Yields the next row from the source files.\n        \"\"\"\n        for self._filename in self._filenames:\n            self._open()\n            for row in self._csv_reader:\n                self._row_number += 1\n                if self._fields:\n                    yield dict(zip_longest(self._fields, row, fillvalue=''))\n                else:\n                    yield row\n            self._close()\n            self._row_number = -1\n\n        self._filename = None\n        raise StopIteration"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening the next current file.", "response": "def _open_file(self, mode, encoding=None):\n        \"\"\"\n        Opens the next current file.\n\n        :param str mode: The mode for opening the file.\n        :param str encoding: The encoding of the file.\n        \"\"\"\n        if self._filename[-4:] == '.bz2':\n            self._file = bz2.open(self._filename, mode=mode, encoding=encoding)\n        else:\n            self._file = open(self._filename, mode=mode, encoding=encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a sample from the next current input file.", "response": "def _get_sample(self, mode, encoding):\n        \"\"\"\n        Get a sample from the next current input file.\n\n        :param str mode: The mode for opening the file.\n        :param str|None encoding: The encoding of the file. None for open the file in binary mode.\n        \"\"\"\n        self._open_file(mode, encoding)\n        self._sample = self._file.read(UniversalCsvReader.sample_size)\n        self._file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _detect_delimiter(self):\n        candidate_value = ','\n        candidate_count = 0\n        for delimiter in UniversalCsvReader.delimiters:\n            count = self._sample.count(delimiter)\n            if count > candidate_count:\n                candidate_value = delimiter\n                candidate_count = count\n\n        self._formatting_parameters['delimiter'] = candidate_value", "response": "Detects the field delimiter in the sample data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndetect the line ending in the sample data.", "response": "def _detect_line_ending(self):\n        \"\"\"\n        Detects the line ending in the sample data.\n        \"\"\"\n        candidate_value = '\\n'\n        candidate_count = 0\n        for line_ending in UniversalCsvReader.line_endings:\n            count = self._sample.count(line_ending)\n            if count > candidate_count:\n                candidate_value = line_ending\n                candidate_count = count\n\n        self._formatting_parameters['line_terminator'] = candidate_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens the next current file with proper settings for encoding and delimiter.", "response": "def _open(self):\n        \"\"\"\n        Opens the next current file with proper settings for encoding and delimiter.\n        \"\"\"\n        self._sample = None\n\n        formatting_parameters0 = {'encoding':        'auto',\n                                  'delimiter':       'auto',\n                                  'line_terminator': 'auto',\n                                  'escape_char':     '\\\\',\n                                  'quote_char':      '\"'}\n        formatting_parameters1 = self._helper.pass1(self._filename, formatting_parameters0)\n        self._formatting_parameters = formatting_parameters1\n\n        # Detect encoding.\n        if formatting_parameters1['encoding'] == 'auto':\n            self._get_sample('rb', None)\n            self._detect_encoding()\n\n        # Detect delimiter.\n        if formatting_parameters1['delimiter'] == 'auto':\n            self._get_sample('rt', formatting_parameters1['encoding'])\n            self._detect_delimiter()\n\n        # Detect line terminators.\n        if formatting_parameters1['line_terminator'] == 'auto':\n            if not self._sample:\n                self._get_sample('rt', formatting_parameters1['encoding'])\n            self._detect_line_ending()\n\n        self._formatting_parameters = self._helper.pass2(self._filename,\n                                                         self._formatting_parameters,\n                                                         formatting_parameters1)\n\n        self._open_file('rt', formatting_parameters1['encoding'])\n        self._csv_reader = csv.reader(self._file,\n                                      delimiter=self._formatting_parameters['delimiter'],\n                                      escapechar=self._formatting_parameters['escape_char'],\n                                      lineterminator=self._formatting_parameters['line_terminator'],\n                                      quotechar=self._formatting_parameters['quote_char'])  # Ignored\n\n        self._sample = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_syntax(self):\n        '''\n        Prints a list of available syntax for the current paste service\n        '''\n        syntax_list = ['Available syntax for %s:' %(self)]\n        logging.info(syntax_list[0])\n        for key in self.SYNTAX_DICT.keys():\n            syntax = '\\t%-20s%-30s' %(key, self.SYNTAX_DICT[key])\n            logging.info(syntax)\n            syntax_list.append(syntax)\n\n        return syntax_list", "response": "Prints a list of available syntax for the current paste service\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the commmon output of the current object.", "response": "def process_commmon(self):\n        '''\n        Some data processing common for all services.\n        No need to override this.\n        '''\n        data = self.data\n        data_content = data['content'][0]\n\n        ## Paste the output of a command\n        # This is deprecated after piping support\n        if data['command']:\n            try:\n                call = subprocess.Popen(data_content.split(),\n                                        stderr=subprocess.PIPE,\n                                        stdout = subprocess.PIPE)\n                out, err = call.communicate()\n                content = out\n            except OSError:\n                logging.exception('Cannot execute the command')\n                content = ''\n\n            if not data['title']:\n                data['title'] = 'Output of command: `%s`' %(data_content)\n\n        ## Paste the output of a file\n        # This is deprecated after piping support\n        elif data['file']:\n            try:\n                f = file(data_content)\n                content = f.read()\n                f.close()\n            except IOError:\n                logging.exception('File not present or unreadable')\n                content = ''\n\n            if not data['title']:\n                data['title'] = 'File: `%s`' %(data_content)\n        else:\n            content = data_content\n\n        self.data['content'] = content\n        self.data['syntax'] = self.SYNTAX_DICT.get(self.data['syntax'], '')\n\n        # Excluded data not useful in paste information\n        for key in ['func', 'verbose', 'service', 'extra', 'command', 'file']:\n            del self.data[key]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_response(self):\n        '''\n        Returns response according submitted the data and method.\n        '''\n        self.process_commmon()\n        self.process_data()\n        urlencoded_data = urllib.urlencode(self.data)\n        if self.METHOD == POST:\n            req = urllib2.Request(self.URL, urlencoded_data)\n        else:\n            req = urllib2.Request('%s?%s' %(self.URL, urlencoded_data))\n\n        if not self.data['content']:\n            raise PasteException(\"No content to paste\")\n\n        self.response = urllib2.urlopen(req)\n        return self.response", "response": "Returns the response according submitted the data and method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the URL for the paste.", "response": "def url(self):\n        '''\n        Executes the methods to send request, process the response and then\n        publishes the url.\n        '''\n        self.get_response()\n        url = self.process_response()\n\n        if url:\n            logging.info('Your paste has been published at %s' %(url))\n            return url\n        else:\n            logging.error('Did not get a URL back for the paste')\n            raise PasteException(\"No URL for paste\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget api user key to enable posts from user accounts.", "response": "def get_api_user_key(self, api_dev_key, username=None, password=None):\n        '''\n        Get api user key to enable posts from user accounts if username\n        and password available.\n        Not getting an api_user_key means that the posts will be \"guest\" posts\n        '''\n        username = username or get_config('pastebin', 'api_user_name')\n        password = password or get_config('pastebin', 'api_user_password')\n        if username and password:\n            data = {\n                'api_user_name': username,\n                'api_user_password': password,\n                'api_dev_key': api_dev_key,\n            }\n            urlencoded_data = urllib.urlencode(data)\n            req = urllib2.Request('http://pastebin.com/api/api_login.php',\n                                  urlencoded_data)\n            response = urllib2.urlopen(req)\n            user_key = response.read()\n            logging.debug(\"User key: %s\" % user_key)\n            return user_key\n        else:\n            logging.info(\"Pastebin: not using any user key\")\n            return \"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_any():\r\n    \"Returns the best available proactor implementation for the current platform.\"\r\n    return get_first(has_ctypes_iocp, has_iocp, has_stdlib_kqueue, has_kqueue, \r\n                        has_stdlib_epoll, has_epoll, has_poll, has_select)", "response": "Returns the best available proactor implementation for the current platform."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy(self, name=None, description=None, meta=None):\n        cls = self.__class__\n        kwargs = self._rel(copy=True)\n        kwargs.update(self._data(copy=True))\n        if name is not None:\n            kwargs['name'] = name\n        if description is not None:\n            kwargs['description'] = description\n        if meta is not None:\n            kwargs['meta'] = meta\n        return cls(**kwargs)", "response": "Create a copy of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef slice_cardinal(self, key):\n        if self._cardinal:\n            cls = self.__class__\n            key = check_key(self[self._cardinal], key, cardinal=True)\n            g = self.network(fig=False)\n            kwargs = {self._cardinal: self[self._cardinal].ix[key], 'name': self.name,\n                      'description': self.description, 'meta': self.meta}\n            # Next traverse, breadth first, all data objects\n            for parent, child in nx.bfs_edges(g, self._cardinal):\n                if child in kwargs:\n                    continue\n                typ = g.edge_types[(parent, child)]\n                if self._cardinal in self[child].columns and hasattr(self[child], 'slice_cardinal'):\n                    kwargs[child] = self[child].slice_cardinal(key)\n                elif typ == 'index-index':\n                    # Select from the child on the parent's index (the parent is\n                    # in the kwargs already).\n                    kwargs[child] = self[child].ix[kwargs[parent].index.values]\n                elif typ == 'index-column':\n                    # Select from the child where the column (of the same name as\n                    # the parent) is in the parent's index values\n                    cdf = self[child]\n                    kwargs[child] = cdf[cdf[parent].isin(kwargs[parent].index.values)]\n                elif typ == 'column-index':\n                    # Select from the child where the child's index is in the\n                    # column of the parent. Note that this relationship\n                    cdf = self[child]\n                    cin = cdf.index.name\n                    cols = [col for col in kwargs[parent] if cin == col or (cin == col[:-1] and col[-1].isdigit())]\n                    index = kwargs[parent][cols].stack().astype(np.int64).values\n                    kwargs[child] = cdf[cdf.index.isin(index)]\n            return cls(**kwargs)", "response": "Slice the container according to its cardinal axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cardinal_groupby(self):\n        if self._cardinal:\n            g = self.network(fig=False)\n            cardinal_indexes = self[self._cardinal].index.values\n            selfs = {}\n            cls = self.__class__\n            for cardinal_index in cardinal_indexes:\n                kwargs = {self._cardinal: self[self._cardinal].ix[[cardinal_index]]}\n                for parent, child in nx.bfs_edges(g):\n                    if child in kwargs:\n                        continue\n                    typ = g.edge_types[(parent, child)]\n                    if self._cardinal in self[child].columns and hasattr(self[child], 'slice_cardinal'):\n                        kwargs[child] = self[child].slice_cardinal(key)\n                    elif typ == 'index-index':\n                        # Select from the child on the parent's index (the parent is\n                        # in the kwargs already).\n                        kwargs[child] = self[child].ix[kwargs[parent].index.values]\n                    elif typ == 'index-column':\n                        # Select from the child where the column (of the same name as\n                        # the parent) is in the parent's index values\n                        cdf = self[child]\n                        kwargs[child] = cdf[cdf[parent].isin(kwargs[parent].index.values)]\n                    elif typ == 'column-index':\n                        # Select from the child where the child's index is in the\n                        # column of the parent. Note that this relationship\n                        cdf = self[child]\n                        cin = cdf.index.name\n                        cols = [col for col in kwargs[parent] if cin == col or (cin == col[:-1] and col[-1].isdigit())]\n                        index = kwargs[parent][cols].stack().astype(np.int64).values\n                        kwargs[child] = cdf[cdf.index.isin(index)]\n                selfs[cardinal_index] = cls(**kwargs)\n        return selfs", "response": "Create an instance of this class for every step in the cardinal dimension."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef info(self):\n        names = []\n        types = []\n        sizes = []\n        names.append('WIDGET')\n        types.append('-')\n        s = 0\n        sizes.append(s)\n        names.append('METADATA')\n        types.append('-')\n        s = 0\n        for obj in self._rel().values():\n            s += getsizeof(obj)\n        sizes.append(s)\n        for name, obj in self._data().items():\n            names.append(name[1:] if name.startswith('_') else name)\n            types.append('.'.join((obj.__module__, obj.__class__.__name__)))\n            if isinstance(obj, pd.Series):\n                sizes.append(obj.memory_usage())\n            else:\n                sizes.append(obj.memory_usage().sum())\n        inf = pd.DataFrame.from_dict({'object': names, 'type': types, 'size': sizes})\n        inf.set_index('object', inplace=True)\n        return inf.sort_index()", "response": "Display information about the container s data objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef memory_usage(self, string=False):\n        if string:\n            n = getsizeof(self)\n            return ' '.join((str(s) for s in convert_bytes(n)))\n        return self.info()['size']", "response": "Get the memory usage estimate of the container."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a network object containing information about the container s object relationships.", "response": "def network(self, figsize=(14, 9), fig=True):\n        \"\"\"\n        Display information about the container's object relationships.\n\n        Nodes correspond to data objects. The size of the node corresponds\n        to the size of the table in memory. The color of the node corresponds\n        to its fundamental data type. Nodes are labeled by their container\n        name; class information is listed below. The color of the connections\n        correspond to the type of relationship; either an index of one table\n        corresponds to a column in another table or the two tables share an\n        index.\n\n        Args:\n            figsize (tuple): Tuple containing figure dimensions\n            fig (bool): Generate the figure (default true)\n\n        Returns:\n            graph: Network graph object containing data relationships\n        \"\"\"\n        conn_types = ['index-index', 'index-column']\n        conn_colors = mpl.sns.color_palette('viridis', len(conn_types))\n        conn = dict(zip(conn_types, conn_colors))\n\n        def get_node_type_color(obj):\n            \"\"\"Gets the color of a node based on the node's (sub)type.\"\"\"\n            cols = mpl.sns.color_palette('viridis', len(conn_types))\n            for col in cols:\n                if isinstance(obj, (pd.DataFrame, pd.Series, pd.SparseSeries, pd.SparseDataFrame)):\n                    typ = type(obj)\n                    return '.'.join((typ.__module__, typ.__name__)), col\n            return 'other', 'gray'\n\n        def legend(items, name, loc, ax):\n            \"\"\"Legend creation helper function.\"\"\"\n            proxies = []\n            descriptions = []\n            for label, color in items:\n                if label == 'column-index':\n                    continue\n                if name == 'Data Type':\n                    line = mpl.sns.mpl.lines.Line2D([], [], linestyle='none', color=color, marker='o')\n                else:\n                    line = mpl.sns.mpl.lines.Line2D([], [], linestyle='-', color=color)\n                proxies.append(line)\n                descriptions.append(label)\n            lgnd = ax.legend(proxies, descriptions, title=name, loc=loc, frameon=True)\n            lgnd_frame = lgnd.get_frame()\n            lgnd_frame.set_facecolor('white')\n            lgnd_frame.set_edgecolor('black')\n            return lgnd, ax\n\n        info = self.info()\n        info = info[info['type'] != '-']\n        info['size'] *= 13000/info['size'].max()\n        info['size'] += 2000\n        node_size_dict = info['size'].to_dict()      # Can pull all nodes from keys\n        node_class_name_dict = info['type'].to_dict()\n        node_type_dict = {}    # Values are tuple of \"underlying\" type and color\n        node_conn_dict = {}    # Values are tuple of connection type and color\n        items = self._data().items()\n        for k0, v0 in items:\n            n0 = k0[1:] if k0.startswith('_') else k0\n            node_type_dict[n0] = get_node_type_color(v0)\n            for k1, v1 in items:\n                if v0 is v1:\n                    continue\n                n1 = k1[1:] if k1.startswith('_') else k1\n                for name in v0.index.names:    # Check the index of data object 0 against the index\n                    if name is None:           # and columns of data object 1\n                        continue\n                    if name in v1.index.names:\n                        contyp = 'index-index'\n                        node_conn_dict[(n0, n1)] = (contyp, conn[contyp])\n                        node_conn_dict[(n1, n0)] = (contyp, conn[contyp])\n                    for col in v1.columns:\n                        # Catches index \"atom\", column \"atom1\"; does not catch atom10\n                        if name == col or (name == col[:-1] and col[-1].isdigit()):\n                            contyp = 'index-column'\n                            node_conn_dict[(n0, n1)] = (contyp, conn[contyp])\n                            node_conn_dict[(n1, n0)] = ('column-index', conn[contyp])\n        g = nx.Graph()\n        g.add_nodes_from(node_size_dict.keys())\n        g.add_edges_from(node_conn_dict.keys())\n        node_sizes = [node_size_dict[node] for node in g.nodes()]\n        node_labels = {node: ' {}\\n({})'.format(node, node_class_name_dict[node]) for node in g.nodes()}\n        node_colors = [node_type_dict[node][1] for node in g.nodes()]\n        edge_colors = [node_conn_dict[edge][1] for edge in g.edges()]\n        # Build the figure and legends\n        if fig:\n            fig, ax = plt.subplots(1, figsize=figsize)\n            ax.axis('off')\n            pos = nx.spring_layout(g)\n            nx.draw_networkx_nodes(g, pos=pos, ax=ax, alpha=0.7, node_size=node_sizes,\n                                        node_color=node_colors)\n            nx.draw_networkx_labels(g, pos=pos, labels=node_labels, font_size=17,\n                                         font_weight='bold', ax=ax)\n            nx.draw_networkx_edges(g, pos=pos, edge_color=edge_colors, width=2, ax=ax)\n            l1, ax = legend(set(node_conn_dict.values()), 'Connection', (1, 0), ax)\n            _, ax = legend(set(node_type_dict.values()), 'Data Type', (1, 0.3), ax)\n            fig.gca().add_artist(l1)\n        g.edge_types = {node: value[0] for node, value in node_conn_dict.items()}  # Attached connection information to network graph\n        return g"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the container as an HDF5 archive.", "response": "def save(self, path=None, complevel=1, complib='zlib'):\n        \"\"\"\n        Save the container as an HDF5 archive.\n\n        Args:\n            path (str): Path where to save the container\n        \"\"\"\n        if path is None:\n            path = self.hexuid + '.hdf5'\n        elif os.path.isdir(path):\n            path += os.sep + self.hexuid + '.hdf5'\n        elif not (path.endswith('.hdf5') or path.endswith('.hdf')):\n            raise ValueError('File path must have a \".hdf5\" or \".hdf\" extension.')\n        with pd.HDFStore(path, 'w', complevel=complevel, complib=complib) as store:\n            store['kwargs'] = pd.Series()\n            store.get_storer('kwargs').attrs.metadata = self._rel()\n            fc = 0    # Field counter (see special handling of fields below)\n            for name, data in self._data().items():\n                if hasattr(data, '_revert_categories'):\n                    data._revert_categories()\n                name = name[1:] if name.startswith('_') else name\n                if isinstance(data, Field):    # Fields are handled separately\n                    fname = 'FIELD{}_'.format(fc) + name + '/'\n                    store[fname + 'data'] = pd.DataFrame(data)\n                    for i, field in enumerate(data.field_values):\n                        ffname = fname + 'values' + str(i)\n                        if isinstance(field, pd.Series):\n                            store[ffname] = pd.Series(field)\n                        else:\n                            store[ffname] = pd.DataFrame(field)\n                    fc += 1\n                elif isinstance(data, Series):\n                    s = pd.Series(data)\n                    if isinstance(data.dtype, pd.types.dtypes.CategoricalDtype):\n                        s = s.astype('O')\n                    store[name] = s\n                elif isinstance(data, DataFrame):\n                    store[name] = pd.DataFrame(data)\n                elif isinstance(data, SparseSeries):\n                    s = pd.SparseSeries(data)\n                    if isinstance(data.dtype, pd.types.dtypes.CategoricalDtype):\n                        s = s.astype('O')\n                    store[name] = s\n                elif isinstance(data, SparseDataFrame):\n                    store[name] = pd.SparseDataFrame(data)\n                else:\n                    if hasattr(data, 'dtype') and isinstance(data.dtype, pd.types.dtypes.CategoricalDtype):\n                        data = data.astype('O')\n                    else:\n                        for col in data:\n                            if isinstance(data[col].dtype, pd.types.dtypes.CategoricalDtype):\n                                data[col] = data[col].astype('O')\n                    store[name] = data\n                if hasattr(data, '_set_categories'):\n                    data._set_categories()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a container object from a persistent location or file path.", "response": "def load(cls, pkid_or_path=None):\n        \"\"\"\n        Load a container object from a persistent location or file path.\n\n        Args:\n            pkid_or_path: Integer pkid corresponding to the container table or file path\n\n        Returns:\n            container: The saved container object\n        \"\"\"\n        path = pkid_or_path\n        if isinstance(path, (int, np.int32, np.int64)):\n            raise NotImplementedError('Lookup via CMS not implemented.')\n        elif not os.path.isfile(path):\n            raise FileNotFoundError('File {} not found.'.format(path))\n        kwargs = {}\n        fields = defaultdict(dict)\n        with pd.HDFStore(path) as store:\n            for key in store.keys():\n                if 'kwargs' in key:\n                    kwargs.update(store.get_storer(key).attrs.metadata)\n                elif \"FIELD\" in key:\n                    name, dname = \"_\".join(key.split(\"_\")[1:]).split(\"/\")\n                    dname = dname.replace('values', '')\n                    fields[name][dname] = store[key]\n                else:\n                    name = str(key[1:])\n                    kwargs[name] = store[key]\n        for name, field_data in fields.items():\n            fps = field_data.pop('data')\n            kwargs[name] = Field(fps, field_values=[field_data[str(arr)] for arr in\n                                                    sorted(map(int, field_data.keys()))])\n        return cls(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets descriptive kwargs of the container.", "response": "def _rel(self, copy=False):\n        \"\"\"\n        Get descriptive kwargs of the container (e.g. name, description, meta).\n        \"\"\"\n        rel = {}\n        for key, obj in vars(self).items():\n            if not isinstance(obj, (pd.Series, pd.DataFrame, pd.SparseSeries, pd.SparseDataFrame)) and not key.startswith('_'):\n                if copy and 'id' not in key:\n                    rel[key] = deepcopy(obj)\n                else:\n                    rel[key] = obj\n        return rel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget data kwargs of the container.", "response": "def _data(self, copy=False):\n        \"\"\"\n        Get data kwargs of the container (i.e. dataframe and series objects).\n        \"\"\"\n        data = {}\n        for key, obj in vars(self).items():\n            if isinstance(obj, (pd.Series, pd.DataFrame, pd.SparseSeries, pd.SparseDataFrame)):\n                if copy:\n                    data[key] = obj.copy(deep=True)\n                else:\n                    data[key] = obj\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a custom property that will be used to get the value of the named property.", "response": "def create_property(name, ptype):\n        \"\"\"\n        Creates a custom property with a getter that performs computing\n        functionality (if available) and raise a type error if setting\n        with the wrong type.\n\n        Note:\n            By default, the setter attempts to convert the object to the\n            correct type; a type error is raised if this fails.\n        \"\"\"\n        pname = '_' + name\n        def getter(self):\n            # This will be where the data is store (e.g. self._name)\n            # This is the default property \"getter\" for container data objects.\n            # If the property value is None, this function will check for a\n            # convenience method with the signature, self.compute_name() and call\n            # it prior to returning the property value.\n            if not hasattr(self, pname) and hasattr(self, '{}{}'.format(self._getter_prefix, pname)):\n                self['{}{}'.format(self._getter_prefix, pname)]()\n            if not hasattr(self, pname):\n                raise AttributeError('Please compute or set {} first.'.format(name))\n            return getattr(self, pname)\n\n        def setter(self, obj):\n            # This is the default property \"setter\" for container data objects.\n            # Prior to setting a property value, this function checks that the\n            # object's type is correct.\n            if not isinstance(obj, ptype):\n                try:\n                    obj = ptype(obj)\n                except Exception:\n                    raise TypeError('Must be able to convert object {0} to {1} (or must be of type {1})'.format(name, ptype))\n            setattr(self, pname, obj)\n\n        def deleter(self):\n            # Deletes the property's value.\n            del self[pname]\n\n        return property(getter, setter, deleter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _polar_to_cartesian(cx, cy, r, theta):\n        return cx - r * math.sin(theta), cy - r * math.cos(theta)", "response": "Convert from polar coordinates to cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef circle(self, cx, cy, r, stroke=None, fill=None, stroke_width=1):\n        self.put(' <circle cx=\"')\n        self.put(str(cx))\n        self.put('\" cy=\"')\n        self.put(str(cy))\n        self.put('\" r=\"')\n        self.put(str(r))\n        self.put('\" stroke-width=\"')\n        self.put(str(stroke_width))\n        self.put('\"')\n        if fill:\n            self.put(' fill=\"')\n            self.put(fill)\n            self.put('\"')\n        if stroke:\n            self.put(' stroke=\"')\n            self.put(stroke)\n            self.put('\"')\n        self.put('/>\\n')", "response": "Writes a circle in the ISO."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef polygon(self, points, stroke=None, fill=None, stroke_width=1, disable_anti_aliasing=False):\n        self.put(' <polygon points=\"')\n        self.put(' '.join(['%s,%s' % p for p in points]))\n        self.put('\" stroke-width=\"')\n        self.put(str(stroke_width))\n        self.put('\"')\n        if fill:\n            self.put(' fill=\"')\n            self.put(fill)\n            self.put('\"')\n        if stroke:\n            self.put(' stroke=\"')\n            self.put(stroke)\n            self.put('\"')\n        if disable_anti_aliasing:\n            self.put(' shape-rendering=\"crispEdges\"')\n        self.put('/>\\n')", "response": "Writes a polygon to the log."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef arc(self, cx, cy, r, start_radians, end_radians, fill=None):\n\n        # This is tricky - we have to use a path, and for that we need to know the start and end points of the arc\n        # in cartesian coordinates\n\n        start = self._polar_to_cartesian(cx, cy, r, start_radians)\n        end = self._polar_to_cartesian(cx, cy, r, end_radians)\n\n        total_radians = start_radians - end_radians\n        if total_radians < 0:\n            total_radians *= -1\n        large_arc_flag = 1 if total_radians > math.pi else 0\n\n        path = SvgPathGenerator()\n        path.move_to(end[0], end[1])\n        path.line_to(cx, cy)\n        path.line_to(start[0], start[1])\n        path.arc_to(r, r, 0, large_arc_flag, 0, end[0], end[1])\n\n        self.put(' <path d=\"')\n        self.put(path.get_d())\n        self.put('\"')\n        if fill:\n            self.put(' fill=\"')\n            self.put(fill)\n            self.put('\"')\n        self.put('/>\\n')", "response": "This function generates a path to the area of the arc that is located at the given center."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name_targets(func):\n    def wrap(*a, **kw):\n        ret = func(*a, **kw)\n        return dict(zip(ret[:-1], ret[-1]))\n    return wrap", "response": "Decorator to wrap a function such that returning a dict containing the name of the target."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, name, nestable, **kw):\n        self.checkpoints[name] = self.nest\n        self.nest = copy.copy(self.nest)\n        return self.nest.add(name, nestable, **kw)", "response": "Adds a level to the nesting and creates a checkpoint that can be used to aggregate the log entries."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pop(self, name=None):\n        if name is not None:\n            self.nest = self.checkpoints[name]\n            keys = list(self.checkpoints.keys())\n            name_idx = keys.index(name)\n            assert name_idx >= 0\n\n            # Pop every key from ``name`` on:\n            for k in reversed(keys[name_idx:]):\n                self.checkpoints.pop(k)\n        else:\n            self.nest = self.checkpoints.popitem()[1]", "response": "Removes the last entry from the nest level."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an SCons target to this nest. The function decorated will be immediately called with each of the output directories and current control dictionaries. Each result will be added to the respective control dictionary for later nests to access. :param name: Name for the target in the name (default: function name).", "response": "def add_target(self, name=None):\n        \"\"\"\n        Add an SCons target to this nest.\n\n        The function decorated will be immediately called with each of the\n        output directories and current control dictionaries. Each result will\n        be added to the respective control dictionary for later nests to\n        access.\n\n        :param name: Name for the target in the name (default: function name).\n        \"\"\"\n        def deco(func):\n            def nestfunc(control):\n                destdir = os.path.join(self.dest_dir, control['OUTDIR'])\n                return [func(destdir, control)]\n            key = name or func.__name__\n            self.nest.add(key, nestfunc, create_dir=False)\n            self._register_alias(key)\n            return func\n        return deco"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_target_with_env(self, environment, name=None):\n        def deco(func):\n            def nestfunc(control):\n                env = environment.Clone()\n                for k, v in control.items():\n                    if k in env:\n                        logger.warn(\"Overwriting previously bound value %s=%s\",\n                                    k, env[k])\n                    env[k] = v\n                destdir = os.path.join(self.dest_dir, control['OUTDIR'])\n                env['OUTDIR'] = destdir\n                return [func(env, destdir, control)]\n            key = name or func.__name__\n            self.nest.add(key, nestfunc, create_dir=False)\n            self._register_alias(key)\n            return func\n        return deco", "response": "Decorator to add an SCons target to this nest with an SCons Environment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_aggregate(self, name, data_fac):\n        @self.add_target(name)\n        def wrap(outdir, c):\n            return data_fac()", "response": "Add an aggregate target to this nest."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a target to build a control file at each of the current leaves.", "response": "def add_controls(self, env, target_name='control',\n                     file_name='control.json',\n                     encoder_cls=SConsEncoder):\n        \"\"\"\n        Adds a target to build a control file at each of the current leaves.\n\n        :param env: SCons Environment object\n        :param target_name: Name for target in nest\n        :param file_name: Name for output file.\n        \"\"\"\n        if not HAS_SCONS:\n            raise ImportError('SCons not available')\n\n        @self.add_target(name=target_name)\n        def control(outdir, c):\n            return env.Command(os.path.join(outdir, file_name),\n                               [],\n                               action=_create_control_file,\n                               control_dict=c,\n                               encoder_cls=encoder_cls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a number to a number with decimal point.", "response": "def clean(amount):\n        \"\"\"\n        Converts a number to a number with decimal point.\n\n        :param str amount: The input number.\n\n        :rtype: str\n        \"\"\"\n        # Return empty input immediately.\n        if not amount:\n            return amount\n\n        if re.search(r'[\\. ][0-9]{3},[0-9]{1,2}$', amount):\n            # Assume amount is in 1.123,12 or 1 123,12 format (Dutch).\n            return amount.replace('.', '').replace(' ', '').replace(',', '.')\n\n        if re.search(r'[, ][0-9]{3}\\.[0-9]{1,2}$', amount):\n            # Assume amount is in 1,123.12 format (Engels).\n            return amount.replace(',', '').replace(' ', '')\n\n        if re.search(r'[0-9](,[0-9]{1,2}$)', amount):\n            # Assume amount is in 123,12 or in 123,1 format (Dutch).\n            return amount.replace(',', '.')\n\n        # Format of amount is not recognized. Return amount.\n        return amount"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_id(self, natural_key, date, enhancement=None):\n        if not date:\n            return None\n\n        # If the natural key is known return the technical ID immediately.\n        if natural_key in self._map:\n            for row in self._map[natural_key]:\n                if row[0] <= date <= row[1]:\n                    return row[2]\n\n        # The natural key is not in the map of this dimension. Call a stored procedure for translating the natural key\n        # to a technical key.\n        self.pre_call_stored_procedure()\n        success = False\n        try:\n            row = self.call_stored_procedure(natural_key, date, enhancement)\n            # Convert dates to strings in ISO 8601 format.\n            if isinstance(row[self._key_date_start], datetime.date):\n                row[self._key_date_start] = row[self._key_date_start].isoformat()\n            if isinstance(row[self._key_date_end], datetime.date):\n                row[self._key_date_end] = row[self._key_date_end].isoformat()\n            success = True\n        finally:\n            self.post_call_stored_procedure(success)\n\n        # Make sure the natural key is in the map.\n        if natural_key not in self._map:\n            self._map[natural_key] = []\n\n        if row[self._key_key]:\n            self._map[natural_key].append((row[self._key_date_start],\n                                           row[self._key_date_end],\n                                           row[self._key_key]))\n        else:\n            self._map[natural_key].append((date, date, None))\n\n        return row[self._key_key]", "response": "Returns the technical ID for a natural key at a given date."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new a othrez - specific Field class", "response": "def factory(coords,\n                dependent_variables,\n                helper_functions):\n        \"\"\"Fields factory generating specialized container build around a\n          triflow Model and xarray.\n\n          Parameters\n          ----------\n          coords: iterable of str:\n              coordinates name. First coordinate have to be shared with all\n              variables\n          dependent_variables : iterable tuple (name, coords)\n              coordinates and name of the dependent variables\n          helper_functions : iterable tuple (name, coords)\n              coordinates and name of the helpers functions\n\n          Returns\n          -------\n          triflow.BaseFields\n              Specialized container which expose the data as a structured\n              numpy array\n          \"\"\"\n        Field = type('Field', BaseFields.__bases__,\n                     dict(BaseFields.__dict__))\n        Field._coords = coords\n        Field.dependent_variables_info = dependent_variables\n        Field.helper_functions_info = helper_functions\n        Field._var_info = [*list(Field.dependent_variables_info),\n                           *list(Field.helper_functions_info)]\n        Field.dependent_variables = [dep[0]\n                                     for dep\n                                     in Field.dependent_variables_info]\n        Field.helper_functions = [dep[0]\n                                  for dep\n                                  in Field.helper_functions_info]\n        Field._keys, Field._coords_info = zip(*Field._var_info)\n        return Field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef factory1D(dependent_variables,\n                  helper_functions):\n        \"\"\"Fields factory generating specialized container build around a\n          triflow Model and xarray.\n          Wrapper for 1D data.\n\n          Parameters\n          ----------\n          dependent_variables : iterable for str\n              name of the dependent variables\n          helper_functions : iterable of str\n              name of the helpers functions\n\n          Returns\n          -------\n          triflow.BaseFields\n              Specialized container which expose the data as a structured\n              numpy array\n          \"\"\"\n        return BaseFields.factory((\"x\", ),\n                                  [(name, (\"x\", ))\n                                   for name\n                                   in dependent_variables],\n                                  [(name, (\"x\", ))\n                                   for name\n                                   in helper_functions],)", "response": "Returns a base - fields. BaseFields instance for 1D data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a flatten copy of the main numpy array with only the AttributeNames dependant variables.", "response": "def uflat(self):\n        \"\"\"return a flatten **copy** of the main numpy array with only the\n        dependant variables.\n\n        Be carefull, modification of these data will not be reflected on\n        the main array!\n        \"\"\"  # noqa\n        aligned_arrays = [self[key].values[[(slice(None)\n                                             if c in coords\n                                             else None)\n                                            for c in self._coords]].T\n                          for key, coords in self.dependent_variables_info]\n        return np.vstack(aligned_arrays).flatten(\"F\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_follow_durable( path,\n\t\tmin_dump_interval=10,\n\t\txattr_name='user.collectd.logtail.pos', xattr_update=True,\n\t\t**follow_kwz ):\n\t'''Records log position into xattrs after reading line every\n\t\t\tmin_dump_interval seconds.\n\t\tChecksum of the last line at the position\n\t\t\tis also recorded (so line itself don't have to fit into xattr) to make sure\n\t\t\tfile wasn't truncated between last xattr dump and re-open.'''\n\n\tfrom xattr import xattr\n\tfrom io import open\n\tfrom hashlib import sha1\n\tfrom time import time\n\timport struct\n\n\t# Try to restore position\n\tsrc = open(path, mode='rb')\n\tsrc_xattr = xattr(src)\n\ttry:\n\t\tif not xattr_name: raise KeyError\n\t\tpos = src_xattr[xattr_name]\n\texcept KeyError: pos = None\n\tif pos:\n\t\tdata_len = struct.calcsize('=I')\n\t\t(pos,), chksum = struct.unpack('=I', pos[:data_len]), pos[data_len:]\n\t\t(data_len,), chksum = struct.unpack('=I', chksum[:data_len]), chksum[data_len:]\n\t\ttry:\n\t\t\tsrc.seek(pos - data_len)\n\t\t\tif sha1(src.read(data_len)).digest() != chksum:\n\t\t\t\traise IOError('Last log line doesnt match checksum')\n\t\texcept (OSError, IOError) as err:\n\t\t\tcollectd.info('Failed to restore log position: {}'.format(err))\n\t\t\tsrc.seek(0)\n\ttailer = file_follow(src, yield_file=True, **follow_kwz)\n\n\t# ...and keep it updated\n\tpos_dump_ts_get = lambda ts=None: (ts or time()) + min_dump_interval\n\tpos_dump_ts = pos_dump_ts_get()\n\twhile True:\n\t\tline, src_chk = next(tailer)\n\t\tif not line: pos_dump_ts = 0 # force-write xattr\n\t\tts = time()\n\t\tif ts > pos_dump_ts:\n\t\t\tif src is not src_chk:\n\t\t\t\tsrc, src_xattr = src_chk, xattr(src_chk)\n\t\t\tpos_new = src.tell()\n\t\t\tif pos != pos_new:\n\t\t\t\tpos = pos_new\n\t\t\t\tif xattr_update:\n\t\t\t\t\tsrc_xattr[xattr_name] =\\\n\t\t\t\t\t\tstruct.pack('=I', pos)\\\n\t\t\t\t\t\t+ struct.pack('=I', len(line))\\\n\t\t\t\t\t\t+ sha1(line).digest()\n\t\t\tpos_dump_ts = pos_dump_ts_get(ts)\n\t\tif (yield line.decode('utf-8', 'replace')):\n\t\t\ttailer.send(StopIteration)\n\t\t\tbreak", "response": "Follows a file at a given time."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge_accounts(self, request):\n        # create new net ID record in database\n        # and attach it to request.user account.\n        try:\n            netid = NetID.objects.get(identity=self.identity, provider=self.provider)\n        except NetID.DoesNotExist:\n            netid = NetID(user=request.user, identity=self.identity, provider=self.provider)\n            netid.save()\n            # show nice message to user.\n            messages.add_message(request, messages.SUCCESS, lang.ACCOUNTS_MERGED)", "response": "Add NetID record to regular django\n        account and then redirect user to the next account."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef login_user(self, request):\n        # only actavted users can login if activation required.\n        user = auth.authenticate(identity=self.identity, provider=self.provider)\n        if user and settings.ACTIVATION_REQUIRED and not user.is_active:\n            messages.add_message(request, messages.ERROR, lang.NOT_ACTIVATED)\n            return redirect(settings.ACTIVATION_REDIRECT_URL)\n        # login\n        if user:\n            auth.login(request, user)\n            return True\n\n        return False", "response": "Try to login user by net identity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fill_extra_fields(self, request, data):\n        form = str_to_class(settings.EXTRA_FORM)(data)\n        if form.is_valid():\n            form.save(request, self.identity, self.provider)\n            self.login_user(request)\n        else:\n            return data", "response": "Fill extra fields from the provider data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the field matches the glob expression of this simple condition. Returns False otherwise.", "response": "def match(self, row):\n        \"\"\"\n        Returns True if the field matches the glob expression of this simple condition. Returns False otherwise.\n\n        :param dict row: The row.\n\n        :rtype: bool\n        \"\"\"\n        return fnmatch.fnmatchcase(row[self._field], self._expression)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a date in miscellaneous format to ISO - 8601 format.", "response": "def clean(date, ignore_time=False):\n        \"\"\"\n        Converts a date in miscellaneous format to ISO-8601 (YYYY-MM-DD) format.\n\n        :param str date: The input date.\n        :param bool ignore_time: If true any trailing time prt is ignore.\n\n        :rtype: str\n        \"\"\"\n        # Return empty input immediately.\n        if not date:\n            return date\n\n        parts = re.split(r'[\\-/. ]', date)\n\n        if (len(parts) == 3) or \\\n                (len(parts) > 3 and ignore_time) or \\\n                (len(parts) == 4 and re.match(r'^[0:]*$', parts[3])) or \\\n                (len(parts) == 5 and re.match(r'^[0:]*$', parts[3]) and re.match(r'^0*$', parts[4])):\n            if len(parts[0]) == 4 and len(parts[1]) <= 2 and len(parts[2]) <= 2:\n                # Assume date is in  YYYY-MM-DD of YYYY-M-D format.\n                return parts[0] + '-' + ('00' + parts[1])[-2:] + '-' + ('00' + parts[2])[-2:]\n\n            if len(parts[0]) <= 2 and len(parts[1]) <= 2 and len(parts[2]) == 4:\n                # Assume date is in  DD-MM-YYYY or D-M-YYYY format.\n                return parts[2] + '-' + ('00' + parts[1])[-2:] + '-' + ('00' + parts[0])[-2:]\n\n            if len(parts[0]) <= 2 and len(parts[1]) <= 2 and len(parts[2]) == 2:\n                # Assume date is in  DD-MM-YY or D-M-YY format.\n                year = '19' + parts[2] if parts[2] >= '20' else '20' + parts[2]\n\n                return year + '-' + ('00' + parts[1])[-2:] + '-' + ('00' + parts[0])[-2:]\n\n        # Try DDmonYYYY or DDmonYYYY HH:mm:ss format\n        pattern = r'^(\\d{2})([a-z]{3})(\\d{4})' + ('.*$' if ignore_time else r'(\\D(\\d{1,2})\\D(\\d{1,2})\\D(\\d{1,2}))?$')\n        match = re.match(pattern, date.lower())\n        if match and match.group(2) in DateCleaner.month_map:\n            ret = match.group(3) + '-' + DateCleaner.month_map[match.group(2)] + '-' + match.group(1)\n            if len(match.groups()) == 7 and match.group(4):\n                ret += 'T' + match.group(5) + ':' + match.group(6) + ':' + match.group(7)\n            return ret\n\n        # Try YYYYMMDD format.\n        pattern = r'^\\d{8}' + ('.*$' if ignore_time else '$')\n        match = re.match(pattern, date)\n        if match:\n            # Assume date is YYYYMMDD format\n            return date[0:4] + '-' + date[4:6] + '-' + date[6:8]\n\n        # Format not recognized. Just return the original string.\n        return date"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef template_string(context, template):\n    'Return the rendered template content with the current context'\n    if not isinstance(context, Context):\n        context = Context(context)\n    return Template(template).render(context)", "response": "Return the rendered template content with the current context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a raster and return a polygon representing the outer edge.", "response": "def raster_to_shape(raster):\n    \"\"\"Take a raster and return a polygon representing the outer edge.\"\"\"\n    left = raster.bounds.left\n    right = raster.bounds.right\n    top = raster.bounds.top\n    bottom = raster.bounds.bottom\n\n    top_left = (left, top)\n    top_right = (right, top)\n    bottom_left = (left, bottom)\n    bottom_right = (right, bottom)\n\n    return Polygon((\n        top_left, top_right, bottom_right, bottom_left, top_left,\n    ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply_markup(value, arg=None):\n    if arg is not None:\n        return formatter(value, filter_name=arg)\n    return formatter(value)", "response": "Applies text - to - HTML conversion."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies SmartyPants to a piece of text applying typographic niceties.", "response": "def smartypants(value):\n    \"\"\"\n    Applies SmartyPants to a piece of text, applying typographic\n    niceties.\n    \n    Requires the Python SmartyPants library to be installed; see\n    http://web.chad.org/projects/smartypants.py/\n    \n    \"\"\"\n    try:\n        from smartypants import smartyPants\n    except ImportError:\n        if settings.DEBUG:\n            raise TemplateSyntaxError(\"Error in smartypants filter: the Python smartypants module is not installed or could not be imported\")\n        return value\n    else:\n        return smartyPants(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrefine the MiddlewareClasses in the original list.", "response": "def refine_MIDDLEWARE_CLASSES(original):\n    \"\"\"\n    Django docs say that the LocaleMiddleware should come after the SessionMiddleware.\n    Here, we make sure that the SessionMiddleware is enabled and then place the\n    LocaleMiddleware at the correct position.\n    Be careful with the order when refining the MiddlewareClasses with following features.\n    :param original:\n    :return:\n    \"\"\"\n    try:\n        session_middleware_index = original.index('django.contrib.sessions.middleware.SessionMiddleware')\n        original.insert(session_middleware_index + 1, 'django.middleware.locale.LocaleMiddleware')\n        return original\n    except ValueError:\n        raise LookupError('SessionMiddleware not found! Please make sure you have enabled the \\\n         SessionMiddleware in your settings (django.contrib.sessions.middleware.SessionMiddleware).')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(cls, params=None):\n        return fields.ListField(name=cls.ENDPOINT, init_class=cls).decode(\n            cls.element_from_string(cls._get_request(params=params).text)\n        )", "response": "Returns a list of the parsed xml objects for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_config(command, filename, section, vars):\r\n    confuri = \"config:\" + filename\r\n    if \":\" in section:\r\n        confuri += \"#\" + section.rsplit(\":\", 1)[-1]\r\n    conf = appconfig(confuri)\r\n\r\n    load_environment(conf.global_conf, conf.local_conf)", "response": "Place any commands to setup chatapp here"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef push(self):\r\n        print `request.body`\r\n        yield request.environ['cogen.call'](pubsub.publish)(\r\n            \"%s: %s\" % (session['client'].name, request.body)\r\n        )\r\n        # the request.environ['cogen.*'] objects are the the asynchronous\r\n        # make the code here work as a coroutine and still work with any\r\n        # wsgi extensions offered by cogen - basicaly they do some magic to\r\n        # middleware\r\n        yield str(request.environ['cogen.wsgi'].result)", "response": "This action puts a message in the global queue that all the clients\r\n            will get via the pull action."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n    args = MainArguments()\n\n    if args.tool.lower() == \"tool1\":\n        args = Tool1Arguments()\n    elif args.tool.lower() == \"tool2\":\n        args = Tool2Arguments()\n    else:\n        print(\"Unknown tool\", args.tool)\n\n    print(args)", "response": "main function for the sequence of tools"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget or create the local library.", "response": "def get_or_create_home_repo(reset=False):\n\t\"\"\"\n\tCheck to make sure we never operate with a non-existing local repo\n\t\"\"\"\n\tdosetup = True\n\tif os.path.exists(ONTOSPY_LOCAL):\n\t\tdosetup = False\n\n\t\tif reset:\n\t\t\timport shutil\n\t\t\tvar = input(\"Delete the local library and all of its contents? (y/n) \")\n\t\t\tif var == \"y\":\n\t\t\t\tshutil.rmtree(ONTOSPY_LOCAL)\n\t\t\t\tdosetup = True\n\t\t\telse:\n\t\t\t\tpass\n\n\tif dosetup or not(os.path.exists(ONTOSPY_LOCAL)):\n\t\tos.mkdir(ONTOSPY_LOCAL)\n\tif dosetup or not(os.path.exists(ONTOSPY_LOCAL_CACHE)):\n\t\t# print \"HERE\"\n\t\tos.makedirs(ONTOSPY_LOCAL_CACHE)\n\tif dosetup or not(os.path.exists(ONTOSPY_LOCAL_VIZ)):\n\t\tos.mkdir(ONTOSPY_LOCAL_VIZ)\n\tif dosetup or not(os.path.exists(ONTOSPY_LIBRARY_DEFAULT)):\n\t\tos.mkdir(ONTOSPY_LIBRARY_DEFAULT)\n\n\tLIBRARY_HOME = get_home_location()  # from init file, or default\n\n\t# check that the local library folder exists, otherwise prompt user to create it\n\tif not(os.path.exists(LIBRARY_HOME)):\n\t\tprintDebug(\"Warning: the local library at '%s' has been deleted or is not accessible anymore.\" % LIBRARY_HOME, \"important\")\n\t\tprintDebug(\"Please reset the local library by running 'ontospy-manager -u <a-valid-path>'\", \"comment\")\n\t\traise SystemExit(1)\n\n\tif dosetup:\n\t\tprint(Fore.GREEN + \"Setup successfull: local library created at <%s>\" % LIBRARY_HOME + Style.RESET_ALL)\n\t# else:\n\t\t# print(Style.DIM + \"Local library: <%s>\" % LIBRARY_HOME + Style.RESET_ALL)\n\n\treturn True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to retrieve a cached ontology", "response": "def get_pickled_ontology(filename):\n\t\"\"\" try to retrieve a cached ontology \"\"\"\n\tpickledfile = ONTOSPY_LOCAL_CACHE + \"/\" + filename + \".pickle\"\n\tif GLOBAL_DISABLE_CACHE:\n\t\tprintDebug(\"WARNING: DEMO MODE cache has been disabled in __init__.py ==============\", \"red\")\n\tif os.path.isfile(pickledfile) and not GLOBAL_DISABLE_CACHE:\n\t\ttry:\n\t\t\treturn cPickle.load(open(pickledfile, \"rb\"))\n\t\texcept:\n\t\t\tprint(\"** WARNING: Cache is out of date ** ...recreating it... \")\n\t\t\treturn None\n\telse:\n\t\treturn None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry to remove a cached ontology", "response": "def del_pickled_ontology(filename):\n\t\"\"\" try to remove a cached ontology \"\"\"\n\tpickledfile = ONTOSPY_LOCAL_CACHE + \"/\" + filename + \".pickle\"\n\tif os.path.isfile(pickledfile) and not GLOBAL_DISABLE_CACHE:\n\t\tos.remove(pickledfile)\n\t\treturn True\n\telse:\n\t\treturn None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to rename a cached ontology", "response": "def rename_pickled_ontology(filename, newname):\n\t\"\"\" try to rename a cached ontology \"\"\"\n\tpickledfile = ONTOSPY_LOCAL_CACHE + \"/\" + filename + \".pickle\"\n\tnewpickledfile = ONTOSPY_LOCAL_CACHE + \"/\" + newname + \".pickle\"\n\tif os.path.isfile(pickledfile) and not GLOBAL_DISABLE_CACHE:\n\t\tos.rename(pickledfile, newpickledfile)\n\t\treturn True\n\telse:\n\t\treturn None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_pickle_ontology(filename, g=None):\n\tONTOSPY_LOCAL_MODELS = get_home_location()\n\tpickledpath = ONTOSPY_LOCAL_CACHE + \"/\" + filename + \".pickle\"\n\tif not g:\n\t\tg = Ontospy(ONTOSPY_LOCAL_MODELS + \"/\" + filename)\n\n\tif not GLOBAL_DISABLE_CACHE:\n\t\ttry:\n\t\t\tcPickle.dump(g, open(pickledpath, \"wb\"))\n\t\t\t# print Style.DIM + \".. cached <%s>\" % pickledpath + Style.RESET_ALL\n\t\texcept Exception as e:\n\t\t\tprint(\"\\n.. Failed caching <%s>\" % filename )\n\t\t\tprint(str(e))\n\t\t\tprint(\"\\n... attempting to increase the recursion limit from %d to %d\" % (sys.getrecursionlimit(), sys.getrecursionlimit()*10))\n\n\t\ttry:\n\t\t\tsys.setrecursionlimit(sys.getrecursionlimit()*10)\n\t\t\tcPickle.dump(g, open(pickledpath, \"wb\"))\n\t\t\t# print(Fore.GREEN + \"Cached <%s>\" % pickledpath + \"...\" + Style.RESET_ALL)\n\t\texcept Exception as e:\n\t\t\tprint(\"\\n... Failed caching <%s>... aborting...\" % filename )\n\t\t\tprint(str(e))\n\t\tsys.setrecursionlimit(int(sys.getrecursionlimit()/10))\n\treturn g", "response": "generate the graph instance and pick it too\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the object with the current object properties.", "response": "def update(self):\n        \"\"\"\n        Updates the object\n\n        :return:\n        :rtype: response\n        \"\"\"\n        return self._put_request(\n            data=self.element_to_string(\n                self.encode()\n            ),\n            endpoint=self.ENDPOINT + '/' + str(self.id)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mixing_phases(U):\n    f = {}\n    # angles\n    f['t13'] = asin(abs(U[0,2]))\n    if U[0,0] == 0:\n        f['t12'] = pi/2\n    else:\n        f['t12'] = atan(abs(U[0,1])/abs(U[0,0]))\n    if U[2,2] == 0:\n        f['t23'] = pi/2\n    else:\n        f['t23'] = atan(abs(U[1,2])/abs(U[2,2]))\n    s12 = sin(f['t12'])\n    c12 = cos(f['t12'])\n    s13 = sin(f['t13'])\n    c13 = cos(f['t13'])\n    s23 = sin(f['t23'])\n    c23 = cos(f['t23'])\n    # standard phase\n    if (s12*s23) == 0 or (c12*c13**2*c23*s13) == 0:\n        f['delta'] = 0\n    else:\n        f['delta'] = -phase((U[0,0].conj()*U[0,2]*U[2,0]*U[2,2].conj()/(c12*c13**2*c23*s13) + c12*c23*s13)/(s12*s23))\n    # Majorana phases\n    f['delta1']  = phase(exp(1j*f['delta']) * U[0, 2])\n    f['delta2']  = phase(U[1, 2])\n    f['delta3']  = phase(U[2, 2])\n    f['phi1'] = 2*phase(exp(1j*f['delta1']) * U[0, 0].conj())\n    f['phi2'] = 2*phase(exp(1j*f['delta1']) * U[0, 1].conj())\n    return f", "response": "Return the angles and CP phases of the CKM or PMNS matrix\n    in standard parametrization starting from a matrix with arbitrary phase\n    convention."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to rephase the quark rotation matrices in order to obtain the CKM matrix in standard parametrization.", "response": "def rephase_standard(UuL, UdL, UuR, UdR):\n    \"\"\"Function to rephase the quark rotation matrices in order to\n    obtain the CKM matrix in standard parametrization.\n\n    The input matrices are assumed to diagonalize the up-type and down-type\n    quark matrices like\n\n    ```\n    UuL.conj().T @ Mu @ UuR = Mu_diag\n    UdL.conj().T @ Md @ UdR = Md_diag\n    ```\n\n    The CKM matrix is given as `VCKM = UuL.conj().T @ UdL`.\n\n    Returns a tuple with the rephased versions of the input matrices.\n    \"\"\"\n    K = UuL.conj().T @ UdL\n    f = mixing_phases(K)\n    Fdelta = np.diag(np.exp([1j*f['delta1'], 1j*f['delta2'], 1j*f['delta3']]))\n    Fphi = np.diag(np.exp([-1j*f['phi1']/2., -1j*f['phi2']/2., 0]))\n    return UuL @ Fdelta, UdL @ Fphi.conj(), UuR @ Fdelta, UdR @ Fphi.conj()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning to rephase the lepton rotation matrices in order to obtain the PMNS matrix in standard parametrization.", "response": "def rephase_pmns_standard(Unu, UeL, UeR):\n    \"\"\"Function to rephase the lepton rotation matrices in order to\n    obtain the PMNS matrix in standard parametrization.\n\n    The input matrices are assumed to diagonalize the charged lepton and\n    neutrino mass matrices like\n\n    ```\n    UeL.conj().T @ Me @ UeR = Me_diag\n    Unu.T @ Mnu @ Unu = Mnu_diag\n    ```\n\n    The PMNS matrix is given as `UPMNS = UeL.conj().T @ Unu`.\n\n    Returns a tuple with the rephased versions of the input matrices.\n    \"\"\"\n    U = UeL.conj().T @ Unu\n    f = mixing_phases(U)\n    Fdelta = np.diag(np.exp([1j*f['delta1'], 1j*f['delta2'], 1j*f['delta3']]))\n    return Unu, UeL @ Fdelta, UeR @ Fdelta"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the given version is older than the latest version of the package on PyPI.", "response": "def check_outdated(package, version):\n    \"\"\"\n    Given the name of a package on PyPI and a version (both strings), checks\n    if the given version is the latest version of the package available.\n\n    Returns a 2-tuple (is_outdated, latest_version) where\n    is_outdated is a boolean which is True if the given version is earlier\n    than the latest version, which is the string latest_version.\n\n    Attempts to cache on disk the HTTP call it makes for 24 hours. If this\n    somehow fails the exception is converted to a warning (OutdatedCacheFailedWarning)\n    and the function continues normally.\n    \"\"\"\n\n    from pkg_resources import parse_version\n\n    parsed_version = parse_version(version)\n    latest = None\n\n    with utils.cache_file(package, 'r') as f:\n        content = f.read()\n        if content:  # in case cache_file fails and so f is a dummy file\n            latest, cache_dt = json.loads(content)\n            if not utils.cache_is_valid(cache_dt):\n                latest = None\n\n    def get_latest():\n        url = 'https://pypi.python.org/pypi/%s/json' % package\n        response = utils.get_url(url)\n        return json.loads(response)['info']['version']\n\n    if latest is None:\n        latest = get_latest()\n\n    parsed_latest = parse_version(latest)\n\n    if parsed_version > parsed_latest:\n\n        # Probably a stale cached value\n        latest = get_latest()\n        parsed_latest = parse_version(latest)\n\n        if parsed_version > parsed_latest:\n            raise ValueError('Version %s is greater than the latest version on PyPI: %s' %\n                             (version, latest))\n\n    is_latest = parsed_version == parsed_latest\n    assert is_latest or parsed_version < parsed_latest\n\n    with utils.cache_file(package, 'w') as f:\n        data = [latest, utils.format_date(datetime.now())]\n        json.dump(data, f)\n\n    return not is_latest, latest"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the sympy Derivative operation in the system.", "response": "def _generate_sympify_namespace(\n    independent_variables, dependent_variables, helper_functions\n):\n    \"\"\"Generate the link between the symbols of the derivatives and the\n      sympy Derivative operation.\n\n      Parameters\n      ----------\n      independent_variable : str\n          name of the independant variable (\"x\")\n      dependent_variables : iterable of str\n          names of the dependent variables\n      helper_functions : iterable of str\n          names of the helper functions\n\n      Returns\n      -------\n      dict\n          dictionnary containing the symbol to parse as keys and the sympy expression to evaluate instead as values.\n      \"\"\"  # noqa\n\n    independent_variable = independent_variables[0]  # TEMP FIX BEFORE REAL ND\n    symbolic_independent_variable = Symbol(independent_variable)\n\n    def partial_derivative(symbolic_independent_variable, i, expr):\n        return Derivative(expr, symbolic_independent_variable, i)\n\n    namespace = {independent_variable: symbolic_independent_variable}\n    namespace.update(\n        {\n            \"d%s\"\n            % (independent_variable * i): partial(\n                partial_derivative, symbolic_independent_variable, i\n            )\n            for i in range(1, 10)\n        }\n    )\n    namespace.update(\n        {\n            \"d%s%s\"\n            % (independent_variable * order, var): Derivative(\n                Function(var)(independent_variable), independent_variable, order\n            )\n            for order, var in product(\n                range(1, 10), dependent_variables + helper_functions\n            )\n        }\n    )\n    logging.debug(\"sympy namespace: %s\" % namespace)\n    return namespace"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare output for multi - model output", "response": "def _prepare_output_multi(self, model):\n        \"\"\"If printing to a different file per model, change the file for the current model\"\"\"\n        model_name = model.__name__\n        current_path = os.path.join(self._output_path, '{model}.{extension}'.format(\n            model=model_name,\n            extension=self.EXTENSION,\n        ))\n        self._outfile = codecs.open(current_path, 'w', encoding='utf-8')\n        print('Dumping {model} to {file}'.format(model=model_name, file=current_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads buckets to bucket cache.", "response": "def prepare_buckets(self):\n        \"\"\"\n        loads buckets to bucket cache.\n        \"\"\"\n        for mdl in self.registry.get_base_models():\n            bucket = mdl(super_context).objects.adapter.bucket\n            self.buckets[bucket.name] = bucket"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting each model in apps_models into its own file.", "response": "def _print_split_model(self, path, apps_models):\n        \"\"\"\n        Print each model in apps_models into its own file.\n        \"\"\"\n        for app, models in apps_models:\n            for model in models:\n                model_name = model().title\n                if self._has_extension(path):\n                    model_path = re.sub(r'^(.*)[.](\\w+)$', r'\\1.%s.%s.\\2' % (app, model_name), path)\n                else:\n                    model_path = '%s.%s.%s.puml' % (path, app, model_name)\n                self._print_single_file(model_path, [(app, [model])])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _print_split_app(self, path, apps_models):\n        for app, models in apps_models:\n            # Convert dir/file.puml to dir/file.app.puml to print to an app specific file\n            if self._has_extension(path):\n                app_path = re.sub(r'^(.*)[.](\\w+)$', r'\\1.%s.\\2' % app, path)\n            else:\n                app_path = '%s.%s.puml' % (path, app)\n\n            self._print_single_file(app_path, [(app, models)])", "response": "Print each app in apps_models associative list into its own file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints apps_models which contains a list of 2 - tuples containing apps and their models into a single file.", "response": "def _print_single_file(self, path, apps_models):\n        \"\"\"\n        Print apps_models which contains a list of 2-tuples containing apps and their models\n        into a single file.\n        \"\"\"\n        if path:\n            outfile = codecs.open(path, 'w', encoding='utf-8')\n            self._print = lambda s: outfile.write(s + '\\n')\n        self._print(self._diagram_start)\n        for app, app_models in apps_models:\n            self._print_app(app, app_models)\n        self._print(self._diagram_end)\n        if path:\n            outfile.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting the models of the app.", "response": "def _print_app(self, app, models):\n        \"\"\"\n        Print the models of app, showing them in a package.\n        \"\"\"\n        self._print(self._app_start % app)\n        self._print_models(models)\n        self._print(self._app_end)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _print_fields(self, fields):\n        # Prepare a formatting string that aligns the names and types based on the longest ones\n        longest_name = max(fields, key=lambda f: len(f[1]))[1]\n        longest_type = max(fields, key=lambda f: len(f[2]))[2]\n        field_format = '%s%-{}s %-{}s %s'.format(\n            len(longest_name) + self._padding_after_name,\n            len(longest_type) + self._padding_after_type)\n        for field in fields:\n            self._print(field_format % field)", "response": "Print the fields padding the names as necessary to align them."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_listnodes(self, listnodes):\n        fields = list()\n        for name, node in listnodes:\n            fields.append(('--', '', '', '--'))\n            fields.append(('', '**%s(ListNode)**' % name, '', ''))\n            for link in node.get_links():\n                linked_model = link['mdl'](super_context)\n                null = self._marker_true if link['null'] is True else self._marker_false\n                fields.append((self._nodelist_field_prefix, link['field'],\n                               '%s()' % linked_model.title, null))\n            fields.extend(self._get_model_fields(node, self._nodelist_field_prefix))\n        return fields", "response": "Formats a listnodes and their fields into a list of tuples that can be printed with _print_fields."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_model_fields(self, model, prefix=_field_prefix):\n        fields = list()\n        for field_name, field in model()._ordered_fields:\n            # Filter the default fields\n            if field_name not in getattr(model, '_DEFAULT_BASE_FIELDS', []):\n                type_name = utils.to_camel(field.solr_type)\n                required = self._marker_true if field.required is True else self._marker_false\n                fields.append((prefix, field_name, type_name, required))\n\n        return fields", "response": "Returns a list of fields that are not default models."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all the non - auto created nodes of the model.", "response": "def _get_model_nodes(self, model):\n        \"\"\"\n        Find all the non-auto created nodes of the model.\n        \"\"\"\n        nodes = [(name, node) for name, node in model._nodes.items()\n                if node._is_auto_created is False]\n        nodes.sort(key=lambda n: n[0])\n        return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _format_links_fields(self, links):\n        fields = list()\n        for link in links:\n            linked_model = link['mdl'](super_context)\n            null = self._marker_true if link['null'] is True else self._marker_false\n            # In LinkProxy, if reverse_name is empty then only reverse has the name\n            # of the field on the link_source side\n            field_name = link['field'] or link['reverse']\n            fields.append((self._field_prefix, field_name, '%s()' % linked_model.title, null))\n        fields.sort(key=lambda f: f[1])\n        return fields", "response": "Format the fields containing links into 4 - tuples printable by _print_fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint links that start from model.", "response": "def _print_links(self, model, links):\n        \"\"\"\n        Print links that start from model.\n        \"\"\"\n        for link in links:\n            if link['o2o'] is True:\n                link_type = self._one_to_one\n            elif link['m2m'] is True:\n                link_type = self._many_to_many\n            else:\n                link_type = self._one_to_many\n            linked_model = link['mdl'](super_context)\n            self._print('%s %s %s' % (model.title, link_type, linked_model.title))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef printBasicInfo(onto):\n    rdfGraph = onto.rdfGraph\n\n    print(\"_\" * 50, \"\\n\")\n    print(\"TRIPLES = %s\" % len(rdfGraph))\n    print(\"_\" * 50)\n    print(\"\\nNAMESPACES:\\n\")\n    for x in onto.ontologyNamespaces:\n        print(\"%s : %s\" % (x[0], x[1]))\n\n    print(\"_\" * 50, \"\\n\")\n    print(\"ONTOLOGY METADATA:\\n\")\n    for x, y in onto.ontologyAnnotations():\n        print(\n            \"%s: \\n\t %s\" % (uri2niceString(x, onto.ontologyNamespaces), uri2niceString(y, onto.ontologyNamespaces)))\n    print(\"_\" * 50, \"\\n\")\n\n    print(\"CLASS TAXONOMY:\\n\")\n    onto.printClassTree()\n    print(\"_\" * 50, \"\\n\")", "response": "Terminal printing of basic ontology information"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef entityTriples(rdfGraph, anEntity, excludeProps=False, excludeBNodes=False,\n                  orderProps=[RDF, RDFS, OWL.OWLNS, DC.DCNS]):\n    \"\"\"\n    Returns the pred-obj for any given resource, excluding selected ones..\n\n    Sorting: by default results are sorted alphabetically and according to namespaces: [RDF, RDFS, OWL.OWLNS, DC.DCNS]\n    \"\"\"\n    temp = []\n    if not excludeProps:\n        excludeProps = []\n\n    # extract predicate/object\n    for x, y, z in rdfGraph.triples((anEntity, None, None)):\n        if excludeBNodes and isBlankNode(z):\n            continue\n        if y not in excludeProps:\n            temp += [(y, z)]\n\n    # sorting\n    if type(orderProps) == type([]):\n        orderedUris = sortByNamespacePrefix([y for y, z in temp], orderProps)  # order props only\n        orderedUris = [(n + 1, x) for n, x in\n                       enumerate(orderedUris)]  # create form: [(1, 'something'),(2,'bobby'),(3,'suzy'),(4,'crab')]\n        rank = dict((key, rank) for (rank, key) in orderedUris)  # create dict to pass to sorted procedure\n        temp = sorted(temp, key=lambda tup: rank.get(tup[0]))\n    elif orderProps:  # default to alpha sorting unless False\n        temp = sorted(temp, key=lambda tup: tup[0])\n\n    # if niceURI:\n    #\ttemp = [(uri2niceString(ontology, y), z) for y,z in temp]\n\n    return temp", "response": "Returns the triples for any given resource excluding selected ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _distinct(row1, row2):\n        relation = Allen.relation(row1[0], row1[1], row2[0], row2[1])\n\n        if relation is None:\n            # One of the 2 intervals is invalid.\n            return []\n\n        if relation == Allen.X_BEFORE_Y:\n            # row1: |----|\n            # row2:            |-----|\n            return None  # [(row1[0], row1[1]), (row2[0], row2[1])]\n\n        if relation == Allen.X_BEFORE_Y_INVERSE:\n            # row1:            |-----|\n            # row2: |----|\n            return None  # [(row2[0], row2[1]), (row1[0], row1[1])]\n\n        if relation == Allen.X_MEETS_Y:\n            # row1: |-------|\n            # row2:          |-------|\n            return None  # [(row1[0], row1[1]), (row2[0], row2[1])]\n\n        if relation == Allen.X_MEETS_Y_INVERSE:\n            # row1:          |-------|\n            # row2: |-------|\n            return None  # [(row2[0], row2[1]), (row1[0], row1[1])]\n\n        if relation == Allen.X_OVERLAPS_WITH_Y:\n            # row1: |-----------|\n            # row2:       |----------|\n            return [(row1[0], row2[0] - 1), (row2[0], row1[1]), (row1[1] + 1, row2[1])]\n\n        if relation == Allen.X_OVERLAPS_WITH_Y_INVERSE:\n            # row1:       |----------|\n            # row2: |-----------|\n            return [(row2[0], row1[0] - 1), (row1[0], row2[1]), (row2[1] + 1, row1[1])]\n\n        if relation == Allen.X_STARTS_Y:\n            # row1: |------|\n            # row2: |----------------|\n            return [(row1[0], row1[1]), (row1[1] + 1, row2[1])]\n\n        if relation == Allen.X_STARTS_Y_INVERSE:\n            # row1: |----------------|\n            # row2: |------|\n            return [(row2[0], row2[1]), (row2[1] + 1, row1[1])]\n\n        if relation == Allen.X_DURING_Y:\n            # row1:      |------|\n            # row2: |----------------|\n            return [(row2[0], row1[0] - 1), (row1[0], row1[1]), (row1[1] + 1, row2[1])]\n\n        if relation == Allen.X_DURING_Y_INVERSE:\n            # row1: |----------------|\n            # row2:      |------|\n            return [(row1[0], row2[0] - 1), (row2[0], row2[1]), (row2[1] + 1, row1[1])]\n\n        if relation == Allen.X_FINISHES_Y:\n            # row1:           |------|\n            # row2: |----------------|\n            return [(row2[0], row1[0] - 1), (row1[0], row1[1])]\n\n        if relation == Allen.X_FINISHES_Y_INVERSE:\n            # row1: |----------------|\n            # row2:           |------|\n            return [(row1[0], row2[0] - 1), (row2[0], row2[1])]\n\n        if relation == Allen.X_EQUAL_Y:\n            # row1: |----------------|\n            # row2: |----------------|\n            return None  # [(row1[0], row1[1])]\n\n        # We got all 13 relation in Allen's interval algebra covered.\n        raise ValueError('Unexpected relation {0}'.format(relation))", "response": "Return a list of distinct entries in the table."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_interval(all_intervals, new_interval):\n        intervals = None\n        old_interval = None\n        for old_interval in all_intervals:\n            intervals = Type2CondenseHelper._distinct(new_interval, old_interval)\n            if intervals:\n                break\n\n        if intervals is None:\n            all_intervals.add(new_interval)\n        else:\n            if old_interval:\n                all_intervals.remove(old_interval)\n            for distinct_interval in intervals:\n                Type2CondenseHelper._add_interval(all_intervals, distinct_interval)", "response": "Adds a new interval to a set of none overlapping intervals."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _derive_distinct_intervals(self, rows):\n        ret = set()\n        for row in rows:\n            self._add_interval(ret, (row[self._key_start_date], row[self._key_end_date]))\n\n        return ret", "response": "Returns the set of distinct intervals in a row set."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncondenses the data set to the distinct intervals based on the pseudo key.", "response": "def condense(self):\n        \"\"\"\n        Condense the data set to the distinct intervals based on the pseudo key.\n        \"\"\"\n        for pseudo_key, rows in self._rows.items():\n            tmp1 = []\n            intervals = sorted(self._derive_distinct_intervals(rows))\n            for interval in intervals:\n                tmp2 = dict(zip(self._pseudo_key, pseudo_key))\n                tmp2[self._key_start_date] = interval[0]\n                tmp2[self._key_end_date] = interval[1]\n                tmp1.append(tmp2)\n\n            self._rows[pseudo_key] = tmp1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _terminate_procs(procs):\n    logging.warn(\"Stopping all remaining processes\")\n    for proc, g in procs.values():\n        logging.debug(\"[%s] SIGTERM\", proc.pid)\n        try:\n            proc.terminate()\n        except OSError as e:\n            # we don't care if the process we tried to kill didn't exist.\n            if e.errno != errno.ESRCH:\n                raise\n    sys.exit(1)", "response": "Terminate all processes in the process dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_summary(all_procs, summary_file):\n    if not summary_file:\n        return\n\n    with summary_file:\n        writer = csv.writer(summary_file, delimiter='\\t', lineterminator='\\n')\n        writer.writerow(('directory', 'command', 'start_time', 'end_time',\n            'run_time', 'exit_status', 'result'))\n        rows = ((p.working_dir, ' '.join(p.command), p.start_time, p.end_time,\n                p.running_time, p.return_code, p.status) for p in all_procs)\n        writer.writerows(rows)", "response": "Write a summary of all run processes to summary_file in tab - delimited alphabetical format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef template_subs_file(in_file, out_fobj, d):\n    with open(in_file, 'r') as in_fobj:\n        for line in in_fobj:\n            out_fobj.write(line.format(**d))", "response": "Substitute template arguments in in_file from variables in d write the result to out_fobj."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef worker(data, json_file):\n    # PERHAPS TODO: Support either full or relative paths.\n    with open(json_file) as fp:\n        d = json.load(fp)\n    json_directory = os.path.dirname(json_file)\n    def p(*parts):\n        return os.path.join(json_directory, *parts)\n\n    # STDOUT and STDERR will be written to a log file in each job directory.\n    log_file = data['log_file']\n\n    # A template file will be written in each job directory, including the\n    # substitution that was performed..\n    savecmd_file = data['savecmd_file']\n\n    # if a template file is being used, then we write out to it\n    template_file = data['template_file']\n    if template_file:\n        output_template = p(os.path.basename(template_file))\n        with open(output_template, 'w') as out_fobj:\n            template_subs_file(template_file, out_fobj, d)\n\n        # Copy permissions to destination\n        try:\n            shutil.copymode(template_file, output_template)\n        except OSError as e:\n            if e.errno == errno.EPERM:\n                logging.warn(\"Couldn't set permissions on %s. \"\n                        \"Continuing with existing permissions\",\n                        output_template)\n            else:\n                raise\n\n    work = data['template'].format(**d)\n\n    if savecmd_file:\n        with open(p(savecmd_file), 'w') as command_file:\n            command_file.write(work + \"\\n\")\n\n    # View what actions will take place in dry_run mode.\n    if data['dry_run']:\n        logging.info(\"%s - Dry run of %s\\n\", p(), work)\n    else:\n        try:\n            with open(p(log_file), 'w') as log:\n                cmd = shlex.split(work)\n                while True:\n                    try:\n                        pr = subprocess.Popen(\n                            cmd, stdout=log, stderr=log, cwd=p())\n                    except OSError as e:\n                        if e.errno != errno.EINTR:\n                            raise\n                        continue\n                    else:\n                        break\n                logging.info('[%d] Started %s in %s', pr.pid, work, p())\n                nestproc = NestlyProcess(cmd, p(), pr)\n                yield nestproc\n        except Exception as e:\n            # Seems useful to print the command that failed to make the\n            # traceback more meaningful.  Note that error output could get\n            # mixed up if two processes encounter errors at the same instant\n            logging.error(\"%s - Error executing %s - %s\", p(), work, e)\n            raise e", "response": "This function is a worker function that handles the processing of a single resource in a directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntypes for argparse - checks that file exists but does not open.", "response": "def extant_file(x):\n    \"\"\"\n    'Type' for argparse - checks that file exists but does not open.\n    \"\"\"\n    if not os.path.exists(x):\n        raise argparse.ArgumentError(\"{0} does not exist\".format(x))\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses command line arguments and return a list of strings.", "response": "def parse_arguments():\n    \"\"\"\n    Grab options and json files.\n    \"\"\"\n    max_procs = MAX_PROCS\n    dry_run = DRY_RUN\n    logging.basicConfig(level=logging.INFO, stream=sys.stdout,\n                        format='%(asctime)s * %(levelname)s * %(message)s')\n\n    parser = argparse.ArgumentParser(description=\"\"\"nestrun - substitute values\n            into a template and run commands in parallel.\"\"\")\n    parser.add_argument('-j', '--processes', '--local', dest='local_procs',\n            type=int, help=\"\"\"Run a maximum of N processes in parallel locally\n            (default: %(default)s)\"\"\", metavar='N', default=MAX_PROCS)\n    parser.add_argument('--template', dest='template',\n            metavar=\"'template text'\", help=\"\"\"Command-execution template, e.g.\n            bash {infile}. By default, nestrun executes the templatefile.\"\"\")\n    parser.add_argument('--stop-on-error', action='store_true',\n            default=False, help=\"\"\"Terminate remaining processes if any process\n            returns non-zero exit status (default: %(default)s)\"\"\")\n    parser.add_argument('--template-file', dest='template_file', metavar=\"FILE\",\n            help='Command-execution template file path.')\n    parser.add_argument('--save-cmd-file', dest='savecmd_file',\n            help=\"\"\"Name of the file that will contain the command that was\n            executed.\"\"\")\n    log_group = parser.add_mutually_exclusive_group()\n    log_group.add_argument('--log-file', dest='log_file', default='log.txt',\n            help=\"\"\"Name of the file that will contain output of the executed\n            command.\"\"\")\n    log_group.add_argument('--no-log', dest=\"log_file\", action=\"store_const\",\n            default='log.txt', const=os.devnull, help=\"\"\"Don't create a log\n            file\"\"\")\n    parser.add_argument('--dry-run', action='store_true', help=\"\"\"Dry run mode,\n            does not execute commands.\"\"\", default=False)\n    parser.add_argument('--summary-file', type=argparse.FileType('w'),\n            help=\"\"\"Write a summary of the run to the specified file\"\"\")\n\n    ctrl_group = parser.add_argument_group('Control files')\n    ctrl_group.add_argument('json_files', metavar='control_files', type=extant_file,\n            nargs='*', help=\"\"\"Nestly control dictionaries\"\"\")\n    ctrl_group.add_argument('-d', '--directory', help=\"\"\"Run on all control\n            files under %(metavar)s. May be used in place of specifying control\n            files.\"\"\", metavar='DIR')\n    arguments = parser.parse_args()\n\n\n    # Load controls\n    if bool(arguments.directory) == bool(arguments.json_files):\n        parser.error('Exactly one of `-d` and control_files must be specified.')\n    elif arguments.directory:\n        arguments.json_files.extend(control_iter(arguments.directory))\n\n    template = arguments.template\n\n    # Make sure that either a template or a template file was given\n    if arguments.template_file:\n        # if given a template file, the default is to run the input\n        if not arguments.template:\n            template = os.path.join('.',\n                    os.path.basename(arguments.template_file))\n\n            # If using the default argument, the template must be executable:\n            if (not os.access(arguments.template_file, os.X_OK) and not\n                    arguments.dry_run):\n                parser.error(\n                        \"{0} is not executable. Specify a template.\".format(\n                    arguments.template_file))\n\n    if not (arguments.template or arguments.template_file):\n        parser.exit(\"Error: Please specify either a template \"\n                \"or a template file\")\n\n    logging.info('Template: %s', template)\n\n    if arguments.local_procs is not None:\n        max_procs = arguments.local_procs\n\n    # Create a dictionary that will be shared amongst all forked processes.\n    data = {}\n    data['dry_run'] = arguments.dry_run\n    data['start_directory'] = os.getcwd()\n    data['template'] = template\n    data['template_file'] = arguments.template_file\n    data['savecmd_file'] = arguments.savecmd_file\n    data['log_file'] = arguments.log_file\n    data['stop_on_error'] = arguments.stop_on_error\n    data['summary_file'] = arguments.summary_file\n\n    return data, max_procs, arguments.json_files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmark the process as complete with provided return_code", "response": "def complete(self, return_code):\n        \"\"\"\n        Mark the process as complete with provided return_code\n        \"\"\"\n        self.return_code = return_code\n        self.status = 'COMPLETE' if not return_code else 'FAILED'\n        self.end_time = datetime.datetime.now()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the last nlines lines of the log file.", "response": "def log_tail(self, nlines=10):\n        \"\"\"\n        Return the last ``nlines`` lines of the log file\n        \"\"\"\n        log_path = os.path.join(self.working_dir, self.log_name)\n        with open(log_path) as fp:\n            d = collections.deque(maxlen=nlines)\n            d.extend(fp)\n            return ''.join(d)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self,table, **kparams):\n        records = self.api.list(table, **kparams)\n        return records", "response": "get a collection of records by table name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self,table, sys_id):\n        record = self.api.get(table, sys_id)\n        return record", "response": "get a single record by table name and sys_id returns a SnowRecord obj."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self,table, sys_id, **kparams):\n        record = self.api.update(table, sys_id, **kparams)\n        return record", "response": "update a record via table api"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __sweeten(self, dumper: 'Dumper', class_: Type, node: Node) -> None:\n        for base_class in class_.__bases__:\n            if base_class in dumper.yaml_representers:\n                logger.debug('Sweetening for class {}'.format(\n                    self.class_.__name__))\n                self.__sweeten(dumper, base_class, node)\n        if hasattr(class_, 'yatiml_sweeten'):\n            class_.yatiml_sweeten(node)", "response": "Applies the user s yatiml_sweeten function to the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbinds the frozen context and compose the selected features returns the selected features", "response": "def select_product():\n    \"\"\"\n    binds the frozen context the selected features\n\n    should be called only once - calls after the first call have\n    no effect\n    \"\"\"\n    global _product_selected\n    if _product_selected:\n        # tss already bound ... ignore\n        return\n\n    _product_selected = True\n    from django_productline import context, template\n\n    featuremonkey.add_import_guard('django.conf')\n    featuremonkey.add_import_guard('django.db')\n    os.environ['DJANGO_SETTINGS_MODULE'] = 'django_productline.settings'\n    contextfile = os.environ['PRODUCT_CONTEXT_FILENAME']\n    equationfile = os.environ['PRODUCT_EQUATION_FILENAME']\n\n\n    #bind context and compose features\n    context.bind_context(contextfile)\n    get_composer().select_equation(equationfile)\n\n    # after composition we are now able to bind composed template settings\n    template.bind_settings()\n\n    featuremonkey.remove_import_guard('django.conf')\n    featuremonkey.remove_import_guard('django.db')\n\n    import django\n    if compare_version(django.get_version(), '1.7') >= 0:\n        django.setup()\n    # force import of settings and urls\n    # better fail during initialization than on the first request\n    from django.conf import settings\n    from django.core.urlresolvers import get_resolver\n    # eager creation of URLResolver\n    get_resolver(None)\n\n    # make sure overextends tag is registered\n    from django.template.loader import get_template\n    from overextends import models"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes the object to a string.", "response": "def serialize(self, format=\"turtle\"):\n        \"\"\" xml, n3, turtle, nt, pretty-xml, trix are built in\"\"\"\n        if self.triples:\n            if not self.rdfgraph:\n                self._buildGraph()\n            return self.rdfgraph.serialize(format=format)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bestDescription(self, prefLanguage=\"en\"):\n\n        test_preds = [rdflib.RDFS.comment, rdflib.namespace.DCTERMS.description, rdflib.namespace.DC.description,\n                      rdflib.namespace.SKOS.definition]\n\n        for pred in test_preds:\n            test = self.getValuesForProperty(pred)\n            if test:\n                return addQuotes(firstEnglishStringInList(test))\n        return \"\"", "response": "facility for extrating the best available description for an entity"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stats(self):\n        printDebug(\"Classes.....: %d\" % len(self.classes))\n        printDebug(\"Properties..: %d\" % len(self.properties))", "response": "Print out useful info for interactive use"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mkp(*args, **kwargs):\n    mk = kwargs.pop('mk', False)\n    path = os.sep.join(list(args))\n    if mk:\n        while sep2 in path:\n            path = path.replace(sep2, os.sep)\n        try:\n            os.makedirs(path)\n        except FileExistsError:\n            pass\n    return path", "response": "Generate a directory path and create it if requested."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_bytes(value):\n    n = np.rint(len(str(value))/4).astype(int)\n    return value/(1024**n), sizes[n]", "response": "Converts a number of bytes to more convenient units."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of internal modules belonging to the given package.", "response": "def get_internal_modules(key='exa'):\n    \"\"\"\n    Get a list of modules belonging to the given package.\n\n    Args:\n        key (str): Package or library name (e.g. \"exa\")\n    \"\"\"\n    key += '.'\n    return [v for k, v in sys.modules.items() if k.startswith(key)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_user_ip(request):\n    ip = get_real_ip(request)\n    if ip is None:\n        ip = get_ip(request)\n        if ip is None:\n            ip = '127.0.0.1'\n    return ip", "response": "Return user ip\n\n    :param request: Django request object\n    :return: user ip"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure the Pylons environment via the pylons. config object", "response": "def load_environment(global_conf, app_conf):\r\n    \"\"\"Configure the Pylons environment via the ``pylons.config``\r\n    object\r\n    \"\"\"\r\n    # Pylons paths\r\n    root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\r\n    paths = dict(root=root,\r\n                 controllers=os.path.join(root, 'controllers'),\r\n                 static_files=os.path.join(root, 'public'),\r\n                 templates=[os.path.join(root, 'templates')])\r\n\r\n    # Initialize config with the basic options\r\n    config.init_app(global_conf, app_conf, package='chatapp', paths=paths)\r\n\r\n    config['routes.map'] = make_map()\r\n    config['pylons.app_globals'] = app_globals.Globals()\r\n    config['pylons.h'] = chatapp.lib.helpers\r\n\r\n    # Create the Mako TemplateLookup, with the default auto-escaping\r\n    config['pylons.app_globals'].mako_lookup = TemplateLookup(\r\n        directories=paths['templates'], input_encoding='utf-8',\r\n        imports=['from webhelpers.html import escape'],\r\n        default_filters=['escape'], output_encoding='utf-8',\r\n        module_directory=os.path.join(app_conf['cache_dir'], 'templates'),\r\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmodify singular value decomposition. Returns U S V where U = M.", "response": "def msvd(m):\n  \"\"\"Modified singular value decomposition.\n\n  Returns U, S, V where Udagger M V = diag(S) and the singular values\n  are sorted in ascending order (small to large).\n  \"\"\"\n  u, s, vdgr = np.linalg.svd(m)\n  order = s.argsort()\n  # reverse the n first columns of u\n  s = s[order]\n  u= u[:,order]\n  vdgr = vdgr[order]\n  return u, s, vdgr.conj().T"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmodifies Takagi factorization of a symmetric matrix.", "response": "def mtakfac(m):\n  \"\"\"Modified Takagi factorization of a (complex) symmetric matrix.\n\n  Returns U, S where U^T M U = diag(S) and the singular values\n  are sorted in ascending order (small to large).\n  \"\"\"\n  u, s, v = msvd(np.asarray(m, dtype=complex))\n  f = np.sqrt(u.conj().T @ v.conj())\n  w = v @ f\n  return w, s"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_parameters(self, resource, params):\n        '''Creates a dictionary from query_string and `params`\n\n        Transforms the `?key=value&...` to a {'key': 'value'} and adds\n        (or overwrites if already present) the value with the dictionary in\n        `params`.\n        '''\n        # remove params from resource URI (needed for paginated stuff)\n        parsed_uri = urlparse(resource)\n        qs = parsed_uri.query\n        resource = urlunparse(parsed_uri._replace(query=''))\n        prms = {}\n        for tup in parse_qsl(qs):\n            prms[tup[0]] = tup[1]\n\n        # params supplied to self.get() override parsed params\n        for key in params:\n            prms[key] = params[key]\n        return resource, prms", "response": "Creates a dictionary from query_string and params"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a vcf variant line and return a dictionary of fields on the header columns", "response": "def get_variant_dict(variant_line, header_line=None):\n    \"\"\"Parse a variant line\n        \n        Split a variant line and map the fields on the header columns\n        \n        Args:\n            variant_line (str): A vcf variant line\n            header_line (list): A list with the header columns\n        Returns:\n            variant_dict (dict): A variant dictionary\n    \"\"\"\n    if not header_line:\n        logger.debug(\"No header line, use only first 8 mandatory fields\")\n        header_line = ['CHROM','POS','ID','REF','ALT','QUAL','FILTER','INFO']\n    \n    logger.debug(\"Building variant dict from variant line {0} and header\"\\\n    \" line {1}\".format(variant_line, '\\t'.join(header_line)))\n    \n    splitted_line = variant_line.rstrip().split('\\t')\n    if len(splitted_line) < len(header_line):\n        logger.info('\\t'.join(header_line))\n        logger.info('\\t'.join(splitted_line))\n        raise SyntaxError(\"Length of variant line differs from length of\"\\\n                            \" header line\")\n    \n    return dict(zip(header_line, splitted_line))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_info_dict(info_line):\n    \n    variant_info = {}\n    for raw_info in info_line.split(';'):\n        splitted_info = raw_info.split('=')\n        if len(splitted_info) == 2:\n            variant_info[splitted_info[0]] = splitted_info[1]\n        else:\n            variant_info[splitted_info[0]] = True\n    \n    return variant_info", "response": "Parse a INFO field of a vcf variant and return a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a variant id from a dictionary of CHROM POS REF ALT and a line of text.", "response": "def get_variant_id(variant_dict=None, variant_line=None):\n    \"\"\"Build a variant id\n    \n        The variant id is a string made of CHROM_POS_REF_ALT\n        \n        Args:\n            variant_dict (dict): A variant dictionary\n        \n        Returns:\n            variant_id (str)\n    \"\"\"\n    \n    if variant_dict:\n        chrom = variant_dict['CHROM']\n        position = variant_dict['POS']\n        ref = variant_dict['REF']\n        alt = variant_dict['ALT']\n    elif variant_line:\n        splitted_line = variant_line.rstrip().split('\\t')\n        chrom = splitted_line[0]\n        position = splitted_line[1]\n        ref = splitted_line[3]\n        alt = splitted_line[4]\n    else:\n        raise Exception(\"Have to provide variant dict or variant line\")\n    \n    return '_'.join([\n        chrom,\n        position,\n        ref,\n        alt,\n    ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vep_info(vep_string, vep_header):\n    \n    vep_annotations = [\n        dict(zip(vep_header, vep_annotation.split('|'))) \n        for vep_annotation in vep_string.split(',')\n    ]\n    \n    return vep_annotations", "response": "Make the vep annotations into a list of dictionaries"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking the vep annotations into a list of dictionaries.", "response": "def get_snpeff_info(snpeff_string, snpeff_header):\n    \"\"\"Make the vep annotations into a dictionaries\n    \n        A snpeff dictionary will have the snpeff column names as keys and \n        the vep annotations as values.\n        The dictionaries are stored in a list. \n        One dictionary for each transcript.\n\n        Args:\n            snpeff_string (string): A string with the ANN annotation\n            snpeff_header (list): A list with the vep header\n        \n        Return:\n            snpeff_annotations (list): A list of vep dicts\n    \n    \"\"\"\n    \n    snpeff_annotations = [\n        dict(zip(snpeff_header, snpeff_annotation.split('|'))) \n        for snpeff_annotation in snpeff_string.split(',')\n    ]\n    \n    return snpeff_annotations"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, timeout = 0):\r\n        ptimeout = int(\r\n            timeout.days*86400000000000 +\r\n            timeout.microseconds*1000 +\r\n            timeout.seconds*1000000000\r\n            if timeout else (self.n_resolution if timeout is None else 0)\r\n        )\r\n        if ptimeout>sys.maxint:\r\n            ptimeout = sys.maxint\r\n        if self.tokens:\r\n            events = self.kq.kevent(None, self.default_size, ptimeout)\r\n            # should check here if timeout isn't negative or larger than maxint\r\n            len_events = len(events)-1\r\n            for nr, ev in enumerate(events):\r\n                fd = ev.ident\r\n                act = ev.udata\r\n\r\n                if ev.flags & EV_ERROR:\r\n                    ev = EV_SET(fd, act.flags, EV_DELETE)\r\n                    self.kq.kevent(ev)\r\n                    self.handle_error_event(act, 'System error %s.'%ev.data)\r\n                else:\r\n                    if nr == len_events:\r\n                        ret = self.yield_event(act)\r\n                        if not ret:\r\n                            ev.flags = EV_ADD | EV_ENABLE | EV_ONESHOT\r\n                            self.kq.kevent(ev)\r\n                        return ret\r\n                    else:\r\n                        if not self.handle_event(act):\r\n                            ev.flags = EV_ADD | EV_ENABLE | EV_ONESHOT\r\n                            self.kq.kevent(ev)\r\n        else:\r\n            sleep(timeout)", "response": "Run a proactor loop and return new socket events."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates a duration ( wall clock time not the CPU time and a memory size.", "response": "def profile(name='stats', _stats=stats):\n    \"\"\"Calculates a duration (wall clock time, not the CPU time) and a memory size.\"\"\"\n    def _profile(function):\n        def __profile(*args, **kw):\n            start_time = timer()\n            start_memory = _get_memory_usage()\n            try:\n                return function(*args, **kw)\n            finally:\n                total = timer() - start_time\n                kstones = _seconds_to_kpystones(total)\n                memory = _get_memory_usage() - start_memory\n                _stats[name] = {'time': total,\n                                'kstones': kstones,\n                                'memory': memory}\n        return __profile\n    return _profile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match(self, row):\n        if re.search(self._expression, row[self._field]):\n            return True\n\n        return False", "response": "Returns True if the field matches the regular expression of this simple condition. Returns False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_horoscope(self, day='today'):\n        if not is_valid_day(day):\n            raise HoroscopeException(\"Invalid day. Allowed days: [today|yesterday|tomorrow]\" )\n\n        horoscope = ''.join([str(s).strip() for s in self.tree.xpath('//*[@id=\"%s\"]/p/text()' % day)])\n\n        if day is 'yesterday':\n            date = self.date_today - timedelta(days=1)\n        elif day is 'today':\n            date = self.date_today\n        elif day is 'tomorrow':\n            date = self.date_today + timedelta(days=1)\n\n        return {\n            'date': date.strftime(\"%Y-%m-%d\"),\n            'sunsign': self.sunsign.capitalize(),\n            'horoscope': horoscope + \"(c) Kelli Fox, The Astrologer, http://new.theastrologer.com\",\n            'meta': self._get_horoscope_meta(day),\n            'credit': '(c) Kelli Fox, The Astrologer, http://new.theastrologer.com'\n        }", "response": "gets a horoscope from site html"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_horoscope_meta(self, day='today'):\n        if not is_valid_day(day):\n            raise HoroscopeException(\"Invalid day. Allowed days: [today|yesterday|tomorrow]\" )\n\n        return {\n            'intensity': str(self.tree.xpath('//*[@id=\"%s\"]/div[3]/div[1]/p[1]/text()' % day)[0]).replace(\": \", \"\"),\n            'mood': str(self.tree.xpath('//*[@id=\"%s\"]/div[3]/div[1]/p[2]/text()' % day)[0]).replace(\": \", \"\"),\n            'keywords': str(self.tree.xpath('//*[@id=\"%s\"]/div[3]/div[2]/p[1]/text()' % day)[0]).replace(\": \", \"\"),\n        }", "response": "gets a horoscope meta from site html"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an item from heap.", "response": "def heapremove(heap,item):\r\n    \"\"\"\r\n    Removes item from heap.\r\n    (This function is missing from the standard heapq package.)\r\n    \"\"\"\r\n    i=heap.index(item)\r\n    lastelt=heap.pop()\r\n    if item==lastelt:\r\n        return\r\n    heap[i]=lastelt\r\n    heapq._siftup(heap,i)\r\n    if i:\r\n        heapq._siftdown(heap,0,i)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the timeout in the scheduler check for defaults.", "response": "def process(self, sched, coro):\r\n        \"\"\"Add the timeout in the scheduler, check for defaults.\"\"\"\r\n        super(TimedOperation, self).process(sched, coro)\r\n\r\n        if sched.default_timeout and not self.timeout:\r\n            self.set_timeout(sched.default_timeout)\r\n        if self.timeout and self.timeout != -1:\r\n            self.coro = coro\r\n\r\n            if self.weak_timeout:\r\n                self.last_checkpoint = getnow()\r\n                self.delta = self.timeout - self.last_checkpoint\r\n            else:\r\n                self.last_checkpoint = self.delta = None\r\n\r\n            heapq.heappush(sched.timeouts, self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process(self, sched, coro):\r\n        super(WaitForSignal, self).process(sched, coro)\r\n        waitlist = sched.sigwait[self.name]\r\n        waitlist.append((self, coro))\r\n        if self.name in sched.signals:\r\n            sig = sched.signals[self.name]\r\n            if sig.recipients <= len(waitlist):\r\n                sig.process(sched, sig.coro)\r\n                del sig.coro\r\n                del sched.signals[self.name]", "response": "Add the calling coro in a waiting for signal queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove this coro from the waiting for signal queue.", "response": "def cleanup(self, sched, coro):\r\n        \"\"\"Remove this coro from the waiting for signal queue.\"\"\"\r\n        try:\r\n            sched.sigwait[self.name].remove((self, coro))\r\n        except ValueError:\r\n            pass\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the calling coro to the queue if there are enough coroutines waiting for the signal as the recipicient param.", "response": "def process(self, sched, coro):\r\n        \"\"\"If there aren't enough coroutines waiting for the signal as the\r\n        recipicient param add the calling coro in another queue to be activated\r\n        later, otherwise activate the waiting coroutines.\"\"\"\r\n        super(Signal, self).process(sched, coro)\r\n        self.result = len(sched.sigwait[self.name])\r\n        if self.result < self.recipients:\r\n            sched.signals[self.name] = self\r\n            self.coro = coro\r\n            return\r\n\r\n        for waitop, waitcoro in sched.sigwait[self.name]:\r\n            waitop.result = self.value\r\n        if self.prio & priority.OP:\r\n            sched.active.extendleft(sched.sigwait[self.name])\r\n        else:\r\n            sched.active.extend(sched.sigwait[self.name])\r\n\r\n        if self.prio & priority.CORO:\r\n            sched.active.appendleft((None, coro))\r\n        else:\r\n            sched.active.append((None, coro))\r\n\r\n        del sched.sigwait[self.name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef finalize(self, sched):\r\n        super(AddCoro, self).finalize(sched)\r\n        return self.result", "response": "Return a reference to the instance of the newly added coroutine."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process(self, sched, coro):\r\n        super(AddCoro, self).process(sched, coro)\r\n        self.result = sched.add(self.coro, self.args, self.kwargs, self.prio & priority.OP)\r\n        if self.prio & priority.CORO:\r\n            return self, coro\r\n        else:\r\n            sched.active.append( (None, coro))", "response": "Add the given coroutine in the scheduler."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the calling coroutine as a waiter.", "response": "def process(self, sched, coro):\r\n        \"\"\"Add the calling coroutine as a waiter in the coro we want to join.\r\n        Also, doesn't keep the called active (we'll be activated back when the\r\n        joined coro dies).\"\"\"\r\n        super(Join, self).process(sched, coro)\r\n        self.coro.add_waiter(coro)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of values for each curve point in the current time varying noise", "response": "def curve_points(self, beginframe, endframe, framestep, birthframe, startframe, stopframe, deathframe,\n                     filternone=False, noiseframe=None):\n        \"\"\"\n        returns a list of frames from startframe to stopframe, in steps of framestep\n        :param beginframe: first frame to include in list of points\n        :param endframe: last frame to include in list of points\n        :param framestep: framestep, e.g. 0.01 means that the points will be calculated in timesteps of 0.01\n        :param birthframe: frame before which animation always returns None\n        :param startframe: frame from which animation starts to evolve \n        :param stopframe: frame in which animation completed\n        :param deathframe: frame in which animation starts returning None \n        :param filternone: removes all \"None\" values from the list of curve_points. The reply can still be None if no curve_points\n        can be calculated.\n        :param noiseframe: for time varying noise, this frame represents the current time for which the noise \n        must be evaluated\n        :return: list of tweened values\n        \"\"\"\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of points from startframe to stopframe in steps of framestep", "response": "def curve_points(self, beginframe, endframe, framestep, birthframe, startframe, stopframe, deathframe,\n                     filternone=True, noiseframe=None):\n        \"\"\"\n        returns a list of frames from startframe to stopframe, in steps of framestepj\n        warning: the list of points may include \"None\" elements \n        :param beginframe: first frame to include in list of points\n        :param endframe: last frame to include in list of points\n        :param framestep: framestep \n        :param birthframe: frame before which animation always returns None\n        :param startframe: frame from which animation starts to evolve \n        :param stopframe: frame in which animation completed\n        :param deathframe: frame in which animation starts returning None \n        :param filternone: automatically remove None entries\n        :param noiseframe: for time varying noise, this represents the time for which the noise should be evaluated\n        :return: list of tweened values\n        \"\"\"\n        if endframe < beginframe and framestep > 0:\n            assert False, \"infinite loop: beginframe = {0}, endframe = {1}, framestep = {2}\".format(beginframe,\n                                                                                                    endframe, framestep)\n        if endframe > beginframe and framestep < 0:\n            assert False, \"infinite loop: beginframe = {0}, endframe = {1}, framestep = {2}\".format(beginframe,\n                                                                                                    endframe, framestep)\n\n        i = beginframe\n        result = [self.make_frame(i, birthframe, startframe, stopframe, deathframe, noiseframe)]\n        while i < endframe:\n            i += framestep\n            if i <= endframe:\n                result.append(self.make_frame(i, birthframe, startframe, stopframe, deathframe, noiseframe))\n        if filternone:\n            return filter_none(result)\n        else:\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addToStore(store, identifier, name):\n    persistedFactory = store.findOrCreate(_PersistedFactory, identifier=identifier)\n    persistedFactory.name = name\n    return persistedFactory", "response": "Adds a persisted factory with given identifier and object name to the given store."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the obj_fields parameter", "response": "def p_obj_fields(self, p):\n        \"\"\"\n        obj_fields : obj_fields ',' obj_field\n                   | obj_field\n        \"\"\"\n        p[0] = dict([p[1]] if len(p) == 2 else p[1] + [p[3]])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading and parses an OWL resource in OWL / XML format using the : class : OWLParser.", "response": "def parse_owl_xml(url):\n    \"\"\"Downloads and parses an OWL resource in OWL/XML format using the :class:`OWLParser`.\n\n    :param str url: The URL to the OWL resource\n    :return: A directional graph representing the OWL document's hierarchy\n    :rtype: networkx.DiGraph\n    \"\"\"\n    res = download(url)\n    owl = OWLParser(content=res.content)\n    return owl"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve a specific object from a given model by primary - key lookup and stores it in a context variable.", "response": "def retrieve_object(model, *args, **kwargs):\n    \"\"\"\n    Retrieves a specific object from a given model by primary-key\n    lookup, and stores it in a context variable.\n    \n    Syntax::\n    \n        {% retrieve_object [app_name].[model_name] [lookup kwargs] as [varname] %}\n    \n    Example::\n    \n        {% retrieve_object flatpages.flatpage pk=12 as my_flat_page %}\n    \n    \"\"\"\n    if len(args) == 1:\n        kwargs.update({'pk': args[0]})\n    _model = _get_model(model)\n    try:\n        return _model._default_manager.get(**kwargs)\n    except _model.DoesNotExist:\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms an overlapped request and saves the token and the token and the overlapped trio.", "response": "def request_generic(self, act, coro, perform, complete):\r\n        \"\"\"\r\n        Performs an overlapped request (via `perform` callable) and saves\r\n        the token and the (`overlapped`, `perform`, `complete`) trio.\r\n        \"\"\"\r\n        overlapped = pywintypes.OVERLAPPED()\r\n        overlapped.object = act\r\n        self.add_token(act, coro, (overlapped, perform, complete))\r\n\r\n        try:\r\n            rc, nbytes = perform(act, overlapped)\r\n\r\n            if rc == 0:\r\n                # ah geez, it didn't got in the iocp, we have a result!\"\r\n                win32file.PostQueuedCompletionStatus(\r\n                    self.iocp, nbytes, 0, overlapped\r\n                )\r\n        except pywintypes.error, exc:\r\n            raise SocketError(exc)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing an operation and return a tuple of the completion and the coroutine exception.", "response": "def process_op(self, rc, nbytes, overlap):\r\n        \"\"\"\r\n        Handles the possible completion or re-queueing if conditions haven't\r\n        been met (the `complete` callable returns false) of a overlapped request.\r\n        \"\"\"\r\n        act = overlap.object\r\n        overlap.object = None\r\n        if act in self.tokens:\r\n            ol, perform, complete = self.tokens[act]\r\n            assert ol is overlap\r\n            if rc == 0:\r\n                ract = self.try_run_act(act, complete, rc, nbytes)\r\n                if ract:\r\n                    del self.tokens[act]\r\n                    win32file.CancelIo(act.sock._fd.fileno())\r\n                    return ract, act.coro\r\n                else:\r\n                    # operation hasn't completed yet (not enough data etc)\r\n                    # read it in the iocp\r\n                    self.request_generic(act, act.coro, perform, complete)\r\n\r\n\r\n            else:\r\n                #looks like we have a problem, forward it to the coroutine.\r\n\r\n                # this needs some research: ERROR_NETNAME_DELETED, need to reopen\r\n                #the accept sock ?! something like:\r\n                #    warnings.warn(\"ERROR_NETNAME_DELETED: %r. Re-registering operation.\" % op)\r\n                #    self.registered_ops[op] = self.run_iocp(op, coro)\r\n                del self.tokens[act]\r\n                win32file.CancelIo(act.sock._fd.fileno())\r\n                return CoroutineException((\r\n                    SocketError, SocketError(\r\n                        (rc, \"%s on %r\" % (ctypes.FormatError(rc), act))\r\n                    )\r\n                )), act.coro\r\n        else:\r\n            import warnings\r\n            warnings.warn(\"Unknown token %s\" % act)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, timeout = 0):\r\n        # same resolution as epoll\r\n        ptimeout = int(\r\n            timeout.days * 86400000 +\r\n            timeout.microseconds / 1000 +\r\n            timeout.seconds * 1000\r\n            if timeout else (self.m_resolution if timeout is None else 0)\r\n        )\r\n        if self.tokens:\r\n            scheduler = self.scheduler\r\n            urgent = None\r\n            # we use urgent as a optimisation: the last operation is returned\r\n            #directly to the scheduler (the sched might just run it till it\r\n            #goes to sleep) and not added in the sched.active queue\r\n            while 1:\r\n                try:\r\n                    rc, nbytes, key, overlap = win32file.GetQueuedCompletionStatus(\r\n                        self.iocp,\r\n                        0 if urgent else ptimeout\r\n                    )\r\n                except RuntimeError:\r\n                    # we will get \"This overlapped object has lost all its\r\n                    # references so was destroyed\" when we remove a operation,\r\n                    # it is garbage collected and the overlapped completes\r\n                    # afterwards\r\n                    break\r\n\r\n                # well, this is a bit weird, if we get a aborted rc (via CancelIo\r\n                #i suppose) evaluating the overlap crashes the interpeter\r\n                #with a memory read error\r\n                if rc != win32file.WSA_OPERATION_ABORTED and overlap:\r\n\r\n                    if urgent:\r\n                        op, coro = urgent\r\n                        urgent = None\r\n                        if op.prio & priority.OP:\r\n                            # imediately run the asociated coroutine step\r\n                            op, coro = scheduler.process_op(\r\n                                coro.run_op(op, scheduler),\r\n                                coro\r\n                            )\r\n                        if coro:\r\n                            #TODO, what \"op and \"\r\n                            if op and (op.prio & priority.CORO):\r\n                                scheduler.active.appendleft( (op, coro) )\r\n                            else:\r\n                                scheduler.active.append( (op, coro) )\r\n                    if overlap.object:\r\n                        urgent = self.process_op(rc, nbytes, overlap)\r\n                else:\r\n                    break\r\n            return urgent\r\n        else:\r\n            sleep(timeout)", "response": "Calls GetQueuedCompletionStatus and handles completion via process_op and process_coroutine."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef html_from_markdown(markdown):\n\n    if login:\n        r = requests.get(gh_url+\"/rate_limit\", auth=login.auth())\n        if r.status_code >= 400:\n            if r.status_code != 401:\n                err = RequestError('Bad HTTP Status Code: %s' % r.status_code)\n                raise err\n            if verbose:\n                sys.stderr.write('Unauthorized. Proceeding without login...\\n')\n            login.devalue()\n\n    headers = {'content-type': 'text/plain', 'charset': 'utf-8'}\n\n    r = requests.post(gh_url + \"/markdown/raw\", data=markdown.encode('utf-8'),\n                      auth=login.auth(), headers=headers)\n    if r.status_code >= 400 and r.status_code != 403:\n            err = RequestError('Bad HTTP Status Code: %s' % r.status_code)\n            raise err\n\n    if verbose:\n        sys.stderr.write(\"%s requests remaining, resets in %d minutes\\n\"\n                         % rate_limit_info())\n    return r.text", "response": "Takes raw markdown returns html result from GitHub api"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef standalone(body):\n    with open(_ROOT + '/html.dat', 'r') as html_template:\n        head = html_title()\n        html = \"\".join(html_template.readlines()) \\\n                 .replace(\"{{HEAD}}\", head) \\\n                 .replace(\"{{BODY}}\", body)\n        return html", "response": "Returns complete html document given markdown html"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns server on port with html response", "response": "def run_server(port=8000):\n    \"\"\" Runs server on port with html response \"\"\"\n    from http.server import BaseHTTPRequestHandler, HTTPServer\n\n    class VerboseHTMLHandler(BaseHTTPRequestHandler):\n        def do_HEAD(s):\n            s.send_response(200)\n            s.send_header(\"Content-type\", \"text/html\")\n            s.end_headers()\n\n        def do_GET(s):\n            global html\n\n            data = changed_file()\n            if data is not None:\n                html = html_from_markdown(data)\n            s.send_response(200)\n            s.send_header(\"Content-type\", \"text/html\")\n            s.end_headers()\n            s.wfile.write(standalone(html).encode('utf-8'))\n\n    class SilentHTMLHandler(VerboseHTMLHandler):\n        def log_message(self, format, *args):\n            return\n\n    port = int(port)\n    server_class = HTTPServer\n    handler = VerboseHTMLHandler if verbose else SilentHTMLHandler\n    try:\n        httpd = server_class((\"localhost\", port), handler)\n    except PermissionError:\n        sys.stderr.write(\"Permission denied\\n\")\n        sys.exit(1)\n    if verbose:\n        print(\"Hosting server on port %d. Ctrl-c to exit\" % port)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    httpd.server_close()\n    if verbose:\n        print(\"\\rShutting down server\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the remaining and minutes to reset for a single node", "response": "def rate_limit_info():\n    \"\"\" Returns (requests_remaining, minutes_to_reset) \"\"\"\n    import json\n    import time\n\n    r = requests.get(gh_url + \"/rate_limit\", auth=login.auth())\n    out = json.loads(r.text)\n    mins = (out[\"resources\"][\"core\"][\"reset\"]-time.time())/60\n    return out[\"resources\"][\"core\"][\"remaining\"], mins"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value of the current resource in the current tree.", "response": "def set(parser, token):\n    \"\"\"\n        Usage:\n        {% set templ_tag var1 var2 ... key %}\n        {% set variable key %}\n        This tag save result of {% templ_tag var1 var2 ... %} to variable with name key,\n        Or will save value of variable to new variable with name key.\n    \"\"\"\n    bits = token.contents.split(' ')[1:]\n    new_token = Token(TOKEN_BLOCK, ' '.join(bits[:-1]))\n    if bits[0] in parser.tags:\n        func = parser.tags[bits[0]](parser, new_token)\n    else:\n        func = Variable(bits[0])\n    return SetNode(func, bits[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stringClade(taxrefs, name, at):\n    '''Return a Newick string from a list of TaxRefs'''\n    string = []\n    for ref in taxrefs:\n        # distance is the difference between the taxonomic level of the ref\n        #  and the current level of the tree growth\n        d = float(at-ref.level)\n        # ensure no spaces in ident, Newick tree cannot have spaces\n        ident = re.sub(\"\\s\", \"_\", ref.ident)\n        string.append('{0}:{1}'.format(ident, d))\n    # join into single string with a name for the clade\n    string = ','.join(string)\n    string = '({0}){1}'.format(string, name)\n    return string", "response": "Return a Newick string from a list of TaxRefs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef taxTree(taxdict):\n    # the taxonomic dictionary holds the lineage of each ident in\n    #  the same order as the taxonomy\n    # use hierarchy to construct a taxonomic tree\n    for rank in taxdict.taxonomy:\n        current_level = float(taxdict.taxonomy.index(rank))\n        # get clades at this rank in hierarchy\n        clades = taxdict.hierarchy[rank]\n        # merge those that are in the same clade into a cladestring\n        for clade in clades:\n            # unpack the identities in this clade and its clade name\n            cladeidents, cladename = clade\n            # Remove '' TaxRefs -- in cladestring already\n            cladeidents = [e for e in cladeidents if e.ident]\n            # only create cladestring if more than one ident in clade\n            if len(cladeidents) < 2:\n                continue\n            # label node by 'clade'_'rank'\n            cladename = '{0}_{1}'.format(cladename, rank)\n            cladestring = stringClade(cladeidents, cladename, current_level)\n            # replace first TaxRef in cladeidents with cladestring\n            cladeidents[0].change(ident=cladestring, rank=rank)\n            # replace all other TaxRefs with ''\n            for e in cladeidents[1:]:\n                e.change(ident='', rank=rank)\n    # join any remaining strands into tree\n    if len(taxdict.hierarchy[taxdict.taxonomy[-1]]) > 1:\n        # unlist first\n        clade = [e[0] for e in taxdict.hierarchy[taxdict.taxonomy[-1]]]\n        cladeidents = sum(clade, [])\n        cladeidents = [e for e in cladeidents if e.ident]\n        cladestring = stringClade(cladeidents, 'life', current_level+1)\n    return cladestring + ';'", "response": "Return a taxonomic Newick tree from a taxonomy dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nchange the instance of the related object.", "response": "def change(self, ident, rank=None):\n        '''Change ident'''\n        self.ident = ident\n        if rank:\n            self.rank = rank\n            self.level = self._getLevel(rank, self.taxonomy)\n        # count changes made to instance\n        self.counter += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd additional data slots from kwargs", "response": "def _additional(self, idents, kwargs):\n        '''Add additional data slots from **kwargs'''\n        if kwargs:\n            for name, value in list(kwargs.items()):\n                if not isinstance(value, list):\n                    raise ValueError('Additional arguments must be lists of \\\nsame length as idents')\n                for i in range(len(value)):\n                    self[idents[i]][name] = value[i]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn list of tuples of ident and lineage ident for given level ( numbered rank", "response": "def _slice(self, level):\n        '''Return list of tuples of ident and lineage ident for given level\n(numbered rank)'''\n        if level >= len(self.taxonomy):\n            raise IndexError('Level greater than size of taxonomy')\n        res = []\n        for ident in sorted(list(self.keys())):\n            res.append((self[ident]['taxref'], self[ident]['lineage'][level]))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn list of lists of idents grouped by shared rank", "response": "def _group(self, taxslice):\n        '''Return list of lists of idents grouped by shared rank'''\n        res = []\n        while taxslice:\n            taxref, lident = taxslice.pop()\n            if lident == '':\n                res.append(([taxref], lident))\n            else:\n                # identify idents in the same group and pop from taxslice\n                i = 0\n                group = []\n                while i < len(taxslice):\n                    if taxslice[i][1] == lident:\n                        group.append(taxslice.pop(i)[0])\n                    else:\n                        i += 1\n                group.append(taxref)\n                res.append((group, lident))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _hierarchy(self):\n        '''Generate dictionary of referenced idents grouped by shared rank'''\n        self.hierarchy = {}\n        for rank in self.taxonomy:\n            # extract lineage idents for this rank\n            taxslice = self._slice(level=self.taxonomy.index(rank))\n            # group idents by shared group at this rank\n            self.hierarchy[rank] = self._group(taxslice)", "response": "Generate dictionary of referenced idents grouped by shared rank"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _contextualise(self):\n        '''Determine contextual idents (cidents)'''\n        # loop through hierarchy identifying unique lineages\n        # TODO: gain other contextual information, not just ident\n        deja_vues = []\n        for rank in reversed(self.taxonomy):\n            # return named clades -- '' are ignored\n            clades = [e for e in self.hierarchy[rank] if e[1]]\n            # print 'Rank: {0} - {1}'.format(rank, len(clades))\n            # get unique lineages at this level\n            uniques = [e for e in clades if len(e[0]) == 1]\n            # removed those already seen\n            uniques = [e for e in uniques if e[0][0].ident not in deja_vues]\n            # add each to self[ident]['cident']\n            for e in uniques:\n                ident = e[0][0].ident\n                self[ident]['cident'] = e[1]\n                deja_vues.append(ident)", "response": "Determine contextual idents ( cidents )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_module(self, module):\n        if isinstance(module, basestring) and module.find('.') > -1:\n            a = module.split('.')\n            module = ('.%s' % a[-1], '.'.join(a[:-1]))\n        try:\n            module = import_module(*module)\n        except Exception, e:\n            return e\n        \n        for name in dir(module):\n            if name.startswith('_'): continue\n            obj = getattr(module, name)\n            if callable(obj):\n                for tag in settings.TAG_TYPES:\n                    if hasattr(obj, tag) and getattr(obj, tag) in (1, True):\n                        name = getattr(obj, 'name', obj.__name__)\n                        if name in self[tag]:\n                            continue\n                        if hasattr(obj, 'name'):\n                            self.register(tag, getattr(obj, 'name'), obj)\n                        else:\n                            self.register(tag, obj)", "response": "Loads a module string like django. contrib. markup. templatetags. markup into the registry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a function to the registry by name", "response": "def register(self, bucket, name_or_func, func=None):\n        \"\"\"\n        Add a function to the registry by name\n        \"\"\"\n        assert bucket in self, 'Bucket %s is unknown' % bucket\n        if func is None and hasattr(name_or_func, '__name__'):\n            name = name_or_func.__name__\n            func = name_or_func\n        elif func:\n            name = name_or_func\n        if name in self[bucket]:\n            raise AlreadyRegistered('The function %s is already registered' % name)\n\n        self[bucket][name] = func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the function from the registry by name", "response": "def unregister(self, bucket, name):\n        \"\"\"\n        Remove the function from the registry by name\n        \"\"\"\n        assert bucket in self, 'Bucket %s is unknown' % bucket\n        if not name in self[bucket]:\n            raise NotRegistered('The function %s is not registered' % name)\n        del self[bucket][name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets documentation for the first tag matching the given name", "response": "def get_doc(self, tag_name):\n        \"Get documentation for the first tag matching the given name\"\n        for tag,func in self.tags:\n            if tag.startswith(tag_name) and func.__doc__:\n                return func.__doc__"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_bucket(self, name):\n        \"Find out which bucket a given tag name is in\"\n        for bucket in self:\n            for k,v in self[bucket].items():\n                if k == name:\n                    return bucket", "response": "Find out which bucket a given tag name is in"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the first tag function matching the given name", "response": "def get(self, name):\n        \"Get the first tag function matching the given name\"\n        for bucket in self:\n            for k,v in self[bucket].items():\n                if k == name:\n                    return v"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating over all tags yielding ( name function )", "response": "def tags(self):\n        \"Iterate over all tags yielding (name, function)\"\n        for bucket in self:\n            for k,v in self[bucket].items():\n                yield k,v"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nopen a BBC radio tracklisting page based on trailing part of url.", "response": "def open_listing_page(trailing_part_of_url):\n    \"\"\"\n    Opens a BBC radio tracklisting page based on trailing part of url.\n    Returns a lxml ElementTree derived from that page.\n\n    trailing_part_of_url: a string, like the pid or e.g. pid/segments.inc\n    \"\"\"\n    base_url = 'http://www.bbc.co.uk/programmes/'\n    print(\"Opening web page: \" + base_url + trailing_part_of_url)\n\n    try:\n        html = requests.get(base_url + trailing_part_of_url).text\n    except (IOError, NameError):\n        print(\"Error opening web page.\")\n        print(\"Check network connection and/or programme id.\")\n        sys.exit(1)\n\n    try:\n        return lxml.html.fromstring(html)\n    except lxml.etree.ParserError:\n        print(\"Error trying to parse web page.\")\n        print(\"Maybe there's no programme listing?\")\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_programme_title(pid):\n    print(\"Extracting title and station...\")\n    main_page_etree = open_listing_page(pid)\n    try:\n        title, = main_page_etree.xpath('//title/text()')\n    except ValueError:\n        title = ''\n    return title.strip()", "response": "Take BBC programme ID as string ; returns programme title as string ; returns programme title as string ; returns programme title as string ;"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_broadcast_date(pid):\n    print(\"Extracting first broadcast date...\")\n    broadcast_etree = open_listing_page(pid + '/broadcasts.inc')\n    original_broadcast_date, = broadcast_etree.xpath(\n        '(//div[@class=\"grid__inner\"]//div'\n        '[@class=\"broadcast-event__time beta\"]/@title)[1]')\n    return original_broadcast_date", "response": "Take BBC pid and extract and return broadcast date as string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts listing ; return list of tuples ( artist title label ).", "response": "def extract_listing(pid):\n    \"\"\"Extract listing; return list of tuples (artist(s), title, label).\"\"\"\n    print(\"Extracting tracklisting...\")\n    listing_etree = open_listing_page(pid + '/segments.inc')\n    track_divs = listing_etree.xpath('//div[@class=\"segment__track\"]')\n\n    listing = []\n    for track_div in track_divs:\n        try:\n            artist_names = track_div.xpath('.//span[@property=\"byArtist\"]'\n                                           '//span[@class=\"artist\"]/text()')\n        except ValueError:\n            artist_names = ['']\n\n        if not artist_names:\n            artist_names = ['']\n\n        if len(artist_names) > 1:\n            artists = ', '.join(artist_names[:-1]) + ' & ' + artist_names[-1]\n        else:\n            artists = artist_names[0]\n\n        try:\n            title, = track_div.xpath('.//p/span[@property=\"name\"]/text()')\n        except ValueError:\n            title = ''\n\n        try:\n            label, = track_div.xpath('.//abbr[@title=\"Record Label\"]'\n                                     '/span[@property=\"name\"]/text()')\n        except ValueError:\n            label = ''\n        listing.append((artists, title, label))\n    return listing"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a full tracklisting string.", "response": "def generate_output(listing, title, date):\n    \"\"\"\n    Returns a string containing a full tracklisting.\n\n    listing: list of (artist(s), track, record label) tuples\n    title: programme title\n    date: programme date\n    \"\"\"\n    listing_string = '{0}\\n{1}\\n\\n'.format(title, date)\n    for entry in listing:\n        listing_string += '\\n'.join(entry) + '\\n***\\n'\n    return listing_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a filename as string without an extension.", "response": "def get_output_filename(args):\n    \"\"\"Returns a filename as string without an extension.\"\"\"\n    # If filename and path provided, use these for output text file.\n    if args.directory is not None and args.fileprefix is not None:\n        path = args.directory\n        filename = args.fileprefix\n        output = os.path.join(path, filename)\n    # Otherwise, set output to current path\n    elif args.fileprefix is not None:\n        output = args.fileprefix\n    else:\n        output = args.pid\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting tracklisting to a text file.", "response": "def write_listing_to_textfile(textfile, tracklisting):\n    \"\"\"Write tracklisting to a text file.\"\"\"\n    with codecs.open(textfile, 'wb', 'utf-8') as text:\n        text.write(tracklisting)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave a tag to an audio file.", "response": "def save_tag_to_audio_file(audio_file, tracklisting):\n    \"\"\"\n    Saves tag to audio file.\n    \"\"\"\n    print(\"Trying to tag {}\".format(audio_file))\n    f = mediafile.MediaFile(audio_file)\n\n    if not f.lyrics:\n        print(\"No tracklisting present. Creating lyrics tag.\")\n        f.lyrics = 'Tracklisting' + '\\n' + tracklisting\n    elif tracklisting not in f.lyrics:\n        print(\"Appending tracklisting to existing lyrics tag.\")\n        f.lyrics = f.lyrics + '\\n\\n' + 'Tracklisting' + '\\n' + tracklisting\n    else:\n        print(\"Tracklisting already present. Not modifying file.\")\n        raise TagNotNeededError\n\n    f.save()\n    print(\"Saved tag to file:\", audio_file)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntag an audio file with tracklisting as list.", "response": "def tag_audio_file(audio_file, tracklisting):\n    \"\"\"\n    Adds tracklisting as list to lyrics tag of audio file if not present.\n    Returns True if successful or not needed, False if tagging fails.\n    \"\"\"\n    try:\n        save_tag_to_audio_file(audio_file, tracklisting)\n    # TODO: is IOError required now or would the mediafile exception cover it?\n    except (IOError, mediafile.UnreadableFileError):\n        print(\"Unable to save tag to file:\", audio_file)\n        audio_tagging_successful = False\n    except TagNotNeededError:\n        audio_tagging_successful = True\n    else:\n        audio_tagging_successful = True\n    return audio_tagging_successful"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef output_to_file(filename, tracklisting, action):\n    if action in ('tag', 'both'):\n        audio_tagged = tag_audio(filename, tracklisting)\n        if action == 'both' and audio_tagged:\n            write_text(filename, tracklisting)\n    elif action == 'text':\n        write_text(filename, tracklisting)", "response": "Produce requested output ; either output text file tag audio file or both."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling writing tracklisting to text file.", "response": "def write_text(filename, tracklisting):\n    \"\"\"Handle writing tracklisting to text.\"\"\"\n    print(\"Saving text file.\")\n    try:\n        write_listing_to_textfile(filename + '.txt', tracklisting)\n    except IOError:\n        # if all else fails, just print listing\n        print(\"Cannot write text file to path: {}\".format(filename))\n        print(\"Printing tracklisting here instead.\")\n        # ignoring errors is a hack to cope with Windows not dealing well\n        # with UTF-8\n        print(tracklisting.encode(sys.stdout.encoding, errors='ignore'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if audio tagged successfully ; handle tagging audio.", "response": "def tag_audio(filename, tracklisting):\n    \"\"\"Return True if audio tagged successfully; handle tagging audio.\"\"\"\n    # TODO: maybe actually glob for files, then try tagging if present?\n    if not(tag_audio_file(filename + '.m4a', tracklisting) or\n           tag_audio_file(filename + '.mp3', tracklisting)):\n        print(\"Cannot find or access any relevant M4A or MP3 audio file.\")\n        print(\"Trying to save a text file instead.\")\n        write_text(filename, tracklisting)\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a tracklisting write to audio file or text.", "response": "def main():\n    \"\"\"Get a tracklisting, write to audio file or text.\"\"\"\n    args = parse_arguments()\n    pid = args.pid\n    title = get_programme_title(pid)\n    broadcast_date = get_broadcast_date(pid)\n    listing = extract_listing(pid)\n    filename = get_output_filename(args)\n    tracklisting = generate_output(listing, title, broadcast_date)\n    output_to_file(filename, tracklisting, args.action)\n    print(\"Done!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreplace the information of a VCF line or a VCF dictionary with a new one.", "response": "def replace_vcf_info(keyword, annotation, variant_line=None, variant_dict=None):\n    \"\"\"Replace the information of a info field of a vcf variant line or a \n        variant dict.\n    \n    Arguments:\n        variant_line (str): A vcf formatted variant line\n        variant_dict (dict): A variant dictionary\n        keyword (str): The info field key\n        annotation (str): If the annotation is a key, value pair\n                          this is the string that represents the value\n    \n    Returns:\n        variant_line (str): A annotated variant line\n    \"\"\"\n    new_info = '{0}={1}'.format(keyword, annotation)\n    \n    logger.debug(\"Replacing the variant information {0}\".format(new_info))\n    \n    fixed_variant = None\n    new_info_list = []\n    \n    if variant_line:\n        logger.debug(\"Adding information to a variant line\")\n        splitted_variant = variant_line.rstrip('\\n').split('\\t')\n        logger.debug(\"Adding information to splitted variant line\")\n        old_info = splitted_variant[7]\n        if old_info == '.':\n            new_info_string = new_info\n        else:\n            splitted_info_string = old_info.split(';')\n            for info in splitted_info_string:\n                splitted_info_entry = info.split('=')\n                if splitted_info_entry[0] == keyword:\n                    new_info_list.append(new_info)\n                else:\n                    new_info_list.append(info)\n            new_info_string = ';'.join(new_info_list)\n        \n        splitted_variant[7] = new_info_string\n        \n        fixed_variant = '\\t'.join(splitted_variant)\n    \n    elif variant_dict:\n        logger.debug(\"Adding information to a variant dict\")\n        old_info = variant_dict['INFO']\n        \n        if old_info == '.':\n            variant_dict['INFO'] = new_info\n        else:\n            for info in old_info.split(';'):\n                splitted_info_entry = info.split('=')\n                if splitted_info_entry[0] == keyword:\n                    new_info_list.append(new_info)\n                else:\n                    new_info_list.append(info)\n            new_info_string = ';'.join(new_info_list)\n        \n        variant_dict['INFO'] = new_info_string\n        fixed_variant = variant_dict\n    \n    return fixed_variant"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the information of a specific keyword from a single vcf line or a variant dictionary.", "response": "def remove_vcf_info(keyword, variant_line=None, variant_dict=None):\n    \"\"\"Remove the information of a info field of a vcf variant line or a \n        variant dict.\n    \n    Arguments:\n        variant_line (str): A vcf formatted variant line\n        variant_dict (dict): A variant dictionary\n        keyword (str): The info field key\n    \n    Returns:\n        variant_line (str): A annotated variant line\n    \"\"\"\n    logger.debug(\"Removing variant information {0}\".format(keyword))\n    \n    fixed_variant = None\n    \n    def get_new_info_string(info_string, keyword):\n        \"\"\"Return a info string without keyword info\"\"\"\n        new_info_list = []\n        splitted_info_string = info_string.split(';')\n        for info in splitted_info_string:\n            splitted_info_entry = info.split('=')\n            if splitted_info_entry[0] != keyword:\n                new_info_list.append(info)\n        \n        new_info_string = ';'.join(new_info_list)\n        \n        return new_info_string\n        \n    \n    if variant_line:\n        logger.debug(\"Removing information from a variant line\")\n        splitted_variant = variant_line.rstrip('\\n').split('\\t')\n        \n        old_info = splitted_variant[7]\n        if old_info == '.':\n            new_info_string = '.'\n        else:\n            new_info_string = get_new_info_string(old_info, keyword)\n        \n        splitted_variant[7] = new_info_string\n        \n        fixed_variant = '\\t'.join(splitted_variant)\n    \n    elif variant_dict:\n        logger.debug(\"Removing information to a variant dict\")\n        old_info = variant_dict['INFO']\n        \n        if old_info == '.':\n            variant_dict['INFO'] = old_info\n        else:\n            new_info_string = get_new_info_string(old_info, keyword)\n        \n        variant_dict['INFO'] = new_info_string\n        fixed_variant = variant_dict\n    \n    return fixed_variant"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd information to the info field of a vcf variant line.", "response": "def add_vcf_info(keyword, variant_line=None, variant_dict=None, annotation=None):\n    \"\"\"\n    Add information to the info field of a vcf variant line.\n    \n    Arguments:\n        variant_line (str): A vcf formatted variant line\n        keyword (str): The info field key\n        annotation (str): If the annotation is a key, value pair\n                          this is the string that represents the value\n    \n    Returns:\n        fixed_variant : str if variant line, or dict if variant_dict\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    if annotation:\n        new_info = '{0}={1}'.format(keyword, annotation)\n    else:\n        new_info = keyword\n    \n    logger.debug(\"Adding new variant information {0}\".format(new_info))\n    \n    fixed_variant = None\n    \n    if variant_line:\n        logger.debug(\"Adding information to a variant line\")\n        splitted_variant = variant_line.rstrip('\\n').split('\\t')\n        logger.debug(\"Adding information to splitted variant line\")\n        old_info = splitted_variant[7]\n        if old_info == '.':\n            splitted_variant[7] = new_info\n        else:\n            splitted_variant[7] = \"{0};{1}\".format(splitted_variant[7], new_info)\n        \n        fixed_variant = '\\t'.join(splitted_variant)\n    \n    elif variant_dict:\n        logger.debug(\"Adding information to a variant dict\")\n        old_info = variant_dict['INFO']\n        if old_info == '.':\n            variant_dict['INFO'] = new_info\n        else:\n            variant_dict['INFO'] = \"{0};{1}\".format(old_info, new_info)\n        fixed_variant = variant_dict\n    \n    return fixed_variant"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef createsuperusers():\n    from django.contrib.auth import models as auth_models\n    from django.conf import settings\n    from django.core.mail import send_mail\n    from django.contrib.sites import models as site_models\n    import uuid\n    from django.db import transaction\n    from django.db.models import Q\n\n    site = site_models.Site.objects.get(id=settings.SITE_ID)\n\n    for entry in settings.INITIAL_SUPERUSERS:\n        # create initial supersuers.\n\n        print('*** Create specified superuser {}'.format(entry['username']))\n\n        if not auth_models.User.objects.filter(Q(username__in=[entry['username'], entry['email']]) | Q(email=entry['email'])).exists():\n            # create the superuser if it does not exist yet\n            with transaction.atomic():\n                password = ''.join(str(uuid.uuid4())[:8])\n\n                root = auth_models.User()\n                root.first_name = entry.get('first_name', '')\n                root.last_name = entry.get('last_name', '')\n                root.email = entry['email']\n                root.username = entry['username']\n                root.set_password(password)\n                root.is_active = True\n                root.save()\n                # overwrite default is_staff\n                root.is_staff = True\n                root.is_superuser = True\n                root.save()\n\n                send_mail(\n                    subject='Your superuser account',\n                    recipient_list=[entry['email']],\n                    from_email=settings.DEFAULT_FROM_EMAIL,\n                    message='username: {username}\\npassword: {pw}\\nsite: {site}'.format(\n                        username=root.username,\n                        pw=password,\n                        site=site.domain\n                    ),\n                )\n\n                print('\\tA new superuser was created. Check {}'.format(entry['email']))\n        else:\n            print('\\tSpecified superuser already exists')", "response": "Creates all superusers defined in settings. INITIAL_SUPERUSERS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _log(message):\n        #  @todo Replace with log package.\n        print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()) + ' ' + str(message), flush=True)", "response": "Logs a message.\n\n        :param str message: The log message.\n\n        :rtype: None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_exception(self, row, exception):\n        self._log('Error during processing of line {0:d}.'.format(self._source_reader.row_number))\n        self._log(row)\n        self._log(str(exception))\n        self._log(traceback.format_exc())", "response": "Logs an exception occurred during transformation of a row."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds all _step methods in this class.", "response": "def _find_all_step_methods(self):\n        \"\"\"\n        Finds all _step<n> methods where n is an integer in this class.\n        \"\"\"\n        steps = ([method for method in dir(self) if callable(getattr(self, method)) and\n                  re.match(r'_step\\d+\\d+.*', method)])\n        steps = sorted(steps)\n        for step in steps:\n            self._steps.append(getattr(self, step))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntransforming all source rows.", "response": "def _transform_rows(self):\n        \"\"\"\n        Transforms all source rows.\n        \"\"\"\n        self._find_all_step_methods()\n\n        for row in self._source_reader.next():\n            self._transform_row_wrapper(row)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _transform_row_wrapper(self, row):\n        self._count_total += 1\n\n        try:\n            # Transform the naturals keys in line to technical keys.\n            in_row = copy.copy(row)\n            out_row = {}\n            park_info, ignore_info = self._transform_row(in_row, out_row)\n\n        except Exception as e:\n            # Log the exception.\n            self._handle_exception(row, e)\n            # Keep track of the number of errors.\n            self._count_error += 1\n            # This row must be parked.\n            park_info = 'Exception'\n            # Keep our IDE happy.\n            ignore_info = None\n            out_row = {}\n\n        if park_info:\n            # Park the row.\n            self.pre_park_row(park_info, row)\n            self._parked_writer.writerow(row)\n            self._count_park += 1\n        elif ignore_info:\n            # Ignore the row.\n            self.pre_ignore_row(ignore_info, row)\n            self._ignored_writer.writerow(row)\n            self._count_ignore += 1\n        else:\n            # Write the technical keys and measures to the output file.\n            self._transformed_writer.writerow(out_row)\n            self._count_transform += 1", "response": "Transforms a single source row.\n\n        :param dict[str|str] row: The source row."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _transform_row(self, in_row, out_row):\n        tmp_row = {}\n\n        for step in self._steps:\n            park_info, ignore_info = step(in_row, tmp_row, out_row)\n            if park_info or ignore_info:\n                return park_info, ignore_info\n\n        return None, None", "response": "Transforms an input row to an output row."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _step00(self, in_row, tmp_row, out_row):\n        for key, value in in_row.items():\n            in_row[key] = WhitespaceCleaner.clean(value)\n\n        return None, None", "response": "Remove all whitespace from all fields in the input row."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates all mandatory fields are present in the input row and fill the output row with the values in the input row.", "response": "def _step99(self, in_row, tmp_row, out_row):\n        \"\"\"\n        Validates all mandatory fields are in the output row and are filled.\n\n        :param dict in_row: The input row.\n        :param dict tmp_row: Not used.\n        :param dict out_row: The output row.\n        \"\"\"\n        park_info = ''\n        for field in self._mandatory_fields:\n            if field not in out_row or not out_row[field]:\n                if park_info:\n                    park_info += ' '\n                park_info += field\n\n        return park_info, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs statistics about the number of rows and number of rows per second.", "response": "def _log_statistics(self):\n        \"\"\"\n        Log statistics about the number of rows and number of rows per second.\n        \"\"\"\n        rows_per_second_trans = self._count_total / (self._time1 - self._time0)\n        rows_per_second_load = self._count_transform / (self._time2 - self._time1)\n        rows_per_second_overall = self._count_total / (self._time3 - self._time0)\n\n        self._log('Number of rows processed            : {0:d}'.format(self._count_total))\n        self._log('Number of rows transformed          : {0:d}'.format(self._count_transform))\n        self._log('Number of rows ignored              : {0:d}'.format(self._count_ignore))\n        self._log('Number of rows parked               : {0:d}'.format(self._count_park))\n        self._log('Number of errors                    : {0:d}'.format(self._count_error))\n        self._log('Number of rows per second processed : {0:d}'.format(int(rows_per_second_trans)))\n        self._log('Number of rows per second loaded    : {0:d}'.format(int(rows_per_second_load)))\n        self._log('Number of rows per second overall   : {0:d}'.format(int(rows_per_second_overall)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transform_source_rows(self):\n        # Start timer for overall progress.\n        self._time0 = time.perf_counter()\n\n        self.pre_transform_source_rows()\n\n        # Transform all source rows.\n        with self._source_reader:\n            with self._transformed_writer:\n                with self._parked_writer:\n                    with self._ignored_writer:\n                        self._transform_rows()\n\n        # Time end of transformation.\n        self._time1 = time.perf_counter()\n\n        # Load transformed rows into the fact table.\n        self._load_transformed_rows()\n\n        # Time end of loading transformed rows.\n        self._time2 = time.perf_counter()\n\n        # Load parked and ignored rows into the parked and ignored rows.\n        self._load_ignored_rows()\n        self._load_parked_rows()\n\n        # Time end of loading parked and ignored rows.\n        self._time3 = time.perf_counter()\n\n        # Show statistics about number of rows and performance.\n        self._log_statistics()", "response": "Transforms the rows for the source system into partial dimensional data."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the tags of current object", "response": "def list_tags(self):\n        \"\"\"\n        Get the tags of current object\n\n        :return: the tags\n        :rtype: list\n        \"\"\"\n        from highton.models.tag import Tag\n        return fields.ListField(\n            name=self.ENDPOINT,\n            init_class=Tag\n        ).decode(\n            self.element_from_string(\n                self._get_request(\n                    endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Tag.ENDPOINT,\n                ).text\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _clean_dict(target_dict, whitelist=None):\n    assert isinstance(target_dict, dict)\n    return {\n        ustr(k).strip(): ustr(v).strip()\n        for k, v in target_dict.items()\n        if v not in (None, Ellipsis, [], (), \"\")\n        and (not whitelist or k in whitelist)\n    }", "response": "Utility function that removes empty values from a dict that are not in whitelist"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_user_agent(platform=None):\n    if isinstance(platform, ustr):\n        platform = platform.upper()\n    return {\"chrome\": AGENT_CHROME, \"edge\": AGENT_EDGE, \"ios\": AGENT_IOS}.get(\n        platform, random.choice(AGENT_ALL)\n    )", "response": "Returns a random user agent string for the specified platform"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _request_json(\n    url,\n    parameters=None,\n    body=None,\n    headers=None,\n    cache=True,\n    agent=None,\n    reattempt=5,\n):\n    \"\"\" Queries a url for json data\n\n    Note: Requests are cached using requests_cached for a week, this is done\n    transparently by using the package's monkey patching\n    \"\"\"\n    assert url\n    content = None\n    status = 500\n    log.info(\"url: %s\" % url)\n\n    if isinstance(headers, dict):\n        headers = _clean_dict(headers)\n    else:\n        headers = dict()\n    if isinstance(parameters, dict):\n        parameters = _d2l(_clean_dict(parameters))\n    if body:\n        method = \"POST\"\n        headers[\"content-type\"] = \"application/json\"\n        headers[\"user-agent\"] = _get_user_agent(agent)\n        headers[\"content-length\"] = ustr(len(body))\n    else:\n        method = \"GET\"\n        headers[\"user-agent\"] = _get_user_agent(agent)\n\n    initial_cache_state = SESSION._is_cache_disabled  # yes, i'm a bad person\n    try:\n        SESSION._is_cache_disabled = not cache\n        response = SESSION.request(\n            url=url,\n            params=parameters,\n            json=body,\n            headers=headers,\n            method=method,\n            timeout=1,\n        )\n        status = response.status_code\n        content = response.json() if status // 100 == 2 else None\n        cache = getattr(response, \"from_cache\", False)\n    except RequestException as e:\n        log.debug(e, exc_info=True)\n        return _request_json(\n            url, parameters, body, headers, cache, agent, reattempt - 1\n        )\n    except Exception as e:\n        log.error(e, exc_info=True)\n        if reattempt > 0:\n            SESSION.cache.clear()\n            return _request_json(\n                url, parameters, body, headers, False, agent, 0\n            )\n    else:\n        log.info(\"method: %s\" % method)\n        log.info(\"headers: %r\" % headers)\n        log.info(\"parameters: %r\" % parameters)\n        log.info(\"cache: %r\" % cache)\n        log.info(\"status: %d\" % status)\n        log.debug(\"content: %s\" % content)\n    finally:\n        SESSION._is_cache_disabled = initial_cache_state\n\n    return status, content", "response": "Queries a url for json data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for The Movie Database objects using another DB s foreign key.", "response": "def tmdb_find(\n    api_key, external_source, external_id, language=\"en-US\", cache=True\n):\n    \"\"\" Search for The Movie Database objects using another DB's foreign key\n\n    Note: language codes aren't checked on this end or by TMDb, so if you\n        enter an invalid language code your search itself will succeed, but\n        certain fields like synopsis will just be empty\n\n    Online docs: developers.themoviedb.org/3/find\n    \"\"\"\n    sources = [\"imdb_id\", \"freebase_mid\", \"freebase_id\", \"tvdb_id\", \"tvrage_id\"]\n    if external_source not in sources:\n        raise MapiProviderException(\"external_source must be in %s\" % sources)\n    if external_source == \"imdb_id\" and not match(r\"tt\\d+\", external_id):\n        raise MapiProviderException(\"invalid imdb tt-const value\")\n    url = \"https://api.themoviedb.org/3/find/\" + external_id or \"\"\n    parameters = {\n        \"api_key\": api_key,\n        \"external_source\": external_source,\n        \"language\": language,\n    }\n    keys = [\n        \"movie_results\",\n        \"person_results\",\n        \"tv_episode_results\",\n        \"tv_results\",\n        \"tv_season_results\",\n    ]\n    status, content = _request_json(url, parameters, cache=cache)\n    if status == 401:\n        raise MapiProviderException(\"invalid API key\")\n    elif status != 200 or not any(content.keys()):\n        raise MapiNetworkException(\"TMDb down or unavailable?\")\n    elif status == 404 or not any(content.get(k, {}) for k in keys):\n        raise MapiNotFoundException\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a movie item using the Movie Database", "response": "def tmdb_movies(api_key, id_tmdb, language=\"en-US\", cache=True):\n    \"\"\" Lookup a movie item using The Movie Database\n\n    Online docs: developers.themoviedb.org/3/movies\n    \"\"\"\n    try:\n        url = \"https://api.themoviedb.org/3/movie/%d\" % int(id_tmdb)\n    except ValueError:\n        raise MapiProviderException(\"id_tmdb must be numeric\")\n    parameters = {\"api_key\": api_key, \"language\": language}\n    status, content = _request_json(url, parameters, cache=cache)\n    if status == 401:\n        raise MapiProviderException(\"invalid API key\")\n    elif status == 404:\n        raise MapiNotFoundException\n    elif status != 200 or not any(content.keys()):\n        raise MapiNetworkException(\"TMDb down or unavailable?\")\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for movies using The Movie Database Online docs : developers. themoviedb. org / 3. search - movies - js", "response": "def tmdb_search_movies(\n    api_key, title, year=None, adult=False, region=None, page=1, cache=True\n):\n    \"\"\" Search for movies using The Movie Database\n\n    Online docs: developers.themoviedb.org/3/search/search-movies\n    \"\"\"\n    url = \"https://api.themoviedb.org/3/search/movie\"\n    try:\n        if year:\n            year = int(year)\n    except ValueError:\n        raise MapiProviderException(\"year must be numeric\")\n    parameters = {\n        \"api_key\": api_key,\n        \"query\": title,\n        \"page\": page,\n        \"include_adult\": adult,\n        \"region\": region,\n        \"year\": year,\n    }\n    status, content = _request_json(url, parameters, cache=cache)\n    if status == 401:\n        raise MapiProviderException(\"invalid API key\")\n    elif status != 200 or not any(content.keys()):\n        raise MapiNetworkException(\"TMDb down or unavailable?\")\n    elif status == 404 or status == 422 or not content.get(\"total_results\"):\n        raise MapiNotFoundException\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs into TVDb using the provided api key", "response": "def tvdb_login(api_key):\n    \"\"\" Logs into TVDb using the provided api key\n\n    Note: You can register for a free TVDb key at thetvdb.com/?tab=apiregister\n    Online docs: api.thetvdb.com/swagger#!/Authentication/post_login=\n    \"\"\"\n    url = \"https://api.thetvdb.com/login\"\n    body = {\"apikey\": api_key}\n    status, content = _request_json(url, body=body, cache=False)\n    if status == 401:\n        raise MapiProviderException(\"invalid api key\")\n    elif status != 200 or not content.get(\"token\"):\n        raise MapiNetworkException(\"TVDb down or unavailable?\")\n    return content[\"token\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tvdb_refresh_token(token):\n    url = \"https://api.thetvdb.com/refresh_token\"\n    headers = {\"Authorization\": \"Bearer %s\" % token}\n    status, content = _request_json(url, headers=headers, cache=False)\n    if status == 401:\n        raise MapiProviderException(\"invalid token\")\n    elif status != 200 or not content.get(\"token\"):\n        raise MapiNetworkException(\"TVDb down or unavailable?\")\n    return content[\"token\"]", "response": "Refreshes JWT token\n    Online docs : api. thetvdb. com / authentication. get_refresh_token =\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a series record that contains all information known about a particular series id_tvdb", "response": "def tvdb_series_id(token, id_tvdb, lang=\"en\", cache=True):\n    \"\"\" Returns a series records that contains all information known about a\n    particular series id\n\n    Online docs: api.thetvdb.com/swagger#!/Series/get_series_id=\n    \"\"\"\n    if lang not in TVDB_LANGUAGE_CODES:\n        raise MapiProviderException(\n            \"'lang' must be one of %s\" % \",\".join(TVDB_LANGUAGE_CODES)\n        )\n    try:\n        url = \"https://api.thetvdb.com/series/%d\" % int(id_tvdb)\n    except ValueError:\n        raise MapiProviderException(\"id_tvdb must be numeric\")\n    headers = {\"Accept-Language\": lang, \"Authorization\": \"Bearer %s\" % token}\n    status, content = _request_json(url, headers=headers, cache=cache)\n    if status == 401:\n        raise MapiProviderException(\"invalid token\")\n    elif status == 404:\n        raise MapiNotFoundException\n    elif status != 200 or not content.get(\"data\"):\n        raise MapiNetworkException(\"TVDb down or unavailable?\")\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nallow the user to search for a series based on the provided parameters", "response": "def tvdb_search_series(\n    token, series=None, id_imdb=None, id_zap2it=None, lang=\"en\", cache=True\n):\n    \"\"\" Allows the user to search for a series based on the following parameters\n\n    Online docs: https://api.thetvdb.com/swagger#!/Search/get_search_series\n    Note: results a maximum of 100 entries per page, no option for pagination=\n    \"\"\"\n    if lang not in TVDB_LANGUAGE_CODES:\n        raise MapiProviderException(\n            \"'lang' must be one of %s\" % \",\".join(TVDB_LANGUAGE_CODES)\n        )\n    url = \"https://api.thetvdb.com/search/series\"\n    parameters = {\"name\": series, \"imdbId\": id_imdb, \"zap2itId\": id_zap2it}\n    headers = {\"Accept-Language\": lang, \"Authorization\": \"Bearer %s\" % token}\n    status, content = _request_json(\n        url, parameters, headers=headers, cache=cache\n    )\n    if status == 401:\n        raise MapiProviderException(\"invalid token\")\n    elif status == 405:\n        raise MapiProviderException(\n            \"series, id_imdb, id_zap2it parameters are mutually exclusive\"\n        )\n    elif status == 404:\n        raise MapiNotFoundException\n    elif status != 200 or not content.get(\"data\"):\n        raise MapiNetworkException(\"TVDb down or unavailable?\")\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef t_ID(self, t):\n        r'~?[a-zA-Z_][a-zA-Z0-9_]*'\n\n        if t.value[0] == '~':\n            t.type = 'TYVAR'\n            t.value = t.value[1:]\n        elif t.value in self.reserved_words:\n            t.type = self.reserved_words[t.value]\n        else:\n            t.type = 'ID'\n\n        return t", "response": "r Returns t with type ID or TEVAR"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_meta_data(self, line):\n        line = line.rstrip()\n        logger.debug(\"Parsing metadata line:{0}\".format(line))\n        line_info = line[2:].split('=')\n        match = False\n\n        if line_info[0] == 'fileformat':\n            logger.debug(\"Parsing fileformat\")\n            try:\n                self.fileformat = line_info[1]\n                logger.debug(\"Found fileformat {0}\".format(self.fileformat))\n            except IndexError:\n                raise SyntaxError(\"fileformat must have a value\")\n\n        elif line_info[0] == 'INFO':\n            match = self.info_pattern.match(line)\n            if not match:\n                raise SyntaxError(\"One of the INFO lines is malformed:{0}\".format(line))\n\n            matches = [\n                match.group('id'), match.group('number'),\n                match.group('type'), match.group('desc')\n            ]\n\n            # extra_info is a dictionary to check the metadata about the INFO values:\n            self.extra_info[matches[0]] = dict(\n                zip(self.header_keys['info'][1:], matches[1:])\n            )\n\n            info_line = dict(list(zip(self.header_keys['info'],matches)))\n\n            if len(info_line['Description'].split('Format:')) > 1:\n                info_line['Format'] = [\n                    info.strip() for info in info_line['Description'].split('Format:')\n                ][-1]\n            self.info_lines.append(info_line)\n\n            # Store the vep columns:\n            if info_line['ID'] == 'CSQ':\n                self.vep_columns = info_line.get('Format', '').split('|')\n\n            if info_line['ID'] == 'ANN':\n                self.snpeff_columns = [\n                    annotation.strip(\"' \") for annotation in\n                    info_line.get('Description', '').split(':')[-1].split('|')]\n\n            self.info_dict[match.group('id')] = line\n\n        elif line_info[0] == 'FILTER':\n            match = self.filter_pattern.match(line)\n            if not match:\n                raise SyntaxError(\"One of the FILTER lines is malformed: {0}\".format(line))\n            matches = [match.group('id'), match.group('desc')]\n            self.filter_lines.append(dict(\n                list(zip(self.header_keys['filt'],matches)))\n            )\n            self.filter_dict[match.group('id')] = line\n\n        elif line_info[0] == 'contig':\n            match = self.contig_pattern.match(line)\n            if not match:\n                print()\n                raise SyntaxError(\"One of the contig lines is malformed: {0}\".format(line))\n\n            matches = [match.group('id'), match.group('length')]\n            self.contig_lines.append(dict(\n                list(zip(self.header_keys['contig'],matches)))\n            )\n            self.contig_dict[match.group('id')] = line\n\n        elif line_info[0] == 'FORMAT':\n            match = self.format_pattern.match(line)\n            if not match:\n                raise SyntaxError(\"One of the FORMAT lines is malformed: {0}\".format(line))\n\n            matches = [\n                match.group('id'), match.group('number'),\n                match.group('type'), match.group('desc')\n            ]\n            self.format_lines.append(dict(\n                list(zip(self.header_keys['form'],matches)))\n            )\n            self.format_dict[match.group('id')] = line\n\n        elif line_info[0] == 'ALT':\n            match = self.alt_pattern.match(line)\n            if not match:\n                raise SyntaxError(\"One of the ALT lines is malformed: {0}\".format(line))\n\n            matches = [match.group('id'), match.group('desc')]\n            self.alt_lines.append(dict(\n                list(zip(self.header_keys['alt'],matches)))\n            )\n            self.alt_dict[match.group('id')] = line\n\n        else:\n            match = self.meta_pattern.match(line)\n            if not match:\n                raise SyntaxError(\"One of the meta data lines is malformed: {0}\".format(line))\n\n            self.other_lines.append({match.group('key'): match.group('val')})\n            self.other_dict[match.group('key')] = line", "response": "Parse a vcf metadataline line and store the information about the VEP and SNPEFF columns."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a field from the header", "response": "def remove_header(self, name):\n        \"\"\"Remove a field from the header\"\"\"\n        if name in self.info_dict:\n            self.info_dict.pop(name)\n            logger.info(\"Removed '{0}' from INFO\".format(name))\n        if name in self.filter_dict:\n            self.filter_dict.pop(name)\n            logger.info(\"Removed '{0}' from FILTER\".format(name))\n        if name in self.format_dict:\n            self.format_dict.pop(name)\n            logger.info(\"Removed '{0}' from FORMAT\".format(name))\n        if name in self.contig_dict:\n            self.contig_dict.pop(name)\n            logger.info(\"Removed '{0}' from CONTIG\".format(name))\n        if name in self.alt_dict:\n            self.alt_dict.pop(name)\n            logger.info(\"Removed '{0}' from ALT\".format(name))\n        if name in self.other_dict:\n            self.other_dict.pop(name)\n            logger.info(\"Removed '{0}' from OTHER\".format(name))\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_fileformat(self, fileformat):\n        self.fileformat = fileformat\n        logger.info(\"Adding fileformat to vcf: {0}\".format(fileformat))\n        return", "response": "Add fileformat line to the header."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_meta_line(self, key, value):\n        meta_line = '##{0}={1}'.format(\n            key, value\n        )\n        logger.info(\"Adding meta line to vcf: {0}\".format(meta_line))\n        self.parse_meta_data(meta_line)\n        return", "response": "Adds an arbitrary metadata line to the header."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_filter(self, filter_id, description):\n        filter_line = '##FILTER=<ID={0},Description=\"{1}\">'.format(\n            filter_id, description\n        )\n        logger.info(\"Adding filter line to vcf: {0}\".format(filter_line))\n        self.parse_meta_data(filter_line)\n        return", "response": "Add a filter line to the header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_format(self, format_id, number, entry_type, description):\n        format_line = '##FORMAT=<ID={0},Number={1},Type={2},Description=\"{3}\">'.format(\n            format_id, number, entry_type, description\n        )\n        logger.info(\"Adding format line to vcf: {0}\".format(format_line))\n        self.parse_meta_data(format_line)\n        return", "response": "Add a format line to the header."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a alternative allele line to the header.", "response": "def add_alt(self, alt_id, description):\n        \"\"\"\n        Add a alternative allele format field line to the header.\n\n        Arguments:\n            alt_id (str): The id of the alternative line\n            description (str): A description of the info line\n\n        \"\"\"\n        alt_line = '##ALT=<ID={0},Description=\"{1}\">'.format(\n            alt_id, description\n        )\n        logger.info(\"Adding alternative allele line to vcf: {0}\".format(alt_line))\n        self.parse_meta_data(alt_line)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a contig line to the header.", "response": "def add_contig(self, contig_id, length):\n        \"\"\"\n        Add a contig line to the header.\n\n        Arguments:\n            contig_id (str): The id of the alternative line\n            length (str): A description of the info line\n\n        \"\"\"\n        contig_line = '##contig=<ID={0},length={1}>'.format(\n            contig_id, length\n        )\n        logger.info(\"Adding contig line to vcf: {0}\".format(contig_line))\n        self.parse_meta_data(contig_line)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vcf_handle(fsock=None, infile=None):\n\n    vcf = None\n    if (fsock or infile):\n    \n        if fsock:\n            # if not infile and hasattr(fsock, 'name'):\n            logger.info(\"Reading vcf form stdin\")\n            if sys.version_info < (3, 0):\n                logger.info(\"Using codecs to read stdin\")\n                sys.stdin = getreader('utf-8')(fsock)\n            \n            vcf = sys.stdin\n        \n        else:\n            logger.info(\"Reading vcf from file {0}\".format(infile))\n            file_name, file_extension = os.path.splitext(infile)\n            if file_extension == '.gz':\n                logger.debug(\"Vcf is zipped\")\n                vcf = getreader('utf-8')(gzip.open(infile), errors='replace')\n            elif file_extension == '.vcf':\n                vcf = open(infile, mode='r', encoding='utf-8', errors='replace')\n            else:\n                raise IOError(\"File is not in a supported format!\\n\"\n                                \" Or use correct ending(.vcf or .vcf.gz)\")\n    else:\n        raise IOError(\"Please provide a fsock or infile\")\n    \n    return vcf", "response": "Open the vcf file and return a handle"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_tag(self, tag_id):\n        from highton.models.tag import Tag\n\n        self._delete_request(\n            endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Tag.ENDPOINT + '/' + str(tag_id),\n        )", "response": "Deletes a Tag from the current object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexpand given requirements file by extending it using pip freeze", "response": "def expand(conf, output_requirements_filename, input_requirements_filename):\n    \"\"\"Expand given requirements file by extending it using pip freeze\n\n    args:\n\n    input_requirements_filename: the requirements filename to expand\n\n    output_requirements_filename: the output filename for the expanded\n    requirements file\n    \"\"\"\n    exit_if_file_not_exists(input_requirements_filename, conf)\n    cireqs.expand_requirements(\n        requirements_filename=input_requirements_filename,\n        expanded_requirements_filename=output_requirements_filename,\n        **conf._asdict()\n    )\n    click.echo(click.style('\u2713', fg='green') + \" {} has been expanded into {}\".format(\n        input_requirements_filename, output_requirements_filename\n    ))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify(conf, input_requirements_filename):\n    exit_if_file_not_exists(input_requirements_filename, conf)\n\n    cireqs.check_if_requirements_are_up_to_date(\n        requirements_filename=input_requirements_filename,\n        **conf._asdict())\n    click.echo(click.style('\u2713', fg='green') + \" {} has been verified\".format(input_requirements_filename))", "response": "Verify that given requirements file is not missing any pins\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the tasks of current object", "response": "def list_tasks(self):\n        \"\"\"\n        Get the tasks of current object\n\n        :return: the tasks\n        :rtype: list\n        \"\"\"\n        from highton.models.task import Task\n\n        return fields.ListField(\n            name=self.ENDPOINT,\n            init_class=Task\n        ).decode(\n            self.element_from_string(\n                self._get_request(\n                    endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Task.ENDPOINT,\n                ).text\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, *args, **kwargs):\n        from django.conf import settings\n        new_lang = self.request.GET.get('lang')\n        response = HttpResponseRedirect(self.request.META.get('HTTP_REFERER'))\n        translation.activate(new_lang)\n        if new_lang and check_for_language(new_lang):\n            next_trans = translate_url(self.request.META.get('HTTP_REFERER'), new_lang)\n            response = HttpResponseRedirect(next_trans)\n        if hasattr(self.request, 'session'):\n            self.request.session[LANGUAGE_SESSION_KEY] = new_lang\n        else:\n            response.set_cookie(settings.LANGUAGE_COOKIE_NAME, new_lang,\n                                max_age=settings.LANGUAGE_COOKIE_AGE,\n                                path=settings.LANGUAGE_COOKIE_PATH,\n                                domain=settings.LANGUAGE_COOKIE_DOMAIN)\n        return response", "response": "This view is used for changing the language."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve all people of the company in the order they were created.", "response": "def people(self):\n        \"\"\"\n        Retrieve all people of the company\n\n        :return: list of people objects\n        :rtype: list\n        \"\"\"\n        return fields.ListField(name=HightonConstants.PEOPLE, init_class=Person).decode(\n            self.element_from_string(\n                self._get_request(\n                    endpoint=self.ENDPOINT + '/' + str(self.id) + '/people',\n                ).text\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nx_to_ontology(graph, source_node, output_path, base_iri):\n    ontology = owlready.Ontology(base_iri)\n\n    parent_lookup = {\n        source_node: types.new_class(source_node, (owlready.Thing,), kwds={\"ontology\": ontology})\n    }\n\n    def recur(pnode):\n        for neighbor in graph.neighbors(pnode):\n            data = graph.node[neighbor]\n            neighbor_class = types.new_class(neighbor, (parent_lookup[pnode],), kwds={\"ontology\": ontology})\n            owlready.ANNOTATIONS[neighbor_class].add_annotation(owlready.rdfs.label, data['label'])\n            recur(neighbor)\n\n    recur(source_node)\n\n    ontology.save(filename=output_path)", "response": "Convert a networkx graph to an ontology."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of points with None s removed", "response": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck this participant in", "response": "async def check_in(self):\n        \"\"\" Checks this participant in\n\n        |methcoro|\n\n        Warning:\n            |unstable|\n\n        Raises:\n            APIException\n\n        \"\"\"\n        res = await self.connection('POST', 'tournaments/{}/participants/{}/check_in'.format(self._tournament_id, self._id))\n        self._refresh_from_json(res)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nundoing the check in for this participant", "response": "async def undo_check_in(self):\n        \"\"\" Undo the check in for this participant\n\n        |methcoro|\n\n        Warning:\n            |unstable|\n\n        Raises:\n            APIException\n\n        \"\"\"\n        res = await self.connection('POST', 'tournaments/{}/participants/{}/undo_check_in'.format(self._tournament_id, self._id))\n        self._refresh_from_json(res)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def get_matches(self, state: MatchState = MatchState.all_):\n        matches = await self.connection('GET',\n                                        'tournaments/{}/matches'.format(self._tournament_id),\n                                        state=state.value,\n                                        participant_id=self._id)\n        # return [await self._tournament.get_match(m['match']['id']) for m in matches] 3.6 only...\n        ms = []\n        for m in matches:\n            ms.append(await self._tournament.get_match(m['match']['id']))\n        return ms", "response": "Return the matches of the given state |methcoro|."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get_next_match(self):\n        if self._final_rank is not None:\n            return None\n\n        matches = await self.get_matches(MatchState.open_)\n\n        if len(matches) == 0:\n            matches = await self.get_matches(MatchState.pending)\n\n        if len(matches) > 0:\n            return matches[0]\n\n        return None", "response": "Return the next open match found or None if none."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the opponent of the potential next match. See get_next_match |methcoro|", "response": "async def get_next_opponent(self):\n        \"\"\" Get the opponent of the potential next match. See :func:`get_next_match`\n\n        |methcoro|\n\n        Raises:\n            APIException\n\n        \"\"\"\n        next_match = await self.get_next_match()\n        if next_match is not None:\n            opponent_id = next_match.player1_id if next_match.player2_id == self._id else next_match.player2_id\n            return await self._tournament.get_participant(opponent_id)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the pseudo key in a row.", "response": "def _get_pseudo_key(self, row):\n        \"\"\"\n        Returns the pseudo key in a row.\n\n        :param dict row: The row.\n\n        :rtype: tuple\n        \"\"\"\n        ret = list()\n        for key in self._pseudo_key:\n            ret.append(row[key])\n\n        return tuple(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a date to an integer.", "response": "def _date2int(date):\n        \"\"\"\n        Returns an integer representation of a date.\n\n        :param str|datetime.date date: The date.\n\n        :rtype: int\n        \"\"\"\n        if isinstance(date, str):\n            if date.endswith(' 00:00:00') or date.endswith('T00:00:00'):\n                # Ignore time suffix.\n                date = date[0:-9]\n            tmp = datetime.datetime.strptime(date, '%Y-%m-%d')\n            return tmp.toordinal()\n\n        if isinstance(date, datetime.date):\n            return date.toordinal()\n\n        if isinstance(date, int):\n            return date\n\n        raise ValueError('Unexpected type {0!s}'.format(date.__class__))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing start and end dates in a row set with their integer representation.", "response": "def _rows_date2int(self, rows):\n        \"\"\"\n        Replaces start and end dates in a row set with their integer representation\n\n        :param list[dict[str,T]] rows: The list of rows.\n        \"\"\"\n        for row in rows:\n            # Determine the type of dates based on the first start date.\n            if not self._date_type:\n                self._date_type = self._get_date_type(row[self._key_start_date])\n\n            # Convert dates to integers.\n            row[self._key_start_date] = self._date2int(row[self._key_start_date])\n            row[self._key_end_date] = self._date2int(row[self._key_end_date])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rows_int2date(self, rows):\n        for row in rows:\n            if self._date_type == 'str':\n                row[self._key_start_date] = datetime.date.fromordinal(row[self._key_start_date]).isoformat()\n                row[self._key_end_date] = datetime.date.fromordinal(row[self._key_end_date]).isoformat()\n            elif self._date_type == 'date':\n                row[self._key_start_date] = datetime.date.fromordinal(row[self._key_start_date])\n                row[self._key_end_date] = datetime.date.fromordinal(row[self._key_end_date])\n            elif self._date_type == 'int':\n                # Nothing to do.\n                pass\n            else:\n                raise ValueError('Unexpected date type {0!s}'.format(self._date_type))", "response": "Replaces start and end dates in the row set with their integer representation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rows_sort(self, rows):\n        return sorted(rows, key=lambda row: (row[self._key_start_date], row[self._key_end_date]))", "response": "Returns a list of rows sorted by start and end date."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the type of a date.", "response": "def _get_date_type(date):\n        \"\"\"\n        Returns the type of a date.\n\n        :param str|datetime.date date: The date.\n\n        :rtype: str\n        \"\"\"\n        if isinstance(date, str):\n            return 'str'\n\n        if isinstance(date, datetime.date):\n            return 'date'\n\n        if isinstance(date, int):\n            return 'int'\n\n        raise ValueError('Unexpected type {0!s}'.format(date.__class__))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if two rows are identical excluding start and end date. Returns False otherwise.", "response": "def _equal(self, row1, row2):\n        \"\"\"\n        Returns True if two rows are identical excluding start and end date. Returns False otherwise.\n\n        :param dict[str,T] row1: The first row.\n        :param dict[str,T] row2: The second row.\n\n        :rtype: bool\n        \"\"\"\n        for key in row1.keys():\n            if key not in [self._key_start_date, self._key_end_date]:\n                if row1[key] != row2[key]:\n                    return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _merge_adjacent_rows(self, rows):\n        ret = list()\n\n        prev_row = None\n        for row in rows:\n            if prev_row:\n                relation = Allen.relation(prev_row[self._key_start_date],\n                                          prev_row[self._key_end_date],\n                                          row[self._key_start_date],\n                                          row[self._key_end_date])\n                if relation is None:\n                    # row holds an invalid interval (prev_row always holds a valid interval). Hence, the join is empty.\n                    return []\n\n                elif relation == Allen.X_BEFORE_Y:\n                    # Two rows with distinct intervals.\n                    # prev_row: |----|\n                    # row:                 |-----|\n                    ret.append(prev_row)\n                    prev_row = row\n\n                elif relation == Allen.X_MEETS_Y:\n                    # The two rows are adjacent.\n                    # prev_row: |-------|\n                    # row:               |-------|\n                    if self._equal(prev_row, row):\n                        # The two rows are identical (except for start and end date) and adjacent. Combine the two rows\n                        # into one row.\n                        prev_row[self._key_end_date] = row[self._key_end_date]\n                    else:\n                        # Rows are adjacent but not identical.\n                        ret.append(prev_row)\n                        prev_row = row\n\n                elif relation == Allen.X_OVERLAPS_WITH_Y:\n                    # prev_row overlaps row. Should not occur with proper reference data.\n                    # prev_row: |-----------|\n                    # row:            |----------|\n                    if self._equal(prev_row, row):\n                        # The two rows are identical (except for start and end date) and overlapping. Combine the two\n                        # rows into one row.\n                        prev_row[self._key_end_date] = row[self._key_end_date]\n                    else:\n                        # Rows are overlapping but not identical.\n                        prev_row[self._key_end_date] = row[self._key_start_date] - 1\n                        ret.append(prev_row)\n                        prev_row = row\n\n                elif relation == Allen.X_STARTS_Y:\n                    # prev_row start row. Should not occur with proper reference data.\n                    # prev_row: |------|\n                    # row:      |----------------|\n                    prev_row = row\n\n                elif relation == Allen.X_EQUAL_Y:\n                    # Can happen when the reference data sets are joined without respect for date intervals.\n                    # prev_row: |----------------|\n                    # row:      |----------------|\n                    prev_row = row\n\n                elif relation == Allen.X_DURING_Y_INVERSE:\n                    # row during prev_row. Should not occur with proper reference data.\n                    # prev_row: |----------------|\n                    # row:           |------|\n                    # Note: the interval with the most recent start date prevails. Hence, the interval after\n                    # row[self._key_end_date] is discarded.\n                    if self._equal(prev_row, row):\n                        prev_row[self._key_end_date] = row[self._key_end_date]\n                    else:\n                        prev_row[self._key_end_date] = row[self._key_start_date] - 1\n                        ret.append(prev_row)\n                        prev_row = row\n\n                elif relation == Allen.X_FINISHES_Y_INVERSE:\n                    # row finishes prev_row. Should not occur with proper reference data.\n                    # prev_row: |----------------|\n                    # row:                |------|\n                    if not self._equal(prev_row, row):\n                        prev_row[self._key_end_date] = row[self._key_start_date] - 1\n                        ret.append(prev_row)\n                        prev_row = row\n\n                        # Note: if the two rows are identical (except for start and end date) nothing to do.\n                else:\n                    # Note: The rows are sorted such that prev_row[self._key_begin_date] <= row[self._key_begin_date].\n                    # Hence the following relation should not occur: X_DURING_Y,  X_FINISHES_Y, X_BEFORE_Y_INVERSE,\n                    # X_MEETS_Y_INVERSE, X_OVERLAPS_WITH_Y_INVERSE, and X_STARTS_Y_INVERSE. Hence, we covered all 13\n                    # relations in Allen's interval algebra.\n                    raise ValueError('Data is not sorted properly. Relation: {0}'.format(relation))\n\n            elif row[self._key_start_date] <= row[self._key_end_date]:\n                # row is the first valid row.\n                prev_row = row\n\n        if prev_row:\n            ret.append(prev_row)\n\n        return ret", "response": "Resolves adjacent and overlapping rows."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enumerate(self, name, start=1):\n        for pseudo_key, rows in self._rows.items():\n            rows = self._rows_sort(rows)\n            ordinal = start\n            for row in rows:\n                row[name] = ordinal\n                ordinal += 1\n            self._rows[pseudo_key] = rows", "response": "Enumerates all rows such that the pseudo key and the ordinal number are unique."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_rows(self, sort=False):\n        ret = []\n        for _, rows in sorted(self._rows.items()) if sort else self._rows.items():\n            self._rows_int2date(rows)\n            ret.extend(rows)\n\n        return ret", "response": "Returns the rows of this Type2Helper."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset and prepares the rows.", "response": "def prepare_data(self, rows):\n        \"\"\"\n        Sets and prepares the rows. The rows are stored in groups in a dictionary. A group is a list of rows with the\n        same pseudo key. The key in the dictionary is a tuple with the values of the pseudo key.\n\n        :param list[dict] rows: The rows\n        \"\"\"\n        self._rows = dict()\n        for row in copy.copy(rows) if self.copy else rows:\n            pseudo_key = self._get_pseudo_key(row)\n            if pseudo_key not in self._rows:\n                self._rows[pseudo_key] = list()\n            self._rows[pseudo_key].append(row)\n\n        # Convert begin and end dates to integers.\n        self._date_type = None\n        for pseudo_key, rows in self._rows.items():\n            self._rows_date2int(rows)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving an annotation return the type and description for the parameter.", "response": "def _get_type_description(annotation):\n    '''\n    Given an annotation, return the (type, description) for the parameter.\n    If you provide an annotation that is somehow both a string and a callable,\n    the behavior is undefined.\n    '''\n    if annotation is _empty:\n        return None, None\n    elif callable(annotation):\n        return annotation, None\n    elif isinstance(annotation, str):\n        return None, annotation\n    elif isinstance(annotation, tuple):\n        try:\n            arg1, arg2 = annotation\n        except ValueError as e:\n            raise AnnotationError(annotation) from e\n        else:\n            if callable(arg1) and isinstance(arg2, str):\n                return arg1, arg2\n            elif isinstance(arg1, str) and callable(arg2):\n                return arg2, arg1\n\n    raise AnnotationError(annotation)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_arguments(param, parser, used_char_args, add_nos):\n    '''\n    Add the argument(s) to an ArgumentParser (using add_argument) for a given\n    parameter. used_char_args is the set of -short options currently already in\n    use, and is updated (if necessary) by this function. If add_nos is True,\n    this will also add an inverse switch for all boolean options. For\n    instance, for the boolean parameter \"verbose\", this will create --verbose\n    and --no-verbose.\n    '''\n\n    # Impl note: This function is kept separate from make_parser because it's\n    # already very long and I wanted to separate out as much as possible into\n    # its own call scope, to prevent even the possibility of suble mutation\n    # bugs.\n    if param.kind is param.POSITIONAL_ONLY:\n        raise PositionalArgError(param)\n    elif param.kind is param.VAR_KEYWORD:\n        raise KWArgError(param)\n\n    # These are the kwargs for the add_argument function.\n    arg_spec = {}\n    is_option = False\n\n    # Get the type and default from the annotation.\n    arg_type, description = _get_type_description(param.annotation)\n\n    # Get the default value\n    default = param.default\n\n    # If there is no explicit type, and the default is present and not None,\n    # infer the type from the default.\n    if arg_type is None and default not in {_empty, None}:\n        arg_type = type(default)\n\n    # Add default. The presence of a default means this is an option, not an\n    # argument.\n    if default is not _empty:\n        arg_spec['default'] = default\n        is_option = True\n\n    # Add the type\n    if arg_type is not None:\n        # Special case for bool: make it just a --switch\n        if arg_type is bool:\n            if not default or default is _empty:\n                arg_spec['action'] = 'store_true'\n            else:\n                arg_spec['action'] = 'store_false'\n\n            # Switches are always options\n            is_option = True\n\n        # Special case for file types: make it a string type, for filename\n        elif isinstance(default, IOBase):\n            arg_spec['type'] = str\n\n        # TODO: special case for list type.\n        #   - How to specificy type of list members?\n        #       - param: [int]\n        #       - param: int =[]\n        #   - action='append' vs nargs='*'\n\n        else:\n            arg_spec['type'] = arg_type\n\n    # nargs: if the signature includes *args, collect them as trailing CLI\n    # arguments in a list. *args can't have a default value, so it can never be\n    # an option.\n    if param.kind is param.VAR_POSITIONAL:\n        # TODO: consider depluralizing metavar/name here.\n        arg_spec['nargs'] = '*'\n\n    # Add description.\n    if description is not None:\n        arg_spec['help'] = description\n\n    # Get the --flags\n    flags = []\n    name = param.name\n\n    if is_option:\n        # Add the first letter as a -short option.\n        for letter in name[0], name[0].swapcase():\n            if letter not in used_char_args:\n                used_char_args.add(letter)\n                flags.append('-{}'.format(letter))\n                break\n\n        # If the parameter is a --long option, or is a -short option that\n        # somehow failed to get a flag, add it.\n        if len(name) > 1 or not flags:\n            flags.append('--{}'.format(name))\n\n        arg_spec['dest'] = name\n    else:\n        flags.append(name)\n\n    parser.add_argument(*flags, **arg_spec)\n\n    # Create the --no- version for boolean switches\n    if add_nos and arg_type is bool:\n        parser.add_argument(\n            '--no-{}'.format(name),\n            action='store_const',\n            dest=name,\n            const=default if default is not _empty else False)", "response": "Add the argument to an ArgumentParser."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_parser(func_sig, description, epilog, add_nos):\n    '''\n    Given the signature of a function, create an ArgumentParser\n    '''\n    parser = ArgumentParser(description=description, epilog=epilog)\n\n    used_char_args = {'h'}\n\n    # Arange the params so that single-character arguments are first. This\n    # esnures they don't have to get --long versions. sorted is stable, so the\n    # parameters will otherwise still be in relative order.\n    params = sorted(\n        func_sig.parameters.values(),\n        key=lambda param: len(param.name) > 1)\n\n    for param in params:\n        _add_arguments(param, parser, used_char_args, add_nos)\n\n    return parser", "response": "Given the signature of a function create an ArgumentParser that will parse the arguments of all the parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a docstring parse it into a description and epilog part", "response": "def parse_docstring(docstring):\n    '''\n    Given a docstring, parse it into a description and epilog part\n    '''\n    if docstring is None:\n        return '', ''\n\n    parts = _DOCSTRING_SPLIT.split(docstring)\n\n    if len(parts) == 1:\n        return docstring, ''\n    elif len(parts) == 2:\n        return parts[0], parts[1]\n    else:\n        raise TooManySplitsError()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_comments(self, page=0):\n        from highton.models.comment import Comment\n        params = {'page': int(page) * self.COMMENT_OFFSET}\n\n        return fields.ListField(\n            name=self.ENDPOINT,\n            init_class=Comment\n        ).decode(\n            self.element_from_string(\n                self._get_request(\n                    endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Comment.ENDPOINT,\n                    params=params\n                ).text\n            )\n        )", "response": "Get the comments of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_status(self, status):\n        assert (status in (HightonConstants.WON, HightonConstants.PENDING, HightonConstants.LOST))\n        from highton.models import Status\n\n        status_obj = Status(name=status)\n        return self._put_request(\n            data=status_obj.element_to_string(status_obj.encode()),\n            endpoint=self.ENDPOINT + '/' + str(self.id) + '/status',\n        )", "response": "Updates the status of the deal\nTaxonomy."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dict_merge(s, m):\n    if not isinstance(m, dict):\n        return m\n    out = copy.deepcopy(s)\n    for k, v in m.items():\n        if k in out and isinstance(out[k], dict):\n            out[k] = dict_merge(out[k], v)\n        else:\n            out[k] = copy.deepcopy(v)\n    return out", "response": "Recursively merge one dict into another."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef settings(instance):\n    with open(instance.root_dir + '/Config/config.yml') as config:\n        config = yaml.load(config)\n        instance.name = config['name']\n        instance.port = config['web']['port']\n        # default host\n        instance.host = \"http://localhost\"\n        if 'host' in config['web']:\n            instance.host = config['web']['host']\n        instance.debug = config['debug']\n    return instance", "response": "Definition to set settings from config file to the app instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating url and replaces regex and gives variables", "response": "def uri_creator(uri, regex, defaults):\n    \"\"\"Creates url and replaces regex and gives variables\"\"\"\n\n    # strip trailing slash\n    uri = uri.strip('/')\n\n    # take out variables in uri\n    matches = re.findall('{[a-zA-Z0-9\\_]+}', uri)\n    default_regex = '[a-zA-Z0-9]+'\n    \n    variables = []\n\n    # iter through matches and replace it with user given regex \\\n    # if not present, then replace it with default regex\n    for match in matches:\n        variable = re.sub(\"{|}\", \"\", match)\n\n        # replace the variable with regex\n        set_regex = default_regex\n        if variable in regex:\n            set_regex = regex[variable]\n        \n        # set default\n        if variable in defaults:\n            set_regex = set_regex + \"|\"\n\n        variables.append(variable)\n        \n        uri = uri.replace(match, \"(\" + set_regex + \")\")\n        \n    # debug, put a ^ starts and $ ends with for exact matching\n    uri = '^' + uri + '$'\n    return {\n        'variables' : variables,\n        'uri'       : uri\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(cls, object_id):\n        return fields.ObjectField(name=cls.ENDPOINT, init_class=cls).decode(\n            cls.element_from_string(\n                cls._get_request(endpoint=cls.ENDPOINT + '/' + str(object_id)).text\n            )\n        )", "response": "Get a single object from the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cached_unless_authenticated(timeout=50, key_prefix='default'):\n    def caching(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            cache_fun = current_cache.cached(\n                timeout=timeout, key_prefix=key_prefix,\n                unless=lambda: current_cache_ext.is_authenticated_callback())\n            return cache_fun(f)(*args, **kwargs)\n        return wrapper\n    return caching", "response": "Decorator for caching anonymous traffic."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def reset(self):\n        params = {\n                'include_participants': 1 if AUTO_GET_PARTICIPANTS else 0,\n                'include_matches': 1 if AUTO_GET_MATCHES else 0\n            }\n        res = await self.connection('POST', 'tournaments/{}/reset'.format(self._id), **params)\n        self._refresh_from_json(res)", "response": "Reset the tournament on Challonge."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the tournament s attributes.", "response": "async def update(self, **params):\n        \"\"\" update some parameters of the tournament\n\n        Use this function if you want to update multiple options at once, but prefer helpers functions like :func:`allow_attachments`, :func:`set_start_date`...\n\n        |methcoro|\n\n        Args:\n            params: one or more of: ``name`` ``tournament_type`` ``url`` ``subdomain`` ``description`` ``open_signup``\n                                    ``hold_third_place_match`` ``pts_for_match_win`` ``pts_for_match_tie`` ``pts_for_game_win``\n                                    ``pts_for_game_tie`` ``pts_for_bye`` ``swiss_rounds`` ``ranked_by`` ``rr_pts_for_match_win``\n                                    ``rr_pts_for_match_tie`` ``rr_pts_for_game_win`` ``rr_pts_for_game_tie`` ``accept_attachments``\n                                    ``hide_forum`` ``show_rounds`` ``private`` ``notify_users_when_matches_open``\n                                    ``notify_users_when_the_tournament_ends`` ``sequential_pairings`` ``signup_cap``\n                                    ``start_at`` ``check_in_duration`` ``grand_finals_modifier``\n\n        Raises:\n            APIException\n\n        \"\"\"\n        assert_or_raise(all(k in self._update_parameters for k in params.keys()),\n                        NameError,\n                        'Wrong parameter given')\n\n        res = await self.connection('PUT',\n                                    'tournaments/{}'.format(self._id),\n                                    'tournament',\n                                    **params)\n        self._refresh_from_json(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the start date of the tournament", "response": "async def set_start_date(self, date: str, time: str, check_in_duration: int = None):\n        \"\"\" set the tournament start date (and check in duration)\n\n        |methcoro|\n\n        Args:\n            date: fomatted date as YYYY/MM/DD (2017/02/14)\n            time: fromatted time as HH:MM (20:15)\n            check_in_duration (optional): duration in minutes\n\n        Raises:\n            APIException\n\n        \"\"\"\n        date_time = datetime.strptime(date + ' ' + time, '%Y/%m/%d %H:%M')\n        res = await self.connection('PUT',\n                                    'tournaments/{}'.format(self._id),\n                                    'tournament',\n                                    start_at=date_time,\n                                    check_in_duration=check_in_duration or 0)\n        self._refresh_from_json(res)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def update_notifications(self, on_match_open: bool = None, on_tournament_end: bool = None):\n        params = {}\n        if on_match_open is not None:\n            params['notify_users_when_matches_open'] = on_match_open\n        if on_tournament_end is not None:\n            params['notify_users_when_the_tournament_ends'] = on_tournament_end\n        assert_or_raise(len(params) > 0, ValueError, 'At least one of the notifications must be given')\n        await self.update(**params)", "response": "Update the participants notifications for this tournament"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_participant(self, p_id: int, force_update=False) -> Participant:\n        found_p = self._find_participant(p_id)\n        if force_update or found_p is None:\n            await self.get_participants()\n            found_p = self._find_participant(p_id)\n        return found_p", "response": "get a participant by its id |methcoro|"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_participants(self, force_update=False) -> list:\n        if force_update or self.participants is None:\n            res = await self.connection('GET', 'tournaments/{}/participants'.format(self._id))\n            self._refresh_participants_from_json(res)\n        return self.participants or []", "response": "get all participants\n\n        |methcoro|\n\n        Args:\n            force_update (default=False): True to force an update to the Challonge API\n\n        Returns:\n            list[Participant]:\n\n        Raises:\n            APIException"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def search_participant(self, name, force_update=False):\n        if force_update or self.participants is None:\n            await self.get_participants()\n        if self.participants is not None:\n            for p in self.participants:\n                if p.name == name:\n                    return p\n        return None", "response": "Search a participant by display name |methcoro|"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a participant to the tournament.", "response": "async def add_participant(self, display_name: str = None, username: str = None, email: str = None, seed: int = 0, misc: str = None, **params):\n        \"\"\" add a participant to the tournament\n\n        |methcoro|\n\n        Args:\n            display_name: The name displayed in the bracket/schedule - not required if email or challonge_username is provided. Must be unique per tournament.\n            username: Provide this if the participant has a Challonge account. He or she will be invited to the tournament.\n            email: Providing this will first search for a matching Challonge account. If one is found, this will have the same effect as the \"challonge_username\" attribute. If one is not found, the \"new-user-email\" attribute will be set, and the user will be invited via email to create an account.\n            seed: The participant's new seed. Must be between 1 and the current number of participants (including the new record). Overwriting an existing seed will automatically bump other participants as you would expect.\n            misc: Max: 255 characters. Multi-purpose field that is only visible via the API and handy for site integration (e.g. key to your users table)\n            params: optional params (see http://api.challonge.com/v1/documents/participants/create)\n\n        Returns:\n            Participant: newly created participant\n\n        Raises:\n            APIException\n\n        \"\"\"\n        assert_or_raise((display_name is None) ^ (username is None),\n                        ValueError,\n                        'One of display_name or username must not be None')\n\n        params.update({\n            'name': display_name or '',\n            'challonge_username': username or '',\n        })\n        if email is not None:\n            params.update({'email': email})\n        if seed != 0:\n            params.update({'seed': seed})\n        if misc is not None:\n            params.update({'misc': misc})\n        res = await self.connection('POST',\n                                    'tournaments/{}/participants'.format(self._id),\n                                    'participant',\n                                    **params)\n        new_p = self._create_participant(res)\n        self._add_participant(new_p)\n        return new_p"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a participant from the tournament", "response": "async def remove_participant(self, p: Participant):\n        \"\"\" remove a participant from the tournament\n\n        |methcoro|\n\n        Args:\n            p: the participant to remove\n\n        Raises:\n            APIException\n\n        \"\"\"\n        await self.connection('DELETE', 'tournaments/{}/participants/{}'.format(self._id, p._id))\n        if p in self.participants:\n            self.participants.remove(p)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a single match by id |methcoro|", "response": "async def get_match(self, m_id, force_update=False) -> Match:\n        \"\"\" get a single match by id\n\n        |methcoro|\n\n        Args:\n            m_id: match id\n            force_update (default=False): True to force an update to the Challonge API\n\n        Returns:\n            Match\n\n        Raises:\n            APIException\n\n        \"\"\"\n        found_m = self._find_match(m_id)\n        if force_update or found_m is None:\n            await self.get_matches()\n            found_m = self._find_match(m_id)\n        return found_m"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def get_matches(self, force_update=False) -> list:\n        if force_update or self.matches is None:\n            res = await self.connection('GET',\n                                        'tournaments/{}/matches'.format(self._id),\n                                        include_attachments=1)\n            self._refresh_matches_from_json(res)\n        return self.matches or []", "response": "get all matches (once the tournament is started)\n\n        |methcoro|\n\n        Args:\n            force_update (default=False): True to force an update to the Challonge API\n\n        Returns:\n            list[Match]:\n\n        Raises:\n            APIException"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshuffling participants' seeds |methcoro| Note: |from_api| Randomize seeds among participants. Only applicable before a tournament has started. Raises: APIException", "response": "async def shuffle_participants(self):\n        \"\"\" Shuffle participants' seeds\n\n        |methcoro|\n\n        Note:\n            |from_api| Randomize seeds among participants. Only applicable before a tournament has started.\n\n        Raises:\n            APIException\n\n        \"\"\"\n        res = await self.connection('POST', 'tournaments/{}/participants/randomize'.format(self._id))\n        self._refresh_participants_from_json(res)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinalizing the check - in phase.", "response": "async def process_check_ins(self):\n        \"\"\" finalize the check in phase\n\n        |methcoro|\n\n        Warning:\n            |unstable|\n\n        Note:\n            |from_api| This should be invoked after a tournament's check-in window closes before the tournament is started.\n            1. Marks participants who have not checked in as inactive.\n            2. Moves inactive participants to bottom seeds (ordered by original seed).\n            3. Transitions the tournament state from 'checking_in' to 'checked_in'\n            NOTE: Checked in participants on the waiting list will be promoted if slots become available.\n\n        Raises:\n            APIException\n\n        \"\"\"\n        params = {\n                'include_participants': 1,  # forced to 1 since we need to update the Participant instances\n                'include_matches': 1 if AUTO_GET_MATCHES else 0\n            }\n        res = await self.connection('POST', 'tournaments/{}/process_check_ins'.format(self._id), **params)\n        self._refresh_from_json(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_final_ranking(self) -> OrderedDict:\n        if self._state != TournamentState.complete.value:\n            return None\n\n        ranking = {}\n        for p in self.participants:\n            if p.final_rank in ranking:\n                ranking[p.final_rank].append(p)\n            else:\n                ranking[p.final_rank] = [p]\n\n        return OrderedDict(sorted(ranking.items(), key=lambda t: t[0]))", "response": "Get the ordered players ranking\n           Folders"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, timeout = 0):\r\n        ptimeout = float(\r\n            timeout.microseconds/1000000+timeout.seconds if timeout\r\n            else (self.resolution if timeout is None else 0)\r\n        )\r\n        if self.tokens:\r\n            events = self.kcontrol(None, self.default_size, ptimeout)\r\n            len_events = len(events)-1\r\n            for nr, ev in enumerate(events):\r\n                fd = ev.ident\r\n                act = self.shadow.pop(fd)\r\n\r\n                if ev.flags & KQ_EV_ERROR:\r\n                    self.kcontrol((kevent(fd, act.flags, KQ_EV_DELETE),), 0)\r\n                    self.handle_error_event(act, 'System error %s.'%ev.data)\r\n                else:\r\n                    if nr == len_events:\r\n                        ret = self.yield_event(act)\r\n                        if not ret:\r\n                            ev.flags = KQ_EV_ADD | KQ_EV_ONESHOT\r\n                            self.kcontrol((ev,), 0)\r\n                            self.shadow[fd] = act\r\n                        return ret\r\n                    else:\r\n                        if not self.handle_event(act):\r\n                            ev.flags = KQ_EV_ADD | KQ_EV_ONESHOT\r\n                            self.kcontrol((ev,), 0)\r\n                            self.shadow[fd] = act\r\n        else:\r\n            sleep(timeout)", "response": "Run a proactor loop and return new socket events."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_xhtml(path, dirs, files):\r\n    # Prepare the path to display.\r\n    if path != '/':\r\n        dirs.insert(0, '..')\r\n    if not path.endswith('/'):\r\n        path += '/'\r\n\r\n    def itemize(item):\r\n        return '<a href=\"%s\">%s</a>' % (item, path+item)\r\n    dirs = [d + '/' for d in dirs]\r\n    return \"\"\"\r\n    <html>\r\n     <body>\r\n      <h1>%s</h1>\r\n       <pre>%s\\n%s</pre>\r\n     </body>\r\n    </html>\r\n    \"\"\" % (path, '\\n'.join(itemize(dir) for dir in dirs), '\\n'.join(itemize(file) for file in files))", "response": "Generate an XHTML document listing the directories and files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn sorted lists of directories and files in the given path.", "response": "def get_entries(path):\r\n    \"\"\"Return sorted lists of directories and files in the given path.\"\"\"\r\n    dirs, files = [], []\r\n    for entry in os.listdir(path):\r\n        # Categorize entry as directory or file.\r\n        if os.path.isdir(os.path.join(path, entry)):\r\n            dirs.append(entry)\r\n        else:\r\n            files.append(entry)\r\n    dirs.sort()\r\n    files.sort()\r\n    return dirs, files"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _conditions(self, full_path, environ):\r\n        mtime = os.stat(full_path).st_mtime\r\n        size = os.stat(full_path).st_size\r\n        return str(mtime), rfc822.formatdate(mtime), size", "response": "Return a tuple of etag last_modified by mtime from stat."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates successive hashes for a set of time - domain audio peaks.", "response": "def hashes(peaks, f_width=F_WIDTH, t_gap=ROWS_PER_SECOND, t_width=2*ROWS_PER_SECOND):\n    \"\"\"\n    Generator function for successive hashes calculated from a mono-channel\n    time-domain audio signal as a set of tuples, (<long>, <int>). The <long>\n    is an integral 64-bit hash so it can be used as a database ID, and\n    the <int> is the frame number associated with the beginning of\n    the time bin for the anchor point.\n\n    The frequency window of each peak for constellation is +/- 1 octave\n\n    Time gap and width recommendations:\n\n    To calculate N seconds in rows (DTFT time windows):\n        rows = N * (1 + (FREQ - FRAME_WIDTH) // FRAME_STRIDE)\n\n    \"\"\"\n    for i, (t1, f1) in enumerate(peaks):\n\n        # limit constellations to a window -- a box constrained by a min\n        # and max time limit, and a min and max frequency bound\n        t_min = t1 + t_gap\n        t_max = t_min + t_width\n        f_min = f1 - f_width // 2\n        f_max = f1 + f_width // 2\n\n        for t2, f2 in peaks[i:]:\n            if t2 < t_min or f2 < f_min:\n                continue\n            elif t2 > t_max:\n                break\n            elif f2 < f_max:\n                yield (_get_hash(f1, f2, t2 - t1), t1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef spectrogram(t_signal, frame_width=FRAME_WIDTH, overlap=FRAME_STRIDE):\n    frame_width = min(t_signal.shape[0], frame_width)\n    w = np.hanning(frame_width)\n    num_components = frame_width // 2 + 1\n    num_frames = 1 + (len(t_signal) - frame_width) // overlap\n\n    f_signal = np.empty([num_frames, num_components], dtype=np.complex_)\n    for i, t in enumerate(range(0, len(t_signal) - frame_width, overlap)):\n        # using rfft avoids computing negative frequency components\n        f_signal[i] = rfft(w * t_signal[t:t + frame_width])\n\n    # amplitude in decibels\n    return 20 * np.log10(1 + np.absolute(f_signal))", "response": "Calculate the magnitude spectrogram of a single - channel time - domain signal."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_hash(f1, f2, dt):\n    return ((long(f1) & 0xffff) << 48 |\n            (long(f2) & 0xffff) << 32 |\n            (long(dt) & 0x3fff))", "response": "Calculate a 64 - bit integral hash from f1 f2 dt."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _extract_peaks(specgram, neighborhood, threshold):\n    kernel = np.ones(shape=neighborhood)\n    local_averages = convolve(specgram, kernel / kernel.sum(), mode=\"constant\", cval=0)\n\n    # suppress all points below the floor value\n    floor = (1 + threshold) * local_averages\n    candidates = np.where(specgram > floor, specgram, 0)\n\n    # grayscale dilation is equivalent to non-maximal suppression\n    local_maximums = grey_dilation(candidates, footprint=kernel)\n    peak_coords = np.argwhere(specgram == local_maximums)\n    peaks = zip(peak_coords[:, 0], peak_coords[:, 1])\n\n    return peaks", "response": "Partition the spectrogram into subcells and extract peaks from each cell."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a collection of records by table name", "response": "def list(self,table, **kparams):\n        \"\"\"\n        get a collection of records by table name.\n        returns a dict (the json map) for python 3.4\n        \"\"\"\n        result = self.table_api_get(table, **kparams)\n        return self.to_records(result, table)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self,table, sys_id, **kparams):\n        result = self.table_api_put(table, sys_id, **kparams)\n        return self.to_record(result, table)", "response": "update a single record by table name and sys_id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a single record by table name and sys_id", "response": "def get(self,table, sys_id):\n        \"\"\"\n        get a single record by table name and sys_id\n        returns a dict (the json map) for python 3.4\n        \"\"\"\n        result = self.table_api_get(table, sys_id)\n        return self.to_record(result, table)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef req(self, meth, url, http_data=''):\n        self.logger.debug(\"Making request: %s %s\\nBody:%s\" % (meth, url, http_data))\n        req_method = getattr(requests, meth)\n        return (req_method(url,\n                           auth=(self.__username, self.__password),\n                           data=http_data,\n                           headers=({'user-agent': self.user_agent(), 'Accept': 'application/json'})))", "response": "sugar that wraps the requests module with basic auth and some headers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_agent(self):\n        version = \"\"\n        project_root = os.path.dirname(os.path.abspath(__file__))\n        with open(os.path.join(project_root, 'VERSION')) as version_file:\n            version = version_file.read().strip()\n\n        return \"Python Snow Api Client (Version %s)\" % version", "response": "returns the user agent string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves the links and return a list of SnowRecords.", "response": "def resolve_links(self, snow_record, **kparams):\n        \"\"\"\n        Get the infos from the links and return SnowRecords[].\n        \"\"\"\n        records = []\n        for attr, link in snow_record.links().items():\n            records.append(self.resolve_link(snow_record, attr, **kparams))\n        return records"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resolve_link(self, snow_record, field_to_resolve, **kparams):\n        try:\n          link = snow_record.links()[field_to_resolve]\n        except KeyError as e:\n          return SnowRecord.NotFound(self, snow_record._table_name, \"Could not find field %s in record\" % field_to_resolve, [snow_record, field_to_resolve, self])\n\n        if kparams:\n            link += ('&', '?')[urlparse(link).query == '']\n            link += '&'.join(\"%s=%s\" % (key,val) for (key,val) in kparams.items())\n        linked_response = self.req(\"get\", link) # rety here...\n\n        rjson = linked_response.json()\n        rtablename = SnowRecord.tablename_from_link(link)\n\n        # could do this, but better to not mutate:\n        # setattr(snow_record, field_to_resolve, linked)\n        # so just return new record. could infer\n\n        if \"result\" in rjson:\n            linked = SnowRecord(self, rtablename, **rjson[\"result\"])\n        else:\n            linked = SnowRecord.NotFound(self, rtablename, \"Could not resolve link %s\" % link, [rjson, rtablename, link, self])\n\n        return linked", "response": "Resolve a link to a SnowRecord."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the Hightonmodel to a serializable value such dicts lists strings", "response": "def to_serializable_value(self):\n        \"\"\"\n        Parses the Hightonmodel to a serializable value such dicts, lists, strings\n        This can be used to save the model in a NoSQL database\n\n        :return: the serialized HightonModel\n        :rtype: dict\n        \"\"\"\n        return_dict = {}\n        for name, field in self.__dict__.items():\n            if isinstance(field, fields.Field):\n                return_dict[name] = field.to_serializable_value()\n        return return_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies Textile conversion to a string and returns the HTML.", "response": "def textile(text, **kwargs):\n    \"\"\"\n    Applies Textile conversion to a string, and returns the HTML.\n    \n    This is simply a pass-through to the ``textile`` template filter\n    included in ``django.contrib.markup``, which works around issues\n    PyTextile has with Unicode strings. If you're not using Django but\n    want to use Textile with ``MarkupFormatter``, you'll need to\n    supply your own Textile filter.\n    \n    \"\"\"\n    from django.contrib.markup.templatetags.markup import textile\n    return textile(text)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restructuredtext(text, **kwargs):\n    from docutils import core\n    parts = core.publish_parts(source=text,\n                               writer_name='html4css1',\n                               **kwargs)\n    return parts['fragment']", "response": "Applies reStructuredText conversion to a string and returns the\n    HTML fragment."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs strongly typed attributes from a dictionary of name and Typed object pairs.", "response": "def _typed_from_items(items):\n    \"\"\"\n    Construct strongly typed attributes (properties) from a dictionary of\n    name and :class:`~exa.typed.Typed` object pairs.\n\n    See Also:\n        :func:`~exa.typed.typed`\n    \"\"\"\n    dct = {}\n    for name, attr in items:\n        if isinstance(attr, Typed):\n            dct[name] = attr(name)\n    return dct"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclass decorator that updates a class definition with strongly typed property attributes. See Also: If the class will be inherited, use :class:`~exa.typed.TypedClass`.", "response": "def typed(cls):\n    \"\"\"\n    Class decorator that updates a class definition with strongly typed\n    property attributes.\n\n    See Also:\n        If the class will be inherited, use :class:`~exa.typed.TypedClass`.\n    \"\"\"\n    for name, attr in _typed_from_items(vars(cls).items()).items():\n        setattr(cls, name, attr)\n    return cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an assignment of type variable names to types that makes this constraint satisfiable or a Refutation", "response": "def reconcile(constraint):\n    '''\n    Returns an assignment of type variable names to\n    types that makes this constraint satisfiable, or a Refutation\n    '''\n    \n    if isinstance(constraint.subtype, NamedType):\n        if isinstance(constraint.supertype, NamedType):\n            if constraint.subtype.name == constraint.supertype.name:\n                return {}\n            else:\n                return Refutation('Cannot reconcile different atomic types: %s' % constraint)\n        elif isinstance(constraint.supertype, Variable):\n            return {constraint.supertype.name: constraint.subtype}\n        else:\n            return Refutation('Cannot reconcile atomic type with non-atomic type: %s' % constraint)\n\n    elif isinstance(constraint.supertype, NamedType):\n        if isinstance(constraint.subtype, NamedType):\n            if constraint.subtype.name == constraint.supertype.name:\n                return {}\n            else:\n                return Refutation('Cannot reconcile different atomic types: %s' % constraint)\n        elif isinstance(constraint.subtype, Variable):\n            return {constraint.subtype.name: constraint.supertype}\n        else:\n            return Refutation('Cannot reconcile non-atomic type with atomic type: %s' % constraint)\n\n    elif isinstance(constraint.supertype, Union):\n        # Lots of stuff could happen here; unsure if there's research to bring to bear\n        if constraint.subtype in constraint.supertype.types:\n            return {}\n\n    return Stumper(constraint)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prnt(self):\n        print(\"= = = =\\n\\n%s object key: \\033[32m%s\\033[0m\" % (self.__class__.__name__, self.key))\n        pprnt(self._data or self.clean_value())", "response": "Prints the DB data representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_choices_for(self, field):\n        choices = self._fields[field].choices\n        if isinstance(choices, six.string_types):\n            return [(d['value'], d['name']) for d in self._choices_manager.get_all(choices)]\n        else:\n            return choices", "response": "Returns the choices for the given fields."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfill the object s fields with given data dict.", "response": "def set_data(self, data, from_db=False):\n        \"\"\"\n        Fills the object's fields with given data dict.\n        Internally calls the self._load_data() method.\n\n        Args:\n            data (dict): Data to fill object's fields.\n            from_db (bool): if data coming from db then we will\n            use related field type's _load_data method\n\n        Returns:\n            Self. Returns objects itself for chainability.\n        \"\"\"\n        self._load_data(data, from_db)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies the field restrictions based on the context s has_permission method. Returns the list of unpermitted fields.", "response": "def _apply_cell_filters(self, context):\n        \"\"\"\n        Applies the field restrictions based on the\n         return value of the context's \"has_permission()\" method.\n         Stores them on self._unpermitted_fields.\n\n        Returns:\n            List of unpermitted fields names.\n        \"\"\"\n        self.setattrs(_is_unpermitted_fields_set=True)\n        for perm, fields in self.Meta.field_permissions.items():\n            if not context.has_permission(perm):\n                self._unpermitted_fields.extend(fields)\n        return self._unpermitted_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_unpermitted_fields(self):\n        return (self._unpermitted_fields if self._is_unpermitted_fields_set else\n                self._apply_cell_filters(self._context))", "response": "Returns a list of unpermitted field names for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the linked model instance with the given link s field values.", "response": "def _update_new_linked_model(self, internal, linked_mdl_ins, link):\n        \"\"\"\n        Iterates through linked_models of given model instance to match it's\n        \"reverse\" with given link's \"field\" values.\n        \"\"\"\n\n        # If there is a link between two sides (A and B), if a link from A to B,\n        # link should be saved at B but it is not necessary to control again data in A.\n        # If internal field is True, data control is not done and passes.\n        if not internal:\n\n            for lnk in linked_mdl_ins.get_links():\n                mdl = lnk['mdl']\n                if not isinstance(self, mdl) or lnk['reverse'] != link['field']:\n                    continue\n                local_field_name = lnk['field']\n                # remote_name = lnk['reverse']\n                remote_field_name = un_camel(mdl.__name__)\n                if not link['o2o']:\n                    if '.' in local_field_name:\n                        local_field_name, remote_field_name = local_field_name.split('.')\n                    remote_set = getattr(linked_mdl_ins, local_field_name)\n\n                    if remote_set._TYPE == 'ListNode' and self not in remote_set:\n                        remote_set(**{remote_field_name: self._root_node})\n                        if linked_mdl_ins._exists is False:\n                            raise ObjectDoesNotExist('Linked %s on field %s with key %s doesn\\'t exist' % (\n                                linked_mdl_ins.__class__.__name__,\n                                remote_field_name,\n                                linked_mdl_ins.key,\n                            ))\n                        linked_mdl_ins.save(internal=True)\n                else:\n                    linked_mdl_ins.setattr(remote_field_name, self._root_node)\n                    if linked_mdl_ins._exists is False:\n                        raise ObjectDoesNotExist('Linked object %s on field %s with key %s doesn\\'t exist' % (\n                            linked_mdl_ins.__class__.__name__,\n                            remote_field_name,\n                            linked_mdl_ins.key,\n                        ))\n                    linked_mdl_ins.save(internal=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling changed fields between new and old data.", "response": "def _handle_changed_fields(self, old_data):\n        \"\"\"\n        Looks for changed relation fields between new and old data (before/after save).\n        Creates back_link references for updated fields.\n\n        Args:\n            old_data: Object's data before save.\n        \"\"\"\n        for link in self.get_links(is_set=False):\n            fld_id = un_camel_id(link['field'])\n            if not old_data or old_data.get(fld_id) != self._data[fld_id]:\n                # self is new or linked model changed\n                if self._data[fld_id]:  # exists\n                    linked_mdl = getattr(self, link['field'])\n                    self._add_back_link(linked_mdl, link)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reload(self):\n        self._load_data(self.objects.data().filter(key=self.key)[0][0], True)", "response": "Reloads current instance from DB store"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _handle_uniqueness(self):\n\n        def _getattr(u):\n            try:\n                return self._field_values[u]\n            except KeyError:\n                return getattr(self, u)\n\n        if self._uniques:\n            for u in self._uniques:\n                val = _getattr(u)\n                changed_fields = self.changed_fields(from_db=True)\n                if self.exist and not (u in changed_fields if not callable(val) else\n                                       (str(u) + \"_id\") in changed_fields):\n                    if val and self.objects.filter(**{u: val}).count() > 1:\n                        raise IntegrityError(\"Unique mismatch: %s for %s already exists for value: \"\n                                             \"%s\" % (u, self.__class__.__name__, val))\n                else:\n                    if val and self.objects.filter(**{u: val}).count():\n                        raise IntegrityError(\"Unique mismatch: %s for %s already exists for value: \"\n                                             \"%s\" % (u, self.__class__.__name__, val))\n        if self.Meta.unique_together:\n            changed_fields = self.changed_fields(from_db=True)\n            for uniques in self.Meta.unique_together:\n                vals = dict([(u, _getattr(u)) for u in uniques])\n                if self.exist:\n                    query_is_changed = []\n                    for uni in vals.keys():\n                        if callable(vals[uni]):\n                            is_changed = (str(uni) + \"_id\") in changed_fields\n                            query_is_changed.append(is_changed)\n                        else:\n                            is_changed = uni in changed_fields\n                            query_is_changed.append(is_changed)\n                    is_unique_changed = any(query_is_changed)\n                    if not is_unique_changed:\n                        if self.objects.filter(**vals).count() > 1:\n                            raise IntegrityError(\n                                \"Unique together mismatch: %s combination already exists for %s\"\n                                % (vals, self.__class__.__name__))\n                    else:\n                        if self.objects.filter(**vals).count():\n                            raise IntegrityError(\n                                \"Unique together mismatch: %s combination already exists for %s\"\n                                % (vals, self.__class__.__name__))\n                else:\n                    if self.objects.filter(**vals).count():\n                        raise IntegrityError(\n                            \"Unique together mismatch: %s combination already exists for %s\"\n                            % (vals, self.__class__.__name__))", "response": "Checks whether the record is unique and if not raises IntegrityError."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self, internal=False, meta=None, index_fields=None):\n        for f in self.on_save:\n            f(self)\n        if not (internal or self._pre_save_hook_called):\n            self._pre_save_hook_called = True\n            self.pre_save()\n        if not self.deleted:\n            self._handle_uniqueness()\n        if not self.exist:\n            self.pre_creation()\n        old_data = self._data.copy()\n        if self.just_created is None:\n            self.setattrs(just_created=not self.exist)\n        if self._just_created is None:\n            self.setattrs(_just_created=self.just_created)\n        self.objects.save_model(self, meta_data=meta, index_fields=index_fields)\n        self._handle_changed_fields(old_data)\n        self._process_relations(internal)\n        if not (internal or self._post_save_hook_called):\n            self._post_save_hook_called = True\n            self.post_save()\n            if self._just_created:\n                self.setattrs(just_created=self._just_created,\n                              _just_created=False)\n                self.post_creation()\n        self._pre_save_hook_called = False\n        self._post_save_hook_called = False\n        if not internal:\n            self._initial_data = self.clean_value()\n        return self", "response": "Save s object to DB."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef changed_fields(self, from_db=False):\n        if self.exist:\n            current_dict = self.clean_value()\n            # `from_db` attr is set False as default, when a `ListNode` is\n            # initialized just after above `clean_value` is called. `from_db` flags\n            # in 'list node sets' makes differences between clean_data and object._data.\n\n            db_data = self._initial_data\n            if from_db:\n                # Thus, after clean_value, object's data is taken from db again.\n                db_data = self.objects.data().get(self.key)[0]\n\n            set_current, set_past = set(current_dict.keys()), set(db_data.keys())\n            intersect = set_current.intersection(set_past)\n            return set(o for o in intersect if db_data[o] != current_dict[o])", "response": "Returns a list of fields names which their values changed in the object s data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_changed(self, field, from_db=False):\n        return field in self.changed_fields(from_db=from_db)", "response": "Checks if given fields value is changed against actual db data\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blocking_save(self, query_dict=None, meta=None, index_fields=None):\n        query_dict = query_dict or {}\n        for query in query_dict:\n            self.setattr(query, query_dict[query])\n\n        self.save(meta=meta, index_fields=index_fields)\n        while not self.objects.filter(key=self.key, **query_dict).count():\n            time.sleep(0.3)\n        return self", "response": "Saves object to DB."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete and waits till the backend properly update indexes for just deleted object.", "response": "def blocking_delete(self, meta=None, index_fields=None):\n        \"\"\"\n        Deletes and waits till the backend properly update indexes for just deleted object.\n        meta (dict): JSON serializable meta data for logging of save operation.\n            {'lorem': 'ipsum', 'dolar': 5}\n        index_fields (list): Tuple list for indexing keys in riak (with 'bin' or 'int').\n            bin is used for string fields, int is used for integer fields.\n            [('lorem','bin'),('dolar','int')]\n        \"\"\"\n        self.delete(meta=meta, index_fields=index_fields)\n        while self.objects.filter(key=self.key).count():\n            time.sleep(0.3)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, dry=False, meta=None, index_fields=None):\n        from datetime import datetime\n        # TODO: Make sure this works safely (like a sql transaction)\n        if not dry:\n            self.pre_delete()\n        results, errors = self._delete_relations(dry)\n        if not (dry or errors):\n            self.deleted = True\n            self.deleted_at = datetime.now()\n            self.save(internal=True, meta=meta, index_fields=index_fields)\n            self.post_delete()\n            if settings.ENABLE_CACHING:\n                cache.delete(self.key)\n        return results, errors", "response": "Delete the object from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclipping value to range [ minimum maximum )", "response": "def __clip(val, minimum, maximum):\n        \"\"\"\n        \n        :param val: input value \n        :param minimum: min value\n        :param maximum: max value\n        :return: val clipped to range [minimum, maximum]\n        \"\"\"\n        if val is None or minimum is None or maximum is None:\n            return None\n        if val < minimum:\n            return minimum\n        if val > maximum:\n            return maximum\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrecognize a node that we expect to be a scalar.", "response": "def __recognize_scalar(self, node: yaml.Node,\n                           expected_type: Type) -> RecResult:\n        \"\"\"Recognize a node that we expect to be a scalar.\n\n        Args:\n            node: The node to recognize.\n            expected_type: The type it is expected to be.\n\n        Returns:\n            A list of recognized types and an error message\n        \"\"\"\n        logger.debug('Recognizing as a scalar')\n        if (isinstance(node, yaml.ScalarNode)\n                and node.tag == scalar_type_to_tag[expected_type]):\n            return [expected_type], ''\n        message = 'Failed to recognize a {}\\n{}\\n'.format(\n            type_to_desc(expected_type), node.start_mark)\n        return [], message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrecognize a node that we expect to be a list of some kind.", "response": "def __recognize_list(self, node: yaml.Node,\n                         expected_type: Type) -> RecResult:\n        \"\"\"Recognize a node that we expect to be a list of some kind.\n\n        Args:\n            node: The node to recognize.\n            expected_type: List[...something...]\n\n        Returns\n            expected_type and the empty string if it was recognized,\n                    [] and an error message otherwise.\n        \"\"\"\n        logger.debug('Recognizing as a list')\n        if not isinstance(node, yaml.SequenceNode):\n            message = '{}{}Expected a list here.'.format(\n                node.start_mark, os.linesep)\n            return [], message\n        item_type = generic_type_args(expected_type)[0]\n        for item in node.value:\n            recognized_types, message = self.recognize(item, item_type)\n            if len(recognized_types) == 0:\n                return [], message\n            if len(recognized_types) > 1:\n                recognized_types = [\n                    List[t]  # type: ignore\n                    for t in recognized_types\n                ]\n                return recognized_types, message\n\n        return [expected_type], ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __recognize_dict(self, node: yaml.Node,\n                         expected_type: Type) -> RecResult:\n        \"\"\"Recognize a node that we expect to be a dict of some kind.\n\n        Args:\n            node: The node to recognize.\n            expected_type: Dict[str, ...something...]\n\n        Returns:\n            expected_type if it was recognized, [] otherwise.\n        \"\"\"\n        logger.debug('Recognizing as a dict')\n        if not issubclass(generic_type_args(expected_type)[0], str):\n            raise RuntimeError(\n                'YAtiML only supports dicts with strings as keys')\n        if not isinstance(node, yaml.MappingNode):\n            message = '{}{}Expected a dict/mapping here'.format(\n                node.start_mark, os.linesep)\n            return [], message\n        value_type = generic_type_args(expected_type)[1]\n        for _, value in node.value:\n            recognized_value_types, message = self.recognize(value, value_type)\n            if len(recognized_value_types) == 0:\n                return [], message\n            if len(recognized_value_types) > 1:\n                return [\n                    Dict[str, t]  # type: ignore\n                    for t in recognized_value_types\n                ], message  # type: ignore\n\n        return [expected_type], ''", "response": "Recognize a node that we expect to be a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __recognize_union(self, node: yaml.Node,\n                          expected_type: Type) -> RecResult:\n        \"\"\"Recognize a node that we expect to be one of a union of types.\n\n        Args:\n            node: The node to recognize.\n            expected_type: Union[...something...]\n\n        Returns:\n            The specific type that was recognized, multiple, or none.\n        \"\"\"\n        logger.debug('Recognizing as a union')\n        recognized_types = []\n        message = ''\n        union_types = generic_type_args(expected_type)\n        logger.debug('Union types {}'.format(union_types))\n        for possible_type in union_types:\n            recognized_type, msg = self.recognize(node, possible_type)\n            if len(recognized_type) == 0:\n                message += msg\n            recognized_types.extend(recognized_type)\n        recognized_types = list(set(recognized_types))\n        if bool in recognized_types and bool_union_fix in recognized_types:\n            recognized_types.remove(bool_union_fix)\n\n        if len(recognized_types) == 0:\n            return recognized_types, message\n        elif len(recognized_types) > 1:\n            message = ('{}{}Could not determine which of the following types'\n                       ' this is: {}').format(node.start_mark, os.linesep,\n                                              recognized_types)\n            return recognized_types, message\n\n        return recognized_types, ''", "response": "Recognize a node that we expect to be one of the types expected_type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __recognize_user_class(self, node: yaml.Node,\n                               expected_type: Type) -> RecResult:\n        \"\"\"Recognize a user-defined class in the node.\n\n        This tries to recognize only exactly the specified class. It \\\n        recurses down into the class's attributes, but not to its \\\n        subclasses. See also __recognize_user_classes().\n\n        Args:\n            node: The node to recognize.\n            expected_type: A user-defined class.\n\n        Returns:\n            A list containing the user-defined class, or an empty list.\n        \"\"\"\n        logger.debug('Recognizing as a user-defined class')\n        loc_str = '{}{}'.format(node.start_mark, os.linesep)\n        if hasattr(expected_type, 'yatiml_recognize'):\n            try:\n                unode = UnknownNode(self, node)\n                expected_type.yatiml_recognize(unode)\n                return [expected_type], ''\n            except RecognitionError as e:\n                if len(e.args) > 0:\n                    message = ('Error recognizing a {}\\n{}because of the'\n                               ' following error(s): {}').format(\n                                   expected_type.__class__, loc_str,\n                                   indent(e.args[0], '    '))\n                else:\n                    message = 'Error recognizing a {}\\n{}'.format(\n                        expected_type.__class__, loc_str)\n                return [], message\n        else:\n            if issubclass(expected_type, enum.Enum):\n                if (not isinstance(node, yaml.ScalarNode)\n                        or node.tag != 'tag:yaml.org,2002:str'):\n                    message = 'Expected an enum value from {}\\n{}'.format(\n                        expected_type.__class__, loc_str)\n                    return [], message\n            elif (issubclass(expected_type, UserString)\n                  or issubclass(expected_type, str)):\n                if (not isinstance(node, yaml.ScalarNode)\n                        or node.tag != 'tag:yaml.org,2002:str'):\n                    message = 'Expected a string matching {}\\n{}'.format(\n                        expected_type.__class__, loc_str)\n                    return [], message\n            else:\n                # auto-recognize based on constructor signature\n                if not isinstance(node, yaml.MappingNode):\n                    message = 'Expected a dict/mapping here\\n{}'.format(\n                        loc_str)\n                    return [], message\n\n                for attr_name, type_, required in class_subobjects(\n                        expected_type):\n                    cnode = Node(node)\n                    # try exact match first, dashes if that doesn't match\n                    for name in [attr_name, attr_name.replace('_', '-')]:\n                        if cnode.has_attribute(name):\n                            subnode = cnode.get_attribute(name)\n                            recognized_types, message = self.recognize(\n                                subnode.yaml_node, type_)\n                            if len(recognized_types) == 0:\n                                message = ('Failed when checking attribute'\n                                           ' {}:\\n{}').format(\n                                               name, indent(message, '    '))\n                                return [], message\n                            break\n                    else:\n                        if required:\n                            message = (\n                                'Error recognizing a {}\\n{}because it'\n                                ' is missing an attribute named {}').format(\n                                    expected_type.__name__, loc_str, attr_name)\n                            if '_' in attr_name:\n                                message += ' or maybe {}.\\n'.format(\n                                    attr_name.replace('_', '-'))\n                            else:\n                                message += '.\\n'\n                            return [], message\n\n            return [expected_type], ''", "response": "Recognize a user - defined class in the node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrecognize a user - defined class in the node.", "response": "def __recognize_user_classes(self, node: yaml.Node,\n                                 expected_type: Type) -> RecResult:\n        \"\"\"Recognize a user-defined class in the node.\n\n        This returns a list of classes from the inheritance hierarchy \\\n        headed by expected_type which match the given node and which \\\n        do not have a registered derived class that matches the given \\\n        node. So, the returned classes are the most derived matching \\\n        classes that inherit from expected_type.\n\n        This function recurses down the user's inheritance hierarchy.\n\n        Args:\n            node: The node to recognize.\n            expected_type: A user-defined class.\n\n        Returns:\n            A list containing matched user-defined classes.\n        \"\"\"\n        # Let the user override with an explicit tag\n        if node.tag in self.__registered_classes:\n            return [self.__registered_classes[node.tag]], ''\n\n        recognized_subclasses = []\n        message = ''\n        for other_class in self.__registered_classes.values():\n            if expected_type in other_class.__bases__:\n                sub_subclasses, msg = self.__recognize_user_classes(\n                    node, other_class)\n                recognized_subclasses.extend(sub_subclasses)\n                if len(sub_subclasses) == 0:\n                    message += msg\n\n        if len(recognized_subclasses) == 0:\n            recognized_subclasses, msg = self.__recognize_user_class(\n                node, expected_type)\n            if len(recognized_subclasses) == 0:\n                message += msg\n\n        if len(recognized_subclasses) == 0:\n            message = ('Failed to recognize a {}\\n{}\\nbecause of the following'\n                       ' error(s):\\n{}').format(expected_type.__name__,\n                                                node.start_mark,\n                                                indent(msg, '    '))\n            return [], message\n\n        if len(recognized_subclasses) > 1:\n            message = ('{}{} Could not determine which of the following types'\n                       ' this is: {}').format(node.start_mark, os.linesep,\n                                              recognized_subclasses)\n            return recognized_subclasses, message\n\n        return recognized_subclasses, ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef recognize(self, node: yaml.Node, expected_type: Type) -> RecResult:\n        logger.debug('Recognizing {} as a {}'.format(node, expected_type))\n        recognized_types = None\n        if expected_type in [\n                str, int, float, bool, bool_union_fix, datetime, None,\n                type(None)\n        ]:\n            recognized_types, message = self.__recognize_scalar(\n                node, expected_type)\n        elif is_generic_union(expected_type):\n            recognized_types, message = self.__recognize_union(\n                node, expected_type)\n        elif is_generic_list(expected_type):\n            recognized_types, message = self.__recognize_list(\n                node, expected_type)\n        elif is_generic_dict(expected_type):\n            recognized_types, message = self.__recognize_dict(\n                node, expected_type)\n        elif expected_type in self.__registered_classes.values():\n            recognized_types, message = self.__recognize_user_classes(\n                node, expected_type)\n\n        if recognized_types is None:\n            raise RecognitionError(\n                ('Could not recognize for type {},'\n                 ' is it registered?').format(expected_type))\n        logger.debug('Recognized types {} matching {}'.format(\n            recognized_types, expected_type))\n        return recognized_types, message", "response": "Recognize a node and return a list of types that match the expected type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_info(ctx, info):\n    head = ctx.parent.head\n    vcf_handle = ctx.parent.handle\n    outfile = ctx.parent.outfile\n    silent = ctx.parent.silent\n    \n    if not info:\n        logger.error(\"No info provided\")\n        sys.exit(\"Please provide a info string\")\n    \n    if not info in head.info_dict:\n        logger.error(\"Info '{0}' is not specified in vcf header\".format(info))\n        sys.exit(\"Please provide a valid info field\")\n    \n    head.remove_header(info)\n    \n    print_headers(head, outfile=outfile, silent=silent)\n    \n    for line in vcf_handle:\n        line = line.rstrip()\n        new_line = remove_vcf_info(keyword=info, variant_line=line)\n        print_variant(variant_line=new_line, outfile=outfile, silent=silent)", "response": "Delete a info field from all variants in a vcf"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint the variants in a vcf", "response": "def variants(ctx, snpeff):\n    \"\"\"Print the variants in a vcf\"\"\"\n    head = ctx.parent.head\n    vcf_handle = ctx.parent.handle\n    outfile = ctx.parent.outfile\n    silent = ctx.parent.silent\n    \n    print_headers(head, outfile=outfile, silent=silent)\n    \n    for line in vcf_handle:\n        print_variant(variant_line=line, outfile=outfile, silent=silent)\n        if snpeff:\n            variant_dict =  get_variant_dict(\n                variant_line = line,\n                header_line = head.header\n            )\n            #Create a info dict:\n            info_dict = get_info_dict(\n                info_line = variant_dict['INFO']\n            )\n            snpeff_string = info_dict.get('ANN')\n\n            if snpeff_string:\n                #Get the snpeff annotations\n                snpeff_info = get_snpeff_info(\n                    snpeff_string = snpeff_string,\n                    snpeff_header = head.snpeff_columns\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsort the variants of a vcf file", "response": "def sort(ctx):\n    \"\"\"Sort the variants of a vcf file\"\"\"\n    head = ctx.parent.head\n    vcf_handle = ctx.parent.handle\n    outfile = ctx.parent.outfile\n    silent = ctx.parent.silent\n\n    print_headers(head, outfile=outfile, silent=silent)\n\n    for line in sort_variants(vcf_handle):\n        print_variant(variant_line=line, outfile=outfile, silent=silent)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates response from OpenID server.", "response": "def validate(self, request, data):\n        \"\"\"\n        Validate response from OpenID server.\n        Set identity in case of successfull validation.\n        \"\"\"\n        client = consumer.Consumer(request.session, None)\n\n        try:\n            resp = client.complete(data, request.session['openid_return_to'])\n        except KeyError:\n            messages.error(request, lang.INVALID_RESPONSE_FROM_OPENID)\n            return redirect('netauth-login')\n        if resp.status == consumer.CANCEL:\n            messages.warning(request, lang.OPENID_CANCELED)\n            return redirect('netauth-login')\n        elif resp.status == consumer.FAILURE:\n            messages.error(request, lang.OPENID_FAILED % resp.message)\n            return redirect('netauth-login')\n        elif resp.status == consumer.SUCCESS:\n            self.identity = resp.identity_url\n            del request.session['openid_return_to']\n            return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use(self, plugin, arguments={}):\n    self.plugins[plugin] = dict(arguments)\n    return self.plugins", "response": "Add plugin to use during compilation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompiling stylus into css", "response": "def compile(self, source, options={}):\n    \"\"\"Compile stylus into css\n\n    source: A string containing the stylus code\n    options: A dictionary of arguments to pass to the compiler\n\n    Returns a string of css resulting from the compilation\n    \"\"\"\n    options = dict(options)\n    if \"paths\" in options:\n      options[\"paths\"] += self.paths\n    else:\n      options[\"paths\"] = self.paths\n\n    if \"compress\" not in options:\n      options[\"compress\"] = self.compress\n\n    return self.context.call(\"compiler\", source, options, self.plugins, self.imports)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef context(self):\n    \"Internal property that returns the stylus compiler\"\n    if self._context is None:\n      with io.open(path.join(path.abspath(path.dirname(__file__)), \"compiler.js\")) as compiler_file:\n        compiler_source = compiler_file.read()\n      self._context = self.backend.compile(compiler_source)\n    return self._context", "response": "Internal property that returns the stylus compiler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming an overlapped request and saves the token and the completion key.", "response": "def request_generic(self, act, coro, perform, complete):\r\n        \"\"\"\r\n        Performs an overlapped request (via `perform` callable) and saves\r\n        the token and the (`overlapped`, `perform`, `complete`) trio.\r\n        \"\"\"\r\n        overlapped = OVERLAPPED()\r\n        overlapped.object = act\r\n        self.add_token(act, coro, (overlapped, perform, complete))\r\n\r\n        rc, nbytes = perform(act, overlapped)\r\n        completion_key = c_long(0)\r\n        if rc == 0:\r\n            # ah geez, it didn't got in the iocp, we have a result!\r\n            pass\r\n\r\n\r\n            # ok this is weird, apparently this doesn't need to be requeued\r\n            #  - need to investigate why (TODO)\r\n            #~ PostQueuedCompletionStatus(\r\n                #~ self.iocp, # HANDLE CompletionPort\r\n                #~ nbytes, # DWORD dwNumberOfBytesTransferred\r\n                #~ byref(completion_key), # ULONG_PTR dwCompletionKey\r\n                #~ overlapped # LPOVERLAPPED lpOverlapped\r\n            #~ )\r\n        elif rc != WSA_IO_PENDING:\r\n            self.remove_token(act)\r\n            raise SocketError(rc, \"%s on %r\" % (ctypes.FormatError(rc), act))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall GetQueuedCompletionStatus and handles completion via process_op.", "response": "def run(self, timeout = 0):\r\n        \"\"\"\r\n        Calls GetQueuedCompletionStatus and handles completion via\r\n        process_op.\r\n        \"\"\"\r\n        # same resolution as epoll\r\n        ptimeout = int(\r\n            timeout.days * 86400000 +\r\n            timeout.microseconds / 1000 +\r\n            timeout.seconds * 1000\r\n            if timeout else (self.m_resolution if timeout is None else 0)\r\n        )\r\n        if self.tokens:\r\n            scheduler = self.scheduler\r\n            urgent = None\r\n            # we use urgent as a optimisation: the last operation is returned\r\n            #directly to the scheduler (the sched might just run it till it\r\n            #goes to sleep) and not added in the sched.active queue\r\n            while 1:\r\n                try:\r\n                    poverlapped = LPOVERLAPPED()\r\n                    nbytes = DWORD()\r\n                    completion_key = c_ulong()\r\n                    #~ BOOL WINAPI GetQueuedCompletionStatus(\r\n                      #~ __in   HANDLE CompletionPort,\r\n                      #~ __out  LPDWORD lpNumberOfBytes,\r\n                      #~ __out  PULONG_PTR lpCompletionKey,\r\n                      #~ __out  LPOVERLAPPED *lpOverlapped,\r\n                      #~ __in   DWORD dwMilliseconds\r\n                    #~ );\r\n\r\n                    rc = GetQueuedCompletionStatus(\r\n                        self.iocp, # HANDLE CompletionPort\r\n                        byref(nbytes), # LPDWORD lpNumberOfBytes\r\n                        byref(completion_key), # PULONG_PTR lpCompletionKey\r\n                        byref(poverlapped),\r\n                        0 if urgent else ptimeout\r\n                    )\r\n                    overlap = poverlapped and poverlapped.contents\r\n                    nbytes = nbytes.value\r\n                except RuntimeError, e:\r\n                    import warnings\r\n                    warnings.warn(\"RuntimeError(%s) on GetQueuedCompletionStatus.\" % e)\r\n                    # we will get \"This overlapped object has lost all its\r\n                    # references so was destroyed\" when we remove a operation,\r\n                    # it is garbage collected and the overlapped completes\r\n                    # afterwards\r\n                    break\r\n\r\n                # well, this is a bit weird, if we get a aborted rc (via CancelIo\r\n                #i suppose) evaluating the overlap crashes the interpeter\r\n                #with a memory read error\r\n                # also, we might get a \"wait operation timed out\", and no overlap pointer\r\n                if rc != WSA_OPERATION_ABORTED and overlap:\r\n\r\n                    if urgent:\r\n                        op, coro = urgent\r\n                        urgent = None\r\n                        if op.prio & priority.OP:\r\n                            # imediately run the asociated coroutine step\r\n                            op, coro = scheduler.process_op(\r\n                                coro.run_op(op, scheduler),\r\n                                coro\r\n                            )\r\n                        if coro:\r\n                            #TODO, what \"op and \"\r\n                            if op and (op.prio & priority.CORO):\r\n                                scheduler.active.appendleft( (op, coro) )\r\n                            else:\r\n                                scheduler.active.append( (op, coro) )\r\n                    if overlap.object:\r\n                        assert overlap.object in self.tokens\r\n                        urgent = self.process_op(rc, nbytes, overlap)\r\n                else:\r\n                    #~ import warnings\r\n                    #~ warnings.warn(\"rc=(%s: %s) overlap=(%s)\" % (rc, ctypes.FormatError(rc), overlap))\r\n                    break\r\n            return urgent\r\n        else:\r\n            sleep(timeout)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first header in the data file", "response": "def header(self):\n    '''\n    This returns the first header in the data file\n\n    '''\n    if self._header is None:\n      self._header = self._read_half_frame_header(self.data)\n\n    return self._header"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the bit - packed data extracted from the data file. This method is used to analyze the data file.", "response": "def _packed_data(self):\n    '''\n    Returns the bit-packed data extracted from the data file. This is not so useful to analyze.\n    Use the complex_data method instead.\n    '''\n    header = self.header()\n\n    packed_data = np.frombuffer(self.data, dtype=np.int8)\\\n        .reshape((header['number_of_half_frames'], header['half_frame_bytes']))  # create array of half frames\n    packed_data = packed_data[::-1, constants.header_offset:]  # slice out header and flip half frame order to reverse time ordering\n    packed_data = packed_data.reshape((header['number_of_half_frames']*(header['half_frame_bytes']- constants.header_offset))) # compact into vector\n\n    return packed_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef complex_data(self):\n    '''\n    This will cast each byte to an int8 and interpret each byte\n    as 4 bits real values and 4 bits imag values (RRRRIIII). The data are then\n    used to create a 3D numpy array of dtype=complex, which is returned. \n\n    The shape of the numpy array is N half frames, M subbands, K data points per half frame,\n    where K = constants.bins_per_half_frame, N is typically 129 and M is typically 1 for\n    compamp files and 16 for archive-compamp files. \n\n    Note that this returns a Numpy array of type complex64. This data is not retained within Compamp objects.\n\n    '''\n    #note that since we can only pack into int8 types, we must pad each 4-bit value with 4, 0 bits\n    #this effectively multiplies each 4-bit value by 16 when that value is represented as an 8-bit signed integer.\n    packed_data = self._packed_data()\n    header = self.header()\n\n    real_val = np.bitwise_and(packed_data, 0xf0).astype(np.int8)  # coef's are: RRRRIIII (4 bits real,\n    imag_val = np.left_shift(np.bitwise_and(packed_data, 0x0f), 4).astype(np.int8)  # 4 bits imaginary in 2's complement)\n\n    cdata = np.empty(len(real_val), np.complex64)\n\n    #\"Normalize\" by making appropriate bit-shift. Otherwise, values for real and imaginary coefficients are\n    #inflated by 16x. \n    cdata.real = np.right_shift(real_val, 4)\n    cdata.imag = np.right_shift(imag_val, 4)\n\n    # expose compamp measurement blocks\n    cdata = cdata.reshape((header['number_of_half_frames'], header['number_of_subbands'], constants.bins_per_half_frame))\n\n    return cdata", "response": "Returns a Numpy array of complex64 values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef complex_data(self):\n    '''\n    This unpacks the data into a time-series data, of complex values.\n\n    Also, any DC offset from the time-series is removed.\n\n    This is a 1D complex-valued numpy array.\n    '''\n    cp = np.frombuffer(self.data, dtype='i1').astype(np.float32).view(np.complex64)\n    cp = cp - cp.mean()\n    return cp", "response": "This method returns a 1D complex - valued numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _spec_fft(self, complex_data):\n    '''\n    Calculates the DFT of the complex_data along axis = 1.  This assumes complex_data is a 2D array.\n\n    This uses numpy and the code is straight forward\n    np.fft.fftshift( np.fft.fft(complex_data), 1)\n\n    Note that we automatically shift the FFT frequency bins so that along the frequency axis, \n    \"negative\" frequencies are first, then the central frequency, followed by \"positive\" frequencies.\n    '''\n    return np.fft.fftshift( np.fft.fft(complex_data), 1)", "response": "Calculates the DFT of the complex_data along axis = 1."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_spectrogram(self):\n    '''\n    Transforms the input simulated data and computes a standard-sized spectrogram.\n\n    If self.sigProc function is not None, the 2D complex-valued time-series data will \n    be processed with that function before the FFT and spectrogram are calculated. \n    '''\n\n    return self._spec_power(self._spec_fft(  self._sigProc( self._reshape( self.complex_data() )) ))", "response": "Returns a standard - scaled time - series spectrogram."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef riak_http_search_query(self, solr_core, solr_params, count_deleted=False):\n\n        # append current _solr_query params\n        sq = [\"%s%%3A%s\" % (q[0], q[1]) for q in self._solr_query]\n        if not count_deleted:\n            sq.append(\"-deleted%3ATrue\")\n\n        search_host = \"http://%s:%s/search/query/%s?wt=json&q=%s&%s\" % (\n            settings.RIAK_SERVER,\n            settings.RIAK_HTTP_PORT,\n            solr_core,\n            \"+AND+\".join(sq),\n            solr_params\n        )\n\n        return json.loads(bytes_to_str(urlopen(search_host).read()))", "response": "This method is for advanced SOLR queries. This method is for advanced SOLR queries. It sends solr_params and query string as a proxy and returns solr response."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict of distinct values of a specific field in a specific level of SLS.", "response": "def distinct_values_of(self, field, count_deleted=False):\n        \"\"\"\n        Uses riak http search query endpoint for advanced SOLR queries.\n\n        Args:\n            field (str): facet field\n            count_deleted (bool): ignore deleted or not\n\n        Returns: \n            (dict): pairs of field values and number of counts\n        \n\n        \"\"\"\n        solr_params = \"facet=true&facet.field=%s&rows=0\" % field\n        result = self.riak_http_search_query(self.index_name, solr_params, count_deleted)\n        facet_fields = result['facet_counts']['facet_fields'][field]\n        keys = facet_fields[0::2]\n        vals = facet_fields[1::2]\n\n        return dict(zip(keys, vals))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a set of records from solr.", "response": "def get_from_solr(clone, number, row_size):\n        \"\"\"\n        If not start parameter is given, with the given number(0,1,2..) multiplies default row size\n        and determines start parameter. Takes results from solr according to this parameter. For\n        example, if number is 2 and default row size is 1000, takes results from solr between 2000\n        and 3000. But if start parameter is given, start value is found adding given start paramater.\n        For example start paramater is given as 550, if number is 2 and default row size is 1000,\n        takes results from solr between 2550 and 3550.\n\n        Args:\n            clone: Queryset adapter clone\n            number(int): Uses for solr start parameter. Multiplies with default row size.\n            row_size(int): Uses for solr rows parameter. Indicates how many record will be taken\n                           from solr.\n\n        Returns:\n             tuple with given number and riak_multi_get method input list.\n             Example return = (0, [('models','personel','McAPchPZzB6RVJ8QI2XSVQk4mUR'),\n                                 ('models','personel','XyZZrsadVJ8QI2XSVQk4mUR'),\n                                 ('models','personel','SkFl3RPZzB6RVJ8QI2XSVQk4mUR'),\n                                 ('models','personel','PxCdytPZzB6RVJ8QI2XSVQk4mUR')])\n\n        \"\"\"\n        start = number * clone._cfg['row_size'] + clone._cfg['start']\n        clone._solr_params.update({'start': start})\n        clone._solr_params.update({'rows': row_size})\n        clone._solr_locked = False\n        return number, [(clone._cfg['bucket_type'], clone._cfg['bucket_name'],\n                         ub_to_str(doc.get('_yz_rk'))) for doc in clone._exec_query()]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef riak_multi_get(self, key_list_tuple):\n        pool = PyokoMG()\n        objs = self._client.multiget(key_list_tuple, pool=pool)\n        pool.stop()\n        return objs", "response": "Send a list of tuples of list to riak objs and took riak objs keys and data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _set_bucket(self, type, name):\n        if type:\n            self._cfg['bucket_type'] = type\n        if name:\n            self._cfg['bucket_name'] = name\n        self.bucket = self._client.bucket_type(self._cfg['bucket_type']\n                                               ).bucket(self._cfg['bucket_name'])\n        self.index_name = \"%s_%s\" % (self._cfg['bucket_type'], self._cfg['bucket_name'])\n        return self", "response": "Sets the bucket type and name of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting a copy of the objects current state to write - once mirror bucket.", "response": "def _write_version(self, data, model):\n        \"\"\"\n            Writes a copy of the objects current state to write-once mirror bucket.\n\n        Args:\n            data (dict): Model instance's all data for versioning.\n            model (instance): Model instance.\n\n        Returns:\n            Key of version record.\n            key (str): Version_bucket key.\n        \"\"\"\n        vdata = {'data': data,\n                 'key': model.key,\n                 'model': model.Meta.bucket_name,\n                 'timestamp': time.time()}\n        obj = version_bucket.new(data=vdata)\n        obj.add_index('key_bin', model.key)\n        obj.add_index('model_bin', vdata['model'])\n        obj.add_index('timestamp_int', int(vdata['timestamp']))\n        obj.store()\n        return obj.key"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a log entry for the current object.", "response": "def _write_log(self, version_key, meta_data, index_fields):\n        \"\"\"\n        Creates a log entry for current object,\n        Args:\n            version_key(str): Version_bucket key from _write_version().\n            meta_data (dict): JSON serializable meta data for logging of save operation.\n                {'lorem': 'ipsum', 'dolar': 5}\n            index_fields (list): Tuple list for secondary indexing keys in riak (with 'bin' or 'int').\n                [('lorem','bin'),('dolar','int')]\n\n        Returns:\n\n        \"\"\"\n        meta_data = meta_data or {}\n        meta_data.update({\n            'version_key': version_key,\n            'timestamp': time.time(),\n        })\n        obj = log_bucket.new(data=meta_data)\n        obj.add_index('version_key_bin', version_key)\n        obj.add_index('timestamp_int', int(meta_data['timestamp']))\n        for field, index_type in index_fields:\n            obj.add_index('%s_%s' % (field, index_type), meta_data.get(field, \"\"))\n        obj.store()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_model(self, model, meta_data=None, index_fields=None):\n        # if model:\n        #     self._model = model\n        if settings.DEBUG:\n            t1 = time.time()\n        clean_value = model.clean_value()\n        model._data = clean_value\n\n        if settings.DEBUG:\n            t2 = time.time()\n\n        if not model.exist:\n            obj = self.bucket.new(data=clean_value).store()\n            model.key = obj.key\n            new_obj = True\n        else:\n            new_obj = False\n            obj = self.bucket.get(model.key)\n            obj.data = clean_value\n            obj.store()\n\n        if settings.ENABLE_VERSIONS:\n            version_key = self._write_version(clean_value, model)\n        else:\n            version_key = ''\n\n        if settings.ENABLE_CACHING:\n            self.set_to_cache((clean_value, model.key))\n\n        meta_data = meta_data or model.save_meta_data\n        if settings.ENABLE_ACTIVITY_LOGGING and meta_data:\n            self._write_log(version_key, meta_data, index_fields)\n\n        if self.COLLECT_SAVES and self.COLLECT_SAVES_FOR_MODEL == model.__class__.__name__:\n            self.block_saved_keys.append(obj.key)\n        if settings.DEBUG:\n            if new_obj:\n                sys.PYOKO_STAT_COUNTER['save'] += 1\n                sys.PYOKO_LOGS['new'].append(obj.key)\n            else:\n                sys.PYOKO_LOGS[self._model_class.__name__].append(obj.key)\n                sys.PYOKO_STAT_COUNTER['update'] += 1\n        # sys._debug_db_queries.append({\n        #         'TIMESTAMP': t1,\n        #         'KEY': obj.key,\n        #         'BUCKET': self.index_name,\n        #         'SAVE_IS_NEW': new_obj,\n        #         'SERIALIZATION_TIME': round(t2 - t1, 5),\n        #         'TIME': round(time.time() - t2, 5)\n        #     })\n        return model", "response": "Save a single object of a specific type of object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_to_cache(vk):\n        v, k = vk\n\n        try:\n            cache.set(k, json.dumps(v), settings.CACHE_EXPIRE_DURATION)\n        except Exception as e:\n            pass\n            # todo should add log.error()\n        return v, k", "response": "Set the value of a key in the cache"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_from_cache(key):\n\n        try:\n            value = cache.get(key)\n            return json.loads(value), key if value else None\n        except Exception as e:\n            # todo should add log.error()\n            return None", "response": "Get a key from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the object from riak", "response": "def _get_from_riak(self, key):\n        \"\"\"\n        Args:\n            key (str): riak key\n        Returns:\n            (tuple): riak obj json data and riak key\n        \"\"\"\n\n        obj = self.bucket.get(key)\n\n        if obj.exists:\n            return obj.data, obj.key\n\n        raise ObjectDoesNotExist(\"%s %s\" % (key, self.compiled_query))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncount the number of objects that could be accessed with the current parameters.", "response": "def count(self):\n        \"\"\"Counts the number of results that could be accessed with the current parameters.\n\n        :return:  number of objects matches to the query\n        :rtype: int\n        \"\"\"\n        # Save the existing rows and start parameters to see how many results were actually expected\n        _rows = self._solr_params.get('rows', None)\n        _start = self._solr_params.get('start', 0)\n        if not self._solr_cache:\n            # Get the count for everything\n            self.set_params(rows=0)\n            self._exec_query()\n        number = self._solr_cache.get('num_found', -1)\n\n        # If start value is bigger or equal than solr results' count, should return 0\n        # If there are 10 results, but if start value is specified as 30, should return 0.\n        if _start >= number:\n            return 0\n        else:\n            # If 'start' is specified, then this many results from the start will not be accessible.\n            number -= _start\n            # If 'rows' is NOT specified, then all results are accessible\n            # (minus the ones skipped with 'start')\n            if _rows is None:\n                return number\n            # If 'rows' is specified, then this many results at most will be accessible. If we have\n            # more than this many results found, then we can say that this many results are\n            # accessible. If there are less results found than rows, then we can't give more\n            # than found results.\n            return number if number < _rows else _rows"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef search_on(self, *fields, **query):\n        search_type = list(query.keys())[0]\n        parsed_query = self._parse_query_modifier(search_type, query[search_type], False)\n        self.add_query([(\"OR_QRY\", dict([(f, parsed_query) for f in fields]), True)])", "response": "Search for query on given fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef order_by(self, *args):\n        if self._solr_locked:\n            raise Exception(\"Query already executed, no changes can be made.\"\n                            \"%s %s\" % (self._solr_query, self._solr_params)\n                            )\n\n        for arg in args:\n            if arg.startswith('-'):\n                self._solr_params['sort'][arg[1:]] = 'desc'\n            else:\n                self._solr_params['sort'][arg] = 'asc'", "response": "Applies query ordering.\n\n        New parameters are appended to current ones, overwriting existing ones.\n\n        Args:\n            **args: Order by fields names.\n            Defaults to ascending, prepend with hypen (-) for desecending ordering."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the solr query parameters.", "response": "def set_params(self, **params):\n        \"\"\"\n        add/update solr query parameters\n        \"\"\"\n        if self._solr_locked:\n            raise Exception(\"Query already executed, no changes can be made.\"\n                            \"%s %s\" % (self._solr_query, self._solr_params)\n                            )\n        self._solr_params.update(params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nescaping a query string.", "response": "def _escape_query(self, query, escaped=False):\n        \"\"\"\n        Escapes query if it's not already escaped.\n\n        Args:\n            query: Query value.\n            escaped (bool): expresses if query already escaped or not.\n\n        Returns:\n            Escaped query value.\n        \"\"\"\n        if escaped:\n            return query\n        query = six.text_type(query)\n        for e in ['+', '-', '&&', '||', '!', '(', ')', '{', '}', '[', ']', '^', '\"', '~', '*',\n                  '?', ':', ' ']:\n            query = query.replace(e, \"\\\\%s\" % e)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_query_modifier(self, modifier, qval, is_escaped):\n        if modifier == 'range':\n            if not qval[0]:\n                start = '*'\n            elif isinstance(qval[0], date):\n                start = self._handle_date(qval[0])\n            elif isinstance(qval[0], datetime):\n                start = self._handle_datetime(qval[0])\n            elif not is_escaped:\n                start = self._escape_query(qval[0])\n            else:\n                start = qval[0]\n            if not qval[1]:\n                end = '*'\n            elif isinstance(qval[1], date):\n                end = self._handle_date(qval[1])\n            elif isinstance(qval[1], datetime):\n                end = self._handle_datetime(qval[1])\n            elif not is_escaped:\n                end = self._escape_query(qval[1])\n            else:\n                end = qval[1]\n            qval = '[%s TO %s]' % (start, end)\n        else:\n            if not is_escaped and not isinstance(qval, (date, datetime, int, float)):\n                qval = self._escape_query(qval)\n            if modifier == 'exact':\n                qval = qval\n            elif modifier == 'contains':\n                qval = \"*%s*\" % qval\n            elif modifier == 'startswith':\n                qval = \"%s*\" % qval\n            elif modifier == 'endswith':\n                qval = \"%s*\" % qval\n            elif modifier == 'lte':\n                qval = '[* TO %s]' % qval\n            elif modifier == 'gte':\n                qval = '[%s TO *]' % qval\n            elif modifier == 'lt':\n                if isinstance(qval, int):\n                    qval -= 1\n                qval = '[* TO %s]' % qval\n            elif modifier == 'gt':\n                if isinstance(qval, int):\n                    qval += 1\n                qval = '[%s TO *]' % qval\n        return qval", "response": "Parses the query_value according to the query_type\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_query_key(self, key, val, is_escaped):\n        if key.endswith('__contains'):\n            key = key[:-10]\n            val = self._parse_query_modifier('contains', val, is_escaped)\n        elif key.endswith('__range'):\n            key = key[:-7]\n            val = self._parse_query_modifier('range', val, is_escaped)\n        elif key.endswith('__startswith'):\n            key = key[:-12]\n            val = self._parse_query_modifier('startswith', val, is_escaped)\n        elif key.endswith('__endswith'):\n            key = key[:-10]\n            val = self._parse_query_modifier('endswith', val, is_escaped)\n        # lower than\n        elif key.endswith('__lt'):\n            key = key[:-4]\n            val = self._parse_query_modifier('lt', val, is_escaped)\n        # greater than\n        elif key.endswith('__gt'):\n            key = key[:-4]\n            val = self._parse_query_modifier('gt', val, is_escaped)\n        # lower than or equal\n        elif key.endswith('__lte'):\n            key = key[:-5]\n            val = self._parse_query_modifier('lte', val, is_escaped)\n        # greater than or equal\n        elif key.endswith('__gte'):\n            key = key[:-5]\n            val = self._parse_query_modifier('gte', val, is_escaped)\n        elif key != 'NOKEY' and not is_escaped:\n            val = self._escape_query(val)\n        return key, val", "response": "Parses a query key and value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a SOLR query and stores it into self. compiled_query", "response": "def _compile_query(self):\n        \"\"\"\n        Builds SOLR query and stores it into self.compiled_query\n        \"\"\"\n        # https://wiki.apache.org/solr/SolrQuerySyntax\n        # http://lucene.apache.org/core/2_9_4/queryparsersyntax.html\n        query = []\n\n        # filtered_query = self._model_class.row_level_access(self._current_context, self)\n        # if filtered_query is not None:\n        #     self._solr_query += filtered_query._solr_query\n        # print(self._solr_query)\n        for key, val, is_escaped in self._solr_query:\n            # querying on a linked model by model instance\n            # it should be a Model, not a Node!\n            if key == 'key':\n                key = '_yz_rk'\n            elif key == '-key':\n                    key = '-_yz_rk'\n            elif key[:5] == 'key__':  # to handle key__in etc.\n                key = '_yz_rk__' + key[5:]\n            elif key[:6] == '-key__':  # to handle key__in etc.\n                key = '-_yz_rk__' + key[6:]\n\n            key, val, is_escaped = self._process_query_val(key, val, is_escaped)\n            # if it's not one of the expected objects, it should be a string\n            # if key == \"OR_QRY\" then join them with \"OR\" after escaping & parsing\n            if key == 'OR_QRY':\n                key = 'NOKEY'\n                val = ' OR '.join(\n                    ['%s:%s' % self._parse_query_key(*self._process_query_val(k, v, is_escaped)) for\n                     k, v in val.items()])\n                is_escaped = True\n            # __in query is same as OR_QRY but key stays same for all values\n            elif key.endswith('__in'):\n                if not val:\n                    raise ValueError(\"query value list can not be empty for __in query, \"\n                                     \"please check if it is empty or not before execute filter.\")\n                key = key[:-4]\n                val = ' OR '.join(\n                    ['%s:%s' % (key, self._escape_query(v, is_escaped)) for v in val])\n                if key.startswith('-'):\n                    val = '*:* %s' % val\n                key = 'NOKEY'\n                is_escaped = True\n            # parse the query\n            key, val = self._parse_query_key(key, val, is_escaped)\n\n            # as long as not explicitly asked for,\n            # we filter out records with deleted flag\n            if key == 'deleted':\n                self.want_deleted = True\n            # convert two underscores to dot notation\n            key = key.replace('__', '.')\n            # NOKEY means we already combined key partition in to \"val\"\n            if key == 'NOKEY':\n                query.append(\"(%s)\" % val)\n            else:\n                query.append(\"%s:%s\" % (key, val))\n\n        # need to add *:* for negative queries, if\n        # query has only one criteria, such as:\n        # (-name:Jack) AND -deleted:True\n        # this wont work properly, it must be altered as\n        # (*:* -name:Jack) AND -deleted:True\n        if len(query) == 1:\n            q = query[0]\n            if q.startswith('-'):\n                query[0] = '*:* %s' % q\n            if q[:2] == '(-':\n                query[0] = '( *:* %s' % q[1:]\n\n        # filter out \"deleted\" fields if not user explicitly asked for\n\n        # join everything with \"AND\"\n        joined_query = self._QUERY_GLUE.join(query)\n        if not self.want_deleted:\n            if joined_query:\n                joined_query = \"(%s) AND -deleted:True\" % joined_query\n            else:\n                joined_query = '-deleted:True'\n        elif not joined_query:\n            joined_query = '*:*'\n        self.compiled_query = joined_query"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _sort_to_str(self):\n\n        params_list = []\n        timestamp = \"\"\n\n        for k, v in self._solr_params['sort'].items():\n            if k != \"timestamp\":\n                params_list.append(\" \".join([k, v]))\n            else:\n                timestamp = v\n\n        params_list.append(\" \".join(['timestamp', timestamp]))\n\n        self._solr_params['sort'] = \", \".join(params_list)", "response": "Transforms sort dict from\n            to string"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd default row size if it s not given in the query.", "response": "def _process_params(self):\n        \"\"\"\n        Adds default row size if it's not given in the query.\n        Converts param values into unicode strings.\n\n        Returns:\n            Processed self._solr_params dict.\n        \"\"\"\n        # transform sort dict into str\n        self._sort_to_str()\n\n        if 'rows' not in self._solr_params:\n            self._solr_params['rows'] = self._cfg['row_size']\n\n        for key, val in self._solr_params.items():\n            if isinstance(val, str) and six.PY2:\n                self._solr_params[key] = val.encode(encoding='UTF-8')\n        return self._solr_params"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute solr query and returns the result.", "response": "def _exec_query(self):\n        \"\"\"\n        Executes solr query if it hasn't already executed.\n\n        Returns:\n            Self.\n        \"\"\"\n        if not self._solr_locked:\n            if not self.compiled_query:\n                self._compile_query()\n            try:\n                solr_params = self._process_params()\n                if settings.DEBUG:\n                    t1 = time.time()\n                self._solr_cache = self.bucket.search(self.compiled_query,\n                                                      self.index_name,\n                                                      **solr_params)\n                # if DEBUG is on and DEBUG_LEVEL set to a value higher than 5\n                # print query in to console.\n                if settings.DEBUG and settings.DEBUG_LEVEL >= 5:\n                    print(\"QRY => %s\\nSOLR_PARAMS => %s\" % (self.compiled_query, solr_params))\n\n            except riak.RiakError as err:\n                err.value += self._get_debug_data()\n                raise\n            self._solr_locked = True\n            return self._solr_cache['docs']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_arguments(args=sys.argv[1:]):\n    cmd_description = \"Download tracklistings for BBC radio shows.\\n\\n\" \\\n                      \"Saves to a text file, tags audio file or does both.\\n\" \\\n                      \"To select output file, filename \" \\\n                      \"must both be specified.\\n\" \\\n                      \"If directory is not specified, directory is assumed\" \\\n                      \"to be where script is.\\n\" \\\n                      \"Filename is the prefix, for someaudio.m4a, use \" \\\n                      \"--filename someaudio\\n\" \\\n                      \"Otherwise, an attempt will be made to write \" \\\n                      \"text file to current directory.\\n\" \\\n                      \"If choosing 'both', directory and filename should \" \\\n                      \"point to audio file.\\n\" \\\n                      \"In this case, text file will have same name \" \\\n                      \"as audio file, but with .txt\"\n\n    # http://stackoverflow.com/questions/7869345/\n    parser = ArgumentParser(formatter_class=RawTextHelpFormatter,\n                            description=cmd_description)\n    action_help = \"tag: tag audio file with tracklisting\\n\" \\\n                  \"text: write tracklisting to text file (default)\\n\" \\\n                  \"both: tag audio file and write to text file\"\n    parser.add_argument('action', choices=('tag', 'text', 'both'),\n                        default='text', help=action_help)\n    parser.add_argument('pid', help=\"BBC programme id, e.g. b03fnc82\")\n    parser.add_argument('--directory', help=\"output directory\")\n    parser.add_argument('--fileprefix', help=\"output filename prefix\")\n    return parser.parse_args()", "response": "Parse command line arguments of script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n    args = parse_arguments()\n    print(args)\n    print(\"action\" + args.action)\n    print(\"pid\" + args.pid)\n    print(\"directory\" + args.directory)\n    print(\"fileprefix\" + args.fileprefix)", "response": "Check arguments are retrieved."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to get Request Token from OAuth Provider and redirect user to provider s site for approval.", "response": "def begin(self, request, data):\n        \"\"\" Try to get Request Token from OAuth Provider and\n            redirect user to provider's site for approval.\n        \"\"\"\n        request = self.get_request(\n                http_url = self.REQUEST_TOKEN_URL,\n                parameters = dict(oauth_callback = self.get_callback(request)))\n        content = self.load_request(request)\n        if not content:\n            return redirect('netauth-login')\n        request = self.get_request(token = Token.from_string(content), http_url=self.AUTHORIZE_URL)\n        return redirect(request.to_url())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, *args, **kwargs):\r\n        return_value = self.coro(*args, **kwargs)\r\n\r\n        # i don't like this but greenlets are so dodgy i have no other choice\r\n        raise StopIteration(return_value)", "response": "This runs in a greenlet"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_op(self, op, sched):\r\n        if op is self:\r\n            import warnings\r\n            warnings.warn(\"Running coro %s with itself. Something is fishy.\"%op)\r\n        assert self.state < self.STATE_COMPLETED, \\\r\n            \"%s called with %s op %r, coroutine state (%s) should be less than %s!\" % (\r\n                self, isinstance(op, CoroutineException) and op or\r\n                (hasattr(op, 'state') and {0:'RUNNING', 1:'FINALIZED', 2:'ERRORED'}[op.state] or 'NOP'), op,\r\n                self._state_names[self.state],\r\n                self._state_names[self.STATE_COMPLETED]\r\n            )\r\n        coroutines.ident = self\r\n\r\n        try:\r\n            if self.state == self.STATE_RUNNING:\r\n                if self.debug:\r\n                    traceback.print_stack(self.coro.gr_frame)\r\n\r\n                if isinstance(op, CoroutineException):\r\n                    rop = self.coro.throw(*op.args)\r\n                else:\r\n                    rop = self.coro.switch(op and op.finalize(sched))\r\n            elif self.state == self.STATE_NEED_INIT:\r\n                assert op is None\r\n                rop = self.coro.switch(*self.f_args, **self.f_kws)\r\n                self.state = self.STATE_RUNNING\r\n\r\n                del self.f_args\r\n                del self.f_kws\r\n            else:\r\n                return None\r\n\r\n        except StopIteration, e:\r\n            self.state = self.STATE_COMPLETED\r\n            self.result = e.args and e.args[0]\r\n            #~ del self.coro\r\n            rop = self\r\n        except (KeyboardInterrupt, GeneratorExit, SystemExit):\r\n            raise\r\n        except:\r\n            self.state = self.STATE_FAILED\r\n            self.result = None\r\n            self.exception = sys.exc_info()\r\n            if not self.caller:\r\n                self.handle_error()\r\n            rop = self\r\n            sys.exc_clear()\r\n            #~ del self.coro\r\n        finally:\r\n            coroutines.ident = None\r\n        return rop", "response": "Run an operation and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef me(cls):\n        return fields.ObjectField(name=cls.ENDPOINT, init_class=cls).decode(\n            cls.element_from_string(\n                cls._get_request(endpoint=cls.ENDPOINT + '/me').text\n            )\n        )", "response": "Returns information about the currently authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ckm_wolfenstein(laC, A, rhobar, etabar):\n    rho = rhobar/(1 - laC**2/2.)\n    eta = etabar/(1 - laC**2/2.)\n    return np.array([[sqrt(1 - laC**2)*sqrt(1 - A**2*laC**6*((-1j)*eta + rho)*((1j)*eta + rho)),\n        laC*sqrt(1 - A**2*laC**6*((-1j)*eta + rho)*((1j)*eta + rho)),\n        A*laC**3*((-1j)*eta + rho)],\n        [-(laC*sqrt(1 - A**2*laC**4)) - A**2*laC**5*sqrt(1 - laC**2)*((1j)*eta + rho),\n        sqrt(1 - laC**2)*sqrt(1 -  A**2*laC**4) - A**2*laC**6*((1j)*eta + rho),\n        A*laC**2*sqrt(1 - A**2*laC**6*((-1j)*eta + rho)*((1j)*eta + rho))],\n        [A*laC**3 - A*laC**3*sqrt(1 - laC**2)*sqrt(1 - A**2*laC**4)*((1j)*eta + rho),\n        -(A*laC**2*sqrt(1 - laC**2)) - A*laC**4*sqrt(1 - A**2*laC**4)*((1j)*eta + rho),\n        sqrt(1 - A**2*laC**4)*sqrt(1 - A**2*laC**6*((-1j)*eta + rho)*((1j)*eta + rho))]])", "response": "rCKM matrix in the Wolfenstein parametrization and standard phase\n    convention."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ckm_tree(Vus, Vub, Vcb, gamma):\n    return np.array([[sqrt(1 - Vub**2)*sqrt(1 - Vus**2/(1 - Vub**2)),\n        Vus,\n        Vub/exp(1j*gamma)],\n        [-((sqrt(1 - Vcb**2/(1 - Vub**2))*Vus)/sqrt(1 - Vub**2)) - (Vub*exp(1j*gamma)*Vcb*sqrt(1 - Vus**2/(1 - Vub**2)))/sqrt(1 - Vub**2),\n        -((Vub*exp(1j*gamma)*Vcb*Vus)/(1 - Vub**2)) + sqrt(1 - Vcb**2/(1 - Vub**2))*sqrt(1 - Vus**2/(1 - Vub**2)),\n        Vcb],\n        [(Vcb*Vus)/(1 - Vub**2) - Vub*exp(1j*gamma)*sqrt(1 - Vcb**2/(1 - Vub**2))*sqrt(1 - Vus**2/(1 - Vub**2)),\n        -((Vub*exp(1j*gamma)*sqrt(1 - Vcb**2/(1 - Vub**2))*Vus)/sqrt(1 - Vub**2)) - (Vcb*sqrt(1 - Vus**2/(1 - Vub**2)))/sqrt(1 - Vub**2),\n        sqrt(1 - Vub**2)*sqrt(1 - Vcb**2/(1 - Vub**2))]])", "response": "r Returns the CKM matrix in the tree parametrization and standard phase\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef debug(trace=True, backtrace=1, other=None, output=sys.stderr):\r\n    from pprint import pprint\r\n    import traceback\r\n    def debugdeco(func):\r\n        def tracer(frame, event, arg):\r\n            print>>output, '--- Tracer: %s, %r' % (event, arg)\r\n            traceback.print_stack(frame, 1, output)\r\n            return tracer\r\n        def wrapped(*a, **k):\r\n            print>>output\r\n            print>>output, '--- Calling %s.%s with:' % (\r\n                getattr(func, '__module__', ''),\r\n                func.__name__\r\n            )\r\n            for i in enumerate(a):\r\n                print>>output, '    | %s: %s' % i\r\n            print>>output, '    | ',\r\n            pprint(k, output)\r\n            print>>output, '    From:'\r\n            for i in traceback.format_stack(sys._getframe(1), backtrace):\r\n                print>>output, i,\r\n            if other:\r\n                print>>output, '---      [ %r ]' % (other(func,a,k))\r\n            if trace: sys.settrace(tracer)\r\n            ret = func(*a, **k)\r\n            if trace: sys.settrace(None)\r\n            #~ a = list(a)\r\n            print>>output, '--- %s.%s returned: %r' % (\r\n                getattr(func, '__module__', ''),\r\n                func.__name__,\r\n                #~ ret not in a and ret or \"ARG%s\"%a.index(ret)\r\n                ret\r\n            )\r\n            return ret\r\n        return wrapped\r\n    return debugdeco", "response": "A decorator for debugging purposes. Shows the arguments result\r\n            and instructions as they are runned."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bind_context(context_filename):\n\n    global PRODUCT_CONTEXT\n    if PRODUCT_CONTEXT is None:\n        with open(context_filename) as contextfile:\n            try:\n                context = json.loads(contextfile.read())\n            except ValueError as e:\n                raise ContextParseError('Error parsing %s: %s' % (context_filename, str(e)))\n            context['PRODUCT_CONTEXT_FILENAME'] = context_filename\n            context['PRODUCT_EQUATION_FILENAME'] = os.environ['PRODUCT_EQUATION_FILENAME']\n            context['PRODUCT_NAME'] = os.environ['PRODUCT_NAME']\n            context['CONTAINER_NAME'] = os.environ['CONTAINER_NAME']\n            context['PRODUCT_DIR'] = os.environ['PRODUCT_DIR']\n            context['CONTAINER_DIR'] = os.environ['CONTAINER_DIR']\n            context['APE_ROOT_DIR'] = os.environ['APE_ROOT_DIR']\n            context['APE_GLOBAL_DIR'] = os.environ['APE_GLOBAL_DIR']\n            PRODUCT_CONTEXT = ContextAccessor(context)\n    else:\n        # bind_context called but context already bound\n        # harmless rebind (with same file) is ignored\n        # otherwise this is a serious error\n        if PRODUCT_CONTEXT.PRODUCT_CONTEXT_FILENAME != context_filename:\n            raise ContextBindingError('product context bound multiple times using different data!')", "response": "Loads the context from file and binds it to the product s internal context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_chromosome_priority(chrom, chrom_dict={}):\n    priority = 0\n    \n    chrom = str(chrom).lstrip('chr')\n    \n    if chrom_dict:\n        priority = chrom_dict.get(chrom, 0)\n    \n    else:\n        try:\n            if int(chrom) < 23:\n                priority = int(chrom)\n        except ValueError:\n            if chrom == 'X':\n                priority = 23\n            elif chrom == 'Y':\n                priority = 24\n            elif chrom == 'MT':\n                priority = 25\n            else:\n                priority = 26\n    \n    return str(priority)", "response": "Returns the chromosome priority for a given chromosome"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort_variants(vcf_handle):\n    logger.debug(\"Creating temp file\")\n    temp_file = NamedTemporaryFile(delete=False)\n    temp_file.close()\n    logger.debug(\"Opening temp file with codecs\")\n    temp_file_handle = codecs.open(\n                        temp_file.name,\n                        mode='w',\n                        encoding='utf-8',\n                        errors='replace'\n                        )\n\n    try:\n        with codecs.open(temp_file.name,mode='w',encoding='utf-8',errors='replace') as f:\n            for line in vcf_handle:\n                if not line.startswith('#'):\n                    line = line.rstrip().split('\\t')\n                    chrom = line[0]\n                    priority = get_chromosome_priority(chrom)\n                \n                    print_line = \"{0}\\t{1}\\n\".format(priority, '\\t'.join(line))\n                    f.write(print_line)\n        #Sort the variants\n        sort_variant_file(temp_file.name)\n        \n        with codecs.open(temp_file.name,mode='r',encoding='utf-8',errors='replace') as f:\n            for line in f:\n                line = line.rstrip().split('\\t')\n                yield '\\t'.join(line[1:])\n\n    except Exception as err:\n        logger.error(\"Something went wrong\")\n        logger.error(err)\n    finally:\n        logger.debug(\"Deleting temp file\")\n        os.remove(temp_file.name)\n        logger.debug(\"Temp file deleted\")", "response": "Sort the variants of a vcf file\n    \n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsorting a modified variant file.", "response": "def sort_variant_file(infile):\n    \"\"\"\n    Sort a modified variant file.\n    Sorting is based on the first column and the POS.\n    \n    Uses unix sort to sort the variants and overwrites the infile.\n    \n    Args:\n        infile : A string that is the path to a file\n        mode : 'chromosome' or 'rank'\n        outfile : The path to an outfile where the variants should be printed\n    \n    Returns:\n        0 if sorting was performed\n        1 if variants where not sorted\n    \"\"\"\n    command = [\n            'sort',\n            ]\n    command.append('-n')\n    command.append('-k1')\n    command.append('-k3')\n\n    command = command + [infile, '-o', infile]\n\n    logger.info(\"Start sorting variants...\")\n    logger.info(\"Sort command: {0}\".format(' '.join(command)))\n    sort_start = datetime.now()\n    \n    try:\n        call(command)\n    except OSError as e:\n        logger.warning(\"unix command sort does not seem to exist on your system...\")\n        logger.warning(\"genmod needs unix sort to provide a sorted output.\")\n        logger.warning(\"Output VCF will not be sorted since genmod can not find\"\\\n                        \"unix sort\")\n        raise e\n\n    logger.info(\"Sorting done. Time to sort: {0}\".format(datetime.now()-sort_start))\n    \n    return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nincluding a given feed into a new Universal Feed Tree.", "response": "def include_feed(feed_url, *args):\n    \"\"\"\n    Parse an RSS or Atom feed and render a given number of its items\n    into HTML.\n    \n    It is **highly** recommended that you use `Django's template\n    fragment caching`_ to cache the output of this tag for a\n    reasonable amount of time (e.g., one hour); polling a feed too\n    often is impolite, wastes bandwidth and may lead to the feed\n    provider banning your IP address.\n    \n    .. _Django's template fragment caching: http://www.djangoproject.com/documentation/cache/#template-fragment-caching\n    \n    Arguments should be:\n    \n    1. The URL of the feed to parse.\n    \n    2. The name of a template to use for rendering the results into HTML.\n\n    3. The number of items to render (if not supplied, renders all\n       items in the feed).\n           \n    The template used to render the results will receive two variables:\n    \n    ``items``\n        A list of dictionaries representing feed items, each with\n        'title', 'summary', 'link' and 'date' members.\n    \n    ``feed``\n        The feed itself, for pulling out arbitrary attributes.\n    \n    Requires the Universal Feed Parser, which can be obtained at\n    http://feedparser.org/. See `its documentation`_ for details of the\n    parsed feed object.\n    \n    .. _its documentation: http://feedparser.org/docs/\n    \n    Syntax::\n    \n        {% include_feed [feed_url] [num_items] [template_name] %}\n    \n    Example::\n    \n        {% include_feed \"http://www2.ljworld.com/rss/headlines/\" 10 feed_includes/ljworld_headlines.html %}\n    \n    \"\"\"\n    feed = feedparser.parse(feed_url)\n    items = []\n    \n    if len(args) == 2:\n        # num_items, template_name\n        num_items, template_name = args\n    elif len(args) == 1:\n        # template_name\n        num_items, template_name = None, args[0]\n    else:\n        raise TemplateSyntaxError(\"'include_feed' tag takes either two or three arguments\")\n        \n    num_items = int(num_items) or len(feed['entries'])\n    for i in range(num_items):\n        pub_date = feed['entries'][i].updated_parsed\n        published = datetime.date(pub_date[0], pub_date[1], pub_date[2])\n        items.append({ 'title': feed['entries'][i].title,\n                       'summary': feed['entries'][i].summary,\n                       'link': feed['entries'][i].link,\n                       'date': published })\n    return template_name, { 'items': items, 'feed': feed }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_app(global_conf, full_stack=True, **app_conf):\r\n    # Configure the Pylons environment\r\n    load_environment(global_conf, app_conf)\r\n\r\n    # The Pylons WSGI app\r\n    app = PylonsApp()\r\n\r\n    # CUSTOM MIDDLEWARE HERE (filtered by error handling middlewares)\r\n\r\n    # Routing/Session/Cache Middleware\r\n    app = RoutesMiddleware(app, config['routes.map'])\r\n    #~ app = SessionMiddleware(app, config)\r\n    app = CacheMiddleware(app, config)\r\n\r\n    if asbool(full_stack):\r\n        # Handle Python exceptions\r\n        #~ app = ErrorHandler(app, global_conf, **config['pylons.errorware'])\r\n\r\n        # Display error documents for 401, 403, 404 status codes (and\r\n        # 500 when debug is disabled)\r\n        if asbool(config['debug']):\r\n            app = StatusCodeRedirect(app)\r\n        else:\r\n            app = StatusCodeRedirect(app, [400, 401, 403, 404, 500])\r\n\r\n    # Establish the Registry for this application\r\n    app = RegistryManager(app, streaming=True)\r\n\r\n\r\n    # Static files (If running in production, and Apache or another web\r\n    # server is handling this static content, remove the following 3 lines)\r\n    javascripts_app = StaticJavascripts()\r\n    static_app = StaticURLParser(config['pylons.paths']['static_files'])\r\n    app = Cascade([static_app, javascripts_app, app])\r\n\r\n    from cogen.web.async import LazyStartResponseMiddleware\r\n    app = LazyStartResponseMiddleware(app)\r\n\r\n    app = SessionMiddleware(app, config)\r\n\r\n    from cogen.web.async import SynchronousInputMiddleware\r\n    app = SynchronousInputMiddleware(app)\r\n\r\n    return app", "response": "Create a new application and return it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connectionMade(self):\n        self.factory.protocols.add(self)\n        self._factories = multiplexing.FactoryDict(self.store)\n        super(AMP, self).connectionMade()", "response": "Keep a reference to the protocol and use the factory s store to find multiplexed connection factories."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls when the connection to the AMP protocol has lost.", "response": "def connectionLost(self, reason):\n        \"\"\"Lose the reference to the protocol on the factory.\n\n        \"\"\"\n        self.factory.protocols.remove(self)\n        super(AMP, self).connectionLost(reason)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_map(func_name, *sequence):\n\n    if len(sequence)==1:\n        sequence = sequence[0]\n    return map(get_func(func_name, False), sequence)", "response": "Returns a list of the results of applying the function to the items of the given sequence."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_reduce(func_name, *sequence):\n    if len(sequence)==1:\n        sequence = sequence[0]\n    return reduce(get_func(func_name), sequence)", "response": "This function applies a function of two arguments cumulatively to the items of a sequence and returns the value of the first item in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _write_field(self, value):\n        class_name = str(value.__class__)\n        if class_name not in self.handlers:\n            raise ValueError('No handler has been registered for class: {0!s}'.format(class_name))\n        handler = self.handlers[class_name]\n        handler(value, self._file)", "response": "Write a single field to the destination file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_notes(self, page=0, since=None):\n        from highton.models.note import Note\n        params = {'n': int(page) * self.NOTES_OFFSET}\n        if since:\n            params['since'] = since.strftime(self.COLLECTION_DATETIME)\n\n        return fields.ListField(\n            name=self.ENDPOINT,\n            init_class=Note\n        ).decode(\n            self.element_from_string(\n                self._get_request(\n                    endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Note.ENDPOINT,\n                    params=params\n                ).text\n            )\n        )", "response": "Get the notes of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlogin to the server.", "response": "def _login(session):\n    \"\"\"Login.\"\"\"\n    _LOGGER.info(\"logging in (no valid cookie found)\")\n    session.cookies.clear()\n    resp = session.post(SSO_URL, {\n        'USER': session.auth.username,\n        'PASSWORD': session.auth.password,\n        'TARGET': TARGET_URL\n    })\n    parsed = BeautifulSoup(resp.text, HTML_PARSER)\n    relay_state = parsed.find('input', {'name': 'RelayState'}).get('value')\n    saml_response = parsed.find('input', {'name': 'SAMLResponse'}).get('value')\n    session.post(SIGNIN_URL, {\n        'RelayState': relay_state,\n        'SAMLResponse': saml_response\n    })\n    session.get(SIGNIN_URL)\n    _save_cookies(session.cookies, session.auth.cookie_path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap function to re - authenticate session.", "response": "def authenticated(function):\n    \"\"\"Re-authenticate if session expired.\"\"\"\n    def wrapped(*args):\n        \"\"\"Wrap function.\"\"\"\n        try:\n            return function(*args)\n        except MoparError:\n            _LOGGER.info(\"attempted to access page before login\")\n            _login(args[0])\n            return function(*args)\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef token(function):\n    def wrapped(session, *args):\n        \"\"\"Wrap function.\"\"\"\n        resp = session.get(TOKEN_URL).json()\n        session.headers.update({'mopar-csrf-salt': resp['token']})\n        return function(session, *args)\n    return wrapped", "response": "Attach a CSRF token for POST requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets vehicle health report summary.", "response": "def get_report(session, vehicle_index):\n    \"\"\"Get vehicle health report summary.\"\"\"\n    vhr = get_vehicle_health_report(session, vehicle_index)\n    if 'reportCard' not in vhr:\n        raise MoparError(\"no vhr found\")\n    return _traverse_report(vhr['reportCard'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_vehicle_health_report(session, vehicle_index):\n    profile = get_profile(session)\n    _validate_vehicle(vehicle_index, profile)\n    return session.get(VHR_URL, params={\n        'uuid': profile['vehicles'][vehicle_index]['uuid']\n    }).json()", "response": "Get complete vehicle health report."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting tow guide information.", "response": "def get_tow_guide(session, vehicle_index):\n    \"\"\"Get tow guide information.\"\"\"\n    profile = get_profile(session)\n    _validate_vehicle(vehicle_index, profile)\n    return session.post(TOW_URL, {\n        'vin': profile['vehicles'][vehicle_index]['vin']\n    }).json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncleans the model field. Best guess.", "response": "def _get_model(vehicle):\n    \"\"\"Clean the model field. Best guess.\"\"\"\n    model = vehicle['model']\n    model = model.replace(vehicle['year'], '')\n    model = model.replace(vehicle['make'], '')\n    return model.strip().split(' ')[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npoll for remote command status.", "response": "def _remote_status(session, service_id, uuid, url, interval=3):\n    \"\"\"Poll for remote command status.\"\"\"\n    _LOGGER.info('polling for status')\n    resp = session.get(url, params={\n        'remoteServiceRequestID':service_id,\n        'uuid':uuid\n    }).json()\n    if resp['status'] == 'SUCCESS':\n        return 'completed'\n    time.sleep(interval)\n    return _remote_status(session, service_id, uuid, url)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a remote command.", "response": "def remote_command(session, command, vehicle_index, poll=True):\n    \"\"\"Send a remote command.\"\"\"\n    if command not in SUPPORTED_COMMANDS:\n        raise MoparError(\"unsupported command: \" + command)\n    profile = get_profile(session)\n    _validate_vehicle(vehicle_index, profile)\n    if command in [COMMAND_LOCK, COMMAND_UNLOCK]:\n        url = REMOTE_LOCK_COMMAND_URL\n    elif command in [COMMAND_ENGINE_ON, COMMAND_ENGINE_OFF]:\n        url = REMOTE_ENGINE_COMMAND_URL\n    elif command == COMMAND_HORN:\n        url = REMOTE_ALARM_COMMAND_URL\n    resp = session.post(url, {\n        'pin': session.auth.pin,\n        'uuid': profile['vehicles'][vehicle_index]['uuid'],\n        'action': command\n    }).json()\n    if poll:\n        uuid = profile['vehicles'][vehicle_index]['uuid']\n        service_id = resp['serviceRequestId']\n        return _remote_status(session, service_id, uuid, url)\n    return 'submitted'"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_session(username, password, pin, cookie_path=COOKIE_PATH):\n    class MoparAuth(AuthBase):  # pylint: disable=too-few-public-methods\n        \"\"\"Authentication wrapper.\"\"\"\n\n        def __init__(self, username, password, pin, cookie_path):\n            \"\"\"Init.\"\"\"\n            self.username = username\n            self.password = password\n            self.pin = pin\n            self.cookie_path = cookie_path\n\n        def __call__(self, r):\n            \"\"\"No-op.\"\"\"\n            return r\n\n    session = requests.session()\n    session.auth = MoparAuth(username, password, pin, cookie_path)\n    session.headers.update({'User-Agent': USER_AGENT})\n    if os.path.exists(cookie_path):\n        _LOGGER.info(\"cookie found at: %s\", cookie_path)\n        session.cookies = _load_cookies(cookie_path)\n    else:\n        _login(session)\n    return session", "response": "Get a new session."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints commandless help for the current locale.", "response": "def print_commandless_help(self):\n        \"\"\"\n        print_commandless_help\n        \"\"\"\n        doc_help = self.m_doc.strip().split(\"\\n\")\n\n        if len(doc_help) > 0:\n            print(\"\\033[33m--\\033[0m\")\n            print(\"\\033[34m\" + doc_help[0] + \"\\033[0m\")\n            asp = \"author  :\"\n            doc_help_rest = \"\\n\".join(doc_help[1:])\n\n            if asp in doc_help_rest:\n                doc_help_rest = doc_help_rest.split(\"author  :\")\n\n                if len(doc_help_rest) > 1:\n                    print(\"\\n\\033[33m\" + doc_help_rest[0].strip() + \"\\n\")\n                    print(\"\\033[37m\" + asp + doc_help_rest[1] + \"\\033[0m\")\n                else:\n                    print(doc_help_rest)\n            else:\n                print(doc_help_rest)\n\n            print(\"\\033[33m--\\033[0m\")\n        else:\n            print(\"\\033[31mERROR, doc should have more then one line\\033[0m\")\n            print(self.m_doc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef for_print(self):\n        s = \"\\033[34m\" + self.get_object_info() + \"\\033[0m\"\n        s += \"\\n\"\n        s += self.as_string()\n        return s", "response": "Returns a string that can be printed to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_subclass(self):\n        strbldr = \"\"\"\n            class IArguments(Arguments):\n                \\\"\\\"\\\"\n                IArguments\n                \\\"\\\"\\\"\n                def __init__(self, doc=None, validateschema=None, argvalue=None, yamlstr=None, yamlfile=None, parse_arguments=True, persistoption=False, alwaysfullhelp=False, version=None, parent=None):\n                    \\\"\\\"\\\"\n                    @type doc: str, None\n                    @type validateschema: Schema, None\n                    @type yamlfile: str, None\n                    @type yamlstr: str, None\n                    @type parse_arguments: bool\n                    @type argvalue: str, None\n                    @return: None\n                    \\\"\\\"\\\"\n        \"\"\"\n        strbldr = remove_extra_indentation(strbldr)\n        strbldr += \"\\n\"\n        self.set_reprdict_from_attributes()\n        strbldr += self.write_members()\n        strbldr += 8 * \" \" + \"super().__init__(doc, validateschema, argvalue, yamlstr, yamlfile, parse_arguments, persistoption, alwaysfullhelp, version, parent)\\n\\n\"\n        strbldr2 = \"\"\"\n            class IArguments(Arguments):\n                \\\"\\\"\\\"\n                IArguments\n                \\\"\\\"\\\"\n                def __init__(self, doc):\n                    \\\"\\\"\\\"\n                    __init__\n                    \\\"\\\"\\\"\n        \"\"\"\n        strbldr2 = remove_extra_indentation(strbldr2)\n        strbldr2 += \"\\n\"\n        strbldr2 += self.write_members()\n        strbldr2 += 8 * \" \" + \"super().__init__(doc)\\n\\n\"\n        return strbldr2", "response": "get_subclass - returns the string representation of the class"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string that contains the contents of the members of the class.", "response": "def write_members(self):\n        \"\"\"\n        write_members\n        \"\"\"\n        s = \"\"\n        objattributes = list(self.m_reprdict[\"positional\"].keys())\n        objattributes.extend(list(self.m_reprdict[\"options\"].keys()))\n        objattributes.sort()\n\n        for objattr in objattributes:\n            s += 8 * \" \" + \"self.\" + objattr + \"=\"\n\n            if objattr in self.m_reprdict[\"positional\"]:\n                td = self.m_reprdict[\"positional\"]\n\n                if isinstance(td[objattr], int):\n                    s += \"0\"\n                elif isinstance(td[objattr], float):\n                    s += \"0.0\"\n                elif isinstance(td[objattr], bool):\n                    s += \"False\"\n                else:\n                    s += '\"\"'\n            else:\n                s += \"False\"\n\n            s += \"\\n\"\n\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_object_info(self):\n        objectinfo = str(self.__class__).replace(\">\", \"\")\n        objectinfo = objectinfo.replace(\"class \", \"\")\n        objectinfo = objectinfo.replace(\"'\", \"\")\n        objectinfo += \" object at 0x%x>\" % id(self)\n        return objectinfo", "response": "Returns the object info in following form class object at address >"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the fields of the object based on the values in positional and options.", "response": "def _set_fields(self, positional, options):\n        \"\"\"\n        _parse_arguments\n        \"\"\"\n        dictionary = {}\n\n        if positional is not None and options is not None:\n            self.positional = positional.copy()\n            self.options = options.copy()\n            dictionary = positional.copy()\n            dictionary.update(options.copy())\n            self.m_reprdict = {\"positional\": positional.copy(),\n                               \"options\": options.copy()}\n\n        for k, v in dictionary.items():\n            if hasattr(v, \"strip\"):\n                v = v.strip(\"'\")\n                v = v.strip('\"')\n\n            setattr(self, str(k), v)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the reprdict from the attributes of the object.", "response": "def set_reprdict_from_attributes(self):\n        \"\"\"\n        set_reprdict_from_attributes\n        \"\"\"\n        reprcopy = self.m_reprdict.copy()\n\n        for kd, d in reprcopy.items():\n            for k in d.keys():\n                if hasattr(self, k):\n                    self.m_reprdict[kd][k] = getattr(self, k)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string representation of the current object as YAML.", "response": "def as_yaml(self):\n        \"\"\"\n        as_yaml\n        \"\"\"\n        self.set_reprdict_from_attributes()\n        return \"---\\n\" + yaml.dump(self.m_reprdict, default_flow_style=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the code of the current state of the object.", "response": "def code(self):\n        \"\"\"\n        code\n        \"\"\"\n\n        def uniq(seq):\n            \"\"\"\n            @type seq: str\n            @return: None\n            \"\"\"\n            seen = set()\n            seen_add = seen.add\n            return [x for x in seq if x not in seen and not seen_add(x)]\n\n        # noinspection PyTypeChecker\n        a = uniq(i for i in self.autos if i is not None)\n        # noinspection PyTypeChecker\n        e = uniq(i for i in self.errors if i is not None)\n\n        if e:\n            return '\\n'.join(e)\n\n        return '\\n'.join(a)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_map():\r\n    map = Mapper(directory=config['pylons.paths']['controllers'],\r\n                 always_scan=config['debug'])\r\n\r\n    # The ErrorController route (handles 404/500 error pages); it should\r\n    # likely stay at the top, ensuring it can always be resolved\r\n    map.connect('error/:action/:id', controller='error')\r\n\r\n    # CUSTOM ROUTES HERE\r\n\r\n    map.connect(':controller/:action/:id')\r\n\r\n    return map", "response": "Create and configure and return the routes Mapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary of additional information to be added to the context.", "response": "def django_admin(request):\n    '''\n    Adds additional information to the context:\n\n    ``django_admin`` - boolean variable indicating whether the current\n    page is part of the django admin or not.\n    ``ADMIN_URL`` - normalized version of settings.ADMIN_URL; starts with a slash, ends without a slash\n\n    NOTE: do not set ADMIN_URL='/' in case your application provides functionality\n    outside of django admin as all incoming urls are interpreted as admin urls.\n    '''\n    # ensure that adminurl always starts with a '/' but never ends with a '/'\n    if settings.ADMIN_URL.endswith('/'):\n        admin_url = settings.ADMIN_URL[:-1]\n    if not settings.ADMIN_URL.startswith('/'):\n        admin_url = '/' + settings.ADMIN_URL\n\n    # add ADMIN_URL and django_admin to context\n\n    if request.META['PATH_INFO'].startswith(admin_url):\n        return {\n            'ADMIN_URL': admin_url,\n            'django_admin': True\n        }\n    else:\n        return {\n            'django_admin': False\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef document(self):\r\n        resp = request.environ.get('pylons.original_response')\r\n        page = error_document_template % \\\r\n            dict(prefix=request.environ.get('SCRIPT_NAME', ''),\r\n                 code=request.params.get('code', resp.status_int),\r\n                 message=request.params.get('message', resp.body))\r\n        return page", "response": "Render the error document"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef img(self, id):\r\n        return self._serve_file(os.path.join(media_path, 'img', id))", "response": "Serve Pylons stock images"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserves Pylons stock stylesheets", "response": "def style(self, id):\r\n        \"\"\"Serve Pylons' stock stylesheets\"\"\"\r\n        return self._serve_file(os.path.join(media_path, 'style', id))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserve the file at the specified path", "response": "def _serve_file(self, path):\r\n        \"\"\"Call Paste's FileApp (a WSGI application) to serve the file\r\n        at the specified path\r\n        \"\"\"\r\n        fapp = paste.fileapp.FileApp(path)\r\n        return fapp(request.environ, self.start_response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rcfile(appname, args={}, strip_dashes=True, module_name=None):\n    if strip_dashes:\n        for k in args.keys():\n            args[k.lstrip('-')] = args.pop(k)\n\n    environ = get_environment(appname)\n\n    if not module_name:\n        module_name = appname\n\n    config = get_config(appname, module_name, args.get('config', ''))\n\n    return merge(merge(args, config), environ)", "response": "Read environment variables and config files and return them merged with predefined list of arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef color_parts(parts):\n    return parts._replace(\n        title=Fore.GREEN + parts.title + Style.RESET_ALL,\n        doi=Fore.CYAN + parts.doi + Style.RESET_ALL\n    )", "response": "Adds colors to each part of the citation"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the parts which are common to all types of citation", "response": "def get_common_parts(r):\n    \"\"\"Gets citation parts which are common to all types of citation\"\"\"\n\n    title = format_title(r.get('title'))\n    author_list = format_author_list(r.get('author'))\n    container = format_container(r.get('container-title'))\n    date = format_date(r.get('issued'))\n    doi = r.get('DOI')\n\n    return Parts(type='Unknown', title=title, authors=author_list, container=container, date=date, extra='', doi=doi)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef safeReadJSON(url, logger, max_check=6, waittime=30):\n    '''Return JSON object from URL'''\n    counter = 0\n    # try, try and try again ....\n    while counter < max_check:\n        try:\n            with contextlib.closing(urllib.request.urlopen(url)) as f:\n                res = json.loads(f.read().decode('utf8'))\n            return res\n        except Exception as errmsg:\n            logger.info('----- GNR error [{0}] : retrying ----'.format(errmsg))\n        counter += 1\n        time.sleep(waittime)\n    logger.error('----- Returning nothing : GNR server may be down -----')\n    return None", "response": "Return JSON object from URL."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching terms against GNR.", "response": "def search(self, terms, prelim=True):\n        \"\"\"Search terms against GNR. If prelim = False, search other datasources \\\nfor alternative names (i.e. synonyms) with which to search main datasource.\\\nReturn JSON object.\"\"\"\n        # TODO: There are now lots of additional data sources, make additional\n        # searching optional (11/01/2017)\n        if prelim:  # preliminary search\n            res = self._resolve(terms, self.Id)\n            self._write(res)\n            return res\n        else:  # search other DSs for alt names, search DS with these\n            # quick fix: https://github.com/DomBennett/TaxonNamesResolver/issues/5\n            # seems to be due to limit on number of ids in single request\n            # switiching to a for loop for each data source\n            # appending all results into single res\n            res = []\n            for ds_id in self.otherIds:\n                tmp = self._resolve(terms, [ds_id])\n                res.append(tmp[0])\n            self._write(res)\n            alt_terms = self._parseNames(res)\n            if len(alt_terms) == 0:\n                return False\n            else:\n                # search the main source again with alt_terms\n                # replace names in json\n                terms = [each[1] for each in alt_terms]  # unzip\n                res = self._resolve(terms, self.Id)\n                self._write(res)\n                alt_res = self._replaceSupStrNames(res, alt_terms)\n                return alt_res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a triflow model and return optimized theano routines. Parameters ---------- model: triflow.Model: Model to compile Returns ------- (theano function, theano_function): Optimized routine that compute the evolution equations and their jacobian matrix.", "response": "def theano_compiler(model):\n    \"\"\"Take a triflow model and return optimized theano routines.\n\n    Parameters\n    ----------\n    model: triflow.Model:\n        Model to compile\n\n    Returns\n    -------\n    (theano function, theano_function):\n        Optimized routine that compute the evolution equations and their\n        jacobian matrix.\n    \"\"\"\n    from theano import tensor as T\n    from theano.ifelse import ifelse\n    import theano.sparse as ths\n    from theano import function\n\n    def th_Min(a, b):\n        if isinstance(a, T.TensorVariable) or isinstance(b, T.TensorVariable):\n            return T.where(a < b, a, b)\n        return min(a, b)\n\n    def th_Max(a, b):\n        if isinstance(a, T.TensorVariable) or isinstance(b, T.TensorVariable):\n            return T.where(a < b, b, a)\n        return max(a, b)\n\n    def th_Heaviside(a):\n        if isinstance(a, T.TensorVariable):\n            return T.where(a < 0, 1, 1)\n        return 0 if a < 0 else 1\n\n    mapargs = {arg: T.vector(arg)\n               for arg, sarg\n               in zip(model._args, model._symbolic_args)}\n\n    to_feed = mapargs.copy()\n\n    x_th = mapargs['x']\n    N = x_th.size\n    L = x_th[-1] - x_th[0]\n    dx = L / (N - 1)\n    to_feed['dx'] = dx\n\n    periodic = T.scalar(\"periodic\", dtype=\"int32\")\n\n    middle_point = int((model._window_range - 1) / 2)\n\n    th_args = [mapargs[key]\n               for key\n               in [*model._indep_vars,\n                   *model._dep_vars,\n                   *model._help_funcs,\n                   *model._pars]] + [periodic]\n\n    map_extended = {}\n\n    for (varname, discretisation_tree) in \\\n            model._symb_vars_with_spatial_diff_order.items():\n        pad_left, pad_right = model._bounds\n\n        th_arg = mapargs[varname]\n\n        per_extended_var = T.concatenate([th_arg[pad_left:],\n                                          th_arg,\n                                          th_arg[:pad_right]])\n        edge_extended_var = T.concatenate([[th_arg[0]] * middle_point,\n                                           th_arg,\n                                           [th_arg[-1]] * middle_point])\n\n        extended_var = ifelse(periodic,\n                              per_extended_var,\n                              edge_extended_var)\n\n        map_extended[varname] = extended_var\n        for order in range(pad_left, pad_right + 1):\n            if order != 0:\n                var = (\"{}_{}{}\").format(varname,\n                                         'm' if order < 0 else 'p',\n                                         np.abs(order))\n            else:\n                var = varname\n            new_var = extended_var[order - pad_left:\n                                   extended_var.size +\n                                   order - pad_right]\n            to_feed[var] = new_var\n\n    F = lambdify((model._symbolic_args),\n                 expr=model.F_array.tolist(),\n                 modules=[T, {\"Max\": th_Max,\n                              \"Min\": th_Min,\n                              \"Heaviside\": th_Heaviside}])(\n        *[to_feed[key]\n          for key\n          in model._args]\n    )\n\n    F = T.concatenate(F, axis=0).reshape((model._nvar, N)).T\n    F = T.stack(F).flatten()\n\n    J = lambdify((model._symbolic_args),\n                 expr=model.J_array.tolist(),\n                 modules=[T, {\"Max\": th_Max,\n                              \"Min\": th_Min,\n                              \"Heaviside\": th_Heaviside}])(\n        *[to_feed[key]\n          for key\n          in model._args]\n    )\n\n    J = [j if j != 0 else T.constant(0.)\n         for j in J]\n    J = [j if not isinstance(j, (int, float)) else T.constant(j)\n         for j in J]\n    J = T.stack([T.repeat(j, N) if j.ndim == 0 else j\n                 for j in J])\n    J = J[model._sparse_indices[0]].T.squeeze()\n\n    i = T.arange(N).dimshuffle([0, 'x'])\n    idx = T.arange(N * model._nvar).reshape((N, model._nvar)).T\n    edge_extended_idx = T.concatenate([T.repeat(idx[:, :1],\n                                                middle_point,\n                                                axis=1),\n                                       idx,\n                                       T.repeat(idx[:, -1:],\n                                                middle_point,\n                                                axis=1)],\n                                      axis=1).T.flatten()\n    per_extended_idx = T.concatenate([idx[:, -middle_point:],\n                                      idx,\n                                      idx[:, :middle_point]],\n                                     axis=1).T.flatten()\n    extended_idx = ifelse(periodic,\n                          per_extended_idx,\n                          edge_extended_idx)\n\n    rows = T.tile(T.arange(model._nvar),\n                  model._window_range * model._nvar) + i * model._nvar\n    cols = T.repeat(T.arange(model._window_range * model._nvar),\n                    model._nvar) + i * model._nvar\n    rows = rows[:, model._sparse_indices].reshape(J.shape).flatten()\n    cols = extended_idx[cols][:, model._sparse_indices] \\\n        .reshape(J.shape).flatten()\n\n    permutation = T.argsort(cols)\n\n    J = J.flatten()[permutation]\n    rows = rows[permutation]\n    cols = cols[permutation]\n    count = T.zeros((N * model._nvar + 1,), dtype=int)\n    uq, cnt = T.extra_ops.Unique(False, False, True)(cols)\n    count = T.set_subtensor(count[uq + 1], cnt)\n\n    indptr = T.cumsum(count)\n    shape = T.stack([N * model._nvar, N * model._nvar])\n    sparse_J = ths.CSC(J, rows, indptr, shape)\n    F_theano_function = function(inputs=th_args,\n                                 outputs=F,\n                                 on_unused_input='ignore',\n                                 allow_input_downcast=True)\n    J_theano_function = function(inputs=th_args,\n                                 outputs=sparse_J,\n                                 on_unused_input='ignore',\n                                 allow_input_downcast=True)\n\n    return F_theano_function, J_theano_function"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef numpy_compiler(model):\n\n    def np_Min(args):\n        a, b = args\n        return np.where(a < b, a, b)\n\n    def np_Max(args):\n        a, b = args\n        return np.where(a < b, b, a)\n\n    def np_Heaviside(a):\n        return np.where(a < 0, 1, 1)\n\n    f_func = lambdify((model._symbolic_args),\n                      expr=model.F_array.tolist(),\n                      modules=[{\"amax\": np_Max,\n                                \"amin\": np_Min,\n                                \"Heaviside\": np_Heaviside},\n                               \"numpy\"])\n\n    j_func = lambdify((model._symbolic_args),\n                      expr=model._J_sparse_array.tolist(),\n                      modules=[{\"amax\": np_Max,\n                                \"amin\": np_Min,\n                                \"Heaviside\": np_Heaviside},\n                               \"numpy\"])\n\n    compute_F = partial(compute_F_numpy, model, f_func)\n    compute_J = partial(compute_J_numpy, model, j_func)\n\n    return compute_F, compute_J", "response": "This function takes a triflow model and returns optimized numpy routines."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, content):\n\n        for byte in content:\n            self._crc64 = (self._crc64 >> 8) ^ self._lookup_table[(self._crc64 & 0xff) ^ byte]", "response": "Enumerates the bytes of the supplied bytearray and updates the CRC - 64."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _construct_lookup_table(self, polynomial):\n\n        self._lookup_table = []\n\n        for i in range(0, 256):\n            lookup_value = i\n\n            for _ in range(0, 8):\n                if lookup_value & 0x1 == 0x1:\n                    lookup_value = (lookup_value >> 1) ^ polynomial\n\n                else:\n                    lookup_value = lookup_value >> 1\n\n            self._lookup_table.append(lookup_value)", "response": "Constructs the lookup table from the supplied polynomial."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef makefile(self, mode='r', bufsize=-1):\r\n        return _fileobject(Socket(\r\n            _sock=self._fd._sock, \r\n            _timeout=self._timeout, \r\n            _proactor_added=self._proactor_added\r\n        ), mode, bufsize)", "response": "Returns a file object that can be read from the file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend data to the socket.", "response": "def send(self, data, **kws):\r\n        \"\"\"Send data to the socket. The socket must be connected to a remote\r\n        socket. Ammount sent may be less than the data provided.\"\"\"\r\n        return yield_(Send(self, data, timeout=self._timeout, **kws))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef accept(self, **kws):\r\n        return yield_(Accept(self, timeout=self._timeout, **kws))", "response": "Accept a connection. The socket must be bound to an address and\r\n        listening for connections. The return value is a pair (conn, address)\r\n        where conn is a new socket object usable to send and receive data on the\r\n        connection, and address is the address bound to the socket on the other\r\n        end of the connection.\r\n\r\n        Example:\r\n        {{{\r\n        conn, address = yield mysock.accept()\r\n        }}}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to a remote socket at _address_.", "response": "def connect(self, address, **kws):\r\n        \"\"\"Connect to a remote socket at _address_. \"\"\"\r\n        return yield_(Connect(self, address, timeout=self._timeout, **kws))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nauthenticating user by net identity.", "response": "def authenticate(identity=None, provider=None):\n        \" Authenticate user by net identity. \"\n        if not identity:\n            return None\n\n        try:\n            netid = NetID.objects.get(identity=identity, provider=provider)\n            return netid.user\n        except NetID.DoesNotExist:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(ty, val):\n    \"Checks that `val` adheres to type `ty`\"\n    \n    if isinstance(ty, basestring):\n        ty = Parser().parse(ty)\n\n    return ty.enforce(val)", "response": "Checks that val adheres to type ty"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the technical ID for a natural key.", "response": "def get_id(self, natural_key, enhancement=None):\n        \"\"\"\n        Returns the technical ID for a natural key or None if the given natural key is not valid.\n\n        :param T natural_key: The natural key.\n        :param T enhancement: Enhancement data of the dimension row.\n\n        :rtype: int|None\n        \"\"\"\n        # If the natural key is known return the technical ID immediately.\n        if natural_key in self._map:\n            return self._map[natural_key]\n\n        # The natural key is not in the map of this dimension. Call a stored procedure for translating the natural key\n        # to a technical key.\n        self.pre_call_stored_procedure()\n        success = False\n        try:\n            key = self.call_stored_procedure(natural_key, enhancement)\n            success = True\n        finally:\n            self.post_call_stored_procedure(success)\n\n        # Add the translation for natural key to technical ID to the map.\n        self._map[natural_key] = key\n\n        return key"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(cls, object_id):\n        from highton.models.party import Party\n        return fields.ListField(name=Party.ENDPOINT, init_class=Party).decode(\n            cls.element_from_string(\n                cls._get_request(endpoint=cls.ENDPOINT + '/' + str(object_id)).text\n            )\n        )", "response": "Get all parties associated with a given tag."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing a 64 - bit Cyclic Redundancy Check checksum from the supplied DVD path.", "response": "def compute(dvd_path):\n    \"\"\"Computes a Windows API IDvdInfo2::GetDiscID-compatible 64-bit Cyclic Redundancy Check\n       checksum from the DVD .vob, .ifo and .bup files found in the supplied DVD path.\n    \"\"\"\n\n    _check_dvd_path_exists(dvd_path)\n\n    _check_video_ts_path_exists(dvd_path)\n\n    # the polynomial used for this CRC-64 checksum is:\n    # x^63 + x^60 + x^57 + x^55 + x^54 + x^50 + x^49 + x^46 + x^41 + x^38 + x^37 + x^34 + x^32 +\n    # x^31 + x^30 + x^28 + x^25 + x^24 + x^21 + x^16 + x^13 + x^12 + x^11 + x^8 + x^7 + x^5 + x^2\n    calculator = _Crc64Calculator(0x92c64265d32139a4)\n\n    for video_ts_file_path in _get_video_ts_file_paths(dvd_path):\n        calculator.update(_get_file_creation_time(video_ts_file_path))\n        calculator.update(_get_file_size(video_ts_file_path))\n        calculator.update(_get_file_name(video_ts_file_path))\n\n    calculator.update(_get_vmgi_file_content(dvd_path))\n    calculator.update(_get_vts01i_file_content(dvd_path))\n\n    return calculator.crc64"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a sorted list of paths for files contained in the VIDEO_TS folder of the specified DVD path.", "response": "def _get_video_ts_file_paths(dvd_path):\n    \"\"\"Returns a sorted list of paths for files contained in th VIDEO_TS folder of the specified\n       DVD path.\n    \"\"\"\n\n    video_ts_folder_path = join(dvd_path, \"VIDEO_TS\")\n\n    video_ts_file_paths = []\n\n    for video_ts_folder_content_name in listdir(video_ts_folder_path):\n        video_ts_folder_content_path = join(video_ts_folder_path, video_ts_folder_content_name)\n\n        if isfile(video_ts_folder_content_path):\n            video_ts_file_paths.append(video_ts_folder_content_path)\n\n    return sorted(video_ts_file_paths)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the creation time of the file at the specified file path in Microsoft FILETIME structure format.", "response": "def _get_file_creation_time(file_path):\n    \"\"\"Returns the creation time of the file at the specified file path in Microsoft FILETIME\n       structure format (https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx),\n       formatted as a 8-byte unsigned integer bytearray.\n    \"\"\"\n\n    ctime = getctime(file_path)\n\n    if ctime < -11644473600 or ctime >= 253402300800:\n        raise FileTimeOutOfRangeException(ctime)\n\n    creation_time_datetime = datetime.utcfromtimestamp(ctime)\n\n    creation_time_epoch_offset = creation_time_datetime - datetime(1601, 1, 1)\n\n    creation_time_secs_from_epoch = _convert_timedelta_to_seconds(creation_time_epoch_offset)\n\n    creation_time_filetime = int(creation_time_secs_from_epoch * (10 ** 7))\n\n    file_creation_time = bytearray(8)\n    pack_into(b\"Q\", file_creation_time, 0, creation_time_filetime)\n\n    return file_creation_time"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _convert_timedelta_to_seconds(timedelta):\n\n    days_in_seconds = timedelta.days * 24 * 3600\n    return int((timedelta.microseconds + (timedelta.seconds + days_in_seconds) * 10 ** 6) / 10 ** 6)", "response": "Converts a timedelta object to a number of seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_file_size(file_path):\n\n    size = getsize(file_path)\n\n    file_size = bytearray(4)\n    pack_into(b\"I\", file_size, 0, size)\n\n    return file_size", "response": "Returns the size of the file at the specified file path formatted as a 4 - byte unsigned\n       integer bytearray."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the name of the file at the specified file path formatted as a UTF - 8 bytearray terminated with null character.", "response": "def _get_file_name(file_path):\n    \"\"\"Returns the name of the file at the specified file path, formatted as a UTF-8 bytearray\n       terminated with a null character.\n    \"\"\"\n\n    file_name = basename(file_path)\n\n    utf8_file_name = bytearray(file_name, \"utf8\")\n    utf8_file_name.append(0)\n\n    return utf8_file_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_first_64k_content(file_path):\n\n    if not isfile(file_path):\n        raise PathDoesNotExistException(file_path)\n\n    file_size = getsize(file_path)\n\n    content_size = min(file_size, 0x10000)\n\n    content = bytearray(content_size)\n    with open(file_path, \"rb\") as file_object:\n        content_read = file_object.readinto(content)\n\n        if content_read is None or content_read < content_size:\n            raise FileContentReadException(content_size, content_read)\n\n    return content", "response": "Returns the first 65536 bytes of the file at the specified file path as a bytearray."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse command line arguments", "response": "def parseArgs():\n    \"\"\"Read arguments\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-names\", \"-n\", help=\".txt file of taxonomic names\")\n    parser.add_argument(\"-datasource\", \"-d\", help=\"taxonomic datasource by \\\nwhich names will be resolved (default NCBI)\")\n    parser.add_argument(\"-taxonid\", \"-t\", help=\"parent taxonomic ID\")\n    parser.add_argument(\"--verbose\", help=\"increase output verbosity\",\n                        action=\"store_true\")\n    parser.add_argument('--details', help='display information about the \\\nprogram', action='store_true')\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logSysInfo():\n    logger.info('#' * 70)\n    logger.info(datetime.today().strftime(\"%A, %d %B %Y %I:%M%p\"))\n    logger.info('Running on [{0}] [{1}]'.format(platform.node(),\n                                                platform.platform()))\n    logger.info('Python [{0}]'.format(sys.version))\n    logger.info('#' * 70 + '\\n')", "response": "Write system info to log file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef logEndTime():\n    logger.info('\\n' + '#' * 70)\n    logger.info('Complete')\n    logger.info(datetime.today().strftime(\"%A, %d %B %Y %I:%M%p\"))\n    logger.info('#' * 70 + '\\n')", "response": "Write end info to log"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting data from configs", "response": "def get_config(section, option, allow_empty_option=True, default=\"\"):\n    '''\n    Get data from configs\n    '''\n    try:\n        value = config.get(section, option)\n        if value is None or len(value) == 0:\n            if allow_empty_option:\n                return \"\"\n            else:\n                return default\n        else:\n            return value\n    except ConfigParser.NoSectionError:\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getboolean_config(section, option, default=False):\n    '''\n    Get data from configs which store boolean records\n    '''\n    try:\n        return config.getboolean(section, option) or default\n    except ConfigParser.NoSectionError:\n        return default", "response": "Get data from configs which store boolean records\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating the filter values of this filter using list of rows.", "response": "def populate_values(self, rows, field):\n        \"\"\"\n        Populates the filter values of this filter using list of rows.\n\n        :param list[dict[str,T]] rows: The row set.\n        :param str field: The field name.\n        \"\"\"\n        self._values.clear()\n        for row in rows:\n            condition = SimpleConditionFactory.create_condition(self._field, row[field])\n            if condition.scheme == 'plain':\n                self._values.append(condition.expression)\n            else:\n                self._conditions.append(condition)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the field is in the list of conditions. Returns False otherwise.", "response": "def match(self, row):\n        \"\"\"\n        Returns True if the field is in the list of conditions. Returns False otherwise.\n\n        :param dict row: The row.\n\n        :rtype: bool\n        \"\"\"\n        if row[self._field] in self._values:\n            return True\n\n        for condition in self._conditions:\n            if condition.match(row):\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsolves the given exercise and notify the user.", "response": "def solveAndNotify(proto, exercise):\n    \"\"\"The user at the given AMP protocol has solved the given exercise.\n\n    This will log the solution and notify the user.\n    \"\"\"\n    exercise.solvedBy(proto.user)\n    proto.callRemote(ce.NotifySolved,\n                     identifier=exercise.identifier,\n                     title=exercise.title)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring that this user has just solved this exercise.", "response": "def solvedBy(self, user):\n        \"\"\"Stores that this user has just solved this exercise.\n\n        You probably want to notify the user when this happens. For\n        that, see ``solveAndNotify``.\n\n        \"\"\"\n        _Solution(store=self.store, who=user, what=self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wasSolvedBy(self, user):\n        thisExercise = _Solution.what == self\n        byThisUser = _Solution.who == user\n        condition = q.AND(thisExercise, byThisUser)\n        return self.store.query(_Solution, condition, limit=1).count() == 1", "response": "Checks if this exercise has previously been solved by the user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getExerciseDetails(self, identifier):\n        exercise = self._getExercise(identifier)\n        response = {\n            b\"identifier\": exercise.identifier,\n            b\"title\": exercise.title,\n            b\"description\": exercise.description,\n            b\"solved\": exercise.wasSolvedBy(self.user)\n        }\n        return response", "response": "Gets the details for a particular exercise."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsolving the current request and notify the user of the current request that they ve solved the current exercise.", "response": "def solveAndNotify(self, request):\n        \"\"\"Notifies the owner of the current request (so, the user doing the\n        exercise) that they've solved the exercise, and mark it as\n        solved in the database.\n\n        \"\"\"\n        remote = request.transport.remote\n        withThisIdentifier = Exercise.identifier == self.exerciseIdentifier\n        exercise = self.store.findUnique(Exercise, withThisIdentifier)\n        solveAndNotify(remote, exercise)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split(s):\n    return map(lambda w: filter(lambda c: c != '\\x00', w), lexsplit(s))", "response": "Split a string into a list of strings respecting any quoted strings inside the alphabet."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to resolve the varialbe in a context OrderItem", "response": "def lookup(parser, var, context, resolve=True, apply_filters=True):\n    \"\"\"\n    Try to resolve the varialbe in a context\n    If ``resolve`` is ``False``, only string variables are returned\n    \"\"\"\n    if resolve:\n        try:\n            return Variable(var).resolve(context)\n        except VariableDoesNotExist:\n            if apply_filters and var.find('|') > -1:\n                return parser.compile_filter(var).resolve(context)\n            return Constant(var)\n        except TypeError:\n            # already resolved\n            return var\n    return var"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_cache_key(bucket, name, args, kwargs):\n    u = ''.join(map(str, (bucket, name, args, kwargs)))\n    return 'native_tags.%s' % sha_constructor(u).hexdigest()", "response": "Gets a unique SHA1 cache key for any native tag."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_signature(token, contextable=False, comparison=False):\n    bits = split(token.contents)\n    args, kwargs = (), {}\n    if comparison and bits[-1] == 'negate':\n        kwargs['negate'] = True\n        bits = bits[:-1]\n    if contextable and len(bits) > 2 and bits[-2] == 'as':\n        kwargs['varname'] = bits[-1]\n        bits = bits[:-2]\n    kwarg_re = re.compile(r'^([-\\w]+)\\=(.*)$')\n    for bit in bits[1:]:\n        match = kwarg_re.match(bit)\n        if match:\n            kwargs[str(match.group(1))] = force_unicode(match.group(2))\n        else:\n            args += (bit,)\n    return bits[0], args, kwargs", "response": "Returns the signature tuple for any native tag\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a node list that can be used to compare the passed arguments.", "response": "def do_comparison(parser, token):\n    \"\"\"\n    Compares passed arguments. \n    Attached functions should return boolean ``True`` or ``False``.\n    If the attached function returns ``True``, the first node list is rendered.\n    If the attached function returns ``False``, the second optional node list is rendered (part after the ``{% else %}`` statement). \n    If the last argument in the tag is ``negate``, then the opposite node list is rendered (like an ``ifnot`` tag).\n    \n    Syntax::\n\n        {% if_[comparison] [var args...] [name=value kwargs...] [negate] %}\n            {# first node list in here #}\n        {% else %}\n            {# second optional node list in here #}\n        {% endif_[comparison] %}\n\n\n    Supported comparisons are ``match``, ``find``, ``startswith``, ``endswith``,\n    ``less``, ``less_or_equal``, ``greater`` and ``greater_or_equal`` and many more.\n    Checkout the :ref:`contrib-index` for more examples\n\n    Examples::\n\n        {% if_less some_object.id 3 %}\n        {{ some_object }} has an id less than 3.\n        {% endif_less %}\n\n        {% if_match request.path '^/$' %}\n        Welcome home\n        {% endif_match %}\n\n    \"\"\"\n    name, args, kwargs = get_signature(token, comparison=True)\n    name = name.replace('if_if', 'if')\n    end_tag = 'end' + name\n    kwargs['nodelist_true'] = parser.parse(('else', end_tag))\n    token = parser.next_token()\n    if token.contents == 'else':\n        kwargs['nodelist_false'] = parser.parse((end_tag,))\n        parser.delete_first_token()\n    else:\n        kwargs['nodelist_false'] = template.NodeList()\n    if name.startswith('if_'):\n        name = name.split('if_')[1]\n    return ComparisonNode(parser, name, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a defined function on the passed arguments. Normally this returns the output of the function into the template. If the second to last argument is ``as``, the result of the function is stored in the context and is named whatever the last argument is. Syntax:: {% [function] [var args...] [name=value kwargs...] [as varname] %} Examples:: {% search '^(\\d{3})$' 800 as match %} {% map sha1 hello world %}", "response": "def do_function(parser, token):\n    \"\"\"\n    Performs a defined function on the passed arguments.\n    Normally this returns the output of the function into the template.\n    If the second to last argument is ``as``, the result of the function is stored in the context and is named whatever the last argument is.\n\n    Syntax::\n\n        {% [function] [var args...] [name=value kwargs...] [as varname] %}\n\n    Examples::\n\n        {% search '^(\\d{3})$' 800 as match %}\n\n        {% map sha1 hello world %}\n\n    \"\"\"\n    name, args, kwargs = get_signature(token, True, True)\n    return FunctionNode(parser, name, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_block(parser, token):\n    name, args, kwargs = get_signature(token, contextable=True)\n    kwargs['nodelist'] = parser.parse(('end%s' % name,))\n    parser.delete_first_token()\n    return BlockNode(parser, name, *args, **kwargs)", "response": "Process several nodes inside a single block."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_attributes_of_node(attrs, node_name, class_type):\n        # print(\"Node: %s\" % node_name)\n        attrs['_nodes'] = {}\n        attrs['_linked_models'] = defaultdict(list)\n        attrs['_debug_linked_models'] = defaultdict(list)\n        attrs['_lazy_linked_models'] = defaultdict(list)\n        attrs['_fields'] = {}\n        attrs['_uniques'] = []\n        # attrs['_many_to_models'] = []\n\n        # iterating over attributes of the soon to be created class object.\n        for key, attr in list(attrs.items()):\n            # if it's a class (not instance) and it's type is Node or ListNode\n            if hasattr(attr, '__base__') and getattr(attr.__base__, '_TYPE', '') in ['Node',\n                                                                                     'ListNode']:\n                # converted pops to dict access to allow sphinx to\n                # properly document the models\n                # attrs['_nodes'][key] = attrs.pop(key)\n                attrs['_nodes'][key] = attrs[key]\n            else:  # otherwise it should be a field or linked model\n                attr_type = getattr(attr, '_TYPE', '')\n\n                if attr_type == 'Model':\n                    attrs['%s_id' % key] = ''\n                    # lnk_mdl_ins = attrs.pop(key)\n                    lnk_mdl_ins = attrs[key]\n                    lnk = {\n                        'null': lnk_mdl_ins.null or class_type == 'ListNode',\n                        'link_source': True,\n                        'mdl': lnk_mdl_ins.__class__,\n                        'o2o': lnk_mdl_ins._is_one_to_one,\n                        'm2m': class_type == 'ListNode',\n                        'reverse': lnk_mdl_ins.reverse_name,\n                        'verbose': lnk_mdl_ins.verbose_name,\n                        'field': key,\n                        'is_set': False,\n                    }\n                    attrs['_linked_models'][attr.__class__.__name__].append(lnk)\n                    debug_lnk = lnk.copy()\n                    debug_lnk['lnksrc']= 'process_attributes_of_node'\n                    attrs['_debug_linked_models'][attr.__class__.__name__].append(debug_lnk)\n                elif attr_type == 'Field':\n                    attr.name = key\n                    attrs['_fields'][key] = attr\n                    if attr.unique:\n                        attrs['_uniques'].append(key)\n                elif attr_type == 'Link':\n                    # lzy_lnk = attrs.pop(key)\n                    attrs['%s_id' % key] = ''\n                    lzy_lnk = attrs[key]\n                    attrs['_lazy_linked_models'][key].append({'from': node_name,\n                                                              'to': lzy_lnk.link_to,\n                                                              'o2o': lzy_lnk.one_to_one,\n                                                              'verbose': lzy_lnk.verbose_name,\n                                                              'reverse': lzy_lnk.reverse_name,\n                                                              'field': key})", "response": "This function processes the attributes of a node and creates the model fields nodes and relations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing the models and add default fields and meta options to the models.", "response": "def process_models(attrs, base_model_class):\n        \"\"\"\n        Attach default fields and meta options to models\n        \"\"\"\n        attrs.update(base_model_class._DEFAULT_BASE_FIELDS)\n        attrs['_instance_registry'] = set()\n        attrs['_is_unpermitted_fields_set'] = False\n        attrs['save_meta_data'] = None\n        attrs['_pre_save_hook_called'] = False\n        attrs['_post_save_hook_called'] = False\n        DEFAULT_META = {'bucket_type': settings.DEFAULT_BUCKET_TYPE,\n                        'field_permissions': {},\n                        'app': 'main',\n                        'list_fields': [],\n                        'list_filters': [],\n                        'search_fields': [],\n                        'fake_model': False,\n                        }\n        if 'Meta' not in attrs:\n            attrs['Meta'] = type('Meta', (object,), DEFAULT_META)\n        else:\n            for k, v in DEFAULT_META.items():\n                if k not in attrs['Meta'].__dict__:\n                    setattr(attrs['Meta'], k, v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies default meta properties.", "response": "def process_objects(kls):\n        \"\"\"\n        Applies default Meta properties.\n        \"\"\"\n        # first add a Meta object if not exists\n        if 'Meta' not in kls.__dict__:\n            kls.Meta = type('Meta', (object,), {})\n        if 'unique_together' not in kls.Meta.__dict__:\n            kls.Meta.unique_together = []\n        # set verbose_name(s) if not already set\n        if 'verbose_name' not in kls.Meta.__dict__:\n            kls.Meta.verbose_name = kls.__name__\n        if 'verbose_name_plural' not in kls.Meta.__dict__:\n            kls.Meta.verbose_name_plural = kls.Meta.verbose_name + 's'"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new user and validates its credentials and returns it", "response": "async def get_user(username: str, api_key: str, **kwargs) -> User:\n    \"\"\" Creates a new user, validate its credentials and returns it\n\n    |funccoro|\n\n    Args:\n        username: username as specified on the challonge website\n        api_key: key as found on the challonge\n            `settings <https://challonge.com/settings/developer>`_\n\n    Returns:\n        User: a logged in user if no exception has been raised\n\n    Raises:\n        APIException\n\n    \"\"\"\n    new_user = User(username, api_key, **kwargs)\n    await new_user.validate()\n    return new_user"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def get_tournament(self, t_id: int = None, url: str = None, subdomain: str = None, force_update=False) -> Tournament:\n        assert_or_raise((t_id is None) ^ (url is None),\n                        ValueError,\n                        'One of t_id or url must not be None')\n\n        found_t = self._find_tournament_by_id(t_id) if t_id is not None else self._find_tournament_by_url(url, subdomain)\n        if force_update or found_t is None:\n            param = t_id\n            if param is None:\n                if subdomain is not None:\n                    param = '{}-{}'.format(subdomain, url)\n                else:\n                    param = url\n            res = await self.connection('GET', 'tournaments/{}'.format(param))\n            self._refresh_tournament_from_json(res)\n            found_t = self._find_tournament_by_id(res['tournament']['id'])\n\n        return found_t", "response": "Gets a tournament with its id or url or url + subdomain."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def get_tournaments(self, subdomain: str = None, force_update: bool = False) -> list:\n        if self.tournaments is None:\n            force_update = True\n            self._subdomains_searched.append('' if subdomain is None else subdomain)\n        elif subdomain is None and '' not in self._subdomains_searched:\n            force_update = True\n            self._subdomains_searched.append('')\n        elif subdomain is not None and subdomain not in self._subdomains_searched:\n            force_update = True\n            self._subdomains_searched.append(subdomain)\n\n        if force_update:\n            params = {\n                'include_participants': 1 if AUTO_GET_PARTICIPANTS else 0,\n                'include_matches': 1 if AUTO_GET_MATCHES else 0\n            }\n            if subdomain is not None:\n                params['subdomain'] = subdomain\n\n            res = await self.connection('GET', 'tournaments', **params)\n            if len(res) == 0:\n                self.tournaments = []\n            else:\n                for t_data in res:\n                    self._refresh_tournament_from_json(t_data)\n\n        return self.tournaments", "response": "get all the user s tournaments in a specific subdomain"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def create_tournament(self, name: str, url: str, tournament_type: TournamentType = TournamentType.single_elimination, **params) -> Tournament:\n        params.update({\n            'name': name,\n            'url': url,\n            'tournament_type': tournament_type.value,\n        })\n        res = await self.connection('POST', 'tournaments', 'tournament', **params)\n        self._refresh_tournament_from_json(res)\n        return self._find_tournament_by_id(res['tournament']['id'])", "response": "Creates a new tournament with basic options"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def destroy_tournament(self, t: Tournament):\n        await self.connection('DELETE', 'tournaments/{}'.format(t.id))\n        if t in self.tournaments:\n            self.tournaments.remove(t)", "response": "completely removes a tournament from Challonge and removes all associated records from Challonge records"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert unicode to str", "response": "def ub_to_str(string):\n    \"\"\"\n    converts py2 unicode / py3 bytestring into str\n    Args:\n        string (unicode, byte_string): string to be converted\n        \n    Returns:\n        (str)\n    \"\"\"\n    if not isinstance(string, str):\n        if six.PY2:\n            return str(string)\n        else:\n            return string.decode()\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_camel(s):\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "response": "Convert string to CamelCased alphabet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget object from given Python path.", "response": "def get_object_from_path(path):\n    \"\"\"\n    Import's object from given Python path.\n    \"\"\"\n    try:\n        return sys.IMPORT_CACHE[path]\n    except KeyError:\n        _path = path.split('.')\n        module_path = '.'.join(_path[:-1])\n        class_name = _path[-1]\n        module = importlib.import_module(module_path)\n        sys.IMPORT_CACHE[path] = getattr(module, class_name)\n        return sys.IMPORT_CACHE[path]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrapped_sendfile(act, offset, length):\r\n    if sendfile:\r\n        offset, sent = sendfile.sendfile(\r\n            act.sock.fileno(),\r\n            act.file_handle.fileno(),\r\n            offset, length\r\n        )\r\n    else:\r\n        act.file_handle.seek(offset)\r\n        sent = act.sock._fd.send(act.file_handle.read(length))\r\n    return sent", "response": "Wrapper for the sendfile system call."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_options(self, multiplex_first=True, **bogus_options):\r\n        \"Takes implementation specific options. To be overriden in a subclass.\"\r\n        self.multiplex_first = multiplex_first\r\n        self._warn_bogus_options(**bogus_options)", "response": "Takes implementation specific options. To be overriden in a subclass."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _warn_bogus_options(self, **opts):\r\n        if opts:\r\n            import warnings\r\n            for i in opts:\r\n                warnings.warn(\"Unsupported option %s for %s\" % (i, self), stacklevel=2)", "response": "Show a warning for unsupported options for the current implementation."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests a connect for coro corutine with parameters and completion \\ passed via act \\", "response": "def request_connect(self, act, coro):\r\n        \"Requests a connect for `coro` corutine with parameters and completion \\\r\n        passed via `act`\"\r\n        result = self.try_run_act(act, perform_connect)\r\n        if result:\r\n            return result, coro\r\n        else:\r\n            self.add_token(act, coro, perform_connect)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request_generic(self, act, coro, perform):\r\n        result = self.multiplex_first and self.try_run_act(act, perform)\r\n        if result:\r\n            return result, coro\r\n        else:\r\n            self.add_token(act, coro, perform)", "response": "Request a generic socket operation for the given coro."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a completion token act in the proactor with associated coro performer.", "response": "def add_token(self, act, coro, performer):\r\n        \"\"\"\r\n        Adds a completion token `act` in the proactor with associated `coro`\r\n        corutine and perform callable.\r\n        \"\"\"\r\n        assert act not in self.tokens\r\n        act.coro = coro\r\n        self.tokens[act] = performer\r\n        self.register_fd(act, performer)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_token(self, act):\r\n        if act in self.tokens:\r\n            self.unregister_fd(act)\r\n            del self.tokens[act]\r\n            return True\r\n        else:\r\n            import warnings\r\n            warnings.warn(\"%s isn't a registered token.\" % act)", "response": "Remove a token from the proactor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_event(self, act):\r\n        scheduler = self.scheduler\r\n        if act in self.tokens:\r\n            coro = act.coro\r\n            op = self.try_run_act(act, self.tokens[act])\r\n            if op:\r\n                del self.tokens[act]\r\n                if scheduler.ops_greedy:\r\n                    while True:\r\n                        op, coro = scheduler.process_op(coro.run_op(op, scheduler), coro)\r\n                        if not op and not coro:\r\n                            break\r\n                else:\r\n                    if op.prio & priority.OP:\r\n                        op, coro = scheduler.process_op(coro.run_op(op, scheduler), coro)\r\n                    if coro and op:\r\n                        if op.prio & priority.CORO:\r\n                            scheduler.active.appendleft( (op, coro) )\r\n                        else:\r\n                            scheduler.active.append( (op, coro) )\r\n            else:\r\n                return\r\n        else:\r\n            import warnings\r\n            warnings.warn(\"Got event for unkown act: %s\" % act)\r\n        return True", "response": "Handles an event for a given action."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields an event from the scheduler.", "response": "def yield_event(self, act):\r\n        \"\"\"\r\n        Hande completion for a request and return an (op, coro) to be\r\n        passed to the scheduler on the last completion loop of a proactor.\r\n        \"\"\"\r\n        if act in self.tokens:\r\n            coro = act.coro\r\n            op = self.try_run_act(act, self.tokens[act])\r\n            if op:\r\n                del self.tokens[act]\r\n                return op, coro"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_error_event(self, act, detail, exc=SocketError):\r\n        del self.tokens[act]\r\n        self.scheduler.active.append((\r\n            CoroutineException(exc, exc(detail)),\r\n            act.coro\r\n        ))", "response": "Handles an error event."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters user - defined classes with the Dumper.", "response": "def add_to_dumper(dumper: Type, classes: List[Type]) -> None:\n    \"\"\"Register user-defined classes with the Dumper.\n\n    This enables the Dumper to write objects of your classes to a \\\n    YAML file. Note that all the arguments are types, not instances!\n\n    Args:\n        dumper: Your dumper class(!), derived from yatiml.Dumper\n        classes: One or more classes to add.\n    \"\"\"\n    if not isinstance(classes, list):\n        classes = [classes]  # type: ignore\n    for class_ in classes:\n        if issubclass(class_, enum.Enum):\n            dumper.add_representer(class_, EnumRepresenter(class_))\n        elif issubclass(class_, str) or issubclass(class_, UserString):\n            dumper.add_representer(class_, UserStringRepresenter(class_))\n        else:\n            dumper.add_representer(class_, Representer(class_))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping around a sparql query", "response": "def sparql(self, stringa):\n        \"\"\" wrapper around a sparql query \"\"\"\n        qres = self.rdfgraph.query(stringa)\n        return list(qres)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nscans a source of RDF triples and build all the objects that are part of the ontology.", "response": "def _scan(self, verbose=False, hide_base_schemas=True):\n        \"\"\"\n        scan a source of RDF triples\n        build all the objects to deal with the ontology/ies pythonically\n\n        \"\"\"\n        if verbose:\n            printDebug(\"Scanning entities...\", \"green\")\n            printDebug(\"----------\", \"comment\")\n\n        self.__extractOntologies()\n        if verbose: printDebug(\"Ontologies.........: %d\" % len(self.ontologies), \"comment\")\n\n        self.__extractClasses(hide_base_schemas)\n        if verbose: printDebug(\"Classes............: %d\" % len(self.classes), \"comment\")\n\n        self.__extractProperties()\n        if verbose: printDebug(\"Properties.........: %d\" % len(self.properties), \"comment\")\n        if verbose: printDebug(\"..annotation.......: %d\" % len(self.annotationProperties), \"comment\")\n        if verbose: printDebug(\"..datatype.........: %d\" % len(self.datatypeProperties), \"comment\")\n        if verbose: printDebug(\"..object...........: %d\" % len(self.objectProperties), \"comment\")\n\n        self.__extractSkosConcepts()\n        if verbose: printDebug(\"Concepts (SKOS)....: %d\" % len(self.skosConcepts), \"comment\")\n\n        self.__computeTopLayer()\n\n        self.__computeInferredProperties()\n\n        if verbose: printDebug(\"----------\", \"comment\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of the basic stats for a given object", "response": "def stats(self):\n        \"\"\" shotcut to pull out useful info for a graph \n\n        2016-08-18 the try/except is a dirty solution to a problem\n        emerging with counting graph lenght on cached Graph objects..\n        TODO: investigate what's going on..\n        \"\"\"\n        out = []\n        try:\n            out += [(\"Triples\", len(self.rdfgraph))]\n        except:\n            pass\n        out += [(\"Classes\", len(self.classes))]\n        out += [(\"Properties\", len(self.properties))]\n        out += [(\"Annotation Properties\", len(self.annotationProperties))]\n        out += [(\"Object Properties\", len(self.objectProperties))]\n        out += [(\"Datatype Properties\", len(self.datatypeProperties))]\n        out += [(\"Skos Concepts\", len(self.skosConcepts))]\n        # out += [(\"Individuals\", len(self.instances))]\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts all ontology class instances from the database and returns a list of Ontology class instances", "response": "def __extractOntologies(self, exclude_BNodes = False, return_string=False):\n        \"\"\"\n        returns Ontology class instances\n\n        [ a owl:Ontology ;\n            vann:preferredNamespacePrefix \"bsym\" ;\n            vann:preferredNamespaceUri \"http://bsym.bloomberg.com/sym/\" ],\n        \"\"\"\n        out = []\n\n        qres = self.queryHelper.getOntology()\n\n        if qres:\n            # NOTE: SPARQL returns a list of rdflib.query.ResultRow (~ tuples..)\n\n            for candidate in qres:\n                if isBlankNode(candidate[0]):\n                    if exclude_BNodes:\n                        continue\n                    else:\n                        checkDC_ID = [x for x in self.rdfgraph.objects(candidate[0], rdflib.namespace.DC.identifier)]\n                        if checkDC_ID:\n                            out += [Ontology(checkDC_ID[0], namespaces=self.namespaces),]\n                        else:\n                            vannprop = rdflib.URIRef(\"http://purl.org/vocab/vann/preferredNamespaceUri\")\n                            vannpref = rdflib.URIRef(\"http://purl.org/vocab/vann/preferredNamespacePrefix\")\n                            checkDC_ID = [x for x in self.rdfgraph.objects(candidate[0], vannprop)]\n                            if checkDC_ID:\n                                checkDC_prefix = [x for x in self.rdfgraph.objects(candidate[0], vannpref)]\n                                if checkDC_prefix:\n                                    out += [Ontology(checkDC_ID[0],\n                                                     namespaces=self.namespaces,\n                                                     prefPrefix=checkDC_prefix[0])]\n                                else:\n                                    out += [Ontology(checkDC_ID[0], namespaces=self.namespaces)]\n\n                else:\n                    out += [Ontology(candidate[0], namespaces=self.namespaces)]\n\n\n        else:\n            pass\n            # printDebug(\"No owl:Ontologies found\")\n\n        #finally... add all annotations/triples\n        self.ontologies = out\n        for onto in self.ontologies:\n            onto.triples = self.queryHelper.entityTriples(onto.uri)\n            onto._buildGraph()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract all classes from the database and creates a new one", "response": "def __extractClasses(self, hide_base_schemas=True):\n        \"\"\"\n        2015-06-04: removed sparql 1.1 queries\n        2015-05-25: optimized via sparql queries in order to remove BNodes\n        2015-05-09: new attempt\n\n        Note: queryHelper.getAllClasses() returns a list of tuples,\n        (class, classRDFtype)\n        so in some cases there are duplicates if a class is both RDFS.CLass and OWL.Class\n        In this case we keep only OWL.Class as it is more informative.\n        \"\"\"\n\n\n        self.classes = [] # @todo: keep adding?\n\n        qres = self.queryHelper.getAllClasses(hide_base_schemas=hide_base_schemas)\n\n        for class_tuple in qres:\n            \n            _uri = class_tuple[0]\n            try:\n                _type = class_tuple[1]\n            except:\n                _type= \"\"\n\n            test_existing_cl = self.getClass(uri=_uri)\n            if not test_existing_cl:\n                # create it\n                self.classes += [OntoClass(_uri, _type, self.namespaces)]\n            else:\n                # if OWL.Class over RDFS.Class - update it\n                if _type == rdflib.OWL.Class:\n                    test_existing_cl.rdftype = rdflib.OWL.Class\n\n\n\n        #add more data\n        for aClass in self.classes:\n\n            aClass.triples = self.queryHelper.entityTriples(aClass.uri)\n            aClass._buildGraph() # force construction of mini graph\n\n            aClass.queryHelper = self.queryHelper\n\n            # attach to an ontology\n            for uri in aClass.getValuesForProperty(rdflib.RDFS.isDefinedBy):\n                onto = self.getOntology(uri)\n                if onto:\n                    onto.classes += [aClass]\n                    aClass.ontology = onto\n\n            # add direct Supers\n            directSupers = self.queryHelper.getClassDirectSupers(aClass.uri)\n\n            for x in directSupers:\n                superclass = self.getClass(uri=x[0])\n                if superclass:\n                    aClass._parents.append(superclass)\n\n                    # add inverse relationships (= direct subs for superclass)\n                    if aClass not in superclass.children():\n                         superclass._children.append(aClass)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __extractProperties(self):\n        self.properties = [] # @todo: keep adding?\n        self.annotationProperties = []\n        self.objectProperties = []\n        self.datatypeProperties = []\n\n        qres = self.queryHelper.getAllProperties()\n\n        for candidate in qres:\n\n            test_existing_prop = self.getProperty(uri=candidate[0])\n            if not test_existing_prop:\n                # create it\n                self.properties += [OntoProperty(candidate[0], candidate[1], self.namespaces)]\n            else:\n                # update it\n                if candidate[1] and (test_existing_prop.rdftype == rdflib.RDF.Property):\n                    test_existing_prop.rdftype = inferMainPropertyType(candidate[1])\n\n\n        #add more data\n        for aProp in self.properties:\n\n            if aProp.rdftype == rdflib.OWL.DatatypeProperty:\n                self.datatypeProperties += [aProp]\n            elif aProp.rdftype == rdflib.OWL.AnnotationProperty:\n                self.annotationProperties += [aProp]\n            elif aProp.rdftype == rdflib.OWL.ObjectProperty:\n                self.objectProperties += [aProp]\n            else:\n                pass\n\n            aProp.triples = self.queryHelper.entityTriples(aProp.uri)\n            aProp._buildGraph() # force construction of mini graph\n\n            # attach to an ontology [2015-06-15: no property type distinction yet]\n            for uri in aProp.getValuesForProperty(rdflib.RDFS.isDefinedBy):\n                onto = self.getOntology(str(uri))\n                if onto:\n                    onto.properties += [aProp]\n                    aProp.ontology = onto\n\n\n\n            self.__buildDomainRanges(aProp)\n\n            # add direct Supers\n            directSupers = self.queryHelper.getPropDirectSupers(aProp.uri)\n\n            for x in directSupers:\n                superprop = self.getProperty(uri=x[0])\n                if superprop:\n                    aProp._parents.append(superprop)\n\n                    # add inverse relationships (= direct subs for superprop)\n                    if aProp not in superprop.children():\n                         superprop._children.append(aProp)", "response": "extract properties from the database and add them to the internal list of properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __buildDomainRanges(self, aProp):\n        domains = aProp.rdfgraph.objects(None, rdflib.RDFS.domain)\n        ranges =  aProp.rdfgraph.objects(None, rdflib.RDFS.range)\n\n        for x in domains:\n            if not isBlankNode(x):\n                aClass = self.getClass(uri=str(x))\n                if aClass:\n                    aProp.domains += [aClass]\n                    aClass.domain_of += [aProp]\n                else:\n                    aProp.domains += [x]  # edge case: it's not an OntoClass instance?\n\n        for x in ranges:\n            if not isBlankNode(x):\n                aClass = self.getClass(uri=str(x))\n                if aClass:\n                    aProp.ranges += [aClass]\n                    aClass.range_of += [aProp]\n                else:\n                    aProp.ranges += [x]", "response": "Build the domain and range details for a property."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting skos concepts from the skos instance and creates them if they don t exist", "response": "def __extractSkosConcepts(self):\n        \"\"\"\n        2015-08-19: first draft\n        \"\"\"\n        self.skosConcepts = [] # @todo: keep adding?\n\n        qres = self.queryHelper.getSKOSInstances()\n\n        for candidate in qres:\n\n            test_existing_cl = self.getSkosConcept(uri=candidate[0])\n            if not test_existing_cl:\n                # create it\n                self.skosConcepts += [OntoSKOSConcept(candidate[0], None, self.namespaces)]\n            else:\n                pass\n\n        #add more data\n        skos = rdflib.Namespace('http://www.w3.org/2004/02/skos/core#')\n\n        for aConcept in self.skosConcepts:\n\n            aConcept.rdftype = skos['Concept']\n            aConcept.triples = self.queryHelper.entityTriples(aConcept.uri)\n            aConcept._buildGraph() # force construction of mini graph\n\n            aConcept.queryHelper = self.queryHelper\n\n            # attach to an ontology\n            for uri in aConcept.getValuesForProperty(rdflib.RDFS.isDefinedBy):\n                onto = self.getOntology(str(uri))\n                if onto:\n                    onto.skosConcepts += [aConcept]\n                    aConcept.ontology = onto\n\n            # add direct Supers\n            directSupers = self.queryHelper.getSKOSDirectSupers(aConcept.uri)\n\n            for x in directSupers:\n                superclass = self.getSkosConcept(uri=x[0])\n                if superclass:\n                    aConcept._parents.append(superclass)\n\n                    # add inverse relationships (= direct subs for superclass)\n                    if aConcept not in superclass.children():\n                         superclass._children.append(aConcept)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning all properties valid for a class (as they have it in their domain) recursively ie traveling up the descendants tree Note: results in a list of dicts including itself Note [2]: all properties with no domain info are added at the top as [None, props] :return: [{<Class *http://xmlns.com/foaf/0.1/Person*>: [<Property *http://xmlns.com/foaf/0.1/currentProject*>,<Property *http://xmlns.com/foaf/0.1/familyName*>, etc....]}, {<Class *http://www.w3.org/2003/01/geo/wgs84_pos#SpatialThing*>: [<Property *http://xmlns.com/foaf/0.1/based_near*>, etc...]}, ]", "response": "def getInferredPropertiesForClass(self, aClass, rel=\"domain_of\"):\n        \"\"\"\n        returns all properties valid for a class (as they have it in their domain)\n        recursively ie traveling up the descendants tree\n        Note: results in a list of dicts including itself\n        Note [2]: all properties with no domain info are added at the top as [None, props]\n\n        :return:\n        [{<Class *http://xmlns.com/foaf/0.1/Person*>:\n            [<Property *http://xmlns.com/foaf/0.1/currentProject*>,<Property *http://xmlns.com/foaf/0.1/familyName*>,\n                etc....]},\n        {<Class *http://www.w3.org/2003/01/geo/wgs84_pos#SpatialThing*>:\n            [<Property *http://xmlns.com/foaf/0.1/based_near*>, etc...]},\n            ]\n        \"\"\"\n        _list = []\n\n        if rel==\"domain_of\":\n            _list.append({aClass: aClass.domain_of})\n            for x in aClass.ancestors():\n                if x.domain_of:\n                    _list.append({x: x.domain_of})\n\n            # add properties from Owl:Thing ie the inference layer\n\n            topLevelProps = [p for p in self.properties if p.domains == []]\n            if topLevelProps:\n                _list.append({self.OWLTHING: topLevelProps})\n\n        elif rel==\"range_of\":\n            _list.append({aClass: aClass.range_of})\n            for x in aClass.ancestors():\n                if x.domain_of:\n                    _list.append({x: x.range_of})\n\n            # add properties from Owl:Thing ie the inference layer\n\n            topLevelProps = [p for p in self.properties if p.ranges == []]\n            if topLevelProps:\n                _list.append({self.OWLTHING: topLevelProps})\n\n        return _list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getClass(self, id=None, uri=None, match=None):\n\n        if not id and not uri and not match:\n            return None\n\n        if type(id) == type(\"string\"):\n            uri = id\n            id = None\n            if not uri.startswith(\"http://\"):\n                match = uri\n                uri = None\n        if match:\n            if type(match) != type(\"string\"):\n                return []\n            res = []\n            if \":\" in match: # qname\n                for x in self.classes:\n                    if match.lower() in x.qname.lower():\n                        res += [x]\n            else:\n                for x in self.classes:\n                    if match.lower() in x.uri.lower():\n                        res += [x]\n            return res\n        else:\n            for x in self.classes:\n                if id and x.id == id:\n                    return x\n                if uri and x.uri.lower() == uri.lower():\n                    return x\n            return None", "response": "get the saved - class with given ID or via other methods"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the saved - class with given ID or via other methods...", "response": "def getProperty(self, id=None, uri=None, match=None):\n        \"\"\"\n        get the saved-class with given ID or via other methods...\n\n        Note: analogous to getClass method\n        \"\"\"\n\n        if not id and not uri and not match:\n            return None\n\n        if type(id) == type(\"string\"):\n            uri = id\n            id = None\n            if not uri.startswith(\"http://\"):\n                match = uri\n                uri = None\n        if match:\n            if type(match) != type(\"string\"):\n                return []\n            res = []\n            if \":\" in match: # qname\n                for x in self.properties:\n                    if match.lower() in x.qname.lower():\n                        res += [x]\n            else:\n                for x in self.properties:\n                    if match.lower() in x.uri.lower():\n                        res += [x]\n            return res\n        else:\n            for x in self.properties:\n                if id and x.id == id:\n                    return x\n                if uri and x.uri.lower() == uri.lower():\n                    return x\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getSkosConcept(self, id=None, uri=None, match=None):\n\n        if not id and not uri and not match:\n            return None\n\n        if type(id) == type(\"string\"):\n            uri = id\n            id = None\n            if not uri.startswith(\"http://\"):\n                match = uri\n                uri = None\n        if match:\n            if type(match) != type(\"string\"):\n                return []\n            res = []\n            if \":\" in match: # qname\n                for x in self.skosConcepts:\n                    if match.lower() in x.qname.lower():\n                        res += [x]\n            else:\n                for x in self.skosConcepts:\n                    if match.lower() in x.uri.lower():\n                        res += [x]\n            return res\n        else:\n            for x in self.skosConcepts:\n                if id and x.id == id:\n                    return x\n                if uri and x.uri.lower() == uri.lower():\n                    return x\n            return None", "response": "get the saved skos concept with given ID or via other methods..."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getEntity(self, id=None, uri=None, match=None):\n\n        if not id and not uri and not match:\n            return None\n\n        if type(id) == type(\"string\"):\n            uri = id\n            id = None\n            if not uri.startswith(\"http://\"):\n                match = uri\n                uri = None\n        if match:\n            if type(match) != type(\"string\"):\n                return []\n            res = []\n            if \":\" in match: # qname\n                for x in self.classes:\n                    if match.lower() in x.qname.lower():\n                        res += [x]\n                for x in self.properties:\n                    if match.lower() in x.qname.lower():\n                        res += [x]\n            else:\n                for x in self.classes:\n                    if match.lower() in x.uri.lower():\n                        res += [x]\n                for x in self.properties:\n                    if match.lower() in x.uri.lower():\n                        res += [x]\n            return res\n        else:\n            for x in self.classes:\n                if id and x.id == id:\n                    return x\n                if uri and x.uri.lower() == uri.lower():\n                    return x\n            for x in self.properties:\n                if id and x.id == id:\n                    return x\n                if uri and x.uri.lower() == uri.lower():\n                    return x\n            return None", "response": "get a generic entity with given ID or via other methods..."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getOntology(self, id=None, uri=None, match=None):\n\n        if not id and not uri and not match:\n            return None\n\n        if type(id) == type(\"string\"):\n            uri = id\n            id = None\n            if not uri.startswith(\"http://\"):\n                match = uri\n                uri = None\n        if match:\n            if type(match) != type(\"string\"):\n                return []\n            res = []\n            for x in self.ontologies:\n                if match.lower() in x.uri.lower():\n                    res += [x]\n            return res\n        else:\n            for x in self.ontologies:\n                if id and x.id == id:\n                    return x\n                if uri and x.uri.lower() == uri.lower():\n                    return x\n            return None", "response": "get the saved - ontology with given ID or via other methods..."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the next class in the list of classes. If it s the last one returns the first one. If it s the last one returns the first one.", "response": "def nextClass(self, classuri):\n        \"\"\"Returns the next class in the list of classes. If it's the last one, returns the first one.\"\"\"\n        if classuri == self.classes[-1].uri:\n            return self.classes[0]\n        flag = False\n        for x in self.classes:\n            if flag == True:\n                return x\n            if x.uri == classuri:\n                flag = True\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nextProperty(self, propuri):\n        if propuri == self.properties[-1].uri:\n            return self.properties[0]\n        flag = False\n        for x in self.properties:\n            if flag == True:\n                return x\n            if x.uri == propuri:\n                flag = True\n        return None", "response": "Returns the next property in the list of properties. If it s the last one returns the first one. If it s the first one returns the last one. If it s the last one returns the first one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nextConcept(self, concepturi):\n        if concepturi == self.skosConcepts[-1].uri:\n            return self.skosConcepts[0]\n        flag = False\n        for x in self.skosConcepts:\n            if flag == True:\n                return x\n            if x.uri == concepturi:\n                flag = True\n        return None", "response": "Returns the next skos concept in the list of concepts. Returns None if there is no next skos concept."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting nicely into stdout the SKOS tree of an ontology.", "response": "def printSkosTree(self, element = None, showids=False, labels=False, showtype=False):\n        \"\"\"\n        Print nicely into stdout the SKOS tree of an ontology\n\n        Note: indentation is made so that ids up to 3 digits fit in, plus a space.\n        [123]1--\n        [1]123--\n        [12]12--\n        \"\"\"\n        TYPE_MARGIN = 13 # length for skos:concept\n\n        if not element:\t # first time\n            for x in self.toplayerSkosConcepts:\n                printGenericTree(x, 0, showids, labels, showtype, TYPE_MARGIN)\n\n        else:\n            printGenericTree(element, 0, showids, labels, showtype, TYPE_MARGIN)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef highlight(code, lexer, **kwargs):\n    if highlighter is None:\n        return '<pre>%s</pre>' % code\n    return highlighter(code or '', get_lexer_by_name(lexer), HtmlFormatter(**kwargs))", "response": "Highlights given code using the given lexer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhighlighting the given nodelist in the given context.", "response": "def highlight_block(context, nodelist, lexer, **kwargs):\n    \"\"\"\n    Code is nodelist ``rendered`` in ``context``\n    Returns highlighted code ``div`` tag from ``HtmlFormatter``\n    Lexer is guessed by ``lexer`` name\n    arguments are passed into the formatter\n\n        Syntax::\n\n            {% highlight_block [lexer name] [formatter options] %}\n                ... source code ..\n            {% endhighlight_block %}\n\n        Example::\n\n            {% highlight_block python linenos=true %}\n                print '{{ request.path }}'\n            {% endhighlight_block %}\n    \"\"\"\n    if highlighter is None:\n        return '<pre>%s</pre>' % str(nodelist.render(context) or '')\n    return highlighter(nodelist.render(context) or '', get_lexer_by_name(lexer), HtmlFormatter(**kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying a warning message.", "response": "def warning(message, code='WARNING'):\n    \"\"\"Display Warning.\n\n    Method prints the warning message, message being given\n    as an input.\n\n    Arguments:\n        message {string} -- The message to be displayed.\n    \"\"\"\n\n    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    output = now + ' [' + torn.plugins.colors.WARNING + \\\n            code + torn.plugins.colors.ENDC + '] \\t' + \\\n            message\n    print(output)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisplaying Information. Method prints the information message, message being given as an input. Arguments: message {string} -- The message to be displayed.", "response": "def info(message, code='INFO'):\n    \"\"\"Display Information.\n\n    Method prints the information message, message being given\n    as an input.\n\n    Arguments:\n        message {string} -- The message to be displayed.\n    \"\"\"\n\n    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    output = now + ' [' + torn.plugins.colors.OKBLUE + \\\n            code + torn.plugins.colors.ENDC + '] \\t' + \\\n            message\n    print(output)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay Error. Method prints the error message and code", "response": "def error(message, code='ERROR'):\n    \"\"\"Display Error.\n\n    Method prints the error message, message being given\n    as an input.\n\n    Arguments:\n        message {string} -- The message to be displayed.\n    \"\"\"\n    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    output = now + ' [' + torn.plugins.colors.FAIL + \\\n            code + torn.plugins.colors.ENDC + '] \\t' + \\\n            message\n    print(output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self, template, **data):\n        if(type(template) != str):\n            raise TypeError(\"String expected\")\n        \n        env = Environment(\n            loader=FileSystemLoader(os.getcwd() + '/View'),\n            autoescape=select_autoescape()\n        )\n\n        template = env.get_template(template)\n        return self.finish(template.render(data))", "response": "Renders the template using Jinja2 with given data arguments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match(self, row):\n        for condition in self._conditions:\n            if condition.match(row):\n                return True\n\n        return False", "response": "Returns True if the row matches one or more child conditions. Returns False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wait_until(time_label):\n    '''\n    Calculates the number of seconds that the process needs to sleep \n    '''\n    if time_label == 'next_minute':\n        gevent.sleep(60 - int(time.time()) % 60)\n    elif time_label == 'next_hour':\n        gevent.sleep(3600 - int(time.time()) % 3600)\n    elif time_label == 'tomorrow':\n        gevent.sleep(86400 - int(time.time()) % 86400)", "response": "Calculates the number of seconds that the process needs to sleep \n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the next occurrence of the next entry in the sequence.", "response": "def next(self):\n        '''\n        Never return StopIteration\n        '''\n        if self.started is False:\n\n            self.started = True\n            now_ = datetime.now()\n            if self.hour:\n                # Fixed hour in a day\n                # Next run will be the next day\n                scheduled = now_.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=0)\n                if scheduled == now_:\n                    return timedelta(seconds=0)\n                elif scheduled < now_:\n                    # Scheduled time is passed\n                    return scheduled.replace(day=now_.day + 1) - now_\n            else:\n                # Every hour in a day\n                # Next run will be the next hour\n                scheduled = now_.replace(minute=self.minute, second=self.second, microsecond=0)\n                if scheduled == now_:\n                    return timedelta(seconds=0)\n                elif scheduled < now_:\n                    # Scheduled time is passed\n                    return scheduled.replace(hour=now_.hour + 1) - now_\n            return scheduled - now_\n        else:\n            if self.hour:\n                return timedelta(days=1)  # next day\n            return timedelta(hours=1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef schedule(self, name, timer, func, *args, **kwargs):\n        '''\n        ts = Scheduler('my_task')\n        ts.schedule(every(seconds=10), handle_message, \"Every 10 seconds\")\n        ts.schedule(every(seconds=30), fetch_url, url=\"http://yahoo.com\", section=\"stock_ticker\")\n        ts.run_forever()\n        '''\n        self.tasks.append(Task(name, func, timer, *args, **kwargs))\n        self.active[name] = []  # list of greenlets\n        self.waiting[name] = []", "response": "Schedule a task for execution."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unschedule(self, task_name):\n        '''\n        Removes a task from scheduled jobs but it will not kill running tasks\n        '''\n        for greenlet in self.waiting[task_name]:\n            try:\n                gevent.kill(greenlet)\n            except BaseException:\n                pass", "response": "Removes a task from scheduled jobs but will not kill running tasks"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop_task(self, task_name):\n        '''\n        Stops a running or dead task\n        '''\n        for greenlet in self.active[task_name]:\n            try:\n                # Do not need to check if greenlet is dead, gevent does it already\n                gevent.kill(greenlet)\n                self.active[task_name] = []\n            except BaseException:\n                pass", "response": "Stops a running or dead task"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _remove_dead_greenlet(self, task_name):\n        '''\n        Removes dead greenlet or done task from active list\n        '''\n        for greenlet in self.active[task_name]:\n            try:\n                # Allows active greenlet continue to run\n                if greenlet.dead:\n                    self.active[task_name].remove(greenlet)\n            except BaseException:\n                pass", "response": "Removes dead greenlet or done task from active list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self, task):\n        '''\n        Runs a task and re-schedule it\n        '''\n        self._remove_dead_greenlet(task.name)\n        if isinstance(task.timer, types.GeneratorType):\n            # Starts the task immediately\n            greenlet_ = gevent.spawn(task.action, *task.args, **task.kwargs)\n            self.active[task.name].append(greenlet_)\n            try:\n                # total_seconds is available in Python 2.7\n                greenlet_later = gevent.spawn_later(task.timer.next().total_seconds(), self.run, task)\n                self.waiting[task.name].append(greenlet_later)\n                return greenlet_, greenlet_later\n            except StopIteration:\n                pass\n            return greenlet_, None\n        # Class based timer\n        try:\n            if task.timer.started is False:\n                delay = task.timer.next().total_seconds()\n                gevent.sleep(delay)\n                greenlet_ = gevent.spawn(task.action, *task.args, **task.kwargs)\n                self.active[task.name].append(greenlet_)\n            else:\n                greenlet_ = gevent.spawn(task.action, *task.args, **task.kwargs)\n                self.active[task.name].append(greenlet_)\n            greenlet_later = gevent.spawn_later(task.timer.next().total_seconds(), self.run, task)\n            self.waiting[task.name].append(greenlet_later)\n            return greenlet_, greenlet_later\n        except StopIteration:\n            pass\n        return greenlet_, None", "response": "Runs a task and re - schedules it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun all assigned tasks in separate green threads.", "response": "def run_tasks(self):\n        '''\n        Runs all assigned task in separate green threads. If the task should not be run, schedule it\n        '''\n        pool = Pool(len(self.tasks))\n        for task in self.tasks:\n            # Launch a green thread to schedule the task\n            # A task will be managed by 2 green thread: execution thread and scheduling thread\n            pool.spawn(self.run, task)\n        return pool"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the scheduler for the given time period.", "response": "def run_forever(self, start_at='once'):\n        \"\"\"\n        Starts the scheduling engine\n        \n        @param start_at: 'once' -> start immediately\n                         'next_minute' -> start at the first second of the next minutes\n                         'next_hour' -> start 00:00 (min) next hour\n                         'tomorrow' -> start at 0h tomorrow\n        \"\"\"\n        if start_at not in ('once', 'next_minute', 'next_hour', 'tomorrow'):\n            raise ValueError(\"start_at parameter must be one of these values: 'once', 'next_minute', 'next_hour', 'tomorrow'\")\n        if start_at != 'once':\n            wait_until(start_at)\n        try:\n            task_pool = self.run_tasks()\n            while self.running:\n                gevent.sleep(seconds=1)\n            task_pool.join(timeout=30)\n            task_pool.kill()\n        except KeyboardInterrupt:\n            # https://github.com/surfly/gevent/issues/85\n            task_pool.closed = True\n            task_pool.kill()\n            logging.getLogger(self.logger_name).info('Time scheduler quits')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef aba_onto2nx(str_gr_id=10):\n    netw = nx.DiGraph()\n\n    # Downloading and parsing json structure graph\n    r = requests.get(url=ABA_API_FORMAT.format(str_gr_id))\n    str_gr_json = r.json()\n\n    def add_children(tree, netw):\n        for child in tree['children']:\n            child_dct = {key: value for key, value in child.items() if key not in ['children', 'id']}\n            # not including children information into the attributes\n            # while it will be edges\n            netw.add_node(child['id'], attr_dict=child_dct)\n            netw.add_edge(tree['id'], child['id'])\n            add_children(child, netw)\n\n    # Putting information into the network\n    # Edge case for the recursive function\n    root = str_gr_json['msg'][0]\n    root_dct = {key: value for key, value in root.items() if key not in ['children', 'id']}\n    netw.add_node(root['id'], attr_dict=root_dct)\n\n    add_children(root, netw)\n\n    return netw", "response": "Downloads and parses the Allen Brain Atlas ontology into a network object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate or append a file handle to a zip file.", "response": "def create_or_append_to_zip(file_handle, zip_path, arc_name=None):\n    \"\"\"\n    Append file_handle to given zip_path with name arc_name if given, else file_handle. zip_path will be created.\n    :param file_handle: path to file or file-like object\n    :param zip_path: path to zip archive\n    :param arc_name: optional filename in archive\n    \"\"\"\n    with zipfile.ZipFile(zip_path, 'a') as my_zip:\n        if arc_name:\n            my_zip.write(file_handle, arc_name)\n        else:\n            my_zip.write(file_handle)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef zipdir(src_path, target_path, wrapdir=''):\n\n    zipf = zipfile.ZipFile(target_path, 'w', zipfile.ZIP_DEFLATED)\n\n    for root, dirs, files in os.walk(src_path):\n        for file in files:\n            path = os.path.join(root, file)\n            # get the relative path from the src_path in order to avoid an archive\n            # of absolute paths including your home directory.\n            rel_path = os.path.relpath(path, src_path)\n            zipf.write(path, os.path.join(wrapdir, rel_path))\n\n    zipf.close()", "response": "Zips the directory src_path into target_path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode(self):\n        element = ElementTree.Element(self.name)\n        element = self._set_nil(element, lambda value: str(value))\n        return element", "response": "Encodes the value of the field and puts it in the element tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(input_filename, format):\n\n    # open the file & convert to wav\n    song_data = AudioSegment.from_file(input_filename, format=format)\n    song_data = song_data.set_channels(1)  # convert to mono\n    wav_tmp = song_data.export(format=\"wav\")  # write to a tmp file buffer\n    wav_tmp.seek(0)\n    rate, wav_data = wavfile.read(wav_tmp)\n\n    rows_per_second = (1 + (rate - WIDTH)) // FRAME_STRIDE\n\n    # Calculate a coarser window for matching\n    window_size = (rows_per_second // TIME_STRIDE, (WIDTH // 2) // FREQ_STRIDE)\n    peaks = resound.get_peaks(np.array(wav_data), window_size=window_size)\n\n    # half width (nyquist freq) & half size (window is +/- around the middle)\n    f_width = WIDTH // (2 * FREQ_STRIDE) * 2\n    t_gap = 1 * rows_per_second\n    t_width = 2 * rows_per_second\n    fingerprints = resound.hashes(peaks, f_width=f_width, t_gap=t_gap, t_width=t_width)  # hash, offset pairs\n\n    return fingerprints", "response": "Calculate the fingerprint hashses of the referenced audio file and save it to disk as a pickle file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_header(self):\n        with open(self.filepath, 'rb') as instrumentDataFile:\n            while True:\n                sync = instrumentDataFile.read(1)\n                if not sync:\n                    break\n                elif sync == '\\xa5':\n                    id = instrumentDataFile.read(1)\n                    if id == '\\x05':\n                        instrumentDataFile.seek(instrumentDataFile.tell() - 2)\n                        hardwareConfiguration = nortek.structures.Header(\n                                instrumentDataFile.read(48)) # always\n                        headConfiguration = nortek.structures.Header(\n                                instrumentDataFile.read(224)) # always\n                        userConfiguration = nortek.structures.Header(\n                                instrumentDataFile.read(512)) # always\n                        self.endOfConfiguration = instrumentDataFile.tell()\n                        if (hardwareConfiguration.checksum and \n                            headConfiguration.checksum and \n                            userConfiguration.checksum):\n                            self[ 'hardwareConfiguration' ] = hardwareConfiguration\n                            self[ 'headConfiguration' ] = headConfiguration\n                            self[ 'userConfiguration' ] = userConfiguration\n                            self[ 'type' ] = self[ 'hardwareConfiguration' ].interpretBinaryData()\n                            self[ 'headConfiguration' ].interpretBinaryData(self[ 'type' ])\n                            self[ 'userConfiguration' ].interpretBinaryData(self[ 'type' ])\n                            break\n                        else:\n                            pdb.set_trace()\n                            # there were problems, try to figure out what\n                            print(\"\"\"Checksum failure in the header. Checksum values are \n\t\t\t\t\t\t\t\thardware: {}\n\t\t\t\t\t\t\t\thead: {}\n\t\t\t\t\t\t\t\tuser: {}\n\t\t\t\t\t\t\t\tData file position is {}\"\"\".format(\n\t\t\t\t\t\t\t\t\tself[ 'hardwareConfiguration' ].checksum,\n\t\t\t\t\t\t\t\t\tself[ 'headConfiguration' ].checksum,\n\t\t\t\t\t\t\t\t\tself[ 'userConfiguration' ].checksum,\n\t\t\t\t\t\t\t\t\tinstrumentDataFile.tell()))", "response": "Read the header of the A505 and A504 A500 file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats the log entry template with that of fields", "response": "def format(self, template=None):\n        \"\"\" Substitutes variables within template with that of fields'\n        \"\"\"\n        pattern = r\"(?:<([^<]*?)\\$(\\w+)([^>]*?)>)\"\n        s = sub(pattern, self._format_repl, template or self.template)\n        s = self._str_fix_whitespace(s)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart the authentication process.", "response": "def begin(request, provider):\n    \"\"\"\n        Display authentication form. This is also the first step\n        in registration. The actual login is in social_complete\n        function below.\n    \"\"\"\n    # store url to where user will be redirected\n    request.session['next_url'] = request.GET.get(\"next\") or settings.LOGIN_REDIRECT_URL\n\n    # start the authentication process\n    backend = get_backend(provider)\n    return backend.begin(request, dict(request.REQUEST.items()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompletes net ID authentication.", "response": "def complete(request, provider):\n    \"\"\"\n        After first step of net authentication, we must validate the response.\n        If everything is ok, we must do the following:\n        1. If user is already authenticated:\n            a. Try to login him again (strange variation but we must take it to account).\n            b. Create new netID record in database.\n            c. Merge authenticated account with newly created netID record.\n            d. Redirect user to 'next' url stored in session.\n        2. If user is anonymouse:\n            a. Try to log him by identity and redirect to 'next' url.\n            b. Create new  netID record in database.\n            c. Try to automaticaly fill all extra fields with information returned form\n            server. If successfull, login the user and redirect to 'next' url.\n            d. Redirect user to extra page where he can fill all extra fields by hand.\n    \"\"\"\n    # merge data from POST and GET methods\n    data = request.GET.copy()\n    data.update(request.POST)\n\n    # In case of skipping begin step.\n    if 'next_url' not in request.session:\n        request.session['next_url'] = request.GET.get(\"next\") or settings.LOGIN_REDIRECT_URL\n\n    backend = get_backend(provider)\n    response = backend.validate(request, data)\n\n    if isinstance(response, HttpResponseRedirect):\n        return response\n    if request.user.is_authenticated():\n        success = backend.login_user(request)\n        backend.merge_accounts(request)\n    else:\n        success = backend.login_user(request)\n        if not success and not settings.REGISTRATION_ALLOWED:\n            messages.warning(request, lang.REGISTRATION_DISABLED)\n            return redirect(settings.REGISTRATION_DISABLED_REDIRECT)\n    if success:\n        return redirect(request.session.pop('next_url', settings.LOGIN_REDIRECT_URL))\n    return backend.complete(request, response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extra(request, provider):\n    identity = request.session.get('identity', None)\n    if not identity:\n        raise Http404\n\n    if request.method == \"POST\":\n        form = str_to_class(settings.EXTRA_FORM)(request.POST)\n        if form.is_valid():\n            user = form.save(request, identity, provider)\n            del request.session['identity']\n            if not settings.ACTIVATION_REQUIRED:\n                user = auth.authenticate(identity=identity, provider=provider)\n                if user:\n                    auth.login(request, user)\n                    return redirect(request.session.pop('next_url', settings.LOGIN_REDIRECT_URL))\n            else:\n                messages.warning(request, lang.ACTIVATION_REQUIRED_TEXT)\n                return redirect(settings.ACTIVATION_REDIRECT_URL)\n    else:\n        initial = request.session['extra']\n        form = str_to_class(settings.EXTRA_FORM)(initial=initial)\n\n    return render_to_response('netauth/extra.html', {'form': form }, context_instance=RequestContext(request))", "response": "Handle registration of new user with extra data for profile\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all members of an object sorted by name. Optionally only return members that satisfy a given predicate. Optionally only return members that satisfy a given predicate.", "response": "def getmembers(object, predicate=None):\n    \"\"\"Return all members of an object as (name, value) pairs sorted by name.\n    Optionally, only return members that satisfy a given predicate.\"\"\"\n    if inspect.isclass(object):\n        mro = (object,) + inspect.getmro(object)\n    else:\n        mro = ()\n    results = []\n    processed = set()\n    names = dir(object)\n    # :dd any DynamicClassAttributes to the list of names if object is a class;\n    # this may result in duplicate entries if, for example, a virtual\n    # attribute with the same name as a DynamicClassAttribute exists\n    try:\n        for base in object.__bases__:\n            for k, v in base.__dict__.items():\n                if isinstance(v, types.DynamicClassAttribute):\n                    names.append(k)\n    except AttributeError:\n        pass\n    for key in names:\n        # First try to get the value via getattr.  Some descriptors don't\n        # like calling their __get__ (see bug #1785), so fall back to\n        # looking in the __dict__.\n        try:\n            value = getattr(object, key)\n            # handle the duplicate key\n            if key in processed:\n                raise AttributeError\n        except AttributeError:\n            for base in mro:\n                if key in base.__dict__:\n                    value = base.__dict__[key]\n                    break\n            else:\n                # could be a (currently) missing slot member, or a buggy\n                # __dir__; discard and move on\n                continue\n        except Exception as e:\n            value = (RAISES_EXCEPTION, e)\n        if not predicate or predicate(value):\n            results.append((key, value))\n        processed.add(key)\n    results.sort(key=lambda pair: pair[0])\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _wrap(obj, wrapper=None, methods_to_add=(), name=None, skip=(), wrap_return_values=False, wrap_filenames=(),\n          filename=None, wrapped_name_func=None, wrapped=None):\n    \"\"\"\n    Wrap module, class, function or another variable recursively\n\n    :param Any obj: Object to wrap recursively\n    :param Optional[Callable] wrapper: Wrapper to wrap functions and methods in (accepts function as argument)\n    :param Collection[Callable] methods_to_add: Container of functions, which accept class as argument, and return \\\n    tuple of method name and method to add to all classes\n    :param Optional[str] name: Name of module to wrap to (if `obj` is module)\n    :param Collection[Union[str, type, Any]] skip: Items to skip wrapping (if an item of a collection is the str, wrap \\\n    will check the obj name, if an item of a collection is the type, wrap will check the obj type, else wrap will \\\n    check an item itself)\n    :param bool wrap_return_values: If try, wrap return values of callables (only types, supported by wrap function \\\n    are supported)\n    :param Collection[str] wrap_filenames: Files to wrap\n    :param Optional[str] filename: Source file of `obj`\n    :param Optional[Callable[Any, str]] wrapped_name_func: Function that accepts `obj` as argument and returns the \\\n    name of wrapped `obj` that will be written into wrapped `obj`\n    :param Any wrapped: Object to wrap to\n    :return: Wrapped `obj`\n    \"\"\"\n    # noinspection PyUnresolvedReferences\n    class ModuleProxy(types.ModuleType, Proxy):\n        # noinspection PyShadowingNames\n        def __init__(self, name, doc=None):\n            super().__init__(name=name, doc=doc)\n\n    try:\n        # Subclassing from obj to pass isinstance(some_object, obj) checks. If defining the class fails, it means that\n        # `obj` was not a class, that means ClassProxy wouldn't be used, we can create a dummy class.\n        class ClassProxy(obj, Proxy):\n            @staticmethod\n            def __new__(cls, *args, **kwargs):\n                # noinspection PyUnresolvedReferences\n                original_obj_object = cls._original_obj(*args, **kwargs)\n                # noinspection PyArgumentList\n                result = _wrap(obj=original_obj_object,\n                               wrapper=wrapper,\n                               methods_to_add=methods_to_add,\n                               name=name,\n                               skip=skip,\n                               wrap_return_values=wrap_return_values,\n                               wrap_filenames=wrap_filenames,\n                               filename=filename,\n                               wrapped_name_func=wrapped_name_func)\n                return result\n    except TypeError:\n        class ClassProxy(Proxy):\n            pass\n\n    class ObjectProxy(Proxy):\n        pass\n\n    # noinspection PyShadowingNames\n    def get_name(*names):\n        name = None\n        for obj in names:\n            try:\n                name = obj.__name__\n            except AttributeError:\n                if isinstance(obj, str):\n                    name = obj\n            if name is not None:\n                return name\n        return name\n\n    # noinspection PyShadowingNames\n    def make_key(obj, wrapper, methods_to_add, name, skip, wrap_return_values, wrap_filenames, filename,\n                 wrapped_name_func):\n        try:\n            obj_key = 'hash', hash(obj)\n        except TypeError:\n            obj_key = 'id', id(obj)\n        return obj_key + (wrapper, methods_to_add, name, skip, wrap_return_values, wrap_filenames, filename,\n                          wrapped_name_func)\n\n    # noinspection PyShadowingNames\n    def wrap_(obj, name, members, wrapped=None):\n        def get_obj_type():\n            if inspect.ismodule(object=obj):\n                result = ObjectType.MODULE\n            elif inspect.isclass(object=obj):\n                result = ObjectType.CLASS\n            elif (inspect.isbuiltin(object=obj) or\n                  inspect.isfunction(object=obj) or\n                  inspect.ismethod(object=obj) or\n                  inspect.ismethoddescriptor(object=obj) or\n                  isinstance(obj, MethodWrapper)):\n                result = ObjectType.FUNCTION_OR_METHOD\n            elif inspect.iscoroutine(object=obj):\n                result = ObjectType.COROUTINE\n            else:\n                result = ObjectType.OBJECT\n            return result\n\n        def create_proxy(proxy_type):\n            return {\n                ProxyType.MODULE: ModuleProxy(name=name),\n                ProxyType.CLASS: ClassProxy,\n                ProxyType.OBJECT: ObjectProxy(),\n            }[proxy_type]\n\n        def add_methods():\n            for method_to_add in methods_to_add:\n                method_name, method = method_to_add(wrapped)\n                if method is not None:\n                    setattr(wrapped, method_name, method)\n\n        def set_original_obj():\n            with suppress(AttributeError):\n                what = type if obj_type == ObjectType.CLASS else object\n                what.__setattr__(wrapped, wrapped_name_func(obj), obj)\n\n        def need_to_wrap():\n            return is_magic_name(name=attr_name) and attr_name not in ['__class__', '__new__']\n\n        obj_type = get_obj_type()\n        if wrapped is None:\n            if obj_type in [ObjectType.MODULE, ObjectType.CLASS]:\n                wrapped = create_proxy(proxy_type=ProxyType.MODULE if inspect.ismodule(obj) else ProxyType.CLASS)\n            elif obj_type == ObjectType.FUNCTION_OR_METHOD:\n                wrapped = function_or_method_wrapper()\n            elif obj_type == ObjectType.COROUTINE:\n                wrapped = coroutine_wrapper()\n            else:\n                wrapped = create_proxy(proxy_type=ProxyType.OBJECT)\n        key = make_key(obj=obj,\n                       wrapper=wrapper,\n                       methods_to_add=methods_to_add,\n                       name=name,\n                       skip=skip,\n                       wrap_return_values=wrap_return_values,\n                       wrap_filenames=wrap_filenames,\n                       filename=filename,\n                       wrapped_name_func=wrapped_name_func)\n        _wrapped_objs[key] = wrapped\n        set_original_obj()\n        if obj_type in [ObjectType.FUNCTION_OR_METHOD, ObjectType.COROUTINE]:\n            return wrapped\n        add_methods()\n        if obj_type == ObjectType.CLASS:\n            for attr_name, attr_value in members:\n                if need_to_wrap():\n                    raises_exception = (isinstance(attr_value, tuple) and\n                                        len(attr_value) > 0 and\n                                        attr_value[0] == RAISES_EXCEPTION)\n                    if raises_exception and not obj_type == ObjectType.MODULE:\n                        def raise_exception(self):\n                            _ = self\n                            raise attr_value[1]\n                        attr_value = property(raise_exception)\n                    with suppress(AttributeError, TypeError):\n                        # noinspection PyArgumentList\n                        attr_value_new = _wrap(obj=attr_value,\n                                               wrapper=wrapper,\n                                               methods_to_add=methods_to_add,\n                                               name=get_name(attr_value, attr_name),\n                                               skip=skip,\n                                               wrap_return_values=wrap_return_values,\n                                               wrap_filenames=wrap_filenames,\n                                               filename=get_obj_file(obj=attr_value) or filename,\n                                               wrapped_name_func=wrapped_name_func)\n                        with suppress(Exception):\n                            type.__setattr__(wrapped, attr_name, attr_value_new)\n        if obj_type != ObjectType.CLASS:\n            wrapped_class_name = get_name(obj.__class__)\n            # noinspection PyArgumentList\n            wrapped_class = _wrap(obj=obj.__class__,\n                                  wrapper=wrapper,\n                                  methods_to_add=methods_to_add,\n                                  name=wrapped_class_name,\n                                  skip=skip,\n                                  wrap_return_values=wrap_return_values,\n                                  wrap_filenames=wrap_filenames,\n                                  filename=get_obj_file(obj=obj.__class__) or filename,\n                                  wrapped_name_func=wrapped_name_func,\n                                  wrapped=wrapped.__class__)\n            object.__setattr__(wrapped, '__class__', wrapped_class)\n        return wrapped\n\n    def wrap_return_values_(result):\n        if wrap_return_values:\n            # noinspection PyArgumentList\n            result = _wrap(obj=result,\n                           wrapper=wrapper,\n                           methods_to_add=methods_to_add,\n                           name=get_name(result, 'result'),\n                           skip=skip,\n                           wrap_return_values=wrap_return_values,\n                           wrap_filenames=wrap_filenames,\n                           filename=filename,\n                           wrapped_name_func=wrapped_name_func)\n        return result\n\n    # noinspection PyShadowingNames\n    def is_magic_name(name):\n        return name.startswith('__') and name.endswith('__')\n\n    # noinspection PyShadowingNames\n    def is_magic(obj):\n        return is_magic_name(name=obj.__name__)\n\n    # noinspection PyShadowingNames\n    def is_coroutine_function(obj, wrapper):\n        return inspect.iscoroutinefunction(object=wrapper(obj)) and not is_magic(obj=obj)\n\n    # noinspection PyShadowingNames\n    def wrap_call_and_wrap_return_values(obj, wrapper):\n        if is_coroutine_function(obj=obj, wrapper=wrapper):\n            # noinspection PyShadowingNames\n            @wraps(obj)\n            async def wrapper(*args, **kwargs):\n                return wrap_return_values_(result=await obj(*args, **kwargs))\n        else:\n            # noinspection PyShadowingNames\n            @wraps(obj)\n            def wrapper(*args, **kwargs):\n                return wrap_return_values_(result=obj(*args, **kwargs))\n        return wrapper\n\n    def function_or_method_wrapper():\n        # noinspection PyShadowingNames\n        @wraps(obj)\n        def wrapped_obj(*args, **kwargs):\n            return wrapper(obj)(*args, **kwargs)\n\n        @wraps(obj)\n        def obj_with_original_obj_as_self(*args, **kwargs):\n            if len(args) > 0 and isinstance(args[0], Proxy):\n                # noinspection PyProtectedMember\n                args = (object.__getattribute__(args[0], '_original_obj'), ) + args[1:]\n            return obj(*args, **kwargs)\n\n        if wrapper is None:\n            result = obj\n        elif is_magic(obj=obj):\n            if obj.__name__ == '__getattribute__':\n                @wraps(obj)\n                def result(*args, **kwargs):\n                    # If we are trying to access magic attribute, call obj with args[0]._original_obj as self,\n                    # else call original __getattribute__ and wrap the result before returning it.\n                    # noinspection PyShadowingNames\n                    name = args[1]\n                    attr_value = obj_with_original_obj_as_self(*args, **kwargs)\n                    if is_magic_name(name=name):\n                        return attr_value\n                    else:\n                        # noinspection PyShadowingNames,PyArgumentList\n                        return _wrap(obj=attr_value,\n                                     wrapper=wrapper,\n                                     methods_to_add=methods_to_add,\n                                     name=name,\n                                     skip=skip,\n                                     wrap_return_values=wrap_return_values,\n                                     wrap_filenames=wrap_filenames,\n                                     filename=filename,\n                                     wrapped_name_func=wrapped_name_func)\n            else:\n                result = obj_with_original_obj_as_self\n        elif obj.__name__ == '__getattr__':\n            @wraps(obj)\n            def result(*args, **kwargs):\n                return wrapper(obj(*args, **kwargs))\n        else:\n            result = wrapped_obj\n        if wrap_return_values:\n            result = wrap_call_and_wrap_return_values(obj=result, wrapper=wrapper)\n        return result\n\n    def coroutine_wrapper():\n        @wraps(obj)\n        async def result(*args, **kwargs):\n            return await wrapper(obj)(*args, **kwargs)\n\n        if wrap_return_values:\n            result = wrap_call_and_wrap_return_values(obj=result, wrapper=wrapper)\n        return result\n\n    def is_in_skip():\n        result = False\n        for s in skip:\n            if isinstance(s, str):\n                if name == s:\n                    result = True\n            elif isinstance(s, type):\n                if isinstance(obj, s):\n                    result = True\n            else:\n                if obj == s:\n                    result = True\n        return result\n\n    # noinspection PyShadowingNames\n    def get_obj_file(obj):\n        # noinspection PyShadowingNames\n        def _get_obj_file(obj):\n            try:\n                result = (obj.__file__\n                          if hasattr(obj, '__file__') else\n                          sys.modules[obj.__module__].__file__\n                          if hasattr(obj, '__module__') else\n                          None)\n            except (AttributeError, KeyError):\n                result = None\n            return result\n\n        result = _get_obj_file(obj=obj)\n        if result is None:\n            result = _get_obj_file(obj=type(obj))\n        return result\n\n    def get_obj_library_files():\n        obj_file = get_obj_file(obj=obj)\n        if obj_file is not None:\n            obj_file = Path(obj_file)\n            if obj_file.name == '__init__.py':\n                result = obj_file.parent.glob('**/*.py')\n            else:\n                result = [obj_file]\n            result = [str(obj_file) for obj_file in result]\n        else:\n            result = []\n        result = frozenset(result)\n        return result\n\n    methods_to_add = frozenset(methods_to_add)\n    skip = frozenset(skip)\n    wrap_filenames = frozenset(wrap_filenames)\n\n    if wrapped_name_func is None:\n        # noinspection PyShadowingNames\n        def wrapped_name_func(obj):\n            _ = obj\n            return '_original_obj'\n\n    name = get_name(name, obj)\n    if name is None:\n        raise ValueError(\"name was not passed and obj.__name__ not found\")\n\n    key = make_key(obj=obj,\n                   wrapper=wrapper,\n                   methods_to_add=methods_to_add,\n                   name=name,\n                   skip=skip,\n                   wrap_return_values=wrap_return_values,\n                   wrap_filenames=wrap_filenames,\n                   filename=filename,\n                   wrapped_name_func=wrapped_name_func)\n\n    wrap_filenames = wrap_filenames or get_obj_library_files()\n    filename = get_obj_file(obj=obj) or filename\n\n    # noinspection PyUnusedLocal\n    members = []\n    with suppress(ModuleNotFoundError):\n        members = getmembers(object=obj)\n\n    try:\n        already_wrapped = key in _wrapped_objs\n    except TypeError:\n        already_wrapped = False\n    if filename not in wrap_filenames or is_in_skip():\n        wrapped = obj\n    elif already_wrapped:\n        wrapped = _wrapped_objs[key]\n    elif members:\n        wrapped = wrap_(obj=obj, name=name, members=members, wrapped=wrapped)\n    else:\n        wrapped = obj\n        _wrapped_objs[key] = wrapped\n\n    return wrapped", "response": "Wrap a module class or function or another variable recursively."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap(obj, wrapper=None, methods_to_add=(), name=None, skip=(), wrap_return_values=False, clear_cache=True):\n    result = _wrap(obj=obj,\n                   wrapper=wrapper,\n                   methods_to_add=methods_to_add,\n                   name=name,\n                   skip=skip,\n                   wrap_return_values=wrap_return_values)\n    if clear_cache:\n        _wrapped_objs.clear()\n    return result", "response": "Wrap module class function or another variable recursively"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the command - line interface described in doc and return a dictionary containing the parsed command - line arguments.", "response": "def docopt(doc, argv=None, help=True, version=None, options_first=False):\n    \"\"\"Parse `argv` based on command-line interface described in `doc`.\n\n    `docopt` creates your command-line interface based on its\n    description that you pass as `doc`. Such description can contain\n    --options, <positional-argument>, commands, which could be\n    [optional], (required), (mutually | exclusive) or repeated...\n\n    Parameters\n    ----------\n    doc : str\n        Description of your command-line interface.\n    argv : list of str, optional\n        Argument vector to be parsed. sys.argv[1:] is used if not\n        provided.\n    help : bool (default: True)\n        Set to False to disable automatic help on -h or --help\n        options.\n    version : any object\n        If passed, the object will be printed if --version is in\n        `argv`.\n    options_first : bool (default: False)\n        Set to True to require options preceed positional arguments,\n        i.e. to forbid options and positional arguments intermix.\n\n    Returns\n    -------\n    args : dict\n        A dictionary, where keys are names of command-line elements\n        such as e.g. \"--verbose\" and \"<path>\", and values are the\n        parsed values of those elements.\n\n    Example\n    -------\n    >>> from docopt import docopt\n    >>> doc = '''\n    Usage:\n        my_program tcp <host> <port> [--timeout=<seconds>]\n        my_program serial <port> [--baud=<n>] [--timeout=<seconds>]\n        my_program (-h | --help | --version)\n\n    Options:\n        -h, --help  Show this screen and exit.\n        --baud=<n>  Baudrate [default: 9600]\n    '''\n    >>> argv = ['tcp', '127.0.0.1', '80', '--timeout', '30']\n    >>> docopt(doc, argv)\n    {'--baud': '9600',\n     '--help': False,\n     '--timeout': '30',\n     '--version': False,\n     '<host>': '127.0.0.1',\n     '<port>': '80',\n     'serial': False,\n     'tcp': True}\n\n    See also\n    --------\n    * For video introduction see http://docopt.org\n    * Full documentation is available in README.rst as well as online\n      at https://github.com/docopt/docopt#readme\n\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n    DocoptExit.usage = printable_usage(doc)\n    options = parse_defaults(doc)\n    pattern = parse_pattern(formal_usage(DocoptExit.usage), options)\n    # [default] syntax for argument is disabled\n    #for a in pattern.flat(Argument):\n    #    same_name = [d for d in arguments if d.name == a.name]\n    #    if same_name:\n    #        a.value = same_name[0].value\n\n    argv = parse_argv(TokenStream(argv, DocoptExit), list(options),\n                      options_first)\n    pattern_options = set(pattern.flat(Option))\n    for ao in pattern.flat(AnyOptions):\n        doc_options = parse_defaults(doc)\n        ao.children = list(set(doc_options) - pattern_options)\n        #if any_options:\n        #    ao.children += [Option(o.short, o.long, o.argcount)\n        #                    for o in argv if type(o) is Option]\n    extras(help, version, argv, doc)\n    matched, left, collected = pattern.fix().match(argv)\n    if matched:\n        return Dict((a.name, a.value) for a in (pattern.flat() + collected))\n    raise DocoptExit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True iff this represents a scalar node.", "response": "def is_scalar(self, typ: Type = _Any) -> bool:\n        \"\"\"Returns True iff this represents a scalar node.\n\n        If a type is given, checks that the ScalarNode represents this \\\n        type. Type may be `str`, `int`, `float`, `bool`, or `None`.\n\n        If no type is given, any ScalarNode will return True.\n        \"\"\"\n        if isinstance(self.yaml_node, yaml.ScalarNode):\n            if typ != _Any and typ in scalar_type_to_tag:\n                if typ is None:\n                    typ = type(None)\n                return self.yaml_node.tag == scalar_type_to_tag[typ]\n\n            if typ is _Any:\n                return True\n            raise ValueError('Invalid scalar type passed to is_scalar()')\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_value(self) -> ScalarType:\n        if self.yaml_node.tag == 'tag:yaml.org,2002:str':\n            return self.yaml_node.value\n        if self.yaml_node.tag == 'tag:yaml.org,2002:int':\n            return int(self.yaml_node.value)\n        if self.yaml_node.tag == 'tag:yaml.org,2002:float':\n            return float(self.yaml_node.value)\n        if self.yaml_node.tag == 'tag:yaml.org,2002:bool':\n            return self.yaml_node.value in ['TRUE', 'True', 'true']\n        if self.yaml_node.tag == 'tag:yaml.org,2002:null':\n            return None\n        raise RuntimeError('This node with tag {} is not of the right type'\n                           ' for get_value()'.format(self.yaml_node.tag))", "response": "Returns the value of a Scalar node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value of the node to a scalar value.", "response": "def set_value(self, value: ScalarType) -> None:\n        \"\"\"Sets the value of the node to a scalar value.\n\n        After this, is_scalar(type(value)) will return true.\n\n        Args:\n            value: The value to set this node to, a str, int, float, \\\n                    bool, or None.\n        \"\"\"\n        if isinstance(value, bool):\n            value_str = 'true' if value else 'false'\n        else:\n            value_str = str(value)\n        start_mark = self.yaml_node.start_mark\n        end_mark = self.yaml_node.end_mark\n        # If we're of a class type, then we want to keep that tag so that the\n        # correct Constructor is called. If we're a built-in type, set the tag\n        # to the appropriate YAML tag.\n        tag = self.yaml_node.tag\n        if tag.startswith('tag:yaml.org,2002:'):\n            tag = scalar_type_to_tag[type(value)]\n        new_node = yaml.ScalarNode(tag, value_str, start_mark, end_mark)\n        self.yaml_node = new_node"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace the node with a new empty mapping.", "response": "def make_mapping(self) -> None:\n        \"\"\"Replaces the node with a new, empty mapping.\n\n        Note that this will work on the Node object that is passed to \\\n        a yatiml_savorize() or yatiml_sweeten() function, but not on \\\n        any of its attributes or items. If you need to set an attribute \\\n        to a complex value, build a yaml.Node representing it and use \\\n        set_attribute with that.\n        \"\"\"\n        start_mark = StreamMark('generated node', 0, 0, 0)\n        end_mark = StreamMark('generated node', 0, 0, 0)\n        self.yaml_node = yaml.MappingNode('tag:yaml.org,2002:map', list(),\n                                          start_mark, end_mark)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the node has an attribute with the given name.", "response": "def has_attribute(self, attribute: str) -> bool:\n        \"\"\"Whether the node has an attribute with the given name.\n\n        Use only if is_mapping() returns True.\n\n        Args:\n            attribute: The name of the attribute to check for.\n\n        Returns:\n            True iff the attribute is present.\n        \"\"\"\n        return any([\n            key_node.value == attribute for key_node, _ in self.yaml_node.value\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True iff the given attribute exists and is an instance of the given type.", "response": "def has_attribute_type(self, attribute: str, typ: Type) -> bool:\n        \"\"\"Whether the given attribute exists and has a compatible type.\n\n        Returns true iff the attribute exists and is an instance of \\\n        the given type. Matching between types passed as typ and \\\n        yaml node types is as follows:\n\n        +---------+-------------------------------------------+\n        |   typ   |                 yaml                      |\n        +=========+===========================================+\n        |   str   |      ScalarNode containing string         |\n        +---------+-------------------------------------------+\n        |   int   |      ScalarNode containing int            |\n        +---------+-------------------------------------------+\n        |  float  |      ScalarNode containing float          |\n        +---------+-------------------------------------------+\n        |   bool  |      ScalarNode containing bool           |\n        +---------+-------------------------------------------+\n        |   None  |      ScalarNode containing null           |\n        +---------+-------------------------------------------+\n        |   list  |      SequenceNode                         |\n        +---------+-------------------------------------------+\n        |   dict  |      MappingNode                          |\n        +---------+-------------------------------------------+\n\n        Args:\n            attribute: The name of the attribute to check.\n            typ: The type to check against.\n\n        Returns:\n            True iff the attribute exists and matches the type.\n        \"\"\"\n        if not self.has_attribute(attribute):\n            return False\n\n        attr_node = self.get_attribute(attribute).yaml_node\n\n        if typ in scalar_type_to_tag:\n            tag = scalar_type_to_tag[typ]\n            return attr_node.tag == tag\n        elif typ == list:\n            return isinstance(attr_node, yaml.SequenceNode)\n        elif typ == dict:\n            return isinstance(attr_node, yaml.MappingNode)\n\n        raise ValueError('Invalid argument for typ attribute')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the node representing the given attribute.", "response": "def get_attribute(self, attribute: str) -> 'Node':\n        \"\"\"Returns the node representing the given attribute's value.\n\n        Use only if is_mapping() returns true.\n\n        Args:\n            attribute: The name of the attribute to retrieve.\n\n        Raises:\n            KeyError: If the attribute does not exist.\n\n        Returns:\n            A node representing the value.\n        \"\"\"\n        matches = [\n            value_node for key_node, value_node in self.yaml_node.value\n            if key_node.value == attribute\n        ]\n        if len(matches) != 1:\n            raise SeasoningError(\n                'Attribute not found, or found multiple times: {}'.format(\n                    matches))\n        return Node(matches[0])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the value of the given attribute.", "response": "def set_attribute(self, attribute: str,\n                      value: Union[ScalarType, yaml.Node]) -> None:\n        \"\"\"Sets the attribute to the given value.\n\n        Use only if is_mapping() returns True.\n\n        If the attribute does not exist, this adds a new attribute, \\\n        if it does, it will be overwritten.\n\n        If value is a str, int, float, bool or None, the attribute will \\\n        be set to this value. If you want to set the value to a list or \\\n        dict containing other values, build a yaml.Node and pass it here.\n\n        Args:\n            attribute: Name of the attribute whose value to change.\n            value: The value to set.\n        \"\"\"\n        start_mark = StreamMark('generated node', 0, 0, 0)\n        end_mark = StreamMark('generated node', 0, 0, 0)\n        if isinstance(value, str):\n            value_node = yaml.ScalarNode('tag:yaml.org,2002:str', value,\n                                         start_mark, end_mark)\n        elif isinstance(value, bool):\n            value_str = 'true' if value else 'false'\n            value_node = yaml.ScalarNode('tag:yaml.org,2002:bool', value_str,\n                                         start_mark, end_mark)\n        elif isinstance(value, int):\n            value_node = yaml.ScalarNode('tag:yaml.org,2002:int', str(value),\n                                         start_mark, end_mark)\n        elif isinstance(value, float):\n            value_node = yaml.ScalarNode('tag:yaml.org,2002:float', str(value),\n                                         start_mark, end_mark)\n        elif value is None:\n            value_node = yaml.ScalarNode('tag:yaml.org,2002:null', '',\n                                         start_mark, end_mark)\n        elif isinstance(value, yaml.Node):\n            value_node = value\n        else:\n            raise TypeError('Invalid kind of value passed to set_attribute()')\n\n        attr_index = self.__attr_index(attribute)\n        if attr_index is not None:\n            key_node = self.yaml_node.value[attr_index][0]\n            self.yaml_node.value[attr_index] = key_node, value_node\n        else:\n            key_node = yaml.ScalarNode('tag:yaml.org,2002:str', attribute,\n                                       start_mark, end_mark)\n            self.yaml_node.value.append((key_node, value_node))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves an attribute from the node.", "response": "def remove_attribute(self, attribute: str) -> None:\n        \"\"\"Remove an attribute from the node.\n\n        Use only if is_mapping() returns True.\n\n        Args:\n            attribute: The name of the attribute to remove.\n        \"\"\"\n        attr_index = self.__attr_index(attribute)\n        if attr_index is not None:\n            self.yaml_node.value.pop(attr_index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrename an attribute. Use only if is_mapping() returns true. If the attribute does not exist, this will do nothing. Args: attribute: The (old) name of the attribute to rename. new_name: The new name to rename it to.", "response": "def rename_attribute(self, attribute: str, new_name: str) -> None:\n        \"\"\"Renames an attribute.\n\n        Use only if is_mapping() returns true.\n\n        If the attribute does not exist, this will do nothing.\n\n        Args:\n            attribute: The (old) name of the attribute to rename.\n            new_name: The new name to rename it to.\n        \"\"\"\n        for key_node, _ in self.yaml_node.value:\n            if key_node.value == attribute:\n                key_node.value = new_name\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreplaces underscores with dashes in key names.", "response": "def unders_to_dashes_in_keys(self) -> None:\n        \"\"\"Replaces underscores with dashes in key names.\n\n        For each attribute in a mapping, this replaces any underscores \\\n        in its keys with dashes. Handy because Python does not \\\n        accept dashes in identifiers, while some YAML-based formats use \\\n        dashes in their keys.\n        \"\"\"\n        for key_node, _ in self.yaml_node.value:\n            key_node.value = key_node.value.replace('_', '-')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dashes_to_unders_in_keys(self) -> None:\n        for key_node, _ in self.yaml_node.value:\n            key_node.value = key_node.value.replace('-', '_')", "response": "Replaces dashes with underscores in key names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef seq_attribute_to_map(self,\n                             attribute: str,\n                             key_attribute: str,\n                             value_attribute: Optional[str] = None,\n                             strict: Optional[bool] = True) -> None:\n        \"\"\"Converts a sequence attribute to a map.\n\n        This function takes an attribute of this Node that is \\\n        a sequence of mappings and turns it into a mapping of mappings. \\\n        It assumes that each of the mappings in the original sequence \\\n        has an attribute containing a unique value, which it will use \\\n        as a key for the new outer mapping.\n\n        An example probably helps. If you have a Node representing \\\n        this piece of YAML::\n\n            items:\n            - item_id: item1\n              description: Basic widget\n              price: 100.0\n            - item_id: item2\n              description: Premium quality widget\n              price: 200.0\n\n        and call seq_attribute_to_map('items', 'item_id'), then the \\\n        Node will be modified to represent this::\n\n            items:\n              item1:\n                description: Basic widget\n                price: 100.0\n              item2:\n                description: Premium quality widget\n                price: 200.0\n\n        which is often more intuitive for people to read and write.\n\n        If the attribute does not exist, or is not a sequence of \\\n        mappings, this function will silently do nothing. If the keys \\\n        are not unique and strict is False, it will also do nothing. If \\\n        the keys are not unique and strict is True, it will raise an \\\n        error.\n\n        With thanks to the makers of the Common Workflow Language for \\\n        the idea.\n\n        Args:\n            attribute: Name of the attribute whose value to modify.\n            key_attribute: Name of the attribute in each item to use \\\n                    as a key for the new mapping.\n            strict: Whether to give an error if the intended keys are \\\n                    not unique.\n\n        Raises:\n            SeasoningError: If the keys are not unique and strict is \\\n                    True.\n        \"\"\"\n        if not self.has_attribute(attribute):\n            return\n\n        attr_node = self.get_attribute(attribute)\n        if not attr_node.is_sequence():\n            return\n\n        start_mark = attr_node.yaml_node.start_mark\n        end_mark = attr_node.yaml_node.end_mark\n\n        # check that all list items are mappings and that the keys are unique\n        # strings\n        seen_keys = set()  # type: Set[str]\n        for item in attr_node.seq_items():\n            key_attr_node = item.get_attribute(key_attribute)\n            if not key_attr_node.is_scalar(str):\n                raise SeasoningError(\n                    ('Attribute names must be strings in'\n                     'YAtiML, {} is not a string.').format(key_attr_node))\n            if key_attr_node.get_value() in seen_keys:\n                if strict:\n                    raise SeasoningError(\n                        ('Found a duplicate key {}: {} when'\n                         ' converting from sequence to mapping'.format(\n                             key_attribute, key_attr_node.get_value())))\n                return\n            seen_keys.add(key_attr_node.get_value())  # type: ignore\n\n        # construct mapping\n        mapping_values = list()\n        for item in attr_node.seq_items():\n            # we've already checked that it's a SequenceNode above\n            key_node = item.get_attribute(key_attribute).yaml_node\n            item.remove_attribute(key_attribute)\n            if value_attribute is not None:\n                value_node = item.get_attribute(value_attribute).yaml_node\n                if len(item.yaml_node.value) == 1:\n                    # no other attributes, use short form\n                    mapping_values.append((key_node, value_node))\n                else:\n                    mapping_values.append((key_node, item.yaml_node))\n            else:\n                mapping_values.append((key_node, item.yaml_node))\n\n        # create mapping node\n        mapping = yaml.MappingNode('tag:yaml.org,2002:map', mapping_values,\n                                   start_mark, end_mark)\n        self.set_attribute(attribute, mapping)", "response": "This function converts a sequence attribute to a map."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map_attribute_to_seq(self,\n                             attribute: str,\n                             key_attribute: str,\n                             value_attribute: Optional[str] = None) -> None:\n        \"\"\"Converts a mapping attribute to a sequence.\n\n        This function takes an attribute of this Node whose value \\\n        is a mapping or a mapping of mappings and turns it into a \\\n        sequence of mappings. Each entry in the original mapping is \\\n        converted to an entry in the list. If only a key attribute is \\\n        given, then each entry in the original mapping must map to a \\\n        (sub)mapping. This submapping becomes the corresponding list \\\n        entry, with the key added to it as an additional attribute. If a \\\n        value attribute is also given, then an entry in the original \\\n        mapping may map to any object. If the mapped-to object is a \\\n        mapping, the conversion is as before, otherwise a new \\\n        submapping is created, and key and value are added using the \\\n        given key and value attribute names.\n\n        An example probably helps. If you have a Node representing \\\n        this piece of YAML::\n\n            items:\n              item1:\n                description: Basic widget\n                price: 100.0\n              item2:\n                description: Premium quality widget\n                price: 200.0\n\n        and call map_attribute_to_seq('items', 'item_id'), then the \\\n        Node will be modified to represent this::\n\n            items:\n            - item_id: item1\n              description: Basic widget\n              price: 100.0\n            - item_id: item2\n              description: Premium quality widget\n              price: 200.0\n\n        which once converted to an object is often easier to deal with \\\n        in code.\n\n        Slightly more complicated, this YAML::\n\n            items:\n              item1: Basic widget\n              item2:\n                description: Premium quality widget\n                price: 200.0\n\n        when passed through map_attribute_to_seq('items', 'item_id', \\\n        'description'), will result in th equivalent of::\n\n            items:\n            - item_id: item1\n              description: Basic widget\n            - item_id: item2\n              description: Premium quality widget\n              price: 200.0\n\n        If the attribute does not exist, or is not a mapping, this \\\n        function will silently do nothing.\n\n        With thanks to the makers of the Common Workflow Language for \\\n        the idea.\n\n        Args:\n            attribute: Name of the attribute whose value to modify.\n            key_attribute: Name of the new attribute in each item to \\\n                    add with the value of the key.\n            value_attribute: Name of the new attribute in each item to \\\n                    add with the value of the key.\n        \"\"\"\n        if not self.has_attribute(attribute):\n            return\n\n        attr_node = self.get_attribute(attribute)\n        if not attr_node.is_mapping():\n            return\n\n        start_mark = attr_node.yaml_node.start_mark\n        end_mark = attr_node.yaml_node.end_mark\n        object_list = []\n        for item_key, item_value in attr_node.yaml_node.value:\n            item_value_node = Node(item_value)\n            if not item_value_node.is_mapping():\n                if value_attribute is None:\n                    return\n                ynode = item_value_node.yaml_node\n                item_value_node.make_mapping()\n                item_value_node.set_attribute(value_attribute, ynode)\n\n            item_value_node.set_attribute(key_attribute, item_key.value)\n            object_list.append(item_value_node.yaml_node)\n        seq_node = yaml.SequenceNode('tag:yaml.org,2002:seq', object_list,\n                                     start_mark, end_mark)\n        self.set_attribute(attribute, seq_node)", "response": "This function maps an attribute of this Node to a sequence of mappings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds an attribute s index in the yaml_node. value list.", "response": "def __attr_index(self, attribute: str) -> Optional[int]:\n        \"\"\"Finds an attribute's index in the yaml_node.value list.\"\"\"\n        attr_index = None\n        for i, (key_node, _) in enumerate(self.yaml_node.value):\n            if key_node.value == attribute:\n                attr_index = i\n                break\n        return attr_index"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef require_scalar(self, *args: Type) -> None:\n        node = Node(self.yaml_node)\n        if len(args) == 0:\n            if not node.is_scalar():\n                raise RecognitionError(('{}{}A scalar is required').format(\n                    self.yaml_node.start_mark, os.linesep))\n        else:\n            for typ in args:\n                if node.is_scalar(typ):\n                    return\n            raise RecognitionError(\n                ('{}{}A scalar of type {} is required').format(\n                    self.yaml_node.start_mark, os.linesep, args))", "response": "Require the node to be a scalar."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequires the node to be a mapping.", "response": "def require_mapping(self) -> None:\n        \"\"\"Require the node to be a mapping.\"\"\"\n        if not isinstance(self.yaml_node, yaml.MappingNode):\n            raise RecognitionError(('{}{}A mapping is required here').format(\n                self.yaml_node.start_mark, os.linesep))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrequires the node to be a sequence.", "response": "def require_sequence(self) -> None:\n        \"\"\"Require the node to be a sequence.\"\"\"\n        if not isinstance(self.yaml_node, yaml.SequenceNode):\n            raise RecognitionError(('{}{}A sequence is required here').format(\n                self.yaml_node.start_mark, os.linesep))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef require_attribute(self, attribute: str, typ: Type = _Any) -> None:\n        attr_nodes = [\n            value_node for key_node, value_node in self.yaml_node.value\n            if key_node.value == attribute\n        ]\n        if len(attr_nodes) == 0:\n            raise RecognitionError(\n                ('{}{}Missing required attribute {}').format(\n                    self.yaml_node.start_mark, os.linesep, attribute))\n        attr_node = attr_nodes[0]\n\n        if typ != _Any:\n            recognized_types, message = self.__recognizer.recognize(\n                attr_node, cast(Type, typ))\n            if len(recognized_types) == 0:\n                raise RecognitionError(message)", "response": "Require an attribute on the node to exist."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef require_attribute_value(\n            self, attribute: str,\n            value: Union[int, str, float, bool, None]) -> None:\n        \"\"\"Require an attribute on the node to have a particular value.\n\n        This requires the attribute to exist, and to have the given value \\\n        and corresponding type. Handy for in your yatiml_recognize() \\\n        function.\n\n        Args:\n            attribute: The name of the attribute / mapping key.\n            value: The value the attribute must have to recognize an \\\n                    object of this type.\n\n        Raises:\n            RecognitionError: If the attribute does not exist, or does \\\n                    not have the required value.\n        \"\"\"\n        found = False\n        for key_node, value_node in self.yaml_node.value:\n            if (key_node.tag == 'tag:yaml.org,2002:str'\n                    and key_node.value == attribute):\n                found = True\n                node = Node(value_node)\n                if not node.is_scalar(type(value)):\n                    raise RecognitionError(\n                            ('{}{}Incorrect attribute type where value {}'\n                             ' of type {} was required').format(\n                                self.yaml_node.start_mark, os.linesep,\n                                value, type(value)))\n                if node.get_value() != value:\n                    raise RecognitionError(\n                        ('{}{}Incorrect attribute value'\n                         ' {} where {} was required').format(\n                             self.yaml_node.start_mark, os.linesep,\n                             value_node.value, value))\n\n        if not found:\n            raise RecognitionError(\n                ('{}{}Required attribute {} not found').format(\n                    self.yaml_node.start_mark, os.linesep, attribute))", "response": "This function requires an attribute to have a particular value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a proactor loop and return new socket events.", "response": "def run(self, timeout = 0):\r\n        \"\"\"\r\n        Run a proactor loop and return new socket events. Timeout is a timedelta\r\n        object, 0 if active coros or None.\r\n\r\n        epoll timeout param is a integer number of miliseconds (seconds/1000).\r\n        \"\"\"\r\n        ptimeout = int(timeout.microseconds/1000+timeout.seconds*1000\r\n                if timeout else (self.m_resolution if timeout is None else 0))\r\n        if self.tokens:\r\n            epoll_fd = self.epoll_fd\r\n            events = epoll_wait(epoll_fd, 1024, ptimeout)\r\n            len_events = len(events)-1\r\n            for nr, (ev, fd) in enumerate(events):\r\n                act = self.shadow.pop(fd)\r\n                if ev & EPOLLHUP:\r\n                    epoll_ctl(self.epoll_fd, EPOLL_CTL_DEL, fd, 0)\r\n                    self.handle_error_event(act, 'Hang up.', ConnectionClosed)\r\n                elif ev & EPOLLERR:\r\n                    epoll_ctl(self.epoll_fd, EPOLL_CTL_DEL, fd, 0)\r\n                    self.handle_error_event(act, 'Unknown error.')\r\n                else:\r\n                    if nr == len_events:\r\n                        ret = self.yield_event(act)\r\n                        if not ret:\r\n                            epoll_ctl(epoll_fd, EPOLL_CTL_MOD, fd, ev | EPOLLONESHOT)\r\n                            self.shadow[fd] = act\r\n                        return ret\r\n                    else:\r\n                        if not self.handle_event(act):\r\n                            epoll_ctl(epoll_fd, EPOLL_CTL_MOD, fd, ev | EPOLLONESHOT)\r\n                            self.shadow[fd] = act\r\n\r\n        else:\r\n            sleep(timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the difference of the nth n values along the given axis.", "response": "def difference(arr, n=1, axis=0, **kwargs):\n  '''\n  Assuming that `arr` is a 2D spectrogram returned by\n  ibmseti.dsp.raw_to_spectrogram(data), this function\n  uses the Numpy.diff function to calculate the nth\n  difference along either time or frequency.\n\n  If axis = 0 and n=1, then the first difference is taken\n  between subsequent time samples\n\n  If axis = 1 and n=1, then the first difference is taken\n  between frequency bins.\n\n  For example:\n\n    //each column is a frequency bin\n    x = np.array([\n       [ 1,  3,  6, 10],   //each row is a time sample\n       [ 0,  5,  6,  8],\n       [ 2,  6,  9, 12]])\n\n    ibmseti.features.first_difference(x, axis=1)\n    >>> array([[2, 3, 4],\n               [5, 1, 2],\n               [4, 3, 3]])\n\n    ibmseti.features.first_difference(x, axis=0)\n    >>> array([[-1,  2,  0, -2],\n               [ 2,  1,  3,  4]])\n\n  '''\n  return np.diff(arr, n=n, axis=axis, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef projection(arr, axis=0, **kwargs):\n  '''\n  Assuming that `arr` is a 2D spectrogram returned by\n  ibmseti.dsp.raw_to_spectrogram(data), where each row\n  of the `arr` is a power spectrum at a particular time,\n  this function uses the numpy.sum function to project the\n  data onto the time or frequency axis into a 1D array.\n\n  If axis = 0, then the projection is onto the frequency axis\n  (the sum is along the time axis)\n\n  If axis = 1, then the projection is onto the time axis.\n  (the sum is along the frequency axis)\n\n  For example:\n\n    //each column is a frequency bin\n    x = np.array([\n       [ 1,  3,  6, 10],   //each row is a time sample\n       [ 0,  5,  6,  8],\n       [ 2,  6,  9, 12]])\n\n    ibmseti.features.projection(x, axis=1)\n    >>> array([20, 19, 29])\n\n    ibmseti.features.projection(x, axis=0)\n    >>> array([ 3, 14, 21, 30])\n\n  One interesting kwarg that you may wish to use is `keepdims`.\n  See the documentation on numpy.sum for more information.\n\n  '''\n  return np.sum(arr, axis=axis, **kwargs)", "response": "This function computes the sum of the data along the specified axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef moment(arr, moment=1, axis=0, **kwargs):\n  '''\n  Uses the scipy.stats.moment to calculate the Nth central\n  moment about the mean.\n\n  If `arr` is a 2D spectrogram returned by\n  ibmseti.dsp.raw_to_spectrogram(data), where each row\n  of the `arr` is a power spectrum at a particular time,\n  this function, then the Nth moment along each axis\n  will be computed.\n\n  If axis = 0, then Nth moment for the data in each\n  frequency bin will be computed. (The calculation is done\n    *along* the 0th axis, which is the time axis.)\n\n  If axis = 1, then Nth moment for the data in each\n  time bin will be computed. (The calculation is done\n    *along* the 1st axis, which is the frequency axis.)\n\n  For example, consider the 2nd moment:\n\n    //each column is a frequency bin\n    x = array([[  1.,   3.,   6.,  10.], //each row is a time sample\n               [  0.,   5.,   6.,   8.],\n               [  2.,   6.,   9.,  12.]])\n\n    ibmseti.features.mement(x, moment=2, axis=0) //the returned array is of size 4, the number of columns / frequency bins.\n    >>>  array([ 0.66666667,  1.55555556,  2.,  2.66666667])\n\n    ibmseti.features.mement(x, moment=2, axis=1) //the returned array is of size 3, the number of rows / time bins.\n    >>>  array([ 11.5 ,  8.6875, 13.6875])\n\n  If `arr` is a 1D array, such as what you'd get if you projected\n  the spectrogram onto the time or frequency axis, then you must\n  use axis=0.\n\n  '''\n  return scipy.stats.moment(arr, moment=moment, axis=axis, **kwargs)", "response": "Calculates the Nth central moment about the mean."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef first_order_gradient(arr, axis=0):\n  '''\n  Returns the gradient of arr along a particular axis using\n  the first order forward-difference.\n  Additionally, the result is padded with 0 so that the\n  returned array is the same shape as in input array.\n  '''\n  grad_arr = difference(arr, n=1, axis=axis)\n  return np.insert(grad_arr, grad_arr.shape[axis], 0, axis=axis)", "response": "Returns the gradient of arr along a particular axis using\n"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef total_variation(arr):\n  '''\n  If arr is a 2D array (N X M), assumes that arr is a spectrogram with time along axis=0.\n\n  Calculates the 1D total variation in time for each frequency and returns an array\n  of size M.\n\n  If arr is a 1D array, calculates total variation and returns a scalar.\n\n  Sum ( Abs(arr_i+1,j  - arr_ij) )\n\n  If arr is a 2D array, it's common to take the mean of the resulting M-sized array\n  to calculate a scalar feature.\n  '''\n  return np.sum(np.abs(np.diff(arr, axis=0)), axis=0)", "response": "Calculates the total variation of a spectrogram with time along axis = 0."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn np.max(arr, axis=0) - np.min(arr, axis=0) If `arr` is a 1D array, a scalar is returned. If `arr` is a 2D array (N x M), an array of length M is returned.", "response": "def maximum_variation(arr):\n  '''\n  return np.max(arr, axis=0) - np.min(arr, axis=0)\n\n  If `arr` is a 1D array, a scalar is returned.\n\n  If `arr` is a 2D array (N x M), an array of length M is returned.\n  '''\n  return np.max(arr, axis=0) - np.min(arr, axis=0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the entropy of a discrete probability distribution function as a set of power values p and w.", "response": "def entropy(p, w):\n  '''\n  Computes the entropy for a discrete probability distribution function, as\n  represented by a histogram, `p`, with bin sizes `w`,\n\n   h_p = Sum -1 * p_i * ln(p_i / w_i)\n\n  Also computes the maximum allowed entropy for a histogram with bin sizes `w`.\n\n    h_max = ln( Sum w_i )\n\n  and returns both as a tuple (h_p , h_max ). The entropy is in 'natural' units.\n\n  Both `p` and `w` must be Numpy arrays.\n\n  If `p` is normalized to 1 ( Sum p_i * w_i = 1), then\n  the normalized entropy is equal toh_p / h_max and will\n  be in the range [0, 1].\n\n  For example, if `p` is a completely flat PDF (a uniform distribution), then\n  the normalized entropy will equal 1, indicating maximum amount of disorder.\n  (This is easily shown for the case where w_i = 1.)\n\n  If the `p_i` is zero for all i except j and p_j = 1, then the entropy will be 0,\n  indicating no disorder.\n\n  One can use this entropy measurement to search for signals in the spectrogram.\n  First we need to build a histogram of the measured power values in the spectrogram.\n  This histogram represents an estimate of the probability distribution function of the\n  observed power in the spectrogram.\n\n  If the spectrogram is entirely noise, the resulting histogram should be quite flat and\n  the normalized entropy ( h_p / h_max ) will approach 1. If there is a significant signal\n  in the spectrogram, then the histogram will not be flat and the normalized entropy will\n  be less than 1.\n\n  The decision that needs to be made is the number of bins and the bin size. And unfortunately,\n  the resulting entropy calculated will depend on the binning.\n\n  Based on testing and interpretibility, we recommend to use a fixed number of bins that either\n  span the full range of the power values in the spectrogram (0 to spectrogram.max()),\n  or span a fixed range (for example, from 0 to 500).\n\n  For example, you may set the range equal to the range of the values in the spectrogram.\n\n    bin_edges = range(0,int(spectrogram.max()) + 2) #add 1 to round up, and one to set the right bin edge.\n    p, _ = np.histogram(spectrogram.flatten(), bins=bin_edges, density=True)\n    w = np.diff(bin_edges)\n    h_p, h_max = ibmseti.features.entropy(p,w)\n\n  If you choose to fix the range of the histogram, it is highly recommended that you use\n  `numpy.clip` to ensure that any of the values in the spectrogram that are greater than\n  your largest bin are not thrown away!\n\n  For example, if you decide on a fixed range between 0 and 500, and your spectrogram\n  contains a value of 777, the following code would produce a histogram where that 777 value\n  is not present in the count.\n\n    bin_edges = range(0,501)\n    p, _ = np.histogram(spectrogram.flatten(), bins=bin_edges, density=True)\n    w = np.diff(bin_edges)\n    h_p, h_max = ibmseti.features.entropy(p,w)\n\n  But if you clip the spectrogram, you can interpret the last bin as being \"the number\n  of spectrogram values equal to or greater than the lower bin edge\".\n\n    bin_edges = range(0,501)\n    p, _ = np.histogram(np.clip(spectrogram.flatten(), 0, 500), bins=bin_edges, density=True)\n    w = np.diff(bin_edges)\n    h_p, h_max = ibmseti.features.entropy(p,w)\n\n  You can also choose to fix the number of bins\n\n    bins = 50\n    p, bin_edges = np.histogram(spectrogram.flatten(), bins=bins, density=True)\n    w = np.diff(bin_edges)\n    h_p, h_max = ibmseti.features.entropy(p,w)\n\n  It is suggested to use any of the following measures as features:\n\n    bin range, spectrogram.min, spectrogram.max, number_of_bins, log(number_of_bins)\n    entropy, max_entropy, normalized_entropy.\n\n  Automatic Binning:\n\n  While Numpy and AstroML offer ways of automatically binning the data, it is unclear if this\n  is a good approach for entropy calculation -- especially when wishing to compare the value\n  across different spectrogram. The automatic binning tends to remove disorder in\n  the set of values, making the histogram smoother and more ordered than the data actually are.\n  This is true of automatic binning with fixed sizes (such as with the 'rice', and 'fd' options in\n  numpy.histogram), or with the variable sized arrays as can be calculated with Bayesian Blocks\n  with astroML. However, nothing is ruled out. In preliminary testing,\n  the calculated entropy from a histogram calculated with Bayesian Block binning seemed to be more\n  sensitive to a simulated signal than using fixed binning. However, it's unclear how to\n  interpret the results because \"h_p/h_max\" *increased* with the presence of a signal and exceeded 1.\n\n  **It is likely that the calculation of h_max is done incorrectly. Please check my work!**\n\n  It may even be that the total number of bins created by the Bayesian Block method would\n  be a suitable feature. For a completely flat distribution, there will only be one bin. If the\n  data contains significant variation in power levels, the Bayesian Block method will produce more\n  bins.  More testing is required and your mileage may vary.\n\n    import astroML.plotting\n\n    bin_edges = astroML.density_estimation.bayesian_blocks(spectrogram.flatten())\n    p, _ = np.histogram(spectrogram.flatten(), bins=bin_edges, density=True)\n    w = np.diff(bin_edges)\n\n    h_p, h_max = ibmseti.features.entropy(p,w)\n\n  Also to note: Using astroML.density_estimation.bayesian_blocks takes prohibitively long!\n\n  \"Entropy\" of raw data.\n\n  If `p` is NOT a PDF, then you're on your own to interpret the results. In this case, you\n  may set `w` = None and the calculation will assume w_i = 1 for all i.\n\n  For example,\n\n    h_p, _ = ibmseti.features.entropy(spectrogram.flatten(), None)\n\n  '''\n  if w is None:\n    w = np.ones(len(p))\n\n  h_p = np.sum([-x[0]*math.log(x[0]/x[1]) if x[0] else 0 for x in zip(p, w)])\n  h_max = math.log(np.sum(w))\n\n  return h_p, h_max"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refine_get_urls(original):\n\n    def get_urls():\n        from django.conf.urls import url\n        from django.conf import settings\n        from django.contrib.staticfiles.urls import staticfiles_urlpatterns\n        from django.views.static import serve\n        if settings.DEBUG:\n            return staticfiles_urlpatterns() + [\n                url(r'^media/(?P<path>.*)$', serve, {\n                    'document_root': settings.MEDIA_ROOT,\n                }),\n            ] + original()\n        else:\n            return original()\n    return get_urls", "response": "Refines the get_urls function to include the static files and media files in production and returns the original function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download(url):\n    session = requests.Session()\n    session.mount('file://', FileAdapter())\n\n    try:\n        res = session.get(url)\n    except requests.exceptions.ConnectionError as e:\n        raise e\n\n    res.raise_for_status()\n\n    return res", "response": "Uses requests to download an URL maybe from a file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_uri_name(url):\n    url_parsed = urlparse(url)\n\n    url_parts = url_parsed.path.split('/')\n\n    log.info('url parts: %s', url_parts)\n\n    return url_parts[-1]", "response": "Gets the file name from the end of the URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompiles a string sympy expression or symengine expression using numba.", "response": "def numbafy(fn, args, compiler=\"jit\", **nbkws):\n    \"\"\"\n    Compile a string, sympy expression or symengine expression using numba.\n\n    Not all functions are supported by Python's numerical package (numpy). For\n    difficult cases, valid Python code (as string) may be more suitable than\n    symbolic expressions coming from sympy, symengine, etc. When compiling\n    vectorized functions, include valid signatures (see `numba`_ documentation).\n\n    Args:\n        fn: Symbolic expression as sympy/symengine expression or string\n        args (iterable): Symbolic arguments\n        compiler: String name or callable numba compiler\n        nbkws: Compiler keyword arguments (if none provided, smart defaults are used)\n\n    Returns:\n        func: Compiled function\n\n    Warning:\n        For vectorized functions, valid signatures are (almost always) required.\n    \"\"\"\n    kwargs = {}    # Numba kwargs to be updated by user\n    if not isinstance(args, (tuple, list)):\n        args = (args, )\n    # Parameterize compiler\n    if isinstance(compiler, six.string_types):\n        compiler_ = getattr(nb, compiler, None)\n        if compiler is None:\n            raise AttributeError(\"No numba function with name {}.\".format(compiler))\n        compiler = compiler_\n    if compiler in (nb.jit, nb.njit, nb.autojit):\n        kwargs.update(jitkwargs)\n        sig = nbkws.pop(\"signature\", None)\n    else:\n        kwargs.update(veckwargs)\n        sig = nbkws.pop(\"signatures\", None)\n        if sig is None:\n            warn(\"Vectorization without 'signatures' can lead to wrong results!\")\n    kwargs.update(nbkws)\n    # Expand sympy expressions and create string for eval\n    if isinstance(fn, sy.Expr):\n        fn = sy.expand_func(fn)\n    func = sy.lambdify(args, fn, modules='numpy')\n    # Machine code compilation\n    if sig is None:\n        try:\n            func = compiler(**kwargs)(func)\n        except RuntimeError:\n            kwargs['cache'] = False\n            func = compiler(**kwargs)(func)\n    else:\n        try:\n            func = compiler(sig, **kwargs)(func)\n        except RuntimeError:\n            kwargs['cache'] = False\n            func = compiler(sig, **kwargs)(func)\n    return func"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef summary(raster, geometry=None, all_touched=False, mean_only=False,\n            bounds=None, exclude_nodata_value=True):\n    \"\"\"Return ``ST_SummaryStats`` style stats for the given raster.\n\n    If ``geometry`` is provided, we mask the raster with the given geometry and\n    return the stats for the intersection. The parameter can be a GeoJSON-like\n    object, a WKT string, or a Shapely geometry.\n\n    If ``all_touched`` is set, we include every pixel that is touched by the\n    given geometry. If set to ``False``, we only include pixels that are\n    \"mostly\" inside the given geometry (the calculation is done by Rasterio).\n\n    If ``mean_only`` is ``True`` we only return the mean value of the pixels,\n    not the full set of stats.\n\n    If ``bounds`` is passed, it should be a two-tuple of (min, max) to use for\n    filtering raster pixels. If not provided, we exclude anything equal to the\n    raster no data value.\n\n    If ``mean_only`` is ``False``, we return a ``namedtuple`` representing the\n    stats. All other attributes should be obvious and are consistent with\n    PostGIS (``min``, ``max``, ``std``, etc).\n\n    If ``mean_only`` is ``True``, we simply return a ``float`` or ``None``\n    representing the mean value of the matching pixels.\n\n    The ``exclude_nodata_value`` is consistent with ``ST_SummaryStats`` in that\n    if it's ``True`` (default) we only count non-nodata pixels (or those pixels\n    within ``bounds`` if defined). If it's ``False`` we return the count of all\n    pixels.\n\n    \"\"\"\n    def no_result(mean_only):\n        if mean_only:\n            return None\n        else:\n            return Summary(None, None, None, None, None, None)\n\n    try:\n        if geometry:\n            # If it's a string, assume WKT\n            if isinstance(geometry, six.string_types):\n                geometry = wkt.loads(geometry)\n\n            # If not already GeoJSON, assume it's a Shapely shape\n            if not isinstance(geometry, dict):\n                geojson = mapping(geometry)\n            else:\n                geojson = geometry\n                geometry = shape(geometry)\n            result, _ = mask(\n                raster, [geojson], crop=True, all_touched=all_touched,\n            )\n            pixels = result.data.flatten()\n        else:\n            pixels = raster.read(1).flatten()\n    except ValueError:\n        return no_result(mean_only)\n\n    raster_shape = raster_to_shape(raster)\n    if not raster_shape.contains(geometry):\n        log.warning(\n            'Geometry {} is not fully contained by the source raster'.format(\n                geometry,\n            )\n        )\n\n    if bounds:\n        score_mask = numpy.logical_and(\n            numpy.greater_equal(pixels, bounds[0]),\n            numpy.less_equal(pixels, bounds[1]),\n        )\n    else:\n        score_mask = numpy.not_equal(pixels, raster.nodata),\n\n    scored_pixels = numpy.extract(score_mask, pixels)\n    if len(scored_pixels):\n        if mean_only:\n            return scored_pixels.mean()\n        else:\n            if exclude_nodata_value:\n                count = len(scored_pixels)\n            else:\n                count = len(pixels)\n            return Summary(\n                count,\n                scored_pixels.sum(),\n                scored_pixels.mean(),\n                scored_pixels.min(),\n                scored_pixels.max(),\n                scored_pixels.std(),\n            )\n    else:\n        return no_result(mean_only)", "response": "Return a summary of the given raster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading and render a template and return subject and content.", "response": "def parse_template(template_path, **kwargs):\n    \"\"\" Load and render template.\n        First line of template should contain the subject of email.\n        Return tuple with subject and content.\n    \"\"\"\n    template = get_template(template_path)\n    context = Context(kwargs)\n    data = template.render(context).strip()\n    subject, content = re.split(r'\\r?\\n', data, 1)\n    return (subject.strip(), content.strip())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef email_template(rcpt, template_path, **kwargs):\n\n    subject, content = parse_template(template_path, **kwargs)\n    count = send_mail(subject, content, settings.DEFAULT_FROM_EMAIL,\n                      [rcpt], fail_silently=True)\n    return bool(count)", "response": "Load and render and email template."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance_from_path(path, *args, **kwargs):\n    i = path.rfind('.')\n    module, attr = path[:i], path[i+1:]\n    try:\n        mod = import_module(module)\n    except ImportError, e:\n        raise ImproperlyConfigured('Error loading registration backend %s: \"%s\"' % (module, e))\n    try:\n        backend_class = getattr(mod, attr)\n    except AttributeError:\n        raise ImproperlyConfigured('Module \"%s\" does not define a registration backend named \"%s\"' % (module, attr))\n\n    return backend_class(*args, **kwargs)", "response": "Return an instance of a class given the dotted\n    Python import path as a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef substitute(search, replace, text):\n    'Regex substitution function. Replaces regex ``search`` with ``replace`` in ``text``'\n    return re.sub(re.compile(str(search)), replace, text)", "response": "Regex substitution function. Replaces regex search with replace in text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the object from the object store", "response": "def get(cls, route, args, kwargs):\n        \"\"\"\n        :cls        (class) <Class> of the object requested\n        :route      (dict) Debris route schema\n        :args       (list) of argument provided for initializing\n        :kwargs     (dict) of given data to construct the object\n        \"\"\"\n        # ---------\n        # Namespace\n        # ---------\n        if None in args:\n            namespace = None\n        else:\n            namespace = call(route.get('namespace'), args, kwargs) if route.get('namespace') \\\n                        else \".\".join(map(str, [cls.__name__] + list(args)))\n\n        # bool, can store in memory\n        # _in_memory = route.get('memory', True)\n\n        # ---------------\n        # Get from Memory\n        # ---------------\n        # if _in_memory and namespace:\n        # check for this namespace\n        try:\n            return debris.services.memory.get(namespace)\n        except LookupError:\n            pass\n\n        # ------------------------\n        # Constructed w/ init args\n        # ------------------------\n        # - this method bypasses many of the debris\n        #   features for cacheing because the \n        #   kwargs should contain all the construction information\n        # - replaces existing object in memory beceause this data is \n        #   given to be \"newer\" data\n        if len(kwargs) > 0:\n            cls = call(route.get('substitute'), args, kwargs) or cls\n            obj = cls.__new__(cls, *args, **kwargs)\n            obj.__init__(*args, **kwargs)\n            if namespace:\n                debris.services.memory.set(namespace, obj)\n            return obj\n\n        elif not namespace:\n            raise LookupError(\"No id/key provided to initialize object \"+namespace.replace('.', '(', 1).replace('.', ', ')+\")\")\n\n        # -----------------\n        # Retrieve the Data\n        # -----------------\n        insp = inspect.getargspec(cls.__init__)\n        data = None\n        if route.get('get'):\n            for r in route['get']:\n                if r['service'] == 'postgresql':\n                    iwargs = dict([(k, args[i] if len(args) > i else None) for i, k in enumerate(insp.args[1:])])\n                    data = r[\"bank\"].get(r['query'], **iwargs)\n                else:\n                    data = r[\"bank\"].get(namespace)\n                if data:\n                    break\n\n            # -----------------\n            # Retrieve the Data\n            # -----------------\n            if not data:\n                raise LookupError(\"Data could not be found for \"+namespace.replace('.', '(', 1).replace('.', ', ')+\")\")\n\n        if not data:\n            data = {}\n\n        # --------------------\n        # Manage Args / Kwargs\n        # --------------------\n        # remove the default \"self\" argument\n        insp.args.pop(0)\n        [data.pop(k) for k in insp.args if k in data]\n\n        # substiture class w/ known data\n        if route.get('substitute'):\n            cls = callattr(cls, route['substitute'], args, data) or cls\n\n        # ----------------\n        # Initialize Class\n        # ----------------\n        obj = cls.__new__(cls, *args, **data)\n        obj.__init__(*args, **data)\n\n        # ---------------\n        # Store in Memory\n        # ---------------\n        if namespace:\n            debris.services.memory.set(namespace, obj)\n\n        # return the constructed object\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets many objects from Memory and return them as a list of new ones.", "response": "def getmany(cls, route, args, kwargs, _keys):\n        \"\"\"\n        1. build name space\n        2. look locally for copies\n        3. build group for batch\n        4. fetch the new ones\n        5. return found + new list\n        \"\"\"\n        # copy the list of keys\n        keys = [] + _keys\n        # build a list of returning objects\n        returning = []\n        # dictionary of references\n        namespaces = {} # key: ns\n        namespace_keys = {} # ns: key\n        \n        # shorthand\n        returning_append = returning.append\n        memory_get = debris.services.memory.get\n        memory_set = debris.services.memory.set\n\n        # ---------------\n        # Get from Memory\n        # ---------------\n        for key in keys:\n            # ---------\n            # Namespace\n            # ---------\n            namespace = call(route.get('namespace'), args + [key], kwargs) if route.get('namespace') \\\n                        else \".\".join(map(str, [cls.__name__] + args + [key]))\n            \n            # check for this namespace\n            try:\n                returning_append(memory_get(namespace))\n            except LookupError:\n                # not found, add to namespace list\n                namespaces[str(key)] = namespace\n                namespace_keys[namespace] = str(key)\n\n        if not namespaces:\n            # all data found, return the findings\n            return returning\n\n        # -----------------\n        # Retrieve the Data\n        # -----------------\n        insp = inspect.getargspec(cls.__init__)\n        insp.args.pop(0) # self\n        data = None\n        for r in route['get']:\n            if r['service'] == 'postgresql':\n                iwargs = dict([(k, args[i] if len(args) > i else None) for i, k in enumerate(insp.args[:-1])])\n                iwargs[insp.args[-1]] = namespaces.keys()\n                # create a limit, speed up the query\n                iwargs['limit'] = len(namespaces)\n                results = r[\"bank\"].getmany(r['query[]'], **iwargs)\n                if results:\n                    # retrieve the key from the results. hacky way, but works\n                    key = insp.args[-1]\n                    # pop out the \"key\" for each row, ex. \"id\", then switch to the namespace\n                    # keys[row.pop('id')] => \"user.1\"\n                    results = [(namespaces[str(row[key])], row) for row in results]\n\n            else:\n                results = r[\"bank\"].getmany(namespaces.values())\n\n            # Results Found\n            # -------------\n            if results:\n                # [(ns, data), ...]\n                for namespace, data in results:\n                    if data:\n                        # substiture class w/ known data\n                        # ------------------------------\n                        if route.get('substitute'):\n                            _cls = callattr(cls, route.get('substitute'), args, data) or cls\n                        else:\n                            _cls = cls\n\n                        # initialize class\n                        # ----------------\n                        obj = _cls.__new__(_cls, *args, **data)\n                        obj.__init__(*args, **data)\n\n                        # store in memory\n                        # ---------------\n                        memory_set(namespace, obj)\n                        namespaces.pop(namespace_keys.pop(namespace))\n\n                        # add the constructed object\n                        # --------------------------\n                        returning_append(obj)\n\n        return returning"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the data from the DB into the object.", "response": "def _load_data(self, data, from_db=False):\n        \"\"\"\n        Stores the data at self._data, actual object creation done at _generate_instances()\n\n        Args:\n            data (list): List of dicts.\n            from_db (bool): Default False. Is this data coming from DB or not.\n        \"\"\"\n        self._data = data[:]\n        self.setattrs(\n            values=[],\n            node_stack=[],\n            node_dict={},\n        )\n        self._from_db = from_db"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the list of instances.", "response": "def _generate_instances(self):\n        \"\"\"\n        ListNode item generator. Will be used internally by __iter__ and __getitem__\n\n        Yields:\n            ListNode items (instances)\n        \"\"\"\n        for node in self.node_stack:\n            yield node\n        while self._data:\n            yield self._make_instance(self._data.pop(0))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a ListNode instance from node_data.", "response": "def _make_instance(self, node_data):\n        \"\"\"\n        Create a ListNode instance from node_data\n\n        Args:\n            node_data (dict): Data to create ListNode item.\n        Returns:\n            ListNode item.\n        \"\"\"\n        node_data['from_db'] = self._from_db\n        clone = self.__call__(**node_data)\n        clone.setattrs(container = self,\n                    _is_item = True)\n        for name in self._nodes:\n            _name = un_camel(name)\n            if _name in node_data:  # check for partial data\n                getattr(clone, name)._load_data(node_data[_name])\n        _key = clone._get_linked_model_key()\n        if _key:\n            self.node_dict[_key] = clone\n        return clone"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npopulate json serialization ready data.", "response": "def clean_value(self):\n        \"\"\"\n        Populates json serialization ready data.\n        This is the method used to serialize and store the object data in to DB\n\n        Returns:\n            List of dicts.\n        \"\"\"\n        result = []\n        for mdl in self:\n            result.append(super(ListNode, mdl).clean_value())\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove an item from the container ListNode.", "response": "def remove(self):\n        \"\"\"\n        Removes an item from ListNode.\n\n        Raises:\n            TypeError: If it's called on container ListNode (intstead of ListNode's item)\n\n        Note:\n            Parent object should be explicitly saved.\n        \"\"\"\n        if not self._is_item:\n            raise TypeError(\"Should be called on an item, not ListNode's itself.\")\n        self.container.node_stack.remove(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild all triples for an entity and returns a list of all relevant data", "response": "def entityTriples(self, aURI):\n        \"\"\" Builds all triples for an entity\n        Note: if a triple object is a blank node (=a nested definition)\n        we try to extract all relevant data recursively (does not work with\n        sparql endpoins)\n        2015-10-18: updated\n        \"\"\"\n\n        aURI = aURI\n        qres = self.rdfgraph.query(\n              \"\"\"CONSTRUCT {<%s> ?y ?z }\n                 WHERE {\n                     { <%s> ?y ?z }\n                 }\n                 \"\"\" % (aURI, aURI ))\n        lres = list(qres)\n\n        def recurse(triples_list):\n            \"\"\" uses the rdflib <triples> method to pull out all blank nodes info\"\"\"\n            out = []\n            for tripl in triples_list:\n                if isBlankNode(tripl[2]):\n                    # print \"blank node\", str(tripl[2])\n                    temp = [x for x in self.rdfgraph.triples((tripl[2], None, None))]\n                    out += temp + recurse(temp)\n                else:\n                    pass\n            return out\n\n        try:\n            return lres + recurse(lres)\n        except:\n            printDebug(\"Error extracting blank nodes info\", \"important\")\n            return lres"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getAllClasses(self, hide_base_schemas=True):\n        query = \"\"\"SELECT DISTINCT ?x ?c\n                 WHERE {\n                         {\n                             { ?x a owl:Class }\n                             union\n                             { ?x a rdfs:Class }\n                             union\n                             { ?x rdfs:subClassOf ?y }\n                             union\n                             { ?z rdfs:subClassOf ?x }\n                             union\n                             { ?y rdfs:domain ?x }\n                             union\n                             { ?y rdfs:range ?x }\n                             # union\n                             # { ?y rdf:type ?x }\n                         } .\n\n                         ?x a ?c\n\n                    %s\n\n                 }\n                 ORDER BY  ?x\n                 \"\"\"\n        if hide_base_schemas:\n            query = query %  \"\"\"FILTER(\n                     !STRSTARTS(STR(?x), \"http://www.w3.org/2002/07/owl\")\n                     && !STRSTARTS(STR(?x), \"http://www.w3.org/1999/02/22-rdf-syntax-ns\")\n                     && !STRSTARTS(STR(?x), \"http://www.w3.org/2000/01/rdf-schema\")\n                     && !STRSTARTS(STR(?x), \"http://www.w3.org/2001/XMLSchema\")\n                     && !STRSTARTS(STR(?x), \"http://www.w3.org/XML/1998/namespace\")\n                     && (!isBlank(?x))\n                      ) .\"\"\"\n        else:\n            query = query % \"\"\n\n        qres = self.rdfgraph.query(query)\n        return list(qres)", "response": "getAllClasses - Returns a list of all classes in the database"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnotes requires SPARQL 1.1 2015-06-04: currenlty not used, inferred from above", "response": "def getClassAllSupers(self, aURI):\n        \"\"\"\n        note: requires SPARQL 1.1\n        2015-06-04: currenlty not used, inferred from above\n        \"\"\"\n        aURI = aURI\n        try:\n            qres = self.rdfgraph.query(\n                  \"\"\"SELECT DISTINCT ?x\n                     WHERE {\n                         { <%s> rdfs:subClassOf+ ?x }\n                         FILTER (!isBlank(?x))\n                     }\n                     \"\"\" % (aURI))\n        except:\n            printDebug(\"... warning: the 'getClassAllSupers' query failed (maybe missing SPARQL 1.1 support?)\")\n            qres = []\n        return list(qres)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnote requires SPARQL 1.1 2015-06-04: currenlty not used, inferred from above", "response": "def getClassAllSubs(self, aURI):\n        \"\"\"\n        note: requires SPARQL 1.1\n        2015-06-04: currenlty not used, inferred from above\n        \"\"\"\n        aURI = aURI\n        try:\n            qres = self.rdfgraph.query(\n                  \"\"\"SELECT DISTINCT ?x\n                     WHERE {\n                         { ?x rdfs:subClassOf+ <%s> }\n                         FILTER (!isBlank(?x))\n                     }\n                     \"\"\" % (aURI))\n        except:\n            printDebug(\"... warning: the 'getClassAllSubs' query failed (maybe missing SPARQL 1.1 support?)\")\n            qres = []\n        return list(qres)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnote requires SPARQL 1.1 2015-06-04: currenlty not used, inferred from above", "response": "def getPropAllSupers(self, aURI):\n        \"\"\"\n        note: requires SPARQL 1.1\n        2015-06-04: currenlty not used, inferred from above\n        \"\"\"\n        aURI = aURI\n        try:\n            qres = self.rdfgraph.query(\n                  \"\"\"SELECT DISTINCT ?x\n                     WHERE {\n                         { <%s> rdfs:subPropertyOf+ ?x }\n                         FILTER (!isBlank(?x))\n                     }\n                     \"\"\" % (aURI))\n        except:\n            printDebug(\"... warning: the 'getPropAllSupers' query failed (maybe missing SPARQL 1.1 support?)\")\n            qres = []\n        return list(qres)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getPropAllSubs(self, aURI):\n        aURI = aURI\n        try:\n            qres = self.rdfgraph.query(\n                  \"\"\"SELECT DISTINCT ?x\n                     WHERE {\n                         { ?x rdfs:subPropertyOf+ <%s> }\n                         FILTER (!isBlank(?x))\n                     }\n                     \"\"\" % (aURI))\n        except:\n            printDebug(\"... warning: the 'getPropAllSubs' query failed (maybe missing SPARQL 1.1 support?)\")\n            qres = []\n        return list(qres)", "response": "getPropAllSubs - returns a list of all the properties of a specific class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encode(self):\n        root_element = ElementTree.Element(self.TAG_NAME)\n        for value in [value for value in self.__dict__.values() if isinstance(value, fields.Field)]:\n            if value.required or value.value:\n                root_element.append(value.encode())\n        return root_element", "response": "Encodes the object to a xml. etree. ElementTree. Element object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a progressbar that works in Jupyter Notebooks and the terminal.", "response": "def progressbar(\n\t\titerable=None, length=None, label=None,\n\t\tshow_eta=True, show_percent=None, show_pos=False, item_show_func=None,\n\t\tfill_char='#', empty_char='-', bar_template='%(label)s [%(bar)s] %(info)s', info_sep=' ',\n\t\twidth=36, file=None, color=None):\n\t\"\"\"Create a progressbar that works in Jupyter/IPython notebooks and the terminal\"\"\"\n\t\n\ttry:\n\t\treturn IPyBackend(iterable, length, label=label,\n\t\t\tshow_eta=show_eta, show_percent=show_percent, show_pos=show_pos,\n\t\t\titem_show_func=item_show_func, info_sep=info_sep)\n\texcept (ImportError, RuntimeError): #fall back if ipython is not installed or no notebook is running\n\t\treturn click.progressbar(\n\t\t\titerable, length, label,\n\t\t\tshow_eta, show_percent, show_pos, item_show_func,\n\t\t\tfill_char, empty_char, bar_template, info_sep,\n\t\t\twidth, file, color)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot a graph in a single X axis.", "response": "def plot(graph, show_x_axis=True,\n             head=None, tail=None, label_length=4, padding=0,\n             height=2, show_min_max=True, show_data_range=True,\n             show_title=True):\n        \"\"\"\n        show_x_axis: Display X axis\n        head: Show first [head:] elements\n        tail: Show last [-tail:] elements\n        padding: Padding size between columns (default 0)\n        height: Override graph height\n        label_length: Force X axis label string size, may truncate label\n        show_min_max: Display Min and Max values on the left of the graph\n        show_title: Display graph title (if any)\n        show_data_range: Display X axis data range\n        \"\"\"\n        def __plot(graph):\n            def get_padding_str(label, value):\n                padding_str = ''\n                if  len(label) < label_length:\n                    diff = label_length - len(label)\n                    padding_str = ' ' * diff\n                padding_str2 = ''\n                if  len(str(value)) < m:\n                    diff = m - len(str(value))\n                    padding_str2 = ' ' * diff\n                return '%s%s' % (padding_str,padding_str2)\n            out = zip(*graph.strings)\n            out.reverse()\n            if graph.title and show_title:\n                print graph.title\n            lines = [sep.join(a) for a in out]\n            if show_min_max:\n                lines[0] = lines[0] + \"   -- Max: %s\" % str(max(graph.data))\n                lines[-1] = lines[-1] + \"   -- Min %s\" % str(min(graph.data))\n            print '\\n'.join(lines)\n            if graph.labels and show_x_axis:\n                print (u'%s' % x_sep.join(['<%s>[%s]%s'\n                        % (label[:label_length], str(v),\n                            get_padding_str(label, v))\n                            for label, v in zip(graph.labels, graph.data)]))\n            if show_data_range and graph.labels:\n                print 'Data range: %s - %s' % (graph.first_x, graph.last_x)\n\n        graph.clean_range()\n        if head:\n            graph.head = head\n        if tail:\n            graph.tail = tail\n\n        if height:\n            graph.height = height\n\n        if label_length < 1:\n            label_length = 4\n\n        max_label_length = max(map(len, graph.labels or ['']))\n\n        if max_label_length < label_length:\n            label_length = max_label_length\n\n        sep = ''\n        if padding >= 1:\n            sep = ' ' * padding\n        m = max(map(len, map(str, graph.data)))  # length of longest value\n        x_sep = '  '\n        if show_x_axis and graph.labels:\n            # 2('[])' + 2('<>') + 1 space\n            sep = ' ' * (label_length + 1 + 2 + m + 2)\n\n        __plot(graph)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the index of the column representation of the given value", "response": "def __get_stack_id(self, value, values, height):\n        \"\"\"\n        Returns the index of the column representation of the given value\n\n                                                  \u2581  \u2582  \u2583  \u2584  \u2585  \u2586  \u2587' ...\n                             \u2581  \u2582  \u2583  \u2584  \u2585  \u2586  \u2587' \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  ...\n        \u2581  \u2582  \u2583  \u2584  \u2585  \u2586  \u2587' \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  \u2587  ...\n        0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 ...\n\n        For example given the values: 1, 2, 3, ..., 20, 21:\n            And we are looking for the index value of 21:\n            This function will return index 20\n        \"\"\"\n\n        def step(values, height):\n            step_range = max(values) - min(values)\n            return (((step_range / float((len(self.__list) * height) - 1)))\n                    or 1)\n\n        step_value = step(values, height)\n        return int(round((value - min(values)) / step_value))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef seaborn_set(context='poster', style='white', palette='colorblind',\n                font_scale=1.3, font='serif', rc=mpl_rc):\n    \"\"\"\n    Perform `seaborn.set(**kwargs)`.\n\n    Additional keyword arguments are passed in using this module's\n    `attr:mpl_rc` attribute.\n    \"\"\"\n    sns.set(context=\"poster\", style=\"white\", palette=\"colorblind\",\n            font_scale=1.3, font=\"serif\", rc=mpl_rc)", "response": "Perform `seaborn.set(**kwargs)`.\n\n    Additional keyword arguments are passed in using this module's\n    `attr:mpl_rc` attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _gen_figure(nxplot=1, nyplot=1, figargs=None, projection=None,\n                sharex='none', joinx=False, sharey='none', joiny=False,\n                x=None, nxlabel=None, xlabels=None, nxdecimal=None, xmin=None, xmax=None,\n                y=None, nylabel=None, ylabels=None, nydecimal=None, ymin=None, ymax=None,\n                z=None, nzlabel=None, zlabels=None, nzdecimal=None, zmin=None, zmax=None,\n                r=None, nrlabel=None, rlabels=None, nrdecimal=None, rmin=None, rmax=None,\n                t=None, ntlabel=None, tlabels=None, fontsize=20):\n    \"\"\"\n    Returns a figure object with as much customization as provided.\n    \"\"\"\n    figargs = {} if figargs is None else figargs\n    if projection is not None:\n        fig, axs = _gen_projected(nxplot, nyplot, projection, figargs)\n    else:\n        fig, axs = _gen_shared(nxplot, nyplot, sharex, sharey, figargs)\n    adj = {}\n    if joinx: adj.update({'hspace': 0})\n    if joiny: adj.update({'wspace': 0})\n    fig.subplots_adjust(**adj)\n    data = {}\n    if projection is None:\n        data = {'x': x, 'y': y}\n    elif projection == '3d':\n        data = {'x': x, 'y': y, 'z': z}\n    elif projection == 'polar':\n        data = {'r': r, 't': t}\n    methods = {}\n    for ax in axs:\n        if 'x' in data:\n            methods['x'] = (ax.set_xlim, ax.set_xticks, ax.set_xticklabels,\n                            nxlabel, xlabels, nxdecimal, xmin, xmax)\n        if 'y' in data:\n            methods['y'] = (ax.set_ylim, ax.set_yticks, ax.set_yticklabels,\n                            nylabel, ylabels, nydecimal, ymin, ymax)\n        if 'z' in data:\n            methods['z'] = (ax.set_zlim, ax.set_zticks, ax.set_zticklabels,\n                            nzlabel, zlabels, nzdecimal, zmin, zmax)\n        if 'r' in data:\n            methods['r'] = (ax.set_rlim, ax.set_rticks, ax.set_rgrids,\n                            nrlabel, rlabels, nrdecimal, rmin, rmax)\n        if 't' in data:\n            methods['t'] = (ax.set_thetagrids, ntlabel, tlabels)\n        for dim, arr in data.items():\n            if dim == 't':\n                grids, nlabel, labls = methods[dim]\n                if ntlabel is not None:\n                    theta = np.arange(0, 2 * np.pi, 2 * np.pi / ntlabel)\n                    if labls is not None:\n                        grids(np.degrees(theta), labls, fontsize=fontsize)\n                    else:\n                        grids(np.degrees(theta), fontsize=fontsize)\n            else:\n                lim, ticks, labels, nlabel, labls, decs, mins, maxs = methods[dim]\n                if arr is not None:\n                    amin = mins if mins is not None else arr.min()\n                    amax = maxs if maxs is not None else arr.max()\n                    lim((amin, amax))\n                elif mins is not None and maxs is not None:\n                    if nlabel is not None:\n                        ticks(np.linspace(amin, amax, nlabel))\n                        if decs is not None:\n                            sub = \"{{:.{}f}}\".format(decs).format\n                            labels([sub(i) for i in np.linspace(amin, amax, nlabel)])\n                if labls is not None:\n                    labels(labls)\n                ax.tick_params(axis=dim, labelsize=fontsize)\n    return fig", "response": "Generates a figure object with as much customization as provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_key(data_object, key, cardinal=False):\n    itype = (int, np.int32, np.int64)\n    if not isinstance(key, itype + (slice, tuple, list, np.ndarray)):\n        raise KeyError(\"Unknown key type {} for key {}\".format(type(key), key))\n    keys = data_object.index.values\n    if cardinal and data_object._cardinal is not None:\n        keys = data_object[data_object._cardinal[0]].unique()\n    elif isinstance(key, itype) and key in keys:\n        key = list(sorted(data_object.index.values[key]))\n    elif isinstance(key, itype) and key < 0:\n        key = list(sorted(data_object.index.values[key]))\n    elif isinstance(key, itype):\n        key = [key]\n    elif isinstance(key, slice):\n        key = list(sorted(data_object.index.values[key]))\n    elif isinstance(key, (tuple, list, pd.Index)) and not np.all(k in keys for k in key):\n        key = list(sorted(data_object.index.values[key]))\n    return key", "response": "Check if a key is in the index and if not update the value of an index key by matching values or getting positionals."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nslice a data object based on its index value slice tuple or list of indices and positionals Returns a new data object based on its index value slice tuple or list of indices and positionals", "response": "def slice_naive(self, key):\n        \"\"\"\n        Slice a data object based on its index, either by value (.loc) or\n        position (.iloc).\n\n        Args:\n            key: Single index value, slice, tuple, or list of indices/positionals\n\n        Returns:\n            data: Slice of self\n        \"\"\"\n        cls = self.__class__\n        key = check_key(self, key)\n        return cls(self.loc[key])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cardinal_groupby(self):\n        g, t = self._cardinal\n        self[g] = self[g].astype(t)\n        grpby = self.groupby(g)\n        self[g] = self[g].astype('category')\n        return grpby", "response": "Group this object by the _cardinal dimension."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef slice_cardinal(self, key):\n        cls = self.__class__\n        key = check_key(self, key, cardinal=True)\n        return cls(self[self[self._cardinal[0]].isin(key)])", "response": "Returns a slice of this object by the value or values of the cardinal\n        dimension."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy(self, *args, **kwargs):\n        cls = self.__class__    # Note that type conversion does not perform copy\n        return cls(pd.Series(self).copy(*args, **kwargs))", "response": "Make a copy of this object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self, *args, **kwargs):\n        cls = self.__class__    # Note that type conversion does not perform copy\n        return cls(pd.DataFrame(self).copy(*args, **kwargs))", "response": "Make a copy of this object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a copy of this object.", "response": "def copy(self, *args, **kwargs):\n        \"\"\"\n        Make a copy of this object.\n\n        Note:\n            Copies both field data and field values.\n\n        See Also:\n            For arguments and description of behavior see `pandas docs`_.\n\n        .. _pandas docs: http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.copy.html\n        \"\"\"\n        cls = self.__class__    # Note that type conversion does not perform copy\n        data = pd.DataFrame(self).copy(*args, **kwargs)\n        values = [field.copy() for field in self.field_values]\n        return cls(data, field_values=values)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef memory_usage(self):\n        data = super(Field, self).memory_usage()\n        values = 0\n        for value in self.field_values:\n            values += value.memory_usage()\n        data['field_values'] = values\n        return data", "response": "Get the combined memory usage of the field data and field values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef slice_naive(self, key):\n        cls = self.__class__\n        key = check_key(self, key)\n        enum = pd.Series(range(len(self)))\n        enum.index = self.index\n        values = self.field_values[enum[key].values]\n        data = self.loc[key]\n        return cls(data, field_values=values)", "response": "Slice the data and values of the record with the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef release(self):\n        self.clear()\n\n        if hasattr(self, \"functions\"):\n            del self.functions\n\n        if hasattr(self, \"lib\") and self.lib is not None:\n            self.lib._jit_destroy_state(self.state)\n            self.lib = None", "response": "Destroys the state along with its functions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear(self):\n        if not self._clear:\n            self.lib._jit_clear_state(self.state)\n            self._clear = True", "response": "Clears state so it can be used for generating entirely new\n        instructions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef emit_function(self, return_type=None, argtypes=[], proxy=True):\n\n        if argtypes is not None:\n            make_func = ctypes.CFUNCTYPE(return_type, *argtypes)\n        else:\n            make_func = ctypes.CFUNCTYPE(return_type)\n\n        # NOTE: An optional way of binding the function is to use cffi.\n        # It's a tad faster then emit_function_fast:\n        #   import cffi\n        #   ffi = cffi.FFI()\n        #   ...\n        #   code = jit.emit()\n        #   func = ffi.cast(\"long (*fptr)(long, long)\", code.value)\n        #   func(123)\n\n        code = self.emit()\n        func = make_func(code.value)\n\n        # Save this in case anyone wants to disassemble using external\n        # libraries\n        func.address = code\n\n        # Because functions code are munmapped when we call _jit_destroy_state,\n        # we need to return weakrefs to the functions. Otherwise, a user could\n        # call a function that points to invalid memory.\n        if proxy:\n            self.functions.append(func)\n            return weakref.proxy(func)\n        else:\n            return func", "response": "Compiles code and returns a Python - callable function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange the url of that attachment", "response": "async def change_url(self, url: str, description: str = None):\n        \"\"\" change the url of that attachment\n\n        |methcoro|\n\n        Args:\n            url: url you want to change\n            description: *optional* description for your attachment\n\n        Raises:\n            ValueError: url must not be None\n            APIException\n\n        \"\"\"\n        await self._change(url=url, description=description)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def change_file(self, file_path: str, description: str = None):\n        with open(file_path, 'rb') as f:\n            await self._change(asset=f.read())", "response": "Change the file of that attachment"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps for tornado requests. Example ``` class MainHandler(tornado.web.RequestHandler): @debris.tornado.cached(\"home-page\") def get(self): self.write(\"Hello, world\") ```", "response": "def cached(namespace=None, service=\"memory\", debug=False):\n    \"\"\"\n    Wrapper for tornado requests. Example\n\n    ```\n    class MainHandler(tornado.web.RequestHandler):\n        @debris.tornado.cached(\"home-page\")\n        def get(self):\n            self.write(\"Hello, world\")\n\n    ```\n\n    \"\"\"\n    _service = getattr(debris.services, service)\n    def wrapper(_f):\n        @functools.wraps(_f)\n        def _stash(self, *a, **k):\n            if debug is False:\n                # this request is cacheable\n                try:\n                    self.finish(_service.get(namespace))\n                except LookupError:\n                    _replace_finish(self, namespace, _service)\n                    # get the result of this request\n                    _f(self, *a, **k)\n                return\n            # request is not cacheable\n            _f(self, *a, **k)\n        return _stash\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind out if an executable exists in the supplied PATH and returns the absolute path to the executable.", "response": "def which(program, environ=None):\n    \"\"\"\n    Find out if an executable exists in the supplied PATH.\n    If so, the absolute path to the executable is returned.\n    If not, an exception is raised.\n\n    :type string\n    :param program: Executable to be checked for\n\n    :param dict\n    :param environ: Any additional ENV variables required, specifically PATH\n\n    :return string|:class:`command.CommandException` Returns the location if found, otherwise raises exception\n    \"\"\"\n    def is_exe(path):\n        \"\"\"\n        Helper method to check if a file exists and is executable\n        \"\"\"\n        return isfile(path) and os.access(path, os.X_OK)\n\n    if program is None:\n        raise CommandException(\"Invalid program name passed\")\n\n    fpath, fname = split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        if environ is None:\n            environ = os.environ\n\n        for path in environ['PATH'].split(os.pathsep):\n            exe_file = join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    raise CommandException(\"Could not find %s\" % program)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun a given command on the given system within a set time period.", "response": "def run(command, timeout=None, cwd=None, env=None, debug=None):\n    \"\"\"\n    Runs a given command on the system within a set time period, providing an easy way to access\n    command output as it happens without waiting for the command to finish running.\n\n    :type list\n    :param command: Should be a list that contains the command that should be ran on the given\n                    system. The only whitespaces that can occur is for paths that use a backslash\n                    to escape it appropriately\n\n    :type int\n    :param timeout: Specificed in seconds. If a command outruns the timeout then the command and\n                    its child processes will be terminated. The default is to run\n\n    :type string\n    :param cwd: If cwd is set then the current directory will be changed to cwd before it is executed.\n                Note that this directory is not considered when searching the executable, so you\n                can\u2019t specify the program\u2019s path relative to cwd.\n\n    :type dict\n    :param env: A dict of any ENV variables that should be combined into the OS ENV that will help\n                the command to run successfully. Note that more often than not the command run\n                does not have the same ENV variables available as your shell by default and as such\n                require some assistance.\n\n    :type function\n    :param debug: A function (also a class function) can be passed in here and all output, line by line,\n                  from the command being run will be passed to it as it gets outputted to stdout.\n                  This allows for things such as logging (using the built in python logging lib)\n                  what is happening on long running commands or redirect output of a tail -f call\n                  as lines get outputted without having to wait till the command finishes.\n\n    :return returns :class:`Command.Response` that contains the exit code and the output from the command\n    \"\"\"\n    return Command.run(command, timeout=timeout, cwd=cwd, env=env, debug=debug)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(cls, command, timeout=None, cwd=None, env=None, debug=None):\n\n        # Merge together the system ENV details and the passed in ones if any\n        environ = dict(os.environ)\n        environ.update(env or {})\n\n        # If string is passed in for the command then attempt to split it up\n        if isinstance(command, str):\n            command = shlex.split(command)\n\n        # Check if the executable is executable and in fact exists\n        which(command[0], environ)\n\n        # Use tempfile to get past a limitation with subprocess.PIPE and 64kb.\n        # Also to have a file to plug into the track generator\n        outputtmp = tempfile.NamedTemporaryFile()\n\n        try:\n            # Verify debug is in fact a function we can call\n            debug_output = False\n            if debug and (callable(debug) or hasattr(debug, \"__call__\")):\n                debug_output = True\n\n            if debug_output:\n                def track(thefile, shutdown=None):\n                    \"\"\"Process the temp file until a valid line is found and return it\"\"\"\n                    thefile.seek(0, 2)\n                    while True:\n                        if shutdown and shutdown.isSet():\n                            break\n\n                        line = thefile.readline()\n                        if not line:\n                            time.sleep(0.00001)\n                            continue\n                        yield line\n\n                def track_run(output, debug, shutdown_event):\n                    \"\"\"Wrap track and pass information on the fly to the debug process\"\"\"\n                    for line in track(output, shutdown_event):\n                        debug(line.rstrip())\n\n                # Run the track generator in a separate thread so we can run the command\n                shutdown_event = threading.Event()\n                thread = threading.Thread(\n                    target=track_run,\n                    args=(open(outputtmp.name, 'rb'), debug, shutdown_event),\n                    name='Monitoring'\n                )\n                thread.start()\n\n            def target():\n                # Run the actual command\n                cls.process = subprocess.Popen(\n                    command,\n                    universal_newlines=True,\n                    shell=False,\n                    env=environ,\n                    cwd=cwd,\n                    preexec_fn=os.setsid,\n                    stdout=outputtmp,\n                    stderr=outputtmp\n                )\n\n                cls.process.communicate()\n\n            # Deal with timeout\n            thread = threading.Thread(target=target, name='Command Runner')\n            thread.start()\n            thread.join(timeout)\n\n            if thread.is_alive():\n                cls.process.terminate()\n                thread.join()\n                if thread.is_alive():\n                    cls.process.kill()\n\n            # Prime the response\n            response = Response\n            response.command = command\n            response.exit = cls.process.returncode\n\n            # Fetch from the temp file\n            outputtmp.seek(0, 0)\n            response.output = outputtmp.read().strip()\n            outputtmp.close()\n\n            if response.exit < 0:\n                raise CommandException(\"command ('%s') was terminated by signal: %s\"\n                                       % (' '.join(command), -response.exit),\n                                       response.exit,\n                                       response.output)\n            if response.exit > 0:\n                raise CommandException(\"command ('%s') exited with value: %s\\n\\n%s\"\n                                       % (' '.join(command), str(response.exit), response.output),\n                                       response.exit,\n                                       response.output)\n\n            return response\n        except OSError as error:\n            # Use fake exit code since we can't get the accurate one from this\n            raise CommandException(\"command failed: %s\" % error, 1, error)\n        except subprocess.CalledProcessError as error:\n            raise CommandException(error.output, error.returncode, error.output)\n        finally:\n            if debug_output:\n                shutdown_event.set()", "response": "Runs a given command on the given system within a set time period."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef form_invalid(self, form):\n        ip = get_user_ip(self.request)\n        if settings.CONTACT_FORM_USE_SIGNALS:\n            contact_form_invalid.send(\n                sender=self,\n                event=self.invalid_event,\n                ip=ip,\n                site=self.site,\n                sender_name=form['sender_name'],\n                sender_email=form['sender_email']\n            )\n\n        return super(ContactFormView, self).form_invalid(form)", "response": "This is what s called when the form is invalid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbind the DJANGO_TEMPLATE_* settings to the right settings. name according to django - version", "response": "def bind_settings():\n    \"\"\"\n    Put DJANGO_TEMPLATE_* under the right settings.* name according to django-version\n    :return:\n    \"\"\"\n    from django_productline import settings\n\n    if settings.TEMPLATE_LOADER_CACHED_ENABLED:\n        loaders = [\n            ['django.template.loaders.cached.Loader', settings.DJANGO_TEMPLATE_LOADERS]\n        ]\n    else:\n        loaders = settings.DJANGO_TEMPLATE_LOADERS\n\n    if compare_version(django.get_version(), '1.9') >= 0:\n\n        TEMPLATES = [\n            {\n                'BACKEND': settings.DJANGO_TEMPLATE_BACKEND,\n                'DIRS': settings.DJANGO_TEMPLATE_DIRS,\n                'OPTIONS': {\n                    'builtins': settings.DJANGO_TEMPLATE_BUILTINS,\n                    'context_processors': settings.DJANGO_TEMPLATE_CONTEXT_PROCESSORS,\n                    'loaders': loaders,\n                    'debug': settings.DJANGO_TEMPLATE_DEBUG\n                },\n            },\n        ]\n\n        setattr(settings, 'TEMPLATES', TEMPLATES)\n\n    else:\n        setattr(settings, 'TEMPLATE_DEBUG', settings.DJANGO_TEMPLATE_DEBUG)\n        setattr(settings, 'TEMPLATE_DIRS', settings.DJANGO_TEMPLATE_DIRS)\n        setattr(settings, 'TEMPLATE_CONTEXT_PROCESSORS', settings.DJANGO_TEMPLATE_CONTEXT_PROCESSORS)\n        setattr(settings, 'TEMPLATE_LOADERS', loaders)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a Tag to current object", "response": "def add_tag(self, name):\n        \"\"\"\n        Create a Tag to current object\n\n        :param name: the name of the tag\n        :type name: str\n        :return: newly created Tag\n        :rtype: Tag\n        \"\"\"\n        from highton.models.tag import Tag\n        created_id = self._post_request(\n            endpoint=self.ENDPOINT + '/' + str(self.id) + '/' + Tag.ENDPOINT,\n            data=self.element_to_string(\n                Tag(name=name).__dict__.get('name').encode()\n            )\n        ).headers.get('Location').replace('.xml', '').split('/')[-1]\n        return Tag.get(created_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the lower bin edge values for the spectrogram.", "response": "def time_bins(header):\n  '''\n  Returns the time-axis lower bin edge values for the spectrogram.\n  '''\n  return np.arange(header['number_of_half_frames'], dtype=np.float64)*constants.bins_per_half_frame\\\n  *(1.0 - header['over_sampling']) / header['subband_spacing_hz']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the frequency - axis lower bin edge values for the spectrogram.", "response": "def frequency_bins(header):\n  '''\n  Returnes the frequency-axis lower bin edge values for the spectrogram. \n  '''\n\n  center_frequency = 1.0e6*header['rf_center_frequency']\n  if header[\"number_of_subbands\"] > 1:\n    center_frequency += header[\"subband_spacing_hz\"]*(header[\"number_of_subbands\"]/2.0 - 0.5)\n\n  return np.fft.fftshift(\\\n    np.fft.fftfreq( int(header[\"number_of_subbands\"] * constants.bins_per_half_frame*(1.0 - header['over_sampling'])), \\\n      1.0/(header[\"number_of_subbands\"]*header[\"subband_spacing_hz\"])) + center_frequency\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a 3D complex signal into a fourier signal.", "response": "def complex_to_fourier(cdata, over_sampling, norm=None):\n  '''\n  cdata: 3D complex data (shaped by subbands and half_frames, as returned from Compamp.complex_data())\n  over_sampling: The fraction of oversampling across subbands (typically 0.25)\n  norm: None or \"ortho\" -- see Numpy FFT Normalization documentation. Default is None.\n\n  returns the signal in complex fourier space. The output fourier data are shifted so the central frequency\n  is at the center of the values. All over-sampled frequencies have been removed so that all frequency bins\n  can be properly arranged next to each other. \n  '''\n  \n  # FFT all blocks separately and rearrange output\n  fftcdata = np.fft.fftshift(np.fft.fft(cdata, norm=norm), 2)  \n  \n  # slice out oversampled frequencies\n  if over_sampling > 0:\n    fftcdata = fftcdata[:, :, int(cdata.shape[2]*over_sampling/2):-int(cdata.shape[2]*over_sampling/2)] \n    \n  return fftcdata"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fourier_to_time(fcdata, norm=None):\n  '''\n  Converts the data from 2D fourier space signal to a 1D time-series.\n\n  fcdata: Complex fourier spectrum as a 2D array, The axis=0 is for each \"half frame\", and axis=1 contains the\n  fourier-space data for that half frame. Typically there are 129 \"half frames\" in the data. \n  Furthermore, it's assumed that fftshift has placed the central frequency at the center of axis=1.\n\n  norm: None or \"ortho\" -- see Numpy FFT Normalization documentation. Default is None.\n\n  Usage:\n\n    aca = ibmseti.compamp.Compamp(raw_data)\n    cdata = aca.complex_data()  #cdata is a 3D numpy array in the time domain.\n    #can manipulate cdata in time-space if desired (use various windowing functions, for example)\n    fcdata = ibmseti.dsp.complex_to_fourier(cdata, aca.header()['over_sampling'])\n    fcdata_2d = ibmseti.dsp.reshape_to_2d(fcdata)\n    tcdata_1d = ibmseti.dsp.fourier_to_time(fcdata_2d)\n\n\n  One can recover the Fourier Spectrum of cdata_1d by:\n\n    cdata_2d = cdata_1d.reshape(aca.header()['number_of_half_frames'], int(aca.header()['number_of_subbands'] * ibmseti.constants.bins_per_half_frame*(1 - aca.header()['over_sampling'])))\n    fcdata_2d_v2 = np.fft.fftshift(np.fft.fft(cdata_2d), 1)\n\n    #fcdata_2d_v2 and fcdata_2d should be the same\n    np.sum(np.sum(fcdata_2d - fcdata_2d_v2))  # should equal to approximately 0\n\n  '''\n\n  return np.fft.ifft(np.fft.ifftshift(fcdata, 1),norm=norm).reshape(fcdata.shape[0] * fcdata.shape[1])", "response": "Converts the data from 2D fourier space signal to 1D time - series."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nassumes a 3D Numpy array, and reshapes like arr.reshape((arr.shape[0], arr.shape[1]*arr.shape[2])) This is useful for converting processed data from `complex_to_power` and from `autocorrelation` into a 2D array for image analysis and display.", "response": "def reshape_to_2d(arr):\n  '''\n  Assumes a 3D Numpy array, and reshapes like\n  \n  arr.reshape((arr.shape[0], arr.shape[1]*arr.shape[2]))\n\n  This is useful for converting processed data from `complex_to_power`\n  and from `autocorrelation` into a 2D array for image analysis and display.\n\n  '''\n  return arr.reshape((arr.shape[0], arr.shape[1]*arr.shape[2]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compamp_to_spectrogram(compamp):\n  '''\n  Returns spectrogram, with each row containing the measured power spectrum for a XX second time sample.\n\n  Using this function is shorthand for:\n      aca = ibmseti.compamp.Compamp(raw_data)\n      power = ibmseti.dsp.complex_to_power(aca.complex_data(), aca.header()['over_sampling'])\n      spectrogram = ibmseti.dsp.reshape_to_2d(power)\n\n  Example Usage: \n      import ibmseti\n      import matplotlib.pyplot as plt\n      plt.ion()\n  \n      aca = ibmseti.compamp.Compamp(raw_data)\n\n      spectrogram = ibmseti.dsp.compamp_to_spectrogram(aca)\n      time_bins = ibmseti.dsp.time_bins( aca.header() )\n      freq_bins = ibmseti.dsp.frequency_bins( aca.header() )\n\n      fig, ax = plt.subplots()\n      ax.pcolormesh(freq_bins, time_bins, spectrogram)\n\n      #Time is on the horizontal axis and frequency is along the vertical.\n\n  '''\n\n  power = complex_to_power(compamp.complex_data(), compamp.header()['over_sampling'])\n  \n  return reshape_to_2d(power)", "response": "Returns spectrogram for a given compamp."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compamp_to_ac(compamp, window=np.hanning):  # convert single or multi-subband compamps into autocorrelation waterfall\n\n  '''\n  Adapted from Gerry Harp at SETI.\n  \n  '''\n  header = compamp.header()\n \n  cdata = compamp.complex_data()\n\n  #Apply Windowing and Padding\n  cdata = np.multiply(cdata, window(cdata.shape[2]))  # window for smoothing sharp time series start/end in freq. dom.\n  cdata_normal = cdata - cdata.mean(axis=2)[:, :, np.newaxis]  # zero mean, does influence a minority of lines in some plots\n\n  cdata = np.zeros((cdata.shape[0], cdata.shape[1], 2 * cdata.shape[2]), complex)\n  cdata[:, :, cdata.shape[2]/2:cdata.shape[2] + cdata.shape[2]/2] = cdata_normal  # zero-pad to 2N\n\n  #Perform Autocorrelation\n  cdata = np.fft.fftshift(np.fft.fft(cdata), 2)  # FFT all blocks separately and arrange correctly\n  cdata = cdata.real**2 + cdata.imag**2  # FFT(AC(x)) = FFT(x)FFT*(x) = abs(x)^2\n  cdata = np.fft.ifftshift(np.fft.ifft(cdata), 2)  # AC(x) = iFFT(abs(x)^2) and arrange correctly\n  cdata = np.abs(cdata)  # magnitude of AC\n\n  # normalize each row to sqrt of AC triangle\n  cdata = np.divide(cdata, np.sqrt(np.sum(cdata, axis=2))[:, :, np.newaxis])  \n\n  return cdata", "response": "Convert a single or multi - band compamp into an autocorrelation time series."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ac_viz(acdata):\n  '''\n  Adapted from Gerry Harp at SETI.\n  \n  Slightly massages the autocorrelated calculation result for better visualization.\n\n  In particular, the natural log of the data are calculated and the\n  values along the subband edges are set to the maximum value of the data, \n  and the t=0 delay of the autocorrelation result are set to the value of the t=-1 delay.\n\n  This is allowed because the t=0, and subband edges do not carry any information. \n\n  To avoid log(0), a value of 0.000001 is added to all array elements before being logged. \n  '''\n\n  acdata = np.log(acdata+0.000001)  # log to reduce darkening on sides of spectrum, due to AC triangling\n  acdata[:, :, acdata.shape[2]/2] = acdata[:, :, acdata.shape[2]/2 - 1]  # vals at zero delay set to symmetric neighbor vals\n  acdata[:, :, acdata.shape[2] - 1] = np.max(acdata)  # visualize subband edges\n\n  return acdata", "response": "Visualize the autocorrelated calculation result for better visualization."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef relation(x_start, x_end, y_start, y_end):\n\n        if (x_end - x_start) < 0 or (y_end - y_start) < 0:\n            return None\n\n        diff_end = y_end - x_end\n\n        if diff_end < 0:\n            return -Allen.relation(y_start, y_end, x_start, x_end)\n\n        diff_start = y_start - x_start\n        gab = y_start - x_end\n\n        if diff_end == 0:\n            if diff_start == 0:\n                return Allen.X_EQUAL_Y\n\n            if diff_start < 0:\n                return Allen.X_FINISHES_Y\n\n            return Allen.X_FINISHES_Y_INVERSE\n\n        if gab > 1:\n            return Allen.X_BEFORE_Y\n\n        if gab == 1:\n            return Allen.X_MEETS_Y\n\n        if diff_start > 0:\n            return Allen.X_OVERLAPS_WITH_Y\n\n        if diff_start == 0:\n            return Allen.X_STARTS_Y\n\n        if diff_start < 0:\n            return Allen.X_DURING_Y", "response": "Returns the relation between two intervals."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef server_factory(global_conf, host, port, **options):\r\n  port = int(port)\r\n\r\n  try:\r\n    import paste.util.threadinglocal as pastelocal\r\n    pastelocal.local = local\r\n  except ImportError:\r\n    pass\r\n  def serve(app):\r\n    runner = Runner(host, port, app, options)\r\n    runner.run()\r\n  return serve", "response": "Returns a server factory for paste.\r\n"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_response(self, status, headers, exc_info = None):\r\n    if self.started_response:\r\n      if not exc_info:\r\n        raise AssertionError(\"WSGI start_response called a second \"\r\n                   \"time with no exc_info.\")\r\n      else:\r\n        try:\r\n          raise exc_info[0], exc_info[1], exc_info[2]\r\n        finally:\r\n          exc_info = None\r\n    self.started_response = True\r\n    self.status = status\r\n    self.outheaders.extend(headers)\r\n\r\n    return self.write_buffer.write", "response": "WSGI callable to begin the HTTP response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a operation for writing a simple response back to the client.", "response": "def simple_response(self, status, msg=\"\"):\r\n    \"\"\"Return a operation for writing simple response back to the client.\"\"\"\r\n    status = str(status)\r\n    buf = [\"%s %s\\r\\n\" % (self.environ['ACTUAL_SERVER_PROTOCOL'], status),\r\n         \"Content-Length: %s\\r\\n\" % len(msg),\r\n         \"Content-Type: text/plain\\r\\n\"]\r\n\r\n    if status[:3] == \"413\" and self.response_protocol == 'HTTP/1.1':\r\n      # Request Entity Too Large\r\n      self.close_connection = True\r\n      buf.append(\"Connection: close\\r\\n\")\r\n\r\n    buf.append(\"\\r\\n\")\r\n    if msg:\r\n      buf.append(msg)\r\n    return sockets.SendAll(self.conn, \"\".join(buf))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serve(self):\r\n    # We don't have to trap KeyboardInterrupt or SystemExit here,\r\n\r\n    # Select the appropriate socket\r\n    if isinstance(self.bind_addr, basestring):\r\n      # AF_UNIX socket\r\n\r\n      # So we can reuse the socket...\r\n      try: os.unlink(self.bind_addr)\r\n      except: pass\r\n\r\n      # So everyone can access the socket...\r\n      try: os.chmod(self.bind_addr, 0777)\r\n      except: pass\r\n\r\n      info = [(socket.AF_UNIX, socket.SOCK_STREAM, 0, \"\", self.bind_addr)]\r\n    else:\r\n      # AF_INET or AF_INET6 socket\r\n      # Get the correct address family for our host (allows IPv6 addresses)\r\n      host, port = self.bind_addr\r\n      try:\r\n        info = socket.getaddrinfo(host, port, socket.AF_UNSPEC,\r\n                      socket.SOCK_STREAM, 0, socket.AI_PASSIVE)\r\n      except socket.gaierror:\r\n        # Probably a DNS issue. Assume IPv4.\r\n        info = [(socket.AF_INET, socket.SOCK_STREAM, 0, \"\", self.bind_addr)]\r\n\r\n    self.socket = None\r\n    msg = \"No socket could be created\"\r\n    for res in info:\r\n      af, socktype, proto, canonname, sa = res\r\n      #~ print res\r\n      try:\r\n        self.bind(af, socktype, proto)\r\n      except socket.error, msg:\r\n        if self.socket:\r\n          self.socket.close()\r\n        self.socket = None\r\n        continue\r\n      break\r\n    if not self.socket:\r\n      raise socket.error, msg\r\n\r\n    self.socket.listen(self.request_queue_size)\r\n    with closing(self.socket):\r\n      while True:\r\n        try:\r\n          s, addr = yield sockets.Accept(self.socket, timeout=-1)\r\n          s.settimeout(self.sockoper_timeout)\r\n        except Exception, exc:\r\n          # make acceptor more robust in the face of weird\r\n          # accept bugs, XXX: but we might get a infinite loop\r\n\r\n          #~ import warnings\r\n          #~ warnings.warn(\"Accept thrown an exception: %s\" % exc)\r\n\r\n          import traceback\r\n          traceback.print_exc()\r\n          continue\r\n\r\n        environ = self.environ.copy()\r\n        environ[\"SERVER_SOFTWARE\"] = self.version\r\n        # set a non-standard environ entry so the WSGI app can know what\r\n        # the *real* server protocol is (and what features to support).\r\n        # See http://www.faqs.org/rfcs/rfc2145.html.\r\n        environ[\"ACTUAL_SERVER_PROTOCOL\"] = self.protocol\r\n        environ[\"SERVER_NAME\"] = self.server_name\r\n\r\n        if isinstance(self.bind_addr, basestring):\r\n          # AF_UNIX. This isn't really allowed by WSGI, which doesn't\r\n          # address unix domain sockets. But it's better than nothing.\r\n          environ[\"SERVER_PORT\"] = \"\"\r\n        else:\r\n          environ[\"SERVER_PORT\"] = str(self.bind_addr[1])\r\n          # optional values\r\n          # Until we do DNS lookups, omit REMOTE_HOST\r\n          environ[\"REMOTE_ADDR\"] = addr[0]\r\n          environ[\"REMOTE_PORT\"] = str(addr[1])\r\n\r\n        conn = self.ConnectionClass(s, self.wsgi_app, environ,\r\n          self.sendfile_timeout)\r\n        yield events.AddCoro(conn.run, prio=priority.LAST if\r\n                                     self.sockaccept_greedy else priority.FIRST)", "response": "Start the server forever."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind(self, family, type, proto=0):\r\n    self.socket = sockets.Socket(family, type, proto)\r\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    self.socket.setblocking(0)\r\n    #~ self.socket.setsockopt(socket.SOL_SOCKET, socket.TCP_NODELAY, 1)\r\n    self.socket.bind(self.bind_addr)", "response": "Bind to the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self, name):\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "response": "Loads and returns foreign library."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the return and parameter types for the foreign C functions.", "response": "def _set_signatures(self):\n        \"\"\"Sets return and parameter types for the foreign C functions.\"\"\"\n\n        # We currently pass structs as void pointers.\n        code_t = ctypes.c_int\n        gpr_t = ctypes.c_int32\n        int32_t = ctypes.c_int32\n        node_p = ctypes.c_void_p\n        pointer_t = ctypes.c_void_p\n        state_p = ctypes.c_void_p\n        void = None\n\n        def sig(rettype, fname, *ptypes):\n            func = getattr(self.lib, fname)\n            func.restype = rettype\n            func.argtypes = ptypes\n\n        sig(node_p, \"_jit_arg\", state_p)\n        sig(node_p, \"_jit_finishi\", state_p, pointer_t)\n        sig(node_p, \"_jit_forward\", state_p)\n        sig(node_p, \"_jit_indirect\", state_p)\n        sig(node_p, \"_jit_label\", state_p)\n        sig(node_p, \"_jit_new_node_p\", state_p, code_t, pointer_t)\n        sig(node_p, \"_jit_new_node_pww\", state_p, code_t, pointer_t, word_t, word_t)\n        sig(node_p, \"_jit_new_node_qww\", state_p, code_t, int32_t, int32_t, word_t)\n        sig(node_p, \"_jit_new_node_w\", state_p, code_t, word_t)\n        sig(node_p, \"_jit_new_node_ww\", state_p, code_t, word_t, word_t)\n        sig(node_p, \"_jit_new_node_www\", state_p, code_t, word_t, word_t, word_t)\n        sig(node_p, \"_jit_note\", state_p, char_p, ctypes.c_int)\n        sig(pointer_t, \"_jit_address\", state_p, node_p)\n        sig(pointer_t, \"_jit_emit\", state_p)\n        sig(state_p, \"jit_new_state\")\n        sig(void, \"_jit_clear_state\", state_p)\n        sig(void, \"_jit_destroy_state\", state_p)\n        sig(void, \"_jit_ellipsis\", state_p)\n        sig(void, \"_jit_epilog\", state_p)\n        sig(void, \"_jit_finishr\", state_p, gpr_t)\n        sig(void, \"_jit_getarg_i\", state_p, gpr_t, node_p)\n        sig(void, \"_jit_getarg_l\", state_p, gpr_t, node_p)\n        sig(void, \"_jit_link\", state_p, node_p)\n        sig(void, \"_jit_patch\", state_p, node_p)\n        sig(void, \"_jit_patch_at\", state_p, node_p, node_p)\n        sig(void, \"_jit_prepare\", state_p)\n        sig(void, \"_jit_prolog\", state_p)\n        sig(void, \"_jit_pushargi\", state_p, word_t)\n        sig(void, \"_jit_pushargr\", state_p, gpr_t)\n        sig(void, \"_jit_ret\", state_p)\n        sig(void, \"_jit_reti\", state_p, word_t)\n        sig(void, \"_jit_retr\", state_p, gpr_t)\n        sig(void, \"_jit_retval_c\", state_p, gpr_t)\n        sig(void, \"_jit_retval_i\", state_p, gpr_t)\n        sig(void, \"_jit_retval_s\", state_p, gpr_t)\n        sig(void, \"_jit_retval_uc\", state_p, gpr_t)\n        sig(void, \"_jit_retval_us\", state_p, gpr_t)\n        sig(void, \"finish_jit\")\n        sig(void, \"init_jit\", ctypes.c_char_p) # NOTE: Don't use char_p\n\n        if wordsize == 64:\n            sig(void, \"_jit_retval_l\", state_p, gpr_t)\n            sig(void, \"_jit_retval_ui\", state_p, gpr_t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new JIT state.", "response": "def state(self):\n        \"\"\"Returns a new JIT state. You have to clean up by calling .destroy()\n        afterwards.\n        \"\"\"\n        return Emitter(weakref.proxy(self.lib), self.lib.jit_new_state())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting any sequence or mapping to list or OrderedDicts", "response": "def __to_plain_containers(self,\n                              container: Union[CommentedSeq, CommentedMap]\n                              ) -> Union[OrderedDict, list]:\n        \"\"\"Converts any sequence or mapping to list or OrderedDict\n\n        Stops at anything that isn't a sequence or a mapping.\n\n        One day, we'll extract the comments and formatting and store \\\n        them out-of-band.\n\n        Args:\n            mapping: The mapping of constructed subobjects to edit\n        \"\"\"\n        if isinstance(container, CommentedMap):\n            new_container = OrderedDict()  # type: Union[OrderedDict, list]\n            for key, value_obj in container.items():\n                if (isinstance(value_obj, CommentedMap)\n                        or isinstance(value_obj, CommentedSeq)):\n                    new_container[key] = self.__to_plain_containers(value_obj)\n                else:\n                    new_container[key] = value_obj\n\n        elif isinstance(container, CommentedSeq):\n            new_container = list()\n            for value_obj in container:\n                if (isinstance(value_obj, CommentedMap)\n                        or isinstance(value_obj, CommentedSeq)):\n                    new_container.append(self.__to_plain_containers(value_obj))\n                else:\n                    new_container.append(value_obj)\n        return new_container"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nseparates the extra attributes in mapping into a dict containing all key - value pairs and additional key - value pairs.", "response": "def __split_off_extra_attributes(self, mapping: CommentedMap,\n                                     known_attrs: List[str]) -> CommentedMap:\n        \"\"\"Separates the extra attributes in mapping into yatiml_extra.\n\n        This returns a mapping containing all key-value pairs from \\\n        mapping whose key is in known_attrs, and an additional key \\\n        yatiml_extra which maps to a dict containing the remaining \\\n        key-value pairs.\n\n        Args:\n            mapping: The mapping to split\n            known_attrs: Attributes that should be kept in the main \\\n                    map, and not moved to yatiml_extra.\n\n        Returns:\n            A map with attributes reorganised as described above.\n        \"\"\"\n        attr_names = list(mapping.keys())\n        main_attrs = mapping.copy()\n        extra_attrs = OrderedDict(mapping.items())\n        for name in attr_names:\n            if name not in known_attrs or name == 'yatiml_extra':\n                del (main_attrs[name])\n            else:\n                del (extra_attrs[name])\n        main_attrs['yatiml_extra'] = extra_attrs\n        return main_attrs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __type_matches(self, obj: Any, type_: Type) -> bool:\n        if is_generic_union(type_):\n            for t in generic_type_args(type_):\n                if self.__type_matches(obj, t):\n                    return True\n            return False\n        elif is_generic_list(type_):\n            if not isinstance(obj, list):\n                return False\n            for item in obj:\n                if not self.__type_matches(item, generic_type_args(type_)[0]):\n                    return False\n            return True\n        elif is_generic_dict(type_):\n            if not isinstance(obj, OrderedDict):\n                return False\n            for key, value in obj:\n                if not isinstance(key, generic_type_args(type_)[0]):\n                    return False\n                if not self.__type_matches(value, generic_type_args(type_)[1]):\n                    return False\n            return True\n        else:\n            return isinstance(obj, type_)", "response": "Checks that the object is of the given type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that all required attributes are present and that they are of the correct type.", "response": "def __check_no_missing_attributes(self, node: yaml.Node,\n                                      mapping: CommentedMap) -> None:\n        \"\"\"Checks that all required attributes are present.\n\n        Also checks that they're of the correct type.\n\n        Args:\n            mapping: The mapping with subobjects of this object.\n\n        Raises:\n            RecognitionError: if an attribute is missing or the type \\\n                is incorrect.\n        \"\"\"\n        logger.debug('Checking presence of required attributes')\n        for name, type_, required in class_subobjects(self.class_):\n            if required and name not in mapping:\n                raise RecognitionError(('{}{}Missing attribute {} needed for'\n                                        ' constructing a {}').format(\n                                            node.start_mark, os.linesep, name,\n                                            self.class_.__name__))\n            if name in mapping and not self.__type_matches(\n                    mapping[name], type_):\n                raise RecognitionError(('{}{}Attribute {} has incorrect type'\n                                        ' {}, expecting a {}').format(\n                                            node.start_mark, os.linesep, name,\n                                            type(mapping[name]), type_))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __type_check_attributes(self, node: yaml.Node, mapping: CommentedMap,\n                                argspec: inspect.FullArgSpec) -> None:\n        \"\"\"Ensure all attributes have a matching constructor argument.\n\n        This checks that there is a constructor argument with a \\\n        matching type for each existing attribute.\n\n        If the class has a yatiml_extra attribute, then extra \\\n        attributes are okay and no error will be raised if they exist.\n\n        Args:\n            node: The node we're processing\n            mapping: The mapping with constructed subobjects\n            constructor_attrs: The attributes of the constructor, \\\n                    including self and yatiml_extra, if applicable\n        \"\"\"\n        logger.debug('Checking for extraneous attributes')\n        logger.debug('Constructor arguments: {}, mapping: {}'.format(\n            argspec.args, list(mapping.keys())))\n        for key, value in mapping.items():\n            if not isinstance(key, str):\n                raise RecognitionError(('{}{}YAtiML only supports strings'\n                                        ' for mapping keys').format(\n                                            node.start_mark, os.linesep))\n            if key not in argspec.args and 'yatiml_extra' not in argspec.args:\n                raise RecognitionError(\n                    ('{}{}Found additional attributes'\n                     ' and {} does not support those').format(\n                         node.start_mark, os.linesep, self.class_.__name__))\n\n            if key in argspec.args and not self.__type_matches(\n                    value, argspec.annotations[key]):\n                raise RecognitionError(('{}{}Expected attribute {} to be of'\n                                        ' type {} but it is a(n) {}').format(\n                                            node.start_mark, os.linesep, key,\n                                            argspec.annotations[key],\n                                            type(value)))", "response": "Checks that all attributes of the class are of the correct type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstrip tags from extra attributes.", "response": "def __strip_extra_attributes(self, node: yaml.Node,\n                                 known_attrs: List[str]) -> None:\n        \"\"\"Strips tags from extra attributes.\n\n        This prevents nodes under attributes that are not part of our \\\n        data model from being converted to objects. They'll be plain \\\n        CommentedMaps instead, which then get converted to OrderedDicts \\\n        for the user.\n\n        Args:\n            node: The node to process\n            known_attrs: The attributes to not strip\n        \"\"\"\n        known_keys = list(known_attrs)\n        known_keys.remove('self')\n        if 'yatiml_extra' in known_keys:\n            known_keys.remove('yatiml_extra')\n\n        for key_node, value_node in node.value:\n            if (not isinstance(key_node, yaml.ScalarNode)\n                    or key_node.tag != 'tag:yaml.org,2002:str'):\n                raise RecognitionError(\n                    ('{}{}Mapping keys that are not of type'\n                     ' string are not supported by YAtiML.').format(\n                         node.start_mark, os.linesep))\n            if key_node.value not in known_keys:\n                self.__strip_tags(value_node)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstrip tags from mappings in the tree headed by node.", "response": "def __strip_tags(self, node: yaml.Node) -> None:\n        \"\"\"Strips tags from mappings in the tree headed by node.\n\n        This keeps yaml from constructing any objects in this tree.\n\n        Args:\n            node: Head of the tree to strip\n        \"\"\"\n        if isinstance(node, yaml.SequenceNode):\n            for subnode in node.value:\n                self.__strip_tags(subnode)\n        elif isinstance(node, yaml.MappingNode):\n            node.tag = 'tag:yaml.org,2002:map'\n            for key_node, value_node in node.value:\n                self.__strip_tags(key_node)\n                self.__strip_tags(value_node)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef publish(self, message, key=None, **kws):\r\n        return PSPut(self, message, key, **kws)", "response": "Put a message in the queue and update any coroutine wating with\r\n        fetch."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompacting the queue by removing all the messages that have been fetched by all the subscribed coroutines. Returns the number of messages that have been removed.", "response": "def compact(self):\r\n        \"\"\"Compacts the queue: removes all the messages from the queue that\r\n        have been fetched by all the subscribed coroutines.\r\n        Returns the number of messages that have been removed.\"\"\"\r\n        if self.subscribers:\r\n            level = min(self.subscribers.itervalues())\r\n            if level:\r\n                del self.messages[:level]\r\n            return level\r\n        else:\r\n            level = len(self.messages)\r\n            del self.messages[:]\r\n            return level"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_provider_support(provider, media_type):\n    if provider.lower() not in API_ALL:\n        return False\n    provider_const = \"API_\" + media_type.upper()\n    return provider in globals().get(provider_const, {})", "response": "Verifies if given API provider has support for requested media type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef provider_factory(provider, **options):\n    try:\n        return {\"tmdb\": TMDb, \"tvdb\": TVDb}[provider.lower()](**options)\n    except KeyError:\n        msg = \"Attempted to initialize non-existing DB Provider\"\n        log.error(msg)\n        raise MapiException(msg)", "response": "Factory function for DB Provider Concrete Classes\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a year or dash - delimited year range into a year range and year range.", "response": "def _year_expand(s):\n        \"\"\" Parses a year or dash-delimeted year range\n        \"\"\"\n        regex = r\"^((?:19|20)\\d{2})?(\\s*-\\s*)?((?:19|20)\\d{2})?$\"\n        try:\n            start, dash, end = match(regex, ustr(s)).groups()\n            start = start or 1900\n            end = end or 2099\n        except AttributeError:\n            return 1900, 2099\n        return (int(start), int(end)) if dash else (int(start), int(start))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef search(self, id_key=None, **parameters):\n        id_tmdb = parameters.get(\"id_tmdb\") or id_key\n        id_imdb = parameters.get(\"id_imdb\")\n        title = parameters.get(\"title\")\n        year = parameters.get(\"year\")\n\n        if id_tmdb:\n            yield self._search_id_tmdb(id_tmdb)\n        elif id_imdb:\n            yield self._search_id_imdb(id_imdb)\n        elif title:\n            for result in self._search_title(title, year):\n                yield result\n        else:\n            raise MapiNotFoundException", "response": "Searches TMDb for movie metadata."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch TVDb for movie metadata and returns a generator of the metadata objects.", "response": "def search(self, id_key=None, **parameters):\n        \"\"\" Searches TVDb for movie metadata\n\n        TODO: Consider making parameters for episode ids\n        \"\"\"\n        episode = parameters.get(\"episode\")\n        id_tvdb = parameters.get(\"id_tvdb\") or id_key\n        id_imdb = parameters.get(\"id_imdb\")\n        season = parameters.get(\"season\")\n        series = parameters.get(\"series\")\n        date = parameters.get(\"date\")\n\n        if id_tvdb:\n            for result in self._search_id_tvdb(id_tvdb, season, episode):\n                yield result\n        elif id_imdb:\n            for result in self._search_id_imdb(id_imdb, season, episode):\n                yield result\n        elif series and date:\n            if not match(\n                r\"(19|20)\\d{2}(-(?:0[1-9]|1[012])(-(?:[012][1-9]|3[01]))?)?\",\n                date,\n            ):\n                raise MapiProviderException(\"Date must be in YYYY-MM-DD format\")\n            for result in self._search_series_date(series, date):\n                yield result\n        elif series:\n            for result in self._search_series(series, season, episode):\n                yield result\n        else:\n            raise MapiNotFoundException"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake all directories up to d.", "response": "def _mkdirs(d):\n    \"\"\"\n    Make all directories up to d.\n\n    No exception is raised if d exists.\n    \"\"\"\n    try:\n        os.makedirs(d)\n    except OSError as e:\n        if e.errno != errno.EEXIST:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _templated(fn):\n    @functools.wraps(fn)\n    def inner(ctl):\n        return [i.format(**ctl) for i in fn(ctl)]\n    return inner", "response": "Returns a function which applies str. format to all results of\n    fn."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator that yields the results of applying map_fn to each control file in control_iter.", "response": "def nest_map(control_iter, map_fn):\n    \"\"\"\n    Apply ``map_fn`` to the directories defined by ``control_iter``\n\n    For each control file in control_iter, map_fn is called with the directory\n    and control file contents as arguments.\n\n    Example::\n\n        >>> list(nest_map(['run1/control.json', 'run2/control.json'],\n        ...               lambda d, c: c['run_id']))\n        [1, 2]\n\n    :param control_iter: Iterable of paths to JSON control files\n    :param function map_fn: Function to run for each control file. It should\n            accept two arguments: the directory of the control file and the\n            json-decoded contents of the control file.\n    :returns: A generator of the results of applying ``map_fn`` to elements in\n            ``control_iter``\n    \"\"\"\n    def fn(control_path):\n        \"\"\"\n        Read the control file, return the result of calling map_fn\n        \"\"\"\n        with open(control_path) as fp:\n            control = ordered_load(fp)\n        dn = os.path.dirname(control_path)\n        return map_fn(dn, control)\n\n    mapped = imap(fn, control_iter)\n    return mapped"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate the names of all control files under base_dir", "response": "def control_iter(base_dir, control_name=CONTROL_NAME):\n    \"\"\"\n    Generate the names of all control files under base_dir\n    \"\"\"\n    controls = (os.path.join(p, control_name) for p, _, fs in os.walk(base_dir)\n                if control_name in fs)\n    return controls"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter(self, root=None):\n        if root is None:\n            return iter(self._controls)\n        return ((os.path.join(root, outdir), control)\n                for outdir, control in self._controls)", "response": "Create an iterator of ( directory control_dict ) tuples for all valid\n        parameter choices in this Nest."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a nested directory structure starting in root", "response": "def build(self, root=\"runs\"):\n        \"\"\"\n        Build a nested directory structure, starting in ``root``\n\n        :param root: Root directory for structure\n        \"\"\"\n\n        for d, control in self.iter(root):\n            _mkdirs(d)\n            with open(os.path.join(d, self.control_name), 'w') as fp:\n                json.dump(control, fp, indent=self.indent)\n                # RJSON and some other tools like a trailing newline\n                fp.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new entry to the nestable control dictionary.", "response": "def add(self, name, nestable, create_dir=True, update=False,\n            label_func=str, template_subs=False):\n        \"\"\"\n        Add a level to the nest\n\n        :param string name: Name of the level. Forms the key in the output\n            dictionary.\n        :param nestable: Either an iterable object containing values, _or_ a\n            function which takes a single argument (the control dictionary)\n            and returns an iterable object containing values\n        :param boolean create_dir: Should a directory level be created for this\n            nestable?\n        :param boolean update: Should the control dictionary be updated with\n            the results of each value returned by the nestable? Only valid for\n            dictionary results; useful for updating multiple values. At a\n            minimum, a key-value pair corresponding to ``name`` must be\n            returned.\n        :param label_func: Function to be called to convert each value to a\n            directory label.\n        :param boolean template_subs: Should the strings in / returned by\n            nestable be treated as templates? If true, str.format is called\n            with the current values of the control dictionary.\n        \"\"\"\n        # Convert everything to functions\n        if not callable(nestable):\n            if not _is_iter(nestable):\n                raise ValueError(\"Invalid nestable: \" + str(nestable))\n            if is_string(nestable):\n                warnings.warn(\n                        \"Passed a string as an iterable for name {0}\".format(name))\n            old_nestable = nestable\n            nestable = _repeat_iter(old_nestable)\n        if template_subs:\n            nestable = _templated(nestable)\n\n        new_controls = []\n        for outdir, control in self._controls:\n            for r in nestable(control):\n                new_outdir, new_control = outdir, control.copy()\n                if update:\n                    # Make sure expected key exists\n                    if name not in r:\n                        raise KeyError(\"Missing key for {0}\".format(name))\n                    # Check for collisions\n                    u = frozenset(control.keys()) & frozenset(r.keys())\n                    if u:\n                        msg = \"Key overlap: {0}\".format(u)\n                        if self.fail_on_clash:\n                            raise KeyError(msg)\n                        elif self.warn_on_clash:\n                            warnings.warn(msg)\n                    new_control.update(r)\n                    to_label = r[name]\n                else:\n                    new_control[name] = to_label = r\n\n                if create_dir:\n                    new_outdir = os.path.join(outdir, label_func(to_label))\n                if self.include_outdir:\n                    new_control['OUTDIR'] = new_outdir\n                new_controls.append((new_outdir, new_control))\n\n        self._controls = new_controls"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compose(self, *args, **kwargs):\r\n        linebreak = kwargs.pop(\"linebreak\", \"\\n\")\r\n        # Update the internally stored args/kwargs from which formatting arguments come\r\n        if len(args) > 0:\r\n            self.args = args\r\n        self._update(**kwargs)\r\n        # Format string arguments (for the modified template)\r\n        fkwargs = {}    # Format string keyword arguments\r\n        modtmpl = []    # The modified template lines\r\n        #curpos = 0      # Positional argument counter\r\n        #i = 0\r\n        for line in self:\r\n            cline = copy(line)\r\n            # If any special formatters exist, handle them\r\n            for match in self._regex.findall(line):\r\n                search = \"[{}]\".format(\"|\".join(match))\r\n                name, indent, delim, qual, _ = match\r\n                if indent != \"\":\r\n                    indent = \" \"*int(indent)\r\n                delim = delim.replace(\"\\\\|\", \"|\")\r\n                # Collect and format the data accordingly\r\n                data = getattr(self, name, None)\r\n                # If no data exists, treat as optional\r\n                if data is None:\r\n                    cline = cline.replace(search, \"\")\r\n                    continue\r\n                elif delim.isdigit():\r\n                    fkwargs[name] = getattr(self, \"_fmt_\"+name)()\r\n                else:\r\n                    fkwargs[name] = linebreak.join([indent+k+delim+qual+v+qual for k, v in data.items()])\r\n                cline = cline.replace(search, \"{\"+name+\"}\")\r\n            modtmpl.append(cline)\r\n        modtmpl = \"\\n\".join(modtmpl)\r\n        print(modtmpl)\r\n        dct = self.get_kwargs()\r\n        dct.update(fkwargs)\r\n        return self._constructor(textobj=modtmpl.format(*self.args, **dct))", "response": "Generates a file from the current template and given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_kwargs(self):\r\n        return {k: v for k, v in vars(self).items() if k not in self._ignored}", "response": "Return kwargs from attached attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef complete(self):\n        return self._post_request(\n            data='',\n            endpoint=self.ENDPOINT + '/' + str(self.id) + '/complete'\n        )", "response": "Complete current task\n        :return:\n        :rtype: requests.models.Response"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_upcoming(cls):\n        return fields.ListField(name=cls.ENDPOINT, init_class=cls).decode(\n            cls.element_from_string(\n                cls._get_request(endpoint=cls.ENDPOINT + '/upcoming').text\n            )\n        )", "response": "Returns a collection of upcoming tasks for the authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef print_headers(head, outfile=None, silent=False):\n    for header_line in head.print_header():\n        \n        if outfile:\n            outfile.write(header_line+'\\n')\n        else:\n            if not silent:\n                print(header_line)\n    return", "response": "Print the headers of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints a single line of text to a file.", "response": "def print_variant(variant_line, outfile=None, silent=False):\n    \"\"\"\n    Print a variant.\n    \n    If a result file is provided the variante will be appended to the file, \n    otherwise they are printed to stdout.\n    \n    Args:\n        variants_file (str): A string with the path to a file\n        outfile (FileHandle): An opened file_handle\n        silent (bool): Bool. If nothing should be printed.\n    \n    \"\"\"\n    variant_line = variant_line.rstrip()\n    if not variant_line.startswith('#'):\n        if outfile:\n            outfile.write(variant_line+'\\n')\n        else:\n            if not silent:\n                print(variant_line)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lines_from_file(path, as_interned=False, encoding=None):\n    lines = None\n    with io.open(path, encoding=encoding) as f:\n        if as_interned:\n            lines = [sys.intern(line) for line in f.read().splitlines()]\n        else:\n            lines = f.read().splitlines()\n    return lines", "response": "Create a list of file lines from a given filepath."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a list of file lines from a given file stream.", "response": "def lines_from_stream(f, as_interned=False):\n    \"\"\"\n    Create a list of file lines from a given file stream.\n\n    Args:\n        f (io.TextIOWrapper): File stream\n        as_interned (bool): List of \"interned\" strings (default False)\n\n    Returns:\n        strings (list): File line list\n    \"\"\"\n    if as_interned:\n        return [sys.intern(line) for line in f.read().splitlines()]\n    return f.read().splitlines()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lines_from_string(string, as_interned=False):\n    if as_interned:\n        return [sys.intern(line) for line in string.splitlines()]\n    return string.splitlines()", "response": "Create a list of file lines from a given string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, path=None, *args, **kwargs):\n        if path is None:\n            print(self.format(*args, **kwargs))\n        else:\n            with io.open(path, 'w', newline=\"\") as f:\n                f.write(self.format(*args, **kwargs))", "response": "Write the formatted string to a file or stdout."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the string representation of the object.", "response": "def format(self, *args, **kwargs):\n        \"\"\"\n        Format the string representation of the editor.\n\n        Args:\n            inplace (bool): If True, overwrite editor's contents with formatted contents\n        \"\"\"\n        inplace = kwargs.pop(\"inplace\", False)\n        if not inplace:\n            return str(self).format(*args, **kwargs)\n        self._lines = str(self).format(*args, **kwargs).splitlines()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef head(self, n=10):\n        r = self.__repr__().split('\\n')\n        print('\\n'.join(r[:n]), end=' ')", "response": "Display the top of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef append(self, lines):\n        if isinstance(lines, list):\n            self._lines = self._lines + lines\n        elif isinstance(lines, str):\n            lines = lines.split('\\n')\n            self._lines = self._lines + lines\n        else:\n            raise TypeError('Unsupported type {0} for lines.'.format(type(lines)))", "response": "Append a list of line strings to the end of the editor s log file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insert(self, lines=None):\n        for i, (key, line) in enumerate(lines.items()):\n            n = key + i\n            first_half = self._lines[:n]\n            last_half = self._lines[n:]\n            self._lines = first_half + [line] + last_half", "response": "Insert lines into the editor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_blank_lines(self):\n        to_remove = []\n        for i, line in enumerate(self):\n            ln = line.strip()\n            if ln == '':\n                to_remove.append(i)\n        self.delete_lines(to_remove)", "response": "Remove all blank lines."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _data(self, copy=False):\n        data = {}\n        for key, obj in self.__dict__.items():\n            if isinstance(obj, (pd.Series, pd.DataFrame, pd.SparseSeries, pd.SparseDataFrame)):\n                if copy:\n                    data[key] = obj.copy()\n                else:\n                    data[key] = obj\n        return data", "response": "Get all data associated with the container as key value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete all lines with given line numbers.", "response": "def delete_lines(self, lines):\n        \"\"\"\n        Delete all lines with given line numbers.\n\n        Args:\n            lines (list): List of integers corresponding to line numbers to delete\n        \"\"\"\n        for k, i in enumerate(lines):\n            del self[i-k]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch the entire editor for lines that match the string.", "response": "def find(self, *strings, **kwargs):\n        \"\"\"\n        Search the entire editor for lines that match the string.\n\n        .. code-block:: Python\n\n            string = '''word one\n            word two\n            three'''\n            ed = Editor(string)\n            ed.find('word')          # [(0, \"word one\"), (1, \"word two\")]\n            ed.find('word', 'three') # {'word': [...], 'three': [(2, \"three\")]}\n\n        Args:\n            strings (str): Any number of strings to search for\n            keys_only (bool): Only return keys\n            start (int): Optional line to start searching on\n            stop (int): Optional line to stop searching on\n\n        Returns:\n            results: If multiple strings searched a dictionary of string key, (line number, line) values (else just values)\n        \"\"\"\n        start = kwargs.pop(\"start\", 0)\n        stop = kwargs.pop(\"stop\", None)\n        keys_only = kwargs.pop(\"keys_only\", False)\n        results = {string: [] for string in strings}\n        stop = len(self) if stop is None else stop\n        for i, line in enumerate(self[start:stop]):\n            for string in strings:\n                if string in line:\n                    if keys_only:\n                        results[string].append(i)\n                    else:\n                        results[string].append((i, line))\n        if len(strings) == 1:\n            return results[strings[0]]\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the next instance of the next entry in the list of strings.", "response": "def find_next(self, *strings, **kwargs):\n        \"\"\"\n        From the editor's current cursor position find the next instance of the\n        given string.\n\n        Args:\n            strings (iterable): String or strings to search for\n\n        Returns:\n            tup (tuple): Tuple of cursor position and line or None if not found\n\n        Note:\n            This function cycles the entire editor (i.e. cursor to length of\n            editor to zero and back to cursor position).\n        \"\"\"\n        start = kwargs.pop(\"start\", None)\n        keys_only = kwargs.pop(\"keys_only\", False)\n        staht = start if start is not None else self.cursor\n        for start, stop in [(staht, len(self)), (0, staht)]:\n            for i in range(start, stop):\n                for string in strings:\n                    if string in self[i]:\n                        tup = (i, self[i])\n                        self.cursor = i + 1\n                        if keys_only: return i\n                        return tup"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef regex(self, *patterns, **kwargs):\n        start = kwargs.pop(\"start\", 0)\n        stop = kwargs.pop(\"stop\", None)\n        keys_only = kwargs.pop(\"keys_only\", False)\n        flags = kwargs.pop(\"flags\", 0)\n        results = {pattern: [] for pattern in patterns}\n        stop = stop if stop is not None else -1\n        for i, line in enumerate(self[start:stop]):\n            for pattern in patterns:\n                grps = re.search(pattern, line, flags=flags)\n                if grps and keys_only:\n                    results[pattern].append(i)\n                elif grps and grps.groups():\n                    for group in grps.groups():\n                        results[pattern].append((i, group))\n                elif grps:\n                    results[pattern].append((i, line))\n        if len(patterns) == 1:\n            return results[patterns[0]]\n        return results", "response": "Search the editor for lines matching the regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace(self, pattern, replacement):\n        for i, line in enumerate(self):\n            if pattern in line:\n                self[i] = line.replace(pattern, replacement)", "response": "Replaces all instances of a pattern with a replacement."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pandas_dataframe(self, start, stop, ncol, **kwargs):\n        try:\n            int(start)\n            int(stop)\n        except TypeError:\n            print('start and stop must be ints')\n        try:\n            ncol = int(ncol)\n            return pd.read_csv(six.StringIO('\\n'.join(self[start:stop])), delim_whitespace=True, names=range(ncol), **kwargs)\n        except TypeError:\n            try:\n                ncol = list(ncol)\n                return pd.read_csv(six.StringIO('\\n'.join(self[start:stop])), delim_whitespace=True, names=ncol, **kwargs)\n            except TypeError:\n                print('Cannot pandas_dataframe if ncol is {}, must be int or list'.format(type(ncol)))", "response": "Returns the result of tab - separated pandas. read_csv on\n            a subset of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisplays a list of templatable variables present in the file.", "response": "def variables(self):\n        \"\"\"\n        Display a list of templatable variables present in the file.\n\n        Templating is accomplished by creating a bracketed object in the same\n        way that Python performs `string formatting`_. The editor is able to\n        replace the placeholder value of the template. Integer templates are\n        positional arguments.\n\n        .. _string formatting: https://docs.python.org/3.6/library/string.html\n        \"\"\"\n        string = str(self)\n        constants = [match[1:-1] for match in re.findall('{{[A-z0-9]}}', string)]\n        variables = re.findall('{[A-z0-9]*}', string)\n        return sorted(set(variables).difference(constants))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_file(cls, path, **kwargs):\n        lines = lines_from_file(path)\n        if 'meta' not in kwargs:\n            kwargs['meta'] = {'from': 'file'}\n        kwargs['meta']['filepath'] = path\n        return cls(lines, **kwargs)", "response": "Create an editor instance from a file on disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an editor instance from a file stream.", "response": "def from_stream(cls, f, **kwargs):\n        \"\"\"Create an editor instance from a file stream.\"\"\"\n        lines = lines_from_stream(f)\n        if 'meta' not in kwargs:\n            kwargs['meta'] = {'from': 'stream'}\n        kwargs['meta']['filepath'] = f.name if hasattr(f, 'name') else None\n        return cls(lines, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_generic_list(type_: Type) -> bool:\n    if hasattr(typing, '_GenericAlias'):\n        # 3.7\n        return (isinstance(type_, typing._GenericAlias) and     # type: ignore\n                type_.__origin__ is list)\n    else:\n        # 3.6 and earlier\n        return (isinstance(type_, typing.GenericMeta) and\n                type_.__origin__ is List)", "response": "Determines whether a type is a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_generic_dict(type_: Type) -> bool:\n    if hasattr(typing, '_GenericAlias'):\n        # 3.7\n        return (isinstance(type_, typing._GenericAlias) and     # type: ignore\n                type_.__origin__ is dict)\n    else:\n        # 3.6 and earlier\n        return (isinstance(type_, typing.GenericMeta) and\n                type_.__origin__ is Dict)", "response": "Determines whether a type is a Dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_generic_union(type_: Type) -> bool:\n    if hasattr(typing, '_GenericAlias'):\n        # 3.7\n        return (isinstance(type_, typing._GenericAlias) and     # type: ignore\n                type_.__origin__ is Union)\n    else:\n        if hasattr(typing, '_Union'):\n            # 3.6\n            return isinstance(type_, typing._Union)             # type: ignore\n        else:\n            # 3.5 and earlier (?)\n            return isinstance(type_, typing.UnionMeta)          # type: ignore\n    raise RuntimeError('Could not determine whether type is a Union. Is this'\n                       ' a YAtiML-supported Python version?')", "response": "Determines whether a type is a Union."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generic_type_args(type_: Type) -> List[Type]:\n    if hasattr(type_, '__union_params__'):\n        # 3.5 Union\n        return list(type_.__union_params__)\n    return list(type_.__args__)", "response": "Gets the type argument list for the given generic type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a type to a human - readable description.", "response": "def type_to_desc(type_: Type) -> str:\n    \"\"\"Convert a type to a human-readable description.\n\n    This is used for generating nice error messages. We want users \\\n    to see a nice readable text, rather than something like \\\n    \"typing.List<~T>[str]\".\n\n    Args:\n        type_: The type to represent.\n\n    Returns:\n        A human-readable description.\n    \"\"\"\n    scalar_type_to_str = {\n        str: 'string',\n        int: 'int',\n        float: 'float',\n        bool: 'boolean',\n        None: 'null value',\n        type(None): 'null value'\n    }\n\n    if type_ in scalar_type_to_str:\n        return scalar_type_to_str[type_]\n\n    if is_generic_union(type_):\n        return 'union of {}'.format([type_to_desc(t)\n                                     for t in generic_type_args(type_)])\n\n    if is_generic_list(type_):\n        return 'list of ({})'.format(type_to_desc(generic_type_args(type_)[0]))\n\n    if is_generic_dict(type_):\n        return 'dict of string to ({})'.format(\n                type_to_desc(generic_type_args(type_)[1]))\n\n    return type_.__name__"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the location of the static data directory.", "response": "def staticdir():\n    \"\"\"Return the location of the static data directory.\"\"\"\n    root = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(root, \"static\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resource(name):\n    for path, _, files in os.walk(staticdir()):\n        if name in files:\n            return os.path.abspath(os.path.join(path, name))", "response": "Return the full path of a named resource in the static directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a URI into the internal state.", "response": "def load_uri(self, uri, verbose):\n        \"\"\"\n        \n        :param uri:\n        :param rdf_format_opts:\n        :param verbose:\n        :return:\n        \"\"\"\n\n        if verbose: printDebug(\"----------\")\n        if verbose: printDebug(\"Reading: <%s>\" % uri)\n        success = False\n        for f in self.rdf_format_opts:\n            if verbose: printDebug(\".. trying rdf serialization: <%s>\" % f)\n            try:\n                self.rdfgraph.parse(uri, format=f)\n                if verbose: printDebug(\"..... success!\", bold=True)\n                success = True\n                self.sources_valid += [uri]\n                break\n            except:\n                if verbose: printDebug(\"..... failed\")\n\n        if not success == True:\n            self.loading_failed(self.rdf_format_opts)\n            self.sources_invalid += [uri]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a set of RDF data from a text string.", "response": "def load_text(self, text, verbose):\n        \"\"\"\n        \n        :param text:\n        :param rdf_format_opts:\n        :param verbose:\n        :return:\n        \"\"\"\n        if verbose: printDebug(\"----------\")\n        if verbose: printDebug(\"Reading: '%s ...'\" % text[:10])\n        success = False\n        for f in self.rdf_format_opts:\n            if verbose: printDebug(\".. trying rdf serialization: <%s>\" % f)\n            try:\n                self.rdfgraph.parse(data=text, format=f)\n                if verbose: printDebug(\"..... success!\")\n                success = True\n                self.sources_valid += [\"Text: '%s ...'\" % text[:10]]\n                break\n            except:\n                if verbose: printDebug(\"..... failed\", \"error\")\n\n        if not success == True:\n            self.loading_failed(self.rdf_format_opts)\n            self.sources_invalid += [\"Text: '%s ...'\" % text[:10]]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_file(self, file_obj, verbose):\n        if verbose: printDebug(\"----------\")\n        if verbose: printDebug(\"Reading: <%s> ...'\" % file_obj.name)\n\n        if type(file_obj) == file:\n            self.rdfgraph = self.rdfgraph + file_obj\n            self.sources_valid += [file_obj.NAME]\n        else:\n            self.loading_failed(self.rdf_format_opts)\n            self.sources_invalid += [file_obj.NAME]", "response": "Load a file into the graph."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, timeout = 0):\r\n        ptimeout = float(\r\n            timeout.microseconds/1000000+timeout.seconds if timeout\r\n            else (self.resolution if timeout is None else 0)\r\n        )\r\n        if self.tokens:\r\n            events = self.epoll_obj.poll(ptimeout, 1024)\r\n            len_events = len(events)-1\r\n            for nr, (fd, ev) in enumerate(events):\r\n                act = self.shadow.pop(fd)\r\n                if ev & EPOLLHUP:\r\n                    self.epoll_obj.unregister(fd)\r\n                    self.handle_error_event(act, 'Hang up.', ConnectionClosed)\r\n                elif ev & EPOLLERR:\r\n                    self.epoll_obj.unregister(fd)\r\n                    self.handle_error_event(act, 'Unknown error.')\r\n                else:\r\n                    if nr == len_events:\r\n                        ret = self.yield_event(act)\r\n                        if not ret:\r\n                            self.epoll_obj.modify(fd, ev | EPOLLONESHOT)\r\n                            self.shadow[fd] = act\r\n                        return ret\r\n                    else:\r\n                        if not self.handle_event(act):\r\n                            self.epoll_obj.modify(fd, ev | EPOLLONESHOT)\r\n                            self.shadow[fd] = act\r\n\r\n\r\n        else:\r\n            sleep(timeout)", "response": "Run a proactor loop and return new socket events."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if terms do not contain unknown characters", "response": "def _check(self, terms):\n        \"\"\"Check terms do not contain unknown characters\"\"\"\n        for t in terms:\n            try:\n                _ = urllib.parse.quote(six.text_type(t).encode('utf8'))\n            except:\n                self.logger.error('Unknown character in [{0}]!'.format(t))\n                self.logger.error('.... remove character and try again.')\n                raise EncodingError"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches and sieve query names.", "response": "def main(self):\n        \"\"\"Search and sieve query names.\"\"\"\n        # TODO: Break up, too complex\n        primary_bool = True\n        no_records = True\n        nsearch = 1\n        search_terms = self.terms\n        original_names = []\n        while True:\n            if primary_bool:\n                self.logger.info('Searching [{0}] ...'.format(\n                    self.primary_datasource))\n            else:\n                self.logger.info('Searching other datasources ...')\n            res = self._res.search(search_terms, prelim=primary_bool)\n            if nsearch > 2 and res:\n                # if second search failed, look up alternative names\n                for each_res, original_name in zip(res, original_names):\n                    each_res['supplied_name_string'] = original_name\n            self._store.add(res)\n            # Check for returns without records\n            no_records = self._count(nrecords=1)\n            if no_records:\n                if nsearch == 1:\n                    primary_bool = False\n                elif nsearch == 2:\n                    original_names = no_records\n                    # genus names\n                    no_records = [e.split()[0] for e in no_records]\n                    primary_bool = True\n                elif nsearch == 3:\n                    original_names = no_records\n                    no_records = [e.split()[0] for e in no_records]\n                    primary_bool = False\n                else:\n                    break\n            else:\n                break\n            nsearch += 1\n            search_terms = no_records\n        # Check for multiple records\n        multi_records = self._count(greater=True, nrecords=1)\n        if multi_records:\n            self.logger.info('Choosing best records to return ...')\n            res = self._sieve(multi_records)\n            self._store.replace(res)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sieve(self, multiple_records):\n        # TODO: Break up, too complex\n        GnrStore = self._store\n\n        def writeAsJson(term, results):\n            record = {'supplied_name_string': term}\n            if len(results) > 0:\n                record['results'] = results\n            return record\n\n        def boolResults(results, bool_li, rand=False):\n            if rand:\n                # choose first record (most likely best?)\n                results = [results[0]]\n            elif sum(bool_li) == 1:\n                results = [results[bool_li.index(1)]]\n            elif sum(bool_li) == 0:\n                # return 'no_record'\n                return []\n            else:\n                results = [result for i, result in enumerate(results) if\n                           bool_li[i]]\n            return results\n\n        sieved = []\n        ranks = ['species', 'genus', 'family', 'order', 'superorder', 'class',\n                 'superclass', 'subphylum', 'phylum', 'kingdom',\n                 'superkingdom']\n        for term in multiple_records:\n            results = GnrStore[term]\n            while len(results) > 1:\n                # choose result with best score\n                scores = [result['score'] for result in results]\n                bool_score = [1 if score == max(scores) else 0 for score in\n                              scores]\n                results = boolResults(results, bool_score)\n                # choose result resolved to lowest taxonomic rank\n                if self.lowrank:\n                    res_ranks = [result['classification_path_ranks'].\n                                 split('|') for result in results]\n                    # calculate 'rank scores' for named and un-named ranks\n                    nmd_rnks = []\n                    unnmd_rnks = []\n                    for rs in res_ranks:\n                        nmd_rnks.append(min([j for j,e in enumerate(ranks) if\n                                             e in rs]))\n                        unnmd_rnk = [j for j,e in enumerate(rs) if\n                                     e == ranks[nmd_rnks[-1]]][0]\n                        unnmd_rnk -= len(rs)\n                        unnmd_rnks.append(unnmd_rnk)\n                    # calculate bool\n                    unnmd_rnks = [e if nmd_rnks[j] == min(nmd_rnks) else 0 for\n                                  j,e in enumerate(unnmd_rnks)]\n                    bool_rank = [1 if e == min(unnmd_rnks) else 0 for e in\n                                 unnmd_rnks]\n                    results = boolResults(results, bool_rank)\n                results = boolResults(results, [], rand=True)\n            record = writeAsJson(term, results)\n            sieved.append(record)\n        return sieved", "response": "Return json object without multiple returns per resolved name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the CSV file of resolved names and txt files of unresolved names.", "response": "def write(self):\n        \"\"\"Write csv file of resolved names and txt file of unresolved names.\n        \"\"\"\n        csv_file = os.path.join(self.outdir, 'search_results.csv')\n        txt_file = os.path.join(self.outdir, 'unresolved.txt')\n        headers = self.key_terms\n        unresolved = []\n        with open(csv_file, 'w') as file:\n            writer = csv.writer(file)\n            writer.writerow(headers)\n            for key in list(self._store.keys()):\n                results = self._store[key]\n                if len(results) == 0:\n                    unresolved.append(key)\n                else:\n                    row = [key]\n                    for key_term in headers[1:]:\n                        element = results[0][key_term]\n                        # GNR returns UTF-8, csv requires ascii\n                        #\n                        # *** Note ***\n                        # According to all docs for csv versions >= 2.6, csv\n                        # can handle either UTF-8 or ascii, just not Unicode.\n                        # In py3, the following two lines result in csv printing\n                        # the element with a bitstring. If GNR is actually\n                        # returning UTF-8, it seems easiest to just drop these\n\n                        # if 'encode' in dir(element):\n                        #     element = element.encode('ascii')\n                        row.append(element)\n                    writer.writerow(row)\n        if len(unresolved) > 0:\n            with open(txt_file, 'w') as file:\n                for name in unresolved:\n                    file.write(\"{0}\\n\".format(name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves data for a given key term as a list.", "response": "def retrieve(self, key_term):\n        \"\"\"Return data for key term specified for each resolved name as a list.\nPossible terms (02/12/2013): 'query_name', 'classification_path',\n'data_source_title', 'match_type', 'score', 'classification_path_ranks',\n'name_string', 'canonical_form',\\\n'classification_path_ids', 'prescore', 'data_source_id', 'taxon_id',\n'gni_uuid'\"\"\"\n        if key_term not in self.key_terms:\n            raise IndexError('Term given is invalid! Check doc string for \\\nvalid terms.')\n        store = self._store\n        retrieved = []\n        for key in list(store.keys()):\n            # take copy, so changes made to the returned list do not affect\n            #  store\n            record = copy.deepcopy(store[key])\n            if len(record) > 0:\n                if key_term == 'query_name':\n                    retrieved.append(key)\n                else:\n                    retrieved.append(record[0][key_term])\n        if re.search('path', key_term):\n            retrieved = [[r2 for r2 in r1.split('|')[1:]] for r1 in retrieved]\n        return retrieved"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_document_type(loader_cls: Type, type_: Type) -> None:\n    loader_cls.document_type = type_\n\n    if not hasattr(loader_cls, '_registered_classes'):\n        loader_cls._registered_classes = dict()", "response": "Sets the type corresponding to the whole document."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_to_loader(loader_cls: Type, classes: List[Type]) -> None:\n    if not isinstance(classes, list):\n        classes = [classes]  # type: ignore\n\n    for class_ in classes:\n        tag = '!{}'.format(class_.__name__)\n        if issubclass(class_, enum.Enum):\n            loader_cls.add_constructor(tag, EnumConstructor(class_))\n        elif issubclass(class_, str) or issubclass(class_, UserString):\n            loader_cls.add_constructor(tag, UserStringConstructor(class_))\n        else:\n            loader_cls.add_constructor(tag, Constructor(class_))\n\n        if not hasattr(loader_cls, '_registered_classes'):\n            loader_cls._registered_classes = dict()\n        loader_cls._registered_classes[tag] = class_", "response": "Registers one or more classes with a YAtiML loader."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhooks used when loading a single document.", "response": "def get_single_node(self) -> yaml.Node:\n        \"\"\"Hook used when loading a single document.\n\n        This is the hook we use to hook yatiml into ruamel.yaml. It is \\\n        called by the yaml libray when the user uses load() to load a \\\n        YAML document.\n\n        Returns:\n            A processed node representing the document.\n        \"\"\"\n        node = super().get_single_node()\n        if node is not None:\n            node = self.__process_node(node, type(self).document_type)\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __type_to_tag(self, type_: Type) -> str:\n        if type_ in scalar_type_to_tag:\n            return scalar_type_to_tag[type_]\n\n        if is_generic_list(type_):\n            return 'tag:yaml.org,2002:seq'\n\n        if is_generic_dict(type_):\n            return 'tag:yaml.org,2002:map'\n\n        if type_ in self._registered_classes.values():\n            return '!{}'.format(type_.__name__)\n\n        raise RuntimeError((\n            'Unknown type {} in type_to_tag,'  # pragma: no cover\n            ' please report a YAtiML bug.').format(type_))", "response": "Convert a type to the corresponding YAML tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves syntactic sugar from the node.", "response": "def __savorize(self, node: yaml.Node, expected_type: Type) -> yaml.Node:\n        \"\"\"Removes syntactic sugar from the node.\n\n        This calls yatiml_savorize(), first on the class's base \\\n        classes, then on the class itself.\n\n        Args:\n            node: The node to modify.\n            expected_type: The type to assume this type is.\n        \"\"\"\n        logger.debug('Savorizing node assuming type {}'.format(\n            expected_type.__name__))\n\n        for base_class in expected_type.__bases__:\n            if base_class in self._registered_classes.values():\n                node = self.__savorize(node, base_class)\n\n        if hasattr(expected_type, 'yatiml_savorize'):\n            logger.debug('Calling {}.yatiml_savorize()'.format(\n                expected_type.__name__))\n            cnode = Node(node)\n            expected_type.yatiml_savorize(cnode)\n            node = cnode.yaml_node\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing a node and returns the new node.", "response": "def __process_node(self, node: yaml.Node,\n                       expected_type: Type) -> yaml.Node:\n        \"\"\"Processes a node.\n\n        This is the main function that implements yatiml's \\\n        functionality. It figures out how to interpret this node \\\n        (recognition), then applies syntactic sugar, and finally \\\n        recurses to the subnodes, if any.\n\n        Args:\n            node: The node to process.\n            expected_type: The type we expect this node to be.\n\n        Returns:\n            The transformed node, or a transformed copy.\n        \"\"\"\n        logger.info('Processing node {} expecting type {}'.format(\n            node, expected_type))\n\n        # figure out how to interpret this node\n        recognized_types, message = self.__recognizer.recognize(\n            node, expected_type)\n\n        if len(recognized_types) != 1:\n            raise RecognitionError(message)\n\n        recognized_type = recognized_types[0]\n\n        # remove syntactic sugar\n        logger.debug('Savorizing node {}'.format(node))\n        if recognized_type in self._registered_classes.values():\n            node = self.__savorize(node, recognized_type)\n        logger.debug('Savorized, now {}'.format(node))\n\n        # process subnodes\n        logger.debug('Recursing into subnodes')\n        if is_generic_list(recognized_type):\n            if node.tag != 'tag:yaml.org,2002:seq':\n                raise RecognitionError('{}{}Expected a {} here'.format(\n                    node.start_mark, os.linesep,\n                    type_to_desc(expected_type)))\n            for item in node.value:\n                self.__process_node(item,\n                                    generic_type_args(recognized_type)[0])\n        elif is_generic_dict(recognized_type):\n            if node.tag != 'tag:yaml.org,2002:map':\n                raise RecognitionError('{}{}Expected a {} here'.format(\n                    node.start_mark, os.linesep,\n                    type_to_desc(expected_type)))\n            for _, value_node in node.value:\n                self.__process_node(value_node,\n                                    generic_type_args(recognized_type)[1])\n\n        elif recognized_type in self._registered_classes.values():\n            if (not issubclass(recognized_type, enum.Enum)\n                    and not issubclass(recognized_type, str)\n                    and not issubclass(recognized_type, UserString)):\n                for attr_name, type_, _ in class_subobjects(recognized_type):\n                    cnode = Node(node)\n                    if cnode.has_attribute(attr_name):\n                        subnode = cnode.get_attribute(attr_name)\n                        new_subnode = self.__process_node(\n                            subnode.yaml_node, type_)\n                        cnode.set_attribute(attr_name, new_subnode)\n        else:\n            logger.debug('Not a generic class or a user-defined class, not'\n                         ' recursing')\n\n        node.tag = self.__type_to_tag(recognized_type)\n        logger.debug('Finished processing node {}'.format(node))\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the object :return: the created object :rtype: object", "response": "def create(self):\n        \"\"\"\n        Creates the object\n\n        :return: the created object\n        :rtype: object\n        \"\"\"\n\n        # In the header.location there is the newly created object so get the id out of the url\n        created_id = self._post_request(\n            data=self.element_to_string(self.encode())\n        ).headers.get('Location').split('/')[-1]\n        return self.get(created_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_cell_value(cell, value):\n    if OPENPYXL_MAJOR_VERSION > 1:\n        cell.value = value\n    else:\n        cell.internal_value = value", "response": "Sets the value of an openpyxl cell"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_change_type(self, ref, a1, a2):\n        if ref == '.':\n            return self.INSERTION\n        elif a1 == '.' or a2 == '.':\n            return self.DELETION", "response": "Returns the type of change given ref allele1 and allele2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn default mdata map for OsidForm", "response": "def get_osid_form_mdata():\n    \"\"\"Return default mdata map for OsidForm\"\"\"\n    return {\n        'journal_comment': {\n            'element_label': {\n                'text': 'Journal Comment',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'Optional form submission journal comment, 255 character maximum',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': []\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning default mdata map for OsidObject", "response": "def get_osid_object_mdata():\n    \"\"\"Return default mdata map for OsidObject\"\"\"\n    return {\n        'display_name': {\n            'element_label': {\n                'text': 'Display Name',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'Required, 255 character maximum',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': []\n        },\n        'description': {\n            'element_label': {\n                'text': 'Description',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'Optional',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 1024,\n            'string_set': []\n        },\n        'genus_type': {\n            'element_label': {\n                'text': 'Genus Type',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'Required genus Type of type osid.type.Type',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': True,\n            'value': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_type_values': [str(DEFAULT_GENUS_TYPE)],\n            'syntax': 'TYPE',\n            'type_set': []\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns default mdata map for OsidTemporal", "response": "def get_osid_temporal_mdata():\n    \"\"\"Return default mdata map for OsidTemporal\"\"\"\n    return {\n        'start_date': {\n            'element_label': {\n                'text': 'Start Date',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [datetime.datetime.min],\n            'syntax': 'DATETIME',\n            'date_time_set': [],\n        },\n        'end_date': {\n            'element_label': {\n                'text': 'Start Date',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [datetime.datetime.max],\n            'syntax': 'DATETIME',\n            'date_time_set': [],\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_osid_containable_mdata():\n    return {\n        'sequestered': {\n            'element_label': {\n                'text': 'sequestered',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'default_boolean_values': [False],\n            'array': False,\n            'syntax': 'BOOLEAN',\n        }\n    }", "response": "Return default mdata map for OsidContainable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn default mdata map for OsidSourceable", "response": "def get_osid_sourceable_mdata():\n    \"\"\"Return default mdata map for OsidSourceable\"\"\"\n    return {\n        'provider': {\n            'element_label': {\n                'text': 'provider',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'branding': {\n            'element_label': {\n                'text': 'branding',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'license': {\n            'element_label': {\n                'text': 'License',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'Optional',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': None,\n            'string_set': []\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_resources(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.ResourceList(self._results, runtime=self._runtime)", "response": "Gets the resource list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the bin list resulting from the search.", "response": "def get_bins(self):\n        \"\"\"Gets the bin list resulting from the search.\n\n        return: (osid.resource.BinList) - the bin list\n        raise:  IllegalState - list already retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.BinList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the character behind pos.", "response": "def _backward_delete_char(text, pos):\n    \"\"\"Delete the character behind pos.\"\"\"\n    if pos == 0:\n        return text, pos\n    return text[:pos - 1] + text[pos:], pos - 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _backward_kill_word(text, pos):\n    text, new_pos = _backward_word(text, pos)\n    return text[:new_pos] + text[pos:], new_pos", "response": "Kill the word behind pos."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _backward_word(text, pos):\n    while pos > 0 and not text[pos - 1].isalnum():\n        pos -= 1\n    while pos > 0 and text[pos - 1].isalnum():\n        pos -= 1\n    return text, pos", "response": "Move pos backward to the start of the current or previous word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncapitalize the current word.", "response": "def _capitalize_word(text, pos):\n    \"\"\"Capitalize the current (or following) word.\"\"\"\n    while pos < len(text) and not text[pos].isalnum():\n        pos += 1\n    if pos < len(text):\n        text = text[:pos] + text[pos].upper() + text[pos + 1:]\n    while pos < len(text) and text[pos].isalnum():\n        pos += 1\n    return text, pos"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete all spaces and tabs around pos.", "response": "def _delete_horizontal_space(text, pos):\n    \"\"\"Delete all spaces and tabs around pos.\"\"\"\n    while pos > 0 and text[pos - 1].isspace():\n        pos -= 1\n    end_pos = pos\n    while end_pos < len(text) and text[end_pos].isspace():\n        end_pos += 1\n    return text[:pos] + text[end_pos:], pos"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _downcase_word(text, pos):\n    text, new_pos = _forward_word(text, pos)\n    return text[:pos] + text[pos:new_pos].lower() + text[new_pos:], new_pos", "response": "Lowercase the current word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmoving pos forward to the end of the next word.", "response": "def _forward_word(text, pos):\n    \"\"\"\n    Move pos forward to the end of the next word. Words are composed of\n    alphanumeric characters (letters and digits).\n    \"\"\"\n    while pos < len(text) and not text[pos].isalnum():\n        pos += 1\n    while pos < len(text) and text[pos].isalnum():\n        pos += 1\n    return text, pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _kill_word(text, pos):\n    text, end_pos = _forward_word(text, pos)\n    return text[:pos] + text[end_pos:], pos", "response": "Kills a word from pos to the end of the next word."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransposes the characters before pos forward over the character at pos.", "response": "def _transpose_chars(text, pos):\n    \"\"\"\n    Drag the character before pos forward over the character at pos,\n    moving pos forward as well. If pos is at the end of text, then this\n    transposes the two characters before pos.\n    \"\"\"\n    if len(text) < 2 or pos == 0:\n        return text, pos\n    if pos == len(text):\n        return text[:pos - 2] + text[pos - 1] + text[pos - 2], pos\n    return text[:pos - 1] + text[pos] + text[pos - 1] + text[pos + 1:], pos + 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransposes the words before pos past the word after pos.", "response": "def _transpose_words(text, pos):\n    \"\"\"\n    Drag the word before pos past the word after pos, moving pos over\n    that word as well. If pos is at the end of text, this transposes the\n    last two words in text.\n    \"\"\"\n    text, end2 = _forward_word(text, pos)\n    text, start2 = _backward_word(text, end2)\n    text, start1 = _backward_word(text, start2)\n    text, end1 = _forward_word(text, start1)\n    if start1 == start2:\n        return text, pos\n    return text[:start1] + text[start2:end2] + text[end1:start2:] + \\\n        text[start1:end1] + text[end2:], end2"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nkills the word behind pos using white space as a word boundary.", "response": "def _unix_word_rubout(text, pos):\n    \"\"\"\n    Kill the word behind pos, using white space as a word boundary.\n    \"\"\"\n    words = text[:pos].rsplit(None, 1)\n    if len(words) < 2:\n        return text[pos:], 0\n    else:\n        index = text.rfind(words[1], 0, pos)\n        return text[:index] + text[pos:], index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _upcase_word(text, pos):\n    text, new_pos = _forward_word(text, pos)\n    return text[:pos] + text[pos:new_pos].upper() + text[new_pos:], new_pos", "response": "Uppercase the current word."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edit(text, pos, key):\n    if key in _key_bindings:\n        return _key_bindings[key](text, pos)\n    elif len(key) == 1:\n        return text[:pos] + key + text[pos:], pos + 1\n    else:\n        return text, pos", "response": "Edit a key in the context of a line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider LogEntrySearchSession. get_log_entries_by_search", "response": "def get_log_entries_by_search(self, log_entry_query, log_entry_search):\n        \"\"\"Pass through to provider LogEntrySearchSession.get_log_entries_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_log_entries_by_search(log_entry_query, log_entry_search)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Family associated with this session.", "response": "def get_family(self):\n        \"\"\"Gets the ``Family`` associated with this session.\n\n        return: (osid.relationship.Family) - the family\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return FamilyLookupSession(proxy=self._proxy,\n                                   runtime=self._runtime).get_family(self._family_id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_relationship(self, relationship_id=None):\n        if relationship_id is None:\n            raise NullArgument()\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr +\n                    '/relationships/' + str(relationship_id))\n        return objects.Relationship(self._get_request(url_path))", "response": "Gets the Relationship specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of Relationships corresponding to the given IdList.", "response": "def get_relationships_by_ids(self, relationship_ids=None):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given ``IdList``.\n\n        arg:    relationship_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n        return: (osid.relationship.RelationshipList) - the returned\n                ``Relationship list``\n        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``relationship_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if relationship_ids is None:\n            raise NullArgument()\n        relationships = []\n        for i in relationship_ids:\n            relationship = None\n            url_path = ('/handcar/services/relationship/families/' +\n                        self._catalog_idstr +\n                        '/relatioships/' + str(i))\n            try:\n                relationship = self._get_request(url_path)\n            except (NotFound, OperationFailed):\n                if self._relationship_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if relationship:\n                if not (self._relationship_view == COMPARATIVE and\n                        relationship in relationships):\n                    relationships.append(relationship)\n        return objects.RelationshipList(relationships)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_relationships_by_genus_type(self, relationship_genus_type=None):\n        if relationship_genus_type is None:\n            raise NullArgument()\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships?genustypeid=' +\n                    relationship_genus_type.get_identifier())\n        return objects.RelationshipList(self._get_request(url_path))", "response": "Gets a RelationshipList corresponding to the given relationship genus Type"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of relationships for a given source.", "response": "def get_relationships_for_source(self, source_id=None):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given peer ``Id``.\n\n        arg:    source_id (osid.id.Id): a peer ``Id``\n        return: (osid.relationship.RelationshipList) - the relationships\n        raise:  NullArgument - ``source_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if source_id is None:\n            raise NullArgument()\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships?sourceid=' +\n                    str(source_id))\n        return objects.RelationshipList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a list of Relationships corresponding to a given source_id and relationship genus Type.", "response": "def get_relationships_by_genus_type_for_source(self, source_id=None, relationship_genus_type=None):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given peer ``Id`` and relationship genus ``Type.\n\n        Relationships`` of any genus derived from the given genus are\n        returned.\n\n        In plenary mode, the returned list contains all of the\n        relationships corresponding to the given peer, including\n        duplicates, or an error results if a relationship is\n        inaccessible. Otherwise, inaccessible ``Relationships`` may be\n        omitted from the list and may present the elements in any order\n        including returning a unique set.\n\n        In effective mode, relationships are returned that are currently\n        effective. In any effective mode, effective relationships and\n        those currently expired are returned.\n\n        arg:    source_id (osid.id.Id): a peer ``Id``\n        arg:    relationship_genus_type (osid.type.Type): a relationship\n                genus type\n        return: (osid.relationship.RelationshipList) - the relationships\n        raise:  NullArgument - ``source_id`` or\n                ``relationship_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        \"\"\"\n        if source_id is None or relationship_genus_type is None:\n            raise NullArgument()\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships?genustypeid=' +\n                    relationship_genus_type.get_identifier + '?sourceid=' +\n                    str(source_id))\n        return objects.RelationshipList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_relationships_for_destination(self, destination_id=None):\n        if destination_id is None:\n            raise NullArgument()\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships?sourceid=' +\n                    str(destination_id))\n        return objects.RelationshipList(self._get_request(url_path))", "response": "Gets a list of relationships for the given destination."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of Relationships corresponding to the given genus Type for the given peer Id and relationship genus Type.", "response": "def get_relationships_by_genus_type_for_destination(self, destination_id=None, relationship_genus_type=None):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given peer ``Id`` and relationship genus ``Type.\n\n        Relationships`` of any genus derived from the given genus are\n        returned.\n\n        In plenary mode, the returned list contains all of the\n        relationships corresponding to the given peer, including\n        duplicates, or an error results if a relationship is\n        inaccessible. Otherwise, inaccessible ``Relationships`` may be\n        omitted from the list and may present the elements in any order\n        including returning a unique set.\n\n        In effective mode, relationships are returned that are currently\n        effective. In any effective mode, effective relationships and\n        those currently expired are returned.\n\n        arg:    destination_id (osid.id.Id): a peer ``Id``\n        arg:    relationship_genus_type (osid.type.Type): a relationship\n                genus type\n        return: (osid.relationship.RelationshipList) - the relationships\n        raise:  NullArgument - ``destination_id`` or\n                ``relationship_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if destination_id is None or relationship_genus_type is None:\n            raise NullArgument()\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships?genustypeid=' +\n                    relationship_genus_type.get_identifier + '?sourceid=' +\n                    str(destination_id))\n        return objects.RelationshipList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_relationships(self):\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships')\n        return objects.RelationshipList(self._get_request(url_path))", "response": "Gets all Relationships in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_family(self):\n        # Implemented from template for osid.resource.ResourceLookupSession.get_bin\n        from ..osid.osid_errors import OperationFailed, PermissionDenied\n        from .objects import Family\n        try:\n            return Family(self.my_catalog_model)\n        except:\n            raise OperationFailed()", "response": "Gets the Family associated with this session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the relationship form for creating new relationships.", "response": "def get_relationship_form_for_create(self, source_id=None, destination_id=None, relationship_record_types=None):\n        \"\"\"Gets the relationship form for creating new relationships.\n\n        A new form should be requested for each create transaction.\n\n        arg:    source_id (osid.id.Id): ``Id`` of a peer\n        arg:    destination_id (osid.id.Id): ``Id`` of the related peer\n        arg:    relationship_record_types (osid.type.Type[]): array of\n                relationship record types\n        return: (osid.relationship.RelationshipForm) - the relationship\n                form\n        raise:  NotFound - ``source_id`` or ``destination_id`` is not\n                found\n        raise:  NullArgument - ``source_id`` or ``destination_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested recod\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if source_id is None or destination_id is None:\n            raise NullArgument()\n        if relationship_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        relationship_form = objects.RelationshipForm(osid_object_map=None,\n                                                     source_id=source_id,\n                                                     destination_id=destination_id)\n        self._forms[relationship_form.get_id().get_identifier()] = not CREATED\n        return relationship_form"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new Relationship.", "response": "def create_relationship(self, relationship_form=None):\n        \"\"\"Creates a new ``Relationship``.\n\n        arg:    relationship_form (osid.relationship.RelationshipForm):\n                the form for this ``Relationship``\n        return: (osid.relationship.Relationship) - the new\n                ``Relationship``\n        raise:  IllegalState - ``relationship_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``relationship_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``relationship_form`` did not originate\n                from ``get_relationship_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if relationship_form is None:\n            raise NullArgument()\n        if not isinstance(relationship_form, abc_relationship_objects.RelationshipForm):\n            raise InvalidArgument('argument type is not a RelationshipForm')\n        if relationship_form.is_for_update():\n            raise InvalidArgument('form is for update only, not create')\n        try:\n            if self._forms[relationship_form.get_id().get_identifier()] == CREATED:\n                raise IllegalState('form already used in a create transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not relationship_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships')\n        try:\n            result = self._post_request(url_path, relationship_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[relationship_form.get_id().get_identifier()] = CREATED\n        return objects.Relationship(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_relationship_form_for_update(self, relationship_id=None):\n        if relationship_id is None:\n            raise NullArgument()\n        try:\n            url_path = ('/handcar/services/relationship/families/' +\n                        self._catalog_idstr + '/relationships/' + str(relationship_id))\n            relationship = objects.Relationship(self._get_request(url_path))\n        except Exception:\n            raise\n        relationship_form = objects.RelationshipForm(relationship._my_map)\n        self._forms[relationship_form.get_id().get_identifier()] = not UPDATED\n        return relationship_form", "response": "Gets the relationship form for updating an existing relationship."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating an existing relationship.", "response": "def update_relationship(self, relationship_id=None, relationship_form=None):\n        \"\"\"Updates an existing relationship.\n\n        arg:    relationship_id (osid.id.Id): the ``Id`` of the\n                ``Relationship``\n        arg:    relationship_form (osid.relationship.RelationshipForm):\n                the form containing the elements to be updated\n        raise:  IllegalState - ``relationship_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``relationship_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``relationship_form`` did not originate\n                from ``get_relationship_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if relationship_id is None or relationship_form is None:\n            raise NullArgument()\n        if not isinstance(relationship_form, objects.RelationshipForm):\n            raise InvalidArgument('argument type is not an RelationshipForm')\n        if not relationship_form.is_for_update():\n            raise InvalidArgument('form is for create only, not update')\n        try:\n            if self._forms[relationship_form.get_id().get_identifier()] == UPDATED:\n                raise IllegalState('form already used in an update transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not relationship_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships')\n        try:\n            result = self._put_request(url_path, relationship_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[relationship_form.get_id().get_identifier()] = UPDATED\n        return objects.Relationship(result)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting a relationship from the hierarchy.", "response": "def delete_relationship(self, relationship_id=None):\n        \"\"\"Deletes a ``Relationship``.\n\n        arg:    relationship_id (osid.id.Id): the ``Id`` of the\n                ``Relationship`` to remove\n        raise:  NotFound - ``relationship_id`` not found\n        raise:  NullArgument - ``relationship_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if relationship_id is None:\n            raise NullArgument()\n        if not isinstance(relationship_id, Id):\n            raise InvalidArgument('argument type is not an osid Id')\n\n        url_path = ('/handcar/services/relationship/families/' +\n                    self._catalog_idstr + '/relationships/' +\n                    str(relationship_id))\n        result = self._delete_request(url_path)\n        return objects.Relationship(result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_family(self, family_id=None):\n        if family_id is None:\n            raise NullArgument()\n        url_path = '/handcar/services/relationship/families/' + str(family_id)\n        return objects.Family(self._get_request(url_path))", "response": "Gets the Family specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_families_by_ids(self, family_ids=None):\n        if family_ids is None:\n            raise NullArgument()\n        families = []\n        for i in family_ids:\n            family = None\n            url_path = '/handcar/services/relationship/families/' + str(i)\n            try:\n                family = self._get_request(url_path)\n            except (NotFound, OperationFailed):\n                if self._family_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if family:\n                if not (self._family_view == COMPARATIVE and\n                        family in families):\n                    families.append(family)\n        return objects.FamilykList(families)", "response": "Gets a FamilyList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_families_by_genus_type(self, family_genus_type=None):\n        if family_genus_type is None:\n            raise NullArgument()\n        url_path = '/handcar/services/relationship/families'\n        families_of_type = []\n        all_families = self._get_request(url_path)\n        for family in all_families:\n            # DO WE NEED TO CHECK ALL THREE ATRIBUTES OF THE Id HERE?\n            if family['genusTypeId'] == str(family_genus_type):\n                families_of_type.append(family)\n        return objects.FamilyList(families_of_type)", "response": "Gets a list of FamilyList corresponding to the given family genus Type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef a_temp_file():\n    filename = None\n    try:\n        tmpfile = tempfile.NamedTemporaryFile(delete=False)\n        filename = tmpfile.name\n        yield tmpfile\n    finally:\n        if filename and os.path.exists(filename):\n            os.remove(filename)", "response": "Yield the name of a temporary file and ensure it s removed after use"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_to(output, txt):\n    if (isinstance(txt, six.binary_type) or six.PY3 and isinstance(output, StringIO)) or isinstance(output, TextIOWrapper):\n        output.write(txt)\n    else:\n        output.write(txt.encode(\"utf-8\", \"replace\"))", "response": "Write some text to some output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_agnocomplete(self, klass_or_instance, user):\n        # If string, use register to fetch the class\n        if isinstance(klass_or_instance, six.string_types):\n            registry = get_agnocomplete_registry()\n            if klass_or_instance not in registry:\n                raise UnregisteredAgnocompleteException(\n                    \"Unregistered Agnocomplete class: {} is unknown\".format(klass_or_instance)  # noqa\n                )\n            klass_or_instance = registry[klass_or_instance]\n        # If not an instance, instanciate this\n        if not isinstance(klass_or_instance, AgnocompleteBase):\n            klass_or_instance = klass_or_instance(user=user)\n        # Pass the field when we have an AgnocompleteBase instance\n        if isinstance(klass_or_instance, AgnocompleteBase):\n            klass_or_instance.set_agnocomplete_field(self)\n        # Store it in the instance\n        self.agnocomplete = klass_or_instance\n        self.agnocomplete.user = user", "response": "This method is used to set the agnocomplete object in the field. It is used to set the agnocomplete object in the field."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transmit_agnocomplete_context(self):\n        # Only if the field has this attribute set.\n        if hasattr(self, AGNOCOMPLETE_USER_ATTRIBUTE):\n            user = self.get_agnocomplete_context()\n            if user:\n                self.agnocomplete.user = user\n            return user", "response": "Assign the user context to the agnocomplete class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_list_value(self, value):\n        # Don't go any further: this value is empty.\n        if not value:\n            return self.empty_value\n        # Clean empty items if wanted\n        if self.clean_empty:\n            value = [v for v in value if v]\n        return value or self.empty_value", "response": "Clean the argument value to eliminate None or Falsy values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new item from kwargs.", "response": "def create_item(self, **kwargs):\n        \"\"\"\n        Return a model instance created from kwargs.\n        \"\"\"\n        item, created = self.queryset.model.objects.get_or_create(**kwargs)\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates values created by the user input. Return the model instances QS.", "response": "def create_new_values(self):\n        \"\"\"\n        Create values created by the user input. Return the model instances QS.\n        \"\"\"\n        model = self.queryset.model\n        pks = []\n        extra_create_kwargs = self.extra_create_kwargs()\n        for value in self._new_values:\n            create_kwargs = {self.create_field: value}\n            create_kwargs.update(extra_create_kwargs)\n            new_item = self.create_item(**create_kwargs)\n            pks.append(new_item.pk)\n        return model.objects.filter(pk__in=pks)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclean the field values.", "response": "def clean(self, value):\n        \"\"\"\n        Clean the field values.\n        \"\"\"\n        if not self.create:\n            # No new value can be created, use the regular clean field\n            return super(AgnocompleteModelMultipleField, self).clean(value)\n\n        # We have to do this here before the call to \"super\".\n        # It'll be called again, but we can't find a way to \"pre_clean\" the\n        # field value before pushing it into the parent class \"clean()\" method.\n        value = self.clear_list_value(value)\n        # Split the actual values with the potential new values\n        # Numeric values will always be considered as PKs\n        pks = [v for v in value if v.isdigit()]\n        self._new_values = [v for v in value if not v.isdigit()]\n\n        qs = super(AgnocompleteModelMultipleField, self).clean(pks)\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge_ranges(inranges,already_sorted=False):\n  if not already_sorted: inranges = sort_ranges(inranges)\n  prev = None\n  outputs = []\n  merged = False\n  for rng in inranges:\n    #nrng = rng.copy()\n    #nrng.set_payload([])\n    #nrng.get_payload().append(rng)\n    merged = False\n    if len(outputs) > 0:\n      if rng.overlaps(outputs[-1]) or rng.adjacent(outputs[-1]):\n        nrng = rng.merge(outputs[-1])\n        #nrng.set_payload(prev.get_payload())\n        #nrng.get_payload().append(rng)\n        outputs[-1] = nrng\n        merged = True\n    if not merged:\n      outputs.append(rng.copy())\n    #prev = nrng\n  #if not merged: outputs.append(prev)\n  return sort_ranges(outputs)", "response": "merge a list of genomic range or bed entries into a flattend list of ranges where the payloads are the previous ranges that overlapped"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pad_ranges(inranges,padding,chr_ranges=None):\n  if not inranges: return\n  outranges = []\n  if len(inranges) == 0: return outranges\n  chr = {}\n  if chr_ranges:\n    for b in chr_ranges:\n      chr[b.chr] = b\n  for rng in inranges:\n    newstart = rng.start - padding\n    newend = rng.end + padding\n    if rng.chr in chr:\n      if newstart < chr[rng.chr].start: newstart = chr[rng.chr].start\n      if newend > chr[rng.chr].end: endstart = chr[rng.chr].end\n    nrng = rng.copy()\n    nrng.start = newstart\n    nrng.end = newend\n    outranges.append(nrng)\n  return sort_ranges(outranges)", "response": "Add the specified amount onto the edges of the transcripts\n \u00d7 the number of genomic edges."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsubtract multiple ranges from a list of genomic ranges r1s and r2s.", "response": "def subtract_ranges(r1s,r2s,already_sorted=False):\n  \"\"\"Subtract multiple ranges from a list of ranges\n\n  :param r1s: range list 1\n  :param r2s: range list 2\n  :param already_sorted: default (False)\n  :type r1s: GenomicRange[]\n  :type r2s: GenomicRange[]\n\n  :return: new range r1s minus r2s\n  :rtype: GenomicRange[]\n  \"\"\"\n  from seqtools.stream import MultiLocusStream\n  if not already_sorted:\n    r1s = merge_ranges(r1s)\n    r2s = merge_ranges(r2s)\n  outputs = []\n  mls = MultiLocusStream([BedArrayStream(r1s),BedArrayStream(r2s)])\n  tot1 = 0\n  tot2 = 0\n  for loc in mls:\n    #[beds1,beds2] = loc.get_payload()\n    v = loc.payload\n    #print v\n    [beds1,beds2] =v\n    beds1 = beds1[:]\n    beds2 = beds2[:]\n    if len(beds1)==0:\n      continue\n    if len(beds2)==0:\n      outputs += beds1\n      continue\n    #this loop could be made much more efficient\n    mapping = {} #keyed by beds1 index stores list of overlaping beds2 indecies\n    for i in range(0,len(beds1)):\n      mapping[i] = []\n    beds2min = 0\n    beds2max = len(beds2)\n    for i in range(0,len(beds1)):\n      for j in range(beds2min,beds2max):\n        cmpval = beds1[i].cmp(beds2[j])\n        if cmpval == -1:\n          beds2min = j+1\n        elif cmpval == 0:\n          mapping[i].append(j)\n        else:\n          break\n    for i in range(0,len(beds1)):\n      if len(mapping[i])==0: outputs += beds1\n      else:\n        outputs += subtract_range_array(beds1[i],[beds2[j] for j in mapping[i]],is_sorted=True)\n    #while len(beds2) > 0:\n    #  b2 = beds2.pop(0)\n    #  vs = [x.subtract(b2) for x in beds1]\n    #  tot = []\n    #  for res in vs:\n    #    tot = tot + res\n    #  beds1 = tot\n    #print \"subtract \"+str(len(beds1))+\"\\t\"+str(len(beds2))\n    #print beds1[0].get_range_string()\n  #outputs = merge_ranges(outputs)\n  #print [x.get_range_string() for x in outputs]\n\n  return merge_ranges(outputs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef intersect_range_array(bed1,beds2,payload=None,is_sorted=False):\n  if not is_sorted: beds2 = sort_ranges(beds2)\n  output = []\n  for bed2 in beds2:\n    cval = bed2.cmp(bed1)\n    #print str(cval)+\" \"+bed1.get_range_string()+\" \"+bed2.get_range_string()\n    if cval == -1: continue\n    elif cval == 0:\n      output.append(bed1.intersect(bed2))\n      if payload==1:\n        output[-1].set_payload(bed1.payload)\n      if payload==2:\n        output[-1].set_payload(bed2.payload)\n    elif cval == 1: break\n  if payload: return sort_ranges(output)\n  return merge_ranges(output)", "response": "Does not do a merge if the payload has been set\n Return the result of intersecting the two genomic ranges"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef subtract_range_array(bed1,beds2,is_sorted=False):\n  if not is_sorted: beds2 = sort_ranges(beds2)\n  output = [bed1.copy()]  \n  mink = 0\n  for j in range(0,len(beds2)):\n    temp = []\n    if mink > 0: temp = output[0:mink]\n    for k in range(mink,len(output)):\n      cmpv = output[k].cmp(beds2[j])\n      if cmpv ==-1: mink=k\n      temp += output[k].subtract(beds2[j])\n    #for nval in [x.subtract(beds2[j]) for x in output]:\n    #  temp += nval\n    output = temp\n  return output", "response": "subtracts several ranges from a range returns array1 - all of array2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a string representing a genomic range to a genomic range", "response": "def string_to_genomic_range(rstring):\n  \"\"\" Convert a string to a genomic range\n\n  :param rstring: string representing a genomic range chr1:801-900\n  :type rstring:\n  :returns: object representing the string\n  :rtype: GenomicRange\n  \"\"\"\n  m = re.match('([^:]+):(\\d+)-(\\d+)',rstring)\n  if not m: \n    sys.stderr.write(\"ERROR: problem with range string \"+rstring+\"\\n\")\n  return GenomicRange(m.group(1),int(m.group(2)),int(m.group(3)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a list of bed ranges as an input output a list of ranges and the coverage at each range", "response": "def ranges_to_coverage(rngs,threads=1):\n  \"\"\"take a list of ranges as an input\n  output a list of ranges and the coverage at each range\n  :param rngs: bed ranges on a single chromosome. not certain about that single chromosome requirement\n  :type rngs: GenomicRange[] or Bed[]\n  :param threads: Not currently being used\n  :type threads: int\n\n  :return: out is the non-overlapping bed ranges with the edition of depth\n  :rtype: GenomicRange[]\n  \"\"\"\n  def do_chr(rngs):\n    \"\"\"do one chromosomes sorting\n    :param rngs:\n    :type rngs: GenomicRange[]\n    \"\"\"\n    #starts = sorted(range(0,len(rngs)), key=lambda x: rngs[x].start)\n    #print starts\n    #ends = sorted(range(0,len(rngs)), key=lambda x: rngs[x].end)\n    start_events = [x.start for x in rngs]\n    end_events = [x.end+1 for x in rngs]\n    indexed_events = {}\n    for e in start_events:\n      if e not in indexed_events: indexed_events[e] = {'starts':0,'ends':0}\n      indexed_events[e]['starts']+=1\n    for e in end_events:\n      if e not in indexed_events: indexed_events[e] = {'starts':0,'ends':0}\n      indexed_events[e]['ends']+=1\n    cdepth = 0\n    pstart = None\n    pend = None\n    outputs = []\n    ordered_events = sorted(indexed_events.keys())\n    for loc in ordered_events:\n      prev_depth = cdepth # where we were\n      # see where we are before the change\n      cdepth += indexed_events[loc]['starts']\n      cdepth -= indexed_events[loc]['ends']\n      if prev_depth > 0 and prev_depth != cdepth:\n        outputs.append([rngs[0].chr,pstart,loc-1,prev_depth]) # output what was before this if we are in something\n      if prev_depth != cdepth or cdepth == 0:\n        pstart = loc\n    #print outputs\n    return outputs\n  \n  class Queue:\n    \"\"\"Simple class to be able to use get function to retreive a value\"\"\"\n    def __init__(self,val):\n      self.val = [val]\n    def get(self):\n      return self.val.pop(0)\n\n  ### START MAIN ####\n  srngs = sort_genomic_ranges(rngs)\n  # get the leftmost unique range\n  chr = srngs[0].chr\n  buffer = []\n  results = []\n  prelim = []\n  for b in srngs:\n    if b.chr != chr:\n      rs = do_chr(buffer[:])\n      for r in rs:  \n        results.append(GenomicRange(r[0],r[1],r[2]))\n        results[-1].set_payload(r[3])\n      buffer = []\n    buffer.append(b)\n    chr = b.chr\n  if len(buffer) > 0:\n    rs = do_chr(buffer[:])\n    for r in rs: \n      results.append(GenomicRange(r[0],r[1],r[2]))\n      results[-1].set_payload(r[3])\n  return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the next value from the array and set internal iterator so next call will be next entry", "response": "def read_entry(self):\n    \"\"\"get the next value from the array, and set internal iterator so next call will be next entry\n\n    :return: The next GenomicRange entry\n    :rtype: GenomicRange\n    \"\"\"\n    if len(self.bedarray) <= self.curr_ind: return None\n    val = self.bedarray[self.curr_ind]\n    self.curr_ind += 1\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_entry(self):\n    line = self.fh.readline()\n    if not line: return None\n    m = re.match('([^\\t]+)\\t(\\d+)\\t(\\d+)\\t*(.*)',line.rstrip())\n    if not m:\n      sys.stderr.write(\"ERROR: unknown line in bed format file\\n\"+line+\"\\n\")\n      sys.exit()\n    g = GenomicRange(m.group(1),int(m.group(2))+1,int(m.group(3)))\n    if len(m.group(4)) > 0:\n      g.set_payload(m.group(4))\n    return g", "response": "read the next bed entry from the stream"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_http_request(self, http_request):\n        self._http_request = http_request\n        if 'HTTP_LTI_USER_ID' in http_request.META:\n            try:\n                authority = http_request.META['HTTP_LTI_TOOL_CONSUMER_INSTANCE_GUID']\n            except (AttributeError, KeyError):\n                authority = 'unknown_lti_consumer_instance'\n            self.set_effective_agent_id(Id(\n                authority=authority,\n                namespace='agent.Agent',\n                identifier=http_request.META['HTTP_LTI_USER_ID']))", "response": "Support the HTTPRequest ProxyConditionRecordType and checks for special agent ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'gnu.org',\n            'namespace': 'Basic Numeric Formats',\n            'identifier': name,\n            'domain': 'Numeric Format Types',\n            'display_name': GNU_BASIC_NUMERIC_FORMAT_TYPES[name] + ' Numeric Format Type',\n            'display_label': GNU_BASIC_NUMERIC_FORMAT_TYPES[name],\n            'description': ('The type for the ' +\n                            GNU_BASIC_NUMERIC_FORMAT_TYPES[name] +\n                            ' numeric format.')\n        }\n    except KeyError:\n        raise NotFound('NumericFormat Type: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog an item. This method is a shortcut to ``createLogEntry()``. arg: content (object): the entry to log arg: content_type (osid.type.Type): the type of this entry which must be one of the types returned by ``LoggingManager.getContentTypes()`` raise: InvalidArgument - ``content`` is not of ``content_type`` raise: NullArgument - ``content`` or ``content_type`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure raise: Unsupported - ``LoggingManager.supportsContentType(contentType)`` is ``false`` *compliance: mandatory -- This method must be implemented.*", "response": "def log(self, content, content_type):\n        \"\"\"Logs an item.\n\n        This method is a shortcut to ``createLogEntry()``.\n\n        arg:    content (object): the entry to log\n        arg:    content_type (osid.type.Type): the type of this entry\n                which must be one of the types returned by\n                ``LoggingManager.getContentTypes()``\n        raise:  InvalidArgument - ``content`` is not of ``content_type``\n        raise:  NullArgument - ``content`` or ``content_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported -\n                ``LoggingManager.supportsContentType(contentType)`` is\n                ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if content_type not in self._content_types:\n            raise errors.Unsupported()\n        lefc = self._leas.get_content_form_for_create([])\n        lefc.set_timestamp(DateTime.utcnow())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_log_entry(self, log_entry_id):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(log_entry_id, 'logging').get_identifier())},\n                 **self._view_filter()))\n        return objects.LogEntry(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the LogEntry specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_log_entries_by_ids(self, log_entry_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in log_entry_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'logging').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.LogEntryList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a LogEntryList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_log_entries_by_genus_type(self, log_entry_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(log_entry_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.LogEntryList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of log entries corresponding to the given log entry genus Type which do not include entries of genus types derived form the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all log entries.", "response": "def get_log_entries(self):\n        \"\"\"Gets all log entries.\n\n        In plenary mode, the returned list contains all known entries or\n        an error results. Otherwise, the returned list may contain only\n        those entries that are accessible through this session.\n\n        return: (osid.logging.LogEntryList) - a list of log entries\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.LogEntryList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of log entries matching the given log entry query.", "response": "def get_log_entries_by_query(self, log_entry_query):\n        \"\"\"Gets a list of log entries matching the given log entry query.\n\n        arg:    log_entry_query (osid.logging.LogEntryQuery): the log\n                entry query\n        return: (osid.logging.LogEntryList) - the returned\n                ``LogEntryList``\n        raise:  NullArgument - ``log_entry_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``log_entry_query`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in log_entry_query._query_terms:\n            if '$in' in log_entry_query._query_terms[term] and '$nin' in log_entry_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': log_entry_query._query_terms[term]['$in']}},\n                             {term: {'$nin': log_entry_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: log_entry_query._query_terms[term]})\n        for term in log_entry_query._keyword_terms:\n            or_list.append({term: log_entry_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('logging',\n                                             collection='LogEntry',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.LogEntryList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if this user can create a single LogEntry using the desired record types.", "response": "def can_create_log_entry_with_record_types(self, log_entry_record_types):\n        \"\"\"Tests if this user can create a single ``LogEntry`` using the desired record types.\n\n        While ``LoggingManager.getLogEntryRecordTypes()`` can be used to\n        examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``LogEntry``.\n        Providing an empty array tests if a ``LogEntry`` can be created\n        with no records.\n\n        arg:    log_entry_record_types (osid.type.Type[]): array of log\n                entry record types\n        return: (boolean) - ``true`` if ``LogEntry`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise\n        raise:  NullArgument - ``log_entry_record_types`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=log_entry_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_log_entry_form_for_create(self, log_entry_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in log_entry_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if log_entry_record_types == []:\n            obj_form = objects.LogEntryForm(\n                log_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.LogEntryForm(\n                log_id=self._catalog_id,\n                record_types=log_entry_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the log entry form for creating new log entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_log_entry(self, log_entry_form):\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        if not isinstance(log_entry_form, ABCLogEntryForm):\n            raise errors.InvalidArgument('argument type is not an LogEntryForm')\n        if log_entry_form.is_for_update():\n            raise errors.InvalidArgument('the LogEntryForm is for update only, not create')\n        try:\n            if self._forms[log_entry_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('log_entry_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('log_entry_form did not originate from this session')\n        if not log_entry_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n\n        if 'timestamp' not in log_entry_form._my_map or log_entry_form._my_map['timestamp'] is None:\n            log_entry_form._my_map['timestamp'] = DateTime.utcnow()\n        log_entry_form._my_map['agentId'] = str(self.get_effective_agent_id())\n\n        insert_result = collection.insert_one(log_entry_form._my_map)\n\n        self._forms[log_entry_form.get_id().get_identifier()] = CREATED\n        result = objects.LogEntry(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new LogEntry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_log_entry(self, log_entry_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        if not isinstance(log_entry_form, ABCLogEntryForm):\n            raise errors.InvalidArgument('argument type is not an LogEntryForm')\n        if not log_entry_form.is_for_update():\n            raise errors.InvalidArgument('the LogEntryForm is for update only, not create')\n        try:\n            if self._forms[log_entry_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('log_entry_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('log_entry_form did not originate from this session')\n        if not log_entry_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(log_entry_form._my_map)\n\n        self._forms[log_entry_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.LogEntry(\n            osid_object_map=log_entry_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing log entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes a ``LogEntry``. arg: log_entry_id (osid.id.Id): the ``Id`` of the ``log_entry_id`` to remove raise: NotFound - ``log_entry_id`` not found raise: NullArgument - ``log_entry_id`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def delete_log_entry(self, log_entry_id):\n        \"\"\"Deletes a ``LogEntry``.\n\n        arg:    log_entry_id (osid.id.Id): the ``Id`` of the\n                ``log_entry_id`` to remove\n        raise:  NotFound - ``log_entry_id`` not found\n        raise:  NullArgument - ``log_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('logging',\n                                         collection='LogEntry',\n                                         runtime=self._runtime)\n        if not isinstance(log_entry_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        log_entry_map = collection.find_one(\n            dict({'_id': ObjectId(log_entry_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.LogEntry(osid_object_map=log_entry_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(log_entry_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef alias_log_entry(self, log_entry_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=log_entry_id, equivalent_id=alias_id)", "response": "Adds an Id to a LogEntry in the system with an alias."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of LogEntry Ids associated with a Log.", "response": "def get_log_entry_ids_by_log(self, log_id):\n        \"\"\"Gets the list of ``LogEntry``  ``Ids`` associated with a ``Log``.\n\n        arg:    log_id (osid.id.Id): ``Id`` of a ``Log``\n        return: (osid.id.IdList) - list of related logEntry ``Ids``\n        raise:  NotFound - ``log_id`` is not found\n        raise:  NullArgument - ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for log_entry in self.get_log_entries_by_log(log_ids):\n            id_list.append(log_entry.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of log entries associated with a Log.", "response": "def get_log_entries_by_log(self, log_id):\n        \"\"\"Gets the list of log entries associated with a ``Log``.\n\n        arg:    log_id (osid.id.Id): ``Id`` of a ``Log``\n        return: (osid.logging.LogEntryList) - list of related logEntry\n        raise:  NotFound - ``log_id`` is not found\n        raise:  NullArgument - ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('LOGGING', local=True)\n        lookup_session = mgr.get_log_entry_lookup_session_for_log(log_id, proxy=self._proxy)\n        lookup_session.use_isolated_log_view()\n        return lookup_session.get_log_entries()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_log_entrie_by_log(self, log_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('LOGGING', local=True)\n        lookup_session = mgr.get_log_entry_lookup_session_for_log(log_ids, proxy=self._proxy)\n        lookup_session.use_isolated_log_view()\n        return lookup_session.get_log_entries()", "response": "Gets the list of log entries corresponding to a list of Log."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of Log Ids mapped to a LogEntry.", "response": "def get_log_ids_by_log_entry(self, log_entry_id):\n        \"\"\"Gets the list of ``Log``  ``Ids`` mapped to a ``LogEntry``.\n\n        arg:    log_entry_id (osid.id.Id): ``Id`` of a ``LogEntry``\n        return: (osid.id.IdList) - list of log ``Ids``\n        raise:  NotFound - ``log_entry_id`` is not found\n        raise:  NullArgument - ``log_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('LOGGING', local=True)\n        lookup_session = mgr.get_log_entry_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_log_view()\n        log_entry = lookup_session.get_log_entry(log_entry_id)\n        id_list = []\n        for idstr in log_entry._my_map['assignedLogIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assignable_log_ids(self, log_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.get_assignable_bin_ids\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('LOGGING', local=True)\n        lookup_session = mgr.get_log_lookup_session(proxy=self._proxy)\n        logs = lookup_session.get_logs()\n        id_list = []\n        for log in logs:\n            id_list.append(log.get_id())\n        return IdList(id_list)", "response": "Gets a list of log including and under the given log node in which any log entry can be assigned."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assign_log_entry_to_log(self, log_entry_id, log_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('LOGGING', local=True)\n        lookup_session = mgr.get_log_lookup_session(proxy=self._proxy)\n        lookup_session.get_log(log_id)  # to raise NotFound\n        self._assign_object_to_catalog(log_entry_id, log_id)", "response": "Adds an existing LogEntry to a Log."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a LogEntry from a Log.", "response": "def unassign_log_entry_from_log(self, log_entry_id, log_id):\n        \"\"\"Removes a ``LogEntry`` from a ``Log``.\n\n        arg:    log_entry_id (osid.id.Id): the ``Id`` of the\n                ``LogEntry``\n        arg:    log_id (osid.id.Id): the ``Id`` of the ``Log``\n        raise:  NotFound - ``log_entry_id`` or ``log_id`` not found or\n                ``log_entry_id`` not assigned to ``log_id``\n        raise:  NullArgument - ``log_entry_id`` or ``log_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('LOGGING', local=True)\n        lookup_session = mgr.get_log_lookup_session(proxy=self._proxy)\n        lookup_session.get_log(log_id)  # to raise NotFound\n        self._unassign_object_from_catalog(log_entry_id, log_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reassign_log_entry_to_log(self, log_entry_id, from_log_id, to_log_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.reassign_resource_to_bin\n        self.assign_log_entry_to_log(log_entry_id, to_log_id)\n        try:\n            self.unassign_log_entry_from_log(log_entry_id, from_log_id)\n        except:  # something went wrong, roll back assignment to to_log_id\n            self.unassign_log_entry_from_log(log_entry_id, to_log_id)\n            raise", "response": "Moves a LogEntry from one Log to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if this user can create a single Log using the desired record types.", "response": "def can_create_log_with_record_types(self, log_record_types):\n        \"\"\"Tests if this user can create a single ``Log`` using the desired record types.\n\n        While ``LoggingManager.getLogRecordTypes()`` can be used to\n        examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Log``.\n        Providing an empty array tests if a ``Log`` can be created with\n        no records.\n\n        arg:    log_record_types (osid.type.Type[]): array of log record\n                types\n        return: (boolean) - ``true`` if ``Log`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise\n        raise:  NullArgument - ``log_record_types`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=log_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_log(self, log_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=log_form)\n        collection = JSONClientValidated('logging',\n                                         collection='Log',\n                                         runtime=self._runtime)\n        if not isinstance(log_form, ABCLogForm):\n            raise errors.InvalidArgument('argument type is not an LogForm')\n        if not log_form.is_for_update():\n            raise errors.InvalidArgument('the LogForm is for update only, not create')\n        try:\n            if self._forms[log_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('log_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('log_form did not originate from this session')\n        if not log_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(log_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[log_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Log(osid_object_map=log_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing log."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef alias_log(self, log_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=log_id, alias_id=alias_id)\n        self._alias_id(primary_id=log_id, equivalent_id=alias_id)", "response": "Adds an Id to a log for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_log_hierarchy_id(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_hierarchy_id\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalog_hierarchy_id()\n        return self._hierarchy_session.get_hierarchy_id()", "response": "Gets the hierarchy Id associated with this session."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the hierarchy associated with this session.", "response": "def get_log_hierarchy(self):\n        \"\"\"Gets the hierarchy associated with this session.\n\n        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_hierarchy\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalog_hierarchy()\n        return self._hierarchy_session.get_hierarchy()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_root_logs(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return LogLookupSession(\n            self._proxy,\n            self._runtime).get_logs_by_ids(list(self.get_root_log_ids()))", "response": "Gets the root logs in the log hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_parent_logs(self, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=log_id)\n        return self._hierarchy_session.has_parents(id_=log_id)", "response": "Tests if the Log has any parents."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if an Id is a direct parent of a log.", "response": "def is_parent_of_log(self, id_, log_id):\n        \"\"\"Tests if an ``Id`` is a direct parent of a log.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    log_id (osid.id.Id): the ``Id`` of a log\n        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``log_id,``  ``false`` otherwise\n        raise:  NotFound - ``log_id`` is not found\n        raise:  NullArgument - ``id`` or ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=log_id)\n        return self._hierarchy_session.is_parent(id_=log_id, parent_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the parent Ids of the given log.", "response": "def get_parent_log_ids(self, log_id):\n        \"\"\"Gets the parent ``Ids`` of the given log.\n\n        arg:    log_id (osid.id.Id): the ``Id`` of a log\n        return: (osid.id.IdList) - the parent ``Ids`` of the log\n        raise:  NotFound - ``log_id`` is not found\n        raise:  NullArgument - ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=log_id)\n        return self._hierarchy_session.get_parents(id_=log_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_parent_logs(self, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=log_id)\n        return LogLookupSession(\n            self._proxy,\n            self._runtime).get_logs_by_ids(\n                list(self.get_parent_log_ids(log_id)))", "response": "Gets the parent logs of the given id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_ancestor_of_log(self, id_, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=log_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=log_id)", "response": "Tests if an Id is an ancestor of a log."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_child_logs(self, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=log_id)\n        return self._hierarchy_session.has_children(id_=log_id)", "response": "Tests if a log has any children."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if an Id is a direct child of a log.", "response": "def is_child_of_log(self, id_, log_id):\n        \"\"\"Tests if an ``Id`` is a direct child of a log.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    log_id (osid.id.Id): the ``Id`` of a log\n        return: (boolean) - ``true`` if this ``id`` is a child of\n                ``log_id,``  ``false`` otherwise\n        raise:  NotFound - ``log_id`` is not found\n        raise:  NullArgument - ``id`` or ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=log_id)\n        return self._hierarchy_session.is_child(id_=log_id, child_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_child_log_ids(self, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=log_id)\n        return self._hierarchy_session.get_children(id_=log_id)", "response": "Gets the child Ids of the given log."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the child logs of the given id.", "response": "def get_child_logs(self, log_id):\n        \"\"\"Gets the child logs of the given ``id``.\n\n        arg:    log_id (osid.id.Id): the ``Id`` of the ``Log`` to query\n        return: (osid.logging.LogList) - the child logs of the ``id``\n        raise:  NotFound - a ``Log`` identified by ``Id is`` not found\n        raise:  NullArgument - ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=log_id)\n        return LogLookupSession(\n            self._proxy,\n            self._runtime).get_logs_by_ids(\n                list(self.get_child_log_ids(log_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_descendant_of_log(self, id_, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=log_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=log_id)", "response": "Tests if an Id is a descendant of a log."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_log_nodes(self, log_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.LogNode(self.get_log_node_ids(\n            log_id=log_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the log nodes in the hierarchy for the given log."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a root log.", "response": "def add_root_log(self, log_id):\n        \"\"\"Adds a root log.\n\n        arg:    log_id (osid.id.Id): the ``Id`` of a log\n        raise:  AlreadyExists - ``log_id`` is already in hierarchy\n        raise:  NotFound - ``log_id`` is not found\n        raise:  NullArgument - ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=log_id)\n        return self._hierarchy_session.add_root(id_=log_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a root log.", "response": "def remove_root_log(self, log_id):\n        \"\"\"Removes a root log.\n\n        arg:    log_id (osid.id.Id): the ``Id`` of a log\n        raise:  NotFound - ``log_id`` is not a root\n        raise:  NullArgument - ``log_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=log_id)\n        return self._hierarchy_session.remove_root(id_=log_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a child to a log.", "response": "def add_child_log(self, log_id, child_id):\n        \"\"\"Adds a child to a log.\n\n        arg:    log_id (osid.id.Id): the ``Id`` of a log\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``log_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``log_id`` or ``child_id`` not found\n        raise:  NullArgument - ``log_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=log_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=log_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_child_log(self, log_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=log_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=log_id, child_id=child_id)", "response": "Removes a child from a log."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_child_logs(self, log_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=log_id)\n        return self._hierarchy_session.remove_children(id_=log_id)", "response": "Removes all children from a log."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a horizontal bar chart for the given data.", "response": "def bar_chart(data, bar_char='=', width=80):\n\t\"\"\"Return an horizontal bar chart \n\n\t>>> print bar_chart({\n\t...     'one': '1',\n\t...     'two': '2',\n\t...     'three': '3',\n\t...     'four': '4',\n\t...     'five': '5',\n\t... })\n\t five =====\n\t four ====\n\t  one =\n\tthree ===\n\t  two ==\n\t>>> print bar_chart({\n\t...     '1/1': 1/1.0,\n\t...     '1/2': 1/2.0,\n\t...     '1/3': 1/3.0,\n\t...     '1/4': 1/4.0,\n\t...     '1/5': 1/5.0,\n\t...     '2': 2,\n\t...     '3': 3,\n\t...     '4': 4,\n\t...     '5': 5,\n\t... })\n\t1/1 ===============\n\t1/2 =======\n\t1/3 =====\n\t1/4 ===\n\t1/5 ===\n\t  2 ==============================\n\t  3 =============================================\n\t  4 ============================================================\n\t  5 ===========================================================================\n\t>>> print bar_chart({\n\t...     '1': 2**1,\n\t...     '2': 2**2,\n\t...     '3': 2**3,\n\t...     '4': 2**4,\n\t...     '5': 2**5,\n\t...     '6': 2**6,\n\t...     '7': 2**7,\n\t... })\n\t1 =\n\t2 ==\n\t3 ====\n\t4 =========\n\t5 ===================\n\t6 ======================================\n\t7 =============================================================================\n    \"\"\"\n\tif type(data) is dict:\n\t\toutput = []\n\t\tmax_len = len(max(data, key=len))\n\t\tfloat_values = map(float, data.values())\n\t\tmax_value = max(float_values)\n\t\tmin_value = min(float_values)\n\t\tall_integer = all(f.is_integer() for f in float_values)\n\t\tfor key in sorted(data):\n\t\t\toutput.append('%s %s'%(key.rjust(max_len, ' '), draw_bar(bar_char, float(data[key]), all_integer, min_value, max_value, width-max_len-2)))\n\treturn '\\n'.join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef action(callback=None, name=None, path=None, methods=Method.GET, resource=None, tags=None,\n           summary=None, middleware=None):\n    # type: (Callable, Path, Path, Methods, Type[Resource], Tags, str, List[Any]) -> Operation\n    \"\"\"\n    Decorator to apply an action to a resource. An action is applied to a `detail` operation.\n    \"\"\"\n    # Generate action path\n    path = path or '{key_field}'\n    if name:\n        path += name\n\n    def inner(c):\n        return Operation(c, path, methods, resource, tags, summary, middleware)\n    return inner(callback) if callback else inner", "response": "Decorator to apply an action to a resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detail(callback=None, path=None, method=Method.GET, resource=None, tags=None, summary=\"Get specified resource.\",\n           middleware=None):\n    # type: (Callable, Path, Methods, Resource, Tags, str, List[Any]) -> Operation\n    \"\"\"\n    Decorator to configure an operation that fetches a resource.\n    \"\"\"\n    def inner(c):\n        op = Operation(c, path or PathParam('{key_field}'), method, resource, tags, summary, middleware)\n        op.responses.add(Response(HTTPStatus.OK, \"Get a {name}\"))\n        op.responses.add(Response(HTTPStatus.NOT_FOUND, \"Not found\", Error))\n        return op\n    return inner(callback) if callback else inner", "response": "Decorator to configure an operation that fetches a resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the callback if required", "response": "def execute(self, request, *args, **path_args):\n        # type: (BaseHttpRequest, tuple, Dict[Any]) -> Any\n        \"\"\"\n        Execute the callback (binding callback if required)\n        \"\"\"\n        binding = self.binding\n        if binding:\n            # Provide binding as decorators are executed prior to binding\n            return self.callback(binding, request, *args, **path_args)\n        else:\n            return self.callback(request, *args, **path_args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbinding a ResourceApi instance to an operation.", "response": "def bind_to_instance(self, instance):\n        \"\"\"\n        Bind a ResourceApi instance to an operation.\n        \"\"\"\n        self.binding = instance\n        self.middleware.append(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef op_paths(self, path_prefix=None):\n        # type: (Path) -> Generator[Tuple[UrlPath, Operation]]\n        \"\"\"\n        Yield operations paths stored in containers.\n        \"\"\"\n        url_path = self.path\n        if path_prefix:\n            url_path = path_prefix + url_path\n\n        yield url_path, self", "response": "Yields the list of operations paths stored in containers."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resource(self):\n        if self._resource:\n            return self._resource\n        elif self.binding:\n            return self.binding.resource", "response": "Return the resource associated with this operation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name of the key.", "response": "def key_field_name(self):\n        \"\"\"\n        Field identified as the key.\n        \"\"\"\n        name = 'resource_id'\n        if self.resource:\n            key_field = getmeta(self.resource).key_field\n            if key_field:\n                name = key_field.attname\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a dictionary for documentation generation.", "response": "def to_swagger(self):\n        \"\"\"\n        Generate a dictionary for documentation generation.\n        \"\"\"\n        return dict_filter(\n            operationId=self.operation_id,\n            description=(self.callback.__doc__ or '').strip() or None,\n            summary=self.summary or None,\n            tags=list(self.tags) or None,\n            deprecated=self.deprecated or None,\n            consumes=list(self.consumes) or None,\n            parameters=[param.to_swagger(self.resource) for param in self.parameters] or None,\n            produces=list(self.produces) or None,\n            responses=dict(resp.to_swagger(self.resource) for resp in self.responses) or None,\n            security=self.security.to_swagger() if self.security else None,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tags(self):\n        # type: () -> Set[str]\n        \"\"\"\n        Tags applied to operation.\n        \"\"\"\n        tags = set()\n        if self._tags:\n            tags.update(self._tags)\n        if self.binding:\n            binding_tags = getattr(self.binding, 'tags', None)\n            if binding_tags:\n                tags.update(binding_tags)\n        return tags", "response": "Returns a set of tags applied to this operation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_container(self, conf, images, **kwargs):\n        with self._run_container(conf, images, **kwargs):\n            pass", "response": "Run this image and all dependency images"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete any deleteable images", "response": "def delete_deps(self, conf, images):\n        \"\"\"Delete any deleteable images\"\"\"\n        for dependency_name, _ in conf.dependency_images():\n            image = images[dependency_name]\n            if image.deleteable_image:\n                log.info(\"Removing un-needed image {0}\".format(image.image_name))\n                conf.harpoon.docker_api.remove_image(image.image_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart containers for all our dependencies", "response": "def run_deps(self, conf, images):\n        \"\"\"Start containers for all our dependencies\"\"\"\n        for dependency_name, detached in conf.dependency_images(for_running=True):\n            try:\n                self.run_container(images[dependency_name], images, detach=detached, dependency=True)\n            except Exception as error:\n                raise BadImage(\"Failed to start dependency container\", image=conf.name, dependency=dependency_name, error=error)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops the containers for all our dependencies", "response": "def stop_deps(self, conf, images):\n        \"\"\"Stop the containers for all our dependencies\"\"\"\n        for dependency, _ in conf.dependency_images():\n            self.stop_deps(images[dependency], images)\n            try:\n                self.stop_container(images[dependency], fail_on_bad_exit=True, fail_reason=\"Failed to run dependency container\")\n            except BadImage:\n                raise\n            except Exception as error:\n                log.warning(\"Failed to stop dependency container\\timage=%s\\tdependency=%s\\tcontainer_name=%s\\terror=%s\", conf.name, dependency, images[dependency].container_name, error)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for all our dependencies", "response": "def wait_for_deps(self, conf, images):\n        \"\"\"Wait for all our dependencies\"\"\"\n        from harpoon.option_spec.image_objs import WaitCondition\n        api = conf.harpoon.docker_context_maker().api\n\n        waited = set()\n        last_attempt = {}\n        dependencies = set(dep for dep, _ in conf.dependency_images())\n\n        # Wait conditions come from dependency_options first\n        # Or if none specified there, they come from the image itself\n        wait_conditions = {}\n        for dependency in dependencies:\n            if conf.dependency_options is not NotSpecified and dependency in conf.dependency_options and conf.dependency_options[dependency].wait_condition is not NotSpecified:\n                wait_conditions[dependency] = conf.dependency_options[dependency].wait_condition\n            elif images[dependency].wait_condition is not NotSpecified:\n                wait_conditions[dependency] = images[dependency].wait_condition\n\n        if not wait_conditions:\n            return\n\n        start = time.time()\n        while True:\n            this_round = []\n            for dependency in dependencies:\n                if dependency in waited:\n                    continue\n\n                image = images[dependency]\n                if dependency in wait_conditions:\n                    done = self.wait_for_dep(api, image, wait_conditions[dependency], start, last_attempt.get(dependency))\n                    this_round.append(done)\n                    if done is True:\n                        waited.add(dependency)\n                    elif done is False:\n                        last_attempt[dependency] = time.time()\n                    elif done is WaitCondition.Timedout:\n                        log.warning(\"Stopping dependency because it timedout waiting\\tcontainer_id=%s\", image.container_id)\n                        self.stop_container(image)\n                else:\n                    waited.add(dependency)\n\n            if set(this_round) != set([WaitCondition.KeepWaiting]):\n                if dependencies - waited == set():\n                    log.info(\"Finished waiting for dependencies\")\n                    break\n                else:\n                    log.info(\"Still waiting for dependencies\\twaiting_on=%s\", list(dependencies-waited))\n\n                couldnt_wait = set()\n                container_ids = {}\n                for dependency in dependencies:\n                    if dependency in waited:\n                        continue\n\n                    image = images[dependency]\n                    if image.container_id is None:\n                        stopped = True\n                        if dependency not in container_ids:\n                            available = sorted([i for i in available if \"/{0}\".format(image.container_name) in i[\"Names\"]], key=lambda i: i[\"Created\"])\n                            if available:\n                                container_ids[dependency] = available[0][\"Id\"]\n                    else:\n                        if dependency not in container_ids:\n                            container_ids[dependency] = image.container_id\n                        stopped, _ = self.is_stopped(image, image.container_id)\n\n                    if stopped:\n                        couldnt_wait.add(dependency)\n\n                if couldnt_wait:\n                    for container in couldnt_wait:\n                        if container not in images or container not in container_ids:\n                            continue\n                        image = images[container]\n                        container_id = container_ids[container]\n                        container_name = image.container_name\n                        hp.write_to(conf.harpoon.stdout, \"=================== Logs for failed container {0} ({1})\\n\".format(container_id, container_name))\n                        for line in conf.harpoon.docker_api.logs(container_id).split(\"\\n\"):\n                            hp.write_to(conf.harpoon.stdout, \"{0}\\n\".format(line))\n                        hp.write_to(conf.harpoon.stdout, \"------------------- End logs for failed container\\n\")\n                    raise BadImage(\"One or more of the dependencies stopped running whilst waiting for other dependencies\", stopped=list(couldnt_wait))\n\n            time.sleep(0.1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for this image to be available", "response": "def wait_for_dep(self, api, conf, wait_condition, start, last_attempt):\n        \"\"\"Wait for this image\"\"\"\n        from harpoon.option_spec.image_objs import WaitCondition\n        conditions = list(wait_condition.conditions(start, last_attempt))\n        if conditions[0] in (WaitCondition.KeepWaiting, WaitCondition.Timedout):\n            return conditions[0]\n\n        log.info(\"Waiting for %s\", conf.container_name)\n        for condition in conditions:\n            log.debug(\"Running condition\\tcondition=%s\", condition)\n            command = 'bash -c \"{0}\"'.format(condition)\n            try:\n                exec_id = api.exec_create(conf.container_id, command, tty=False)\n            except DockerAPIError as error:\n                log.error(\"Failed to run condition\\tcondition=%s\\tdependency=%s\\terror=%s\", condition, conf.name, error)\n                return False\n\n            output = api.exec_start(exec_id).decode('utf-8')\n            inspection = api.exec_inspect(exec_id)\n            exit_code = inspection[\"ExitCode\"]\n            if exit_code != 0:\n                log.error(\"Condition says no\\tcondition=%s\\toutput:\\n\\t%s\", condition, \"\\n\\t\".join(line for line in output.split('\\n')))\n                return False\n\n        log.info(\"Finished waiting for %s\", conf.container_name)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_container(self, conf, detach, tty):\n\n        name = conf.name\n        image_name = conf.image_name\n        if conf.tag is not NotSpecified:\n            image_name = conf.image_name_with_tag\n        container_name = conf.container_name\n\n        with conf.assumed_role():\n            env = dict(e.pair for e in conf.env)\n\n        binds = conf.volumes.binds\n        command = conf.formatted_command\n        volume_names = conf.volumes.volume_names\n        volumes_from = list(conf.volumes.share_with_names)\n        no_tty_option = conf.no_tty_option\n\n        ports = [p.container_port.port_pair for p in conf.ports]\n        port_bindings = self.exposed(conf.ports)\n\n        uncreated = []\n        for name in binds:\n            if not os.path.exists(name):\n                log.info(\"Making volume for mounting\\tvolume=%s\", name)\n                try:\n                    os.makedirs(name)\n                except OSError as error:\n                    uncreated.append((name, error))\n        if uncreated:\n            raise BadOption(\"Failed to create some volumes on the host\", uncreated=uncreated)\n\n        log.info(\"Creating container from %s\\timage=%s\\tcontainer_name=%s\\ttty=%s\", image_name, name, container_name, tty)\n        if binds:\n            log.info(\"\\tUsing volumes\\tvolumes=%s\", volume_names)\n        if env:\n            log.info(\"\\tUsing environment\\tenv=%s\", sorted(env.keys()))\n        if ports:\n            log.info(\"\\tUsing ports\\tports=%s\", ports)\n        if port_bindings:\n            log.info(\"\\tPort bindings: %s\", port_bindings)\n        if volumes_from:\n            log.info(\"\\tVolumes from: %s\", volumes_from)\n\n        host_config = conf.harpoon.docker_api.create_host_config(\n              binds = binds\n            , volumes_from = volumes_from\n            , port_bindings = port_bindings\n\n            , devices = conf.devices\n            , lxc_conf = conf.lxc_conf\n            , privileged = conf.privileged\n            , restart_policy = conf.restart_policy\n\n            , dns = conf.network.dns\n            , dns_search = conf.network.dns_search\n            , extra_hosts = conf.network.extra_hosts\n            , network_mode = conf.network.network_mode\n            , publish_all_ports = conf.network.publish_all_ports\n\n            , cap_add = conf.cpu.cap_add\n            , cap_drop = conf.cpu.cap_drop\n            , mem_limit = conf.cpu.mem_limit\n            , cpu_shares = conf.cpu.cpu_shares\n            , cpuset_cpus = conf.cpu.cpuset_cpus\n            , cpuset_mems = conf.cpu.cpuset_mems\n            , memswap_limit = conf.cpu.memswap_limit\n\n            , ulimits = conf.ulimits\n            , read_only = conf.read_only_rootfs\n            , log_config = conf.log_config\n            , security_opt = conf.security_opt\n\n            , **conf.other_options.host_config\n            )\n\n        container_id = conf.harpoon.docker_api.create_container(image_name\n            , name=container_name\n            , detach=detach\n            , command=command\n            , volumes=volume_names\n            , environment=env\n\n            , tty = False if no_tty_option else tty\n            , user = conf.user\n            , ports = ports\n            , stdin_open = tty\n\n            , hostname = conf.network.hostname\n            , domainname = conf.network.domainname\n            , network_disabled = conf.network.disabled\n\n            , host_config = host_config\n\n            , **conf.other_options.create\n            )\n\n        if isinstance(container_id, dict):\n            if \"errorDetail\" in container_id:\n                raise BadImage(\"Failed to create container\", image=name, error=container_id[\"errorDetail\"])\n            container_id = container_id[\"Id\"]\n\n        return container_id", "response": "Create a single container from a configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart a single container", "response": "def start_container(self, conf, tty=True, detach=False, is_dependency=False, no_intervention=False):\n        \"\"\"Start up a single container\"\"\"\n        # Make sure we can bind to our specified ports!\n        if not conf.harpoon.docker_api.base_url.startswith(\"http\"):\n            self.find_bound_ports(conf.ports)\n\n        container_id = conf.container_id\n        container_name = conf.container_name\n\n        conf.harpoon.network_manager.register(conf, container_name)\n\n        log.info(\"Starting container %s (%s)\", container_name, container_id)\n\n        try:\n            if not detach and not is_dependency:\n                self.start_tty(conf, interactive=tty, **conf.other_options.start)\n            else:\n                conf.harpoon.docker_api.start(container_id\n                    , **conf.other_options.start\n                    )\n        except docker.errors.APIError as error:\n            if str(error).startswith(\"404 Client Error: Not Found\"):\n                log.error(\"Container died before we could even get to it...\")\n\n        inspection = None\n        if not detach and not is_dependency:\n            inspection = self.get_exit_code(conf)\n\n        if inspection and not no_intervention:\n            if not inspection[\"State\"][\"Running\"] and inspection[\"State\"][\"ExitCode\"] != 0:\n                self.stage_run_intervention(conf)\n                raise BadImage(\"Failed to run container\", container_id=container_id, container_name=container_name, reason=\"nonzero exit code after launch\")\n\n        if not is_dependency and conf.harpoon.intervene_afterwards and not no_intervention:\n            self.stage_run_intervention(conf, just_do_it=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaiting till a container is stopped", "response": "def wait_till_stopped(self, conf, container_id, timeout=10, message=None, waiting=True):\n        \"\"\"Wait till a container is stopped\"\"\"\n        stopped = False\n        inspection = None\n        for _ in until(timeout=timeout, action=message):\n            try:\n                inspection = conf.harpoon.docker_api.inspect_container(container_id)\n                if not isinstance(inspection, dict):\n                    log.error(\"Weird response from inspecting the container\\tresponse=%s\", inspection)\n                else:\n                    if not inspection[\"State\"][\"Running\"]:\n                        stopped = True\n                        conf.container_id = None\n                        break\n                    else:\n                        break\n            except (socket.timeout, ValueError):\n                log.warning(\"Failed to inspect the container\\tcontainer_id=%s\", container_id)\n            except DockerAPIError as error:\n                if error.response.status_code != 404:\n                    raise\n                else:\n                    break\n\n        if not inspection:\n            log.warning(\"Failed to inspect the container!\")\n            stopped = True\n            exit_code = 1\n        else:\n            exit_code = inspection[\"State\"][\"ExitCode\"]\n        return stopped, exit_code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn whether this container is stopped.", "response": "def is_stopped(self, *args, **kwargs):\n        \"\"\"Return whether this container is stopped\"\"\"\n        kwargs[\"waiting\"] = False\n        return self.wait_till_stopped(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_exit_code(self, conf):\n        for _ in until(timeout=0.5, step=0.1, silent=True):\n            try:\n                inspection = conf.harpoon.docker_api.inspect_container(conf.container_id)\n                if not isinstance(inspection, dict) or \"State\" not in inspection:\n                    raise BadResult(\"Expected inspect result to be a dictionary with 'State' in it\", found=inspection)\n                elif not inspection[\"State\"][\"Running\"]:\n                    return inspection\n            except Exception as error:\n                log.error(\"Failed to see if container exited normally or not\\thash=%s\\terror=%s\", conf.container_id, error)", "response": "Determine how a container exited"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind any ports that are already bound and complain about them", "response": "def find_bound_ports(self, ports):\n        \"\"\"Find any ports that are already bound and complain about them\"\"\"\n        bound = []\n        for port in ports:\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                s.bind((port.ip if port.ip is not NotSpecified else \"127.0.0.1\", port.host_port))\n            except socket.error as error:\n                bound.append(port.host_port)\n            finally:\n                s.close()\n\n        if bound:\n            raise AlreadyBoundPorts(ports=bound)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef intervention(self, commit, conf):\n        if not conf.harpoon.interactive or conf.harpoon.no_intervention:\n            yield\n            return\n\n        hp.write_to(conf.harpoon.stdout, \"!!!!\\n\")\n        hp.write_to(conf.harpoon.stdout, \"It would appear building the image failed\\n\")\n        hp.write_to(conf.harpoon.stdout, \"Do you want to run {0} where the build to help debug why it failed?\\n\".format(conf.resolved_shell))\n        conf.harpoon.stdout.flush()\n        answer = input(\"[y]: \")\n        if answer and not answer.lower().startswith(\"y\"):\n            yield\n            return\n\n        with self.commit_and_run(commit, conf, command=conf.resolved_shell):\n            yield", "response": "Ask the user if they want to commit this container and run sh in it"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef commit_and_run(self, commit, conf, command=\"sh\"):\n        image_hash = None\n        try:\n            image_hash = conf.harpoon.docker_api.commit(commit)[\"Id\"]\n\n            new_conf = conf.clone()\n            new_conf.bash = NotSpecified\n            new_conf.command = command\n            new_conf.image_name = image_hash\n            new_conf.container_id = None\n            new_conf.container_name = \"{0}-intervention-{1}\".format(conf.container_id, str(uuid.uuid1()))\n\n            container_id = self.create_container(new_conf, False, True)\n            new_conf.container_id = container_id\n\n            try:\n                self.start_container(new_conf, tty=True, detach=False, is_dependency=False, no_intervention=True)\n            finally:\n                self.stop_container(new_conf)\n            yield\n        except Exception as error:\n            log.error(\"Something failed about creating the intervention image\\terror=%s\", error)\n            raise\n        finally:\n            try:\n                if image_hash:\n                    log.info(\"Removing intervened image\\thash=%s\", image_hash)\n                    conf.harpoon.docker_api.remove_image(image_hash)\n            except Exception as error:\n                log.error(\"Failed to kill intervened image\\thash=%s\\terror=%s\", image_hash, error)", "response": "Commit this container id and run the provided command in it and clean up afterwards"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing this listener. Finds most recent timestamp", "response": "def initialize(self, runtime):\n        \"\"\"Initialize this listener. Finds most recent timestamp\"\"\"\n        if self.is_alive():\n            raise IllegalState('notification thread is already initialized')\n        if not JSON_CLIENT.is_json_client_set() and runtime is not None:\n            JSON_CLIENT.set_json_client(runtime)\n        try:\n            cursor = JSON_CLIENT.json_client['local']['oplog.rs'].find().sort('ts', DESCENDING).limit(-1)\n        except TypeError:\n            # filesystem, so .json_client is a bool and not iterable\n            pass\n        else:\n            try:\n                self.last_timestamp = cursor.next()['ts']\n            except StopIteration:\n                self.last_timestamp = Timestamp(0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a notification to the receiver", "response": "def _notify_receiver(self, receiver, params, doc):\n        \"\"\"Send notification to the receiver\"\"\"\n        verb = VMAP[doc['op']]\n        ns = doc['ns']\n        notification_id = Id(ns + 'Notification:' + str(ObjectId()) + '@' + params['authority'])\n        object_id = Id(ns + ':' + str(doc['o']['_id']) + '@' + params['authority'])\n        try:\n            getattr(receiver, '_'.join([verb, params['obj_name_plural']]))(notification_id, [object_id])\n        except AttributeError:\n            pass\n        return notification_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning through all receivers related to the doc s namespace", "response": "def _run_namespace(self, doc):\n        \"\"\"Run through all receivers related to the doc's namespace\"\"\"\n        for receiver in self.receivers[doc['ns']]:\n            params = self.receivers[doc['ns']][receiver]\n            if params[doc['op']]:\n                if params[doc['op']] is True or str(doc['o']['_id']) in params[doc['op']]:\n                    notification_id = self._notify_receiver(receiver, params, doc)\n                    if params['reliable'] and self._max_attempts > 1:\n                        self.notifications[notification_id] = {\n                            'receiver': receiver,\n                            'params': dict(params),\n                            'doc': dict(doc),\n                            'ts': datetime.datetime.utcnow(),\n                            'attempts': 1}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _retry(self):\n        notifications_to_delete = []\n        for notification_id in self.notifications:\n            if datetime.datetime.utcnow() > self.notifications[notification_id]['ts'] + self._wait_period:\n                self._notify_receiver(\n                    self.notifications[notification_id]['receiver'],\n                    self.notifications[notification_id]['params'],\n                    self.notifications[notification_id]['doc'])\n                if self.notifications[notification_id]['attempts'] >= self._max_attempts - 1:\n                    notifications_to_delete.append(notification_id)\n                else:\n                    self.notifications[notification_id]['ts'] = datetime.datetime.utcnow()\n                    self.notifications[notification_id]['attempts'] += 1\n        for notification_id in notifications_to_delete:\n            del self.notifications[notification_id]", "response": "Deal with unacknowledged notifications."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self):\n        while True:\n            try:\n                cursor = JSON_CLIENT.json_client['local']['oplog.rs'].find(\n                    {'ts': {'$gt': self.last_timestamp}})\n            except TypeError:\n                # filesystem, so .json_client is a bool and not iterable\n                pass\n            else:\n                # http://stackoverflow.com/questions/30401063/pymongo-tailing-oplog\n                cursor.add_option(2)  # tailable\n                cursor.add_option(8)  # oplog_replay\n                cursor.add_option(32)  # await data\n                self._retry()\n                for doc in cursor:\n                    self.last_timestamp = doc['ts']\n                    if doc['ns'] in self.receivers:\n                        self._run_namespace(doc)\n            time.sleep(1)", "response": "main loop for thread"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine what range of objects to return.", "response": "def range_return(request, items):\n    \"\"\"\n    Determine what range of objects to return.\n\n    Will check fot both `Range` and `X-Range` headers in the request and\n    set both `Content-Range` and 'X-Content-Range' headers.\n\n    :rtype: list\n    \"\"\"\n    if ('Range' in request.headers):\n        range = parse_range_header(request.headers['Range'])\n    elif 'X-Range' in request.headers:\n        range = parse_range_header(request.headers['X-Range'])\n    else:\n        range = {\n            'start': 0,\n            'finish': MAX_NUMBER_ITEMS - 1,\n            'count': MAX_NUMBER_ITEMS\n        }\n    filtered = items[range['start']:range['finish'] + 1]\n    if len(filtered) < range['count']:\n        # Something was stripped, deal with it\n        range['count'] = len(filtered)\n        range['finish'] = range['start'] + range['count'] - 1\n    if range['finish'] - range['start'] + 1 >= MAX_NUMBER_ITEMS:\n        range['finish'] = range['start'] + MAX_NUMBER_ITEMS - 1\n        filtered = items[range['start']:range['finish'] + 1]\n\n    request.response.headers['Content-Range'] = 'items %d-%d/%d' % (range['start'], range['finish'], len(items))\n    request.response.headers['X-Content-Range'] = request.response.headers['Content-Range']\n    return filtered"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset an HTTP Cache Control header on a request.", "response": "def set_http_caching(request, gateway='crab', region='permanent'):\n    \"\"\"\n    Set an HTTP Cache Control header on a request.\n\n    :param pyramid.request.Request request: Request to set headers on.\n    :param str gateway: What gateway are we caching for? Defaults to `crab`.\n    :param str region: What caching region to use? Defaults to `permanent`.\n    :rtype: pyramid.request.Request\n    \"\"\"\n    crabpy_exp = request.registry.settings.get('crabpy.%s.cache_config.%s.expiration_time' % (gateway, region), None)\n    if crabpy_exp is None:\n        return request\n    ctime = int(int(crabpy_exp) * 1.05)\n    request.response.cache_expires(ctime, public=True)\n    return request"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_type_data(self, name):\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'Genus Types',\n            'identifier': name,\n            'domain': 'Generic Types',\n            'display_name': self.generic_types[name] + ' Generic Type',\n            'display_label': self.generic_types[name],\n            'description': ('The ' + self.generic_types[name] +\n                            ' Type. This type has no symantic meaning.')\n        }", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset up assessmentPartMap with as much information as is initially available.", "response": "def _initialize_part_map(self):\n        \"\"\"Sets up assessmentPartMap with as much information as is initially available.\"\"\"\n        self._my_map['assessmentParts'] = []\n        self._my_map['questions'] = []\n        item_ids = self._assessment_part.get_item_ids()\n        if item_ids.available():\n            # This is a simple section:\n            self._load_simple_section_questions(item_ids)\n        else:\n            # This goes down the winding path...\n            # let's not call this...seems redundant, and per Jeff, this might\n            # save us time.\n            # self._update_questions()\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the map of the assessment parts that have the given ID", "response": "def _get_part_map(self, part_id):\n        \"\"\" from self._my_map['assessmentParts'], return the one part map\n        with ID that matches the one passed in\"\"\"\n        return [p for p in self._my_map['assessmentParts']\n                if p['assessmentPartId'] == str(part_id)][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _insert_part_map(self, part_map, index=-1):\n        if index == -1:\n            self._my_map['assessmentParts'].append(part_map)\n        else:\n            self._my_map['assessmentParts'].insert(index, part_map)", "response": "insert a part map into the assessmentParts list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the current state of this AssessmentSection to database.", "response": "def _save(self):\n        \"\"\"Saves the current state of this AssessmentSection to database.\n\n        Should be called every time the question map changes.\n\n        \"\"\"\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentSection',\n                                         runtime=self._runtime)\n        if '_id' in self._my_map:  # This is the first time:\n            collection.save(self._my_map)\n        else:\n            insert_result = collection.insert_one(self._my_map)\n            self._my_map = collection.find_one({'_id': insert_result.inserted_id})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete this AssessmentSection from database.", "response": "def _delete(self):\n        \"\"\"Deletes this AssessmentSection from database.\n\n        Will be called by AssessmentTaken._delete() for clean-up purposes.\n\n        \"\"\"\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentSection',\n                                         runtime=self._runtime)\n        collection.delete_one({'_id': ObjectId(self.get_id().get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_simple_section(self):\n        item_ids = self._get_assessment_part(self._assessment_part_id).get_item_ids()\n        if item_ids.available():\n            return True\n        return False", "response": "Tests if this section is simple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_assessment_part(self, part_id=None):\n        if part_id is None:\n            return self._assessment_part\n        if part_id not in self._assessment_parts:\n            lookup_session = self._get_assessment_part_lookup_session()\n            self._assessment_parts[part_id] = lookup_session.get_assessment_part(part_id)\n        return self._assessment_parts[part_id]", "response": "Gets an AssessmentPart given a part_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _update_from_database(self):\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentSection',\n                                         runtime=self._runtime)\n        self._my_map = collection.find_one({'_id': self._my_map['_id']})", "response": "Updates the map to latest state in database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate questions known to this Section", "response": "def _update_questions(self):\n        \"\"\"Updates questions known to this Section\"\"\"\n        if self.is_simple_section():\n            return  # we don't need to go through any this for simple sections\n        # ideally, we would update the parts map and questions list\n        # at the same time as _get_parts(), to not run into the\n        # issue where magic parts are initialized (with items)\n        # ignorant of their \"sibling\" magic part items...\n        # because the section hasn't been updated or saved to database\n        part_list = self._get_parts()\n        if len(part_list) > len(self._my_map['assessmentParts']):\n            self._update_assessment_parts_map(part_list)\n            self._update_questions_list(part_list)\n            self._save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _update_assessment_parts_map(self, part_list):\n        for part in part_list:\n            # perhaps look for a \"level offset\"?\n            level = part._level_in_section  # plus or minus \"level offset\"?\n            if str(part.get_id()) not in self._part_ids():\n                self._insert_part_map(get_default_part_map(\n                    part.get_id(), level, part.are_items_sequential()),\n                    index=part_list.index(part))", "response": "Updates the assessmentPart map."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_question_map(self, question_id):\n        if question_id.get_authority() == ASSESSMENT_AUTHORITY:\n            key = '_id'\n            match_value = ObjectId(question_id.get_identifier())\n        else:\n            key = 'questionId'\n            match_value = str(question_id)\n        for question_map in self._my_map['questions']:\n            if question_map[key] == match_value:\n                return question_map\n        raise errors.NotFound()", "response": "get question map from questions matching question_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_question_ids_for_assessment_part(self, assessment_part_id):\n        question_ids = []\n        for question_map in self._my_map['questions']:\n            if question_map['assessmentPartId'] == str(assessment_part_id):\n                question_ids.append(self.get_question(question_map=question_map).get_id())\n        return question_ids", "response": "convenience method returns unique question ids associated with an assessment_part_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all available questions for this section", "response": "def get_questions(self, answered=None, honor_sequential=True, update=True):\n        \"\"\"gets all available questions for this section\n\n        if answered == False: only return next unanswered question\n        if answered == True: only return next answered question\n        if answered in None: return next question whether answered or not\n        if honor_sequential == True: only return questions if section or part\n                                     is set to sequential items\n\n        \"\"\"\n\n        def update_question_list():\n            \"\"\"Supportive function to aid readability of _get_questions.\"\"\"\n            latest_question_response = question_map['responses'][0]\n            question_answered = False\n            # take missingResponse == UNANSWERED or NULL_RESPONSE as an unanswered question\n            if 'missingResponse' not in latest_question_response:\n                question_answered = True\n\n            if answered is None or answered == question_answered:\n                question_list.append(self.get_question(question_map=question_map))\n            return question_answered\n\n        prev_question_answered = True\n        question_list = []\n        if update:\n            self._update_questions()  # Make sure questions list is current\n        for question_map in self._my_map['questions']:\n            if self._is_question_sequential(question_map) and honor_sequential:\n                if prev_question_answered:\n                    prev_question_answered = update_question_list()\n            else:\n                update_question_list()\n        if self._my_map['actualStartTime'] is None:\n            self._my_map['actualStartTime'] = DateTime.utcnow()\n        return QuestionList(question_list, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_next_question(self, question_id, answered=None, reverse=False, honor_sequential=True):\n        self._update_questions()  # Make sure questions list is current\n        question_map = self._get_question_map(question_id)  # will raise NotFound()\n        questions = list(self._my_map['questions'])\n        if reverse:\n            questions = questions[::-1]\n            error_text = ' previous '\n        else:\n            if 'missingResponse' in question_map:\n                if self._is_question_sequential(question_map) and honor_sequential:\n                    raise errors.IllegalState('Next question is not yet available')\n            error_text = ' next '\n        if questions[-1] == question_map:\n            raise errors.IllegalState('No ' + error_text + ' questions available')\n        index = questions.index(question_map) + 1\n        for question_map in questions[index:]:\n            latest_question_response = question_map['responses'][0]\n            question_answered = False\n            # take missingResponse == UNANSWERED or NULL_RESPONSE as an unanswered question\n            if 'missingResponse' not in latest_question_response:\n                question_answered = True\n            if answered is None or question_answered == answered:\n                return self.get_question(question_map=question_map)\n        raise errors.IllegalState('No ' + error_text + ' question matching parameters was found')", "response": "Inspects question map to return the next available question."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef submit_response(self, question_id, answer_form=None):\n        if answer_form is None:\n            response = {'missingResponse': NULL_RESPONSE,\n                        'itemId': str(question_id)}\n        else:\n            response = dict(answer_form._my_map)\n            response['submissionTime'] = DateTime.utcnow()\n            try:\n                response['isCorrect'] = self._get_item(question_id).is_response_correct(\n                    Response(osid_object_map=response, runtime=self._runtime, proxy=self._proxy))\n            except (errors.IllegalState, errors.NotFound):\n                response['isCorrect'] = None\n        response['submissionTime'] = DateTime.utcnow()\n\n        question_map = self._get_question_map(question_id)  # will raise NotFound()\n        if ('missingResponse' in question_map['responses'][0] and\n                question_map['responses'][0]['missingResponse'] == UNANSWERED):\n            question_map['responses'] = []  # clear unanswered response\n        question_map['responses'].insert(0, response)\n        self._save()", "response": "Updates assessmentParts map to insert an item response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_response(self, question_id):\n        question_map = self._get_question_map(question_id)  # will raise NotFound()\n        return self._get_response_from_question_map(question_map)", "response": "Gets the response for question_id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of latest responses", "response": "def get_responses(self):\n        \"\"\"Gets list of the latest responses\"\"\"\n        response_list = []\n        for question_map in self._my_map['questions']:\n            response_list.append(self._get_response_from_question_map(question_map))\n        return ResponseList(response_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nis the question matching item_id been answered and not skipped?", "response": "def is_question_answered(self, question_id):\n        \"\"\"has the question matching item_id been answered and not skipped\"\"\"\n        question_map = self._get_question_map(question_id)  # will raise NotFound()\n        if 'missingResponse' in question_map['responses'][0]:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_feedback_available(self, question_id):\n        response = self.get_response(question_id)\n        item = self._get_item(question_id)\n        if response.is_answered():\n            return item.is_feedback_available_for_response(response)\n        return item.is_feedback_available()", "response": "is feedback available for item"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets feedback for item", "response": "def get_feedback(self, question_id):\n        \"\"\"get feedback for item\"\"\"\n        response = self.get_response(question_id)\n        item = self._get_item(response.get_item_id())\n        if response.is_answered():\n            try:\n                return item.get_feedback_for_response(response)\n            except errors.IllegalState:\n                pass\n        else:\n            return item.get_feedback()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets confused objective ids available for the question", "response": "def get_confused_learning_objective_ids(self, question_id):\n        \"\"\"get confused objective ids available for the question\"\"\"\n        response = self.get_response(question_id)\n        if response.is_answered():\n            item = self._get_item(response.get_item_id())\n            return item.get_confused_learning_objective_ids_for_response(response)\n        raise errors.IllegalState()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_correctness_available(self, question_id):\n        response = self.get_response(question_id)\n        if response.is_answered():\n            item = self._get_item(response.get_item_id())\n            return item.is_correctness_available_for_response(response)\n        return False", "response": "is a measure of correctness available for the question"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_correct(self, question_id):\n        response = self.get_response(question_id=question_id)\n        if response.is_answered():\n            item = self._get_item(response.get_item_id())\n            return item.is_response_correct(response)\n        raise errors.IllegalState()", "response": "is the question answered correctly?"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_correctness(self, question_id):\n        response = self.get_response(question_id)\n        if response.is_answered():\n            item = self._get_item(response.get_item_id())\n            return item.get_correctness_for_response(response)\n        raise errors.IllegalState()", "response": "get measure of correctness for the question"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndeclare this section finished", "response": "def finish(self):\n        \"\"\"Declare this section finished\"\"\"\n        self._my_map['over'] = True  # finished == over?\n        self._my_map['completionTime'] = DateTime.utcnow()\n        self._save()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck all Questions for completeness", "response": "def is_complete(self):\n        \"\"\"Check all Questions for completeness\n\n        For now, completeness simply means that all questions have been\n        responded to and not skipped or cleared.\n\n        \"\"\"\n        self._update_questions()  # Make sure questions list is current\n        for question_map in self._my_map['questions']:\n            if 'missingResponse' in question_map['responses'][0]:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a unit file and updates self. _data [ options ] with the values from that file.", "response": "def _set_options_from_file(self, file_handle):\n        \"\"\"Parses a unit file and updates self._data['options']\n\n        Args:\n            file_handle (file): a file-like object (supporting read()) containing a unit\n\n        Returns:\n            True: The file was successfuly parsed and options were updated\n\n        Raises:\n            IOError: from_file was specified and it does not exist\n            ValueError: The unit contents specified in from_string or from_file is not valid\n        \"\"\"\n\n        # TODO: Find a library to handle this unit file parsing\n        # Can't use configparser, it doesn't handle multiple entries for the same key in the same section\n        # This is terribly naive\n\n        # build our output here\n        options = []\n\n        # keep track of line numbers to report when parsing problems happen\n        line_number = 0\n\n        # the section we are currently in\n        section = None\n        for line in file_handle.read().splitlines():\n            line_number += 1\n\n            # clear any extra white space\n            orig_line = line\n            line = line.strip()\n\n            # ignore comments, and blank lines\n            if not line or line.startswith('#'):\n                continue\n\n            # is this a section header?  If so, update our variable and continue\n            # Section headers look like: [Section]\n            if line.startswith('[') and line.endswith(']'):\n                section = line.strip('[]')\n                continue\n\n            # We encountered a non blank line outside of a section, this is a problem\n            if not section:\n                raise ValueError(\n                    'Unable to parse unit file; '\n                    'Unexpected line outside of a section: {0} (line: {1}'.format(\n                        line,\n                        line_number\n                    ))\n\n            # Attempt to parse a line inside a section\n            # Lines should look like: name=value \\\n            # continuation\n            continuation = False\n            try:\n                    # if the previous value ends with \\ then we are a continuation\n                    # so remove the \\, and set the flag so we'll append to this below\n                    if options[-1]['value'].endswith('\\\\'):\n                        options[-1]['value'] = options[-1]['value'][:-1]\n                        continuation = True\n            except IndexError:\n                    pass\n\n            try:\n                # if we are a continuation, then just append our value to the previous line\n                if continuation:\n                    options[-1]['value'] += orig_line\n                    continue\n\n                # else we are a normal line, so spit and get our name / value\n                name, value = line.split('=', 1)\n                options.append({\n                    'section': section,\n                    'name': name,\n                    'value': value\n                })\n            except ValueError:\n                raise ValueError(\n                    'Unable to parse unit file; '\n                    'Malformed line in section {0}: {1} (line: {2})'.format(\n                        section,\n                        line,\n                        line_number\n                    ))\n\n        # update our internal structure\n        self._data['options'] = options\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_option(self, section, name, value):\n\n        # Don't allow updating units we loaded from fleet, it's not supported\n        if self._is_live():\n            raise RuntimeError('Submitted units cannot update their options')\n\n        option = {\n            'section': section,\n            'name': name,\n            'value': value\n        }\n\n        self._data['options'].append(option)\n\n        return True", "response": "Add an option to a section of the unit file\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves an option from a unit.", "response": "def remove_option(self, section, name, value=None):\n        \"\"\"Remove an option from a unit\n\n        Args:\n            section (str): The section to remove from.\n            name (str): The item to remove.\n            value (str, optional): If specified, only the option matching this value will be removed\n                                   If not specified, all options with ``name`` in ``section`` will be removed\n\n        Returns:\n            True: At least one item was removed\n            False: The item requested to remove was not found\n\n        \"\"\"\n        # Don't allow updating units we loaded from fleet, it's not supported\n        if self._is_live():\n            raise RuntimeError('Submitted units cannot update their options')\n\n        removed = 0\n        # iterate through a copy of the options\n        for option in list(self._data['options']):\n            # if it's in our section\n            if option['section'] == section:\n                # and it matches our name\n                if option['name'] == name:\n                    # and they didn't give us a value, or it macthes\n                    if value is None or option['value'] == value:\n                        # nuke it from the source\n                        self._data['options'].remove(option)\n                        removed += 1\n\n        if removed > 0:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef destroy(self):\n\n        # if this unit didn't come from fleet, we can't destroy it\n        if not self._is_live():\n            raise RuntimeError('A unit must be submitted to fleet before it can destroyed.')\n\n        return self._client.destroy_unit(self.name)", "response": "Remove a unit from the fleet cluster"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_desired_state(self, state):\n        if state not in self._STATES:\n            raise ValueError(\n                'state must be one of: {0}'.format(\n                    self._STATES\n                ))\n\n        # update our internal structure\n        self._data['desiredState'] = state\n\n        # if we have a name, then we came from the server\n        # and we have a handle to an active client\n        # Then update our selves on the server\n        if self._is_live():\n            self._update('_data', self._client.set_unit_desired_state(self.name, self.desiredState))\n\n        # Return the state\n        return self._data['desiredState']", "response": "Update the desired state of a unit."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the difference in medians between two arrays of values.", "response": "def diff_medians(array_one, array_two):\n    \"\"\"\n    Computes the difference in medians between two arrays of values.\n\n    Given arrays will be flattened (to 1D array) regardless of dimension,\n        and any non-finite/NaN values will be ignored.\n\n    Parameters\n    ----------\n    array_one, array_two : iterable\n        Two arrays of values, possibly of different length.\n\n    Returns\n    -------\n    diff_medians : float\n        scalar measuring the difference in medians, ignoring NaNs/non-finite values.\n\n    Raises\n    ------\n    ValueError\n        If one or more of the arrays are empty.\n\n    \"\"\"\n\n    array_one = check_array(array_one)\n    array_two = check_array(array_two)\n    diff_medians = np.ma.median(array_one) - np.ma.median(array_two)\n\n    return diff_medians"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef diff_medians_abs(array_one, array_two):\n\n    abs_diff_medians = np.abs(diff_medians(array_one, array_two))\n\n    return abs_diff_medians", "response": "Computes the absolute difference in medians between two arrays of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diff_means(array_one, array_two):\n\n    array_one = check_array(array_one)\n    array_two = check_array(array_two)\n    diff_means = np.ma.mean(array_one) - np.ma.mean(array_two)\n\n    return diff_means", "response": "Computes the difference in means between two arrays of values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the absolute difference in means between two arrays of values.", "response": "def diff_means_abs(array_one, array_two):\n    \"\"\"\n    Computes the absolute (symmetric) difference in means between two arrays of values.\n\n    Given arrays will be flattened (to 1D array) regardless of dimension,\n        and any non-finite/NaN values will be ignored.\n\n    Parameters\n    ----------\n    array_one, array_two : iterable\n        Two arrays of values, possibly of different length.\n\n    Returns\n    -------\n    diff_medians : float\n        scalar measuring the difference in medians, ignoring NaNs/non-finite values.\n\n    Raises\n    ------\n    ValueError\n        If one or more of the arrays are empty.\n\n    \"\"\"\n\n    abs_diff_means = np.abs(diff_means(array_one, array_two))\n\n    return abs_diff_means"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef isstring(value):\n    classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821\n    return isinstance(value, classes)", "response": "Report whether the given value is a byte or unicode string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the ``Item``. return: (osid.assessment.Item) - the assessment item *compliance: mandatory -- This method must be implemented.*", "response": "def get_item(self):\n        \"\"\"Gets the ``Item``.\n\n        return: (osid.assessment.Item) - the assessment item\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # So, for now we're assuming that what should be returned here is the question.\n        # We could change this class impl to \"know\" if it came from a ResponseLookupSession call\n        # and return the whole Item if so.\n        try:\n            # an un-answered response will have a magic itemId here\n            item_lookup_session = get_item_lookup_session(runtime=self._runtime, proxy=self._proxy)\n            item_lookup_session.use_federated_bank_view()\n            item = item_lookup_session.get_item(self._item_id)\n        except errors.NotFound:\n            # otherwise an answered response will have an assessment-session itemId\n            if self._section is not None:\n                question = self._section.get_question(self._item_id)\n                ils = self._section._get_item_lookup_session()\n                real_item_id = Id(question._my_map['itemId'])\n                item = ils.get_item(real_item_id)\n            else:\n                raise errors.NotFound()\n        return item.get_question()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_response_record(self, item_record_type):\n        if not self.has_record_type(item_record_type):\n            raise errors.Unsupported()\n        if str(item_record_type) not in self._records:\n            raise errors.Unimplemented()\n        return self._records[str(item_record_type)]", "response": "Gets the response record corresponding to the given item record type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverride get_id to generate our magic ids that encode choice order", "response": "def get_id(self):\n        \"\"\"override get_id to generate our \"magic\" ids that encode choice order\"\"\"\n\n        # Check first to make sure no one else has claimed authority on my object.\n        # This will likely occur when an AssessmentSection returns a Question\n        # During an AssessmentSession\n        if self.my_osid_object._authority != MAGIC_AUTHORITY:\n            return self.my_osid_object._item_id\n            # raise AttributeError\n\n        # If not, go ahead and build magic Id:\n        choices = self.my_osid_object._my_map['choices']\n        choice_ids = [c['id'] for c in choices]\n        magic_identifier = quote('{0}?{1}'.format(self.my_osid_object._my_map['_id'],\n                                                  json.dumps(choice_ids)))\n        return Id(namespace='assessment.Item',\n                  identifier=magic_identifier,\n                  authority=MAGIC_AUTHORITY)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the values of the choice objects in the current object", "response": "def set_values(self, choice_ids):\n        \"\"\"assume choice_ids is a list of choiceIds, like\n        [\"57978959cdfc5c42eefb36d1\", \"57978959cdfc5c42eefb36d0\",\n        \"57978959cdfc5c42eefb36cf\", \"57978959cdfc5c42eefb36ce\"]\n        \"\"\"\n        # if not self.my_osid_object._my_map['choices']:\n        #     raise IllegalState()\n        organized_choices = []\n        for choice_id in choice_ids:\n            choice_obj = [c for c in self._original_choice_order if c['id'] == choice_id][0]\n            organized_choices.append(choice_obj)\n        self.my_osid_object._my_map['choices'] = organized_choices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Id of the source of this asset.", "response": "def get_source_id(self):\n        \"\"\"Gets the ``Resource Id`` of the source of this asset.\n\n        The source is the original owner of the copyright of this asset\n        and may differ from the creator of this asset. The source for a\n        published book written by Margaret Mitchell would be Macmillan.\n        The source for an unpublished painting by Arthur Goodwin would\n        be Arthur Goodwin.\n\n        An ``Asset`` is ``Sourceable`` and also contains a provider\n        identity. The provider is the entity that makes this digital\n        asset available in this repository but may or may not be the\n        publisher of the contents depicted in the asset. For example, a\n        map published by Ticknor and Fields in 1848 may have a provider\n        of Library of Congress and a source of Ticknor and Fields. If\n        copied from a repository at Middlebury College, the provider\n        would be Middlebury College and a source of Ticknor and Fields.\n\n        return: (osid.id.Id) - the source ``Id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['sourceId']):\n            raise errors.IllegalState('this Asset has no source')\n        else:\n            return Id(self._my_map['sourceId'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the Resources representing the source of this asset in order from the most recent provider to the originating source.", "response": "def get_provider_links(self):\n        \"\"\"Gets the ``Resources`` representing the source of this asset in order from the most recent provider to the originating source.\n\n        return: (osid.resource.ResourceList) - the provider chain\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_assets_template\n        if not bool(self._my_map['providerLinkIds']):\n            raise errors.IllegalState('no providerLinkIds')\n        mgr = self._get_provider_manager('RESOURCE')\n        if not mgr.supports_resource_lookup():\n            raise errors.OperationFailed('Resource does not support Resource lookup')\n\n        # What about the Proxy?\n        lookup_session = mgr.get_resource_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bin_view()\n        return lookup_session.get_resources_by_ids(self.get_provider_link_ids())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the content Ids of this asset.", "response": "def get_asset_content_ids(self):\n        \"\"\"Gets the content ``Ids`` of this asset.\n\n        return: (osid.id.IdList) - the asset content ``Ids``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.Asset.get_asset_content_ids_template\n        id_list = []\n        for asset_content in self.get_asset_contents():\n            id_list.append(asset_content.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_contents(self):\n        # Implemented from template for osid.repository.Asset.get_asset_contents_template\n        return AssetContentList(\n            self._my_map['assetContents'],\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Gets the content of this asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the Composition Id corresponding to this asset.", "response": "def get_composition_id(self):\n        \"\"\"Gets the ``Composition``  ``Id`` corresponding to this asset.\n\n        return: (osid.id.Id) - the composiiton ``Id``\n        raise:  IllegalState - ``is_composition()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['compositionId']):\n            raise errors.IllegalState('composition empty')\n        return Id(self._my_map['compositionId'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the Composition corresponding to this asset.", "response": "def get_composition(self):\n        \"\"\"Gets the Composition corresponding to this asset.\n\n        return: (osid.repository.Composition) - the composiiton\n        raise:  IllegalState - ``is_composition()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['compositionId']):\n            raise errors.IllegalState('composition empty')\n        mgr = self._get_provider_manager('REPOSITORY')\n        if not mgr.supports_composition_lookup():\n            raise errors.OperationFailed('Repository does not support Composition lookup')\n        lookup_session = mgr.get_composition_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_repository_view()\n        return lookup_session.get_composition(self.get_composition_id())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the metadata for the current object", "response": "def _init_metadata(self, **kwargs):\n        \"\"\"Initialize form metadata\"\"\"\n\n        osid_objects.OsidSourceableForm._init_metadata(self)\n        osid_objects.OsidObjectForm._init_metadata(self, **kwargs)\n        self._copyright_registration_default = self._mdata['copyright_registration']['default_string_values'][0]\n        update_display_text_defaults(self._mdata['copyright'], self._locale_map)\n        self._copyright_default = dict(self._mdata['copyright']['default_string_values'][0])\n        update_display_text_defaults(self._mdata['title'], self._locale_map)\n        self._title_default = dict(self._mdata['title']['default_string_values'][0])\n        self._distribute_verbatim_default = self._mdata['distribute_verbatim']['default_boolean_values'][0]\n        self._created_date_default = self._mdata['created_date']['default_date_time_values'][0]\n        self._distribute_alterations_default = self._mdata['distribute_alterations']['default_boolean_values'][0]\n        update_display_text_defaults(self._mdata['principal_credit_string'], self._locale_map)\n        self._principal_credit_string_default = dict(self._mdata['principal_credit_string']['default_string_values'][0])\n        self._published_date_default = self._mdata['published_date']['default_date_time_values'][0]\n        self._source_default = self._mdata['source']['default_id_values'][0]\n        self._provider_links_default = self._mdata['provider_links']['default_id_values']\n        self._public_domain_default = self._mdata['public_domain']['default_boolean_values'][0]\n        self._distribute_compositions_default = self._mdata['distribute_compositions']['default_boolean_values'][0]\n        self._composition_default = self._mdata['composition']['default_id_values'][0]\n        self._published_default = self._mdata['published']['default_boolean_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_map(self, record_types=None, **kwargs):\n\n        osid_objects.OsidSourceableForm._init_map(self)\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['copyrightRegistration'] = self._copyright_registration_default\n        self._my_map['assignedRepositoryIds'] = [str(kwargs['repository_id'])]\n        self._my_map['copyright'] = self._copyright_default\n        self._my_map['title'] = self._title_default\n        self._my_map['distributeVerbatim'] = self._distribute_verbatim_default\n        self._my_map['createdDate'] = self._created_date_default\n        self._my_map['distributeAlterations'] = self._distribute_alterations_default\n        self._my_map['principalCreditString'] = self._principal_credit_string_default\n        self._my_map['publishedDate'] = self._published_date_default\n        self._my_map['sourceId'] = self._source_default\n        self._my_map['providerLinkIds'] = self._provider_links_default\n        self._my_map['publicDomain'] = self._public_domain_default\n        self._my_map['distributeCompositions'] = self._distribute_compositions_default\n        self._my_map['compositionId'] = self._composition_default\n        self._my_map['published'] = self._published_default\n        self._my_map['assetContents'] = []", "response": "Initialize the map of the record types that this object is using."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the metadata for an asset title.", "response": "def get_title_metadata(self):\n        \"\"\"Gets the metadata for an asset title.\n\n        return: (osid.Metadata) - metadata for the title\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['title'])\n        metadata.update({'existing_string_values': self._my_map['title']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_title(self, title):\n        # Implemented from template for osid.repository.AssetForm.set_title_template\n        self._my_map['title'] = self._get_display_text(title, self.get_title_metadata())", "response": "Sets the title.\n\n        arg:    title (string): the new title\n        raise:  InvalidArgument - ``title`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``title`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_title(self):\n        # Implemented from template for osid.repository.AssetForm.clear_title_template\n        if (self.get_title_metadata().is_read_only() or\n                self.get_title_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['title'] = dict(self._title_default)", "response": "Removes the title.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_public_domain_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['public_domain'])\n        metadata.update({'existing_boolean_values': self._my_map['publicDomain']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the public domain flag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the public domain flag.", "response": "def set_public_domain(self, public_domain):\n        \"\"\"Sets the public domain flag.\n\n        arg:    public_domain (boolean): the public domain status\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_public_domain_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(public_domain):\n            raise errors.InvalidArgument()\n        self._my_map['publicDomain'] = public_domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_public_domain(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_public_domain_metadata().is_read_only() or\n                self.get_public_domain_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['publicDomain'] = self._public_domain_default", "response": "Removes the public domain status."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_copyright_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['copyright'])\n        metadata.update({'existing_string_values': self._my_map['copyright']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the copyright"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the copyright. arg: copyright (string): the new copyright raise: InvalidArgument - ``copyright`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``copyright`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_copyright(self, copyright_):\n        \"\"\"Sets the copyright.\n\n        arg:    copyright (string): the new copyright\n        raise:  InvalidArgument - ``copyright`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``copyright`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.AssetForm.set_title_template\n        self._my_map['copyright'] = self._get_display_text(copyright_, self.get_copyright_metadata())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_copyright(self):\n        # Implemented from template for osid.repository.AssetForm.clear_title_template\n        if (self.get_copyright_metadata().is_read_only() or\n                self.get_copyright_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['copyright'] = dict(self._copyright_default)", "response": "Removes the copyright.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_copyright_registration_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['copyright_registration'])\n        metadata.update({'existing_string_values': self._my_map['copyrightRegistration']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the copyright registration"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_copyright_registration(self):\n        # Implemented from template for osid.repository.AssetContentForm.clear_url_template\n        if (self.get_copyright_registration_metadata().is_read_only() or\n                self.get_copyright_registration_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['copyrightRegistration'] = self._copyright_registration_default", "response": "Removes the copyright registration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the metadata for the distribute verbatim rights flag.", "response": "def get_distribute_verbatim_metadata(self):\n        \"\"\"Gets the metadata for the distribute verbatim rights flag.\n\n        return: (osid.Metadata) - metadata for the distribution rights\n                fields\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['distribute_verbatim'])\n        metadata.update({'existing_boolean_values': self._my_map['distributeVerbatim']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the distribute rights.", "response": "def set_distribute_verbatim(self, distribute_verbatim):\n        \"\"\"Sets the distribution rights.\n\n        arg:    distribute_verbatim (boolean): right to distribute\n                verbatim copies\n        raise:  InvalidArgument - ``distribute_verbatim`` is invalid\n        raise:  NoAccess - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_distribute_verbatim_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(distribute_verbatim):\n            raise errors.InvalidArgument()\n        self._my_map['distributeVerbatim'] = distribute_verbatim"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the distribution rights.", "response": "def clear_distribute_verbatim(self):\n        \"\"\"Removes the distribution rights.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_distribute_verbatim_metadata().is_read_only() or\n                self.get_distribute_verbatim_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['distributeVerbatim'] = self._distribute_verbatim_default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_distribute_alterations_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['distribute_alterations'])\n        metadata.update({'existing_boolean_values': self._my_map['distributeAlterations']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the distribute alterations rights flag."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_distribute_alterations(self, distribute_mods):\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_distribute_alterations_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(distribute_mods):\n            raise errors.InvalidArgument()\n        self._my_map['distributeAlterations'] = distribute_mods", "response": "Sets the distribute alterations flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_distribute_alterations(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_distribute_alterations_metadata().is_read_only() or\n                self.get_distribute_alterations_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['distributeAlterations'] = self._distribute_alterations_default", "response": "Removes the distribution rights."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the metadata for the distribute compositions rights flag.", "response": "def get_distribute_compositions_metadata(self):\n        \"\"\"Gets the metadata for the distribute compositions rights flag.\n\n        return: (osid.Metadata) - metadata for the distribution rights\n                fields\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['distribute_compositions'])\n        metadata.update({'existing_boolean_values': self._my_map['distributeCompositions']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_distribute_compositions(self, distribute_comps):\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_distribute_compositions_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(distribute_comps):\n            raise errors.InvalidArgument()\n        self._my_map['distributeCompositions'] = distribute_comps", "response": "Sets the distribute rights."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the distribution rights.", "response": "def clear_distribute_compositions(self):\n        \"\"\"Removes the distribution rights.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_distribute_compositions_metadata().is_read_only() or\n                self.get_distribute_compositions_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['distributeCompositions'] = self._distribute_compositions_default"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the metadata for the source", "response": "def get_source_metadata(self):\n        \"\"\"Gets the metadata for the source.\n\n        return: (osid.Metadata) - metadata for the source\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['source'])\n        metadata.update({'existing_id_values': self._my_map['sourceId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_source(self, source_id):\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_source_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(source_id):\n            raise errors.InvalidArgument()\n        self._my_map['sourceId'] = str(source_id)", "response": "Sets the source.\n\n        arg:    source_id (osid.id.Id): the new publisher\n        raise:  InvalidArgument - ``source_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``source_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the source. raise: NoAccess - ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_source(self):\n        \"\"\"Removes the source.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_source_metadata().is_read_only() or\n                self.get_source_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['sourceId'] = self._source_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the metadata for the provider chain.", "response": "def get_provider_links_metadata(self):\n        \"\"\"Gets the metadata for the provider chain.\n\n        return: (osid.Metadata) - metadata for the provider chain\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.get_assets_metadata_template\n        metadata = dict(self._mdata['provider_links'])\n        metadata.update({'existing_provider_links_values': self._my_map['providerLinkIds']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the provider links for this asset.", "response": "def set_provider_links(self, resource_ids):\n        \"\"\"Sets a provider chain in order from the most recent source to the originating source.\n\n        arg:    resource_ids (osid.id.Id[]): the new source\n        raise:  InvalidArgument - ``resource_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``resource_ids`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.set_assets_template\n        if not isinstance(resource_ids, list):\n            raise errors.InvalidArgument()\n        if self.get_provider_links_metadata().is_read_only():\n            raise errors.NoAccess()\n        idstr_list = []\n        for object_id in resource_ids:\n            if not self._is_valid_id(object_id):\n                raise errors.InvalidArgument()\n            idstr_list.append(str(object_id))\n        self._my_map['providerLinkIds'] = idstr_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the provider links.", "response": "def clear_provider_links(self):\n        \"\"\"Removes the provider chain.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.clear_assets_template\n        if (self.get_provider_links_metadata().is_read_only() or\n                self.get_provider_links_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['providerLinkIds'] = self._provider_links_default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the metadata for the asset creation date.", "response": "def get_created_date_metadata(self):\n        \"\"\"Gets the metadata for the asset creation date.\n\n        return: (osid.Metadata) - metadata for the created date\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['created_date'])\n        metadata.update({'existing_date_time_values': self._my_map['createdDate']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_created_date(self, created_date):\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_start_time_template\n        if self.get_created_date_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_date_time(\n                created_date,\n                self.get_created_date_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['createdDate'] = created_date", "response": "Sets the created date."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_created_date(self):\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.clear_start_time_template\n        if (self.get_created_date_metadata().is_read_only() or\n                self.get_created_date_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['createdDate'] = self._created_date_default", "response": "Removes the created date."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the metadata for the published status", "response": "def get_published_metadata(self):\n        \"\"\"Gets the metadata for the published status.\n\n        return: (osid.Metadata) - metadata for the published field\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['published'])\n        metadata.update({'existing_boolean_values': self._my_map['published']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_published(self, published):\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_published_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(published):\n            raise errors.InvalidArgument()\n        self._my_map['published'] = published", "response": "Sets the published status."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_published(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_published_metadata().is_read_only() or\n                self.get_published_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['published'] = self._published_default", "response": "Removes the published status."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_published_date_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['published_date'])\n        metadata.update({'existing_date_time_values': self._my_map['publishedDate']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the published date."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the published date.", "response": "def set_published_date(self, published_date):\n        \"\"\"Sets the published date.\n\n        arg:    published_date (osid.calendaring.DateTime): the new\n                published date\n        raise:  InvalidArgument - ``published_date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``published_date`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_start_time_template\n        if self.get_published_date_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_date_time(\n                published_date,\n                self.get_published_date_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['publishedDate'] = published_date"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_published_date(self):\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.clear_start_time_template\n        if (self.get_published_date_metadata().is_read_only() or\n                self.get_published_date_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['publishedDate'] = self._published_date_default", "response": "Removes the puiblished date."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the metadata for the principal credit string", "response": "def get_principal_credit_string_metadata(self):\n        \"\"\"Gets the metadata for the principal credit string.\n\n        return: (osid.Metadata) - metadata for the credit string\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['principal_credit_string'])\n        metadata.update({'existing_string_values': self._my_map['principalCreditString']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_principal_credit_string(self, credit_string):\n        # Implemented from template for osid.repository.AssetForm.set_title_template\n        self._my_map['principalCreditString'] = self._get_display_text(credit_string, self.get_principal_credit_string_metadata())", "response": "Sets the principal credit string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the principal credit string.", "response": "def clear_principal_credit_string(self):\n        \"\"\"Removes the principal credit string.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.AssetForm.clear_title_template\n        if (self.get_principal_credit_string_metadata().is_read_only() or\n                self.get_principal_credit_string_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['principalCreditString'] = dict(self._principal_credit_string_default)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_composition_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['composition'])\n        metadata.update({'existing_id_values': self._my_map['compositionId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for linking this asset to a composition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the composition. arg: composition_id (osid.id.Id): a composition raise: InvalidArgument - ``composition_id`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``composition_id`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_composition(self, composition_id):\n        \"\"\"Sets the composition.\n\n        arg:    composition_id (osid.id.Id): a composition\n        raise:  InvalidArgument - ``composition_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``composition_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_composition_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(composition_id):\n            raise errors.InvalidArgument()\n        self._my_map['compositionId'] = str(composition_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the composition link.", "response": "def clear_composition(self):\n        \"\"\"Removes the composition link.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_composition_metadata().is_read_only() or\n                self.get_composition_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['compositionId'] = self._composition_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['assetId']):\n            raise errors.IllegalState('asset empty')\n        return Id(self._my_map['assetId'])", "response": "Gets the Asset Id corresponding to this content."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the Asset corresponding to this content.", "response": "def get_asset(self):\n        \"\"\"Gets the ``Asset`` corresponding to this content.\n\n        return: (osid.repository.Asset) - the asset\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['assetId']):\n            raise errors.IllegalState('asset empty')\n        mgr = self._get_provider_manager('REPOSITORY')\n        if not mgr.supports_asset_lookup():\n            raise errors.OperationFailed('Repository does not support Asset lookup')\n        lookup_session = mgr.get_asset_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_repository_view()\n        return lookup_session.get_asset(self.get_asset_id())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_data(self):\n        if not bool(self._my_map['data']):\n            raise errors.IllegalState('no data')\n        dbase = JSONClientValidated('repository',\n                                    runtime=self._runtime).raw()\n        filesys = gridfs.GridFS(dbase)\n        return DataInputStream(filesys.get(self._my_map['data']))", "response": "Gets the asset content data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the metadata for an accessibility type", "response": "def get_accessibility_type_metadata(self):\n        \"\"\"Gets the metadata for an accessibility type.\n\n        return: (osid.Metadata) - metadata for the accessibility types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.logging.LogEntryForm.get_priority_metadata\n        metadata = dict(self._mdata['accessibility_type'])\n        metadata.update({'existing_type_values': self._my_map['accessibilityTypeId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_data_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['data'])\n        metadata.update({'existing_object_values': self._my_map['data']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the content data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the content data.", "response": "def set_data(self, data):\n        \"\"\"Sets the content data.\n\n        arg:    data (osid.transport.DataInputStream): the content data\n        raise:  InvalidArgument - ``data`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``data`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if data is None:\n            raise errors.NullArgument('data cannot be None')\n        if not isinstance(data, DataInputStream):\n            raise errors.InvalidArgument('data must be instance of DataInputStream')\n        dbase = JSONClientValidated('repository',\n                                    runtime=self._runtime).raw()\n        filesys = gridfs.GridFS(dbase)\n        self._my_map['data'] = filesys.put(data._my_data)\n        data._my_data.seek(0)\n        self._my_map['base64'] = base64.b64encode(data._my_data.read())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the content data.", "response": "def clear_data(self):\n        \"\"\"Removes the content data.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_data_metadata().is_read_only() or\n                self.get_data_metadata().is_required()):\n            raise errors.NoAccess()\n        if self._my_map['data'] == self._data_default:\n            return\n        dbase = JSONClientValidated('repository',\n                                    runtime=self._runtime).raw()\n        filesys = gridfs.GridFS(dbase)\n        filesys.delete(self._my_map['data'])\n        self._my_map['data'] = self._data_default\n        del self._my_map['base64']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_url_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['url'])\n        metadata.update({'existing_string_values': self._my_map['url']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_url(self, url):\n        # Implemented from template for osid.repository.AssetContentForm.set_url_template\n        if self.get_url_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_string(\n                url,\n                self.get_url_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['url'] = url", "response": "Sets the url.\n\n        arg:    url (string): the new copyright\n        raise:  InvalidArgument - ``url`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``url`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the url. raise: NoAccess - ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_url(self):\n        \"\"\"Removes the url.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.AssetContentForm.clear_url_template\n        if (self.get_url_metadata().is_read_only() or\n                self.get_url_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['url'] = self._url_default"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_children(self):\n        # Implemented from template for osid.learning.Activity.get_assets_template\n        if not bool(self._my_map['childIds']):\n            raise errors.IllegalState('no childIds')\n        mgr = self._get_provider_manager('REPOSITORY')\n        if not mgr.supports_composition_lookup():\n            raise errors.OperationFailed('Repository does not support Composition lookup')\n\n        # What about the Proxy?\n        lookup_session = mgr.get_composition_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_repository_view()\n        return lookup_session.get_compositions_by_ids(self.get_child_ids())", "response": "Gets the children of this composition."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the form map.", "response": "def _init_map(self, record_types=None, **kwargs):\n        \"\"\"Initialize form map\"\"\"\n\n        osid_objects.OsidContainableForm._init_map(self)\n        osid_objects.OsidSourceableForm._init_map(self)\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['childIds'] = self._children_default\n        self._my_map['assignedRepositoryIds'] = [str(kwargs['repository_id'])]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_children_metadata(self):\n        metadata = dict(self._mdata['children'])\n        metadata.update({'existing_children_values': self._my_map['childIds']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the children"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the children. arg: child_ids (osid.id.Id[]): the children``Ids`` raise: InvalidArgument - ``child_ids`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_children(self, child_ids):\n        \"\"\"Sets the children.\n\n        arg:    child_ids (osid.id.Id[]): the children``Ids``\n        raise:  InvalidArgument - ``child_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not isinstance(child_ids, list):\n            raise errors.InvalidArgument()\n        if self.get_children_metadata().is_read_only():\n            raise errors.NoAccess()\n        idstr_list = []\n        for object_id in child_ids:\n            if not self._is_valid_id(object_id):\n                raise errors.InvalidArgument()\n            if str(object_id) not in idstr_list:\n                idstr_list.append(str(object_id))\n        self._my_map['childIds'] = idstr_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear the children. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_children(self):\n        \"\"\"Clears the children.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_children_metadata().is_read_only() or\n                self.get_children_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['childIds'] = self._children_default"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_repository(self):\n        if self._lookup_session is None:\n            mgr = get_provider_manager('REPOSITORY', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_repository_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_repository(Id(self._my_map['id']))", "response": "Gets the Repository at this node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the parents of this repository.", "response": "def get_parent_repository_nodes(self):\n        \"\"\"Gets the parents of this repository.\n\n        return: (osid.repository.RepositoryNodeList) - the parents of\n                the ``id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        parent_repository_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_repository_nodes.append(RepositoryNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return RepositoryNodeList(parent_repository_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef valid_for(whitelist):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(self, *args):\n            valid_item = False\n            try:\n                if Id(self.my_osid_object_form._my_map['genusTypeId']).identifier in whitelist:\n                    valid_item = True\n            except AttributeError:\n                if Id(self.my_osid_object._my_map['genusTypeId']).identifier in whitelist:\n                    valid_item = True\n            finally:\n                if valid_item:\n                    return func(self, *args)\n                else:\n                    raise IllegalState('Method not allowed for this object.')\n        return wrapper\n    return decorator", "response": "decorator to check the genus type of an item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_map(self):\n        super(EdXCompositionFormRecord, self)._init_map()\n        TextsFormRecord._init_map(self)  # because the OsidForm breaks the MRO chain for super, in TemporalFormRecord\n        ProvenanceFormRecord._init_map(self)  # because the OsidForm breaks the MRO chain for super, in TemporalFormRecord\n\n        self.my_osid_object_form._my_map['texts']['fileName'] = \\\n            self._text_metadata['default_string_values'][0]\n        self.my_osid_object_form._my_map['texts']['format'] = \\\n            self._text_metadata['default_string_values'][0]  # homework, exam, lab, etc.\n        self.my_osid_object_form._my_map['visibleToStudents'] = \\\n            self._visible_to_students_metadata['default_boolean_values'][0]\n        self.my_osid_object_form._my_map['draft'] = \\\n            self._draft_metadata['default_boolean_values'][0]\n        self.my_osid_object_form._my_map['texts']['userPartitionId'] = \\\n            self._text_metadata['default_string_values'][0]\n        self.my_osid_object_form._my_map['texts']['org'] = \\\n            self._text_metadata['default_string_values'][0]\n        self.my_osid_object_form._my_map['learningObjectiveIds'] = \\\n            self._learning_objective_ids_metadata['default_string_values'][0]", "response": "Initialize the map for the current species."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_metadata(self):\n        super(EdXCompositionFormRecord, self)._init_metadata()\n        TextsFormRecord._init_metadata(self)  # because the OsidForm breaks the MRO chain for super, in TemporalFormRecord\n        ProvenanceFormRecord._init_metadata(self)  # because the OsidForm breaks the MRO chain for super, in TemporalFormRecord\n        self._visible_to_students_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'visible_to_students'),\n            'element_label': 'Visible to students',\n            'instructions': 'enter a boolean value',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN'\n        }\n        self._draft_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'draft'),\n            'element_label': 'Draft',\n            'instructions': 'enter a boolean value',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [False],\n            'syntax': 'BOOLEAN'\n        }\n\n        # ideally this would be type LIST?\n        self._learning_objective_ids_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'learning_objectives'),\n            'element_label': 'learning_objectives',\n            'instructions': 'enter a list of strings',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_string_values': [[]],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }", "response": "Initializes the metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match_any_learning_objective(self, match):\n        match_key = 'learningObjectiveIds'\n        param = '$exists'\n        if match:\n            flag = 'true'\n        else:\n            flag = 'false'\n        if match_key in self._my_osid_query._query_terms:\n            self._my_osid_query._query_terms[match_key][param] = flag\n        else:\n            self._my_osid_query._query_terms[match_key] = {param: flag}\n        self._my_osid_query._query_terms[match_key]['$nin'] = [[], ['']]", "response": "Matches an item with any learning objective."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the group id to child", "response": "def get_group_id_to_child(self):\n        \"\"\" At a minimum need a course composition parent and two children to the split test\n\n            course composition\n                    |\n            split_test composition\n                |           |\n            vertical     vertical\n\n        And the expected output is a URL-safe (&quot; instead of \") JSON string, of this object\n            {\n                0: \"i4x://<org>/<course-name-slug>/<child-tag>/<child-name-slug>,\n                1: \"i4x://<org>/<course-name-slug>/<tag>/<child-name-slug>\n            }\n        \"\"\"\n        # get the children compositions, then construct\n        # the escaped-JSON structure for this split_test\n        group_ids = {}\n        # also need the course name...so go up the composition tree\n        course_node = None\n        found_course = False\n        rm = self.my_osid_object._get_provider_manager('REPOSITORY')\n        if self.my_osid_object._proxy is not None:\n            cqs = rm.get_composition_query_session_for_repository(Id(self.my_osid_object._my_map['assignedRepositoryIds'][0]),\n                                                                  proxy=self.my_osid_object._proxy)\n        else:\n            cqs = rm.get_composition_query_session_for_repository(\n                Id(self.my_osid_object._my_map['assignedRepositoryIds'][0]))\n        search_node = self.my_osid_object\n        while not found_course:\n            querier = cqs.get_composition_query()\n            cqs.use_unsequestered_composition_view()\n            querier.match_contained_composition_id(search_node.ident, True)\n            parents = cqs.get_compositions_by_query(querier)\n            if parents.available() == 0:\n                found_course = True\n            else:\n                parent = next(parents)\n                if parent.genus_type.identifier == 'course':\n                    found_course = True\n                    course_node = parent\n                else:\n                    search_node = parent\n\n        if course_node is None:\n            return ''\n        else:\n            for index, child in enumerate(self.my_osid_object.get_children()):\n                group_ids[index] = 'i4x://{0}/{1}/{2}/{3}'.format(course_node.org.text,\n                                                                  re.sub('[^\\w\\s-]', '', course_node.display_name.text),\n                                                                  child.genus_type.identifier,\n                                                                  child.url)\n            return json.dumps(group_ids).replace('\"', '&quot;')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexport the assets and the assets in the tarball", "response": "def export_olx(self, tarball, root_path):\n        \"\"\"if sequestered, only export the assets\"\"\"\n        def append_asset_to_soup_and_export(asset_):\n            if isinstance(asset_, Item):\n                try:\n                    unique_url = asset_.export_olx(tarball, root_path)\n                except AttributeError:\n                    pass\n                else:\n                    unique_name = get_file_name_without_extension(unique_url)\n                    asset_type = asset_.genus_type.identifier\n                    asset_tag = my_soup.new_tag(asset_type)\n                    asset_tag['url_name'] = unique_name\n                    getattr(my_soup, my_tag).append(asset_tag)\n            else:\n                try:\n                    unique_urls = asset_.export_olx(tarball, root_path)\n                except AttributeError:\n                    pass\n                else:\n                    for index, ac in enumerate(asset_.get_asset_contents()):\n                        asset_type = ac.genus_type.identifier\n\n                        unique_url = unique_urls[index]\n                        unique_name = get_file_name_without_extension(unique_url)\n                        asset_tag = my_soup.new_tag(asset_type)\n\n                        asset_tag['url_name'] = unique_name\n                        getattr(my_soup, my_tag).append(asset_tag)\n\n        def get_file_name_without_extension(filepath):\n            return filepath.split('/')[-1].replace('.xml', '')\n\n        my_path = None\n        if self.my_osid_object.is_sequestered():\n            # just export assets\n            for asset in self.assets:\n                try:\n                    asset.export_olx(tarball, root_path)\n                except AttributeError:\n                    pass\n        else:\n            # also add to the /<tag>/ folder\n            my_tag = self.my_osid_object.genus_type.identifier\n            expected_name = self.get_unique_name(tarball, self.url, my_tag, root_path)\n            my_path = '{0}{1}/{2}.xml'.format(root_path,\n                                              my_tag,\n                                              expected_name)\n            my_soup = BeautifulSoup('<' + my_tag + '/>', 'xml')\n            getattr(my_soup, my_tag)['display_name'] = self.my_osid_object.display_name.text\n\n            if my_tag == 'split_test':\n                getattr(my_soup, my_tag)['group_id_to_child'] = self.my_osid_object.group_id_to_child\n                getattr(my_soup, my_tag)['user_partition_id'] = self.my_osid_object.user_partition_id.text\n\n            rm = self.my_osid_object._get_provider_manager('REPOSITORY')\n            if self.my_osid_object._proxy is None:\n                cls = rm.get_composition_lookup_session()\n            else:\n                cls = rm.get_composition_lookup_session(proxy=self.my_osid_object._proxy)\n            cls.use_federated_repository_view()\n            cls.use_unsequestered_composition_view()\n            for child_id in self.my_osid_object.get_child_ids():\n                child = cls.get_composition(child_id)\n                if child.is_sequestered():\n                    # append its assets here\n                    for asset in child.assets:\n                        append_asset_to_soup_and_export(asset)\n                else:\n                    child_type = child.genus_type.identifier\n                    child_tag = my_soup.new_tag(child_type)\n\n                    child_path = child.export_olx(tarball, root_path)\n                    if child_path is not None:\n                        child_tag['url_name'] = get_file_name_without_extension(child_path)\n                    getattr(my_soup, my_tag).append(child_tag)\n\n            for asset in self.assets:\n                append_asset_to_soup_and_export(asset)\n\n            self.write_to_tarfile(tarball, my_path, my_soup)\n\n        return my_path"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, d3mds):\n        X, y = d3mds.get_data()\n\n        return Dataset(d3mds.dataset_id, X, y)", "response": "Load X y and context from D3MDS."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads X y and context from D3MDS.", "response": "def load(self, d3mds):\n        \"\"\"Load X, y and context from D3MDS.\"\"\"\n        X, y = d3mds.get_data()\n\n        resource_columns = d3mds.get_related_resources(self.data_modality)\n        for resource_column in resource_columns:\n            X = self.load_resources(X, resource_column, d3mds)\n\n        context = self.get_context(X, y)\n\n        return Dataset(d3mds.dataset_id, X, y, context=context)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef long_encode(input, errors='strict'):\n    if not isinstance(input, text_type):\n        input = text_type(input, sys.getdefaultencoding(), errors)\n    length = len(input)\n    input = unicodedata.normalize('NFKC', input)\n    return input.translate(long_table), length", "response": "Transliterate to 8 bit using as many letters as needed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef short_encode(input, errors='strict'):\n    if not isinstance(input, text_type):\n        input = text_type(input, sys.getdefaultencoding(), errors)\n    length = len(input)\n    input = unicodedata.normalize('NFKC', input)\n    return input.translate(short_table), length", "response": "Transliterate to 8 bit using as few letters as possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransliterate to 8 bit using only single letter replacements.", "response": "def single_encode(input, errors='strict'):\n    \"\"\"Transliterate to 8 bit using only single letter replacements.\n\n    For example, \\u2639 WHITE FROWNING FACE ``\u2639`` will be passed\n    through unchanged.\n\n    \"\"\"\n    if not isinstance(input, text_type):\n        input = text_type(input, sys.getdefaultencoding(), errors)\n    length = len(input)\n    input = unicodedata.normalize('NFKC', input)\n    return input.translate(single_table), length"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _double_encoding_factory(encoder, byte_encoder, byte_encoding):\n    def dbl_encode(input, errors='strict'):\n        uni, length = encoder(input, errors)\n        return byte_encoder(uni, errors)[0], length\n    dbl_encode.__name__ = '%s_%s' % (encoder.__name__, byte_encoding)\n    return dbl_encode", "response": "Return a function that will send the transliterated output to another codec."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a generator that walks all children recursively.", "response": "def visit(self, node):\n        \"\"\"Returns a generator that walks all children recursively.\"\"\"\n        for child in node:\n            yield child\n            for subchild in self.visit(child):\n                yield subchild"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_mdata():\n    return {\n        'cognitive_process': {\n            'element_label': {\n                'text': 'cognitive process',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'assessment': {\n            'element_label': {\n                'text': 'assessment',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'knowledge_category': {\n            'element_label': {\n                'text': 'knowledge category',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Objective"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_activity_mdata():\n    return {\n        'courses': {\n            'element_label': {\n                'text': 'courses',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id[] object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'assessments': {\n            'element_label': {\n                'text': 'assessments',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id[] object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'objective': {\n            'element_label': {\n                'text': 'objective',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'assets': {\n            'element_label': {\n                'text': 'assets',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id[] object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Activity"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_proficiency_mdata():\n    return {\n        'completion': {\n            'element_label': {\n                'text': 'completion',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n        'objective': {\n            'element_label': {\n                'text': 'objective',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'resource': {\n            'element_label': {\n                'text': 'resource',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'level': {\n            'element_label': {\n                'text': 'level',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Proficiency"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getLogger(name):\n    log = logging.getLogger(name=name)\n    for handler in log.handlers:\n        if name == handler.name:\n            return log\n    else:\n        return LogSetup().default_logger(name=name.split('.')[0])", "response": "Return a logger from a given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getMessage(self):\n        msg = str(self.msg)\n        if self.args:\n            msg = msg % self.args\n\n        if platform.system().lower() == 'windows' or self.levelno < 10:\n            return msg\n        elif self.levelno >= 50:\n            return utils.return_colorized(msg, 'critical')\n        elif self.levelno >= 40:\n            return utils.return_colorized(msg, 'error')\n        elif self.levelno >= 30:\n            return utils.return_colorized(msg, 'warn')\n        elif self.levelno >= 20:\n            return utils.return_colorized(msg, 'info')\n        else:\n            return utils.return_colorized(msg, 'debug')", "response": "Returns a colorized log message based on the log level."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef default_logger(self, name=__name__, enable_stream=False,\n                       enable_file=True):\n        \"\"\"Default Logger.\n\n        This is set to use a rotating File handler and a stream handler.\n        If you use this logger all logged output that is INFO and above will\n        be logged, unless debug_logging is set then everything is logged.\n        The logger will send the same data to a stdout as it does to the\n        specified log file.\n\n        You can disable the default handlers by setting either `enable_file` or\n        `enable_stream` to `False`\n\n        :param name: ``str``\n        :param enable_stream: ``bol``\n        :param enable_file: ``bol``\n        :return: ``object``\n        \"\"\"\n        if self.format is None:\n            self.format = logging.Formatter(\n                '%(asctime)s - %(module)s:%(levelname)s => %(message)s'\n            )\n\n        log = logging.getLogger(name)\n        self.name = name\n\n        if enable_file is True:\n            file_handler = handlers.RotatingFileHandler(\n                filename=self.return_logfile(filename='%s.log' % name),\n                maxBytes=self.max_size,\n                backupCount=self.max_backup\n            )\n            self.set_handler(log, handler=file_handler)\n\n        if enable_stream is True or self.debug_logging is True:\n            stream_handler = logging.StreamHandler()\n            self.set_handler(log, handler=stream_handler)\n\n        log.info('Logger [ %s ] loaded', name)\n        return log", "response": "Default Logger.\n\n        This is set to use a rotating File handler and a stream handler.\n        If you use this logger all logged output that is INFO and above will\n        be logged, unless debug_logging is set then everything is logged.\n        The logger will send the same data to a stdout as it does to the\n        specified log file.\n\n        You can disable the default handlers by setting either `enable_file` or\n        `enable_stream` to `False`\n\n        :param name: ``str``\n        :param enable_stream: ``bol``\n        :param enable_file: ``bol``\n        :return: ``object``"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_handler(self, log, handler):\n        if self.debug_logging is True:\n            log.setLevel(logging.DEBUG)\n            handler.setLevel(logging.DEBUG)\n        else:\n            log.setLevel(logging.INFO)\n            handler.setLevel(logging.INFO)\n\n        handler.name = self.name\n        handler.setFormatter(self.format)\n        log.addHandler(handler)", "response": "Set the logging level as well as the handlers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef return_logfile(filename, log_dir='/var/log'):\n        if sys.platform == 'win32':\n            user = getpass.getuser()\n        else:\n            user = os.getuid()\n        home = os.path.expanduser('~')\n\n        if not os.path.isdir(log_dir):\n            return os.path.join(home, filename)\n\n        log_dir_stat = os.stat(log_dir)\n        if log_dir_stat.st_uid == user:\n            return os.path.join(log_dir, filename)\n        elif log_dir_stat.st_gid == user:\n            return os.path.join(log_dir, filename)\n        else:\n            return os.path.join(home, filename)", "response": "Return a path to the log file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef text_coords(string, position):\n    line_start = string.rfind('\\n', 0, position) + 1\n    line_end = string.find('\\n', position)\n    lineno = string.count('\\n', 0, position)\n    columnno = position - line_start\n    line = string[line_start:line_end]\n    return (lineno, columnno, line)", "response": "r Transform a simple index into a human - readable position in a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a compiled regular expression object.", "response": "def get_regex(regex):\n    \"\"\"\n    Ensure we have a compiled regular expression object.\n\n        >>> import re\n        >>> get_regex('string') # doctest: +ELLIPSIS\n        <_sre.SRE_Pattern object at 0x...>\n        >>> pattern = re.compile(r'string')\n        >>> get_regex(pattern) is pattern\n        True\n        >>> get_regex(3) # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n        ...\n        TypeError: Invalid regex type: 3\n    \"\"\"\n    if isinstance(regex, basestring):\n        return re.compile(regex)\n    elif not isinstance(regex, re._pattern_type):\n        raise TypeError(\"Invalid regex type: %r\" % (regex,))\n    return regex"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a single character and advance the scan pointer.", "response": "def getch(self):\n        \"\"\"\n        Get a single character and advance the scan pointer.\n\n            >>> s = Scanner(\"abc\")\n            >>> s.getch()\n            'a'\n            >>> s.getch()\n            'b'\n            >>> s.getch()\n            'c'\n            >>> s.pos\n            3\n        \"\"\"\n        self.pos += 1\n        return self.string[self.pos - 1:self.pos]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a number of characters without advancing the scan pointer.", "response": "def peek(self, length):\n        \"\"\"\n        Get a number of characters without advancing the scan pointer.\n\n            >>> s = Scanner(\"test string\")\n            >>> s.peek(7)\n            'test st'\n            >>> s.peek(7)\n            'test st'\n        \"\"\"\n        return self.string[self.pos:self.pos + length]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nundoing the last scan of the current record set.", "response": "def unscan(self):\n        \"\"\"\n        Undo the last scan, resetting the position and match registers.\n\n            >>> s = Scanner('test string')\n            >>> s.pos\n            0\n            >>> s.skip(r'te')\n            2\n            >>> s.rest\n            'st string'\n            >>> s.unscan()\n            >>> s.pos\n            0\n            >>> s.rest\n            'test string'\n        \"\"\"\n        self.pos_history.pop()\n        self._pos = self.pos_history[-1]\n        self.match_history.pop()\n        self._match = self.match_history[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scan_full(self, regex, return_string=True, advance_pointer=True):\n        regex = get_regex(regex)\n        self.match = regex.match(self.string, self.pos)\n        if not self.match:\n            return\n        if advance_pointer:\n            self.pos = self.match.end()\n        if return_string:\n            return self.match.group(0)\n        return len(self.match.group(0))", "response": "Scan the current position for a specific entry in the current string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search_full(self, regex, return_string=True, advance_pointer=True):\n        regex = get_regex(regex)\n        self.match = regex.search(self.string, self.pos)\n        if not self.match:\n            return\n        start_pos = self.pos\n        if advance_pointer:\n            self.pos = self.match.end()\n        if return_string:\n            return self.string[start_pos:self.match.end()]\n        return (self.match.end() - start_pos)", "response": "Search from the current position."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nscans the current position for a pattern from the current position.", "response": "def scan(self, regex):\n        \"\"\"\n        Match a pattern from the current position.\n\n        If a match is found, advances the scan pointer and returns the matched\n        string. Otherwise returns ``None``.\n\n            >>> s = Scanner(\"test string\")\n            >>> s.pos\n            0\n            >>> s.scan(r'foo')\n            >>> s.scan(r'bar')\n            >>> s.pos\n            0\n            >>> s.scan(r'test ')\n            'test '\n            >>> s.pos\n            5\n        \"\"\"\n        return self.scan_full(regex, return_string=True, advance_pointer=True)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scan_until(self, regex):\n        return self.search_full(regex, return_string=True, advance_pointer=True)", "response": "Scan the log file for a pattern from the current position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scan_upto(self, regex):\n        pos = self.pos\n        if self.scan_until(regex) is not None:\n            self.pos -= len(self.matched())\n            # Remove the intermediate position history entry.\n            self.pos_history.pop(-2)\n            return self.pre_match()[pos:]", "response": "Scan up to but not including the given regex."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nliking scan but return the number of characters matched.", "response": "def skip(self, regex):\n        \"\"\"\n        Like :meth:`scan`, but return the number of characters matched.\n\n            >>> s = Scanner(\"test string\")\n            >>> s.skip('test ')\n            5\n        \"\"\"\n        return self.scan_full(regex, return_string=False, advance_pointer=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef skip_until(self, regex):\n        return self.search_full(regex, return_string=False, advance_pointer=True)", "response": "Like scan_until but return the number of characters matched."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check(self, regex):\n        return self.scan_full(regex, return_string=True, advance_pointer=False)", "response": "See what : meth : scan would return without advancing the pointer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches the log file until a given regex is found.", "response": "def check_until(self, regex):\n        \"\"\"\n        See what :meth:`scan_until` would return without advancing the pointer.\n\n            >>> s = Scanner(\"test string\")\n            >>> s.check_until(' ')\n            'test '\n            >>> s.pos\n            0\n        \"\"\"\n        return self.search_full(regex, return_string=True, advance_pointer=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching for a pattern in the log file.", "response": "def exists(self, regex):\n        \"\"\"\n        See what :meth:`skip_until` would return without advancing the pointer.\n\n            >>> s = Scanner(\"test string\")\n            >>> s.exists(' ')\n            5\n            >>> s.pos\n            0\n\n        Returns the number of characters matched if it does exist, or ``None``\n        otherwise.\n        \"\"\"\n        return self.search_full(regex, return_string=False, advance_pointer=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef address_from_path(self, path=None):\n        path = path if path else self._unique_hierarchical_string()\n        return path, self.wallet.subkey_for_path(path).address()", "response": "Returns the path and leaf address of the HD wallet."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _unique_hierarchical_string(self):\n        t = datetime.now()\n        return '%s/%s/%s/%s/%s/%s/%s' % (t.year, t.month, t.day, t.hour,\n                                         t.minute, t.second, t.microsecond)", "response": "Returns a string representation of the time of the current in - memory cache entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(requirements):\n    transformer = RTransformer()\n    return map(transformer.transform, filter(None, map(_parse, requirements.splitlines())))", "response": "Parses given requirements line - by - line."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nauthenticate account if no password given tries to pre - authenticate.", "response": "def authenticate(self, transport, account_name, password):\n        \"\"\"\n        Authenticates account, if no password given tries to pre-authenticate.\n        @param transport: transport to use for method calls\n        @param account_name: account name\n        @param password: account password\n        @return: AuthToken if authentication succeeded\n        @raise AuthException: if authentication fails\n        \"\"\"\n        if not isinstance(transport, ZimbraClientTransport):\n            raise ZimbraClientException('Invalid transport')\n\n        if util.empty(account_name):\n            raise AuthException('Empty account name')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform Gillespie SSA simulations and returns trajectories for of each species in the problem.", "response": "def simulate_system(self, parameters, initial_conditions, timepoints,\n                        max_moment_order=1, number_of_processes=1):\n        \"\"\"\n        Perform Gillespie SSA simulations and returns trajectories for of each species.\n        Each trajectory is interpolated at the given time points.\n        By default, the average amounts of species for all simulations is returned.\n\n        :param parameters: list of the initial values for the constants in the model.\n                                  Must be in the same order as in the model\n        :param initial_conditions: List of the initial values for the equations in the problem.\n                        Must be in the same order as these equations occur.\n\n        :param timepoints: A list of time points to simulate the system for\n\n        :param number_of_processes: the number of parallel process to be run\n        :param max_moment_order: the highest moment order to calculate the trajectories to.\n                                 if set to zero, the individual trajectories will be returned, instead of\n                                 the averaged moments.\n        E.g. a value of one will return means, a values of two, means, variances and covariance and so on.\n\n\n        :return: a list of :class:`~means.simulation.Trajectory` one per species in the problem,\n            or a list of lists of trajectories (one per simulation) if `return_average == False`.\n        :rtype: list[:class:`~means.simulation.Trajectory`]\n        \"\"\"\n        max_moment_order = int(max_moment_order)\n        assert(max_moment_order >= 0)\n\n        n_simulations = self.__n_simulations\n        self._validate_parameters(parameters, initial_conditions)\n        t_max= max(timepoints)\n\n        substitution_pairs = dict(zip(self.__problem.parameters, parameters))\n        propensities = substitute_all(self.__problem.propensities, substitution_pairs)\n        # lambdify the propensities for fast evaluation\n        propensities_as_function = self.__problem.propensities_as_function\n        def f(*species_parameters):\n            return propensities_as_function(*(np.concatenate((species_parameters, parameters))))\n\n        population_rates_as_function = f\n\n        if not self.__random_seed:\n            seed_for_processes = [None] * n_simulations\n        else:\n            seed_for_processes = [i for i in range(self.__random_seed, n_simulations + self.__random_seed)]\n\n\n\n        if number_of_processes ==1:\n            ssa_generator = _SSAGenerator(population_rates_as_function,\n                                        self.__problem.change, self.__problem.species,\n                                        initial_conditions, t_max, seed=self.__random_seed)\n\n            results = map(ssa_generator.generate_single_simulation, seed_for_processes)\n\n\n        else:\n            p = multiprocessing.Pool(number_of_processes,\n                    initializer=multiprocessing_pool_initialiser,\n                    initargs=[population_rates_as_function, self.__problem.change,\n                              self.__problem.species,\n                              initial_conditions, t_max, self.__random_seed])\n\n            results = p.map(multiprocessing_apply_ssa, seed_for_processes)\n\n            p.close()\n            p.join()\n\n        resampled_results = [[traj.resample(timepoints, extrapolate=True) for traj in res] for res in results]\n        for i in resampled_results:\n            idx = len(i[0].values) - 1\n\n        if max_moment_order == 0:\n            # Return a list of TrajectoryCollection objects\n            return map(TrajectoryCollection, resampled_results)\n\n        moments = self._compute_moments(resampled_results, max_moment_order)\n        return TrajectoryCollection(moments)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a single simulation for the current state of the problem.", "response": "def generate_single_simulation(self, x):\n        \"\"\"\n        Generate a single SSA simulation\n        :param x: an integer to reset the random seed. If None, the initial random number generator is used\n        :return: a list of :class:`~means.simulation.Trajectory` one per species in the problem\n        :rtype: list[:class:`~means.simulation.Trajectory`]\n        \"\"\"\n        #reset random seed\n        if x:\n            self.__rng = np.random.RandomState(x)\n\n        # perform one stochastic simulation\n        time_points, species_over_time = self._gssa(self.__initial_conditions, self.__t_max)\n\n        # build descriptors for first order raw moments aka expectations (e.g. [1, 0, 0], [0, 1, 0] and [0, 0, 1])\n        descriptors = []\n        for i, s in enumerate(self.__species):\n            row = [0] * len(self.__species)\n            row[i] = 1\n            descriptors.append(Moment(row, s))\n\n        # build trajectories\n        trajectories = [Trajectory(time_points, spot, desc) for\n                        spot, desc in zip(species_over_time, descriptors)]\n\n        return trajectories"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild the requirements list for this project", "response": "def requirements():\n  \"\"\"Build the requirements list for this project\"\"\"\n  requirements_list = []\n  with open('requirements.txt') as requirements:\n    for install in requirements:\n      requirements_list.append(install.strip())\n  return requirements_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a http request to given URL and return the response.", "response": "def request(self, url, parameters):\n        \"\"\"Perform a http(s) request for given parameters to given URL\n\n            Keyword arguments:\n            url -- API url\n            parameters -- dict with payload.\n        \"\"\"\n\n        try:\n            request = Request(url + '?' + urlencode(parameters), None, {\n                'X-Authentication-Token': self.api_key,\n                'User-Agent': self.user_agent\n                },\n                None,\n                False,\n                \"GET\"\n            )\n\n            response = urlopen(request)\n        except HTTPError as e:\n            self.logger.error('Code: ' + str(e.code))\n            self.logger.error('Response: ' + str(e.reason))\n\n            if e.code == 400:\n                raise UnknownOutputFormatException()\n\n            if e.code == 401:\n                raise AuthorizationRequiredException()\n\n            if e.code == 402:\n                raise NotEnoughCreditsException()\n\n            if e.code == 403:\n                raise AccessDeniedException()\n\n            if e.code == 422:\n                raise InvalidMacOrOuiException()\n\n            if e.code >= 500:\n                raise ServerErrorException(\"Response code: {}\".format(e.code))\n\n            raise ServerErrorException(e.reason)\n\n        if response.code >= 300 or response.code < 200:\n            raise ServerErrorException(\"Response code: {}\".format(response.code))\n\n        headers = dict(response.getheaders())\n        if \"Warning\" in headers.keys():\n            self.logger.warning(headers[\"Warning\"])\n\n        self.logger.debug(response.info())\n\n        return response.read()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting self. sum self. avr and return sum of dice rolled count times.", "response": "def do_sum(self, count=1):\n        '''Set self.sum, self.avr and return sum of dice rolled, count times.\n        :param count: Number of rolls to make\n        :return: Total sum of all rolls\n        '''\n        if not self.roll.summable:\n            return 0\n        self.sum = sum(self.roll.roll(count))\n        self.avr = self.sum / count\n        return self.sum"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting self. bucket and return results.", "response": "def do_bucket(self, count=1):\n        '''Set self.bucket and return results.\n        :param count: Number of rolls to make\n        :return: List of tuples (total of roll, times it was rolled)\n        '''\n        self._bucket = dict()\n        for roll in self.roll.roll(count):\n            self._bucket[roll] = self._bucket.get(roll, 0) + 1\n        return self.bucket"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_run(self, count=1):\n        '''Roll count dice, store results. Does all stats so might be slower\n        than specific doFoo methods. But, it is proly faster than running\n        each of those seperately to get same stats.\n\n        Sets the following properties:\n          - stats.bucket\n          - stats.sum\n          - stats.avr\n\n        :param count: Number of rolls to make.\n        '''\n        if not self.roll.summable:\n            raise Exception('Roll is not summable')\n        h = dict()\n        total = 0\n        for roll in self.roll.x_rolls(count):\n            total += roll\n            h[roll] = h.get(roll, 0) + 1\n        self._bucket = h\n        self.sum = total\n        self.avr = total / count", "response": "Roll count dice store results. Does all stats so might be slower than specific doFoo methods."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a PDF of a given length.", "response": "def get_distr(center=0.0, stdev=default_stdev, length=50):\n    \"Returns a PDF of a given length. \"\n    # distr = np.random.random(length)\n\n    # sticking to normal distibution to easily control separability\n    distr = rng.normal(center, stdev, size=[length, 1])\n\n    return distr"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_random_histogram(center=0.0, stdev=default_stdev, length=default_feature_dim, num_bins=default_num_bins):\n    \"Returns a sequence of histogram density values that sum to 1.0\"\n\n    hist, bin_edges = np.histogram(get_distr(center, stdev, length),\n                                   range=edge_range, bins=num_bins, density=True)\n    # to ensure they sum to 1.0\n    hist = hist / sum(hist)\n\n    if len(hist) < 2:\n        raise ValueError('Invalid histogram')\n\n    return hist, bin_edges", "response": "Returns a sequence of histogram density values that sum to 1. 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pull(self, conf, ignore_missing=False):\n        with Builder().remove_replaced_images(conf):\n            self.push_or_pull(conf, \"pull\", ignore_missing=ignore_missing)", "response": "Push this image to the master"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef push_or_pull(self, conf, action=None, ignore_missing=False):\n        if action not in (\"push\", \"pull\"):\n            raise ProgrammerError(\"Should have called push_or_pull with action to either push or pull, got {0}\".format(action))\n\n        if not conf.image_index:\n            raise BadImage(\"Can't {0} without an image_index configuration\".format(action), image=conf.name)\n\n        if conf.image_name == \"scratch\":\n            log.warning(\"Not pulling/pushing scratch, this is a reserved image!\")\n            return\n\n        sync_stream = SyncProgressStream()\n\n        for attempt in range(3):\n            if attempt > 0:\n                log.info(\"Attempting sync again\\taction=%s\\tattempt=%d\", action, attempt)\n\n            # Login before pulling or pushing\n            # Have this in the for loop incase it fails and the push/pull also fails as a result\n            conf.login(conf.image_name, is_pushing=action=='push')\n\n            try:\n                for line in getattr(conf.harpoon.docker_api, action)(\n                        conf.image_name\n                        , tag = None if conf.tag is NotSpecified else conf.tag\n                        , stream = True\n                        ):\n\n                    for line in line.split(six.binary_type(\"\\r\\n\", \"utf-8\")):\n                        if not line:\n                            continue\n\n                        try:\n                            sync_stream.feed(line)\n                        except Failure as error:\n                            if ignore_missing and action == \"pull\":\n                                log.error(\"Failed to %s an image\\timage=%s\\timage_name=%s\\tmsg=%s\", action, conf.name, conf.image_name, error)\n                                break\n                            else:\n                                raise FailedImage(\"Failed to {0} an image\".format(action), image=conf.name, image_name=conf.image_name, msg=error)\n                        except Unknown as error:\n                            log.warning(\"Unknown line\\tline=%s\", error)\n\n                        for part in sync_stream.printable():\n                            if six.PY3:\n                                conf.harpoon.stdout.write(part)\n                            else:\n                                conf.harpoon.stdout.write(part.encode('utf-8', 'replace'))\n                        conf.harpoon.stdout.flush()\n\n                # And stop the loop!\n                break\n\n            except KeyboardInterrupt:\n                raise\n            except FailedImage as error:\n                log.exception(error)\n                if attempt == 2:\n                    raise", "response": "Push or pull this image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_grade_system_id(self, grade_system_id, match):\n        self._add_match('gradeSystemId', str(grade_system_id), bool(match))", "response": "Sets the grade system Id for this query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef releasers(cls):\n\n        return [\n            HookReleaser,\n            VersionFileReleaser,\n            PythonReleaser,\n            CocoaPodsReleaser,\n            NPMReleaser,\n            CReleaser,\n            ChangelogReleaser,\n            GitHubReleaser,\n            GitReleaser,\n        ]", "response": "Returns a list of all the supported releasers for the given class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all of the releasers that are compatible with the project.", "response": "def detected_releasers(cls, config):\n        \"\"\"\n        Returns all of the releasers that are compatible with the project.\n        \"\"\"\n\n        def get_config(releaser):\n            if config:\n                return config.get(releaser.config_name(), {})\n\n            return {}\n\n        releasers = []\n\n        for releaser_cls in cls.releasers():\n            releaser_config = get_config(releaser_cls)\n\n            if releaser_config.get('disabled', False):\n                continue\n\n            if releaser_cls.detect():\n                logger.info('Enabled Releaser: {}'.format(releaser_cls.name))\n                releasers.append(releaser_cls(releaser_config))\n\n        return releasers"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_version_consistency(self):\n\n        version = None\n        releaser_name = None\n\n        for releaser in self.releasers:\n            try:\n                next_version = releaser.determine_current_version()\n            except NotImplementedError:\n                continue\n\n            if next_version and version and version != next_version:\n                raise Exception('Inconsistent versions, {} is at {} but {} is at {}.'.format(\n                                releaser_name, version, releaser.name, next_version))\n\n            version = next_version\n            releaser_name = releaser.name", "response": "Checks if any releasers have inconsistent versions"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_aws_s3_handle(config_map):\n    url = 'https://' + config_map['s3_bucket'] + '.s3.amazonaws.com'\n    if not AWS_CLIENT.is_aws_s3_client_set():\n        client = boto3.client(\n            's3',\n            aws_access_key_id=config_map['put_public_key'],\n            aws_secret_access_key=config_map['put_private_key']\n        )\n        AWS_CLIENT.set_aws_s3_client(client)\n    else:\n        client = AWS_CLIENT.s3\n    return client, url", "response": "Returns a boto3 client and url for the AWS S3 object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_signed_url(url, config_map):\n    # From https://stackoverflow.com/a/34322915\n    def rsa_signer(message):\n        private_key = open(config_map['cloudfront_private_key_file'], 'r').read()\n        return rsa.sign(\n            message,\n            rsa.PrivateKey.load_pkcs1(private_key.encode('utf8')),\n            'SHA-1')  # CloudFront requires SHA-1 hash\n\n    if any(config_map[key] == '' for key in ['s3_bucket', 'cloudfront_distro',\n                                             'cloudfront_private_key_file', 'cloudfront_keypair_id']):\n        # This is a test configuration\n        return 'You are missing S3 and CF configs: https:///?Expires=X&Signature=X&Key-Pair-Id='\n\n    expires = datetime.datetime.utcnow() + datetime.timedelta(days=7)\n    s3_bucket = config_map['s3_bucket']\n\n    url = url.replace(s3_bucket + '.s3.amazonaws.com', config_map['cloudfront_distro'])\n\n    if not AWS_CLIENT.is_aws_cf_client_set():\n        cf_signer = CloudFrontSigner(\n            config_map['cloudfront_keypair_id'],\n            rsa_signer\n        )\n        AWS_CLIENT.set_aws_cf_client(cf_signer)\n    else:\n        cf_signer = AWS_CLIENT.cf\n    signed_url = cf_signer.generate_presigned_url(\n        url,\n        date_less_than=expires)\n    return signed_url", "response": "This function returns a signed URL given a saved URL and a configuration map."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_file(config_map, file_key):\n    # for boto3, need to remove any leading /\n    if file_key[0] == '/':\n        file_key = file_key[1::]\n    client = boto3.client(\n        's3',\n        aws_access_key_id=config_map['put_public_key'],\n        aws_secret_access_key=config_map['put_private_key']\n    )\n    client.delete_object(\n        Bucket=config_map['s3_bucket'],\n        Key=file_key\n    )", "response": "Convenience function for removing objects from AWS S3\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the grade system list resulting from the search.", "response": "def get_grade_systems(self):\n        \"\"\"Gets the grade system list resulting from the search.\n\n        return: (osid.grading.GradeSystemList) - the grade system list\n        raise:  IllegalState - list already retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.GradeSystemList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the package list resulting from the search.", "response": "def get_grade_entries(self):\n        \"\"\"Gets the package list resulting from the search.\n\n        return: (osid.grading.GradeEntryList) - the grade entry list\n        raise:  IllegalState - list already retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.GradeEntryList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the gradebook column list resulting from the search.", "response": "def get_gradebook_columns(self):\n        \"\"\"Gets the gradebook column list resulting from the search.\n\n        return: (osid.grading.GradebookColumnList) - the gradebook\n                column list\n        raise:  IllegalState - list already retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.GradebookColumnList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_gradebooks(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.GradebookList(self._results, runtime=self._runtime)", "response": "Gets the gradebook list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_next_object(self, object_class):\n        try:\n            next_object = OsidList.next(self)\n        except StopIteration:\n            raise\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        if isinstance(next_object, dict):\n            next_object = object_class(next_object)\n        return next_object", "response": "Get the next object from the list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the relationship lookup service.", "response": "def get_relationship_lookup_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the relationship lookup service.\n\n        return: (osid.relationship.RelationshipLookupSession) - a\n                ``RelationshipLookupSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_relationship_lookup()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if ``supports_relationship_lookup()``\n            is ``true``.*\n\n        \"\"\"\n        if not self.supports_relationship_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.RelationshipLookupSession(proxy=self._proxy,\n                                                         runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_relationship_lookup_session_for_family(self, family_id=None):\n        if not family_id:\n            raise NullArgument\n        if not self.supports_relationship_lookup():\n            raise Unimplemented()\n        ##\n        # Need to include check to see if the familyId is found otherwise raise NotFound\n        ##\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.RelationshipLookupSession(family_id,\n                                                         proxy=self._proxy,\n                                                         runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship lookup service for the given family."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_relationship_admin_session_for_family(self, family_id=None):\n        if not family_id:\n            raise NullArgument\n        if not self.supports_relationship_admin():\n            raise Unimplemented()\n        ##\n        # Need to include check to see if the familyId is found otherwise raise NotFound\n        ##\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.RelationshipAdminSession(family_id,\n                                                        proxy=self._proxy,\n                                                        runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship administration service for the given family."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the family lookup service.", "response": "def get_family_lookup_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the family lookup service.\n\n        return: (osid.relationship.FamilyLookupSession) - a\n                ``FamilyLookupSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_family_lookup()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if ``supports_family_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_family_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.FamilyLookupSession(proxy=self._proxy,\n                                                   runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_family_admin_session(self):\n        if not self.supports_family_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.FamilyAdminSession(proxy=self._proxy,\n                                                  runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the family administrative service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_relationship_lookup_session_for_family(self, family_id=None, proxy=None, *args, **kwargs):\n        if not family_id:\n            raise NullArgument\n        if not self.supports_relationship_lookup():\n            raise Unimplemented()\n        ##\n        # Need to include check to see if the familyId is found otherwise raise NotFound\n        ##\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipLookupSession(family_id, proxy=proxy, runtime=self._runtime, **kwargs)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship lookup service for the given family."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_relationship_query_session(self, proxy=None):\n        if not self.supports_relationship_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipQuerySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the relationship query service for the given family.", "response": "def get_relationship_query_session_for_family(self, family_id=None, proxy=None):\n        \"\"\"Gets the ``OsidSession`` associated with the relationship query service for the given family.\n\n        arg:    family_id (osid.id.Id): the ``Id`` of the family\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.relationship.RelationshipQuerySession) - a\n                ``RelationshipQuerySession``\n        raise:  NotFound - no ``Family`` found by the given ``Id``\n        raise:  NullArgument - ``family_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_relationship_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if ``supports_relationship_query()``\n            and ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not family_id:\n            raise NullArgument\n        if not self.supports_relationship_query():\n            raise Unimplemented()\n        ##\n        # Need to include check to see if the familyId is found otherwise raise NotFound\n        ##\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipQuerySession(family_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_relationship_search_session(self, proxy=None):\n        if not self.supports_relationship_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipSearchSession(proxy=proxy,\n                                                         runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship search service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_relationship_search_session_for_family(self, family_id=None, proxy=None):\n        if not family_id:\n            raise NullArgument\n        if not self.supports_relationship_search():\n            raise Unimplemented()\n        ##\n        # Need to include check to see if the familyId is found otherwise raise NotFound\n        ##\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipSearchSession(family_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship search service for the given family."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_relationship_admin_session(self, proxy=None):\n        if not self.supports_relationship_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipAdminSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the relationship administration service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the relationship administration service for the given family.", "response": "def get_relationship_admin_session_for_family(self, family_id=None, proxy=None, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the relationship administration service for the given family.\n\n        arg:    family_id (osid.id.Id): the ``Id`` of the family\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.relationship.RelationshipAdminSession) - a\n                ``RelationshipAdminSession``\n        raise:  NotFound - no ``Family`` found by the given ``Id``\n        raise:  NullArgument - ``family_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_relationship_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if ``supports_relationship_admin()``\n            and ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not family_id:\n            raise NullArgument\n        if not self.supports_relationship_admin():\n            raise Unimplemented()\n        ##\n        # Need to include check to see if the familyId is found otherwise raise NotFound\n        ##\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipAdminSession(family_id, proxy=proxy, runtime=self._runtime, **kwargs)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession to lookup relationship and family mappings.", "response": "def get_relationship_family_session(self, proxy=None):\n        \"\"\"Gets the ``OsidSession`` to lookup relationship/family mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.relationship.RelationshipFamilySession) - a\n                ``RelationshipFamilySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_relationship_family()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if ``supports_relationship_family()``\n            is ``true``.*\n\n        \"\"\"\n        if not self.supports_relationship_family():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipFamilySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_relationship_family_assignment_session(self, proxy=None):\n        if not self.supports_relationship_family_assignment():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.RelationshipFamilyAssignmentSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with assigning relationships to families."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the OsidSession associated with the family lookup service.", "response": "def get_family_lookup_session(self, proxy=None, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the family lookup service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.relationship.FamilyLookupSession) - a\n                ``FamilyLookupSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_family_lookup()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if ``supports_family_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_family_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.FamilyLookupSession(proxy=proxy, runtime=self._runtime, **kwargs)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_family_query_session(self, proxy=None):\n        if not self.supports_family_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.FamilyQuerySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the family query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_family_search_session(self, proxy=None):\n        if not self.supports_family_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.FamilySearchSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the family search service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the OsidSession associated with the family hierarchy service.", "response": "def get_family_hierarchy_session(self, proxy=None):\n        \"\"\"Gets the ``OsidSession`` associated with the family hierarchy service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.relationship.FamilyHierarchySession) - a\n                ``FamilyHierarchySession`` for families\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_family_hierarchy()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if ``supports_family_hierarchy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_family_hierarchy():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.FamilyHierarchySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the family hierarchy design service.", "response": "def get_family_hierarchy_design_session(self, proxy=None):\n        \"\"\"Gets the ``OsidSession`` associated with the family hierarchy design service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.relationship.FamilyHierarchyDesignSession) - a\n                ``HierarchyDesignSession`` for families\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_family_hierarchy_design()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if ``supports_family_hierarchy_design()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_family_hierarchy_design():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.FamilyHierarchyDesignSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the content of an asset", "response": "def _get_asset_content(self, asset_id, asset_content_type_str=None, asset_content_id=None):\n        \"\"\"stub\"\"\"\n        rm = self.my_osid_object._get_provider_manager('REPOSITORY')\n        if 'assignedBankIds' in self.my_osid_object._my_map:\n            if self.my_osid_object._proxy is not None:\n                als = rm.get_asset_lookup_session_for_repository(\n                    Id(self.my_osid_object._my_map['assignedBankIds'][0]),\n                    self.my_osid_object._proxy)\n            else:\n                als = rm.get_asset_lookup_session_for_repository(\n                    Id(self.my_osid_object._my_map['assignedBankIds'][0]))\n        elif 'assignedBookIds' in self.my_osid_object._my_map:\n            if self.my_osid_object._proxy is not None:\n                als = rm.get_asset_lookup_session_for_repository(\n                    Id(self.my_osid_object._my_map['assignedBookIds'][0]),\n                    self.my_osid_object._proxy)\n            else:\n                als = rm.get_asset_lookup_session_for_repository(\n                    Id(self.my_osid_object._my_map['assignedBookIds'][0]))\n        elif 'assignedRepositoryIds' in self.my_osid_object._my_map:\n            if self.my_osid_object._proxy is not None:\n                als = rm.get_asset_lookup_session_for_repository(\n                    Id(self.my_osid_object._my_map['assignedRepositoryIds'][0]),\n                    self.my_osid_object._proxy)\n            else:\n                als = rm.get_asset_lookup_session_for_repository(\n                    Id(self.my_osid_object._my_map['assignedRepositoryIds'][0]))\n        else:\n            raise KeyError\n\n        if asset_content_id is not None:\n            ac_list = als.get_asset(asset_id).get_asset_contents()\n            for ac in ac_list:\n                if str(ac.ident) == str(asset_content_id):\n                    return ac\n\n        if not asset_content_type_str:\n            return next(als.get_asset(asset_id).get_asset_contents())  # Just return first one\n        else:\n\n            if isinstance(asset_content_type_str, Type):\n                asset_content_type_str = str(asset_content_type_str)\n            for ac in als.get_asset(asset_id).get_asset_contents():\n                if ac.get_genus_type() == Type(asset_content_type_str):\n                    return ac\n        raise NotFound()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_asset(self,\n                   asset_data=None,\n                   asset_type=None,\n                   asset_content_type=None,\n                   asset_content_record_types=None,\n                   display_name='',\n                   description=''):\n        \"\"\"stub\"\"\"\n        # This method should be deprecated and its code added to the create_asset method:\n        rm = self.my_osid_object_form._get_provider_manager('REPOSITORY')\n        catalog_id = ''\n        try:\n            # for create forms\n            catalog_id = self.my_osid_object_form._catalog_id\n        except AttributeError:\n            # for update forms\n            if 'assignedBankIds' in self.my_osid_object_form._my_map:\n                catalog_id = Id(self.my_osid_object_form._my_map['assignedBankIds'][0])\n            elif 'assignedRepositoryIds' in self.my_osid_object_form._my_map:\n                catalog_id = Id(self.my_osid_object_form._my_map['assignedRepositoryIds'][0])\n\n        try:\n            aas = rm.get_asset_admin_session_for_repository(\n                catalog_id,\n                self.my_osid_object_form._proxy)\n        except (TypeError, NullArgument):  # not a ProxyManager, so don't pass it the proxy\n            aas = rm.get_asset_admin_session_for_repository(\n                catalog_id)\n        afc = aas.get_asset_form_for_create([])\n        if asset_type is not None:\n            afc.set_genus_type(asset_type)\n\n        afc.set_display_name(display_name)\n        afc.set_description(description)\n        asset_id = aas.create_asset(afc).get_id()\n        ac = None\n        if asset_data is not None:\n            asset_content_type_list = asset_content_record_types\n            if asset_content_type_list is None:\n                asset_content_type_list = []\n\n            try:\n                config = self.my_osid_object_form._runtime.get_configuration()\n                parameter_id = Id('parameter:assetContentRecordTypeForFiles@json')\n                asset_content_type_list.append(\n                    config.get_value_by_parameter(parameter_id).get_type_value())\n            except (AttributeError, KeyError, NotFound):\n                pass\n\n            acfc = aas.get_asset_content_form_for_create(asset_id,\n                                                         asset_content_type_list)\n            if asset_content_type is not None:\n                acfc.set_genus_type(asset_content_type)\n\n            acfc.set_data(asset_data)\n            ac = aas.create_asset_content(acfc)\n\n            # really stupid, but set the data again, because for filesystem impl\n            # the ID above will be off by one-ish -- we need it to match the\n            # AssetContent ID, so re-set it.\n            # have to set it above so that the filesystem adapter kicks in on update\n            # asset_data.seek(0)\n            # acfu = aas.get_asset_content_form_for_update(ac.ident)\n            # acfu.set_data(asset_data)\n            # ac = aas.update_asset_content(acfu)\n        if ac is not None:\n            return asset_id, ac.ident\n        else:\n            return asset_id, None", "response": "This method is deprecated and will be removed in the future."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an asset content to the list of available asset content records", "response": "def _add_asset_content(self,\n                           asset_id,\n                           asset_data=None,\n                           asset_url=None,\n                           asset_content_type=None,\n                           asset_label=None):\n        \"\"\"stub\"\"\"\n        rm = self.my_osid_object_form._get_provider_manager('REPOSITORY')\n        try:\n            # for create forms\n            catalog_id = self.my_osid_object_form._catalog_id\n        except AttributeError:\n            # for update forms\n            catalog_id = Id(self.my_osid_object_form._my_map['assignedBankIds'][0])\n\n        try:\n            aas = rm.get_asset_admin_session_for_repository(\n                catalog_id,\n                self.my_osid_object_form._proxy)\n        except (TypeError, NullArgument):  # not a ProxyManager, so don't pass it the proxy\n            aas = rm.get_asset_admin_session_for_repository(\n                catalog_id)\n\n        asset_content_type_list = []\n        try:\n            config = self.my_osid_object_form._runtime.get_configuration()\n            parameter_id = Id('parameter:assetContentRecordTypeForFiles@json')\n            asset_content_type_list.append(\n                config.get_value_by_parameter(parameter_id).get_type_value())\n        except (AttributeError, KeyError):\n            pass\n\n        acfc = aas.get_asset_content_form_for_create(asset_id,\n                                                     asset_content_type_list)\n        if asset_content_type is not None:\n            acfc.set_genus_type(asset_content_type)\n        if asset_label is not None:\n            acfc.display_name = str(asset_label)\n        if asset_data:\n            acfc.set_data(asset_data)\n        if asset_url:\n            acfc.set_url(asset_url)\n        ac = aas.create_asset_content(acfc)\n\n        return asset_id, ac.ident"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the creation time", "response": "def get_creation_time(self):\n        \"\"\"stub\"\"\"\n        ct = self.my_osid_object._my_map['creationTime']\n        return DateTime(ct.year,\n                        ct.month,\n                        ct.day,\n                        ct.hour,\n                        ct.minute,\n                        ct.second,\n                        ct.microsecond)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update_object_map(self, obj_map):\n        creation_time = obj_map['creationTime']\n        obj_map['creationTime'] = dict()\n        obj_map['creationTime']['year'] = creation_time.year\n        obj_map['creationTime']['month'] = creation_time.month\n        obj_map['creationTime']['day'] = creation_time.day\n        obj_map['creationTime']['hour'] = creation_time.hour\n        obj_map['creationTime']['minute'] = creation_time.minute\n        obj_map['creationTime']['second'] = creation_time.second\n        obj_map['creationTime']['microsecond'] = creation_time.microsecond", "response": "Update the object_map with the object_map values from the object_map."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _init_metadata(self):\n        self._provenance_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'provenanceId'),\n            'element_label': 'provenanceId',\n            'instructions': 'The item that \"gave birth\" to this item.',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [''],\n            'syntax': 'STRING',\n            'minimum_string_length': None,\n            'maximum_string_length': None,\n            'string_set': []\n        }", "response": "Initialize metadata for the item."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_provenance(self, provenance_id):\n        if not self.my_osid_object_form._is_valid_string(\n                provenance_id, self.get_provenance_metadata()):\n            raise InvalidArgument('provenanceId')\n        self.my_osid_object_form._my_map['provenanceId'] = provenance_id", "response": "set the provenance id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_metadata(self):\n        self._resource_id_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'resource_id'),\n            'element_label': 'Resource Id',\n            'instructions': 'accepts a valid OSID Id',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initialize metadata for resource id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the resource id", "response": "def set_resource_id(self, resource_id=None):\n        \"\"\"stub\"\"\"\n        if resource_id is None:\n            raise NullArgument()\n        if self.get_resource_id_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_id(\n                resource_id):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['resourceId'] = resource_id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_resource_id(self):\n        if (self.get_resource_id_metadata().is_read_only() or\n                self.get_resource_id_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['resourceId'] = \\\n            self.get_resource_id_metadata().get_default_id_values()[0]", "response": "clear the resource id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_text(self, text=None):\n        if text is None:\n            raise NullArgument()\n        if self.get_text_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_string(\n                text,\n                self.get_text_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['text']['text'] = text", "response": "set the text of the assessment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_metadata(self):\n        self._min_integer_value = None\n        self._max_integer_value = None\n        self._integer_value_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'integer_value'),\n            'element_label': 'Integer Value',\n            'instructions': 'enter an integer value',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_integer_values': [None],\n            'syntax': 'INTEGER',\n            'minimum_integer': self._min_integer_value,\n            'maximum_integer': self._max_integer_value,\n            'integer_set': []\n        }", "response": "Initialize metadata for the integer value field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the integer value", "response": "def set_integer_value(self, value=None):\n        \"\"\"stub\"\"\"\n        if value is None:\n            raise NullArgument()\n        if self.get_integer_value_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_integer(\n                value,\n                self.get_integer_value_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['integerValue'] = int(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_decimal_value(self, value=None):\n        if value is None:\n            raise NullArgument()\n        if self.get_decimal_value_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_decimal(\n                value,\n                self.get_decimal_value_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['decimalValue'] = float(value)", "response": "set the decimal value of the resource"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_metadata(self):\n        self._min_string_length = None\n        self._max_string_length = None\n        self._texts_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'texts'),\n            'element_label': 'Texts',\n            'instructions': 'enter text with optional label',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._text_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'text'),\n            'element_label': 'Text',\n            'instructions': 'enter a text string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }\n        self._label_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'label'),\n            'element_label': 'Label',\n            'instructions': 'enter a string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [str(ObjectId())],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 128,\n            'string_set': []\n        }", "response": "Initializes the metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_text(self, text, label=None):\n        if label is None:\n            label = self._label_metadata['default_string_values'][0]\n        else:\n            if not self.my_osid_object_form._is_valid_string(\n                    label, self.get_label_metadata()) or '.' in label:\n                raise InvalidArgument('label')\n        if text is None:\n            raise NullArgument('text cannot be none')\n        if not (self.my_osid_object_form._is_valid_string(\n                text, self.get_text_metadata()) or isinstance(text, DisplayText)):\n            raise InvalidArgument('text')\n        if utilities.is_string(text):\n            self.my_osid_object_form._my_map['texts'][label] = {\n                'text': text,\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE)\n            }\n        else:\n            self.my_osid_object_form._my_map['texts'][label] = {\n                'text': text.text,\n                'languageTypeId': str(text.language_type),\n                'scriptTypeId': str(text.script_type),\n                'formatTypeId': str(text.format_type)\n            }", "response": "add a text to the language"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the text with the given label", "response": "def clear_text(self, label):\n        \"\"\"stub\"\"\"\n        if label not in self.my_osid_object_form._my_map['texts']:\n            raise NotFound()\n        del self.my_osid_object_form._my_map['texts'][label]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the metadata for the object store.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._min_integer_value = None\n        self._max_integer_value = None\n        self._integer_values_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'integer_values'),\n            'element_label': 'Integer Values',\n            'instructions': 'enter integer values with optional labels',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._integer_value_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'integer_value'),\n            'element_label': 'Integer Value',\n            'instructions': 'enter an integer value',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_integer_value': [None],\n            'syntax': 'INTEGER',\n            'minimum_integer': self._min_integer_value,\n            'maximum_integer': self._max_integer_value,\n            'integer_set': []\n        }\n        self._label_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'label'),\n            'element_label': 'Label',\n            'instructions': 'enter a string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [str(ObjectId())],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 128,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an integer value to the entry", "response": "def add_integer_value(self, value, label=None):\n        \"\"\"stub\"\"\"\n        if value is None:\n            raise NullArgument('value cannot be None')\n        if label is None:\n            label = self._label_metadata['default_string_values'][0]\n        else:\n            if not self.my_osid_object_form._is_valid_string(\n                    label, self.get_label_metadata()) or '.' in label:\n                raise InvalidArgument('label')\n        if not self.my_osid_object_form._is_valid_integer(\n                value, self.get_integer_value_metadata()):\n            raise InvalidArgument('value')\n        self.my_osid_object_form._my_map['integerValues'][label] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the metadata for the object store.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._min_decimal_value = None\n        self._max_decimal_value = None\n        self._decimal_values_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'decimal_values'),\n            'element_label': 'Decimal Values',\n            'instructions': 'enter decimal values with optional labels',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._decimal_value_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'decimal_value'),\n            'element_label': 'Decimal Value',\n            'instructions': 'enter a decimal value',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None, 0.0],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': self._min_decimal_value,\n            'maximum_decimal': self._max_decimal_value,\n            'decimal_set': []\n        }\n        self._label_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'label'),\n            'element_label': 'Label',\n            'instructions': 'enter a string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [str(ObjectId())],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 128,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_decimal_value(self, value, label=None):\n        if label is None:\n            label = self._label_metadata['default_string_values'][0]\n        else:\n            if not self.my_osid_object_form._is_valid_string(\n                    label, self.get_label_metadata()) or '.' in label:\n                raise InvalidArgument('label')\n        if value is None:\n            raise NullArgument('value cannot be None')\n        if not self.my_osid_object_form._is_valid_decimal(\n                value, self.get_decimal_value_metadata()):\n            raise InvalidArgument('value')\n        self.my_osid_object_form._my_map['decimalValues'][label] = value", "response": "add a decimal value to the entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the map with the default values.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        self.my_osid_object_form._my_map['attempts'] = \\\n            int(self._attempts_metadata['default_object_values'][0])\n        self.my_osid_object_form._my_map['weight'] = \\\n            float(self._weight_metadata['default_object_values'][0])\n        # self.my_osid_object_form._my_map['rerandomize'] = \\\n        #     self._rerandomize_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['showanswer'] = \\\n            str(self._showanswer_metadata['default_object_values'][0])\n        self.my_osid_object_form._my_map['markdown'] = \\\n            str(self._markdown_metadata['default_object_values'][0])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the metadata for the student object.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._attempts_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'attempts'),\n            'element_label': 'Attempts',\n            'instructions': 'Max number of student attempts',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [0],\n            'syntax': 'INTEGER',\n            'object_set': [],\n            'minimum_integer': None,\n            'maximum_integer': None,\n            'integer_set': []\n        }\n        self._weight_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'weight'),\n            'element_label': 'Weight',\n            'instructions': 'Weight of the item when calculating grades',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [1.0],\n            'syntax': 'DECIMAL',\n            'object_set': [],\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': []\n        }\n        # self._rerandomize_metadata = {\n        #     'element_id': Id(self.my_osid_object_form._authority,\n        #                      self.my_osid_object_form._namespace,\n        #                      'rerandomize'),\n        #     'element_label': 'Randomize',\n        #     'instructions': 'How to rerandomize the parameters',\n        #     'required': False,\n        #     'read_only': False,\n        #     'linked': False,\n        #     'array': False,\n        #     'default_object_values': ['never'],\n        #     'syntax': 'STRING',\n        #     'minimum_string_length': None,\n        #     'maximum_string_length': None,\n        #     'string_set': []\n        # }\n        self._showanswer_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'showanswer'),\n            'element_label': 'Show answer',\n            'instructions': 'When to show the answer to the student',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': ['closed'],\n            'syntax': 'STRING',\n            'minimum_string_length': None,\n            'maximum_string_length': None,\n            'string_set': []\n        }\n        self._markdown_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'markdown'),\n            'element_label': 'Studio markdown',\n            'instructions': 'Studio markdown representation of the problem',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [''],\n            'syntax': 'STRING',\n            'minimum_string_length': None,\n            'maximum_string_length': None,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new attempt", "response": "def add_attempts(self, attempts):\n        \"\"\"stub\"\"\"\n        if attempts is None:\n            raise NullArgument('attempts cannot be None')\n        if not self.my_osid_object_form._is_valid_integer(\n                attempts, self.get_attempts_metadata()):\n            raise InvalidArgument('attempts')\n        self.my_osid_object_form._my_map['attempts'] = attempts"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_weight(self, weight):\n        if weight is None:\n            raise NullArgument('weight cannot be None')\n        if not self.my_osid_object_form._is_valid_decimal(\n                weight, self.get_weight_metadata()):\n            raise InvalidArgument('weight')\n        self.my_osid_object_form._my_map['weight'] = weight", "response": "add a weight to the entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_markdown(self, markdown):\n        if markdown is None:\n            raise NullArgument('markdown cannot be None')\n        if not self.my_osid_object_form._is_valid_string(\n                markdown, self.get_markdown_metadata()):\n            raise InvalidArgument('markdown')\n        self.my_osid_object_form._my_map['markdown'] = markdown", "response": "add a markdown to the entry"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the time as a string", "response": "def get_time_as_string(self):\n        \"\"\"stub\"\"\"\n        if self.has_time():\n            return (str(self.time['hours']).zfill(2) + ':' +\n                    str(self.time['minutes']).zfill(2) + ':' +\n                    str(self.time['seconds']).zfill(2))\n        raise IllegalState()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_metadata(self):\n        self._min_time_value = None\n        self._max_time_value = None\n        self._time_value_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'time_value'),\n            'element_label': 'Time Value',\n            'instructions': 'enter a time duration string / duration',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_duration_values': [{\n                'hours': 0,\n                'minutes': 0,\n                'seconds': 0\n            }],\n            'syntax': 'DURATION',\n            'minimum_time': self._min_time_value,\n            'maximum_time': self._max_time_value\n        }", "response": "Initialize the metadata for the time value field."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a duration object to a dictionary of HHMMSS values.", "response": "def _convert_duration_to_hhmmss(self, duration):\n        \"\"\"stub\"\"\"\n        time_secs = duration.seconds\n        min_, sec = divmod(time_secs, 60)\n        hour, min_ = divmod(min_, 60)\n        results = {\n            'hours': hour,\n            'minutes': min_,\n            'seconds': sec\n        }\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_string_to_hhmmss(self, string):\n        # assume input string is 'hh:mm:ss'\n        components = string.split(':')\n        if len(components) != 3:\n            raise InvalidArgument('time input string must be hh:mm:ss format')\n        return {\n            'hours': int(components[0]),\n            'minutes': int(components[1]),\n            'seconds': int(components[2])\n        }", "response": "converts string to hhmmss format"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the time value", "response": "def set_time_value(self, value=None):\n        \"\"\"stub\"\"\"\n        if value is None:\n            raise NullArgument()\n        if self.get_time_value_metadata().is_read_only():\n            raise NoAccess()\n        if self.my_osid_object_form._is_valid_duration(\n                value,\n                self.get_time_value_metadata()):\n            # http://stackoverflow.com/questions/775049/python-time-seconds-to-hms\n            time = self._convert_duration_to_hhmmss(value)\n        elif utilities.is_string(value):\n            # assume something like hh:mm:ss, convert to dict\n            time = self._convert_string_to_hhmmss(value)\n        else:\n            raise InvalidArgument('value must be a string or duration')\n        self.my_osid_object_form._my_map['timeValue'] = {\n            'hours': time['hours'],\n            'minutes': time['minutes'],\n            'seconds': time['seconds']\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_files(self):\n        # I had to add the following check because file record types\n        # don't seem to be implemented\n        # correctly for raw edx Question objects\n        if 'fileIds' not in self.my_osid_object._my_map:\n            return False\n        return bool(self.my_osid_object._my_map['fileIds'])", "response": "returns true if the file record types are set"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the files map", "response": "def get_files_map(self):\n        \"\"\"stub\"\"\"\n        files_map = {}\n        if self.has_files():\n            for label in self.my_osid_object._my_map['fileIds']:\n                asset_content = self._get_asset_content(\n                    Id(self.my_osid_object._my_map['fileIds'][label]['assetId']),\n                    Type(self.my_osid_object._my_map['fileIds'][label]['assetContentTypeId']))\n                try:\n                    files_map[label] = asset_content._my_map['base64']\n                except KeyError:\n                    files_map[label] = base64.b64encode(asset_content.get_data().read())\n            return files_map\n        raise IllegalState('no files_map')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the file urls map", "response": "def get_file_urls_map(self):\n        \"\"\"stub\"\"\"\n        file_urls_map = {}\n        if self.has_files():\n            for label in self.my_osid_object._my_map['fileIds']:\n                label_map = self.my_osid_object._my_map['fileIds'][label]\n                if 'assetContentId' in label_map and bool(label_map['assetContentId']):\n                    asset_content = self._get_asset_content(\n                        Id(label_map['assetId']),\n                        asset_content_id=Id(label_map['assetContentId']))\n                else:\n                    asset_content = self._get_asset_content(\n                        Id(label_map['assetId']),\n                        asset_content_type_str=label_map['assetContentTypeId'])\n                file_urls_map[label] = asset_content.get_url()\n            return file_urls_map\n        raise IllegalState('no files_map')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_asset_ids(self):\n        asset_ids = []\n        for f in self.my_osid_object._my_map['fileIds']:\n            asset_ids.append(Id(self.my_osid_object._my_map['fileIds'][f]['assetId']))\n        return IdList(asset_ids)", "response": "get the asset ids"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the asset ids map", "response": "def get_asset_ids_map(self):\n        \"\"\"stub\"\"\"\n        asset_ids_map = {}\n        for label, asset_obj in self.my_osid_object._my_map['fileIds'].items():\n            asset_ids_map[label] = asset_obj\n        return asset_ids_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_asset_id_by_label(self, label):\n        if self.has_file(label):\n            return Id(self.my_osid_object._my_map['fileIds'][label]['assetId'])\n        raise IllegalState()", "response": "get the asset id by label"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file_by_label(self, label, asset_content_type=None):\n        return self._get_asset_content(self.get_asset_id_by_label(label), asset_content_type).get_data()", "response": "get file by label"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_url_by_label(self, label, asset_content_type=None):\n        return self._get_asset_content(self.get_asset_id_by_label(label)).get_url()", "response": "get url by label"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the object map with the object_map", "response": "def _update_object_map(self, obj_map):\n        \"\"\"loop through all the keys in self.my_osid_object._my_map, and\n        see if any of them contain text like \"AssetContent:<label>\"\n        If so, assume it is markup (?), replace the string with asset_content.get_url()\"\"\"\n        # TODO: Look for <img> tags to add in alt-text and description\n        # TODO: Look for <video> and <audio> tags to add in description, transcripts and vtt files?\n        try:\n            super(FilesRecord, self)._update_object_map(obj_map)\n        except AttributeError:\n            pass\n\n        bypass_asset_content_authorization = False\n        acls = None\n\n        try:\n            config = self.my_osid_object._runtime.get_configuration()\n            parameter_id = Id('parameter:bypassAuthorizationForFilesRecordAssetContentLookup@json')\n            bypass_asset_content_authorization = config.get_value_by_parameter(parameter_id).get_boolean_value()\n        except (AttributeError, KeyError, NotFound):\n            pass\n\n        def replace_url_in_display_text(potential_display_text, dict_files_map):\n            if ('text' in potential_display_text and\n                    potential_display_text['text'] is not None and\n                    'AssetContent' in potential_display_text['text']):\n                # assume markup? Wrap this in case it's not a valid XML doc\n                # with a single parent object\n                wrapped_text = '<wrapper>{0}</wrapper'.format(potential_display_text['text'])\n                soup = BeautifulSoup(wrapped_text, 'xml')\n                media_file_elements = soup.find_all(src=media_regex)\n                media_file_elements += soup.find_all(data=media_regex)\n                for media_file_element in media_file_elements:\n                    if 'src' in media_file_element.attrs:\n                        media_key = 'src'\n                    else:\n                        media_key = 'data'\n                    if ':' not in media_file_element[media_key]:\n                        continue\n\n                    media_label = media_file_element[media_key].split(':')[-1]\n\n                    if media_label in dict_files_map:\n                        asset_id = Id(dict_files_map[media_label]['assetId'])\n                        ac_id = Id(dict_files_map[media_label]['assetContentId'])\n                        if bypass_asset_content_authorization:\n                            ac = acls.get_asset_content(ac_id)\n                        else:\n                            ac = self._get_asset_content(asset_id=asset_id, asset_content_id=ac_id)\n\n                        if media_file_element.name == 'track':\n                            try:\n                                if not ac.has_files():\n                                    continue\n                            except AttributeError:\n                                # non-multi-language VTT files\n                                media_file_element[media_key] = ac.get_url()\n                            else:\n                                media_file_element[media_key] = ac.get_url()\n                                media_file_element['srclang'] = ac.get_vtt_locale_identifier().lower()[0:2]\n                                media_file_element['label'] = ac.get_vtt_locale_label()\n                        elif media_file_element.name == 'transcript':\n                            if not ac.has_files():\n                                continue\n                            transcript_template_path = '{0}/osid/transcript_template.xml'.format(ABS_PATH)\n                            with codecs.open(transcript_template_path, 'r', encoding='utf-8') as template_file:\n                                template = template_file.read().format(media_label,\n                                                                       ac.get_transcript_locale_label().lower(),\n                                                                       ac.get_transcript_locale_label().title(),\n                                                                       ac.get_transcript_text())\n                                new_template_tag = BeautifulSoup(template, 'xml').div\n                                # media_file_element.replace_with(new_template_tag)\n                                p_parent = None\n                                for parent in media_file_element.parents:\n                                    if parent is not None and parent.name != 'p':\n                                        # insert the transcript after the top p tag\n                                        # so that we don't create invalid HTML by nesting\n                                        # <div> and <aside> inside of a <p> tag\n                                        p_parent.insert_after(new_template_tag)\n                                        break\n                                    p_parent = parent\n                                media_file_element.extract()\n                        else:\n                            media_file_element[media_key] = ac.get_url()\n\n                    # check for alt-tags\n                    if 'alt' in media_file_element.attrs:\n                        alt_tag_label = media_file_element['alt'].split(':')[-1]\n                        if alt_tag_label in dict_files_map:\n                            asset_id = Id(dict_files_map[alt_tag_label]['assetId'])\n                            ac_id = Id(dict_files_map[alt_tag_label]['assetContentId'])\n                            if bypass_asset_content_authorization:\n                                ac = acls.get_asset_content(ac_id)\n                            else:\n                                ac = self._get_asset_content(asset_id=asset_id, asset_content_id=ac_id)\n                            try:\n                                media_file_element['alt'] = ac.get_alt_text().text\n                            except AttributeError:\n                                pass\n\n                potential_display_text['text'] = soup.wrapper.renderContents().decode('utf-8')\n            else:\n                for new_key, value in potential_display_text.items():\n                    if isinstance(value, list):\n                        new_files_map = dict_files_map\n                        if 'fileIds' in potential_display_text:\n                            new_files_map = potential_display_text['fileIds']\n                        potential_display_text[new_key] = check_list_children(value, new_files_map)\n            return potential_display_text\n\n        def check_list_children(potential_text_list, list_files_map):\n            updated_list = []\n            for child in potential_text_list:\n                if isinstance(child, dict):\n                    files_map = list_files_map\n                    if 'fileIds' in child:\n                        files_map = child['fileIds']\n                    updated_list.append(replace_url_in_display_text(child, files_map))\n                elif isinstance(child, list):\n                    updated_list.append(check_list_children(child, list_files_map))\n                else:\n                    updated_list.append(child)\n            return updated_list\n\n        if bypass_asset_content_authorization:\n            # One assumption is that the object's catalogId can be used\n            # as the repositoryId\n            manager = self.my_osid_object._get_provider_manager('REPOSITORY')\n\n            try:\n                if self.my_osid_object._proxy is not None:\n                    acls = manager.get_asset_content_lookup_session(proxy=self.my_osid_object._proxy)\n                else:\n                    acls = manager.get_asset_content_lookup_session()\n            except AttributeError:\n                pass\n            else:\n                acls.use_federated_repository_view()\n\n        media_regex = re.compile('(AssetContent:)')\n        original_files_map = {}\n        if 'fileIds' in obj_map:\n            original_files_map = obj_map['fileIds']\n\n        for key, data in obj_map.items():\n            if isinstance(data, dict):\n                obj_map[key] = replace_url_in_display_text(data, original_files_map)\n            elif isinstance(data, list):\n                obj_map[key] = check_list_children(data, original_files_map)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the metadata for the object", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._files_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'files'),\n            'element_label': 'Files',\n            'instructions': 'enter a file id with optional label',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._file_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'file'),\n            'element_label': 'File',\n            'instructions': 'accepts an Asset Id',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }\n        self._label_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'label'),\n            'element_label': 'Label',\n            'instructions': 'enter a string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [str(ObjectId())],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 128,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_asset(self, asset_id, asset_content_id=None, label=None, asset_content_type=None):\n        if asset_id is None:\n            raise NullArgument('asset_id cannot be None')\n        if not isinstance(asset_id, Id):\n            raise InvalidArgument('asset_id must be an Id instance')\n        if asset_content_id is not None and not isinstance(asset_content_id, Id):\n            raise InvalidArgument('asset_content_id must be an Id instance')\n        if asset_content_type is not None and not isinstance(asset_content_type, Type):\n            raise InvalidArgument('asset_content_type must be a Type instance')\n        if label is None:\n            label = self._label_metadata['default_string_values'][0]\n        else:\n            if not self.my_osid_object_form._is_valid_string(\n                    label, self.get_label_metadata()) or '.' in label:\n                raise InvalidArgument('label')\n        if asset_content_type is None:\n            asset_content_type = ''\n\n        self.my_osid_object_form._my_map['fileIds'][label] = {\n            'assetId': str(asset_id),\n            'assetContentTypeId': str(asset_content_type)\n        }\n\n        if asset_content_id is not None:\n            self.my_osid_object_form._my_map['fileIds'][label].update({\n                'assetContentId': str(asset_content_id)\n            })", "response": "add an asset to the archive"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a file to the archive", "response": "def add_file(self,\n                 asset_data,\n                 label=None,\n                 asset_type=None,\n                 asset_content_type=None,\n                 asset_content_record_types=None,\n                 asset_name='',\n                 asset_description=''):\n        \"\"\"stub\"\"\"\n        if asset_data is None:\n            raise NullArgument('asset_data cannot be None')\n        if not isinstance(asset_data, DataInputStream):\n            raise InvalidArgument('asset_data must be instance of DataInputStream')\n        if asset_type is not None and not isinstance(asset_type, Type):\n            raise InvalidArgument('asset_type must be an instance of Type')\n        if asset_content_type is not None and not isinstance(asset_content_type, Type):\n            raise InvalidArgument('asset_content_type must be an instance of Type')\n        if asset_content_record_types is not None and not isinstance(asset_content_record_types, list):\n            raise InvalidArgument('asset_content_record_types must be an instance of list')\n        if asset_content_record_types is not None:\n            for record_type in asset_content_record_types:\n                if not isinstance(record_type, Type):\n                    raise InvalidArgument('non-Type present in asset_content_record_types')\n\n        if label is None:\n            label = self._label_metadata['default_string_values'][0]\n        else:\n            if not self.my_osid_object_form._is_valid_string(\n                    label, self.get_label_metadata()) or '.' in label:\n                raise InvalidArgument('label')\n\n        asset_id, asset_content_id = self.create_asset(asset_data=asset_data,\n                                                       asset_type=asset_type,\n                                                       asset_content_type=asset_content_type,\n                                                       asset_content_record_types=asset_content_record_types,\n                                                       display_name=asset_name,\n                                                       description=asset_description)\n        self.add_asset(asset_id,\n                       asset_content_id,\n                       label,\n                       asset_content_type)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn true if the file has a url", "response": "def has_file_url(self):\n        \"\"\"stub\"\"\"\n        return bool(self._get_asset_content(\n            Id(self.my_osid_object._my_map['fileId']['assetId']),\n            self.my_osid_object._my_map['fileId']['assetContentTypeId']).has_url())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_file_url(self):\n        if self.has_file_url():\n            return self._get_asset_content(\n                Id(self.my_osid_object._my_map['fileId']['assetId']),\n                self.my_osid_object._my_map['fileId']['assetContentTypeId']).get_url()\n        raise IllegalState()", "response": "get the url of the file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_file(self):\n        if self.has_file_asset():\n            return self._get_asset_content(\n                Id(self.my_osid_object._my_map['fileId']['assetId']),\n                self.my_osid_object._my_map['fileId']['assetContentTypeId']).get_data()\n        raise IllegalState()", "response": "get the file content"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the metadata for the file", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._file_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'file'),\n            'element_label': 'File',\n            'instructions': 'accepts an asset id and optional asset_content type',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_file(self,\n                 asset_data=None,\n                 asset_type=None,\n                 asset_content_type=None,\n                 asset_name='',\n                 asset_description=''):\n        \"\"\"stub\"\"\"\n        if asset_data is None:\n            raise NullArgument()\n        if not isinstance(asset_data, DataInputStream):\n            raise InvalidArgument('asset_data must be instance of DataInputStream')\n        if asset_type is not None and not isinstance(asset_type, Type):\n            raise InvalidArgument('asset_type must be instance of Type')\n        if asset_content_type is not None and not isinstance(asset_content_type, Type):\n            raise InvalidArgument('asset_content_type must be instance of Type')\n\n        asset_id, asset_content_id = self.create_asset(asset_data=asset_data,\n                                                       asset_type=asset_type,\n                                                       asset_content_type=asset_content_type,\n                                                       display_name=asset_name,\n                                                       description=asset_description)\n        self.set_asset(asset_id,\n                       asset_content_type)", "response": "set_file - Set the file for this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate object map with the color coordinate information.", "response": "def _update_object_map(self, obj_map):\n        \"\"\"stub\"\"\"\n        if self.has_color_coordinate() and \\\n                self.get_color_coordinate().get_coordinate_type() == RGB_COLOR_COORDINATE:\n            obj_map['colorCoordinate']['hexValue'] = str(self.get_color_coordinate())\n        try:\n            super(ColorCoordinateRecord, self)._update_object_map(obj_map)\n        except AttributeError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_metadata(self):\n        self._min_decimal_value = None\n        self._max_decimal_value = None\n        self._color_coordinate_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'color_coordinate'),\n            'element_label': 'Color Coordinate',\n            'instructions': 'enter a color coordinate',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_coordinate_values': [{}],\n            'syntax': 'COORDINATE',\n            'coordinate_set': []\n        }", "response": "Initialize metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the color coordinate", "response": "def set_color_coordinate(self, coordinate=None):\n        \"\"\"stub\"\"\"\n        if coordinate is None:\n            raise NullArgument()\n        if self.get_color_coordinate_metadata().is_read_only():\n            raise NoAccess()\n        if not isinstance(coordinate, RGBColorCoordinate):\n            raise InvalidArgument('coordinate must be instance of RGBColorCoordinate')\n        self.my_osid_object_form._my_map['colorCoordinate']['values'] = \\\n            coordinate.get_values()\n        self.my_osid_object_form._my_map['colorCoordinate']['uncertaintyPlus'] = \\\n            coordinate.get_uncertainty_plus()\n        self.my_osid_object_form._my_map['colorCoordinate']['uncertaintyMinus'] = \\\n            coordinate.get_uncertainty_minus()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the metadata for the start date", "response": "def get_start_date_metadata(self):\n        \"\"\"Gets the metadata for a start date.\n\n        return: (osid.Metadata) - metadata for the date\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._start_date_metadata)\n        metadata.update({'existing_date_time_values': self.my_osid_object_form._my_map['startDate']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the start date.", "response": "def set_start_date(self, date):\n        \"\"\"Sets the start date.\n\n        arg:    date (osid.calendaring.DateTime): the new date\n        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if date is None:\n            raise NullArgument('date cannot be None')\n        if self.get_start_date_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_date_time(date, self.get_start_date_metadata()):\n            raise InvalidArgument('date must be instance of DateTime')\n        self.my_osid_object_form._my_map['startDate'] = date"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the start date.", "response": "def clear_start_date(self):\n        \"\"\"Clears the start date.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_start_date_metadata().is_read_only() or\n                self.get_start_date_metadata().is_required()):\n            raise NoAccess()\n        default_start_date = self._start_date_metadata['default_date_time_values'][0]\n        self.my_osid_object_form._my_map['startDate'] = DateTime(year=default_start_date.year,\n                                                                 month=default_start_date.month,\n                                                                 day=default_start_date.day,\n                                                                 hour=default_start_date.hour,\n                                                                 minute=default_start_date.minute,\n                                                                 second=default_start_date.second,\n                                                                 microsecond=default_start_date.microsecond)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_end_date_metadata(self):\n        metadata = dict(self._end_date_metadata)\n        metadata.update({'existing_date_time_values': self.my_osid_object_form._my_map['endDate']})\n        return Metadata(**metadata)", "response": "Gets the metadata for an end date"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_end_date(self, date):\n        if date is None:\n            raise NullArgument('date cannot be None')\n        if self.get_end_date_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_date_time(date, self.get_end_date_metadata()):\n            raise InvalidArgument('date must be instance of DateTime')\n        self.my_osid_object_form._my_map['endDate'] = date", "response": "Sets the end date."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclears the end date.", "response": "def clear_end_date(self):\n        \"\"\"Clears the end date.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_end_date_metadata().is_read_only() or\n                self.get_end_date_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['endDate'] = \\\n            DateTime(**self._end_date_metadata['default_date_time_values'][0])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_end_date(self):\n        edate = self.my_osid_object._my_map['endDate']\n        return DateTime(\n            edate.year,\n            edate.month,\n            edate.day,\n            edate.hour,\n            edate.minute,\n            edate.second,\n            edate.microsecond)", "response": "Gets the end date of the assessment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_provider_metadata(self):\n        metadata = dict(self._provider_metadata)\n        metadata.update({'existing_id_values': self.my_osid_object_form._my_map['providerId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a provider"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting a provider. arg: provider_id (osid.id.Id): the new provider raise: InvalidArgument - ``provider_id`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``provider_id`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_provider(self, provider_id):\n        \"\"\"Sets a provider.\n\n        arg:    provider_id (osid.id.Id): the new provider\n        raise:  InvalidArgument - ``provider_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``provider_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if provider_id is None:\n            raise NullArgument('provider_id cannot be None')\n        if self.get_provider_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_id(provider_id):\n            raise InvalidArgument('provider_id must be instance of Id')\n        self.my_osid_object_form._my_map['providerId'] = str(provider_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the metadata for the asset branding.", "response": "def get_branding_metadata(self):\n        \"\"\"Gets the metadata for the asset branding.\n\n        return: (osid.Metadata) - metadata for the asset branding.\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._branding_metadata)\n        metadata.update({'existing_id_values': self.my_osid_object_form._my_map['brandingIds']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the branding. arg: asset_ids (osid.id.Id[]): the new assets raise: InvalidArgument - ``asset_ids`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``asset_ids`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_branding(self, asset_ids):\n        \"\"\"Sets the branding.\n\n        arg:    asset_ids (osid.id.Id[]): the new assets\n        raise:  InvalidArgument - ``asset_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``asset_ids`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if asset_ids is None:\n            raise NullArgument('asset_ids cannot be None')\n        if self.get_branding_metadata().is_read_only():\n            raise NoAccess()\n        if not isinstance(asset_ids, list):\n            raise InvalidArgument('asset_ids must be a list')\n        if not self.my_osid_object_form._is_valid_input(asset_ids,\n                                                        self.get_branding_metadata(),\n                                                        array=True):\n            raise InvalidArgument()\n        branding_ids = []\n        for asset_id in asset_ids:\n            branding_ids.append(str(asset_id))\n        self.my_osid_object_form._my_map['brandingIds'] = branding_ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_branding(self):\n        if (self.get_branding_metadata().is_read_only() or\n                self.get_branding_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['brandingIds'] = self._branding_default", "response": "Removes the branding.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the metadata for the license", "response": "def get_license_metadata(self):\n        \"\"\"Gets the metadata for the license.\n\n        return: (osid.Metadata) - metadata for the license\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._license_metadata)\n        metadata.update({'existing_string_values': self.my_osid_object_form._my_map['license']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_license(self, license_):\n        if license_ is None:\n            raise NullArgument('license cannot be None')\n        if not utilities.is_string(license_):\n            raise InvalidArgument('license must be a string')\n        if self.get_license_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_string(license_, self.get_license_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['license']['text'] = license_", "response": "Sets the license.\n\n        arg:    license (string): the new license\n        raise:  InvalidArgument - ``license`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``license`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_provider_id(self):\n        if ('providerId' not in self.my_osid_object._my_map or\n                not self.my_osid_object._my_map['providerId']):\n            raise IllegalState('this sourceable object has no provider set')\n        return Id(self.my_osid_object._my_map['providerId'])", "response": "Gets the Id of the provider."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_branding_ids(self):\n        if 'brandingIds' not in self.my_osid_object._my_map:\n            return IdList([])\n        id_list = []\n        for idstr in self.my_osid_object._my_map['brandingIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)", "response": "Gets the branding asset Ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_branding(self):\n        mgr = self.my_osid_object._get_provider_manager('REPOSITORY')\n        lookup_session = mgr.get_asset_lookup_session()\n        lookup_session.use_federated_repository_view()\n        return lookup_session.get_assets_by_ids(self.get_branding_ids())", "response": "Gets a branding for the asset"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_license(self):\n        if 'license' in self.my_osid_object._my_map:\n            license_text = self.my_osid_object._my_map['license']\n            return DisplayText(display_text_map=license_text)\n        return DisplayText(text='',\n                           language_type=DEFAULT_LANGUAGE_TYPE,\n                           format_type=DEFAULT_FORMAT_TYPE,\n                           script_type=DEFAULT_SCRIPT_TYPE)", "response": "Gets the terms of usage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the metadata for all display_names", "response": "def get_display_names_metadata(self):\n        \"\"\"Gets the metadata for all display_names.\n\n        return: (osid.Metadata) - metadata for the display_names\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._display_names_metadata)\n        metadata.update({'existing_string_values': [t['text'] for t in self.my_osid_object_form._my_map['displayNames']]})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the metadata for all descriptions", "response": "def get_descriptions_metadata(self):\n        \"\"\"Gets the metadata for all descriptions.\n\n        return: (osid.Metadata) - metadata for the descriptions\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._descriptions_metadata)\n        metadata.update({'existing_string_values': [t['text'] for t in self.my_osid_object_form._my_map['descriptions']]})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a display name.", "response": "def add_display_name(self, display_name):\n        \"\"\"Adds a display_name.\n\n        arg:    display_name (displayText): the new display name\n        raise:  InvalidArgument - ``display_name`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``display_name`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_display_names_metadata().is_read_only():\n            raise NoAccess()\n        if not isinstance(display_name, DisplayText):\n            raise InvalidArgument('display_name must be instance of DisplayText')\n        self.add_or_replace_value('displayNames', display_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the specified display_name.", "response": "def remove_display_name_by_language(self, language_type):\n        \"\"\"Removes the specified display_name.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_display_names_metadata().is_read_only():\n            raise NoAccess()\n        if not isinstance(language_type, Type):\n            raise InvalidArgument('language_type must be instance of Type')\n        self.my_osid_object_form._my_map['displayNames'] = [t\n                                                            for t in self.my_osid_object_form._my_map['displayNames']\n                                                            if t['languageTypeId'] != str(language_type)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a description. arg: description (displayText): the new description raise: InvalidArgument - ``description`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``description`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def add_description(self, description):\n        \"\"\"Adds a description.\n\n        arg:    description (displayText): the new description\n        raise:  InvalidArgument - ``description`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``description`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_descriptions_metadata().is_read_only():\n            raise NoAccess()\n        if not isinstance(description, DisplayText):\n            raise InvalidArgument('description must be instance of DisplayText')\n        self.add_or_replace_value('descriptions', description)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_description_by_language(self, language_type):\n        if self.get_descriptions_metadata().is_read_only():\n            raise NoAccess()\n        if not isinstance(language_type, Type):\n            raise InvalidArgument('language_type must be instance of Type')\n        self.my_osid_object_form._my_map['descriptions'] = [t\n                                                            for t in self.my_osid_object_form._my_map['descriptions']\n                                                            if t['languageTypeId'] != str(language_type)]", "response": "Removes the specified description."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match_display_names(self, value, match):\n        if value is None:\n            raise NullArgument('value must not be None')\n        if not utilities.is_string(value):\n            raise InvalidArgument('value must be a string')\n        if match is None:\n            raise NullArgument('match must not be None')\n        if not isinstance(match, bool):\n            raise InvalidArgument('match must be a bool')\n        self._my_osid_query._add_match('displayNames.text', str(value).lower(), match)", "response": "set the display names of the user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_member(self,grange):\n    if self.use_direction and not grange.direction:\n      sys.stderr.write(\"ERROR if using direction then direction of input members must be set\\n\")\n      sys.exit()\n    # Get range set properly\n    if not self.range:\n      self.range = GenomicRange(grange.chr,grange.start,grange.end)\n      if self.use_direction:\n        self.range.set_direction(grange.get_direction())\n    elif self.range.chr != grange.chr:\n      sys.stderr.write(\"WARNING cannot add member with chromosomes are not equal\\n\")\n      return False\n    elif self.use_direction and self.range.direction != grange.direction:\n      sys.stderr.write(\"WARNING cannot add member with different directions\\n\")\n      return False\n    else:\n      if grange.start < self.range.start:  self.range.start = grange.start\n      if grange.end > self.range.end: self.range.end = grange.end\n    self.members.append(grange)", "response": "Add a genomic range to the locus\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a locus to our loci but does not go through an update yet", "response": "def add_locus(self,inlocus):\n    \"\"\" Adds a locus to our loci, but does not go through an update our locus sets yet\"\"\"\n    if self.use_direction == True and inlocus.use_direction == False:\n      sys.stderr.write(\"ERROR if using the direction in Loci, then every locus added needs use_direction to be True\\n\")\n      sys.exit()\n    self.loci.append(inlocus)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngo through and merges loci until we have one set meeting our overlap definition", "response": "def update_loci(self):\n    \"\"\"Goes through and combines loci until we have one set meeting our overlap definition\"\"\"\n    # Create sub-loci for each chromosome\n    lbc = {}\n    chroms = sorted([x.range.chr for x in self.loci])\n    for chrom in chroms: lbc[chrom] = Loci()\n    for x in self.loci: lbc[x.range.chr].add_locus(x)\n    for chrom in sorted(lbc.keys()):\n      if self.verbose: \n        lbc[chrom].verbose = True\n        sys.stderr.write(chrom+\"\\n\")\n      lbc[chrom].overhang = self.overhang\n      lbc[chrom].use_direction = self.use_direction\n      lbc[chrom].merge_down_loci()\n    self.loci = []\n    for chrom in sorted(lbc.keys()):\n      for locus in lbc[chrom].loci:  self.loci.append(locus)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_down_loci(self):\n    old_locus_size = -1\n    z = 0\n    while len(self.loci) != old_locus_size:\n      z+=1\n      old_locus_size = len(self.loci)\n      locus_size = len(self.loci)\n      if self.verbose:\n        sys.stderr.write(str(locus_size)+\" Combining down loci step \"+str(z)+\"       \\r\")\n      combined = set()\n      for i in range(0,locus_size):\n        if i in combined: continue\n        for j in range(i+1,locus_size):\n          if self.loci[i].range.overlaps_with_padding(self.loci[j].range,self.overhang):\n            if self.use_direction and self.loci[i].range.direction != self.loci[j].range.direction:  continue\n            for obj in self.loci[j].members:\n              self.loci[i].add_member(obj)\n            combined.add(j)\n            break\n      newloci = []\n      for i in range(0,locus_size):\n        if i not in combined:\n          newloci.append(self.loci[i])\n      self.loci = newloci\n    if self.verbose:\n      sys.stderr.write(\"Finished combining down \"+str(len(self.loci))+\" loci in \"+str(z)+\" steps   \\n\")\n    return", "response": "Called internally to make loci overlapping into one set"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npush an image to the cache", "response": "def push(collector, image, **kwargs):\n    \"\"\"Push an image\"\"\"\n    if not image.image_index:\n        raise BadOption(\"The chosen image does not have a image_index configuration\", wanted=image.name)\n    tag = kwargs[\"artifact\"]\n    if tag is NotSpecified:\n        tag = collector.configuration[\"harpoon\"].tag\n    if tag is not NotSpecified:\n        image.tag = tag\n    Builder().make_image(image, collector.configuration[\"images\"], pushing=True)\n    Syncer().push(image)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npushes all the images", "response": "def push_all(collector, **kwargs):\n    \"\"\"Push all the images\"\"\"\n    configuration = collector.configuration\n    configuration[\"harpoon\"].do_push = True\n    configuration[\"harpoon\"].only_pushable = True\n    make_all(collector, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npull an arbitrary image", "response": "def pull_arbitrary(collector, image, **kwargs):\n    \"\"\"Pull an arbitrary image\"\"\"\n    image_index_of = lambda image: urlparse(\"https://{0}\".format(image)).netloc\n\n    if image.startswith(\"file://\"):\n        parsed = urlparse(image)\n        filename = parsed.netloc + parsed.path\n        if not os.path.exists(filename):\n            raise HarpoonError(\"Provided file doesn't exist!\", wanted=image)\n        with open(filename) as fle:\n            image_indexes = [(line.strip(), image_index_of(line.strip())) for line in fle]\n    else:\n        image_indexes = [(image, image_index_of(image))]\n\n    authentication = collector.configuration.get(\"authentication\", NotSpecified)\n    for index, (image, image_index) in enumerate(image_indexes):\n        tag = sb.NotSpecified\n        if \":\" in image:\n            image, tag = image.split(\":\", 1)\n\n        image = {\n              \"image_name\": image\n            , \"tag\": tag\n            , \"harpoon\": collector.configuration[\"harpoon\"]\n            , \"commands\": [\"FROM scratch\"]\n            , \"image_index\": image_index\n            , \"assume_role\": NotSpecified\n            , \"authentication\": authentication\n            }\n        meta = Meta(collector.configuration, []).at(\"images\").at(\"__arbitrary_{0}__\".format(index))\n        image = HarpoonSpec().image_spec.normalise(meta, image)\n        Syncer().pull(image)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npulling an image s dependent images", "response": "def pull_dependencies(collector, image, **kwargs):\n    \"\"\"Pull an image's dependent images\"\"\"\n    for dep in image.commands.dependent_images:\n        kwargs[\"image\"] = dep\n        pull_arbitrary(collector, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pull_parent(collector, image, **kwargs):\n    log.warning(\"DEPRECATED - use pull_dependencies instead\")\n    pull_dependencies(collector, image, **kwargs)", "response": "DEPRECATED - use pull_dependencies instead"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npulls all the images", "response": "def pull_all(collector, image, **kwargs):\n    \"\"\"Pull all the images\"\"\"\n    images = collector.configuration[\"images\"]\n\n    for layer in Builder().layered(images, only_pushable=True):\n        for image_name, image in layer:\n            log.info(\"Pulling %s\", image_name)\n            pull(collector, image, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npulls all the external dependencies of all the images", "response": "def pull_all_external(collector, **kwargs):\n    \"\"\"Pull all the external dependencies of all the images\"\"\"\n    deps = set()\n\n    images = collector.configuration[\"images\"]\n    for layer in Builder().layered(images):\n        for image_name, image in layer:\n            for dep in image.commands.external_dependencies:\n                deps.add(dep)\n\n    for dep in sorted(deps):\n        kwargs[\"image\"] = dep\n        pull_arbitrary(collector, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make(collector, image, **kwargs):\n    tag = kwargs.get(\"artifact\", NotSpecified)\n    if tag is NotSpecified:\n        tag = collector.configuration[\"harpoon\"].tag\n\n    if tag is not NotSpecified:\n        image.tag = tag\n\n    Builder().make_image(image, collector.configuration[\"images\"])\n    print(\"Created image {0}\".format(image.image_name))", "response": "Just create an image"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_all(collector, **kwargs):\n    configuration = collector.configuration\n    push = configuration[\"harpoon\"].do_push\n    only_pushable = configuration[\"harpoon\"].only_pushable\n    if push:\n        only_pushable = True\n\n    tag = kwargs.get(\"artifact\", NotSpecified)\n    if tag is NotSpecified:\n        tag = configuration[\"harpoon\"].tag\n\n    images = configuration[\"images\"]\n    for layer in Builder().layered(images, only_pushable=only_pushable):\n        for _, image in layer:\n            if tag is not NotSpecified:\n                image.tag = tag\n            Builder().make_image(image, images, ignore_deps=True, ignore_parent=True)\n            print(\"Created image {0}\".format(image.image_name))\n            if push and image.image_index:\n                Syncer().push(image)", "response": "Creates all the images in layered order"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_pushable(collector, **kwargs):\n    configuration = collector.configuration\n    configuration[\"harpoon\"].do_push = True\n    configuration[\"harpoon\"].only_pushable = True\n    make_all(collector, **kwargs)", "response": "Make all the pushable images and their dependencies"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist the available tasks", "response": "def list_tasks(collector, tasks, **kwargs):\n    \"\"\"List the available_tasks\"\"\"\n    print(\"Available tasks to choose from are:\")\n    print(\"Use the --task option to choose one\")\n    print(\"\")\n    keygetter = lambda item: item[1].label\n    tasks = sorted(tasks.items(), key=keygetter)\n    for label, items in itertools.groupby(tasks, keygetter):\n        print(\"--- {0}\".format(label))\n        print(\"----{0}\".format(\"-\" * len(label)))\n        sorted_tasks = sorted(list(items), key=lambda item: len(item[0]))\n        max_length = max(len(name) for name, _ in sorted_tasks)\n        for key, task in sorted_tasks:\n            desc = dedent(task.description or \"\").strip().split('\\n')[0]\n            print(\"\\t{0}{1} :-: {2}\".format(\" \" * (max_length-len(key)), key, desc))\n        print(\"\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_untagged(collector, **kwargs):\n    configuration = collector.configuration\n    docker_api = configuration[\"harpoon\"].docker_api\n    images = docker_api.images()\n    found = False\n    for image in images:\n        if image[\"RepoTags\"] == [\"<none>:<none>\"]:\n            found = True\n            image_id = image[\"Id\"]\n            log.info(\"Deleting untagged image\\thash=%s\", image_id)\n            try:\n                docker_api.remove_image(image[\"Id\"])\n            except DockerAPIError as error:\n                log.error(\"Failed to delete image\\thash=%s\\terror=%s\", image_id, error)\n\n    if not found:\n        log.info(\"Didn't find any untagged images to delete!\")", "response": "Delete untagged images from the untagged image list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show(collector, **kwargs):\n    configuration = collector.configuration\n    flat = configuration.get(\"harpoon.flat\", False)\n    only_pushable = configuration.get(\"harpoon.only_pushable\", False)\n\n    for index, layer in enumerate(Builder().layered(configuration[\"images\"], only_pushable=only_pushable)):\n        if flat:\n            for _, image in layer:\n                print(image.image_name)\n        else:\n            print(\"Layer {0}\".format(index))\n            for _, image in layer:\n                print(\"    {0}\".format(image.display_line()))\n            print(\"\")", "response": "Show what images we have"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_pushable(collector, **kwargs):\n    collector.configuration['harpoon'].only_pushable = True\n    show(collector, **kwargs)", "response": "Show what images we have in the current order"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_all_dockerfiles(collector, **kwargs):\n    for name, image in collector.configuration[\"images\"].items():\n        print(\"{0}\".format(name))\n        print(\"-\" * len(name))\n        kwargs[\"image\"] = image\n        print_dockerfile(collector, **kwargs)", "response": "Print all the dockerfiles"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_login(collector, image, **kwargs):\n    docker_api = collector.configuration[\"harpoon\"].docker_api\n    collector.configuration[\"authentication\"].login(docker_api, image, is_pushing=False, global_docker=True)", "response": "Login to a docker registry with read permissions"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs-in to a docker registry with write permissions", "response": "def write_login(collector, image, **kwargs):\n    \"\"\"Login to a docker registry with write permissions\"\"\"\n    docker_api = collector.configuration[\"harpoon\"].docker_api\n    collector.configuration[\"authentication\"].login(docker_api, image, is_pushing=True, global_docker=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef untag(collector, image, artifact, **kwargs):\n    if artifact in (None, \"\", NotSpecified):\n        artifact = collector.configuration[\"harpoon\"].tag\n\n    if artifact is NotSpecified:\n        raise BadOption(\"Please specify a tag using the artifact or tag options\")\n\n    image.tag = artifact\n    image_name = image.image_name_with_tag\n\n    log.info(\"Removing image\\timage={0}\".format(image_name))\n    try:\n        image.harpoon.docker_api.remove_image(image_name)\n    except docker.errors.ImageNotFound:\n        log.warning(\"No image was found to remove\")", "response": "Remove an image from the registry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tag(collector, image, artifact, **kwargs):\n    if artifact in (None, \"\", NotSpecified):\n        raise BadOption(\"Please specify a tag using the artifact option\")\n\n    if image.image_index in (None, \"\", NotSpecified):\n        raise BadOption(\"Please specify an image with an image_index option\")\n\n    tag = image.image_name\n    if collector.configuration[\"harpoon\"].tag is not NotSpecified:\n        tag = \"{0}:{1}\".format(tag, collector.configuration[\"harpoon\"].tag)\n    else:\n        tag = \"{0}:latest\".format(tag)\n\n    images = image.harpoon.docker_api.images()\n    current_tags = chain.from_iterable(image_conf[\"RepoTags\"] for image_conf in images if image_conf[\"RepoTags\"] is not None)\n    if tag not in current_tags:\n        raise BadOption(\"Please build or pull the image down to your local cache before tagging it\")\n\n    for image_conf in images:\n        if image_conf[\"RepoTags\"] is not None:\n            if tag in image_conf[\"RepoTags\"]:\n                image_id = image_conf[\"Id\"]\n                break\n\n    log.info(\"Tagging {0} ({1}) as {2}\".format(image_id, image.image_name, artifact))\n    image.harpoon.docker_api.tag(image_id, repository=image.image_name, tag=artifact, force=True)\n\n    image.tag = artifact\n    Syncer().push(image)", "response": "Tag an image using the local cache"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a file from an image", "response": "def retrieve(collector, image, artifact, **kwargs):\n    \"\"\"Retrieve a file/folder from an image\"\"\"\n    if artifact in (None, \"\", NotSpecified):\n        raise BadOption(\"Please specify what to retrieve using the artifact option\")\n\n    if collector.configuration[\"harpoon\"].tag is not NotSpecified:\n        image.tag = collector.configuration[\"harpoon\"].tag\n\n    # make sure the image is built\n    if os.environ.get(\"NO_BUILD\") is None:\n        Builder().make_image(image, collector.configuration[\"images\"])\n\n    content = {\n          \"conf\": image\n        , \"docker_api\": collector.configuration[\"harpoon\"].docker_api\n        , \"images\": collector.configuration[\"images\"]\n        , \"image\": image.image_name_with_tag\n        , \"path\": artifact\n        }\n\n    # Get us our gold!\n    with ContextBuilder().the_context(content) as fle:\n        shutil.copyfile(fle.name, os.environ.get(\"FILENAME\", \"./retrieved.tar.gz\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the user password salt.", "response": "def get_salt(request):\n    \"\"\"\n    return the user password salt.\n    If the user doesn't exist return a pseudo salt.\n    \"\"\"\n    try:\n        username = request.POST[\"username\"]\n    except KeyError:\n        # log.error(\"No 'username' in POST data?!?\")\n        return HttpResponseBadRequest()\n\n    try:\n        request.server_challenge = request.session[SERVER_CHALLENGE_KEY]\n    except KeyError as err:\n        # log.error(\"Can't get challenge from session: %s\", err)\n        return HttpResponseBadRequest()\n    # log.debug(\"old challenge: %r\", request.server_challenge)\n\n    send_pseudo_salt=True\n\n    form = UsernameForm(request, data=request.POST)\n    if form.is_valid():\n        send_pseudo_salt=False\n\n        user_profile = form.user_profile\n        init_pbkdf2_salt = user_profile.init_pbkdf2_salt\n        if not init_pbkdf2_salt:\n            # log.error(\"No init_pbkdf2_salt set in user profile!\")\n            send_pseudo_salt=True\n\n        if len(init_pbkdf2_salt)!=app_settings.PBKDF2_SALT_LENGTH:\n            # log.error(\"Salt for user %r has wrong length: %r\" % (request.POST[\"username\"], init_pbkdf2_salt))\n            send_pseudo_salt=True\n    # else:\n        # log.error(\"Salt Form is not valid: %r\", form.errors)\n\n    if send_pseudo_salt:\n        # log.debug(\"\\nUse pseudo salt!!!\")\n        init_pbkdf2_salt = crypt.get_pseudo_salt(app_settings.PBKDF2_SALT_LENGTH, username)\n\n    response = HttpResponse(init_pbkdf2_salt, content_type=\"text/plain\")\n\n    if not send_pseudo_salt:\n        response.add_duration=True # collect duration time in @TimingAttackPreventer\n\n    # log.debug(\"\\nsend init_pbkdf2_salt %r to client.\", init_pbkdf2_salt)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a message, after login. Because this signal receiver will be called **after** auth.models.update_last_login(), the user.last_login information was updated before! As a work-a-round, we add **user.previous_login** in forms.SecureLoginForm.clean()", "response": "def display_login_info(sender, user, request, **kwargs):\n    \"\"\"\n    Create a message, after login.\n\n    Because this signal receiver will be called **after** auth.models.update_last_login(), the\n    user.last_login information was updated before!\n\n    As a work-a-round, we add **user.previous_login** in forms.SecureLoginForm.clean()\n    \"\"\"\n    if not hasattr(user, \"previous_login\"):\n        # e.g. normal django admin login page was used\n        return\n    message = render_to_string('secure_js_login/login_info.html', {\"last_login\":user.previous_login})\n    messages.success(request, message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _compute_raw_moments(self, n_counter, k_counter):\n\n        alpha_multipliers, beta_multipliers = self._get_parameter_symbols(n_counter, k_counter)\n\n        out_mat = sp.Matrix([a * b for a,b in zip(alpha_multipliers, beta_multipliers)])\n        out_mat = out_mat.applyfunc(sp.expand)\n        return out_mat", "response": "r Compute the raw moments for the central moments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nthrottle a client by keeping track of the number of failed login attempts.", "response": "def throttle_login(request):\n    \"\"\"Throttles a client by keeping track of the number of failed login\n    attempts. If the user succeeds at a login before the max attempts has\n    been reached, the attempts are reset.\n    \"\"\"\n    email = request.POST['email']\n    password = request.POST['password']\n\n    # if the form is not filled out completely, pass along\n    if not (email and password):\n        return True\n\n    ip_address = get_ip_address(request)\n\n    # the cache key is determined by the client IP address in addition to\n    # the username being used to login. once the client reaches the max\n    # login attempts, they will be notified.\n\n    # if the same IP address attempts at multiple usernames within the same\n    # session, the IP will be blacklisted.\n    key = MAX_LOGIN_ATTEMPTS_KEY % (email, ip_address)\n\n    attempts = cache.get(key, 0) + 1\n\n    if attempts >= MAX_LOGIN_ATTEMPTS:\n\n        # once the max attempts has been reached, deactive the account\n        # and email the admins\n        user_already_inactive = False\n\n        try:\n            user = User.objects.get(username=email)\n        except User.DoesNotExist:\n            user = None\n\n        if user:\n            if user.is_active:\n                user.is_active = False\n                user.save()\n            # this condition tells me whether the user attempted to access\n            # their account with another session even though their account\n            # is already inactive\n            else:\n                user_already_inactive = True\n\n        t = get_template('registration/max_login_attempts.txt')\n        c = Context({\n            'user': user,\n            'minutes': int(request.session.get_expiry_age() / 60.0),\n            'email': email,\n            'ip_address': ip_address,\n            'user_already_inactive': user_already_inactive,\n        })\n\n        mail_admins(MAX_LOGIN_ATTEMPTS_SUBJECT, t.render(c), True)\n\n        login_allowed = False\n\n    else:\n        login_allowed = True\n\n    # cache for the duration of this session\n    cache.set(key, attempts, request.session.get_expiry_age())\n\n    # this is a convenience flag for subsequent requests during this session.\n    # if the client clears their cookies or uses a different browser, this\n    # flag will be gone, but the next login attempt will be caught again by\n    # the above logic\n    request.session['login_allowed'] = login_allowed\n\n    return login_allowed"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_file(path, text):\n    dir = os.path.dirname(path)\n    if not os.path.exists(dir):\n        os.makedirs(dir)\n\n    fd = open(path, 'w')\n    try:\n        fd.write(text)\n    finally:\n        fd.close()", "response": "Save a string to a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef split_delimited(delimiters, split_by, text):\n    delims = [0] * (old_div(len(delimiters), 2))\n    actions = {}\n    for i in range(0, len(delimiters), 2):\n        actions[delimiters[i]] = (old_div(i, 2), 1)\n        actions[delimiters[i + 1]] = (old_div(i, 2), -1)\n\n    if isinstance(split_by, str):\n        def split_fn(c): return c == split_by\n    else:\n        split_fn = split_by\n    last = 0\n\n    for i in range(len(text)):\n        c = text[i]\n        if split_fn(c) and not any(delims):\n            yield text[last:i]\n            last = i + 1\n        try:\n            which, dir = actions[c]\n            delims[which] = delims[which] + dir\n        except KeyError:\n            pass # Normal character\n    yield text[last:]", "response": "Generator that walks the text and splits it into a list of strings with the given delimiters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_doc_comments(text):\n    def make_pair(match):\n        comment = match.group()\n        try:\n            end = text.find('\\n', match.end(0)) + 1\n            if '@class' not in comment:\n                next_line = next(split_delimited('()', '\\n', text[end:]))\n            else:\n                next_line = text[end:text.find('\\n', end)]\n        except StopIteration:\n            next_line = ''\n        return (comment, next_line)\n    return [make_pair(match) for match in re.finditer('/\\*\\*(.*?)\\*/', \n            text, re.DOTALL)]", "response": "r Returns a list of all documentation comments in the file text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_tag(section):\n    splitval = re.split('\\s+', section, 1)\n    tag, body = len(splitval) > 1 and splitval or (splitval[0], '')\n    return tag.strip(), body.strip()", "response": "Split the JSDoc tag text at the first\n    whitespace."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to guess the function name from the first line of the code line containing the comment. If a match is found returns the function name. If a match is not found returns None.", "response": "def guess_function_name(next_line, regexps=FUNCTION_REGEXPS):\n    \"\"\"\n    Attempt to determine the function name from the first code line\n    following the comment.  The patterns recognized are described by\n    `regexps`, which defaults to FUNCTION_REGEXPS.  If a match is successful, \n    returns the function name.  Otherwise, returns None.\n    \"\"\"\n    for regexp in regexps:\n        match = re.search(regexp, next_line)\n        if match:\n            return match.group(1)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to guess parameters based on the presence of a parenthesized group of identifiers. If successful returns a list of parameter names ; otherwise returns None.", "response": "def guess_parameters(next_line):\n    \"\"\"\n    Attempt to guess parameters based on the presence of a parenthesized\n    group of identifiers.  If successful, returns a list of parameter names;\n    otherwise, returns None.\n    \"\"\"\n    match = re.search('\\(([\\w\\s,]+)\\)', next_line)\n    if match:\n        return [arg.strip() for arg in match.group(1).split(',')]\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_comment(doc_comment, next_line):\n    sections = re.split('\\n\\s*@', doc_comment)\n    tags = { \n        'doc': sections[0].strip(),\n        'guessed_function': guess_function_name(next_line),\n        'guessed_params': guess_parameters(next_line)\n    }\n    for section in sections[1:]:\n        tag, body = split_tag(section)\n        if tag in tags:\n            existing = tags[tag]\n            try:\n                existing.append(body)\n            except AttributeError:\n                tags[tag] = [existing, body]\n        else:\n            tags[tag] = body\n    return tags", "response": "r Split the raw comment text into a dictionary of tags."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of all parsed comments in a file.", "response": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a graph where nodes are filenames and edges are reverse dependencies .", "response": "def build_dependency_graph(start_nodes, js_doc):\n    \"\"\"\n    Build a graph where nodes are filenames and edges are reverse dependencies\n    (so an edge from jquery.js to jquery.dimensions.js indicates that jquery.js\n    must be included before jquery.dimensions.js).  The graph is represented\n    as a dictionary from filename to (in-degree, edges) pair, for ease of\n    topological sorting.  Also returns a list of nodes of degree zero.\n    \"\"\"\n    queue = []\n    dependencies = {}\n    start_sort = []\n    def add_vertex(file):\n        in_degree = len(js_doc[file].module.dependencies)\n        dependencies[file] = [in_degree, []]\n        queue.append(file)\n        if in_degree == 0:\n            start_sort.append(file)\n    def add_edge(from_file, to_file):\n        dependencies[from_file][1].append(to_file)\n    def is_in_graph(file):\n        return file in dependencies\n\n    for file in start_nodes:\n        add_vertex(file)\n    for file in queue:\n        for dependency in js_doc[file].module.dependencies:\n            if dependency not in js_doc:\n                raise MissingDependency(file, dependency)\n            if not is_in_graph(dependency):\n                add_vertex(dependency)\n            add_edge(dependency, file)\n    return dependencies, start_sort"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef topological_sort(dependencies, start_nodes):\n    retval = []\n    def edges(node): return dependencies[node][1]\n    def in_degree(node): return dependencies[node][0]\n    def remove_incoming(node): dependencies[node][0] = in_degree(node) - 1\n    while start_nodes:\n        node = start_nodes.pop()\n        retval.append(node)\n        for child in edges(node):\n            remove_incoming(child)\n            if not in_degree(child):\n                start_nodes.append(child)\n    leftover_nodes = [node for node in list(dependencies.keys())\n                      if in_degree(node) > 0]\n    if leftover_nodes:\n        raise CyclicDependency(leftover_nodes)\n    else:\n        return retval", "response": "Perform a topological sort on the dependency graph dependencies starting\n    from list start_nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_index(css_class, entities):\n    def make_entry(entity):\n        return ('<dt><a href = \"%(url)s\">%(name)s</a></dt>\\n' +\n                '<dd>%(doc)s</dd>') % {\n            'name': entity.name,\n            'url': entity.url,\n            'doc': first_sentence(entity.doc)\n        }\n    entry_text = '\\n'.join(make_entry(val) for val in entities)\n    if entry_text:\n        return '<dl class = \"%s\">\\n%s\\n</dl>' % (css_class, entry_text)\n    else:\n        return ''", "response": "Generates the HTML index for a list of FunctionDocs or ClassDocs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef htmlize_paragraphs(text):\n    paragraphs = re.split('(\\r?\\n)\\s*(\\r?\\n)', text)\n    return '\\n'.join('<p>%s</p>' % paragraph for paragraph in paragraphs)", "response": "Convert paragraphs delimited by blank lines into HTML text enclosed by paragraphs in <p > tags."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of all root paths where JS files can be found given the command line options.", "response": "def get_path_list(opts):\n    \"\"\"\n    Return a list of all root paths where JS files can be found, given the\n    command line options (in dict form) for this script.\n    \"\"\"\n    paths = []\n    for opt, arg in list(opts.items()):\n        if opt in ('-p', '--jspath'):\n            paths.append(arg)\n    return paths or [os.getcwd()]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_and_exit_if(opts, action, *names):\n    for name in names:\n        if name in opts:\n            action()\n            sys.exit(0)", "response": "Run the no - arg function action if any of names appears in the option dict opts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(args=sys.argv):\n    try:\n        opts, args = getopt.gnu_getopt(args[1:], 'p:o:jdt', [\n            'jspath=', 'output=', 'private', 'json', 'dependencies', \n            'test', 'help'])\n        opts = dict(opts)\n    except getopt.GetoptError:\n        usage()\n        sys.exit(2)\n\n    run_and_exit_if(opts, run_doctests, '--test')\n    run_and_exit_if(opts, usage, '--help')\n\n    js_paths = get_path_list(opts)\n    docs = CodeBaseDoc(js_paths, '--private' in opts)\n    if args:\n        selected_files = set(docs.keys()) & set(args)\n    else:\n        selected_files = list(docs.keys())\n\n    def print_json():\n        print(docs.to_json(selected_files))\n    run_and_exit_if(opts, print_json, '--json', '-j')\n\n    def print_dependencies():\n        for dependency in find_dependencies(selected_files, docs):\n            print(dependency)\n    run_and_exit_if(opts, print_dependencies, '--dependencies', '-d')\n\n    output = opts.get('--output') or opts.get('-o')\n    if output is None and len(args) != 1:\n        output = 'apidocs'\n    docs.save_docs(selected_files, output)", "response": "Main entry point for the code base doc command - line invocation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding the dependencies of all modules.", "response": "def _build_dependencies(self):\n        \"\"\"\n        >>> CodeBaseDoc(['examples'])['subclass.js'].module.all_dependencies\n        ['module.js', 'module_closure.js', 'class.js', 'subclass.js']\n        \"\"\"\n        for module in list(self.values()):\n            module.set_all_dependencies(find_dependencies([module.name], self))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _build_superclass_lists(self):\n        cls_dict = self.all_classes\n        for cls in list(cls_dict.values()):\n            cls.all_superclasses = []\n            superclass = cls.superclass\n            try:\n                while superclass:\n                    superclass_obj = cls_dict[superclass]\n                    cls.all_superclasses.append(superclass_obj)\n                    superclass = superclass_obj.superclass\n            except KeyError:\n                print(\"Missing superclass: \" + superclass)", "response": "Build the list of all superclasses."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntranslate a reference to a URL.", "response": "def translate_ref_to_url(self, ref, in_comment=None):\n        \"\"\"\n        Translates an @see or @link reference to a URL.  If the ref is of the \n        form #methodName, it looks for a method of that name on the class\n        `in_comment` or parent class of method `in_comment`.  In this case, it\n        returns a local hash URL, since the method is guaranteed to be on the\n        same page:\n\n        >>> doc = CodeBaseDoc(['examples'])\n        >>> doc.translate_ref_to_url('#public_method', doc.all_methods['private_method'])\n        '#public_method'\n        >>> doc.translate_ref_to_url('#public_method', doc.all_classes['MySubClass'])\n        '#public_method'\n\n        If it doesn't find it there, it looks for a global function:\n\n        >>> doc.translate_ref_to_url('#make_class')\n        'module_closure.html#make_class'\n\n        A reference of the form ClassName#method_name looks up a specific method:\n\n        >>> doc.translate_ref_to_url('MyClass#first_method')\n        'class.html#first_method'\n\n        Finally, a reference of the form ClassName looks up a specific class:\n\n        >>> doc.translate_ref_to_url('MyClass')\n        'class.html#MyClass'\n\n        \"\"\"\n        if ref.startswith('#'):\n            method_name = ref[1:]\n            if isinstance(in_comment, FunctionDoc) and in_comment.member:\n                search_in = self.all_classes[in_comment.member]\n            elif isinstance(in_comment, ClassDoc):\n                search_in = in_comment\n            else:\n                search_in = None\n\n            try:\n                return search_in.get_method(method_name).url\n            except AttributeError:\n                pass\n\n            def lookup_ref(file_doc):\n                for fn in file_doc.functions:\n                    if fn.name == method_name:\n                        return fn.url\n                return None\n        elif '#' in ref:\n            class_name, method_name = ref.split('#')\n            def lookup_ref(file_doc):\n                for cls in file_doc.classes:\n                    if cls.name == class_name:\n                        try:\n                            return cls.get_method(method_name).url\n                        except AttributeError:\n                            pass\n                return None\n        else:\n            class_name = ref\n            def lookup_ref(file_doc):\n                for cls in file_doc.classes:\n                    if cls.name == class_name:\n                        return cls.url\n                return None\n\n        for file_doc in list(self.values()):\n            url = lookup_ref(file_doc)\n            if url:\n                return file_doc.url + url\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates all links in text into HTML anchor tags.", "response": "def translate_links(self, text, in_comment=None):\n        \"\"\"\n        Turn all @link tags in `text` into HTML anchor tags.\n\n        `in_comment` is the `CommentDoc` that contains the text, for\n        relative method lookups.\n        \"\"\"\n        def replace_link(matchobj):\n            ref = matchobj.group(1)\n            return '<a href = \"%s\">%s</a>' % (\n                    self.translate_ref_to_url(ref, in_comment), ref)\n        return re.sub('{@link ([\\w#]+)}', replace_link, text)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the CodeBaseDoc into a dictionary containing the to_dict() representations of each contained file.", "response": "def to_dict(self, files=None):\n        \"\"\"\n        Converts the CodeBaseDoc into a dictionary containing the to_dict()\n        representations of each contained file.  The optional `files` list\n        lets you restrict the dict to include only specific files.\n\n        >>> CodeBaseDoc(['examples']).to_dict(['class.js']).get('module.js')\n        >>> CodeBaseDoc(['examples']).to_dict(['class.js'])['class.js'][0]['name']\n        'MyClass'\n\n        \"\"\"\n        keys = files or list(self.keys())\n        return dict((key, self[key].to_dict()) for key in keys)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_docs(self, files=None, output_dir=None):\n        if output_dir:\n            try:\n                os.mkdir(output_dir)\n            except OSError:\n                pass\n\n            try:\n                import pkg_resources\n                save_file(os.path.join(output_dir, 'jsdoc.css'),\n                    pkg_resources.resource_string(__name__, 'static/jsdoc.css'))\n            except (ImportError, IOError):\n                try:\n                    import shutil\n                    base_dir = os.path.dirname(os.path.realpath(__file__))\n                    css_file = os.path.join(base_dir, 'jsdoc.css')\n                    shutil.copy(css_file, output_dir)\n                except IOError:\n                    print('jsdoc.css not found.  HTML will not be styled.')\n\n            save_file('%s/index.html' % output_dir, \n                    build_html_page('Module index', self.to_html()))\n        else:\n            output_dir = '.'\n\n        if files is None:\n            files = list(self.keys())\n\n        for filename in files:\n            try:\n                doc = self[filename]\n                save_file('%s/%s.html' % (output_dir, trim_js_ext(doc.name)), \n                        build_html_page(doc.name, doc.to_html(self)))\n            except KeyError:\n                warn('File %s does not exist', filename)", "response": "Save documentation files for codebase into output_dir."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef functions(self):\n        def is_function(comment):\n            return isinstance(comment, FunctionDoc) and not comment.member\n        return self._filtered_iter(is_function)", "response": "Returns an iterator of all standalone functions in the file in textual\n        order."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an iterator of all member functions in the file in textual order.", "response": "def methods(self):\n        \"\"\"\n        Returns a generator of all member functions in the file, in textual\n        order.  \n\n        >>> file = FileDoc('class.js', read_file('examples/class.js'))\n        >>> file.methods.next().name\n        'first_method'\n\n        \"\"\"\n        def is_method(comment):\n            return isinstance(comment, FunctionDoc) and comment.member\n        return self._filtered_iter(is_method)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_as_list(self, tag_name):\n        val = self.get(tag_name, [])\n        if isinstance(val, list):\n            return val[:]\n        else:\n            return [val]", "response": "Return the value of a tag making sure that it s a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning this ModuleDoc as a dict.", "response": "def to_dict(self):\n        \"\"\"\n        Return this ModuleDoc as a dict.  In addition to `CommentDoc` defaults,\n        this has:\n\n            - **name**: The module name.\n            - **dependencies**: A list of immediate dependencies.\n            - **all_dependencies**: A list of all dependencies.\n        \"\"\"\n        vars = super(ModuleDoc, self).to_dict()\n        vars['dependencies'] = self.dependencies\n        vars['name'] = self.name\n        try:\n            vars['all_dependencies'] = self.all_dependencies[:]\n        except AttributeError:\n            vars['all_dependencies'] = []\n        return vars"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts this object to HTML.", "response": "def to_html(self, codebase):\n        \"\"\"\n        Convert this to HTML.\n        \"\"\"\n        html = ''\n        def build_line(key, include_pred, format_fn):\n            val = getattr(self, key)\n            if include_pred(val):\n                return '<dt>%s</dt><dd>%s</dd>\\n' % (printable(key), format_fn(val))\n            else:\n                return ''\n        def build_dependency(val):\n            return ', '.join('<a href = \"%s.html\">%s</a>' % (trim_js_ext(name), name)\n                             for name in val)\n        for key in ('author', 'organization', 'version', 'license'):\n            html += build_line(key, lambda val: val, lambda val: val)\n        html += build_line('dependencies', lambda val: val, build_dependency)\n        html += build_line('all_dependencies', lambda val: len(val) > 1, \n                                                build_dependency)\n        html += codebase.build_see_html(self.see, 'h3')\n        \n        if html:\n            return '<dl class = \"module\">\\n%s\\n</dl>\\n' % html\n        else:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef params(self):\n        tag_texts = self.get_as_list('param') + self.get_as_list('argument')\n        if self.get('guessed_params') is None:\n            return [ParamDoc(text) for text in tag_texts]\n        else:\n            param_dict = {}\n            for text in tag_texts:\n                param = ParamDoc(text)\n                param_dict[param.name] = param\n            return [param_dict.get(name) or ParamDoc('{} ' + name)\n                    for name in self.get('guessed_params')]", "response": "Returns a list of ParamDoc for each parameter of the function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef return_val(self):\n        ret = self.get('return') or self.get('returns')\n        type = self.get('type')\n        if '{' in ret and '}' in ret:\n            if not '}  ' in ret:\n                # Ensure that name is empty\n                ret = ret.replace('} ', '}  ')\n            return ParamDoc(ret)\n        if ret and type:\n            return ParamDoc('{%s}  %s' % (type, ret))\n        return ParamDoc(ret)", "response": "Returns the return value of the function as a ParamDoc with an empty name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exceptions(self):\n        def make_param(text):\n            if '{' in text and '}' in text:\n                # Make sure param name is blank:\n                word_split = list(split_delimited('{}', ' ', text))\n                if word_split[1] != '':\n                    text = ' '.join([word_split[0], ''] + word_split[1:])\n            else:\n                # Handle old JSDoc format\n                word_split = text.split()\n                text = '{%s}  %s' % (word_split[0], ' '.join(word_split[1:]))\n            return ParamDoc(text)\n        return [make_param(text) for text in \n                self.get_as_list('throws') + self.get_as_list('exception')]", "response": "Returns a list of ParamDoc objects with empty names for the exception tags for the function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        vars = super(FunctionDoc, self).to_dict()\n        vars.update({\n            'name': self.name,\n            'params': [param.to_dict() for param in self.params],\n            'options': [option.to_dict() for option in self.options],\n            'exceptions': [exc.to_dict() for exc in self.exceptions],\n            'return_val': self.return_val.to_dict(),\n            'is_private': self.is_private,\n            'is_constructor': self.is_constructor,\n            'member': self.member\n        })\n        return vars", "response": "Convert this FunctionDoc to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_html(self, codebase):\n        body = ''\n        for section in ('params', 'options', 'exceptions'):\n            val = getattr(self, section)\n            if val:\n                body += '<h5>%s</h5>\\n<dl class = \"%s\">%s</dl>' % (\n                        printable(section), section, \n                        '\\n'.join(param.to_html() for param in val))\n\n        body += codebase.build_see_html(self.see, 'h5', self)\n        return ('<a name = \"%s\" />\\n<div class = \"function\">\\n' + \n                '<h4>%s</h4>\\n%s\\n%s\\n</div>\\n') % (self.name, self.name, \n                    htmlize_paragraphs(codebase.translate_links(self.doc, self)), body)", "response": "Convert this FunctionDoc to HTML."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the contained method of the specified name or default if no method is found.", "response": "def get_method(self, method_name, default=None):\n        \"\"\"\n        Returns the contained method of the specified name, or `default` if\n        not found.\n        \"\"\"\n        for method in self.methods:\n            if method.name == method_name:\n                return method\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_dict(self):\n        vars = super(ClassDoc, self).to_dict()\n        vars.update({\n            'name': self.name,\n            'method': [method.to_dict() for method in self.methods]\n        })\n        return vars", "response": "Convert this ClassDoc to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting this ClassDoc to HTML.", "response": "def to_html(self, codebase):\n        \"\"\"\n        Convert this ClassDoc to HTML.  This returns the default long-form\n        HTML description that's used when the full docs are built.\n        \"\"\"\n        return ('<a name = \"%s\" />\\n<div class = \"jsclass\">\\n' + \n                '<h3>%s</h3>\\n%s\\n<h4>Methods</h4>\\n%s</div>') % (\n                self.name, self.name, \n                htmlize_paragraphs(codebase.translate_links(self.doc, self)) +\n                codebase.build_see_html(self.see, 'h4', self),\n                '\\n'.join(method.to_html(codebase) for method in self.methods\n                        if codebase.include_private or not method.is_private))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_html(self, css_class=''):\n        if self.name and self.type:\n            header_text = '%s (%s)' % (self.name, self.type)\n        elif self.type:\n            header_text = self.type\n        else:\n            header_text = self.name\n        return '<dt>%s</dt><dd>%s</dd>' % (header_text, self.doc)", "response": "Returns the parameter as a dt / dd pair."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_max_attempts(self):\n        if 'maxAttempts' not in self.my_osid_object._my_map or \\\n                self.my_osid_object._my_map['maxAttempts'] is None:\n            return False\n        return True", "response": "check if the user has max attempts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the map with the default values for the object.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        self.my_osid_object_form._my_map['reviewOptions'] = \\\n            dict(self._review_options_metadata['default_object_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['whetherCorrect'] = \\\n            dict(self._whether_correct_metadata['default_object_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['whetherCorrect']['duringAttempt'] = \\\n            bool(self._during_attempt_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['whetherCorrect']['afterAttempt'] = \\\n            bool(self._after_attempt_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['whetherCorrect']['beforeDeadline'] = \\\n            bool(self._before_deadline_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['whetherCorrect']['afterDeadline'] = \\\n            bool(self._after_deadline_metadata['default_boolean_values'][0])\n\n        self.my_osid_object_form._my_map['reviewOptions']['solution'] = \\\n            dict(self._solutions_metadata['default_object_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['solution']['duringAttempt'] = False\n        self.my_osid_object_form._my_map['reviewOptions']['solution']['afterAttempt'] = \\\n            bool(self._after_attempt_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['solution']['beforeDeadline'] = \\\n            bool(self._before_deadline_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['reviewOptions']['solution']['afterDeadline'] = \\\n            bool(self._after_deadline_metadata['default_boolean_values'][0])\n\n        self.my_osid_object_form._my_map['maxAttempts'] = \\\n            list(self._max_attempts_metadata['default_integer_values'])[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the metadata for the object", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._review_options_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'review_options'),\n            'element_label': 'Review Options',\n            'instructions': 'Choose various Review Options',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._whether_correct_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'report_correct'),\n            'element_label': 'Report Correct',\n            'instructions': 'Choose when to report correct answer to Taker',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._solutions_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'review_solutions'),\n            'element_label': 'Review Solutions / Explanations',\n            'instructions': 'Choose when to report a solution or explanation text blob, when available',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._during_attempt_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'during-attempt'),\n            'element_label': 'During Attempt',\n            'instructions': 'accepts a boolean (True/False) value',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }\n        self._after_attempt_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'during-attempt'),\n            'element_label': 'During Attempt',\n            'instructions': 'accepts a boolean (True/False) value',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }\n        self._before_deadline_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'during-attempt'),\n            'element_label': 'During Attempt',\n            'instructions': 'accepts a boolean (True/False) value',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }\n        self._after_deadline_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'during-attempt'),\n            'element_label': 'During Attempt',\n            'instructions': 'accepts a boolean (True/False) value',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }\n        self._min_max_attempts_value = None\n        self._max_max_attempts_value = None\n        self._max_attempts_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'max_attempts'),\n            'element_label': 'Maximum Attempts',\n            'instructions': 'enter an integer value for maximum attempts',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_integer_values': [None],\n            'syntax': 'INTEGER',\n            'minimum_integer': self._min_max_attempts_value,\n            'maximum_integer': self._max_max_attempts_value,\n            'integer_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the whether correct flag", "response": "def set_review_whether_correct(self,\n                                   during_attempt=None,\n                                   after_attempt=None,\n                                   before_deadline=None,\n                                   after_deadline=None):\n        \"\"\"stub\"\"\"\n        whether_correct = self.my_osid_object_form._my_map['reviewOptions']['whetherCorrect']\n        if during_attempt is not None:\n            whether_correct['duringAttempt'] = bool(during_attempt)\n        if after_attempt is not None:\n            whether_correct['afterAttempt'] = bool(after_attempt)\n        if before_deadline is not None:\n            whether_correct['beforeDeadline'] = bool(before_deadline)\n        if after_deadline is not None:\n            whether_correct['afterDeadline'] = bool(after_deadline)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the review solution", "response": "def set_review_solution(self,\n                            during_attempt=None,\n                            after_attempt=None,\n                            before_deadline=None,\n                            after_deadline=None):\n        \"\"\"stub\"\"\"\n        solution = self.my_osid_object_form._my_map['reviewOptions']['solution']\n        if during_attempt is not None:\n            solution['duringAttempt'] = bool(during_attempt)\n        if after_attempt is not None:\n            solution['afterAttempt'] = bool(after_attempt)\n        if before_deadline is not None:\n            solution['beforeDeadline'] = bool(before_deadline)\n        if after_deadline is not None:\n            solution['afterDeadline'] = bool(after_deadline)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the max attempts", "response": "def set_max_attempts(self, value):\n        \"\"\"stub\"\"\"\n        if value is None:\n            raise InvalidArgument('value must be an integer')\n        if value is not None and not isinstance(value, int):\n            raise InvalidArgument('value is not an integer')\n        if not self.my_osid_object_form._is_valid_integer(value,\n                                                          self.get_max_attempts_metadata()):\n            raise InvalidArgument('value must be an integer')\n        self.my_osid_object_form._my_map['maxAttempts'] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_review_whether_correct(self):\n        ao = self.my_osid_object.get_assessment_offered()\n        attempt_complete = self.my_osid_object.has_ended()\n        if ao.can_review_whether_correct_during_attempt() and not attempt_complete:\n            return True\n        if ao.can_review_whether_correct_after_attempt and attempt_complete:\n            return True\n        return False", "response": "returns True if the user can review the assessment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mangle_scope_tree(root, toplevel):\n    def mangle(scope):\n        # don't mangle global scope if not specified otherwise\n        if scope.get_enclosing_scope() is None and not toplevel:\n            return\n        for name in scope.symbols:\n            mangled_name = scope.get_next_mangled_name()\n            scope.mangled[name] = mangled_name\n            scope.rev_mangled[mangled_name] = name\n\n    def visit(node):\n        mangle(node)\n        for child in node.children:\n            visit(child)\n\n    visit(root)", "response": "Mangles the scope tree and all its children."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfills the scope with the referenced name.", "response": "def _fill_scope_refs(name, scope):\n        \"\"\"Put referenced name in 'ref' dictionary of a scope.\n\n        Walks up the scope tree and adds the name to 'ref' of every scope\n        up in the tree until a scope that defines referenced name is reached.\n        \"\"\"\n        symbol = scope.resolve(name)\n        if symbol is None:\n            return\n\n        orig_scope = symbol.scope\n        scope.refs[name] = orig_scope\n        while scope is not orig_scope:\n            scope = scope.get_enclosing_scope()\n            scope.refs[name] = orig_scope"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        tokens = []\n        section = nodes.section()\n        section['ids'].append(\"available-tasks\")\n\n        title = nodes.title()\n        title += nodes.Text(\"Default tasks\")\n        section += title\n\n        task_finder = TaskFinder(Collector())\n        for name, task in sorted(task_finder.default_tasks().items(), key=lambda x: len(x[0])):\n\n            lines = [name] + [\"  {0}\".format(line.strip()) for line in task.description.split('\\n')]\n            viewlist = ViewList()\n            for line in lines:\n                viewlist.append(line, name)\n            self.state.nested_parse(viewlist, self.content_offset, section)\n\n        return [section]", "response": "For each file in noseOfYeti / specs output nodes to represent each spec file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef resource_definition(resource):\n    meta = getmeta(resource)\n\n    definition = {\n        'type': \"object\",\n        'properties': {}\n    }\n\n    for field in meta.all_fields:\n        field_definition = {}\n\n        type_def = map_field_to_type(field)\n        if type_def:\n            field_definition['type'] = str(type_def)\n            if type_def.format:\n                field_definition['format'] = type_def.format\n\n        if field.doc_text:\n            field_definition['description'] = field.doc_text\n\n        if isinstance(field, VirtualField) or field in meta.readonly_fields:\n            field_definition['readOnly'] = True\n\n        # Use getattr to support calculated fields\n        if getattr(field, 'choices', None):\n            field_definition['enum'] = [c[0] for c in field.choices]\n\n        definition['properties'][field.name] = field_definition\n\n    return definition", "response": "Generate a Swagger Definitions Object <http://swagger. io / specification/#definitionsObject > _\n    from a resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the last universal ancestor of this object.", "response": "def cenancestor(self):\n        \"\"\"\n        Last universal ancestor (or the top level of the API structure).\n        \"\"\"\n        ancestor = parent = self.parent\n        while parent:\n            ancestor = parent\n            parent = getattr(parent, 'parent', None)\n        return ancestor"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the API base path for the base object of the current object.", "response": "def base_path(self):\n        \"\"\"\n        Calculate the APIs base path\n        \"\"\"\n        path = UrlPath()\n\n        # Walk up the API to find the base object\n        parent = self.parent\n        while parent:\n            path_prefix = getattr(parent, 'path_prefix', NoPath)\n            path = path_prefix + path\n            parent = getattr(parent, 'parent', None)\n\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_operations(self):\n        resource_defs = {\n            getmeta(resources.Error).resource_name: resource_definition(resources.Error),\n            getmeta(resources.Listing).resource_name: resource_definition(resources.Listing),\n        }\n\n        paths = collections.OrderedDict()\n        for path, operation in self.parent.op_paths():\n            # Cut of first item (will be the parents path)\n            path = '/' + path[1:]  # type: UrlPath\n\n            # Filter out swagger endpoints\n            if self.SWAGGER_TAG in operation.tags:\n                continue\n\n            # Add to resource definitions\n            if operation.resource:\n                resource_defs[getmeta(operation.resource).resource_name] = resource_definition(operation.resource)\n\n            # Add any resource definitions from responses\n            if operation.responses:\n                for response in operation.responses:\n                    resource = response.resource\n                    # Ensure we have a resource\n                    if resource and resource is not DefaultResource:\n                        resource_name = getmeta(resource).resource_name\n                        # Don't generate a resource definition if one has already been created.\n                        if resource_name not in resource_defs:\n                            resource_defs[resource_name] = resource_definition(resource)\n\n            # Add path parameters\n            path_spec = paths.setdefault(path.format(self.swagger_node_formatter), {})\n\n            # Add parameters\n            parameters = self.generate_parameters(path)\n            if parameters:\n                path_spec['parameters'] = parameters\n\n            # Add methods\n            for method in operation.methods:\n                path_spec[method.value.lower()] = operation.to_swagger()\n\n        return paths, resource_defs", "response": "Parse the operations into a path parameter and a resource definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ui(self, _):\n        if not self._ui_cache:\n            content = self.load_static('ui.html')\n            if isinstance(content, binary_type):\n                content = content.decode('UTF-8')\n            self._ui_cache = content.replace(u\"{{SWAGGER_PATH}}\", str(self.swagger_path))\n        return HttpResponse(self._ui_cache, headers={\n            'Content-Type': 'text/html'\n        })", "response": "Load the Swagger UI interface"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_static(self, _, file_name=None):\n        content_type = {\n            'ss': 'text/css',\n            'js': 'application/javascript',\n        }.get(file_name[-2:])\n        if not content_type:\n            raise HttpError(HTTPStatus.NOT_FOUND, 42)\n\n        return HttpResponse(self.load_static(file_name), headers={\n            'Content-Type': content_type,\n            'Content-Encoding': 'gzip',\n            'Cache-Control': 'public, max-age=300',\n        })", "response": "Get static content for UI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef perturbed_trajectory(trajectory, sensitivity_trajectory, delta=1e-4):\n    sensitivity_trajectory_description = sensitivity_trajectory.description\n    assert(isinstance(sensitivity_trajectory_description, SensitivityTerm))\n    assert(np.equal(trajectory.timepoints, sensitivity_trajectory.timepoints).all())\n\n    return Trajectory(trajectory.timepoints,\n                      trajectory.values + sensitivity_trajectory.values * delta,\n                      PerturbedTerm(sensitivity_trajectory_description.ode_term,\n                                    sensitivity_trajectory_description.parameter,\n                                    delta))", "response": "Returns a new unperturbed trajectory with the given timepoints and sensitivity_trajectory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_csv(self, file):\n\n        file.write(\"time,value\\n\")\n        for t,v in self:\n            file.write(\"%f,%f\\n\"% (t, v))", "response": "Writes this trajectory to a csv file with the headers time and value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resample(self, new_timepoints, extrapolate=False):\n\n        \"\"\"\n        Use linear interpolation to resample trajectory values.\n        The new values are interpolated for the provided time points.\n        This is generally before comparing or averaging trajectories.\n\n        :param new_timepoints: the new time points\n        :param extrapolate: whether extrapolation should be performed when some new time points\n            are out of the current time range. if extrapolate=False, it would raise an exception.\n        :return: a new trajectory.\n        :rtype: :class:`~means.simulation.trajectory.Trajectory`\n        \"\"\"\n        if not extrapolate:\n            if min(self.timepoints) > min(new_timepoints):\n                raise Exception(\"Some of the new time points are before any time points. If you really want to extrapolate, use `extrapolate=True`\")\n            if max(self.timepoints) < max(new_timepoints):\n                raise Exception(\"Some of the new time points are after any time points. If you really want to extrapolate, use `extrapolate=True`\")\n        new_values = np.interp(new_timepoints, self.timepoints, self.values)\n        return Trajectory(new_timepoints, new_values, self.description)", "response": "Resample the trajectories to the provided time points."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying an arithmetic operation between two trajectories and a scalar or between the respective values of a Trajectory and a scalar.", "response": "def _arithmetic_operation(self, other, operation):\n        \"\"\"\n        Applies an operation between the values of a trajectories and a scalar or between\n        the respective values of two trajectories. In the latter case, trajectories should have\n        equal descriptions and time points\n        \"\"\"\n        if isinstance(other, Trajectory):\n            if self.description != other.description:\n                raise Exception(\"Cannot add trajectories with different descriptions\")\n            if not np.array_equal(self.timepoints, other.timepoints):\n                raise Exception(\"Cannot add trajectories with different time points\")\n            new_values = operation(self.values, other.values)\n        elif isinstance(other, numbers.Real):\n            new_values = operation(self.values, float(other))\n        else:\n            raise Exception(\"Arithmetic operations is between two `Trajectory` objects or a `Trajectory` and a scalar.\")\n\n        return Trajectory(self.timepoints, new_values, self.description)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _arithmetic_operation(self, other, operation):\n        if isinstance(other, TrajectoryWithSensitivityData):\n            if self.description != other.description:\n                raise Exception(\"Cannot add trajectories with different descriptions\")\n            if not np.array_equal(self.timepoints, other.timepoints):\n                raise Exception(\"Cannot add trajectories with different time points\")\n            new_values = operation(self.values, other.values)\n            new_sensitivity_data = [operation(ssd, osd) for ssd, osd in\n                                    zip(self.sensitivity_data, other.sensitivity_data)]\n\n        elif isinstance(other, numbers.Real):\n            new_values = operation(self.values, float(other))\n            new_sensitivity_data = [operation(ssd, float(other)) for ssd in self.sensitivity_data]\n\n        else:\n            raise Exception(\"Arithmetic operations is between two `TrajectoryWithSensitivityData`\\\n                            objects or a `TrajectoryWithSensitivityData` and a scalar.\")\n\n        return TrajectoryWithSensitivityData(self.timepoints, new_values, self.description, new_sensitivity_data )", "response": "Applies an arithmetic operation between two trajectories and a scalar or between\n        the respective values of a TrajectoryWithSensitivityData object and the corresponding values of a TrajectoryWithSensitivityData object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_csv(self, file):\n        file.write(\"description,time,value\\n\")\n        for traj in self:\n            for t,v in traj:\n                file.write(\"%s,%f,%f\\n\"% (traj.description.symbol, t, v))", "response": "Writes all the trajectories of a collection to a csv file with the headers description time and value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef xform(self, number, base):\n        if self.CONFIG.use_letters:\n            digits = \\\n               self._UPPER_DIGITS if self.CONFIG.use_caps else \\\n               self._LOWER_DIGITS\n            return ''.join(digits[x] for x in number)\n        separator = '' if base <= 10 else self.CONFIG.separator\n        return separator.join(str(x) for x in number)", "response": "Get a number as a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstripping trailing zeros from a list of ints.", "response": "def _strip_trailing_zeros(value):\n        \"\"\"\n        Strip trailing zeros from a list of ints.\n\n        :param value: the value to be stripped\n        :type value: list of str\n\n        :returns: list with trailing zeros stripped\n        :rtype: list of int\n        \"\"\"\n        return list(\n           reversed(\n              list(itertools.dropwhile(lambda x: x == 0, reversed(value)))\n           )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xform(self, number, relation):\n\n        # pylint: disable=too-many-boolean-expressions\n        if (self.CONFIG.strip) or \\\n           (self.CONFIG.strip_exact and relation == 0) or \\\n           (self.CONFIG.strip_whole and relation == 0 and \\\n            all(x == 0 for x in number)):\n            return Strip._strip_trailing_zeros(number)\n        return number", "response": "Return the number according to config and relation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the radix - level string for the radix - level radix - level value", "response": "def xform(self, left, right, repeating, base, sign):\n        \"\"\"\n        Return prefixes for tuple.\n\n        :param str left: left of the radix\n        :param str right: right of the radix\n        :param str repeating: repeating part\n        :param int base: the base in which value is displayed\n        :param int sign: -1, 0, 1 as appropriate\n        :returns: the number string\n        :rtype: str\n        \"\"\"\n        # pylint: disable=too-many-arguments\n\n        base_prefix = ''\n        if self.CONFIG.use_prefix:\n            if base == 8:\n                base_prefix = '0'\n            elif base == 16:\n                base_prefix = '0x'\n            else:\n                base_prefix = ''\n\n        base_subscript = str(base) if self.CONFIG.use_subscript else ''\n\n        result = {\n           'sign' : '-' if sign == -1 else '',\n           'base_prefix' : base_prefix,\n           'left' : left,\n           'radix' : '.' if (right != \"\" or repeating != \"\") else \"\",\n           'right' : right,\n           'repeating' : (\"(%s)\" % repeating) if repeating != \"\" else \"\",\n           'base_separator' : '' if base_subscript == '' else '_',\n           'base_subscript' : base_subscript\n        }\n\n        return self._FMT_STR % result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns decorators for tuple.", "response": "def decorators(self, relation):\n        \"\"\"\n        Return prefixes for tuple.\n\n        :param int relation: relation of string value to actual value\n        \"\"\"\n        if self.CONFIG.show_approx_str:\n            approx_str = Decorators.relation_to_symbol(relation)\n        else:\n            approx_str = ''\n\n        return _Decorators(approx_str=approx_str)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xform(self, radix, relation):\n        right = radix.non_repeating_part\n        left = radix.integer_part\n        repeating = radix.repeating_part\n\n        if repeating == []:\n            right = self.STRIP.xform(right, relation)\n\n        right_str = self.DIGITS.xform(right, radix.base)\n        left_str = self.DIGITS.xform(left, radix.base) or '0'\n        repeating_str = self.DIGITS.xform(repeating, radix.base)\n\n        number = self.NUMBER.xform(\n           left_str,\n           right_str,\n           repeating_str,\n           radix.base,\n           radix.sign\n        )\n\n        decorators = self.DECORATORS.decorators(relation)\n\n        result = {\n           'approx' : decorators.approx_str,\n           'space' : ' ' if decorators.approx_str else '',\n           'number' : number\n        }\n\n        return self._FMT_STR % result", "response": "Transform a radix and some information to a str according to the configurations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_provider_link_ids(self):\n        id_list = []\n        for id_ in self._my_map['providerLinkIds']:\n            id_list.append(Id(id_))\n        return IdList(id_list)", "response": "Gets the resource Ids representing the source of this asset in\n        order from the most recent provider to the originating source."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the title. :param title: the new title :type title: ``string`` :raise: ``InvalidArgument`` -- ``title`` is invalid :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true`` :raise: ``NullArgument`` -- ``title`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_title(self, title=None):\n        \"\"\"Sets the title.\n\n        :param title: the new title\n        :type title: ``string``\n        :raise: ``InvalidArgument`` -- ``title`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``title`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if title is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['title'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(title, metadata, array=False):\n            self._my_map['title']['text'] = title\n        else:\n            raise InvalidArgument()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the title. :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_title(self):\n        \"\"\"Removes the title.\n\n        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or\n            ``Metadata.isReadOnly()`` is ``true``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = Metadata(**settings.METADATA['title'])\n        if metadata.is_read_only() or metadata.is_required():\n            raise NoAccess()\n        self._my_map['title']['text'] = ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the public domain flag.", "response": "def set_public_domain(self, public_domain=None):\n        \"\"\"Sets the public domain flag.\n\n        :param public_domain: the public domain status\n        :type public_domain: ``boolean``\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if public_domain is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['public_domain'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(public_domain, metadata, array=False):\n            self._my_map['publicDomain'] = public_domain\n        else:\n            raise InvalidArgument()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_copyright(self, copyright=None):\n        if copyright is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['copyright'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(copyright, metadata, array=False):\n            self._my_map['copyright']['text'] = copyright\n        else:\n            raise InvalidArgument()", "response": "Sets the copyright.\n\n        :param copyright: the new copyright\n        :type copyright: ``string``\n        :raise: ``InvalidArgument`` -- ``copyright`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``copyright`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_copyright_registration(self, registration):\n        # Implemented from template for osid.repository.AssetContentForm.set_url_template\n        if self.get_copyright_registration_metadata().is_read_only():\n            raise NoAccess()\n        if not self._is_valid_string(\n                registration,\n                self.get_copyright_registration_metadata()):\n            raise InvalidArgument()\n        self._my_map['copyrightRegistration'] = registration", "response": "Sets the copyright registration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_distribute_verbatim(self, distribute_verbatim=None):\n        if distribute_verbatim is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['distribute_verbatim'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(distribute_verbatim, metadata, array=False):\n            self._my_map['canDistributeVerbatim'] = distribute_verbatim\n        else:\n            raise InvalidArgument()", "response": "Sets the distribution rights."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_distribute_alterations(self, distribute_mods=None):\n        if distribute_mods is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['distribute_alterations'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(distribute_mods, metadata, array=False):\n            self._my_map['canDistributeAlterations'] = distribute_mods\n        else:\n            raise InvalidArgument()", "response": "Sets the distribute alterations flag."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the distribution rights. This sets distribute verbatim to true.", "response": "def set_distribute_compositions(self, distribute_comps=None):\n        \"\"\"Sets the distribution rights.\n\n        This sets distribute verbatim to ``true``.\n\n        :param distribute_comps: right to distribute modifications\n        :type distribute_comps: ``boolean``\n        :raise: ``InvalidArgument`` -- ``distribute_comps`` is invalid\n        :raise: ``NoAccess`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if distribute_comps is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['distribute_compositions'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(distribute_comps, metadata, array=False):\n            self._my_map['canDistributeCompositions'] = distribute_comps\n        else:\n            raise InvalidArgument()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_source(self, source_id=None):\n        if source_id is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['source_id'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(source_id, metadata, array=False):\n            self._my_map['sourceId'] = str(source_id)\n        else:\n            raise InvalidArgument()", "response": "Sets the source.\n\n        :param source_id: the new publisher\n        :type source_id: ``osid.id.Id``\n        :raise: ``InvalidArgument`` -- ``source_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``source_id`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_provider_links(self, resource_ids=None):\n        if resource_ids is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['provider_link_ids'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(resource_ids, metadata, array=True):\n            self._my_map['providerLinkIds'] = []\n            for i in resource_ids:\n                self._my_map['providerLinkIds'].append(str(i))\n        else:\n            raise InvalidArgument()", "response": "Sets a provider chain in order from the most recent source to\n        the originating source."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_created_date(self, created_date=None):\n        if created_date is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['created_date'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(created_date, metadata, array=False):\n            self._my_map['createdDate'] = created_date  # This is probably wrong\n        else:\n            raise InvalidArgument()", "response": "Sets the created date."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the published status.", "response": "def set_published(self, published=None):\n        \"\"\"Sets the published status.\n\n        :param published: the published status\n        :type published: ``boolean``\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if published is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['published'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(published, metadata, array=False):\n            self._my_map['published'] = published\n        else:\n            raise InvalidArgument()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the published status.", "response": "def clear_published(self):\n        \"\"\"Removes the published status.\n\n        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = Metadata(**settings.METADATA['published'])\n        if metadata.is_read_only() or metadata.is_required():\n            raise NoAccess()\n        self._my_map['published'] = False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_published_date(self, published_date=None):\n        if published_date is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['published_date'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(published_date, metadata, array=False):\n            self._my_map['publishedDate'] = published_date  # This is probably wrong\n        else:\n            raise InvalidArgument()", "response": "Sets the published date."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_principal_credit_string(self, credit_string=None):\n        if credit_string is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['principal_credit_string'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(credit_string, metadata, array=False):\n            self._my_map['principalCreditString']['text'] = credit_string\n        else:\n            raise InvalidArgument()", "response": "Sets the principal credit string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_composition(self, composition_id=None):\n        if composition_id is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['composition_id'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(composition_id, metadata, array=False):\n            self._my_map['compositionId'] = str(composition_id)\n        else:\n            raise InvalidArgument()", "response": "Sets the composition.\n\n        :param composition_id: a composition\n        :type composition_id: ``osid.id.Id``\n        :raise: ``InvalidArgument`` -- ``composition_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the next Asset in this list.", "response": "def get_next_asset(self):\n        \"\"\"Gets the next Asset in this list.\n\n        return: (osid.repository.Asset) - the next Asset in this list.\n                The has_next() method should be used to test that a next\n                Asset is available before calling this method.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an accessibility type.", "response": "def add_accessibility_type(self, accessibility_type=None):\n        \"\"\"Adds an accessibility type.\n\n        Multiple types can be added.\n\n        :param accessibility_type: a new accessibility type\n        :type accessibility_type: ``osid.type.Type``\n        :raise: ``InvalidArgument`` -- ``accessibility_type`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``accessibility_t_ype`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if accessibility_type is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['accessibility_type'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(accessibility_type, metadata, array=False):\n            self._my_map['accessibilityTypeIds'].append(accessibility_type._my_map['id'])\n            # REALLY?  This assumes that all accessibility_type arguments\n            # will be Types that have come from Handcar.  Perhaps?\n        else:\n            raise InvalidArgument"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove an accessibility type from the metadata.", "response": "def remove_accessibility_type(self, accessibility_type=None):\n        \"\"\"Removes an accessibility type.\n\n        :param accessibility_type: accessibility type to remove\n        :type accessibility_type: ``osid.type.Type``\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NotFound`` -- acessibility type not found\n        :raise: ``NullArgument`` -- ``accessibility_type`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if accessibility_type is None:\n            raise NullArgument\n        metadata = Metadata(**settings.METADATA['accessibility_type'])\n        if metadata.is_read_only() or metadata.is_required():\n            raise NoAccess()\n        if (accessibility_type._my_map['id']) not in self._my_map['accessibility_type']:\n            raise NotFound()\n        self._my_map['accessibility_types'].remove(accessibility_type._my_map['id'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the copyright url.", "response": "def set_url(self, url=None):\n        \"\"\"Sets the url.\n\n        :param url: the new copyright\n        :type url: ``string``\n        :raise: ``InvalidArgument`` -- ``url`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``url`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if url is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['url'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(url, metadata, array=False):\n            self._my_map['url'] = url\n        else:\n            raise InvalidArgument()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the next AssetContent in this list.", "response": "def get_next_asset_content(self):\n        \"\"\"Gets the next AssetContent in this list.\n\n        return: (osid.repository.AssetContent) - the next AssetContent\n                in this list. The has_next() method should be used to\n                test that a next AssetContent is available before\n                calling this method.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_next_repository(self):\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object", "response": "Gets the next Repository in this list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_item_lookup_session(self):\n        if not self.supports_item_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the item lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the item lookup service for the given bank.", "response": "def get_item_lookup_session_for_bank(self, bank_id):\n        \"\"\"Gets the ``OsidSession`` associated with the item lookup service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        return: (osid.assessment.ItemLookupSession) - ``an\n                _item_lookup_session``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_item_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_item_lookup()`` and ``supports_visible_federation()``\n        are ``true``.*\n\n        \"\"\"\n        if not self.supports_item_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ItemLookupSession(bank_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_item_query_session(self):\n        if not self.supports_item_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemQuerySession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the item query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_item_query_session_for_bank(self, bank_id):\n        if not self.supports_item_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ItemQuerySession(bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the item query service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the notification session for notifications pertaining to item changes.", "response": "def get_item_notification_session(self, item_receiver):\n        \"\"\"Gets the notification session for notifications pertaining to item changes.\n\n        arg:    item_receiver (osid.assessment.ItemReceiver): the item\n                receiver interface\n        return: (osid.assessment.ItemNotificationSession) - an\n                ``ItemNotificationSession``\n        raise:  NullArgument - ``item_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_item_notification()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_item_notification()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_item_notification():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemNotificationSession(runtime=self._runtime, receiver=item_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the item notification service for the given bank.", "response": "def get_item_notification_session_for_bank(self, item_receiver, bank_id):\n        \"\"\"Gets the ``OsidSession`` associated with the item notification service for the given bank.\n\n        arg:    item_receiver (osid.assessment.ItemReceiver): the item\n                receiver interface\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        return: (osid.assessment.AssessmentNotificationSession) - ``an\n                _item_notification_session``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``item_receiver`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_item_notification()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_item_notification()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_item_notification():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ItemNotificationSession(bank_id, runtime=self._runtime, receiver=item_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_item_bank_session(self):\n        if not self.supports_item_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemBankSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the item banking service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the OsidSession associated with the item bank assignment service.", "response": "def get_item_bank_assignment_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the item bank assignment service.\n\n        return: (osid.assessment.ItemBankAssignmentSession) - an\n                ``ItemBankAssignmentSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_item_bank_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_item_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_item_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemBankAssignmentSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessment_admin_session(self):\n        if not self.supports_assessment_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentAdminSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment administration service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the OsidSession associated with the assessment admin service for the given bank.", "response": "def get_assessment_admin_session_for_bank(self, bank_id):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment admin service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        return: (osid.assessment.AssessmentAdminSession) - ``an\n                _assessment_admin_session``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_assessment_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentAdminSession(bank_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the notification session for notifications pertaining to assessment changes.", "response": "def get_assessment_notification_session(self, assessment_receiver):\n        \"\"\"Gets the notification session for notifications pertaining to assessment changes.\n\n        arg:    assessment_receiver\n                (osid.assessment.AssessmentReceiver): the assessment\n                receiver interface\n        return: (osid.assessment.AssessmentNotificationSession) - an\n                ``AssessmentNotificationSession``\n        raise:  NullArgument - ``assessment_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_notification()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_notification()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_notification():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemNotificationSession(runtime=self._runtime, receiver=assessment_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_notification_session_for_bank(self, assessment_receiver, bank_id):\n        if not self.supports_assessment_notification():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ItemNotificationSession(bank_id, runtime=self._runtime, receiver=assessment_receiver)", "response": "Gets the OsidSession associated with the assessment notification service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessment_offered_lookup_session(self):\n        if not self.supports_assessment_offered_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment offered lookup service."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the OsidSession associated with the assessment offered lookup service for the given bank.", "response": "def get_assessment_offered_lookup_session_for_bank(self, bank_id):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment offered lookup service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        return: (osid.assessment.AssessmentOfferedLookupSession) - an\n                ``AssessmentOfferedLookupSession``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_assessment_offered_lookup()``\n                or ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_offered_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_offered_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedLookupSession(bank_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_assessment_offered_query_session(self):\n        if not self.supports_assessment_offered_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedQuerySession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment offered query service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessment_offered_query_session_for_bank(self, bank_id):\n        if not self.supports_assessment_offered_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedQuerySession(bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment offered query service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_taken_lookup_session(self):\n        if not self.supports_assessment_taken_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment taken lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessment_taken_lookup_session_for_bank(self, bank_id):\n        if not self.supports_assessment_taken_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenLookupSession(bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment taken lookup service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_taken_query_session(self):\n        if not self.supports_assessment_taken_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenQuerySession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment taken query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessment_taken_query_session_for_bank(self, bank_id):\n        if not self.supports_assessment_taken_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenQuerySession(bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment taken query service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the bank lookup service.", "response": "def get_bank_lookup_session(self):\n        \"\"\"Gets the OsidSession associated with the bank lookup service.\n\n        return: (osid.assessment.BankLookupSession) - a\n                ``BankLookupSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bank_lookup() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bank_lookup()`` is true.*\n\n        \"\"\"\n        if not self.supports_bank_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BankLookupSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the bank query service.", "response": "def get_bank_query_session(self):\n        \"\"\"Gets the OsidSession associated with the bank query service.\n\n        return: (osid.assessment.BankQuerySession) - a\n                ``BankQuerySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bank_query() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bank_query()`` is true.*\n\n        \"\"\"\n        if not self.supports_bank_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BankQuerySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the bank administration service.", "response": "def get_bank_admin_session(self):\n        \"\"\"Gets the OsidSession associated with the bank administration service.\n\n        return: (osid.assessment.BankAdminSession) - a\n                ``BankAdminSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bank_admin() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bank_admin()`` is true.*\n\n        \"\"\"\n        if not self.supports_bank_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BankAdminSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the session traversing bank hierarchies.", "response": "def get_bank_hierarchy_session(self):\n        \"\"\"Gets the session traversing bank hierarchies.\n\n        return: (osid.assessment.BankHierarchySession) - a\n                ``BankHierarchySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bank_hierarchy() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bank_hierarchy()`` is true.*\n\n        \"\"\"\n        if not self.supports_bank_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BankHierarchySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting an AssessmentSession which is responsible for taking assessments and examining responses from assessments taken.", "response": "def get_assessment_session(self, proxy):\n        \"\"\"Gets an ``AssessmentSession`` which is responsible for taking assessments and examining responses from assessments taken.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentSession) - an assessment\n                session for this service\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessment_session_for_bank(self, bank_id, proxy):\n        if not self.supports_assessment():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentSession(bank_id, proxy, self._runtime)", "response": "Gets an AssessmentSession which is responsible for performing assessments for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_results_session(self, proxy):\n        if not self.supports_assessment_results():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentResultsSession(proxy=proxy, runtime=self._runtime)", "response": "Gets an AssessmentResultsSession to retrieve assessment results for the given service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_results_session_for_bank(self, bank_id, proxy):\n        if not self.supports_assessment_results():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentResultsSession(bank_id, proxy, self._runtime)", "response": "Gets an AssessmentResultsSession to retrieve assessment results for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_item_search_session(self, proxy):\n        if not self.supports_item_search():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemSearchSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the item search service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the item search service for the given bank.", "response": "def get_item_search_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the item search service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.ItemSearchSession) - ``an\n                _item_search_session``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``porxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_item_search()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_item_search()`` and ``supports_visible_federation()``\n        are ``true``.*\n\n        \"\"\"\n        if not self.supports_item_search():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ItemSearchSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_item_admin_session(self, proxy):\n        if not self.supports_item_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ItemAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the item administration service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the item admin service for the given bank.", "response": "def get_item_admin_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the item admin service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.ItemAdminSession) - ``an\n                _item_admin_session``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_item_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_item_admin()`` and ``supports_visible_federation()``\n        are ``true``.*\n\n        \"\"\"\n        if not self.supports_item_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ItemAdminSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessment_lookup_session(self, proxy):\n        if not self.supports_assessment_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the assessment lookup service for the given bank.", "response": "def get_assessment_lookup_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment lookup service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentLookupSession) - ``an\n                _assessment_lookup_session``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_assessment_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentLookupSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessment_query_session(self, proxy):\n        if not self.supports_assessment_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentQuerySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_query_session_for_bank(self, bank_id, proxy):\n        if not self.supports_assessment_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentQuerySession(bank_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the assessment query service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the assessment banking service.", "response": "def get_assessment_bank_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment banking service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentBankSession) - an\n                ``AssessmentBankSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_bank()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_bank()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentBankSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_assessment_bank_assignment_session(self, proxy):\n        if not self.supports_assessment_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentBankAssignmentSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment bank assignment service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the assessment authoring service.", "response": "def get_assessment_basic_authoring_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment authoring service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentBasicAuthoringSession) - an\n                ``AssessmentBasicAuthoringSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_basic_authoring()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_basic_authoring()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_basic_authoring():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentBasicAuthoringSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the assessment authoring service for the given bank.", "response": "def get_assessment_basic_authoring_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment authoring service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of a bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentBasicAuthoringSession) - an\n                ``AssessmentBasicAuthoringSession``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_basic_authoring()`` or\n                ``supports_visibe_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_basic_authoring()`` and\n        ``supports_visibe_federation()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_basic_authoring():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentBasicAuthoringSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_offered_admin_session(self, proxy):\n        if not self.supports_assessment_offered_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment offered administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessment_offered_admin_session_for_bank(self, bank_id, proxy):\n        if not self.supports_assessment_offered_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedAdminSession(bank_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the assessment offered admin service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_offered_bank_session(self, proxy):\n        if not self.supports_assessment_offered_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedBankSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment offered bank service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the assessment offered assessments to bank mappings.", "response": "def get_assessment_offered_bank_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning offered assessments to bank mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentOfferedBankAssignmentSession)\n                - an ``AssessmentOfferedBankAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_offered_bank_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_offered_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_offered_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentOfferedBankAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_taken_admin_session(self, proxy):\n        if not self.supports_assessment_taken_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment taken administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the assessment taken admin service for the given bank.", "response": "def get_assessment_taken_admin_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment taken admin service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentTakenAdminSession) - an\n                ``AssessmentTakenSearchSession``\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_assessment_taken_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_taken_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_taken_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenAdminSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_taken_bank_session(self, proxy):\n        if not self.supports_assessment_taken_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenBankSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment taken bank service."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the session for assigning taken assessments to bank mappings.", "response": "def get_assessment_taken_bank_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning taken assessments to bank mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.AssessmentTakenBankAssignmentSession) -\n                an ``AssessmentTakenBankAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_taken_bank_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_taken_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_taken_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentTakenBankAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the session designing bank hierarchies.", "response": "def get_bank_hierarchy_design_session(self, proxy):\n        \"\"\"Gets the session designing bank hierarchies.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.BankHierarchyDesignSession) - a\n                ``BankHierarchySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bank_hierarchy_design() is\n                false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bank_hierarchy_design()`` is true.*\n\n        \"\"\"\n        if not self.supports_bank_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BankHierarchyDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nallow adding or overriding env vars in the execution context.", "response": "def env(self, **kw):\n        '''\n        Allows adding/overriding env vars in the execution context.\n        :param kw: Key-value pairs\n        :return: self\n        '''\n        self._original_env = kw\n        if self._env is None:\n            self._env = dict(os.environ)\n        self._env.update({k: unicode(v) for k, v in kw.iteritems()})\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expand(self, expand):\n        '''\n        Turn off argument expansion, useful for 'grep'. Example:\n\n            Sh('grep .*').expand(False) > 'tango'\n\n        :param expand: True or False\n        :return: self\n        '''\n        self._expand = expand\n        cmd = self._original_cmd\n        if len(cmd) == 1:\n            if not type(cmd[0]) in (str, unicode):\n                cmd = cmd[0]\n            else:\n                cmd = shlex.split(cmd[0])\n        cmd = [os.path.expanduser(os.path.expandvars(arg)) for arg in cmd]\n        self._cmd, self._args = cmd[0], cmd[1:]\n        return self", "response": "Turn off argument expansion useful for grep."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef returncode(self):\n        '''\n        Runs the command if it has not yet run (redirecting output to stdout).\n        :return: The returncode of the last executed command in the chain.\n        '''\n        if not self._pop:\n            self > sys.stdout\n        link = self\n        while link is not None:\n            if link._pop:\n                return link._pop.returncode\n        return None", "response": "Returns the returncode of the last executed command in the chain."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reset(self):\n        '''\n        Allows you to re-run the command chain.\n        :return: self\n        '''\n        t = self\n        while t._output is not None:\n            t = t._output\n        while t is not None:\n            if t._pop and t._pop.returncode is None:\n                t._pop.kill()\n                t._pop.wait()\n            del t._pop\n            t._pop = None\n            t = t._input\n        return self", "response": "Resets the internal state of the object to its original state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _append(self, sh):\n        '''\n        Internal. Chains a command after this.\n        :param sh: Next command.\n        '''\n        sh._input = self\n        self._output = sh\n        if self._env:\n            sh._env = dict(self._env)\n        if self._cwd:\n            sh._cwd = self._cwd", "response": "Internal. Chains a command after this."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _run(self, stdout=subprocess.PIPE):\n        '''\n        Internal. Starts running this command and those before it. Can only\n        be called once.\n        :param stdout: Where to send stdout for this link in the chain.\n        '''\n        assert self._pop is None\n        if self._input is not None:\n            self._input._run()\n\n        cwd = (self._cwd if self._cwd else os.getcwd()) + '/'\n\n        def glob_or(expr):\n            res = [expr]\n            if self._expand and ('*' in expr or '?' in expr):\n                if expr and expr[0] != '/':\n                    expr = cwd + expr\n                res = glob.glob(expr)\n                if not res:\n                    res = [expr]\n            return res\n\n        args = [glob_or(arg) for arg in self._args]\n        stderr = subprocess.STDOUT if self._err_to_out else None\n        assert not self._stdin or self._input is None, \"*** ERROR: Stdin must be none outside of head of chain.\"\n        stdin = self._stdin if self._input is None else self._input._pop.stdout\n        if stdin is not None and getattr(stdin, 'fileno', None) is None:\n            stdin = subprocess.PIPE\n        cmd = [self._cmd] + list(itertools.chain.from_iterable(args))\n        if self.debug:\n            print \"*** DEBUG: Run\", cmd\n        try:\n            self._pop = subprocess.Popen(cmd, stdin=stdin, stdout=stdout, stderr=stderr,\n                                         close_fds=True, cwd=self._cwd, env=self._env)\n            if stdin == subprocess.PIPE:\n                try:\n                    # TODO: Write a non-blocking reader-writer to ship data here\n                    self._pop.stdin.write(self._stdin.read())\n                except AttributeError:\n                    self._pop.stdin.write(self._stdin)\n        except OSError:\n            print \"*** ERROR: %r failed at %r\" % (self, self._original_cmd)\n            raise", "response": "Internal. Starts running this command and those before it. Can only be called once."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _stream_out(self, outfile, append=False):\n        '''\n        Internal. Writes all stdout into outfile.\n        :param outfile: Filename or file-like object for writing.\n        :param append: Opens filename with append.\n        :return: This command's returncode.\n        '''\n        if type(outfile) in (str, unicode):\n            outfile = os.path.expanduser(os.path.expandvars(outfile))\n            outfile = open(outfile, 'a' if append else 'w')\n        self._run(outfile)\n        self._pop.wait()", "response": "Internal. Writes all stdout into outfile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pipe(cls, input):\n        '''\n        Creates a stdin source for Sh object chains.\n        :param input: If string; open as filename, if iterable, send iterated content into next command,\n        if none of the above assume file like object.\n\n        To input a string as content source, wrap in iterable:\n\n        print 'Lines in \"my_input_string\":', Sh.pipe([my_string_input]) | 'wc -l'\n        :return: Stdin object for chaining Sh commands after.\n\n        WARNING: If iterable is an endless generator command evaluation will never complete.\n        '''\n        if type(input) in (str, unicode):\n            return cls.Stdin.from_file(input)\n        try:\n            return cls.Stdin.from_iterator(iter(input))\n        except TypeError:\n            pass\n        return cls.Stdin.from_file(input)", "response": "Create a stdin source for chaining Sh commands after."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns class or module object. if the argument is only a module name and return a module object. if the argument is a module and class name, and return a class object.", "response": "def helper_import(module_name, class_name=None):\n    \"\"\"\n    Return class or module object.\n    if the argument is only a module name and return a module object.\n    if the argument is a module and class name, and return a class object.\n    \"\"\"\n    try:\n        module = __import__(module_name, globals(), locals(), [class_name])\n    except (BlackbirdError, ImportError) as error:\n        raise BlackbirdError(\n            'can not load {0} module [{1}]'\n            ''.format(module_name, str(error))\n        )\n\n    if not class_name:\n        return module\n    else:\n        try:\n            return getattr(module, class_name)\n        except:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef global_import(mod_name):\n    mod_tuple = imp.find_module(mod_name, sys.path[1:])\n    mod = imp.load_module(mod_name, mod_tuple[0], mod_tuple[1], mod_tuple[2])\n\n    return mod", "response": "This function imports a module and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncollects all of the repositories in the current working directory.", "response": "def gather_repositories():\n    \"\"\"\n    Collects all of the repositories. The current implementation\n    searches for them in the current working directory.\n    \"\"\"\n\n    for (root, dirs, files) in os.walk('.', topdown=True):\n        if '.git' not in dirs:\n            continue\n\n        for dir in list(dirs):\n            dirs.remove(dir)\n\n        path = os.path.split(root)[1]\n        repo = os.path.basename(path)\n        yield (repo, root)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun given command on all repos and checks if exit is True.", "response": "def run(command, exit, silent, check):\n    \"\"\"\n    Runs given command on all repos and checks status\n\n        $ maintain repo run -- git checkout master\n    \"\"\"\n\n    status = 0\n\n    for (repo, path) in gather_repositories():\n        if check and not check_repo(repo, path):\n            status = 1\n\n            if exit:\n                break\n\n            continue\n\n        with chdir(path):\n            result = subprocess.run(command, shell=True, capture_output=silent)\n            if result.returncode != 0:\n                status = result.returncode\n\n                print('Command failed: {}'.format(repo))\n\n                if exit:\n                    break\n\n    sys.exit(status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(inp, format=None, encoding='utf-8', force_types=True):\n    proper_inp = inp\n    if hasattr(inp, 'read'):\n        proper_inp = inp.read()\n    # if proper_inp is unicode, encode it\n    if isinstance(proper_inp, six.text_type):\n        proper_inp = proper_inp.encode(encoding)\n\n    # try to guess markup type\n    fname = None\n    if hasattr(inp, 'name'):\n        fname = inp.name\n    fmt = _get_format(format, fname, proper_inp)\n\n    # make it look like file-like bytes-yielding object\n    proper_inp = six.BytesIO(proper_inp)\n\n    try:\n        res = _do_parse(proper_inp, fmt, encoding, force_types)\n    except Exception as e:\n        # I wish there was only Python 3 and I could just use \"raise ... from e\"\n        raise AnyMarkupError(e, traceback.format_exc())\n    if res is None:\n        res = {}\n\n    return res", "response": "Parse input from file - like object unicode string or byte string with markup type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_file(path, format=None, encoding='utf-8', force_types=True):\n    try:\n        with open(path, 'rb') as f:\n            return parse(f, format, encoding, force_types)\n    except EnvironmentError as e:\n        raise AnyMarkupError(e, traceback.format_exc())", "response": "A convenience wrapper of parse which accepts path of file to parse."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize(struct, format, target=None, encoding='utf-8'):\n    # raise if \"unicode-opened\"\n    if hasattr(target, 'encoding') and target.encoding:\n        raise AnyMarkupError('Input file must be opened in binary mode')\n\n    fname = None\n    if hasattr(target, 'name'):\n        fname = target.name\n\n    fmt = _get_format(format, fname)\n\n    try:\n        serialized = _do_serialize(struct, fmt, encoding)\n        if target is None:\n            return serialized\n        else:\n            return target.write(serialized)\n    except Exception as e:\n        raise AnyMarkupError(e, traceback.format_exc())", "response": "Serialize given structure and return it as encoded string or write it to target."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _do_parse(inp, fmt, encoding, force_types):\n    res = {}\n    _check_lib_installed(fmt, 'parse')\n\n    if fmt == 'ini':\n        cfg = configobj.ConfigObj(inp, encoding=encoding)\n        res = cfg.dict()\n    elif fmt == 'json':\n        if six.PY3:\n            # python 3 json only reads from unicode objects\n            inp = io.TextIOWrapper(inp, encoding=encoding)\n        res = json.load(inp, encoding=encoding)\n    elif fmt == 'json5':\n        if six.PY3:\n            inp = io.TextIOWrapper(inp, encoding=encoding)\n        res = json5.load(inp, encoding=encoding)\n    elif fmt == 'toml':\n        if not _is_utf8(encoding):\n            raise AnyMarkupError('toml is always utf-8 encoded according to specification')\n        if six.PY3:\n            # python 3 toml prefers unicode objects\n            inp = io.TextIOWrapper(inp, encoding=encoding)\n        res = toml.load(inp)\n    elif fmt == 'xml':\n        res = xmltodict.parse(inp, encoding=encoding)\n    elif fmt == 'yaml':\n        # guesses encoding by its own, there seems to be no way to pass\n        #  it explicitly\n        res = yaml.safe_load(inp)\n    else:\n        raise  # unknown format\n\n    # make sure it's all unicode and all int/float values were parsed correctly\n    #   the unicode part is here because of yaml on PY2 and also as workaround for\n    #   https://github.com/DiffSK/configobj/issues/18#issuecomment-76391689\n    return _ensure_proper_types(res, encoding, force_types)", "response": "Actually parse input.\n\n    Args:\n        inp: bytes yielding file-like object\n        fmt: format to use for parsing\n        encoding: encoding of `inp`\n        force_types:\n            if `True`, integers, floats, booleans and none/null\n                are recognized and returned as proper types instead of strings;\n            if `False`, everything is converted to strings\n            if `None`, backend return value is used\n    Returns:\n        parsed `inp` (dict or list) containing unicode values\n    Raises:\n        various sorts of errors raised by used libraries while parsing"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _do_serialize(struct, fmt, encoding):\n    res = None\n    _check_lib_installed(fmt, 'serialize')\n\n    if fmt == 'ini':\n        config = configobj.ConfigObj(encoding=encoding)\n        for k, v in struct.items():\n            config[k] = v\n        res = b'\\n'.join(config.write())\n    elif fmt in ['json', 'json5']:\n        # specify separators to get rid of trailing whitespace\n        # specify ensure_ascii to make sure unicode is serialized in \\x... sequences,\n        #  not in \\u sequences\n        res = (json if fmt == 'json' else json5).dumps(struct,\n                                                       indent=2,\n                                                       separators=(',', ': '),\n                                                       ensure_ascii=False).encode(encoding)\n    elif fmt == 'toml':\n        if not _is_utf8(encoding):\n            raise AnyMarkupError('toml must always be utf-8 encoded according to specification')\n        res = toml.dumps(struct).encode(encoding)\n    elif fmt == 'xml':\n        # passing encoding argument doesn't encode, just sets the xml property\n        res = xmltodict.unparse(struct, pretty=True, encoding='utf-8').encode('utf-8')\n    elif fmt == 'yaml':\n        res = yaml.safe_dump(struct, encoding='utf-8', default_flow_style=False)\n    else:\n        raise  # unknown format\n\n    return res", "response": "Actually serialize input.\n\n    Args:\n        struct: structure to serialize to\n        fmt: format to serialize to\n        encoding: encoding to use while serializing\n    Returns:\n        encoded serialized structure\n    Raises:\n        various sorts of errors raised by libraries while serializing"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _recognize_basic_types(s):\n    tps = [int, float]\n    if not six.PY3:  # compat for older versions of six that don't have PY2\n        tps.append(long)\n    for tp in tps:\n        try:\n            return tp(s)\n        except ValueError:\n            pass\n    if s.lower() == 'true':\n        return True\n    if s.lower() == 'false':\n        return False\n    if s.lower() in ['none', 'null']:\n        return None\n\n    return s", "response": "Given a string s return it."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntry to guess markup format of given input.", "response": "def _get_format(format, fname, inp=None):\n    \"\"\"Try to guess markup format of given input.\n\n    Args:\n        format: explicit format override to use\n        fname: name of file, if a file was used to read `inp`\n        inp: optional bytestring to guess format of (can be None, if markup\n            format is to be guessed only from `format` and `fname`)\n    Returns:\n        guessed format (a key of fmt_to_exts dict)\n    Raises:\n        AnyMarkupError if explicit format override has unsupported value\n            or if it's impossible to guess the format\n    \"\"\"\n    fmt = None\n    err = True\n\n    if format is not None:\n        if format in fmt_to_exts:\n            fmt = format\n            err = False\n    elif fname:\n        # get file extension without leading dot\n        file_ext = os.path.splitext(fname)[1][len(os.path.extsep):]\n        for fmt_name, exts in fmt_to_exts.items():\n            if file_ext in exts:\n                fmt = fmt_name\n                err = False\n\n    if fmt is None:\n        if inp is not None:\n            fmt = _guess_fmt_from_bytes(inp)\n            err = False\n\n    if err:\n        err_string = 'Failed to guess markup format based on: '\n        what = []\n        for k, v in {format: 'specified format argument',\n                     fname: 'filename', inp: 'input string'}.items():\n            if k:\n                what.append(v)\n        if not what:\n            what.append('nothing to guess format from!')\n        err_string += ', '.join(what)\n        raise AnyMarkupError(err_string)\n\n    return fmt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _guess_fmt_from_bytes(inp):\n    stripped = inp.strip()\n    fmt = None\n    ini_section_header_re = re.compile(b'^\\[([\\w-]+)\\]')\n\n    if len(stripped) == 0:\n        # this can be anything, so choose yaml, for example\n        fmt = 'yaml'\n    else:\n        if stripped.startswith(b'<'):\n            fmt = 'xml'\n        else:\n            for l in stripped.splitlines():\n                line = l.strip()\n                # there are C-style comments in json5, but we don't auto-detect it,\n                #  so it doesn't matter here\n                if not line.startswith(b'#') and line:\n                    break\n            # json, ini or yaml => skip comments and then determine type\n            if ini_section_header_re.match(line):\n                fmt = 'ini'\n            else:\n                # we assume that yaml is superset of json\n                # TODO: how do we figure out it's not yaml?\n                fmt = 'yaml'\n\n    return fmt", "response": "Try to guess format of given bytestring."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_farm(farm_name):\n    utils.check_for_cloud_server()\n    utils.check_for_cloud_user()\n    server = Server(config[\"cloud_server\"][\"url\"])\n    username = config[\"cloud_server\"][\"username\"]\n    password = config[\"cloud_server\"][\"password\"]\n    server.log_in(username, password)\n    url = urljoin(server.resource.url, \"_openag\", \"v0.1\", \"register_farm\")\n    status, _, content = server.resource.session.request(\n        \"POST\", url, headers=server.resource.headers.copy(), body={\n            \"name\": username, \"farm_name\": farm_name\n        }, credentials=(username, password)\n    )\n    if status != 200:\n        raise click.ClickException(\n            \"Failed to register farm with cloud server ({}): {}\".format(\n                status, content\n            )\n        )", "response": "Create a farm on the currently selected\n ArcGIS cloud server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist all farms you can manage.", "response": "def list_farms():\n    \"\"\"\n    List all farms you can manage. If you have selected a farm already, the\n    name of that farm will be prefixed with an asterisk in the returned list.\n    \"\"\"\n    utils.check_for_cloud_server()\n    utils.check_for_cloud_user()\n    server = Server(config[\"cloud_server\"][\"url\"])\n    server.log_in(\n        config[\"cloud_server\"][\"username\"], config[\"cloud_server\"][\"password\"]\n    )\n    farms_list = server.get_user_info().get(\"farms\", [])\n    if not len(farms_list):\n        raise click.ClickException(\n            \"No farms exist. Run `openag cloud create_farm` to create one\"\n        )\n    active_farm_name = config[\"cloud_server\"][\"farm_name\"]\n    for farm_name in farms_list:\n        if farm_name == active_farm_name:\n            click.echo(\"*\"+farm_name)\n        else:\n            click.echo(farm_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes a new farm.", "response": "def init_farm(farm_name):\n    \"\"\"\n    Select a farm to use. This command sets up the replication between your\n    local database and the selected cloud server if you have already\n    initialized your local database with the `openag db init` command.\n    \"\"\"\n    utils.check_for_cloud_server()\n    utils.check_for_cloud_user()\n    old_farm_name = config[\"cloud_server\"][\"farm_name\"]\n    if old_farm_name and old_farm_name != farm_name:\n        raise click.ClickException(\n            \"Farm \\\"{}\\\" already initialized. Run `openag cloud deinit_farm` \"\n            \"to deinitialize it\".format(old_farm_name)\n        )\n    if config[\"local_server\"][\"url\"]:\n        utils.replicate_per_farm_dbs(farm_name=farm_name)\n    config[\"cloud_server\"][\"farm_name\"] = farm_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deinit_farm():\n    utils.check_for_cloud_server()\n    utils.check_for_cloud_user()\n    utils.check_for_cloud_farm()\n    farm_name = config[\"cloud_server\"][\"farm_name\"]\n    if farm_name and config[\"local_server\"][\"url\"]:\n        utils.cancel_per_farm_db_replication()\n    config[\"cloud_server\"][\"farm_name\"] = None", "response": "Detaches from the current farm."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_learning_objective_ids(self):\n        if 'learningObjectiveIds' not in self._my_map:  # Will this ever be the case?\n            collection = JSONClientValidated('assessment',\n                                             collection='Item',\n                                             runtime=self._runtime)\n            item_map = collection.find_one({'_id': ObjectId(Id(self._my_map['itemId']).get_identifier())})\n            self._my_map['learningObjectiveIds'] = list(item_map['learningObjectiveIds'])\n        return IdList(self._my_map['learningObjectiveIds'])", "response": "This method returns the list of learning objective ids for the item."}
