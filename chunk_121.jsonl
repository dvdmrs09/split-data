{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_row_to_sdpa_index(block_struct, row_offsets, row):\n    block_index = bisect_left(row_offsets[1:], row + 1)\n    width = block_struct[block_index]\n    row = row - row_offsets[block_index]\n    i, j = divmod(row, width)\n    return block_index, i, j", "response": "Helper function to map row to SDPA index values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_to_sdpa(sdp, filename):\n    # Coefficient matrices\n    row_offsets = [0]\n    cumulative_sum = 0\n    for block_size in sdp.block_struct:\n        cumulative_sum += block_size ** 2\n        row_offsets.append(cumulative_sum)\n    multiplier = 1\n    if sdp.F.dtype == np.complex128:\n        multiplier = 2\n    lines = [[] for _ in range(multiplier*sdp.n_vars+1)]\n    for row in range(len(sdp.F.rows)):\n        if len(sdp.F.rows[row]) > 0:\n            col_index = 0\n            block_index, i, j = convert_row_to_sdpa_index(sdp.block_struct,\n                                                          row_offsets, row)\n            for k in sdp.F.rows[row]:\n                value = sdp.F.data[row][col_index]\n                col_index += 1\n                if k == 0:\n                    value *= -1\n                if sdp.F.dtype == np.float64:\n                    lines[k].append('{0}\\t{1}\\t{2}\\t{3}\\n'.format(\n                        block_index + 1, i + 1, j + 1, value))\n                else:\n                    bs = sdp.block_struct[block_index]\n                    if value.real != 0:\n                        lines[k].append('{0}\\t{1}\\t{2}\\t{3}\\n'.format(\n                            block_index + 1, i + 1, j + 1, value.real))\n                        lines[k].append('{0}\\t{1}\\t{2}\\t{3}\\n'.format(\n                            block_index + 1, i + bs + 1, j + bs + 1,\n                            value.real))\n                    if value.imag != 0:\n                        lines[k + sdp.n_vars].append(\n                            '{0}\\t{1}\\t{2}\\t{3}\\n'.format(\n                                block_index + 1, i + 1, j + bs + 1,\n                                value.imag))\n                        lines[k + sdp.n_vars].append(\n                            '{0}\\t{1}\\t{2}\\t{3}\\n'.format(\n                                block_index + 1, j + 1, i + bs + 1,\n                                -value.imag))\n    file_ = open(filename, 'w')\n    file_.write('\"file ' + filename + ' generated by ncpol2sdpa\"\\n')\n    file_.write(str(multiplier*sdp.n_vars) + ' = number of vars\\n')\n    # bloc structure\n    block_struct = [multiplier*blk_size\n                    for blk_size in sdp.block_struct]\n    file_.write(str(len(block_struct)) + ' = number of blocs\\n')\n    file_.write(str(block_struct).replace('[', '(')\n                .replace(']', ')'))\n    file_.write(' = BlocStructure\\n')\n    # c vector (objective)\n    objective = \\\n        str(list(sdp.obj_facvar)).replace('[', '').replace(']', '')\n    if multiplier == 2:\n        objective += ', ' + objective\n    file_.write('{'+objective+'}\\n')\n    for k, line in enumerate(lines):\n        if line == []:\n            continue\n        for item in line:\n            file_.write('{0}\\t'.format(k)+item)\n    file_.close()", "response": "Write the SDP relaxation to SDPA format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_to_human_readable(sdp):\n\n    objective = \"\"\n    indices_in_objective = []\n    for i, tmp in enumerate(sdp.obj_facvar):\n        candidates = [key for key, v in\n                      sdp.monomial_index.items() if v == i+1]\n        if len(candidates) > 0:\n            monomial = convert_monomial_to_string(candidates[0])\n        else:\n            monomial = \"\"\n        if tmp > 0:\n            objective += \"+\"+str(tmp)+monomial\n            indices_in_objective.append(i)\n        elif tmp < 0:\n            objective += str(tmp)+monomial\n            indices_in_objective.append(i)\n\n    matrix_size = 0\n    cumulative_sum = 0\n    row_offsets = [0]\n    block_offset = [0]\n    for bs in sdp.block_struct:\n        matrix_size += abs(bs)\n        cumulative_sum += bs ** 2\n        row_offsets.append(cumulative_sum)\n        block_offset.append(matrix_size)\n\n    matrix = []\n    for i in range(matrix_size):\n        matrix_line = [\"0\"] * matrix_size\n        matrix.append(matrix_line)\n\n    for row in range(len(sdp.F.rows)):\n        if len(sdp.F.rows[row]) > 0:\n            col_index = 0\n            for k in sdp.F.rows[row]:\n                value = sdp.F.data[row][col_index]\n                col_index += 1\n                block_index, i, j = convert_row_to_sdpa_index(\n                    sdp.block_struct, row_offsets, row)\n                candidates = [key for key, v in\n                              sdp.monomial_index.items()\n                              if v == k]\n                if len(candidates) > 0:\n                    monomial = convert_monomial_to_string(candidates[0])\n                else:\n                    monomial = \"\"\n                offset = block_offset[block_index]\n                if matrix[offset+i][offset+j] == \"0\":\n                    matrix[offset+i][offset+j] = (\"%s%s\" % (value, monomial))\n                else:\n                    if value.real > 0:\n                        matrix[offset+i][offset+j] += (\"+%s%s\" % (value,\n                                                                  monomial))\n                    else:\n                        matrix[offset+i][offset+j] += (\"%s%s\" % (value,\n                                                                 monomial))\n    return objective, matrix", "response": "Convert the SDP relaxation to a human - readable format."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the SDP relaxation to a human - readable format.", "response": "def write_to_human_readable(sdp, filename):\n    \"\"\"Write the SDP relaxation to a human-readable format.\n\n    :param sdp: The SDP relaxation to write.\n    :type sdp: :class:`ncpol2sdpa.sdp`.\n    :param filename: The name of the file.\n    :type filename: str.\n    \"\"\"\n    objective, matrix = convert_to_human_readable(sdp)\n    f = open(filename, 'w')\n    f.write(\"Objective:\" + objective + \"\\n\")\n    for matrix_line in matrix:\n        f.write(str(list(matrix_line)).replace('[', '').replace(']', '')\n                .replace('\\'', ''))\n        f.write('\\n')\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_header(url,\n                access_key=None,\n                secret_key=None):\n    ''' create request header function\n    :param url: URL for the new :class:`Request` object.\n    '''\n    nonce = nounce()\n    url    = url\n    message = nonce + url\n    signature = hmac.new(secret_key.encode('utf-8'), message.encode('utf-8'), hashlib.sha256).hexdigest()\n    headers = {\n       'ACCESS-KEY'      : access_key,\n       'ACCESS-NONCE'    : nonce,\n       'ACCESS-SIGNATURE': signature\n    }\n    return headers", "response": "create request header function\n    :param url: URL for the new :class:`Request` object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unget_bytes(self, string):\n\n        self.unprocessed_bytes.extend(string[i:i + 1]\n                                      for i in range(len(string)))", "response": "Adds bytes to be internal buffer to be read\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _wait_for_read_ready_or_timeout(self, timeout):\n        remaining_timeout = timeout\n        t0 = time.time()\n        while True:\n            try:\n                (rs, _, _) = select.select(\n                    [self.in_stream.fileno()] + self.readers,\n                    [], [], remaining_timeout)\n                if not rs:\n                    return False, None\n                r = rs[0]  # if there's more than one, get it in the next loop\n                if r == self.in_stream.fileno():\n                    return True, None\n                else:\n                    os.read(r, 1024)\n                    if self.queued_interrupting_events:\n                        return False, self.queued_interrupting_events.pop(0)\n                    elif remaining_timeout is not None:\n                        remaining_timeout = max(0, t0 + timeout - time.time())\n                        continue\n                    else:\n                        continue\n\n            except select.error:\n                if self.sigints:\n                    return False, self.sigints.pop()\n                if remaining_timeout is not None:\n                    remaining_timeout = max(timeout - (time.time() - t0), 0)", "response": "Wait for stdin to read and an event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an event or None if no events occur before timeout.", "response": "def send(self, timeout=None):\n        \"\"\"Returns an event or None if no events occur before timeout.\"\"\"\n        if self.sigint_event and is_main_thread():\n            with ReplacedSigIntHandler(self.sigint_handler):\n                return self._send(timeout)\n        else:\n            return self._send(timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _nonblocking_read(self):\n        with Nonblocking(self.in_stream):\n            if PY3:\n                try:\n                    data = os.read(self.in_stream.fileno(), READ_SIZE)\n                except BlockingIOError:\n                    return 0\n                if data:\n                    self.unprocessed_bytes.extend(data[i:i+1] for i in range(len(data)))\n                    return len(data)\n                else:\n                    return 0\n            else:\n                try:\n                    data = os.read(self.in_stream.fileno(), READ_SIZE)\n                except OSError:\n                    return 0\n                else:\n                    self.unprocessed_bytes.extend(data)\n                    return len(data)", "response": "Returns the number of characters read and adds them to self. unread_bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef event_trigger(self, event_type):\n        def callback(**kwargs):\n            self.queued_events.append(event_type(**kwargs))\n        return callback", "response": "Returns a callback that creates events.\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a callback that schedules events for the future.", "response": "def scheduled_event_trigger(self, event_type):\n        \"\"\"Returns a callback that schedules events for the future.\n\n        Returned callback function will add an event of type event_type\n        to a queue which will be checked the next time an event is requested.\"\"\"\n        def callback(when, **kwargs):\n            self.queued_scheduled_events.append((when, event_type(when=when, **kwargs)))\n        return callback"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef threadsafe_event_trigger(self, event_type):\n        readfd, writefd = os.pipe()\n        self.readers.append(readfd)\n\n        def callback(**kwargs):\n            self.queued_interrupting_events.append(event_type(**kwargs))  #TODO use a threadsafe queue for this\n            logger.warning('added event to events list %r', self.queued_interrupting_events)\n            os.write(writefd, b'interrupting event!')\n        return callback", "response": "Returns a callback function to create events interrupting current event requests."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsolving the SDP relaxation.", "response": "def solve_sdp(sdp, solver=None, solverparameters=None):\n    \"\"\"Call a solver on the SDP relaxation. Upon successful solution, it\n    returns the primal and dual objective values along with the solution\n    matrices.\n\n    :param sdpRelaxation: The SDP relaxation to be solved.\n    :type sdpRelaxation: :class:`ncpol2sdpa.SdpRelaxation`.\n    :param solver: The solver to be called, either `None`, \"sdpa\", \"mosek\",\n                   \"cvxpy\", \"scs\", or \"cvxopt\". The default is `None`,\n                   which triggers autodetect.\n    :type solver: str.\n    :param solverparameters: Parameters to be passed to the solver. Actual\n                             options depend on the solver:\n\n                             SDPA:\n\n                               - `\"executable\"`:\n                                 Specify the executable for SDPA. E.g.,\n                                 `\"executable\":\"/usr/local/bin/sdpa\"`, or\n                                 `\"executable\":\"sdpa_gmp\"`\n                               - `\"paramsfile\"`: Specify the parameter file\n\n                             Mosek:\n                             Refer to the Mosek documentation. All\n                             arguments are passed on.\n\n                             Cvxopt:\n                             Refer to the PICOS documentation. All\n                             arguments are passed on.\n\n                             Cvxpy:\n                             Refer to the Cvxpy documentation. All\n                             arguments are passed on.\n\n                             SCS:\n                             Refer to the Cvxpy documentation. All\n                             arguments are passed on.\n    :type solverparameters: dict of str.\n    :returns: tuple of the primal and dual optimum, and the solutions for the\n              primal and dual.\n    :rtype: (float, float, list of `numpy.array`, list of `numpy.array`)\n    \"\"\"\n    solvers = autodetect_solvers(solverparameters)\n    solver = solver.lower() if solver is not None else solver\n    if solvers == []:\n        raise Exception(\"Could not find any SDP solver. Please install SDPA,\" +\n                        \" Mosek, Cvxpy, or Picos with Cvxopt\")\n    elif solver is not None and solver not in solvers:\n        print(\"Available solvers: \" + str(solvers))\n        if solver == \"cvxopt\":\n            try:\n                import cvxopt\n            except ImportError:\n                pass\n            else:\n                raise Exception(\"Cvxopt is detected, but Picos is not. \"\n                                \"Please install Picos to use Cvxopt\")\n        raise Exception(\"Could not detect requested \" + solver)\n    elif solver is None:\n        solver = solvers[0]\n    primal, dual, x_mat, y_mat, status = None, None, None, None, None\n    tstart = time.time()\n    if solver == \"sdpa\":\n        primal, dual, x_mat, y_mat, status = \\\n          solve_with_sdpa(sdp, solverparameters)\n    elif solver == \"cvxpy\":\n        primal, dual, x_mat, y_mat, status = \\\n          solve_with_cvxpy(sdp, solverparameters)\n    elif solver == \"scs\":\n        if solverparameters is None:\n            solverparameters_ = {\"solver\": \"SCS\"}\n        else:\n            solverparameters_ = solverparameters.copy()\n            solverparameters_[\"solver\"] = \"SCS\"\n        primal, dual, x_mat, y_mat, status = \\\n          solve_with_cvxpy(sdp, solverparameters_)\n    elif solver == \"mosek\":\n        primal, dual, x_mat, y_mat, status = \\\n          solve_with_mosek(sdp, solverparameters)\n    elif solver == \"cvxopt\":\n        primal, dual, x_mat, y_mat, status = \\\n          solve_with_cvxopt(sdp, solverparameters)\n        # We have to compensate for the equality constraints\n        for constraint in sdp.constraints[sdp._n_inequalities:]:\n            idx = sdp._constraint_to_block_index[constraint]\n            sdp._constraint_to_block_index[constraint] = (idx[0],)\n    else:\n        raise Exception(\"Unkown solver: \" + solver)\n    sdp.solution_time = time.time() - tstart\n    sdp.primal = primal\n    sdp.dual = dual\n    sdp.x_mat = x_mat\n    sdp.y_mat = y_mat\n    sdp.status = status\n    return primal, dual, x_mat, y_mat"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a dual problem returns the SOS decomposition of the dual problem.", "response": "def get_sos_decomposition(sdp, y_mat=None, threshold=0.0):\n    \"\"\"Given a solution of the dual problem, it returns the SOS\n    decomposition.\n\n    :param sdp: The SDP relaxation to be solved.\n    :type sdp: :class:`ncpol2sdpa.sdp`.\n    :param y_mat: Optional parameter providing the dual solution of the\n                  moment matrix. If not provided, the solution is extracted\n                  from the sdp object.\n    :type y_mat: :class:`numpy.array`.\n    :param threshold: Optional parameter for specifying the threshold value\n                      below which the eigenvalues and entries of the\n                      eigenvectors are disregarded.\n    :type threshold: float.\n    :returns: The SOS decomposition of [sigma_0, sigma_1, ..., sigma_m]\n    :rtype: list of :class:`sympy.core.exp.Expr`.\n    \"\"\"\n    if len(sdp.monomial_sets) != 1:\n        raise Exception(\"Cannot automatically match primal and dual \" +\n                        \"variables.\")\n    elif len(sdp.y_mat[1:]) != len(sdp.constraints):\n        raise Exception(\"Cannot automatically match constraints with blocks \" +\n                        \"in the dual solution.\")\n    elif sdp.status == \"unsolved\" and y_mat is None:\n        raise Exception(\"The SDP relaxation is unsolved and dual solution \" +\n                        \"is not provided!\")\n    elif sdp.status != \"unsolved\" and y_mat is None:\n        y_mat = sdp.y_mat\n    sos = []\n    for y_mat_block in y_mat:\n        term = 0\n        vals, vecs = np.linalg.eigh(y_mat_block)\n        for j, val in enumerate(vals):\n            if val < -0.001:\n                raise Exception(\"Large negative eigenvalue: \" + val +\n                                \". Matrix cannot be positive.\")\n            elif val > 0:\n                sub_term = 0\n                for i, entry in enumerate(vecs[:, j]):\n                    sub_term += entry * sdp.monomial_sets[0][i]\n                term += val * sub_term**2\n        term = expand(term)\n        new_term = 0\n        if term.is_Mul:\n            elements = [term]\n        else:\n            elements = term.as_coeff_mul()[1][0].as_coeff_add()[1]\n        for element in elements:\n            _, coeff = separate_scalar_factor(element)\n            if abs(coeff) > threshold:\n                new_term += element\n        sos.append(new_term)\n    return sos"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a solution of the dual problem and a monomial, it returns the inner product of the corresponding coefficient matrix and the dual solution. It can be restricted to certain blocks. :param sdp: The SDP relaxation. :type sdp: :class:`ncpol2sdpa.sdp`. :param monomial: The monomial for which the value is requested. :type monomial: :class:`sympy.core.exp.Expr`. :param monomial: The monomial for which the value is requested. :type monomial: :class:`sympy.core.exp.Expr`. :param blocks: Optional parameter to specify the blocks to be included. :type blocks: list of `int`. :returns: The value of the monomial in the solved relaxation. :rtype: float.", "response": "def extract_dual_value(sdp, monomial, blocks=None):\n    \"\"\"Given a solution of the dual problem and a monomial, it returns the\n    inner product of the corresponding coefficient matrix and the dual\n    solution. It can be restricted to certain blocks.\n\n    :param sdp: The SDP relaxation.\n    :type sdp: :class:`ncpol2sdpa.sdp`.\n    :param monomial: The monomial for which the value is requested.\n    :type monomial: :class:`sympy.core.exp.Expr`.\n    :param monomial: The monomial for which the value is requested.\n    :type monomial: :class:`sympy.core.exp.Expr`.\n    :param blocks: Optional parameter to specify the blocks to be included.\n    :type blocks: list of `int`.\n    :returns: The value of the monomial in the solved relaxation.\n    :rtype: float.\n    \"\"\"\n    if sdp.status == \"unsolved\":\n        raise Exception(\"The SDP relaxation is unsolved!\")\n    if blocks is None:\n        blocks = [i for i, _ in enumerate(sdp.block_struct)]\n    if is_number_type(monomial):\n        index = 0\n    else:\n        index = sdp.monomial_index[monomial]\n    row_offsets = [0]\n    cumulative_sum = 0\n    for block_size in sdp.block_struct:\n        cumulative_sum += block_size ** 2\n        row_offsets.append(cumulative_sum)\n    result = 0\n    for row in range(len(sdp.F.rows)):\n        if len(sdp.F.rows[row]) > 0:\n            col_index = 0\n            for k in sdp.F.rows[row]:\n                if k != index:\n                    continue\n                value = sdp.F.data[row][col_index]\n                col_index += 1\n                block_index, i, j = convert_row_to_sdpa_index(\n                    sdp.block_struct, row_offsets, row)\n                if block_index in blocks:\n                    result += -value*sdp.y_mat[block_index][i][j]\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a complete CC number.", "response": "def completed_number(prefix, length):\n    \"\"\"\n    'prefix' is the start of the CC number as a string, any number of digits.\n    'length' is the length of the CC number to generate. Typically 13 or 16\n    \"\"\"\n    ccnumber = prefix\n    # generate digits\n    while len(ccnumber) < (length - 1):\n        digit = random.choice(['0',  '1', '2', '3', '4', '5', '6', '7', '8', '9'])\n        ccnumber.append(digit)\n    # Calculate sum \n    sum = 0\n    pos = 0\n    reversedCCnumber = []\n    reversedCCnumber.extend(ccnumber)\n    reversedCCnumber.reverse()\n    while pos < length - 1:\n        odd = int( reversedCCnumber[pos] ) * 2\n        if odd > 9:\n            odd -= 9\n        sum += odd\n        if pos != (length - 2):\n            sum += int( reversedCCnumber[pos+1] )\n        pos += 2\n    # Calculate check digit\n    checkdigit = ((sum / 10 + 1) * 10 - sum) % 10\n    ccnumber.append( str(int(checkdigit)) )\n    return ''.join(ccnumber)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_module(self, fullname):\n        mod = super(JsonLoader, self).load_module(fullname)\n\n        try:\n            with codecs.open(self.cfg_file, 'r', 'utf-8') as f:\n                mod.__dict__.update(json.load(f))\n        except ValueError:\n            # if raise here, traceback will contain ValueError\n            self.e = \"ValueError\"\n            self.err_msg = sys.exc_info()[1]\n\n        if self.e == \"ValueError\":\n            err_msg = \"\\nJson file not valid: \"\n            err_msg += self.cfg_file + '\\n'\n            err_msg += str(self.err_msg)\n            raise InvalidJsonError(err_msg)\n\n        return mod", "response": "Loads the specified module and updates the object with the data from it."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a message from tick if game is over", "response": "def process_event(self, c):\n        \"\"\"Returns a message from tick() to be displayed if game is over\"\"\"\n        if c == \"\u0004\":\n            sys.exit()\n        elif c in key_directions:\n            self.move_entity(self.player, *vscale(self.player.speed, key_directions[c]))\n        else:\n            return \"try arrow keys, w, a, s, d, or ctrl-D (you pressed %r)\" % c\n        return self.tick()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a message to be displayed if game is over else None", "response": "def tick(self):\n        \"\"\"Returns a message to be displayed if game is over, else None\"\"\"\n        for npc in self.npcs:\n            self.move_entity(npc, *npc.towards(self.player))\n        for entity1, entity2 in itertools.combinations(self.entities, 2):\n            if (entity1.x, entity1.y) == (entity2.x, entity2.y):\n                if self.player in (entity1, entity2):\n                    return 'you lost on turn %d' % self.turn\n                entity1.die()\n                entity2.die()\n\n        if all(npc.speed == 0 for npc in self.npcs):\n            return 'you won on turn %d' % self.turn\n        self.turn += 1\n        if self.turn % 20 == 0:\n            self.player.speed = max(1, self.player.speed - 1)\n            self.player.display = on_blue(green(bold(unicode_str(self.player.speed))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef array_from_text(self, msg):\n        rows, columns = self.t.height, self.t.width\n        return self.array_from_text_rc(msg, rows, columns)", "response": "Returns an FSArray of the size of the window containing msg"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render_to_terminal(self, array, cursor_pos=(0, 0)):\n        # TODO there's a race condition here - these height and widths are\n        # super fresh - they might change between the array being constructed\n        # and rendered\n        # Maybe the right behavior is to throw away the render\n        # in the signal handler?\n        height, width = self.height, self.width\n\n        for_stdout = self.fmtstr_to_stdout_xform()\n        if not self.hide_cursor:\n            self.write(self.t.hide_cursor)\n        if (height != self._last_rendered_height or\n                width != self._last_rendered_width):\n            self.on_terminal_size_change(height, width)\n\n        current_lines_by_row = {}\n        rows = list(range(height))\n        rows_for_use = rows[:len(array)]\n        rest_of_rows = rows[len(array):]\n\n        # rows which we have content for and don't require scrolling\n        for row, line in zip(rows_for_use, array):\n            current_lines_by_row[row] = line\n            if line == self._last_lines_by_row.get(row, None):\n                continue\n            self.write(self.t.move(row, 0))\n            self.write(for_stdout(line))\n            if len(line) < width:\n                self.write(self.t.clear_eol)\n\n        # rows onscreen that we don't have content for\n        for row in rest_of_rows:\n            if self._last_lines_by_row and row not in self._last_lines_by_row:\n                continue\n            self.write(self.t.move(row, 0))\n            self.write(self.t.clear_eol)\n            self.write(self.t.clear_bol)\n            current_lines_by_row[row] = None\n\n        logger.debug(\n            'lines in last lines by row: %r' % self._last_lines_by_row.keys()\n        )\n        logger.debug(\n            'lines in current lines by row: %r' % current_lines_by_row.keys()\n        )\n        self.write(self.t.move(*cursor_pos))\n        self._last_lines_by_row = current_lines_by_row\n        if not self.hide_cursor:\n            self.write(self.t.normal_cursor)", "response": "Renders the array to the terminal and places the cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_cursor_position(self):\n        # TODO would this be cleaner as a parameter?\n        in_stream = self.in_stream\n\n        query_cursor_position = u\"\\x1b[6n\"\n        self.write(query_cursor_position)\n\n        def retrying_read():\n            while True:\n                try:\n                    c = in_stream.read(1)\n                    if c == '':\n                        raise ValueError(\"Stream should be blocking - should't\"\n                                         \" return ''. Returned %r so far\",\n                                         (resp,))\n                    return c\n                except IOError:\n                    raise ValueError(\n                        'cursor get pos response read interrupted'\n                    )\n                    # find out if this ever really happens - if so, continue\n\n        resp = ''\n        while True:\n            c = retrying_read()\n            resp += c\n            m = re.search('(?P<extra>.*)'\n                          '(?P<CSI>\\x1b\\[|\\x9b)'\n                          '(?P<row>\\\\d+);(?P<column>\\\\d+)R', resp, re.DOTALL)\n            if m:\n                row = int(m.groupdict()['row'])\n                col = int(m.groupdict()['column'])\n                extra = m.groupdict()['extra']\n                if extra:\n                    if self.extra_bytes_callback:\n                        self.extra_bytes_callback(\n                            extra.encode(in_stream.encoding)\n                        )\n                    else:\n                        raise ValueError((\"Bytes preceding cursor position \"\n                                          \"query response thrown out:\\n%r\\n\"\n                                          \"Pass an extra_bytes_callback to \"\n                                          \"CursorAwareWindow to prevent this\")\n                                         % (extra,))\n                return (row - 1, col - 1)", "response": "Returns the terminal row column of the cursor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_cursor_vertical_diff(self):\n        # Probably called by a SIGWINCH handler, and therefore\n        # will do cursor querying until a SIGWINCH doesn't happen during\n        # the query. Calls to the function from a signal handler COULD STILL\n        # HAPPEN out of order -\n        # they just can't interrupt the actual cursor query.\n        if self.in_get_cursor_diff:\n            self.another_sigwinch = True\n            return 0\n\n        cursor_dy = 0\n        while True:\n            self.in_get_cursor_diff = True\n            self.another_sigwinch = False\n            cursor_dy += self._get_cursor_vertical_diff_once()\n            self.in_get_cursor_diff = False\n            if not self.another_sigwinch:\n                return cursor_dy", "response": "Returns the number of lines moved down the cursor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the how far down the cursor moved.", "response": "def _get_cursor_vertical_diff_once(self):\n        \"\"\"Returns the how far down the cursor moved.\"\"\"\n        old_top_usable_row = self.top_usable_row\n        row, col = self.get_cursor_position()\n        if self._last_cursor_row is None:\n            cursor_dy = 0\n        else:\n            cursor_dy = row - self._last_cursor_row\n            logger.info('cursor moved %d lines down' % cursor_dy)\n            while self.top_usable_row > -1 and cursor_dy > 0:\n                self.top_usable_row += 1\n                cursor_dy -= 1\n            while self.top_usable_row > 1 and cursor_dy < 0:\n                self.top_usable_row -= 1\n                cursor_dy += 1\n        logger.info('top usable row changed from %d to %d', old_top_usable_row,\n                    self.top_usable_row)\n        logger.info('returning cursor dy of %d from curtsies' % cursor_dy)\n        self._last_cursor_row = row\n        return cursor_dy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_to_terminal(self, array, cursor_pos=(0, 0)):\n        for_stdout = self.fmtstr_to_stdout_xform()\n        # caching of write and tc (avoiding the self. lookups etc) made\n        # no significant performance difference here\n        if not self.hide_cursor:\n            self.write(self.t.hide_cursor)\n\n        # TODO race condition here?\n        height, width = self.t.height, self.t.width\n        if (height != self._last_rendered_height or\n                width != self._last_rendered_width):\n            self.on_terminal_size_change(height, width)\n\n        current_lines_by_row = {}\n        rows_for_use = list(range(self.top_usable_row, height))\n\n        # rows which we have content for and don't require scrolling\n        # TODO rename shared\n        shared = min(len(array), len(rows_for_use))\n        for row, line in zip(rows_for_use[:shared], array[:shared]):\n            current_lines_by_row[row] = line\n            if line == self._last_lines_by_row.get(row, None):\n                continue\n            self.write(self.t.move(row, 0))\n            self.write(for_stdout(line))\n            if len(line) < width:\n                self.write(self.t.clear_eol)\n\n        # rows already on screen that we don't have content for\n        rest_of_lines = array[shared:]\n        rest_of_rows = rows_for_use[shared:]\n        for row in rest_of_rows:  # if array too small\n            if self._last_lines_by_row and row not in self._last_lines_by_row:\n                continue\n            self.write(self.t.move(row, 0))\n            self.write(self.t.clear_eol)\n            # TODO probably not necessary - is first char cleared?\n            self.write(self.t.clear_bol)\n            current_lines_by_row[row] = None\n\n        # lines for which we need to scroll down to render\n        offscreen_scrolls = 0\n        for line in rest_of_lines:  # if array too big\n            self.scroll_down()\n            if self.top_usable_row > 0:\n                self.top_usable_row -= 1\n            else:\n                offscreen_scrolls += 1\n            current_lines_by_row = dict(\n                (k - 1, v) for k, v in current_lines_by_row.items()\n            )\n            logger.debug('new top_usable_row: %d' % self.top_usable_row)\n            # since scrolling moves the cursor\n            self.write(self.t.move(height - 1, 0))\n            self.write(for_stdout(line))\n            current_lines_by_row[height - 1] = line\n\n        logger.debug(\n            'lines in last lines by row: %r' % self._last_lines_by_row.keys()\n        )\n        logger.debug(\n            'lines in current lines by row: %r' % current_lines_by_row.keys()\n        )\n        self._last_cursor_row = max(\n            0, cursor_pos[0] - offscreen_scrolls + self.top_usable_row\n        )\n        self._last_cursor_column = cursor_pos[1]\n        self.write(\n            self.t.move(self._last_cursor_row, self._last_cursor_column)\n        )\n        self._last_lines_by_row = current_lines_by_row\n        if not self.hide_cursor:\n            self.write(self.t.normal_cursor)\n        return offscreen_scrolls", "response": "Renders the given array to the terminal. Returns the number of lines scrolled offscreen."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsolve the SDP relaxation on the current object.", "response": "def solve(self, solver=None, solverparameters=None):\n        \"\"\"Call a solver on the SDP relaxation. Upon successful solution, it\n        returns the primal and dual objective values along with the solution\n        matrices. It also sets these values in the `sdpRelaxation` object,\n        along with some status information.\n\n        :param sdpRelaxation: The SDP relaxation to be solved.\n        :type sdpRelaxation: :class:`ncpol2sdpa.SdpRelaxation`.\n        :param solver: The solver to be called, either `None`, \"sdpa\", \"mosek\",\n                       \"cvxpy\", \"scs\", or \"cvxopt\". The default is `None`,\n                       which triggers autodetect.\n        :type solver: str.\n        :param solverparameters: Parameters to be passed to the solver. Actual\n                                 options depend on the solver:\n\n                                 SDPA:\n\n                                   - `\"executable\"`:\n                                     Specify the executable for SDPA. E.g.,\n                                     `\"executable\":\"/usr/local/bin/sdpa\"`, or\n                                     `\"executable\":\"sdpa_gmp\"`\n                                   - `\"paramsfile\"`: Specify the parameter file\n\n                                 Mosek:\n                                 Refer to the Mosek documentation. All\n                                 arguments are passed on.\n\n                                 Cvxopt:\n                                 Refer to the PICOS documentation. All\n                                 arguments are passed on.\n\n                                 Cvxpy:\n                                 Refer to the Cvxpy documentation. All\n                                 arguments are passed on.\n\n                                 SCS:\n                                 Refer to the Cvxpy documentation. All\n                                 arguments are passed on.\n\n        :type solverparameters: dict of str.\n        \"\"\"\n        if self.F is None:\n            raise Exception(\"Relaxation is not generated yet. Call \"\n                            \"'SdpRelaxation.get_relaxation' first\")\n        solve_sdp(self, solver, solverparameters)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses a single monomial when building the moment matrix.", "response": "def _process_monomial(self, monomial, n_vars):\n        \"\"\"Process a single monomial when building the moment matrix.\n        \"\"\"\n        processed_monomial, coeff = separate_scalar_factor(monomial)\n        # Are we substituting this moment?\n        try:\n            substitute = self.moment_substitutions[processed_monomial]\n            if not isinstance(substitute, (int, float, complex)):\n                result = []\n                if not isinstance(substitute, Add):\n                    args = [substitute]\n                else:\n                    args = substitute.args\n                for arg in args:\n                    if is_number_type(arg):\n                        if iscomplex(arg):\n                            result.append((0, coeff*complex(arg)))\n                        else:\n                            result.append((0, coeff*float(arg)))\n                    else:\n                        result += [(k, coeff*c2)\n                                   for k, c2 in self._process_monomial(arg,\n                                                                       n_vars)]\n            else:\n                result = [(0, coeff*substitute)]\n        except KeyError:\n            # Have we seen this monomial before?\n            try:\n                # If yes, then we improve sparsity by reusing the\n                # previous variable to denote this entry in the matrix\n                k = self.monomial_index[processed_monomial]\n            except KeyError:\n                # If no, it still may be possible that we have already seen its\n                # conjugate. If the problem is real-valued, a monomial and its\n                # conjugate should be equal (Hermiticity becomes symmetry)\n                if not self.complex_matrix:\n                    try:\n                    # If we have seen the conjugate before, we just use the\n                    # conjugate monomial instead\n                        processed_monomial_adjoint = \\\n                              apply_substitutions(processed_monomial.adjoint(),\n                                                  self.substitutions)\n                        k = self.monomial_index[processed_monomial_adjoint]\n                    except KeyError:\n                        # Otherwise we define a new entry in the associated\n                        # array recording the monomials, and add an entry in\n                        # the moment matrix\n                        k = n_vars + 1\n                        self.monomial_index[processed_monomial] = k\n                else:\n                    k = n_vars + 1\n                    self.monomial_index[processed_monomial] = k\n            result = [(k, coeff)]\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _generate_moment_matrix(self, n_vars, block_index, processed_entries,\n                                monomialsA, monomialsB, ppt=False):\n        \"\"\"Generate the moment matrix of monomials.\n\n        Arguments:\n        n_vars -- current number of variables\n        block_index -- current block index in the SDP matrix\n        monomials -- |W_d| set of words of length up to the relaxation level\n        \"\"\"\n        row_offset = 0\n        if block_index > 0:\n            for block_size in self.block_struct[0:block_index]:\n                row_offset += block_size ** 2\n        N = len(monomialsA)*len(monomialsB)\n        func = partial(assemble_monomial_and_do_substitutions,\n                       monomialsA=monomialsA, monomialsB=monomialsB, ppt=ppt,\n                       substitutions=self.substitutions,\n                       pure_substitution_rules=self.pure_substitution_rules)\n        if self._parallel:\n            pool = Pool()\n            # This is just a guess and can be optimized\n            chunksize = int(max(int(np.sqrt(len(monomialsA) * len(monomialsB) *\n                                        len(monomialsA) / 2) / cpu_count()),\n                                1))\n        for rowA in range(len(monomialsA)):\n            if self._parallel:\n                iter_ = pool.map(func, [(rowA, columnA, rowB, columnB)\n                                        for rowB in range(len(monomialsB))\n                                        for columnA in range(rowA,\n                                                             len(monomialsA))\n                                        for columnB in range((rowA == columnA)*rowB,\n                                                             len(monomialsB))],\n                                 chunksize)\n                print_criterion = processed_entries + len(iter_)\n            else:\n                iter_ = imap(func, [(rowA, columnA, rowB, columnB)\n                                    for columnA in range(rowA, len(monomialsA))\n                                    for rowB in range(len(monomialsB))\n                                    for columnB in range((rowA == columnA)*rowB,\n                                                         len(monomialsB))])\n            for columnA, rowB, columnB, monomial in iter_:\n                processed_entries += 1\n                n_vars = self._push_monomial(monomial, n_vars,\n                                             row_offset, rowA,\n                                             columnA, N, rowB,\n                                             columnB, len(monomialsB),\n                                             prevent_substitutions=True)\n                if self.verbose > 0 and (not self._parallel or\n                                         processed_entries == self.n_vars or\n                                         processed_entries == print_criterion):\n                    percentage = processed_entries / self.n_vars\n                    time_used = time.time()-self._time0\n                    eta = (1.0 / percentage) * time_used - time_used\n                    hours = int(eta/3600)\n                    minutes = int((eta-3600*hours)/60)\n                    seconds = eta-3600*hours-minutes*60\n\n                    msg = \"\"\n                    if self.verbose > 1 and self._parallel:\n                        msg = \", working on block {:0} with {:0} processes with a chunksize of {:0d}\"\\\n                              .format(block_index, cpu_count(),\n                                      chunksize)\n                    msg = \"{:0} (done: {:.2%}, ETA {:02d}:{:02d}:{:03.1f}\"\\\n                          .format(n_vars, percentage, hours, minutes, seconds) + \\\n                          msg\n                    msg = \"\\r\\x1b[KCurrent number of SDP variables: \" + msg + \")\"\n                    sys.stdout.write(msg)\n                    sys.stdout.flush()\n\n        if self._parallel:\n            pool.close()\n            pool.join()\n        if self.verbose > 0:\n            sys.stdout.write(\"\\r\")\n        return n_vars, block_index + 1, processed_entries", "response": "Generate the moment matrix of the monomials."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the index of a monomial.", "response": "def _get_index_of_monomial(self, element, enablesubstitution=True,\n                               daggered=False):\n        \"\"\"Returns the index of a monomial.\n        \"\"\"\n        result = []\n        processed_element, coeff1 = separate_scalar_factor(element)\n        if processed_element in self.moment_substitutions:\n            r = self._get_index_of_monomial(self.moment_substitutions[processed_element], enablesubstitution)\n            return [(k, coeff*coeff1) for k, coeff in r]\n        if enablesubstitution:\n            processed_element = \\\n                apply_substitutions(processed_element, self.substitutions,\n                                    self.pure_substitution_rules)\n        # Given the monomial, we need its mapping L_y(w) to push it into\n        # a corresponding constraint matrix\n        if is_number_type(processed_element):\n            return [(0, coeff1)]\n        elif processed_element.is_Add:\n            monomials = processed_element.args\n        else:\n            monomials = [processed_element]\n        for monomial in monomials:\n            monomial, coeff2 = separate_scalar_factor(monomial)\n            coeff = coeff1*coeff2\n            if is_number_type(monomial):\n                result.append((0, coeff))\n                continue\n            k = -1\n            if monomial != 0:\n                if monomial.as_coeff_Mul()[0] < 0:\n                    monomial = -monomial\n                    coeff = -1.0 * coeff\n            try:\n                new_element = self.moment_substitutions[monomial]\n                r = self._get_index_of_monomial(self.moment_substitutions[new_element], enablesubstitution)\n                result += [(k, coeff*coeff3) for k, coeff3 in r]\n            except KeyError:\n                try:\n                    k = self.monomial_index[monomial]\n                    result.append((k, coeff))\n                except KeyError:\n                    if not daggered:\n                        dag_result = self._get_index_of_monomial(monomial.adjoint(),\n                                                                 daggered=True)\n                        result += [(k, coeff0*coeff) for k, coeff0 in dag_result]\n                    else:\n                        raise RuntimeError(\"The requested monomial \" +\n                                           str(monomial) + \" could not be found.\")\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npush a sparse vector representation of a polynomial into the F structure.", "response": "def __push_facvar_sparse(self, polynomial, block_index, row_offset, i, j):\n        \"\"\"Calculate the sparse vector representation of a polynomial\n        and pushes it to the F structure.\n        \"\"\"\n        width = self.block_struct[block_index - 1]\n        # Preprocess the polynomial for uniform handling later\n        # DO NOT EXPAND THE POLYNOMIAL HERE!!!!!!!!!!!!!!!!!!!\n        # The simplify_polynomial bypasses the problem.\n        # Simplifying here will trigger a bug in SymPy related to\n        # the powers of daggered variables.\n        # polynomial = polynomial.expand()\n        if is_number_type(polynomial) or polynomial.is_Mul:\n            elements = [polynomial]\n        else:\n            elements = polynomial.as_coeff_mul()[1][0].as_coeff_add()[1]\n        # Identify its constituent monomials\n        for element in elements:\n            results = self._get_index_of_monomial(element)\n            # k identifies the mapped value of a word (monomial) w\n            for (k, coeff) in results:\n                if k > -1 and coeff != 0:\n                    self.F[row_offset + i * width + j, k] += coeff"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __process_inequalities(self, block_index):\n        initial_block_index = block_index\n        row_offsets = [0]\n        for block, block_size in enumerate(self.block_struct):\n            row_offsets.append(row_offsets[block] + block_size ** 2)\n\n        if self._parallel:\n            pool = Pool()\n        for k, ineq in enumerate(self.constraints):\n            block_index += 1\n            monomials = self.localizing_monomial_sets[block_index -\n                                                      initial_block_index-1]\n            lm = len(monomials)\n            if isinstance(ineq, str):\n                self.__parse_expression(ineq, row_offsets[block_index-1])\n                continue\n            if ineq.is_Relational:\n                ineq = convert_relational(ineq)\n            func = partial(moment_of_entry, monomials=monomials, ineq=ineq,\n                           substitutions=self.substitutions)\n            if self._parallel and lm > 1:\n                chunksize = max(int(np.sqrt(lm*lm/2) /\n                                    cpu_count()), 1)\n                iter_ = pool.map(func, ([row, column] for row in range(lm)\n                                        for column in range(row, lm)),\n                                 chunksize)\n            else:\n                iter_ = imap(func, ([row, column] for row in range(lm)\n                                    for column in range(row, lm)))\n            if block_index > self.constraint_starting_block + \\\n                    self._n_inequalities and lm > 1:\n                is_equality = True\n            else:\n                is_equality = False\n            for row, column, polynomial in iter_:\n                if is_equality:\n                    row, column = 0, 0\n                self.__push_facvar_sparse(polynomial, block_index,\n                                          row_offsets[block_index-1],\n                                          row, column)\n                if is_equality:\n                    block_index += 1\n            if is_equality:\n                block_index -= 1\n            if self.verbose > 0:\n                sys.stdout.write(\"\\r\\x1b[KProcessing %d/%d constraints...\" %\n                                 (k+1, len(self.constraints)))\n                sys.stdout.flush()\n        if self._parallel:\n            pool.close()\n            pool.join()\n\n        if self.verbose > 0:\n            sys.stdout.write(\"\\n\")\n        return block_index", "response": "Generate localizing matrices for the inequality constraints of the SDP relaxation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the localizing matrices for the given set of equalities and the given list of moment equalities.", "response": "def __process_equalities(self, equalities, momentequalities):\n        \"\"\"Generate localizing matrices\n\n        Arguments:\n        equalities -- list of equality constraints\n        equalities -- list of moment equality constraints\n        \"\"\"\n        monomial_sets = []\n        n_rows = 0\n        le = 0\n        if equalities is not None:\n            for equality in equalities:\n                le += 1\n                # Find the order of the localizing matrix\n                if equality.is_Relational:\n                    equality = convert_relational(equality)\n                eq_order = ncdegree(equality)\n                if eq_order > 2 * self.level:\n                    raise Exception(\"An equality constraint has degree %d. \"\n                                    \"Choose a higher level of relaxation.\"\n                                    % eq_order)\n                localization_order = (2 * self.level - eq_order)//2\n                index = find_variable_set(self.variables, equality)\n                localizing_monomials = \\\n                    pick_monomials_up_to_degree(self.monomial_sets[index],\n                                                localization_order)\n                if len(localizing_monomials) == 0:\n                    localizing_monomials = [S.One]\n                localizing_monomials = unique(localizing_monomials)\n                monomial_sets.append(localizing_monomials)\n                n_rows += len(localizing_monomials) * \\\n                    (len(localizing_monomials) + 1) // 2\n        if momentequalities is not None:\n            for _ in momentequalities:\n                le += 1\n                monomial_sets.append([S.One])\n                n_rows += 1\n        A = np.zeros((n_rows, self.n_vars + 1), dtype=self.F.dtype)\n        n_rows = 0\n        if self._parallel:\n            pool = Pool()\n        for i, equality in enumerate(flatten([equalities, momentequalities])):\n            func = partial(moment_of_entry, monomials=monomial_sets[i],\n                           ineq=equality, substitutions=self.substitutions)\n            lm = len(monomial_sets[i])\n            if self._parallel and lm > 1:\n                chunksize = max(int(np.sqrt(lm*lm/2) /\n                                    cpu_count()), 1)\n                iter_ = pool.map(func, ([row, column] for row in range(lm)\n                                        for column in range(row, lm)),\n                                 chunksize)\n            else:\n                iter_ = imap(func, ([row, column] for row in range(lm)\n                                    for column in range(row, lm)))\n            # Process M_y(gy)(u,w) entries\n            for row, column, polynomial in iter_:\n                # Calculate the moments of polynomial entries\n                if isinstance(polynomial, str):\n                    self.__parse_expression(equality, -1, A[n_rows])\n                else:\n                    A[n_rows] = self._get_facvar(polynomial)\n                n_rows += 1\n                if self.verbose > 0:\n                    sys.stdout.write(\"\\r\\x1b[KProcessing %d/%d equalities...\" %\n                                     (i+1, le))\n                    sys.stdout.flush()\n        if self._parallel:\n            pool.close()\n            pool.join()\n\n        if self.verbose > 0:\n            sys.stdout.write(\"\\n\")\n        return A"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattempting to remove equalities by solving the linear equations.", "response": "def __remove_equalities(self, equalities, momentequalities):\n        \"\"\"Attempt to remove equalities by solving the linear equations.\n        \"\"\"\n        A = self.__process_equalities(equalities, momentequalities)\n        if min(A.shape != np.linalg.matrix_rank(A)):\n            print(\"Warning: equality constraints are linearly dependent! \"\n                  \"Results might be incorrect.\", file=sys.stderr)\n        if A.shape[0] == 0:\n            return\n        c = np.array(self.obj_facvar)\n        if self.verbose > 0:\n            print(\"QR decomposition...\")\n        Q, R = np.linalg.qr(A[:, 1:].T, mode='complete')\n        n = np.max(np.nonzero(np.sum(np.abs(R), axis=1) > 0)) + 1\n        x = np.dot(Q[:, :n], np.linalg.solve(np.transpose(R[:n, :]), -A[:, 0]))\n        self._new_basis = lil_matrix(Q[:, n:])\n        # Transforming the objective function\n        self._original_obj_facvar = self.obj_facvar\n        self._original_constant_term = self.constant_term\n        self.obj_facvar = self._new_basis.T.dot(c)\n        self.constant_term += c.dot(x)\n        x = np.append(1, x)\n        # Transforming the moment matrix and localizing matrices\n        new_F = lil_matrix((self.F.shape[0], self._new_basis.shape[1] + 1))\n        new_F[:, 0] = self.F[:, :self.n_vars+1].dot(x).reshape((new_F.shape[0],\n                                                                1))\n        new_F[:, 1:] = self.F[:, 1:self.n_vars+1].\\\n            dot(self._new_basis)\n        self._original_F = self.F\n        self.F = new_F\n        self.n_vars = self._new_basis.shape[1]\n        if self.verbose > 0:\n            print(\"Number of variables after solving the linear equations: %d\"\n                  % self.n_vars)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the block structure for the current object.", "response": "def _calculate_block_structure(self, inequalities, equalities,\n                                   momentinequalities, momentequalities,\n                                   extramomentmatrix, removeequalities,\n                                   block_struct=None):\n        \"\"\"Calculates the block_struct array for the output file.\n        \"\"\"\n        if block_struct is None:\n            if self.verbose > 0:\n                print(\"Calculating block structure...\")\n            self.block_struct = []\n            if self.parameters is not None:\n                self.block_struct += [1 for _ in self.parameters]\n            for monomials in self.monomial_sets:\n                if len(monomials) > 0 and isinstance(monomials[0], list):\n                    self.block_struct.append(len(monomials[0]))\n                else:\n                    self.block_struct.append(len(monomials))\n            if extramomentmatrix is not None:\n                for _ in extramomentmatrix:\n                    for monomials in self.monomial_sets:\n                        if len(monomials) > 0 and \\\n                                isinstance(monomials[0], list):\n                            self.block_struct.append(len(monomials[0]))\n                        else:\n                            self.block_struct.append(len(monomials))\n        else:\n            self.block_struct = block_struct\n        degree_warning = False\n        if inequalities is not None:\n            self._n_inequalities = len(inequalities)\n            n_tmp_inequalities = len(inequalities)\n        else:\n            self._n_inequalities = 0\n            n_tmp_inequalities = 0\n        constraints = flatten([inequalities])\n        if momentinequalities is not None:\n            self._n_inequalities += len(momentinequalities)\n            constraints += momentinequalities\n        if not removeequalities:\n            constraints += flatten([equalities])\n        monomial_sets = []\n        for k, constraint in enumerate(constraints):\n            # Find the order of the localizing matrix\n            if k < n_tmp_inequalities or k >= self._n_inequalities:\n                if isinstance(constraint, str):\n                    ineq_order = 2 * self.level\n                else:\n                    if constraint.is_Relational:\n                        constraint = convert_relational(constraint)\n                    ineq_order = ncdegree(constraint)\n                    if iscomplex(constraint):\n                        self.complex_matrix = True\n                if ineq_order > 2 * self.level:\n                    degree_warning = True\n                localization_order = (2*self.level - ineq_order)//2\n                if self.level == -1:\n                    localization_order = 0\n                if self.localizing_monomial_sets is not None and \\\n                        self.localizing_monomial_sets[k] is not None:\n                    localizing_monomials = self.localizing_monomial_sets[k]\n                else:\n                    index = find_variable_set(self.variables, constraint)\n                    localizing_monomials = \\\n                        pick_monomials_up_to_degree(self.monomial_sets[index],\n                                                    localization_order)\n                ln = len(localizing_monomials)\n                if ln == 0:\n                    localizing_monomials = [S.One]\n            else:\n                localizing_monomials = [S.One]\n                ln = 1\n            localizing_monomials = unique(localizing_monomials)\n            monomial_sets.append(localizing_monomials)\n            if k < self._n_inequalities:\n                self.block_struct.append(ln)\n            else:\n                monomial_sets += [None for _ in range(ln*(ln+1)//2-1)]\n                monomial_sets.append(localizing_monomials)\n                monomial_sets += [None for _ in range(ln*(ln+1)//2-1)]\n                self.block_struct += [1 for _ in range(ln*(ln+1))]\n\n        if degree_warning and self.verbose > 0:\n            print(\"A constraint has degree %d. Either choose a higher level \"\n                  \"relaxation or ensure that a mixed-order relaxation has the\"\n                  \" necessary monomials\" % (ineq_order), file=sys.stderr)\n\n        if momentequalities is not None:\n            for moment_eq in momentequalities:\n                self._moment_equalities.append(moment_eq)\n                if not removeequalities:\n                    monomial_sets += [[S.One], [S.One]]\n                    self.block_struct += [1, 1]\n        self.localizing_monomial_sets = monomial_sets"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_constraints(self, inequalities=None, equalities=None,\n                            momentinequalities=None, momentequalities=None,\n                            block_index=0, removeequalities=False):\n        \"\"\"Process the constraints and generate localizing matrices. Useful\n        only if the moment matrix already exists. Call it if you want to\n        replace your constraints. The number of the respective types of\n        constraints and the maximum degree of each constraint must remain the\n        same.\n\n        :param inequalities: Optional parameter to list inequality constraints.\n        :type inequalities: list of :class:`sympy.core.exp.Expr`.\n        :param equalities: Optional parameter to list equality constraints.\n        :type equalities: list of :class:`sympy.core.exp.Expr`.\n        :param momentinequalities: Optional parameter of inequalities defined\n                                   on moments.\n        :type momentinequalities: list of :class:`sympy.core.exp.Expr`.\n        :param momentequalities: Optional parameter of equalities defined\n                                 on moments.\n        :type momentequalities: list of :class:`sympy.core.exp.Expr`.\n        :param removeequalities: Optional parameter to attempt removing the\n                                 equalities by solving the linear equations.\n\n        :param removeequalities: Optional parameter to attempt removing the\n                                 equalities by solving the linear equations.\n        :type removeequalities: bool.\n        \"\"\"\n        self.status = \"unsolved\"\n        if block_index == 0:\n            if self._original_F is not None:\n                self.F = self._original_F\n                self.obj_facvar = self._original_obj_facvar\n                self.constant_term = self._original_constant_term\n                self.n_vars = len(self.obj_facvar)\n                self._new_basis = None\n            block_index = self.constraint_starting_block\n            self.__wipe_F_from_constraints()\n        self.constraints = flatten([inequalities])\n        self._constraint_to_block_index = {}\n        for constraint in self.constraints:\n            self._constraint_to_block_index[constraint] = (block_index, )\n            block_index += 1\n        if momentinequalities is not None:\n            for mineq in momentinequalities:\n                self.constraints.append(mineq)\n                self._constraint_to_block_index[mineq] = (block_index, )\n                block_index += 1\n        if not (removeequalities or equalities is None):\n            # Equalities are converted to pairs of inequalities\n            for k, equality in enumerate(equalities):\n                if equality.is_Relational:\n                    equality = convert_relational(equality)\n                self.constraints.append(equality)\n                self.constraints.append(-equality)\n                ln = len(self.localizing_monomial_sets[block_index-\n                                                       self.constraint_starting_block])\n                self._constraint_to_block_index[equality] = (block_index,\n                                                             block_index+ln*(ln+1)//2)\n                block_index += ln*(ln+1)\n        if momentequalities is not None and not removeequalities:\n            for meq in momentequalities:\n                self.constraints += [meq, flip_sign(meq)]\n                self._constraint_to_block_index[meq] = (block_index,\n                                                        block_index+1)\n                block_index += 2\n        block_index = self.constraint_starting_block\n        self.__process_inequalities(block_index)\n        if removeequalities:\n            self.__remove_equalities(equalities, momentequalities)", "response": "Processes the constraints and generates localizing matrices. Useful for creating the localizing matrices."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting or change the objective function of the polynomial optimization problem.", "response": "def set_objective(self, objective, extraobjexpr=None):\n        \"\"\"Set or change the objective function of the polynomial optimization\n        problem.\n\n        :param objective: Describes the objective function.\n        :type objective: :class:`sympy.core.expr.Expr`\n        :param extraobjexpr: Optional parameter of a string expression of a\n                             linear combination of moment matrix elements to be\n                             included in the objective function\n        :type extraobjexpr: str.\n        \"\"\"\n        if objective is not None:\n            facvar = \\\n                self._get_facvar(simplify_polynomial(objective,\n                                                     self.substitutions))\n            self.obj_facvar = facvar[1:]\n            self.constant_term = facvar[0]\n            if self.verbose > 0 and facvar[0] != 0:\n                print(\"Warning: The objective function has a non-zero %s \"\n                      \"constant term. It is not included in the SDP objective.\"\n                      % facvar[0], file=sys.stderr)\n        else:\n            self.obj_facvar = self._get_facvar(0)[1:]\n        if extraobjexpr is not None:\n            for sub_expr in extraobjexpr.split(']'):\n                startindex = 0\n                if sub_expr.startswith('-') or sub_expr.startswith('+'):\n                    startindex = 1\n                ind = sub_expr.find('[')\n                if ind > -1:\n                    idx = sub_expr[ind+1:].split(\",\")\n                    i, j = int(idx[0]), int(idx[1])\n                    mm_ind = int(sub_expr[startindex:ind])\n                    if sub_expr.find('*') > -1:\n                        value = float(sub_expr[:sub_expr.find('*')])\n                    elif sub_expr.startswith('-'):\n                        value = -1.0\n                    else:\n                        value = 1.0\n                    base_row_offset = sum([bs**2 for bs in\n                                           self.block_struct[:mm_ind]])\n                    width = self.block_struct[mm_ind]\n                    for column in self.F[base_row_offset + i*width + j].rows[0]:\n                        self.obj_facvar[column-1] = \\\n                            value*self.F[base_row_offset + i*width + j, column]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_solution_ranks(self, xmat=None, baselevel=0):\n        return find_solution_ranks(self, xmat=xmat, baselevel=baselevel)", "response": "This function is used to detect the rank loop in the solution matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_dual(self, constraint, ymat=None):\n        if not isinstance(constraint, Expr):\n            raise Exception(\"Not a monomial or polynomial!\")\n        elif self.status == \"unsolved\" and ymat is None:\n            raise Exception(\"SDP relaxation is not solved yet!\")\n        elif ymat is None:\n            ymat = self.y_mat\n        index = self._constraint_to_block_index.get(constraint)\n        if index is None:\n            raise Exception(\"Constraint is not in the dual!\")\n        if len(index) == 2:\n            return ymat[index[0]], self.y_mat[index[1]]\n        else:\n            return ymat[index[0]]", "response": "Given a solution of the dual problem and a constraint returns the corresponding dual block."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_to_file(self, filename, filetype=None):\n        if filetype == \"sdpa\" and not filename.endswith(\".dat-s\"):\n            raise Exception(\"SDPA files must have .dat-s extension!\")\n        if filetype == \"mosek\" and not filename.endswith(\".task\"):\n            raise Exception(\"Mosek files must have .task extension!\")\n        elif filetype is None and filename.endswith(\".dat-s\"):\n            filetype = \"sdpa\"\n        elif filetype is None and filename.endswith(\".csv\"):\n            filetype = \"csv\"\n        elif filetype is None and filename.endswith(\".task\"):\n            filetype = \"mosek\"\n        elif filetype is None:\n            raise Exception(\"Cannot detect filetype from extension!\")\n\n        if filetype == \"sdpa\":\n            write_to_sdpa(self, filename)\n        elif filetype == \"mosek\":\n            task = convert_to_mosek(self)\n            task.writedata(filename)\n        elif filetype == \"csv\":\n            write_to_human_readable(self, filename)\n        else:\n            raise Exception(\"Unknown filetype\")", "response": "Writes the relaxation to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_relaxation(self, level, objective=None, inequalities=None,\n                       equalities=None, substitutions=None,\n                       momentinequalities=None, momentequalities=None,\n                       momentsubstitutions=None,\n                       removeequalities=False, extramonomials=None,\n                       extramomentmatrices=None, extraobjexpr=None,\n                       localizing_monomials=None, chordal_extension=False):\n        \"\"\"Get the SDP relaxation of a noncommutative polynomial optimization\n        problem.\n\n        :param level: The level of the relaxation. The value -1 will skip\n                      automatic monomial generation and use only the monomials\n                      supplied by the option `extramonomials`.\n        :type level: int.\n        :param obj: Optional parameter to describe the objective function.\n        :type obj: :class:`sympy.core.exp.Expr`.\n        :param inequalities: Optional parameter to list inequality constraints.\n        :type inequalities: list of :class:`sympy.core.exp.Expr`.\n        :param equalities: Optional parameter to list equality constraints.\n        :type equalities: list of :class:`sympy.core.exp.Expr`.\n        :param substitutions: Optional parameter containing monomials that can\n                              be replaced (e.g., idempotent variables).\n        :type substitutions: dict of :class:`sympy.core.exp.Expr`.\n        :param momentinequalities: Optional parameter of inequalities defined\n                                   on moments.\n        :type momentinequalities: list of :class:`sympy.core.exp.Expr`.\n        :param momentequalities: Optional parameter of equalities defined\n                                 on moments.\n        :type momentequalities: list of :class:`sympy.core.exp.Expr`.\n        :param momentsubstitutions: Optional parameter containing moments that\n                                    can be replaced.\n        :type momentsubstitutions: dict of :class:`sympy.core.exp.Expr`.\n        :param removeequalities: Optional parameter to attempt removing the\n                                 equalities by solving the linear equations.\n        :type removeequalities: bool.\n        :param extramonomials: Optional paramter of monomials to be included,\n                               on top of the requested level of relaxation.\n        :type extramonomials: list of :class:`sympy.core.exp.Expr`.\n        :param extramomentmatrices: Optional paramter of duplicating or adding\n                               moment matrices.  A new moment matrix can be\n                               unconstrained (\"\"), a copy  of the first one\n                               (\"copy\"), and satisfying a partial positivity\n                               constraint (\"ppt\"). Each new moment matrix is\n                               requested as a list of string of these options.\n                               For instance, adding a single new moment matrix\n                               as a copy of the first would be\n                               ``extramomentmatrices=[[\"copy\"]]``.\n        :type extramomentmatrices: list of list of str.\n        :param extraobjexpr: Optional parameter of a string expression of a\n                             linear combination of moment matrix elements to be\n                             included in the objective function.\n        :type extraobjexpr: str.\n        :param localizing_monomials: Optional parameter to specify sets of\n                                     localizing monomials for each constraint.\n                                     The internal order of constraints is\n                                     inequalities first, followed by the\n                                     equalities. If the parameter is specified,\n                                     but for a certain constraint the automatic\n                                     localization is requested, leave None in\n                                     its place in this parameter.\n        :type localizing_monomials: list of list of `sympy.core.exp.Expr`.\n        :param chordal_extension: Optional parameter to request a sparse\n                                  chordal extension.\n        :type chordal_extension: bool.\n\n        \"\"\"\n        if self.level < -1:\n            raise Exception(\"Invalid level of relaxation\")\n        self.level = level\n        if substitutions is None:\n            self.substitutions = {}\n        else:\n            self.substitutions = substitutions\n            for lhs, rhs in substitutions.items():\n                if not is_pure_substitution_rule(lhs, rhs):\n                    self.pure_substitution_rules = False\n                if iscomplex(lhs) or iscomplex(rhs):\n                    self.complex_matrix = True\n        if momentsubstitutions is not None:\n            self.moment_substitutions = momentsubstitutions.copy()\n            # If we have a real-valued problem, the moment matrix is symmetric\n            # and moment substitutions also apply to the conjugate monomials\n            if not self.complex_matrix:\n                for key, val in self.moment_substitutions.copy().items():\n                    adjoint_monomial = apply_substitutions(key.adjoint(),\n                                                           self.substitutions)\n                    self.moment_substitutions[adjoint_monomial] = val\n        if chordal_extension:\n            self.variables = find_variable_cliques(self.variables, objective,\n                                                   inequalities, equalities,\n                                                   momentinequalities,\n                                                   momentequalities)\n        self.__generate_monomial_sets(extramonomials)\n        self.localizing_monomial_sets = localizing_monomials\n\n        # Figure out basic structure of the SDP\n        self._calculate_block_structure(inequalities, equalities,\n                                        momentinequalities, momentequalities,\n                                        extramomentmatrices,\n                                        removeequalities)\n        self._estimate_n_vars()\n        if extramomentmatrices is not None:\n            for parameters in extramomentmatrices:\n                copy = False\n                for parameter in parameters:\n                    if parameter == \"copy\":\n                        copy = True\n                if copy:\n                    self.n_vars += self.n_vars + 1\n                else:\n                    self.n_vars += (self.block_struct[0]**2)/2\n        if self.complex_matrix:\n            dtype = np.complex128\n        else:\n            dtype = np.float64\n        self.F = lil_matrix((sum([bs**2 for bs in self.block_struct]),\n                                    self.n_vars + 1), dtype=dtype)\n\n        if self.verbose > 0:\n            print(('Estimated number of SDP variables: %d' % self.n_vars))\n            print('Generating moment matrix...')\n        # Generate moment matrices\n        new_n_vars, block_index = self.__add_parameters()\n        self._time0 = time.time()\n        new_n_vars, block_index = \\\n            self._generate_all_moment_matrix_blocks(new_n_vars, block_index)\n        if extramomentmatrices is not None:\n            new_n_vars, block_index = \\\n                self.__add_extra_momentmatrices(extramomentmatrices,\n                                                new_n_vars, block_index)\n        # The initial estimate for the size of F was overly generous.\n        self.n_vars = new_n_vars\n        # We don't correct the size of F, because that would trigger\n        # memory copies, and extra columns in lil_matrix are free anyway.\n        # self.F = self.F[:, 0:self.n_vars + 1]\n\n        if self.verbose > 0:\n            print(('Reduced number of SDP variables: %d' % self.n_vars))\n        # Objective function\n        self.set_objective(objective, extraobjexpr)\n        # Process constraints\n        self.constraint_starting_block = block_index\n        self.process_constraints(inequalities, equalities, momentinequalities,\n                                 momentequalities, block_index,\n                                 removeequalities)", "response": "Returns the SDP relaxation of a noncommutative polynomial optimization."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flatten(lol):\n    new_list = []\n    for element in lol:\n        if element is None:\n            continue\n        elif not isinstance(element, list) and not isinstance(element, tuple):\n            new_list.append(element)\n        elif len(element) > 0:\n            new_list.extend(flatten(element))\n    return new_list", "response": "Flatten a list of lists to a list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef simplify_polynomial(polynomial, monomial_substitutions):\n    if isinstance(polynomial, (int, float, complex)):\n        return polynomial\n    polynomial = (1.0 * polynomial).expand(mul=True,\n                                           multinomial=True)\n    if is_number_type(polynomial):\n        return polynomial\n    if polynomial.is_Mul:\n        elements = [polynomial]\n    else:\n        elements = polynomial.as_coeff_mul()[1][0].as_coeff_add()[1]\n    new_polynomial = 0\n    # Identify its constituent monomials\n    for element in elements:\n        monomial, coeff = separate_scalar_factor(element)\n        monomial = apply_substitutions(monomial, monomial_substitutions)\n        new_polynomial += coeff * monomial\n    return new_polynomial", "response": "Simplify a polynomial for uniform handling later."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __separate_scalar_factor(monomial):\n    scalar_factor = 1\n    if is_number_type(monomial):\n        return S.One, monomial\n    if monomial == 0:\n        return S.One, 0\n    comm_factors, _ = split_commutative_parts(monomial)\n    if len(comm_factors) > 0:\n        if isinstance(comm_factors[0], Number):\n            scalar_factor = comm_factors[0]\n    if scalar_factor != 1:\n        return monomial / scalar_factor, scalar_factor\n    else:\n        return monomial, scalar_factor", "response": "Separate the constant factor from a monomial."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the support of a polynomial.", "response": "def get_support(variables, polynomial):\n    \"\"\"Gets the support of a polynomial.\n    \"\"\"\n    support = []\n    if is_number_type(polynomial):\n        support.append([0] * len(variables))\n        return support\n    for monomial in polynomial.expand().as_coefficients_dict():\n        tmp_support = [0] * len(variables)\n        mon, _ = __separate_scalar_factor(monomial)\n        symbolic_support = flatten(split_commutative_parts(mon))\n        for s in symbolic_support:\n            if isinstance(s, Pow):\n                base = s.base\n                if is_adjoint(base):\n                    base = base.adjoint()\n                tmp_support[variables.index(base)] = s.exp\n            elif is_adjoint(s):\n                tmp_support[variables.index(s.adjoint())] = 1\n            elif isinstance(s, (Operator, Symbol)):\n                tmp_support[variables.index(s)] = 1\n        support.append(tmp_support)\n    return support"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the support variables of a polynomial.", "response": "def get_support_variables(polynomial):\n    \"\"\"Gets the support of a polynomial.\n    \"\"\"\n    support = []\n    if is_number_type(polynomial):\n        return support\n    for monomial in polynomial.expand().as_coefficients_dict():\n        mon, _ = __separate_scalar_factor(monomial)\n        symbolic_support = flatten(split_commutative_parts(mon))\n        for s in symbolic_support:\n            if isinstance(s, Pow):\n                base = s.base\n                if is_adjoint(base):\n                    base = base.adjoint()\n                support.append(base)\n            elif is_adjoint(s):\n                support.append(s.adjoint())\n            elif isinstance(s, Operator):\n                support.append(s)\n    return support"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef separate_scalar_factor(element):\n    coeff = 1.0\n    monomial = S.One\n    if isinstance(element, (int, float, complex)):\n        coeff *= element\n        return monomial, coeff\n    for var in element.as_coeff_mul()[1]:\n        if not (var.is_Number or var.is_imaginary):\n            monomial = monomial * var\n        else:\n            if var.is_Number:\n                coeff = float(var)\n            # If not, then it is imaginary\n            else:\n                coeff = 1j * coeff\n    coeff = float(element.as_coeff_mul()[0]) * coeff\n    return monomial, coeff", "response": "Construct a monomial with the coefficient separated\n    from an element in a polynomial."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count_ncmonomials(monomials, degree):\n    ncmoncount = 0\n    for monomial in monomials:\n        if ncdegree(monomial) <= degree:\n            ncmoncount += 1\n        else:\n            break\n    return ncmoncount", "response": "Given a list of monomials it counts those that have a certain degree and less."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply_substitutions(monomial, monomial_substitutions, pure=False):\n    if is_number_type(monomial):\n        return monomial\n    original_monomial = monomial\n    changed = True\n    if not pure:\n        substitutions = monomial_substitutions\n    else:\n        substitutions = {}\n        for lhs, rhs in monomial_substitutions.items():\n            irrelevant = False\n            for atom in lhs.atoms():\n                if atom.is_Number:\n                    continue\n                if not monomial.has(atom):\n                    irrelevant = True\n                    break\n            if not irrelevant:\n                substitutions[lhs] = rhs\n    while changed:\n        for lhs, rhs in substitutions.items():\n            monomial = fast_substitute(monomial, lhs, rhs)\n        if original_monomial == monomial:\n            changed = False\n        original_monomial = monomial\n    return monomial", "response": "Helper function to remove monomials from the basis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_variables(name, n_vars=1, hermitian=None, commutative=True):\n\n    variables = []\n    for i in range(n_vars):\n        if n_vars > 1:\n            var_name = '%s%s' % (name, i)\n        else:\n            var_name = '%s' % name\n        if commutative:\n            if hermitian is None or hermitian:\n                variables.append(Symbol(var_name, real=True))\n            else:\n                variables.append(Symbol(var_name, complex=True))\n        elif hermitian is not None and hermitian:\n            variables.append(HermitianOperator(var_name))\n        else:\n            variables.append(Operator(var_name))\n    return variables", "response": "Generates a number of commutative or noncommutative variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a number of commutative or noncommutative operators.", "response": "def generate_operators(name, n_vars=1, hermitian=None, commutative=False):\n    \"\"\"Generates a number of commutative or noncommutative operators\n\n    :param name: The prefix in the symbolic representation of the noncommuting\n                 variables. This will be suffixed by a number from 0 to\n                 n_vars-1 if n_vars > 1.\n    :type name: str.\n    :param n_vars: The number of variables.\n    :type n_vars: int.\n    :param hermitian: Optional parameter to request Hermitian variables .\n    :type hermitian: bool.\n    :param commutative: Optional parameter to request commutative variables.\n                        Commutative variables are Hermitian by default.\n    :type commutative: bool.\n\n    :returns: list of :class:`sympy.physics.quantum.operator.Operator` or\n              :class:`sympy.physics.quantum.operator.HermitianOperator`\n              variables\n\n    :Example:\n\n    >>> generate_variables('y', 2, commutative=True)\n    \ufffc[y0, y1]\n    \"\"\"\n\n    variables = []\n    for i in range(n_vars):\n        if n_vars > 1:\n            var_name = '%s%s' % (name, i)\n        else:\n            var_name = '%s' % name\n        if hermitian is not None and hermitian:\n            variables.append(HermitianOperator(var_name))\n        else:\n            variables.append(Operator(var_name))\n        variables[-1].is_commutative = commutative\n    return variables"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate all noncommutative monomials up to a degree.", "response": "def get_monomials(variables, degree):\n    \"\"\"Generates all noncommutative monomials up to a degree\n\n    :param variables: The noncommutative variables to generate monomials from\n    :type variables: list of :class:`sympy.physics.quantum.operator.Operator`\n                     or\n                     :class:`sympy.physics.quantum.operator.HermitianOperator`.\n    :param degree: The maximum degree.\n    :type degree: int.\n\n    :returns: list of monomials.\n    \"\"\"\n    if degree == -1:\n        return []\n    if not variables:\n        return [S.One]\n    else:\n        _variables = variables[:]\n        _variables.insert(0, 1)\n        ncmonomials = [S.One]\n        ncmonomials.extend(var for var in variables)\n        for var in variables:\n            if not is_hermitian(var):\n                ncmonomials.append(var.adjoint())\n        for _ in range(1, degree):\n            temp = []\n            for var in _variables:\n                for new_var in ncmonomials:\n                    temp.append(var * new_var)\n                    if var != 1 and not is_hermitian(var):\n                        temp.append(var.adjoint() * new_var)\n            ncmonomials = unique(temp[:])\n        return ncmonomials"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ncdegree(polynomial):\n    degree = 0\n    if is_number_type(polynomial):\n        return degree\n    polynomial = polynomial.expand()\n    for monomial in polynomial.as_coefficients_dict():\n        subdegree = 0\n        for variable in monomial.as_coeff_mul()[1]:\n            if isinstance(variable, Pow):\n                subdegree += variable.exp\n            elif not isinstance(variable, Number) and variable != I:\n                subdegree += 1\n        if subdegree > degree:\n            degree = subdegree\n    return degree", "response": "Returns the degree of a noncommutative polynomial."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iscomplex(polynomial):\n    if isinstance(polynomial, (int, float)):\n        return False\n    if isinstance(polynomial, complex):\n        return True\n    polynomial = polynomial.expand()\n    for monomial in polynomial.as_coefficients_dict():\n        for variable in monomial.as_coeff_mul()[1]:\n            if isinstance(variable, complex) or variable == I:\n                return True\n    return False", "response": "Returns whether the polynomial has complex coefficients."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_monomials(variables, extramonomials, substitutions, degree,\n                      removesubstitutions=True):\n    \"\"\"Return the monomials of a certain degree.\n    \"\"\"\n    monomials = get_monomials(variables, degree)\n    if extramonomials is not None:\n        monomials.extend(extramonomials)\n    if removesubstitutions and substitutions is not None:\n        monomials = [monomial for monomial in monomials if monomial not\n                     in substitutions]\n        monomials = [remove_scalar_factor(apply_substitutions(monomial,\n                                                              substitutions))\n                     for monomial in monomials]\n    monomials = unique(monomials)\n    return monomials", "response": "Return all monomials of a certain degree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pick_monomials_up_to_degree(monomials, degree):\n    ordered_monomials = []\n    if degree >= 0:\n        ordered_monomials.append(S.One)\n    for deg in range(1, degree + 1):\n        ordered_monomials.extend(pick_monomials_of_degree(monomials, deg))\n    return ordered_monomials", "response": "Return a list of monomials up to a given degree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of monomials up of a given degree.", "response": "def pick_monomials_of_degree(monomials, degree):\n    \"\"\"Collect all monomials up of a given degree.\n    \"\"\"\n    selected_monomials = []\n    for monomial in monomials:\n        if ncdegree(monomial) == degree:\n            selected_monomials.append(monomial)\n    return selected_monomials"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving a monomial dictionary for debugging purposes.", "response": "def save_monomial_index(filename, monomial_index):\n    \"\"\"Save a monomial dictionary for debugging purposes.\n\n    :param filename: The name of the file to save to.\n    :type filename: str.\n    :param monomial_index: The monomial index of the SDP relaxation.\n    :type monomial_index: dict of :class:`sympy.core.expr.Expr`.\n\n    \"\"\"\n    monomial_translation = [''] * (len(monomial_index) + 1)\n    for key, k in monomial_index.items():\n        monomial_translation[k] = convert_monomial_to_string(key)\n    file_ = open(filename, 'w')\n    for k in range(len(monomial_translation)):\n        file_.write('%s %s\\n' % (k, monomial_translation[k]))\n    file_.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a permutation matrix for a permutation.", "response": "def build_permutation_matrix(permutation):\n    \"\"\"Build a permutation matrix for a permutation.\n    \"\"\"\n    matrix = lil_matrix((len(permutation), len(permutation)))\n    column = 0\n    for row in permutation:\n        matrix[row, column] = 1\n        column += 1\n    return matrix"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_relational(relational):\n    rel = relational.rel_op\n    if rel in ['==', '>=', '>']:\n        return relational.lhs-relational.rhs\n    elif rel in ['<=', '<']:\n        return relational.rhs-relational.lhs\n    else:\n        raise Exception(\"The relational operation ' + rel + ' is not \"\n                        \"implemented!\")", "response": "Convert all inequalities to >=0 form."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef value(board, who='x'):\n    w = board.winner()\n    if w == who:\n        return 1\n    if w == opp(who):\n        return -1\n    if board.turn == 9:\n        return 0\n\n    if who == board.whose_turn:\n        return max([value(b, who) for b in board.possible()])\n    else:\n        return min([value(b, who) for b in board.possible()])", "response": "Returns the value of a board by its name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns best next board in order of x", "response": "def ai(board, who='x'):\n    \"\"\"\n    Returns best next board\n\n    >>> b = Board(); b._rows = [['x', 'o', ' '], ['x', 'o', ' '], [' ', ' ', ' ']]\n    >>> ai(b)\n    < Board |xo.xo.x..| >\n    \"\"\"\n    return sorted(board.possible(), key=lambda b: value(b, who))[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef winner(self):\n        for c in 'xo':\n            for comb in [(0,3,6), (1,4,7), (2,5,8), (0,1,2), (3,4,5), (6,7,8), (0,4,8), (2,4,6)]:\n                if all(self.spots[p] == c for p in comb):\n                    return c\n        return None", "response": "Returns either x or o if one of them won otherwise None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the sparse SDP relaxation of a Bell inequality. :param A_configuration: The definition of measurements of Alice. :type A_configuration: list of list of int. :param B_configuration: The definition of measurements of Bob. :type B_configuration: list of list of int. :param I: The matrix describing the Bell inequality in the Collins-Gisin picture. :type I: list of list of int.", "response": "def get_relaxation(self, A_configuration, B_configuration, I):\n        \"\"\"Get the sparse SDP relaxation of a Bell inequality.\n\n        :param A_configuration: The definition of measurements of Alice.\n        :type A_configuration: list of list of int.\n        :param B_configuration: The definition of measurements of Bob.\n        :type B_configuration: list of list of int.\n        :param I: The matrix describing the Bell inequality in the\n                  Collins-Gisin picture.\n        :type I: list of list of int.\n        \"\"\"\n        coefficients = collinsgisin_to_faacets(I)\n        M, ncIndices = get_faacets_moment_matrix(A_configuration,\n                                                 B_configuration, coefficients)\n        self.n_vars = M.max() - 1\n        bs = len(M)  # The block size\n        self.block_struct = [bs]\n        self.F = lil_matrix((bs**2, self.n_vars + 1))\n        # Constructing the internal representation of the constraint matrices\n        # See Section 2.1 in the SDPA manual and also Yalmip's internal\n        # representation\n        for i in range(bs):\n            for j in range(i, bs):\n                if M[i, j] != 0:\n                    self.F[i*bs+j, abs(M[i, j])-1] = copysign(1, M[i, j])\n        self.obj_facvar = [0 for _ in range(self.n_vars)]\n        for i in range(1, len(ncIndices)):\n            self.obj_facvar[abs(ncIndices[i])-2] += \\\n                copysign(1, ncIndices[i])*coefficients[i]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshares a track with a list of users.", "response": "def share(track_id=None, url=None, users=None):\n    \"\"\"\n    Returns list of users track has been shared with.\n    Either track or url need to be provided.\n    \"\"\"\n\n    client = get_client()\n\n    if url:\n        track_id = client.get('/resolve', url=url).id\n\n    if not users:\n        return client.get('/tracks/%d/permissions' % track_id)\n\n    permissions = {'user_id': []}\n\n    for username in users:\n        # check cache for user\n        user = settings.users.get(username, None)\n        if user:\n            permissions['user_id'].append(user['id'])\n        else:\n            user = client.get('/resolve', url='http://soundcloud.com/%s' % username)\n            permissions['user_id'].append(user.id)\n            settings.users[username] = user.obj\n    settings.save()\n\n    return client.put('/tracks/%d/permissions' % track_id, permissions=permissions)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef solve_with_cvxopt(sdp, solverparameters=None):\n    P = convert_to_picos(sdp)\n    P.set_option(\"solver\", \"cvxopt\")\n    P.set_option(\"verbose\", sdp.verbose)\n    if solverparameters is not None:\n        for key, value in solverparameters.items():\n            P.set_option(key, value)\n    solution = P.solve()\n    x_mat = [np.array(P.get_valued_variable('X'))]\n    y_mat = [np.array(P.get_constraint(i).dual)\n             for i in range(len(P.constraints))]\n    return -solution[\"cvxopt_sol\"][\"primal objective\"] + \\\n        sdp.constant_term, \\\n        -solution[\"cvxopt_sol\"][\"dual objective\"] + \\\n        sdp.constant_term, \\\n        x_mat, y_mat, solution[\"status\"]", "response": "Helper function to convert the SDP problem to PICOS\n    and call CVXOPT solver and parse the output."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_to_picos(sdp, duplicate_moment_matrix=False):\n    import picos as pic\n    import cvxopt as cvx\n    P = pic.Problem(verbose=sdp.verbose)\n    block_size = sdp.block_struct[0]\n    if sdp.F.dtype == np.float64:\n        X = P.add_variable('X', (block_size, block_size), vtype=\"symmetric\")\n        if duplicate_moment_matrix:\n            Y = P.add_variable('Y', (block_size, block_size), vtype=\"symmetric\")\n    else:\n        X = P.add_variable('X', (block_size, block_size), vtype=\"hermitian\")\n        if duplicate_moment_matrix:\n            Y = P.add_variable('X', (block_size, block_size), vtype=\"hermitian\")\n    row_offset = 0\n    theoretical_n_vars = sdp.block_struct[0]**2\n    eq_block_start = sdp.constraint_starting_block+sdp._n_inequalities\n    block_idx = 0\n    while (block_idx < len(sdp.block_struct)):\n        block_size = sdp.block_struct[block_idx]\n        x, Ix, Jx = [], [], []\n        c, Ic, Jc = [], [], []\n        for i, row in enumerate(sdp.F.rows[row_offset:row_offset +\n                                                     block_size**2]):\n            for j, column in enumerate(row):\n                if column > 0:\n                    x.append(sdp.F.data[row_offset+i][j])\n                    Ix.append(i)\n                    Jx.append(column-1)\n                    i0 = (i//block_size)+(i % block_size)*block_size\n                    if i != i0:\n                        x.append(sdp.F.data[row_offset+i][j])\n                        Ix.append(i0)\n                        Jx.append(column-1)\n\n                else:\n                    c.append(sdp.F.data[row_offset+i][j])\n                    Ic.append(i%block_size)\n                    Jc.append(i//block_size)\n        permutation = cvx.spmatrix(x, Ix, Jx, (block_size**2,\n                                               theoretical_n_vars))\n        constant = cvx.spmatrix(c, Ic, Jc, (block_size, block_size))\n        if duplicate_moment_matrix:\n            constraint = X\n        else:\n            constraint = X.copy()\n        for k in constraint.factors:\n            constraint.factors[k] = permutation\n        constraint._size = (block_size, block_size)\n        if block_idx < eq_block_start:\n            P.add_constraint(constant + constraint >> 0)\n        else:\n            P.add_constraint(constant + constraint == 0)\n            row_offset += block_size**2\n            block_idx += 1\n        if duplicate_moment_matrix and \\\n                block_size == sdp.block_struct[0]:\n            for k in Y.factors:\n                Y.factors[k] = permutation\n        row_offset += block_size**2\n        block_idx += 1\n    if len(np.nonzero(sdp.obj_facvar)[0]) > 0:\n        x, Ix, Jx = [], [], []\n        for k, val in enumerate(sdp.obj_facvar):\n            if val != 0:\n                x.append(val)\n                Ix.append(0)\n                Jx.append(k)\n        permutation = cvx.spmatrix(x, Ix, Jx)\n        objective = X.copy()\n        for k in objective.factors:\n            objective.factors[k] = permutation\n        objective._size = (1, 1)\n        P.set_objective('min', objective)\n    return P", "response": "Convert an SDP relaxation to a PICOS problem."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_to_cvxpy(sdp):\n    from cvxpy import Minimize, Problem, Variable\n    row_offsets = [0]\n    cumulative_sum = 0\n    for block_size in sdp.block_struct:\n        cumulative_sum += block_size ** 2\n        row_offsets.append(cumulative_sum)\n    x = Variable(sdp.n_vars)\n    # The moment matrices are the first blocks of identical size\n    constraints = []\n    for idx, bs in enumerate(sdp.block_struct):\n        nonzero_set = set()\n        F = [lil_matrix((bs, bs)) for _ in range(sdp.n_vars+1)]\n        for ri, row in enumerate(sdp.F.rows[row_offsets[idx]:\n                                            row_offsets[idx+1]],\n                                 row_offsets[idx]):\n            block_index, i, j = convert_row_to_sdpa_index(sdp.block_struct,\n                                                          row_offsets, ri)\n            for col_index, k in enumerate(row):\n                value = sdp.F.data[ri][col_index]\n                F[k][i, j] = value\n                F[k][j, i] = value\n                nonzero_set.add(k)\n        if bs > 1:\n            sum_ = sum(F[k]*x[k-1] for k in nonzero_set if k > 0)\n            if not isinstance(sum_, (int, float)):\n                if F[0].getnnz() > 0:\n                    sum_ += F[0]\n                constraints.append(sum_ >> 0)\n        else:\n            sum_ = sum(F[k][0, 0]*x[k-1] for k in nonzero_set if k > 0)\n            if not isinstance(sum_, (int, float)):\n                sum_ += F[0][0, 0]\n                constraints.append(sum_ >= 0)\n    obj = sum(ci*xi for ci, xi in zip(sdp.obj_facvar, x) if ci != 0)\n    problem = Problem(Minimize(obj), constraints)\n    return problem", "response": "Convert an SDP relaxation to a CVXPY problem."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_neighbors(index, lattice_length, width=0, periodic=False):\n    if width == 0:\n        width = lattice_length\n    neighbors = []\n    coords = divmod(index, width)\n    if coords[1] < width - 1:\n        neighbors.append(index + 1)\n    elif periodic and width > 1:\n        neighbors.append(index - width + 1)\n    if coords[0] < lattice_length - 1:\n        neighbors.append(index + width)\n    elif periodic:\n        neighbors.append(index - (lattice_length - 1) * width)\n    return neighbors", "response": "Get the forward neighbors of a site in a 2D lattice."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_next_neighbors(indices, lattice_length, width=0, distance=1,\n                       periodic=False):\n    \"\"\"Get the forward neighbors at a given distance of a site or set of sites\n    in a lattice.\n\n    :param index: Linear index of operator.\n    :type index: int.\n    :param lattice_length: The size of the 2D lattice in either dimension\n    :type lattice_length: int.\n    :param width: Optional parameter to define width.\n    :type width: int.\n    :param distance: Optional parameter to define distance.\n    :type width: int.\n    :param periodic: Optional parameter to indicate periodic boundary\n                     conditions.\n    :type periodic: bool\n\n    :returns: list of int -- the neighbors at given distance in linear index.\n    \"\"\"\n    if not isinstance(indices, list):\n        indices = [indices]\n    if distance == 1:\n        return flatten(get_neighbors(index, lattice_length, width, periodic)\n                       for index in indices)\n    else:\n        s1 = set(flatten(get_next_neighbors(get_neighbors(index,\n                                                          lattice_length,\n                                                          width, periodic),\n                                            lattice_length, width, distance-1,\n                                            periodic) for index in indices))\n        s2 = set(get_next_neighbors(indices, lattice_length, width, distance-1,\n                                    periodic))\n        return list(s1 - s2)", "response": "Get the next neighbors of a given set of sites."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bosonic_constraints(a):\n    substitutions = {}\n    for i, ai in enumerate(a):\n        substitutions[ai * Dagger(ai)] = 1.0 + Dagger(ai) * ai\n        for aj in a[i+1:]:\n            # substitutions[ai*Dagger(aj)] = -Dagger(ai)*aj\n            substitutions[ai*Dagger(aj)] = Dagger(aj)*ai\n            substitutions[Dagger(ai)*aj] = aj*Dagger(ai)\n            substitutions[ai*aj] = aj*ai\n            substitutions[Dagger(ai) * Dagger(aj)] = Dagger(aj) * Dagger(ai)\n\n    return substitutions", "response": "Returns a set of constraints that define fermionic ladder operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fermionic_constraints(a):\n    substitutions = {}\n    for i, ai in enumerate(a):\n        substitutions[ai ** 2] = 0\n        substitutions[Dagger(ai) ** 2] = 0\n        substitutions[ai * Dagger(ai)] = 1.0 - Dagger(ai) * ai\n        for aj in a[i+1:]:\n            # substitutions[ai*Dagger(aj)] = -Dagger(ai)*aj\n            substitutions[ai*Dagger(aj)] = -Dagger(aj)*ai\n            substitutions[Dagger(ai)*aj] = -aj*Dagger(ai)\n            substitutions[ai*aj] = -aj*ai\n            substitutions[Dagger(ai) * Dagger(aj)] = - Dagger(aj) * Dagger(ai)\n\n    return substitutions", "response": "Returns a set of constraints that define fermionic ladder operators."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pauli_constraints(X, Y, Z):\n    substitutions = {}\n    n_vars = len(X)\n    for i in range(n_vars):\n        # They square to the identity\n        substitutions[X[i] * X[i]] = 1\n        substitutions[Y[i] * Y[i]] = 1\n        substitutions[Z[i] * Z[i]] = 1\n\n        # Anticommutation relations\n        substitutions[Y[i] * X[i]] = - X[i] * Y[i]\n        substitutions[Z[i] * X[i]] = - X[i] * Z[i]\n        substitutions[Z[i] * Y[i]] = - Y[i] * Z[i]\n        # Commutation relations.\n        # equalities.append(X[i]*Y[i] - 1j*Z[i])\n        # equalities.append(X[i]*Z[i] + 1j*Y[i])\n        # equalities.append(Y[i]*Z[i] - 1j*X[i])\n        # They commute between the sites\n        for j in range(i + 1, n_vars):\n            substitutions[X[j] * X[i]] = X[i] * X[j]\n            substitutions[Y[j] * Y[i]] = Y[i] * Y[j]\n            substitutions[Y[j] * X[i]] = X[i] * Y[j]\n            substitutions[Y[i] * X[j]] = X[j] * Y[i]\n            substitutions[Z[j] * Z[i]] = Z[i] * Z[j]\n            substitutions[Z[j] * X[i]] = X[i] * Z[j]\n            substitutions[Z[i] * X[j]] = X[j] * Z[i]\n            substitutions[Z[j] * Y[i]] = Y[i] * Z[j]\n            substitutions[Z[i] * Y[j]] = Y[j] * Z[i]\n    return substitutions", "response": "Returns a set of constraints that define Pauli spin operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_measurements(party, label):\n    measurements = []\n    for i in range(len(party)):\n        measurements.append(generate_operators(label + '%s' % i, party[i] - 1,\n                                               hermitian=True))\n    return measurements", "response": "Generates symbolic variables that behave like measurements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a set of constraints that define projective measurements.", "response": "def projective_measurement_constraints(*parties):\n    \"\"\"Return a set of constraints that define projective measurements.\n\n    :param parties: Measurements of different parties.\n    :type A: list or tuple of list of list of\n             :class:`sympy.physics.quantum.operator.HermitianOperator`.\n\n    :returns: substitutions containing idempotency, orthogonality and\n              commutation relations.\n    \"\"\"\n    substitutions = {}\n    # Idempotency and orthogonality of projectors\n    if isinstance(parties[0][0][0], list):\n        parties = parties[0]\n    for party in parties:\n        for measurement in party:\n            for projector1 in measurement:\n                for projector2 in measurement:\n                    if projector1 == projector2:\n                        substitutions[projector1**2] = projector1\n                    else:\n                        substitutions[projector1*projector2] = 0\n                        substitutions[projector2*projector1] = 0\n    # Projectors commute between parties in a partition\n    for n1 in range(len(parties)):\n        for n2 in range(n1+1, len(parties)):\n            for measurement1 in parties[n1]:\n                for measurement2 in parties[n2]:\n                    for projector1 in measurement1:\n                        for projector2 in measurement2:\n                            substitutions[projector2*projector1] = \\\n                                projector1*projector2\n    return substitutions"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndefining a polynomial using measurements and an I matrix describing a Bell etic inequality.", "response": "def define_objective_with_I(I, *args):\n    \"\"\"Define a polynomial using measurements and an I matrix describing a Bell\n    inequality.\n\n    :param I: The I matrix of a Bell inequality in the Collins-Gisin notation.\n    :type I: list of list of int.\n    :param args: Either the measurements of Alice and Bob or a `Probability`\n                 class describing their measurement operators.\n    :type A: tuple of list of list of\n             :class:`sympy.physics.quantum.operator.HermitianOperator` or\n             :class:`ncpol2sdpa.Probability`\n\n    :returns: :class:`sympy.core.expr.Expr` -- the objective function to be\n              solved as a minimization problem to find the maximum quantum\n              violation. Note that the sign is flipped compared to the Bell\n              inequality.\n    \"\"\"\n    objective = I[0][0]\n    if len(args) > 2 or len(args) == 0:\n        raise Exception(\"Wrong number of arguments!\")\n    elif len(args) == 1:\n        A = args[0].parties[0]\n        B = args[0].parties[1]\n    else:\n        A = args[0]\n        B = args[1]\n    i, j = 0, 1  # Row and column index in I\n    for m_Bj in B:  # Define first row\n        for Bj in m_Bj:\n            objective += I[i][j] * Bj\n            j += 1\n    i += 1\n    for m_Ai in A:\n        for Ai in m_Ai:\n            objective += I[i][0] * Ai\n            j = 1\n            for m_Bj in B:\n                for Bj in m_Bj:\n                    objective += I[i][j] * Ai * Bj\n                    j += 1\n            i += 1\n    return -objective"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef correlator(A, B):\n    correlators = []\n    for i in range(len(A)):\n        correlator_row = []\n        for j in range(len(B)):\n            corr = 0\n            for k in range(len(A[i])):\n                for l in range(len(B[j])):\n                    if k == l:\n                        corr += A[i][k] * B[j][l]\n                    else:\n                        corr -= A[i][k] * B[j][l]\n            correlator_row.append(corr)\n        correlators.append(correlator_row)\n    return correlators", "response": "Returns the correlators between the probabilities of two parties."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef maximum_violation(A_configuration, B_configuration, I, level, extra=None):\n    P = Probability(A_configuration, B_configuration)\n    objective = define_objective_with_I(I, P)\n    if extra is None:\n        extramonomials = []\n    else:\n        extramonomials = P.get_extra_monomials(extra)\n    sdpRelaxation = SdpRelaxation(P.get_all_operators(), verbose=0)\n    sdpRelaxation.get_relaxation(level, objective=objective,\n                                 substitutions=P.substitutions,\n                                 extramonomials=extramonomials)\n    solve_sdp(sdpRelaxation)\n    return sdpRelaxation.primal, sdpRelaxation.dual", "response": "Get the maximum violation of a two - party Bell inequality."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stable_format_dict(d):\n    inner = ', '.join('{}: {}'.format(repr(k)[1:]\n                                      if repr(k).startswith(u\"u'\") or repr(k).startswith(u'u\"')\n                                      else repr(k),\n                                      v)\n                      for k, v in sorted(d.items()))\n    return '{%s}' % inner", "response": "A sorted python2 / 3 stable formatting of a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns by how much two intervals overlap a and b.", "response": "def interval_overlap(a, b, x, y):\n    \"\"\"Returns by how much two intervals overlap\n\n    assumed that a <= b and x <= y\"\"\"\n    if b <= x or a >= y:\n        return 0\n    elif x <= a <= y:\n        return min(b, y) - a\n    elif x <= b <= y:\n        return b - max(a, x)\n    elif a >= x and b <= y:\n        return b - a\n    else:\n        assert False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef width_aware_slice(s, start, end, replacement_char=u' '):\n    # type: (Text, int, int, Text)\n    \"\"\"\n    >>> width_aware_slice(u'a\\uff25iou', 0, 2)[1] == u' '\n    True\n    \"\"\"\n    divides = [0]\n    for c in s:\n        divides.append(divides[-1] + wcswidth(c))\n\n    new_chunk_chars = []\n    for char, char_start, char_end in zip(s, divides[:-1], divides[1:]):\n        if char_start == start and char_end == start:\n            continue  # don't use zero-width characters at the beginning of a slice\n                      # (combining characters combine with the chars before themselves)\n        elif char_start >= start and char_end <= end:\n            new_chunk_chars.append(char)\n        else:\n            new_chunk_chars.extend(replacement_char * interval_overlap(char_start, char_end, start, end))\n\n    return ''.join(new_chunk_chars)", "response": "Returns a slice of a string that is width - aware."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef linesplit(string, columns):\n    # type: (Union[Text, FmtStr], int) -> List[FmtStr]\n    \"\"\"Returns a list of lines, split on the last possible space of each line.\n\n    Split spaces will be removed. Whitespaces will be normalized to one space.\n    Spaces will be the color of the first whitespace character of the\n    normalized whitespace.\n    If a word extends beyond the line, wrap it anyway.\n\n    >>> linesplit(fmtstr(\" home    is where the heart-eating mummy is\", 'blue'), 10)\n    [blue('home')+blue(' ')+blue('is'), blue('where')+blue(' ')+blue('the'), blue('heart-eati'), blue('ng')+blue(' ')+blue('mummy'), blue('is')]\n    \"\"\"\n    if not isinstance(string, FmtStr):\n        string = fmtstr(string)\n\n    string_s = string.s\n    matches = list(re.finditer(r'\\s+', string_s))\n    spaces = [string[m.start():m.end()] for m in matches if m.start() != 0 and m.end() != len(string_s)]\n    words = [string[start:end] for start, end in zip(\n            [0] + [m.end() for m in matches],\n            [m.start() for m in matches] + [len(string_s)]) if start != end]\n\n    word_to_lines = lambda word: [word[columns*i:columns*(i+1)] for i in range((len(word) - 1) // columns + 1)]\n\n    lines = word_to_lines(words[0])\n    for word, space in zip(words[1:], spaces):\n        if len(lines[-1]) + len(word) < columns:\n            lines[-1] += fmtstr(' ', **space.shared_atts)\n            lines[-1] += word\n        else:\n            lines.extend(word_to_lines(word))\n    return lines", "response": "Returns a list of lines split on the last possible space of each line."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfills in the Nones in a slice.", "response": "def normalize_slice(length, index):\n    \"Fill in the Nones in a slice.\"\n    is_int = False\n    if isinstance(index, int):\n        is_int = True\n        index = slice(index, index+1)\n    if index.start is None:\n        index = slice(0, index.stop, index.step)\n    if index.stop is None:\n        index = slice(index.start, length, index.step)\n    if index.start < -1:         # XXX why must this be -1?\n        index = slice(length - index.start, index.stop, index.step)\n    if index.stop < -1:          # XXX why must this be -1?\n        index = slice(index.start, length - index.stop, index.step)\n    if index.step is not None:\n        raise NotImplementedError(\"You can't use steps with slicing yet\")\n    if is_int:\n        if index.start < 0 or index.start > length:\n            raise IndexError(\"index out of bounds: %r for length %s\" % (index, length))\n    return index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_args(args, kwargs):\n    if 'style' in kwargs:\n        args += (kwargs['style'],)\n        del kwargs['style']\n    for arg in args:\n        if not isinstance(arg, (bytes, unicode)):\n            raise ValueError(\"args must be strings:\" + repr(args))\n        if arg.lower() in FG_COLORS:\n            if 'fg' in kwargs: raise ValueError(\"fg specified twice\")\n            kwargs['fg'] = FG_COLORS[arg]\n        elif arg.lower().startswith('on_') and arg[3:].lower() in BG_COLORS:\n            if 'bg' in kwargs: raise ValueError(\"fg specified twice\")\n            kwargs['bg'] = BG_COLORS[arg[3:]]\n        elif arg.lower() in STYLES:\n            kwargs[arg] = True\n        else:\n            raise ValueError(\"couldn't process arg: \"+repr(arg))\n    for k in kwargs:\n        if k not in ['fg', 'bg'] + list(STYLES.keys()):\n            raise ValueError(\"Can't apply that transformation\")\n    if 'fg' in kwargs:\n        if kwargs['fg'] in FG_COLORS:\n            kwargs['fg'] = FG_COLORS[kwargs['fg']]\n        if kwargs['fg'] not in list(FG_COLORS.values()):\n            raise ValueError(\"Bad fg value: %r\" % kwargs['fg'])\n    if 'bg' in kwargs:\n        if kwargs['bg'] in BG_COLORS:\n            kwargs['bg'] = BG_COLORS[kwargs['bg']]\n        if kwargs['bg'] not in list(BG_COLORS.values()):\n            raise ValueError(\"Bad bg value: %r\" % kwargs['bg'])\n    return kwargs", "response": "Parse the arguments into a dictionary by turning them into kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an escape - coded string to write to the terminal.", "response": "def color_str(self):\n        \"Return an escape-coded string to write to the terminal.\"\n        s = self.s\n        for k, v in sorted(self.atts.items()):\n            # (self.atts sorted for the sake of always acting the same.)\n            if k not in xforms:\n                # Unsupported SGR code\n                continue\n            elif v is False:\n                continue\n            elif v is True:\n                s = xforms[k](s)\n            else:\n                s = xforms[k](s, v)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef repr_part(self):\n        def pp_att(att):\n            if att == 'fg': return FG_NUMBER_TO_COLOR[self.atts[att]]\n            elif att == 'bg': return 'on_' + BG_NUMBER_TO_COLOR[self.atts[att]]\n            else: return att\n        atts_out = dict((k, v) for (k, v) in self.atts.items() if v)\n        return (''.join(pp_att(att)+'(' for att in sorted(atts_out))\n                + (repr(self.s) if PY3 else repr(self.s)[1:]) + ')'*len(atts_out))", "response": "FmtStr repr is build by concatenating these."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequest a sub - chunk of max_width or shorter. Returns None if no more chunks are available. Returns None if no more chunks are available. Returns None if no more chunks are available. Returns None if no more chunks are available.", "response": "def request(self, max_width):\n        # type: (int) -> Optional[Tuple[int, Chunk]]\n        \"\"\"Requests a sub-chunk of max_width or shorter. Returns None if no chunks left.\"\"\"\n        if max_width < 1:\n            raise ValueError('requires positive integer max_width')\n\n        s = self.chunk.s\n        length = len(s)\n\n        if self.internal_offset == len(s):\n            return None\n\n        width = 0\n        start_offset = i = self.internal_offset\n        replacement_char = u' '\n\n        while True:\n            w = wcswidth(s[i])\n\n            # If adding a character puts us over the requested width, return what we've got so far\n            if width + w > max_width:\n                self.internal_offset = i  # does not include ith character\n                self.internal_width += width\n\n                # if not adding it us makes us short, this must have been a double-width character\n                if width < max_width:\n                    assert width + 1 == max_width, 'unicode character width of more than 2!?!'\n                    assert w == 2, 'unicode character of width other than 2?'\n                    return (width + 1, Chunk(s[start_offset:self.internal_offset] + replacement_char,\n                                             atts=self.chunk.atts))\n                return (width, Chunk(s[start_offset:self.internal_offset], atts=self.chunk.atts))\n            # otherwise add this width\n            width += w\n\n            # If one more char would put us over, return whatever we've got\n            if i + 1 == length:\n                self.internal_offset = i + 1  # beware the fencepost, i is an index not an offset\n                self.internal_width += width\n                return (width, Chunk(s[start_offset:self.internal_offset], atts=self.chunk.atts))\n            # otherwise attempt to add the next character\n            i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncopying the current FmtStr s attributes while changing its string.", "response": "def copy_with_new_str(self, new_str):\n        \"\"\"Copies the current FmtStr's attributes while changing its string.\"\"\"\n        # What to do when there are multiple Chunks with conflicting atts?\n        old_atts = dict((att, value) for bfs in self.chunks\n                    for (att, value) in bfs.atts.items())\n        return FmtStr(Chunk(new_str, old_atts))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshims for easily converting old __setitem__ calls", "response": "def setitem(self, startindex, fs):\n        \"\"\"Shim for easily converting old __setitem__ calls\"\"\"\n        return self.setslice_with_length(startindex, startindex+1, fs, len(self))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshimming for easily converting old __setitem__ calls", "response": "def setslice_with_length(self, startindex, endindex, fs, length):\n        \"\"\"Shim for easily converting old __setitem__ calls\"\"\"\n        if len(self) < startindex:\n            fs = ' '*(startindex - len(self)) + fs\n        if len(self) > endindex:\n            fs = fs + ' '*(endindex - startindex - len(fs))\n            assert len(fs) == endindex - startindex, (len(fs), startindex, endindex)\n        result = self.splice(fs, startindex, endindex)\n        assert len(result) <= length\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef splice(self, new_str, start, end=None):\n        if len(new_str) == 0:\n            return self\n        new_fs = new_str if isinstance(new_str, FmtStr) else fmtstr(new_str)\n        assert len(new_fs.chunks) > 0, (new_fs.chunks, new_fs)\n        new_components = []\n        inserted = False\n        if end is None:\n            end = start\n        tail = None\n\n        for bfs, bfs_start, bfs_end in zip(self.chunks,\n                                           self.divides[:-1],\n                                           self.divides[1:]):\n            if end == bfs_start == 0:\n                new_components.extend(new_fs.chunks)\n                new_components.append(bfs)\n                inserted = True\n\n            elif bfs_start <= start < bfs_end:\n                divide = start - bfs_start\n                head = Chunk(bfs.s[:divide], atts=bfs.atts)\n                tail = Chunk(bfs.s[end - bfs_start:], atts=bfs.atts)\n                new_components.extend([head] + new_fs.chunks)\n                inserted = True\n\n                if bfs_start < end < bfs_end:\n                    tail = Chunk(bfs.s[end - bfs_start:], atts=bfs.atts)\n                    new_components.append(tail)\n\n            elif bfs_start < end < bfs_end:\n                divide = start - bfs_start\n                tail = Chunk(bfs.s[end - bfs_start:], atts=bfs.atts)\n                new_components.append(tail)\n\n            elif bfs_start >= end or bfs_end <= start:\n                new_components.append(bfs)\n\n        if not inserted:\n            new_components.extend(new_fs.chunks)\n            inserted = True\n\n        return FmtStr(*[s for s in new_components if s.s])", "response": "Returns a new FmtStr with the input string spliced into the FmtStr at start and end."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy_with_new_atts(self, **attributes):\n        return FmtStr(*[Chunk(bfs.s, bfs.atts.extend(attributes))\n                        for bfs in self.chunks])", "response": "Returns a new FmtStr with the same content but new formatting"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef join(self, iterable):\n        before = []\n        chunks = []\n        for i, s in enumerate(iterable):\n            chunks.extend(before)\n            before = self.chunks\n            if isinstance(s, FmtStr):\n                chunks.extend(s.chunks)\n            elif isinstance(s, (bytes, unicode)):\n                chunks.extend(fmtstr(s).chunks) #TODO just make a chunk directly\n            else:\n                raise TypeError(\"expected str or FmtStr, %r found\" % type(s))\n        return FmtStr(*chunks)", "response": "Joins an iterable yielding strings or FmtStrs with self as separator"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split(self, sep=None, maxsplit=None, regex=False):\n        if maxsplit is not None:\n            raise NotImplementedError('no maxsplit yet')\n        s = self.s\n        if sep is None:\n            sep = r'\\s+'\n        elif not regex:\n            sep = re.escape(sep)\n        matches = list(re.finditer(sep, s))\n        return [self[start:end] for start, end in zip(\n            [0] + [m.end() for m in matches],\n            [m.start() for m in matches] + [len(s)])]", "response": "Split based on seperator optionally using a regex\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef splitlines(self, keepends=False):\n        lines = self.split('\\n')\n        return [line+'\\n' for line in lines] if keepends else (\n               lines if lines[-1] else lines[:-1])", "response": "Return a list of lines split on newline characters and include line boundaries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the horizontal position of the character n of the string", "response": "def width_at_offset(self, n):\n        \"\"\"Returns the horizontal position of character n of the string\"\"\"\n        #TODO make more efficient?\n        width = wcswidth(self.s[:n])\n        assert width != -1\n        return width"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget atts shared among all nonzero length component Chunks", "response": "def shared_atts(self):\n        \"\"\"Gets atts shared among all nonzero length component Chunk\"\"\"\n        #TODO cache this, could get ugly for large FmtStrs\n        atts = {}\n        first = self.chunks[0]\n        for att in sorted(first.atts):\n            #TODO how to write this without the '???'?\n            if all(fs.atts.get(att, '???') == first.atts[att] for fs in self.chunks if len(fs) > 0):\n                atts[att] = first.atts[att]\n        return atts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef new_with_atts_removed(self, *attributes):\n        return FmtStr(*[Chunk(bfs.s, bfs.atts.remove(*attributes))\n                        for bfs in self.chunks])", "response": "Returns a new FmtStr with the same content but some attributes removed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist of indices of divisions between the constituent chunks.", "response": "def divides(self):\n        \"\"\"List of indices of divisions between the constituent chunks.\"\"\"\n        acc = [0]\n        for s in self.chunks:\n            acc.append(acc[-1] + len(s))\n        return acc"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a slice based on the number of columns it would take to display the substring.", "response": "def width_aware_slice(self, index):\n        \"\"\"Slice based on the number of columns it would take to display the substring.\"\"\"\n        if wcswidth(self.s) == -1:\n            raise ValueError('bad values for width aware slicing')\n        index = normalize_slice(self.width, index)\n        counter = 0\n        parts = []\n        for chunk in self.chunks:\n            if index.start < counter + chunk.width and index.stop > counter:\n                start = max(0, index.start - counter)\n                end = min(index.stop - counter, chunk.width)\n                if end - start == chunk.width:\n                    parts.append(chunk)\n                else:\n                    s_part = width_aware_slice(chunk.s, max(0, index.start - counter), index.stop - counter)\n                    parts.append(Chunk(s_part, chunk.atts))\n            counter += chunk.width\n            if index.stop < counter:\n                break\n        return FmtStr(*parts) if parts else fmtstr('')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsplitting into lines pushing double - width characters at the end of a line to the next line.", "response": "def width_aware_splitlines(self, columns):\n        # type: (int) -> Iterator[FmtStr]\n        \"\"\"Split into lines, pushing doublewidth characters at the end of a line to the next line.\n\n        When a double-width character is pushed to the next line, a space is added to pad out the line.\n        \"\"\"\n        if columns < 2:\n            raise ValueError(\"Column width %s is too narrow.\" % columns)\n        if wcswidth(self.s) == -1:\n            raise ValueError('bad values for width aware slicing')\n        return self._width_aware_splitlines(columns)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild the more compact fmtstrs by using fromstr of the control sequences.", "response": "def _getitem_normalized(self, index):\n        \"\"\"Builds the more compact fmtstrs by using fromstr( of the control sequences)\"\"\"\n        index = normalize_slice(len(self), index)\n        counter = 0\n        output = ''\n        for fs in self.chunks:\n            if index.start < counter + len(fs) and index.stop > counter:\n                s_part = fs.s[max(0, index.start - counter):index.stop - counter]\n                piece = Chunk(s_part, fs.atts).color_str\n                output += piece\n            counter += len(fs)\n            if index.stop < counter:\n                break\n        return fmtstr(output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _calculate_block_structure(self, inequalities, equalities,\n                                   momentinequalities, momentequalities,\n                                   extramomentmatrix, removeequalities,\n                                   block_struct=None):\n        \"\"\"Calculates the block_struct array for the output file.\n        \"\"\"\n        block_struct = []\n        if self.verbose > 0:\n            print(\"Calculating block structure...\")\n        block_struct.append(len(self.monomial_sets[0]) *\n                            len(self.monomial_sets[1]))\n        if extramomentmatrix is not None:\n            for _ in extramomentmatrix:\n                block_struct.append(len(self.monomial_sets[0]) *\n                                    len(self.monomial_sets[1]))\n        super(MoroderHierarchy, self).\\\n            _calculate_block_structure(inequalities, equalities,\n                                       momentinequalities, momentequalities,\n                                       extramomentmatrix,\n                                       removeequalities,\n                                       block_struct=block_struct)", "response": "Calculates the block_struct array for the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _process_monomial(self, monomial, n_vars):\n        coeff, monomial = monomial.as_coeff_Mul()\n        k = 0\n        # Have we seen this monomial before?\n        conjugate = False\n        try:\n            # If yes, then we improve sparsity by reusing the\n            # previous variable to denote this entry in the matrix\n            k = self.monomial_index[monomial]\n        except KeyError:\n            # An extra round of substitutions is granted on the conjugate of\n            # the monomial if all the variables are Hermitian\n            daggered_monomial = \\\n                apply_substitutions(Dagger(monomial), self.substitutions,\n                                    self.pure_substitution_rules)\n            try:\n                k = self.monomial_index[daggered_monomial]\n                conjugate = True\n            except KeyError:\n                # Otherwise we define a new entry in the associated\n                # array recording the monomials, and add an entry in\n                # the moment matrix\n                k = n_vars + 1\n                self.monomial_index[monomial] = k\n        if conjugate:\n            k = -k\n        return k, coeff", "response": "Process a single monomial when building the moment matrix."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __get_trace_facvar(self, polynomial):\n        facvar = [0] * (self.n_vars + 1)\n        F = {}\n        for i in range(self.matrix_var_dim):\n            for j in range(self.matrix_var_dim):\n                for key, value in \\\n                        polynomial[i, j].as_coefficients_dict().items():\n                    skey = apply_substitutions(key, self.substitutions,\n                                               self.pure_substitution_rules)\n                    try:\n                        Fk = F[skey]\n                    except KeyError:\n                        Fk = zeros(self.matrix_var_dim, self.matrix_var_dim)\n                    Fk[i, j] += value\n                    F[skey] = Fk\n        # This is the tracing part\n        for key, Fk in F.items():\n            if key == S.One:\n                k = 1\n            else:\n                k = self.monomial_index[key]\n            for i in range(self.matrix_var_dim):\n                for j in range(self.matrix_var_dim):\n                    sym_matrix = zeros(self.matrix_var_dim,\n                                       self.matrix_var_dim)\n                    sym_matrix[i, j] = 1\n                    facvar[k+i*self.matrix_var_dim+j] = (sym_matrix*Fk).trace()\n        facvar = [float(f) for f in facvar]\n        return facvar", "response": "This function returns a dense vector representation of a polynomial. This function is also intended to be used by the trace function of the polynomial. This function is also intended to be used by the pushing_facvar_sparse function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset or change the objective function of the polynomial optimization.", "response": "def set_objective(self, objective, extraobjexpr=None):\n        \"\"\"Set or change the objective function of the polynomial optimization\n        problem.\n\n        :param objective: Describes the objective function.\n        :type objective: :class:`sympy.core.expr.Expr`\n        :param extraobjexpr: Optional parameter of a string expression of a\n                             linear combination of moment matrix elements to be\n                             included in the objective function\n        :type extraobjexpr: str.\n        \"\"\"\n        if objective is not None and self.matrix_var_dim is not None:\n            facvar = self.__get_trace_facvar(objective)\n            self.obj_facvar = facvar[1:]\n            self.constant_term = facvar[0]\n            if self.verbose > 0 and facvar[0] != 0:\n                print(\"Warning: The objective function has a non-zero %s \"\n                      \"constant term. It is not included in the SDP objective.\"\n                      % facvar[0])\n        else:\n            super(SteeringHierarchy, self).\\\n              set_objective(objective, extraobjexpr=extraobjexpr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _calculate_block_structure(self, inequalities, equalities,\n                                   momentinequalities, momentequalities,\n                                   extramomentmatrix, removeequalities,\n                                   block_struct=None):\n        \"\"\"Calculates the block_struct array for the output file.\n        \"\"\"\n        super(SteeringHierarchy, self).\\\n          _calculate_block_structure(inequalities, equalities,\n                                     momentinequalities, momentequalities,\n                                     extramomentmatrix, removeequalities)\n        if self.matrix_var_dim is not None:\n            self.block_struct = [self.matrix_var_dim*bs\n                                 for bs in self.block_struct]", "response": "Calculates the block_struct array for the output file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the relaxation to a file.", "response": "def write_to_file(self, filename, filetype=None):\n        \"\"\"Write the relaxation to a file.\n\n        :param filename: The name of the file to write to. The type can be\n                         autodetected from the extension: .dat-s for SDPA,\n                         .task for mosek, .csv for human readable format, or\n                         .txt for a symbolic export\n        :type filename: str.\n        :param filetype: Optional parameter to define the filetype. It can be\n                         \"sdpa\" for SDPA , \"mosek\" for Mosek, \"csv\" for\n                         human readable format, or \"txt\" for a symbolic export.\n        :type filetype: str.\n        \"\"\"\n        if filetype == \"txt\" and not filename.endswith(\".txt\"):\n            raise Exception(\"TXT files must have .txt extension!\")\n        elif filetype is None and filename.endswith(\".txt\"):\n            filetype = \"txt\"\n        else:\n            return super(SteeringHierarchy, self).write_to_file(filename,\n                                                                filetype=filetype)\n        tempfile_ = tempfile.NamedTemporaryFile()\n        tmp_filename = tempfile_.name\n        tempfile_.close()\n        tmp_dats_filename = tmp_filename + \".dat-s\"\n        write_to_sdpa(self, tmp_dats_filename)\n        f = open(tmp_dats_filename, 'r')\n        f.readline();f.readline();f.readline()\n        blocks = ((f.readline().strip().split(\" = \")[0])[1:-1]).split(\", \")\n        block_offset, matrix_size = [0], 0\n        for block in blocks:\n            matrix_size += abs(int(block))\n            block_offset.append(matrix_size)\n        f.readline()\n        matrix = [[0 for _ in range(matrix_size)] for _ in range(matrix_size)]\n        for line in f:\n            entry = line.strip().split(\"\\t\")\n            var, block = int(entry[0]), int(entry[1])-1\n            row, column = int(entry[2]) - 1, int(entry[3]) - 1\n            value = float(entry[4])\n            offset = block_offset[block]\n            matrix[offset+row][offset+column] = int(value*var)\n            matrix[offset+column][offset+row] = int(value*var)\n        f.close()\n        f = open(filename, 'w')\n        for matrix_line in matrix:\n            f.write(str(matrix_line).replace('[', '').replace(']', '') + '\\n')\n        f.close()\n        os.remove(tmp_dats_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the outerframe of the given level skipping importlib frames.", "response": "def get_outerframe_skip_importlib_frame(level):\n        \"\"\"\n        There's a bug in Python3.4+, see http://bugs.python.org/issue23773,\n        remove this and use sys._getframe(3) when bug is fixed\n        \"\"\"\n        if sys.version_info < (3, 4):\n            return sys._getframe(level)\n        else:\n            currentframe = inspect.currentframe()\n            levelup = 0\n            while levelup < level:\n                currentframe = currentframe.f_back\n                if currentframe.f_globals['__name__'] == 'importlib._bootstrap':\n                    continue\n                else:\n                    levelup += 1\n            return currentframe"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntemplates function of public api", "response": "def public_api(self,url):\n        ''' template function of public api'''\n        try :\n            url in api_urls\n            return ast.literal_eval(requests.get(base_url + api_urls.get(url)).text)\n        except Exception as e:\n            print(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef peel_off_esc_code(s):\n    p = r\"\"\"(?P<front>.*?)\n            (?P<seq>\n                (?P<csi>\n                    (?:[\u001b]\\[)\n                    |\n                    [\"\"\"+'\\x9b' + r\"\"\"])\n                (?P<private>)\n                (?P<numbers>\n                    (?:\\d+;)*\n                    (?:\\d+)?)\n                (?P<intermed>\"\"\" + '[\\x20-\\x2f]*)' + r\"\"\"\n                (?P<command>\"\"\" + '[\\x40-\\x7e]))' + r\"\"\"\n            (?P<rest>.*)\"\"\"\n    m1 = re.match(p, s, re.VERBOSE)  # multibyte esc seq\n    m2 = re.match('(?P<front>.*?)(?P<seq>(?P<csi>\u001b)(?P<command>[\\x40-\\x5f]))(?P<rest>.*)', s)  # 2 byte escape sequence\n    if m1 and m2:\n        m = m1 if len(m1.groupdict()['front']) <= len(m2.groupdict()['front']) else m2\n        # choose the match which has less processed text in order to get the\n        # first escape sequence\n    elif m1: m = m1\n    elif m2: m = m2\n    else: m = None\n\n    if m:\n        d = m.groupdict()\n        del d['front']\n        del d['rest']\n        if 'numbers' in d and all(d['numbers'].split(';')):\n            d['numbers'] = [int(x) for x in d['numbers'].split(';')]\n\n        return m.groupdict()['front'], d, m.groupdict()['rest']\n    else:\n        return s, None, ''", "response": "Return the processed text the next token and unprocessed text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_key(bytes_, encoding, keynames='curtsies', full=False):\n    if not all(isinstance(c, type(b'')) for c in bytes_):\n        raise ValueError(\"get key expects bytes, got %r\" % bytes_) # expects raw bytes\n    if keynames not in ['curtsies', 'curses', 'bytes']:\n        raise ValueError(\"keynames must be one of 'curtsies', 'curses' or 'bytes'\")\n    seq = b''.join(bytes_)\n    if len(seq) > MAX_KEYPRESS_SIZE:\n        raise ValueError('unable to decode bytes %r' % seq)\n\n    def key_name():\n        if keynames == 'curses':\n            if seq in CURSES_NAMES: # may not be here (and still not decodable) curses names incomplete\n                return CURSES_NAMES[seq]\n\n            # Otherwise, there's no special curses name for this\n            try:\n                return seq.decode(encoding) # for normal decodable text or a special curtsies sequence with bytes that can be decoded\n            except UnicodeDecodeError:\n                # this sequence can't be decoded with this encoding, so we need to represent the bytes\n                if len(seq) == 1:\n                    return u'x%02X' % ord(seq)\n                    #TODO figure out a better thing to return here\n                else:\n                    raise NotImplementedError(\"are multibyte unnameable sequences possible?\")\n                    return u'bytes: ' + u'-'.join(u'x%02X' % ord(seq[i:i+1]) for i in range(len(seq)))\n                    #TODO if this isn't possible, return multiple meta keys as a paste event if paste events enabled\n        elif keynames == 'curtsies':\n            if seq in CURTSIES_NAMES:\n                return CURTSIES_NAMES[seq]\n            return seq.decode(encoding) #assumes that curtsies names are a subset of curses ones\n        else:\n            assert keynames == 'bytes'\n            return seq\n\n    key_known = seq in CURTSIES_NAMES or seq in CURSES_NAMES or decodable(seq, encoding)\n\n    if full and key_known:\n        return key_name()\n    elif seq in KEYMAP_PREFIXES or could_be_unfinished_char(seq, encoding):\n        return None # need more input to make up a full keypress\n    elif key_known:\n        return key_name()\n    else:\n        seq.decode(encoding) # this will raise a unicode error (they're annoying to raise ourselves)\n        assert False, 'should have raised an unicode decode error'", "response": "Return a key pressed from bytes_ or None meaning it s an incomplete sequence of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef could_be_unfinished_char(seq, encoding):\n    if decodable(seq, encoding):\n        return False # any sensible encoding surely doesn't require lookahead (right?)\n        # (if seq bytes encoding a character, adding another byte shouldn't also encode something)\n\n    if encodings.codecs.getdecoder('utf8') is encodings.codecs.getdecoder(encoding):\n        return could_be_unfinished_utf8(seq)\n    elif encodings.codecs.getdecoder('ascii') is encodings.codecs.getdecoder(encoding):\n        return False\n    else:\n        return True", "response": "Whether seq bytes might create a char in encoding if more bytes were added"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pp_event(seq):\n\n    if isinstance(seq, Event):\n        return str(seq)\n\n    # Get the original sequence back if seq is a pretty name already\n    rev_curses = dict((v, k) for k, v in CURSES_NAMES.items())\n    rev_curtsies = dict((v, k) for k, v in CURTSIES_NAMES.items())\n    if seq in rev_curses:\n        seq = rev_curses[seq]\n    elif seq in rev_curtsies:\n        seq = rev_curtsies[seq]\n\n    pretty = curtsies_name(seq)\n    if pretty != seq:\n        return pretty\n    return repr(seq).lstrip('u')[1:-1]", "response": "Returns a pretty representation of an Event or keypress"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_nouns(max=2):\n    nouns = []\n    for noun in range(0, max):\n        nouns.append(random.choice(noun_list))\n    return \" \".join(nouns)", "response": "Return a string of random nouns up to max number"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a random valid date based on the given parameters", "response": "def create_date(past=False, max_years_future=10, max_years_past=10):\n    \"\"\"\n    Create a random valid date\n    If past, then dates can be in the past\n    If into the future, then no more than max_years into the future\n    If it's not, then it can't be any older than max_years_past\n    \"\"\"\n    if past:\n        start = datetime.datetime.today() - datetime.timedelta(days=max_years_past * 365)\n        #Anywhere between 1980 and today plus max_ears\n        num_days = (max_years_future * 365) + start.day\n    else:\n        start = datetime.datetime.today()\n        num_days = max_years_future * 365\n\n    random_days = random.randint(1, num_days)\n    random_date = start + datetime.timedelta(days=random_days)\n    return(random_date)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a random birthday fomr someone between the ages of min_age and max_age", "response": "def create_birthday(min_age=18, max_age=80):\n    \"\"\"\n    Create a random birthday fomr someone between the ages of min_age and max_age\n    \"\"\"\n    age = random.randint(min_age, max_age)\n    start = datetime.date.today() - datetime.timedelta(days=random.randint(0, 365))\n    return start - datetime.timedelta(days=age * 365)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_pw(length=8, digits=2, upper=2, lower=2):\n\n    seed(time())\n\n    lowercase = string.ascii_lowercase\n    uppercase = string.ascii_uppercase\n    letters = string.ascii_letters\n    password = list(\n        chain(\n            (choice(uppercase) for _ in range(upper)),\n            (choice(lowercase) for _ in range(lower)),\n            (choice(string.digits) for _ in range(digits)),\n            (choice(letters) for _ in range((length - digits - upper - lower)))\n        )\n    )\n\n    return \"\".join(sample(password, len(password)))", "response": "Create a random password in a random language"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_examples():\n    first, last = create_name()\n    add = create_street()\n    zip, city, state = create_city_state_zip()\n    phone = create_phone(zip)\n    print(first, last)\n    print(add)\n    print(\"{0:s} {1:s} {2:s}\".format(city, state, zip))\n    print(phone)\n    print(create_sentence())\n    print(create_paragraphs(num=3))\n    print(create_cc_number())\n    expiry = create_date(max_years_future=3)\n    print(\"{0:%m/%y}\".format(expiry))\n    print(create_email(name=(first, last)))\n    print(\"Password: {0:s}\".format(create_pw()))\n    print(create_company_name())\n    print(create_job_title())\n    print(\"Born on {0:%m/%d/%Y}\".format(create_birthday()))", "response": "Run through some simple examples\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_to_mosek_index(block_struct, row_offsets, block_offsets, row):\n    block_index, i, j = convert_row_to_sdpa_index(block_struct, row_offsets,\n                                                  row)\n\n    offset = block_offsets[block_index]\n    ci = offset + i\n    cj = offset + j\n    return cj, ci", "response": "This function converts a row of a Mosek matrix into the lower - triangular index of the C and C j."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_to_mosek_matrix(sdp):\n    barci = []\n    barcj = []\n    barcval = []\n    barai = []\n    baraj = []\n    baraval = []\n    for k in range(sdp.n_vars):\n        barai.append([])\n        baraj.append([])\n        baraval.append([])\n    row_offsets = [0]\n    block_offsets = [0]\n    cumulative_sum = 0\n    cumulative_square_sum = 0\n    for block_size in sdp.block_struct:\n        cumulative_sum += block_size\n        cumulative_square_sum += block_size ** 2\n        row_offsets.append(cumulative_square_sum)\n        block_offsets.append(cumulative_sum)\n    for row in range(len(sdp.F.rows)):\n        if len(sdp.F.rows[row]) > 0:\n            col_index = 0\n            for k in sdp.F.rows[row]:\n                value = sdp.F.data[row][col_index]\n                i, j = convert_to_mosek_index(sdp.block_struct,\n                                              row_offsets, block_offsets, row)\n                if k > 0:\n                    barai[k - 1].append(i)\n                    baraj[k - 1].append(j)\n                    baraval[k - 1].append(-value)\n                else:\n                    barci.append(i)\n                    barcj.append(j)\n                    barcval.append(value)\n                col_index += 1\n    return barci, barcj, barcval, barai, baraj, baraval", "response": "Converts the entire sparse representation of the Fi constraint matrices\n    to sparse MOSEK matrices."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_to_mosek(sdp):\n    import mosek\n    # Cheat when variables are complex and convert with PICOS\n    if sdp.complex_matrix:\n        from .picos_utils import convert_to_picos\n        Problem = convert_to_picos(sdp).to_real()\n        Problem._make_mosek_instance()\n        task = Problem.msk_task\n        if sdp.verbose > 0:\n            task.set_Stream(mosek.streamtype.log, streamprinter)\n        return task\n\n    barci, barcj, barcval, barai, baraj, baraval = \\\n        convert_to_mosek_matrix(sdp)\n    bkc = [mosek.boundkey.fx] * sdp.n_vars\n    blc = [-v for v in sdp.obj_facvar]\n    buc = [-v for v in sdp.obj_facvar]\n\n    env = mosek.Env()\n    task = env.Task(0, 0)\n    if sdp.verbose > 0:\n        task.set_Stream(mosek.streamtype.log, streamprinter)\n    numvar = 0\n    numcon = len(bkc)\n    BARVARDIM = [sum(sdp.block_struct)]\n\n    task.appendvars(numvar)\n    task.appendcons(numcon)\n    task.appendbarvars(BARVARDIM)\n    for i in range(numcon):\n        task.putconbound(i, bkc[i], blc[i], buc[i])\n\n    symc = task.appendsparsesymmat(BARVARDIM[0], barci, barcj, barcval)\n    task.putbarcj(0, [symc], [1.0])\n\n    for i in range(len(barai)):\n        syma = task.appendsparsesymmat(BARVARDIM[0], barai[i], baraj[i],\n                                       baraval[i])\n        task.putbaraij(i, 0, [syma], [1.0])\n\n    # Input the objective sense (minimize/maximize)\n    task.putobjsense(mosek.objsense.minimize)\n\n    return task", "response": "Convert an SDP relaxation to a MOSEK task."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a new Text node to the most recent NoCOOKIE.", "response": "def _add_text(self, text):\n        \"\"\"\n        If ``text`` is not empty, append a new Text node to the most recent\n        pending node, if there is any, or to the new nodes, if there are no\n        pending nodes.\n        \"\"\"\n        if text:\n            if self.pending_nodes:\n                self.pending_nodes[-1].append(nodes.Text(text))\n            else:\n                self.new_nodes.append(nodes.Text(text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fsarray(strings, *args, **kwargs):\n\n    strings = list(strings)\n    if 'width' in kwargs:\n        width = kwargs['width']\n        del kwargs['width']\n        if strings and max(len(s) for s in strings) > width:\n            raise ValueError(\"Those strings won't fit for width %d\" % width)\n    else:\n        width = max(len(s) for s in strings) if strings else 0\n    fstrings = [s if isinstance(s, FmtStr) else fmtstr(s, *args, **kwargs) for s in strings]\n    arr = FSArray(len(fstrings), width, *args, **kwargs)\n    rows = [fs.setslice_with_length(0, len(s), s, width) for fs, s in zip(arr.rows, fstrings)]\n    arr.rows = rows\n    return arr", "response": "Returns an FSArray of the maximum size of the provided FmtStrs_or_strings or width and height of the number of strings provided."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns two FSArrays with differences underlined", "response": "def diff(cls, a, b, ignore_formatting=False):\n        \"\"\"Returns two FSArrays with differences underlined\"\"\"\n        def underline(x): return u'\\x1b[4m%s\\x1b[0m' % (x,)\n        def blink(x): return u'\\x1b[5m%s\\x1b[0m' % (x,)\n        a_rows = []\n        b_rows = []\n        max_width = max([len(row) for row in a] + [len(row) for row in b])\n        a_lengths = []\n        b_lengths = []\n        for a_row, b_row in zip(a, b):\n            a_lengths.append(len(a_row))\n            b_lengths.append(len(b_row))\n            extra_a = u'`' * (max_width - len(a_row))\n            extra_b = u'`' * (max_width - len(b_row))\n            a_line = u''\n            b_line = u''\n            for a_char, b_char in zip(a_row + extra_a, b_row + extra_b):\n                if ignore_formatting:\n                    a_char_for_eval = a_char.s if isinstance(a_char, FmtStr) else a_char\n                    b_char_for_eval = b_char.s if isinstance(b_char, FmtStr) else b_char\n                else:\n                    a_char_for_eval = a_char\n                    b_char_for_eval = b_char\n                if a_char_for_eval == b_char_for_eval:\n                    a_line += actualize(a_char)\n                    b_line += actualize(b_char)\n                else:\n                    a_line += underline(blink(actualize(a_char)))\n                    b_line += underline(blink(actualize(b_char)))\n            a_rows.append(a_line)\n            b_rows.append(b_line)\n        hdiff = '\\n'.join(a_line + u' %3d | %3d ' % (a_len, b_len) + b_line for a_line, b_line, a_len, b_len in zip(a_rows, b_rows, a_lengths, b_lengths))\n        return hdiff"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self,rate, amount, order_type, pair):\n        ''' create new order function\n        :param rate: float\n        :param amount: float\n        :param order_type: str; set 'buy' or 'sell'\n        :param pair: str; set 'btc_jpy' \n        '''\n        nonce = nounce()\n        payload = { 'rate': rate,\n                    'amount': amount,\n                    'order_type': order_type,\n                    'pair': pair\n                    }\n        url= 'https://coincheck.com/api/exchange/orders'\n        body = 'rate={rate}&amount={amount}&order_type={order_type}&pair={pair}'.format(**payload)\n        message = nonce + url + body\n        signature = hmac.new(self.secret_key.encode('utf-8'), message.encode('utf-8'), hashlib.sha256).hexdigest()\n        headers = {\n           'ACCESS-KEY'      : self.access_key,\n           'ACCESS-NONCE'    : nonce,\n           'ACCESS-SIGNATURE': signature\n        }\n        r = requests.post(url,headers=headers,data=body)\n        return json.loads(r.text)", "response": "create new order function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cancel(self,order_id):\n        ''' cancel the specified order\n        :param order_id: order_id to be canceled\n        '''\n        url= 'https://coincheck.com/api/exchange/orders/' + order_id\n        headers = make_header(url,access_key=self.access_key,secret_key=self.secret_key)\n        r = requests.delete(url,headers=headers)\n        return json.loads(r.text)", "response": "cancel the order with the specified order_id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the length hint of an object.", "response": "def _length_hint(obj):\n    \"\"\"Returns the length hint of an object.\"\"\"\n    try:\n        return len(obj)\n    except TypeError:\n        try:\n            get_hint = type(obj).__length_hint__\n        except AttributeError:\n            return None\n        try:\n            hint = get_hint(obj)\n        except TypeError:\n            return None\n        if hint is NotImplemented or \\\n           not isinstance(hint, (int, long)) or \\\n           hint < 0:\n            return None\n        return hint"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndecides what method to use for paging through text.", "response": "def pager(text, color=None):\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    stdout = _default_text_stdout()\n    if not isatty(sys.stdin) or not isatty(stdout):\n        return _nullpager(stdout, text, color)\n    if 'PAGER' in os.environ:\n        if WIN:\n            return _tempfilepager(text, os.environ['PAGER'], color)\n        return _pipepager(text, os.environ['PAGER'], color)\n    if os.environ.get('TERM') in ('dumb', 'emacs'):\n        return _nullpager(stdout, text, color)\n    if WIN or sys.platform.startswith('os2'):\n        return _tempfilepager(text, 'more <', color)\n    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:\n        return _pipepager(text, 'less', color)\n\n    import tempfile\n    fd, filename = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if hasattr(os, 'system') and os.system('more \"%s\"' % filename) == 0:\n            return _pipepager(text, 'more', color)\n        return _nullpager(stdout, text, color)\n    finally:\n        os.unlink(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a retries value to a Retry object.", "response": "def from_int(cls, retries, redirect=True, default=None):\n        \"\"\" Backwards-compatibility for the old retries format.\"\"\"\n        if retries is None:\n            retries = default if default is not None else cls.DEFAULT\n\n        if isinstance(retries, Retry):\n            return retries\n\n        redirect = bool(redirect) and None\n        new_retries = cls(retries, redirect=redirect)\n        log.debug(\"Converted retries value: %r -> %r\" % (retries, new_retries))\n        return new_retries"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the current backoff time.", "response": "def get_backoff_time(self):\n        \"\"\" Formula for computing the current backoff\n\n        :rtype: float\n        \"\"\"\n        if self._observed_errors <= 1:\n            return 0\n\n        backoff_value = self.backoff_factor * (2 ** (self._observed_errors - 1))\n        return min(self.BACKOFF_MAX, backoff_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_forced_retry(self, method, status_code):\n        if self.method_whitelist and method.upper() not in self.method_whitelist:\n            return False\n\n        return self.status_forcelist and status_code in self.status_forcelist", "response": "Is this method retryable?"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a callable or python ty into the most appropriate param ty.", "response": "def convert_type(ty, default=None):\n    \"\"\"Converts a callable or python ty into the most appropriate param\n    ty.\n    \"\"\"\n    if isinstance(ty, tuple):\n        return Tuple(ty)\n    if isinstance(ty, ParamType):\n        return ty\n    guessed_type = False\n    if ty is None and default is not None:\n        ty = type(default)\n        guessed_type = True\n    if ty is text_type or ty is str or ty is None:\n        return STRING\n    if ty is int:\n        return INT\n    # Booleans are only okay if not guessed.  This is done because for\n    # flags the default value is actually a bit of a lie in that it\n    # indicates which of the flags is the one we want.  See get_default()\n    # for more information.\n    if ty is bool and not guessed_type:\n        return BOOL\n    if ty is float:\n        return FLOAT\n    if guessed_type:\n        return STRING\n\n    # Catch a common mistake\n    if __debug__:\n        try:\n            if issubclass(ty, ParamType):\n                raise AssertionError('Attempted to use an uninstantiated '\n                                     'parameter type (%s).' % ty)\n        except TypeError:\n            pass\n    return FuncParamType(ty)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_usage(self, prog, args='', prefix='Usage: '):\n        prefix = '%*s%s' % (self.current_indent, prefix, prog)\n        self.write(prefix)\n\n        text_width = max(self.width - self.current_indent - term_len(prefix), 10)\n        indent = ' ' * (term_len(prefix) + 1)\n        self.write(wrap_text(args, text_width,\n                             initial_indent=' ',\n                             subsequent_indent=indent))\n\n        self.write('\\n')", "response": "Writes a usage line into the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current topics to topics", "response": "def in_(ctx, topics, yes, as_, enter):\n    \"\"\"Set the current topics to `topics`\n\n    Environment:\n        BE_PROJECT: First topic\n        BE_CWD: Current `be` working directory\n        BE_TOPICS: Arguments to `in`\n        BE_DEVELOPMENTDIR: Absolute path to current development directory\n        BE_PROJECTROOT: Absolute path to current project\n        BE_PROJECTSROOT: Absolute path to where projects are located\n        BE_ACTIVE: 0 or 1, indicates an active be environment\n        BE_USER: Current user, overridden with `--as`\n        BE_SCRIPT: User-supplied shell script\n        BE_PYTHON: User-supplied python script\n        BE_ENTER: 0 or 1 depending on whether the topic was entered\n        BE_GITHUB_API_TOKEN: Optional GitHub API token\n        BE_ENVIRONMENT: Space-separated list of user-added\n            environment variables\n        BE_TEMPDIR: Directory in which temporary files are stored\n        BE_PRESETSDIR: Directory in which presets are searched\n        BE_ALIASDIR: Directory in which aliases are written\n        BE_BINDING: Binding between template and item in inventory\n\n    \\b\n    Usage:\n        $ be in project topics\n\n    \"\"\"\n\n    topics = map(str, topics)  # They enter as unicode\n\n    if self.isactive():\n        lib.echo(\"ERROR: Exit current project first\")\n        sys.exit(lib.USER_ERROR)\n\n    # Determine topic syntax\n    if len(topics[0].split(\"/\")) == 3:\n        topic_syntax = lib.FIXED\n        project = topics[0].split(\"/\")[0]\n    else:\n        topic_syntax = lib.POSITIONAL\n        project = topics[0]\n\n    project_dir = lib.project_dir(_extern.cwd(), project)\n    if not os.path.exists(project_dir):\n        lib.echo(\"Project \\\"%s\\\" not found. \" % project)\n        lib.echo(\"\\nAvailable:\")\n        ctx.invoke(ls)\n        sys.exit(lib.USER_ERROR)\n\n    # Boot up\n    context = lib.context(root=_extern.cwd(), project=project)\n\n    be = _extern.load_be(project)\n    templates = _extern.load_templates(project)\n    inventory = _extern.load_inventory(project)\n    context.update({\n        \"BE_PROJECT\": project,\n        \"BE_USER\": str(as_),\n        \"BE_ENTER\": \"1\" if enter else \"\",\n        \"BE_TOPICS\": \" \".join(topics)\n    })\n\n    # Remap topic syntax, for backwards compatibility\n    # In cases where the topic is entered in a way that\n    # differs from the template, remap topic to template.\n    if any(re.findall(\"{\\d+}\", pattern) for pattern in templates.values()):\n        template_syntax = lib.POSITIONAL\n    else:\n        template_syntax = lib.FIXED\n\n    if topic_syntax & lib.POSITIONAL and not template_syntax & lib.POSITIONAL:\n        topics = [\"/\".join(topics)]\n    if topic_syntax & lib.FIXED and not template_syntax & lib.FIXED:\n        topics[:] = topics[0].split(\"/\")\n\n    try:\n        key = be.get(\"templates\", {}).get(\"key\") or \"{1}\"\n        item = lib.item_from_topics(key, topics)\n        binding = lib.binding_from_item(inventory, item)\n        context[\"BE_BINDING\"] = binding\n    except IndexError as exc:\n        lib.echo(\"At least %s topics are required\" % str(exc))\n        sys.exit(lib.USER_ERROR)\n\n    except KeyError as exc:\n        lib.echo(\"\\\"%s\\\" not found\" % item)\n        if exc.bindings:\n            lib.echo(\"\\nAvailable:\")\n            for item_ in sorted(exc.bindings,\n                                key=lambda a: (exc.bindings[a], a)):\n                lib.echo(\"- %s (%s)\" % (item_, exc.bindings[item_]))\n        sys.exit(lib.USER_ERROR)\n\n    # Finally, determine a development directory\n    # based on the template-, not topic-syntax.\n    if template_syntax & lib.POSITIONAL:\n        try:\n            development_dir = lib.pos_development_directory(\n                templates=templates,\n                inventory=inventory,\n                context=context,\n                topics=topics,\n                user=as_,\n                item=item)\n        except KeyError as exc:\n            lib.echo(\"\\\"%s\\\" not found\" % item)\n            if exc.bindings:\n                lib.echo(\"\\nAvailable:\")\n                for item_ in sorted(exc.bindings,\n                                    key=lambda a: (exc.bindings[a], a)):\n                    lib.echo(\"- %s (%s)\" % (item_, exc.bindings[item_]))\n            sys.exit(lib.USER_ERROR)\n\n    else:  # FIXED topic_syntax\n        development_dir = lib.fixed_development_directory(\n            templates,\n            inventory,\n            topics,\n            as_)\n\n    context[\"BE_DEVELOPMENTDIR\"] = development_dir\n\n    tempdir = (tempfile.mkdtemp()\n               if not os.environ.get(\"BE_TEMPDIR\")\n               else os.environ[\"BE_TEMPDIR\"])\n    context[\"BE_TEMPDIR\"] = tempdir\n\n    # Should it be entered?\n    if enter and not os.path.exists(development_dir):\n        create = False\n        if yes:\n            create = True\n        else:\n            sys.stdout.write(\"No development directory found. Create? [Y/n]: \")\n            sys.stdout.flush()\n            if raw_input().lower() in (\"\", \"y\", \"yes\"):\n                create = True\n        if create:\n            ctx.invoke(mkdir, dir=development_dir)\n        else:\n            sys.stdout.write(\"Cancelled\")\n            sys.exit(lib.NORMAL)\n\n    # Parse be.yaml\n    if \"script\" in be:\n        context[\"BE_SCRIPT\"] = _extern.write_script(\n            be[\"script\"], tempdir).replace(\"\\\\\", \"/\")\n\n    if \"python\" in be:\n        script = \"\\n\".join(be[\"python\"])\n        context[\"BE_PYTHON\"] = script\n        try:\n            exec script in {\"__name__\": __name__}\n        except Exception as e:\n            lib.echo(\"ERROR: %s\" % e)\n\n    invalids = [v for v in context.values() if not isinstance(v, str)]\n    assert all(isinstance(v, str) for v in context.values()), invalids\n\n    # Create aliases\n    aliases_dir = _extern.write_aliases(\n        be.get(\"alias\", {}), tempdir)\n\n    context[\"PATH\"] = (aliases_dir\n                       + os.pathsep\n                       + context.get(\"PATH\", \"\"))\n    context[\"BE_ALIASDIR\"] = aliases_dir\n\n    # Parse redirects\n    lib.parse_redirect(\n        be.get(\"redirect\", {}), topics, context)\n\n    # Override inherited context\n    # with that coming from be.yaml.\n    if \"environment\" in be:\n        parsed = lib.parse_environment(\n            fields=be[\"environment\"],\n            context=context,\n            topics=topics)\n        context[\"BE_ENVIRONMENT\"] = \" \".join(parsed.keys())\n        context.update(parsed)\n\n    if \"BE_TESTING\" in context:\n        os.chdir(development_dir)\n        os.environ.update(context)\n    else:\n        parent = lib.parent()\n        cmd = lib.cmd(parent)\n\n        # Store reference to calling shell\n        context[\"BE_SHELL\"] = parent\n\n        try:\n            sys.exit(subprocess.call(cmd, env=context))\n        finally:\n            import shutil\n            shutil.rmtree(tempdir)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new empty file in the current project", "response": "def new(preset, name, silent, update):\n    \"\"\"Create new default preset\n\n    \\b\n    Usage:\n        $ be new ad\n        \"blue_unicorn\" created\n        $ be new film --name spiderman\n        \"spiderman\" created\n\n    \"\"\"\n\n    if self.isactive():\n        lib.echo(\"Please exit current preset before starting a new\")\n        sys.exit(lib.USER_ERROR)\n\n    if not name:\n        count = 0\n        name = lib.random_name()\n        while name in _extern.projects():\n            if count > 10:\n                lib.echo(\"ERROR: Couldn't come up with a unique name :(\")\n                sys.exit(lib.USER_ERROR)\n            name = lib.random_name()\n            count += 1\n\n    project_dir = lib.project_dir(_extern.cwd(), name)\n    if os.path.exists(project_dir):\n        lib.echo(\"\\\"%s\\\" already exists\" % name)\n        sys.exit(lib.USER_ERROR)\n\n    username, preset = ([None] + preset.split(\"/\", 1))[-2:]\n    presets_dir = _extern.presets_dir()\n    preset_dir = os.path.join(presets_dir, preset)\n\n    # Is the preset given referring to a repository directly?\n    relative = False if username else True\n\n    try:\n        if not update and preset in _extern.local_presets():\n            _extern.copy_preset(preset_dir, project_dir)\n\n        else:\n            lib.echo(\"Finding preset for \\\"%s\\\".. \" % preset, silent)\n            time.sleep(1 if silent else 0)\n\n            if relative:\n                # Preset is relative, look it up from the Hub\n                presets = _extern.github_presets()\n\n                if preset not in presets:\n                    sys.stdout.write(\"\\\"%s\\\" not found\" % preset)\n                    sys.exit(lib.USER_ERROR)\n\n                time.sleep(1 if silent else 0)\n                repository = presets[preset]\n\n            else:\n                # Absolute paths are pulled directly\n                repository = username + \"/\" + preset\n\n            lib.echo(\"Pulling %s.. \" % repository, silent)\n            repository = _extern.fetch_release(repository)\n\n            # Remove existing preset\n            if preset in _extern.local_presets():\n                _extern.remove_preset(preset)\n\n            try:\n                _extern.pull_preset(repository, preset_dir)\n            except IOError as e:\n                lib.echo(\"ERROR: Sorry, something went wrong.\\n\"\n                         \"Use be --verbose for more\")\n                lib.echo(e)\n                sys.exit(lib.USER_ERROR)\n\n            try:\n                _extern.copy_preset(preset_dir, project_dir)\n            finally:\n                # Absolute paths are not stored locally\n                if not relative:\n                    _extern.remove_preset(preset)\n\n    except IOError as exc:\n        if self.verbose:\n            lib.echo(\"ERROR: %s\" % exc)\n        else:\n            lib.echo(\"ERROR: Could not write, do you have permission?\")\n        sys.exit(lib.PROGRAM_ERROR)\n\n    lib.echo(\"\\\"%s\\\" created\" % name, silent)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(preset, clean):\n\n    if self.isactive():\n        lib.echo(\"ERROR: Exit current project first\")\n        sys.exit(lib.USER_ERROR)\n\n    presets = _extern.github_presets()\n\n    if preset not in presets:\n        sys.stdout.write(\"\\\"%s\\\" not found\" % preset)\n        sys.exit(lib.USER_ERROR)\n\n    lib.echo(\"Are you sure you want to update \\\"%s\\\", \"\n             \"any changes will be lost?: [y/N]: \", newline=False)\n    if raw_input().lower() in (\"y\", \"yes\"):\n        presets_dir = _extern.presets_dir()\n        preset_dir = os.path.join(presets_dir, preset)\n\n        repository = presets[preset]\n\n        if clean:\n            try:\n                _extern.remove_preset(preset)\n            except:\n                lib.echo(\"ERROR: Could not clean existing preset\")\n                sys.exit(lib.USER_ERROR)\n\n        lib.echo(\"Updating %s.. \" % repository)\n\n        try:\n            _extern.pull_preset(repository, preset_dir)\n        except IOError as e:\n            lib.echo(e)\n            sys.exit(lib.USER_ERROR)\n\n    else:\n        lib.echo(\"Cancelled\")", "response": "Update a local preset"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tab(topics, complete):\n\n    # Discard `be tab`\n    topics = list(topics)[2:]\n\n    # When given an incomplete argument,\n    # the argument is *sometimes* returned twice (?)\n    # .. note:: Seen in Git Bash on Windows\n    # $ be in giant [TAB]\n    # -> ['giant']\n    # $ be in gi[TAB]\n    # -> ['gi', 'gi']\n    if len(topics) > 1 and topics[-1] == topics[-2]:\n        topics.pop()\n\n    # Suggest projects\n    if len(topics) == 0:\n        projects = lib.list_projects(root=_extern.cwd())\n        sys.stdout.write(\" \".join(projects))\n\n    elif len(topics) == 1:\n        project = topics[0]\n        projects = lib.list_projects(root=_extern.cwd())\n\n        # Complete project\n        if not complete:\n            projects = [i for i in projects if i.startswith(project)]\n            sys.stdout.write(\" \".join(projects))\n        else:\n            # Suggest items from inventory\n            inventory = _extern.load_inventory(project)\n            inventory = lib.list_inventory(inventory)\n            items = [i for i, b in inventory]\n            sys.stdout.write(\" \".join(items))\n\n    else:\n        project, item = topics[:2]\n\n        # Complete inventory item\n        if len(topics) == 2 and not complete:\n            inventory = _extern.load_inventory(project)\n            inventory = lib.list_inventory(inventory)\n            items = [i for i, b in inventory]\n            items = [i for i in items if i.startswith(item)]\n            sys.stdout.write(\" \".join(items))\n\n        # Suggest items from template\n        else:\n            try:\n                be = _extern.load_be(project)\n                templates = _extern.load_templates(project)\n                inventory = _extern.load_inventory(project)\n\n                item = topics[-1]\n                items = lib.list_template(root=_extern.cwd(),\n                                          topics=topics,\n                                          templates=templates,\n                                          inventory=inventory,\n                                          be=be)\n                if not complete:\n                    items = lib.list_template(root=_extern.cwd(),\n                                              topics=topics[:-1],\n                                              templates=templates,\n                                              inventory=inventory,\n                                              be=be)\n                    items = [i for i in items if i.startswith(item)]\n                    sys.stdout.write(\" \".join(items) + \" \")\n                else:\n                    sys.stdout.write(\" \".join(items) + \" \")\n\n            except IndexError:\n                sys.exit(lib.NORMAL)", "response": "Utility sub - command for tab completion\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nenters into an environment with support for tab - completion", "response": "def activate():\n    \"\"\"Enter into an environment with support for tab-completion\n\n    This command drops you into a subshell, similar to the one\n    generated via `be in ...`, except no topic is present and\n    instead it enables tab-completion for supported shells.\n\n    See documentation for further information.\n    https://github.com/mottosso/be/wiki/cli\n\n    \"\"\"\n\n    parent = lib.parent()\n\n    try:\n        cmd = lib.cmd(parent)\n    except SystemError as exc:\n        lib.echo(exc)\n        sys.exit(lib.PROGRAM_ERROR)\n\n    # Store reference to calling shell\n    context = lib.context(root=_extern.cwd())\n    context[\"BE_SHELL\"] = parent\n\n    if lib.platform() == \"unix\":\n        context[\"BE_TABCOMPLETION\"] = os.path.join(\n            os.path.dirname(__file__), \"_autocomplete.sh\").replace(\"\\\\\", \"/\")\n\n    context.pop(\"BE_ACTIVE\", None)\n\n    sys.exit(subprocess.call(cmd, env=context))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ls(topics):\n\n    if self.isactive():\n        lib.echo(\"ERROR: Exit current project first\")\n        sys.exit(lib.USER_ERROR)\n\n    # List projects\n    if len(topics) == 0:\n        for project in lib.list_projects(root=_extern.cwd()):\n            lib.echo(\"- %s (project)\" % project)\n        sys.exit(lib.NORMAL)\n\n    # List inventory of project\n    elif len(topics) == 1:\n        inventory = _extern.load_inventory(topics[0])\n        for item, binding in lib.list_inventory(inventory):\n            lib.echo(\"- %s (%s)\" % (item, binding))\n        sys.exit(lib.NORMAL)\n\n    # List specific portion of template\n    else:\n        try:\n            project = topics[0]\n            be = _extern.load_be(project)\n            templates = _extern.load_templates(project)\n            inventory = _extern.load_inventory(project)\n            for item in lib.list_template(root=_extern.cwd(),\n                                          topics=topics,\n                                          templates=templates,\n                                          inventory=inventory,\n                                          be=be):\n                lib.echo(\"- %s\" % item)\n        except IndexError as exc:\n            lib.echo(exc)\n            sys.exit(lib.USER_ERROR)\n\n    sys.exit(lib.NORMAL)", "response": "List contents of current context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mkdir(dir, enter):\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "response": "Create a directory with the template for the current environment"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef preset_ls(remote):\n\n    if self.isactive():\n        lib.echo(\"ERROR: Exit current project first\")\n        sys.exit(lib.USER_ERROR)\n\n    if remote:\n        presets = _extern.github_presets()\n    else:\n        presets = _extern.local_presets()\n\n    if not presets:\n        lib.echo(\"No presets found\")\n        sys.exit(lib.NORMAL)\n    for preset in sorted(presets):\n        lib.echo(\"- %s\" % preset)\n    sys.exit(lib.NORMAL)", "response": "List presets available on the current project"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef preset_find(query):\n\n    if self.isactive():\n        lib.echo(\"ERROR: Exit current project first\")\n        sys.exit(lib.USER_ERROR)\n\n    found = _extern.github_presets().get(query)\n    if found:\n        lib.echo(found)\n    else:\n        lib.echo(\"Unable to locate preset \\\"%s\\\"\" % query)", "response": "Find preset from hub\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints current environment and redirected environment variables", "response": "def dump():\n    \"\"\"Print current environment\n\n    Environment is outputted in a YAML-friendly format\n\n    \\b\n    Usage:\n        $ be dump\n        Prefixed:\n        - BE_TOPICS=hulk bruce animation\n        - ...\n\n    \"\"\"\n\n    if not self.isactive():\n        lib.echo(\"ERROR: Enter a project first\")\n        sys.exit(lib.USER_ERROR)\n\n    # Print custom environment variables first\n    custom = sorted(os.environ.get(\"BE_ENVIRONMENT\", \"\").split())\n    if custom:\n        lib.echo(\"Custom:\")\n        for key in custom:\n            lib.echo(\"- %s=%s\" % (key, os.environ.get(key)))\n\n    # Then print redirected variables\n    project = os.environ[\"BE_PROJECT\"]\n    root = os.environ[\"BE_PROJECTSROOT\"]\n    be = _extern.load(project, \"be\", optional=True, root=root)\n    redirect = be.get(\"redirect\", {}).items()\n    if redirect:\n        lib.echo(\"\\nRedirect:\")\n        for map_source, map_dest in sorted(redirect):\n            lib.echo(\"- %s=%s\" % (map_dest, os.environ.get(map_dest)))\n\n    # And then everything else\n    prefixed = dict((k, v) for k, v in os.environ.iteritems()\n                    if k.startswith(\"BE_\"))\n    if prefixed:\n        lib.echo(\"\\nPrefixed:\")\n        for key in sorted(prefixed):\n            if not key.startswith(\"BE_\"):\n                continue\n            lib.echo(\"- %s=%s\" % (key, os.environ.get(key)))\n\n    sys.exit(lib.NORMAL)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_netrc_auth(url):\n\n    try:\n        from netrc import netrc, NetrcParseError\n\n        netrc_path = None\n\n        for f in NETRC_FILES:\n            try:\n                loc = os.path.expanduser('~/{0}'.format(f))\n            except KeyError:\n                # os.path.expanduser can fail when $HOME is undefined and\n                # getpwuid fails. See http://bugs.python.org/issue20164 &\n                # https://github.com/kennethreitz/requests/issues/1846\n                return\n\n            if os.path.exists(loc):\n                netrc_path = loc\n                break\n\n        # Abort early if there isn't one.\n        if netrc_path is None:\n            return\n\n        ri = urlparse(url)\n\n        # Strip port numbers from netloc\n        host = ri.netloc.split(':')[0]\n\n        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n            # If there was a parsing error or a permissions issue reading the file,\n            # we'll just skip netrc auth\n            pass\n\n    # AppEngine hackiness.\n    except (ImportError, AttributeError):\n        pass", "response": "Returns the Requests tuple auth for a given url from netrc."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_dict_to_cookiejar(cj, cookie_dict):\n\n    cj2 = cookiejar_from_dict(cookie_dict)\n    cj.update(cj2)\n    return cj", "response": "Returns a CookieJar from a key - value dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn whether we should bypass proxies on this URL.", "response": "def should_bypass_proxies(url):\n    \"\"\"\n    Returns whether we should bypass proxies or not.\n    \"\"\"\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n    no_proxy = get_proxy('no_proxy')\n    netloc = urlparse(url).netloc\n\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the netloc, both with and without the port.\n        no_proxy = no_proxy.replace(' ', '').split(',')\n\n        ip = netloc.split(':')[0]\n        if is_ipv4_address(ip):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(ip, proxy_ip):\n                        return True\n        else:\n            for host in no_proxy:\n                if netloc.endswith(host) or netloc.split(':')[0].endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n\n    # If the system proxy settings indicate that this URL should be bypassed,\n    # don't proxy.\n    # The proxy_bypass function is incredibly buggy on OS X in early versions\n    # of Python 2.6, so allow this call to fail. Only catch the specific\n    # exceptions we've seen, though: this call failing in other ways can reveal\n    # legitimate problems.\n    try:\n        bypass = proxy_bypass(netloc)\n    except (TypeError, socket.gaierror):\n        bypass = False\n\n    if bypass:\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string representing the default user agent.", "response": "def default_user_agent(name=\"python-requests\"):\n    \"\"\"Return a string representing the default user agent.\"\"\"\n    _implementation = platform.python_implementation()\n\n    if _implementation == 'CPython':\n        _implementation_version = platform.python_version()\n    elif _implementation == 'PyPy':\n        _implementation_version = '%s.%s.%s' % (sys.pypy_version_info.major,\n                                                sys.pypy_version_info.minor,\n                                                sys.pypy_version_info.micro)\n        if sys.pypy_version_info.releaselevel != 'final':\n            _implementation_version = ''.join([_implementation_version, sys.pypy_version_info.releaselevel])\n    elif _implementation == 'Jython':\n        _implementation_version = platform.python_version()  # Complete Guess\n    elif _implementation == 'IronPython':\n        _implementation_version = platform.python_version()  # Complete Guess\n    else:\n        _implementation_version = 'Unknown'\n\n    try:\n        p_system = platform.system()\n        p_release = platform.release()\n    except IOError:\n        p_system = 'Unknown'\n        p_release = 'Unknown'\n\n    return \" \".join(['%s/%s' % (name, __version__),\n                     '%s/%s' % (_implementation, _implementation_version),\n                     '%s/%s' % (p_system, p_release)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a string object regardless of type returns a representation of that string in the native string type encoding and decoding where necessary.", "response": "def to_native_string(string, encoding='ascii'):\n    \"\"\"\n    Given a string object, regardless of type, returns a representation of that\n    string in the native string type, encoding and decoding where necessary.\n    This assumes ASCII unless told otherwise.\n    \"\"\"\n    out = None\n\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            out = string.decode(encoding)\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bashcomplete(cmd, prog_name, complete_var=None):\n    if complete_var is None:\n        complete_var = '_%s_COMPLETE' % (prog_name.replace('-', '_')).upper()\n    complete_instr = os.environ.get(complete_var)\n    if not complete_instr:\n        return\n\n    from ._bashcomplete import bashcomplete\n    if bashcomplete(cmd, prog_name, complete_var, complete_instr):\n        sys.exit(1)", "response": "Internal handler for the bash completion support."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninvokes a command callback in exactly the way it expects.", "response": "def invoke(*args, **kwargs):\n        \"\"\"Invokes a command callback in exactly the way it expects.  There\n        are two ways to invoke this method:\n\n        1.  the first argument can be a callback and all other arguments and\n            keyword arguments are forwarded directly to the function.\n        2.  the first argument is a click command object.  In that case all\n            arguments are forwarded as well but proper click parameters\n            (options and click arguments) must be keyword arguments and Click\n            will fill in defaults.\n\n        Note that before Click 3.2 keyword arguments were not properly filled\n        in against the intention of this code and no context was created.  For\n        more information about this change and why it was done in a bugfix\n        release see :ref:`upgrade-to-3.2`.\n        \"\"\"\n        self, callback = args[:2]\n        ctx = self\n\n        # This is just to improve the error message in cases where old\n        # code incorrectly invoked this method.  This will eventually be\n        # removed.\n        injected_arguments = False\n\n        # It's also possible to invoke another command which might or\n        # might not have a callback.  In that case we also fill\n        # in defaults and make a new context for this command.\n        if isinstance(callback, Command):\n            other_cmd = callback\n            callback = other_cmd.callback\n            ctx = Context(other_cmd, info_name=other_cmd.name, parent=self)\n            if callback is None:\n                raise TypeError('The given command does not have a '\n                                'callback that can be invoked.')\n\n            for param in other_cmd.params:\n                if param.name not in kwargs and param.expose_value:\n                    kwargs[param.name] = param.get_default(ctx)\n                    injected_arguments = True\n\n        args = args[2:]\n        if getattr(callback, '__click_pass_context__', False):\n            args = (ctx,) + args\n        with augment_usage_errors(self):\n            try:\n                with ctx:\n                    return callback(*args, **kwargs)\n            except TypeError as e:\n                if not injected_arguments:\n                    raise\n                if 'got multiple values for' in str(e):\n                    raise RuntimeError(\n                        'You called .invoke() on the context with a command '\n                        'but provided parameters as positional arguments.  '\n                        'This is not supported but sometimes worked by chance '\n                        'in older versions of Click.  To fix this see '\n                        'http://click.pocoo.org/upgrading/#upgrading-to-3.2')\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_context(self, info_name, args, parent=None, **extra):\n        for key, value in iteritems(self.context_settings):\n            if key not in extra:\n                extra[key] = value\n        ctx = Context(self, info_name=info_name, parent=parent, **extra)\n        self.parse_args(ctx, args)\n        return ctx", "response": "This function is called by the command line parser when a new context is created."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the underlying option parser for this command.", "response": "def make_parser(self, ctx):\n        \"\"\"Creates the underlying option parser for this command.\"\"\"\n        parser = OptionParser(ctx)\n        parser.allow_interspersed_args = ctx.allow_interspersed_args\n        parser.ignore_unknown_options = ctx.ignore_unknown_options\n        for param in self.get_params(ctx):\n            param.add_to_parser(parser, ctx)\n        return parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting the help text to the formatter if it exists.", "response": "def format_help_text(self, ctx, formatter):\n        \"\"\"Writes the help text to the formatter if it exists.\"\"\"\n        if self.help:\n            formatter.write_paragraph()\n            with formatter.indentation():\n                formatter.write_text(self.help)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_command(self, cmd, name=None):\n        name = name or cmd.name\n        if name is None:\n            raise TypeError('Command has no name.')\n        self.commands[name] = cmd", "response": "Registers another command with this group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pass_obj(f):\n    @pass_context\n    def new_func(*args, **kwargs):\n        ctx = args[0]\n        return ctx.invoke(f, ctx.obj, *args[1:], **kwargs)\n    return update_wrapper(new_func, f)", "response": "Decorator to pass the object on the object on the object context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef option(*param_decls, **attrs):\n    def decorator(f):\n        if 'help' in attrs:\n            attrs['help'] = inspect.cleandoc(attrs['help'])\n        OptionClass = attrs.pop('cls', Option)\n        _param_memo(f, OptionClass(param_decls, **attrs))\n        return f\n    return decorator", "response": "Decorator to add an option to the command."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a option to be applied to a single command line command line.", "response": "def version_option(version=None, *param_decls, **attrs):\n    \"\"\"Adds a ``--version`` option which immediately ends the program\n    printing out the version number.  This is implemented as an eager\n    option that prints the version and exits the program in the callback.\n\n    :param version: the version number to show.  If not provided Click\n                    attempts an auto discovery via setuptools.\n    :param prog_name: the name of the program (defaults to autodetection)\n    :param message: custom message to show instead of the default\n                    (``'%(prog)s, version %(version)s'``)\n    :param others: everything else is forwarded to :func:`option`.\n    \"\"\"\n    if version is None:\n        module = sys._getframe(1).f_globals.get('__name__')\n    def decorator(f):\n        prog_name = attrs.pop('prog_name', None)\n        message = attrs.pop('message', '%(prog)s, version %(version)s')\n\n        def callback(ctx, param, value):\n            if not value or ctx.resilient_parsing:\n                return\n            prog = prog_name\n            if prog is None:\n                prog = ctx.find_root().info_name\n            ver = version\n            if ver is None:\n                try:\n                    import pkg_resources\n                except ImportError:\n                    pass\n                else:\n                    for dist in pkg_resources.working_set:\n                        scripts = dist.get_entry_map().get('console_scripts') or {}\n                        for script_name, entry_point in iteritems(scripts):\n                            if entry_point.module_name == module:\n                                ver = dist.version\n                                break\n                if ver is None:\n                    raise RuntimeError('Could not determine version')\n            echo(message % {\n                'prog': prog,\n                'version': ver,\n            }, color=ctx.color)\n            ctx.exit()\n\n        attrs.setdefault('is_flag', True)\n        attrs.setdefault('expose_value', False)\n        attrs.setdefault('is_eager', True)\n        attrs.setdefault('help', 'Show the version and exit.')\n        attrs['callback'] = callback\n        return option(*(param_decls or ('--version',)), **attrs)(f)\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a Basic Auth string.", "response": "def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(('%s:%s' % (username, password)).encode('latin1')).strip()\n    )\n\n    return authstr"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ls(*topic, **kwargs):\n\n    context = dump()\n\n    root = kwargs.get(\"root\") or context.get(\"cwd\") or os.getcwd()\n    backend = kwargs.get(\"backend\", os.listdir)\n    absolute = kwargs.get(\"absolute\", True)\n\n    content = {\n        0: \"projects\",\n        1: \"inventory\",\n        2: \"template\"\n    }[min(2, len(topic))]\n\n    # List projects\n    if content == \"projects\":\n        projects = lib.list_projects(root=root, backend=backend)\n        if absolute:\n            return map(lambda p: os.path.join(root, p), projects)\n        else:\n            return projects\n\n    # List items\n    if content == \"inventory\":\n        project = topic[0]\n\n        be = _extern.load(project, \"be\", root=root)\n        inventory = _extern.load(project, \"inventory\", root=root)\n        inventory = lib.invert_inventory(inventory)\n        templates = _extern.load(project, \"templates\", root=root)\n\n        if absolute:\n            paths = list()\n            for item, binding in inventory.iteritems():\n                template = templates.get(binding)\n                index = len(topic)\n                sliced = lib.slice(index, template)\n                paths.append(sliced.format(*(topic + (item,)), **context))\n            return paths\n        else:\n            return inventory.keys()\n\n    # List template\n    if content == \"template\":\n        project = topic[0]\n        be = _extern.load(project, \"be\", root=root)\n        templates = _extern.load(project, \"templates\", root=root)\n        inventory = _extern.load(project, \"inventory\", root=root)\n        return lib.list_template(root=root,\n                                 topics=topic,\n                                 templates=templates,\n                                 inventory=inventory,\n                                 be=be,\n                                 absolute=absolute)", "response": "List all the items in the external datastore."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump(context=os.environ):\n\n    output = {}\n    for key, value in context.iteritems():\n        if not key.startswith(\"BE_\"):\n            continue\n        output[key[3:].lower()] = value\n\n    return output", "response": "Dump current environment as a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cwd():\n    cwd = os.environ.get(\"BE_CWD\")\n    if cwd and not os.path.isdir(cwd):\n        sys.stderr.write(\"ERROR: %s is not a directory\" % cwd)\n        sys.exit(lib.USER_ERROR)\n    return cwd or os.getcwd().replace(\"\\\\\", \"/\")", "response": "Return the be current working directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a list of commands to a temporary directory and returns the absolute path to the script", "response": "def write_script(script, tempdir):\n    \"\"\"Write script to a temporary directory\n\n    Arguments:\n        script (list): Commands which to put into a file\n\n    Returns:\n        Absolute path to script\n\n    \"\"\"\n\n    name = \"script\" + self.suffix\n    path = os.path.join(tempdir, name)\n\n    with open(path, \"w\") as f:\n        f.write(\"\\n\".join(script))\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_aliases(aliases, tempdir):\n\n    platform = lib.platform()\n    if platform == \"unix\":\n        home_alias = \"cd $BE_DEVELOPMENTDIR\"\n    else:\n        home_alias = \"cd %BE_DEVELOPMENTDIR%\"\n\n    aliases[\"home\"] = home_alias\n\n    tempdir = os.path.join(tempdir, \"aliases\")\n    os.makedirs(tempdir)\n\n    for alias, cmd in aliases.iteritems():\n        path = os.path.join(tempdir, alias)\n\n        if platform == \"windows\":\n            path += \".bat\"\n\n        with open(path, \"w\") as f:\n            f.write(cmd)\n\n        if platform == \"unix\":\n            # Make executable\n            st = os.stat(path)\n            os.chmod(path, st.st_mode | stat.S_IXUSR\n                     | stat.S_IXGRP | stat.S_IXOTH)\n\n    return tempdir", "response": "Write aliases to temporary directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_preset(preset):\n\n    preset_dir = os.path.join(presets_dir(), preset)\n\n    try:\n        shutil.rmtree(preset_dir)\n    except IOError:\n        lib.echo(\"\\\"%s\\\" did not exist\" % preset)", "response": "Physically delete local preset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(path, **kwargs):\n    token = os.environ.get(BE_GITHUB_API_TOKEN)\n    if token:\n        kwargs[\"headers\"] = {\n            \"Authorization\": \"token %s\" % token\n        }\n\n    try:\n        response = requests.get(path, verify=False, **kwargs)\n        if response.status_code == 403:\n            lib.echo(\"Patience: You can't pull more than 60 \"\n                     \"presets per hour without an API token.\\n\"\n                     \"See https://github.com/mottosso/be/wiki\"\n                     \"/advanced#extended-preset-access\")\n            sys.exit(lib.USER_ERROR)\n        return response\n    except Exception as e:\n        if self.verbose:\n            lib.echo(\"ERROR: %s\" % e)\n        else:\n            lib.echo(\"ERROR: Something went wrong. \"\n                     \"See --verbose for more information\")", "response": "Wrapper for requests. get"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _gist_is_preset(repo):\n\n    _, gistid = repo.split(\"/\")\n\n    gist_template = \"https://api.github.com/gists/{}\"\n    gist_path = gist_template.format(gistid)\n\n    response = get(gist_path)\n    if response.status_code == 404:\n        return False\n\n    try:\n        data = response.json()\n    except:\n        return False\n\n    files = data.get(\"files\", {})\n    package = files.get(\"package.json\", {})\n\n    try:\n        content = json.loads(package.get(\"content\", \"\"))\n    except:\n        return False\n\n    if content.get(\"type\") != \"bepreset\":\n        return False\n\n    return True", "response": "Evaluate whether gist is a be package"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nevaluates whether GitHub repository is a be package", "response": "def _repo_is_preset(repo):\n    \"\"\"Evaluate whether GitHub repository is a be package\n\n    Arguments:\n        gist (str): username/id pair e.g. mottosso/be-ad\n\n    \"\"\"\n\n    package_template = \"https://raw.githubusercontent.com\"\n    package_template += \"/{repo}/master/package.json\"\n    package_path = package_template.format(repo=repo)\n\n    response = get(package_path)\n    if response.status_code == 404:\n        return False\n\n    try:\n        data = response.json()\n    except:\n        return False\n\n    if not data.get(\"type\") == \"bepreset\":\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns remote presets hosted on GitHub", "response": "def github_presets():\n    \"\"\"Return remote presets hosted on GitHub\"\"\"\n    addr = (\"https://raw.githubusercontent.com\"\n            \"/mottosso/be-presets/master/presets.json\")\n    response = get(addr)\n\n    if response.status_code == 404:\n        lib.echo(\"Could not connect with preset database\")\n        sys.exit(lib.PROGRAM_ERROR)\n\n    return dict((package[\"name\"], package[\"repository\"])\n                for package in response.json().get(\"presets\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_preset(preset_dir, project_dir):\n\n    os.makedirs(project_dir)\n\n    package_file = os.path.join(preset_dir, \"package.json\")\n    with open(package_file) as f:\n        package = json.load(f)\n\n    for fname in os.listdir(preset_dir):\n        src = os.path.join(preset_dir, fname)\n\n        contents = package.get(\"contents\") or []\n\n        if fname not in self.files + contents:\n            continue\n\n        if os.path.isfile(src):\n            shutil.copy2(src, project_dir)\n        else:\n            dest = os.path.join(project_dir, fname)\n            shutil.copytree(src, dest)", "response": "Copy contents of preset into new project_dir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _resolve_references(templates):\n\n    def repl(match):\n        lib.echo(\"Deprecation warning: The {@ref} syntax is being removed\")\n        key = pattern[match.start():match.end()].strip(\"@{}\")\n        if key not in templates:\n            sys.stderr.write(\"Unresolvable reference: \\\"%s\\\"\" % key)\n            sys.exit(lib.USER_ERROR)\n        return templates[key]\n\n    for key, pattern in templates.copy().iteritems():\n        templates[key] = re.sub(\"{@\\w+}\", repl, pattern)\n\n    return templates", "response": "Resolve occurences by expansion"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a ( name value ) pair to the dictionary. Doesn t overwrite the value if it already exists.", "response": "def add(self, key, val):\n        \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already\n        exists.\n\n        >>> headers = HTTPHeaderDict(foo='bar')\n        >>> headers.add('Foo', 'baz')\n        >>> headers['foo']\n        'bar, baz'\n        \"\"\"\n        key_lower = key.lower()\n        new_vals = key, val\n        # Keep the common case aka no item present as fast as possible\n        vals = _dict_setdefault(self, key_lower, new_vals)\n        if new_vals is not vals:\n            # new_vals was not inserted, as there was a previous one\n            if isinstance(vals, list):\n                # If already several items got inserted, we have a list\n                vals.append(val)\n            else:\n                # vals should be a tuple then, i.e. only one item so far\n                # Need to convert the tuple to list for further extension\n                _dict_setitem(self, key_lower, [vals[0], vals[1], val])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getlist(self, key):\n        try:\n            vals = _dict_getitem(self, key.lower())\n        except KeyError:\n            return []\n        else:\n            if isinstance(vals, tuple):\n                return [vals[1]]\n            else:\n                return vals[1:]", "response": "Returns a list of all the values for the named field. Returns an empty list if the key doesn t exist. Returns an empty list if the key doesn t exist. Returns an empty list if the key doesn t exist. Returns an empty list if the key doesn t exist. Returns an empty list if the key doesn t exist. Returns an empty list if the key doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate over all header lines including duplicate ones.", "response": "def iteritems(self):\n        \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"\n        for key in self:\n            vals = _dict_getitem(self, key)\n            for val in vals[1:]:\n                yield vals[0], val"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\niterates over all headers merging duplicate ones together.", "response": "def itermerged(self):\n        \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"\n        for key in self:\n            val = _dict_getitem(self, key)\n            yield val[0], ', '.join(val[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread headers from a Python 2 httplib message object.", "response": "def from_httplib(cls, message, duplicates=('set-cookie',)): # Python 2\n        \"\"\"Read headers from a Python 2 httplib message object.\"\"\"\n        ret = cls(message.items())\n        # ret now contains only the last header line for each duplicate.\n        # Importing with all duplicates would be nice, but this would\n        # mean to repeat most of the raw parsing already done, when the\n        # message object was created. Extracting only the headers of interest \n        # separately, the cookies, should be faster and requires less\n        # extra code.\n        for key in duplicates:\n            ret.discard(key)\n            for val in message.getheaders(key):\n                ret.add(key, val)\n            return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes a request using the method url and fields encoded in", "response": "def request_encode_url(self, method, url, fields=None, **urlopen_kw):\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the url. This is useful for request methods like GET, HEAD, DELETE, etc.\n        \"\"\"\n        if fields:\n            url += '?' + urlencode(fields)\n        return self.urlopen(method, url, **urlopen_kw)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a value into a valid string.", "response": "def make_str(value):\n    \"\"\"Converts a value into a valid string.\"\"\"\n    if isinstance(value, bytes):\n        try:\n            return value.decode(sys.getfilesystemencoding())\n        except UnicodeError:\n            return value.decode('utf-8', 'replace')\n    return text_type(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef echo(message=None, file=None, nl=True, err=False, color=None):\n    if file is None:\n        if err:\n            file = _default_text_stderr()\n        else:\n            file = _default_text_stdout()\n\n    # Convert non bytes/text into the native string type.\n    if message is not None and not isinstance(message, echo_native_types):\n        message = text_type(message)\n\n    # If there is a message, and we're in Python 3, and the value looks\n    # like bytes, we manually need to find the binary stream and write the\n    # message in there.  This is done separately so that most stream\n    # types will work as you would expect.  Eg: you can write to StringIO\n    # for other cases.\n    if message and not PY2 and is_bytes(message):\n        binary_file = _find_binary_writer(file)\n        if binary_file is not None:\n            file.flush()\n            binary_file.write(message)\n            if nl:\n                binary_file.write(b'\\n')\n            binary_file.flush()\n            return\n\n    # ANSI-style support.  If there is no message or we are dealing with\n    # bytes nothing is happening.  If we are connected to a file we want\n    # to strip colors.  If we are on windows we either wrap the stream\n    # to strip the color or we use the colorama support to translate the\n    # ansi codes to API calls.\n    if message and not is_bytes(message):\n        if should_strip_ansi(file, color):\n            message = strip_ansi(message)\n        elif WIN:\n            if auto_wrap_for_ansi is not None:\n                file = auto_wrap_for_ansi(file)\n            elif not color:\n                message = strip_ansi(message)\n\n    if message:\n        file.write(message)\n    if nl:\n        file.write('\\n')\n    file.flush()", "response": "Prints a message to the given file or stdout."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parent():\n\n    if self._parent:\n        return self._parent\n\n    if \"BE_SHELL\" in os.environ:\n        self._parent = os.environ[\"BE_SHELL\"]\n    else:\n        # If a shell is not provided, rely on `psutil`\n        # to look at the calling process name.\n        try:\n            import psutil\n        except ImportError:\n            raise ImportError(\n                \"No shell provided, see documentation for \"\n                \"BE_SHELL for more information.\\n\"\n                \"https://github.com/mottosso/be/wiki\"\n                \"/environment#read-environment-variables\")\n\n        parent = psutil.Process(os.getpid()).parent()\n\n        # `pip install` creates an additional executable\n        # that tricks the above mechanism to think of it\n        # as the parent shell. See #34 for more.\n        if parent.name() in (\"be\", \"be.exe\"):\n            parent = parent.parent()\n\n        self._parent = str(parent.exe())\n\n    return self._parent", "response": "Determine the parent shell for the currently running shell."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef platform():\n    executable = parent()\n    basename = os.path.basename(executable)\n    basename, _ = os.path.splitext(basename)\n\n    if basename in (\"bash\", \"sh\"):\n        return \"unix\"\n    if basename in (\"cmd\", \"powershell\"):\n        return \"windows\"\n\n    raise SystemError(\"Unsupported shell: %s\" % basename)", "response": "Return the platform for the current shell e. g. windows unix or unix"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd(parent):\n\n    shell_name = os.path.basename(parent).rsplit(\".\", 1)[0]\n\n    dirname = os.path.dirname(__file__)\n\n    # Support for Bash\n    if shell_name in (\"bash\", \"sh\"):\n        shell = os.path.join(dirname, \"_shell.sh\").replace(\"\\\\\", \"/\")\n        cmd = [parent.replace(\"\\\\\", \"/\"), shell]\n\n    # Support for Cmd\n    elif shell_name in (\"cmd\",):\n        shell = os.path.join(dirname, \"_shell.bat\").replace(\"\\\\\", \"/\")\n        cmd = [parent, \"/K\", shell]\n\n    # Support for Powershell\n    elif shell_name in (\"powershell\",):\n        raise SystemError(\"Powershell not yet supported\")\n\n    # Unsupported\n    else:\n        raise SystemError(\"Unsupported shell: %s\" % shell_name)\n\n    return cmd", "response": "Determine subshell command for subprocess. call\n    Arguments : parent (str ) : Absolute path to parent shell executable"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nproduces the active be environment with additional variables and values listed below.", "response": "def context(root, project=\"\"):\n    \"\"\"Produce the be environment\n\n    The environment is an exact replica of the active\n    environment of the current process, with a few\n    additional variables, all of which are listed below.\n\n    \"\"\"\n\n    environment = os.environ.copy()\n    environment.update({\n        \"BE_PROJECT\": project,\n        \"BE_PROJECTROOT\": (\n            os.path.join(root, project).replace(\"\\\\\", \"/\")\n            if project else \"\"),\n        \"BE_PROJECTSROOT\": root,\n        \"BE_ALIASDIR\": \"\",\n        \"BE_CWD\": root,\n        \"BE_CD\": \"\",\n        \"BE_ROOT\": \"\",\n        \"BE_TOPICS\": \"\",\n        \"BE_DEVELOPMENTDIR\": \"\",\n        \"BE_ACTIVE\": \"1\",\n        \"BE_USER\": \"\",\n        \"BE_SCRIPT\": \"\",\n        \"BE_PYTHON\": \"\",\n        \"BE_ENTER\": \"\",\n        \"BE_TEMPDIR\": \"\",\n        \"BE_PRESETSDIR\": \"\",\n        \"BE_GITHUB_API_TOKEN\": \"\",\n        \"BE_ENVIRONMENT\": \"\",\n        \"BE_BINDING\": \"\",\n        \"BE_TABCOMPLETION\": \"\"\n    })\n\n    return environment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a random name of the available adjective and nouns.", "response": "def random_name():\n    \"\"\"Return a random name\n\n    Example:\n        >> random_name()\n        dizzy_badge\n        >> random_name()\n        evasive_cactus\n\n    \"\"\"\n\n    adj = _data.adjectives[random.randint(0, len(_data.adjectives) - 1)]\n    noun = _data.nouns[random.randint(0, len(_data.nouns) - 1)]\n    return \"%s_%s\" % (adj, noun)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns whether or not path is a project", "response": "def isproject(path):\n    \"\"\"Return whether or not `path` is a project\n\n    Arguments:\n        path (str): Absolute path\n\n    \"\"\"\n\n    try:\n        if os.path.basename(path)[0] in (\".\", \"_\"):\n            return False\n        if not os.path.isdir(path):\n            return False\n        if not any(fname in os.listdir(path)\n                   for fname in (\"templates.yaml\",\n                                 \"inventory.yaml\")):\n            return False\n    except:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef echo(text, silent=False, newline=True):\n\n    if silent:\n        return\n    print(text) if newline else sys.stdout.write(text)", "response": "Print to the console\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_projects(root, backend=os.listdir):\n    projects = list()\n    for project in sorted(backend(root)):\n        abspath = os.path.join(root, project)\n        if not isproject(abspath):\n            continue\n        projects.append(project)\n    return projects", "response": "List all projects at root"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_inventory(inventory):\n\n    inverted = invert_inventory(inventory)\n    items = list()\n    for item in sorted(inverted, key=lambda a: (inverted[a], a)):\n        items.append((item, inverted[item]))\n    return items", "response": "List a projects inventory\n    Given a project simply list the contents of the inventory. yaml"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist contents for resolved template", "response": "def list_template(root, topics, templates, inventory, be, absolute=False):\n    \"\"\"List contents for resolved template\n\n    Resolve a template as far as possible via the given `topics`.\n    For example, if a template supports 5 arguments, but only\n    3 are given, resolve the template until its 4th argument\n    and list the contents thereafter.\n\n    In some cases, an additional path is present following an\n    argument, e.g. {3}/assets. The `/assets` portion is referred\n    to as the \"tail\" and is appended also.\n\n    Arguments:\n        topics (tuple): Current topics\n        templates (dict): templates.yaml\n        inventory (dict): inventory.yaml\n        be (dict): be.yaml\n\n    \"\"\"\n\n    project = topics[0]\n\n    # Get item\n    try:\n        key = be.get(\"templates\", {}).get(\"key\") or \"{1}\"\n        item = item_from_topics(key, topics)\n        binding = binding_from_item(inventory, item)\n\n    except KeyError:\n        return []\n\n    except IndexError as exc:\n        raise IndexError(\"At least %s topics are required\" % str(exc))\n\n    fields = replacement_fields_from_context(\n        context(root, project))\n    binding = binding_from_item(inventory, item)\n    pattern = pattern_from_template(templates, binding)\n\n    # 2 arguments, {1}/{2}/{3} -> {1}/{2}\n    # 2 arguments, {1}/{2}/assets/{3} -> {1}/{2}/assets\n    index_end = pattern.index(str(len(topics)-1)) + 2\n    trimmed_pattern = pattern[:index_end]\n\n    # If there aren't any more positional arguments, we're done\n    print trimmed_pattern\n    if not re.findall(\"{[\\d]+}\", pattern[index_end:]):\n        return []\n\n    # Append trail\n    # e.g. {1}/{2}/assets\n    #             ^^^^^^^\n    try:\n        index_trail = pattern[index_end:].index(\"{\")\n        trail = pattern[index_end:index_end + index_trail - 1]\n        trimmed_pattern += trail\n    except ValueError:\n        pass\n\n    try:\n        path = trimmed_pattern.format(*topics, **fields)\n    except IndexError:\n        raise IndexError(\"Template for \\\"%s\\\" has unordered \"\n                         \"positional arguments: \\\"%s\\\"\" % (item, pattern))\n\n    if not os.path.isdir(path):\n        return []\n\n    items = list()\n    for dirname in os.listdir(path):\n        abspath = os.path.join(path, dirname).replace(\"\\\\\", \"/\")\n        if not os.path.isdir(abspath):\n            continue\n\n        if absolute:\n            items.append(abspath)\n        else:\n            items.append(dirname)\n\n    return items"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninvert the inventory by removing items with additional metadata and items whose type is a number", "response": "def invert_inventory(inventory):\n    \"\"\"Return {item: binding} from {binding: item}\n\n    Protect against items with additional metadata\n    and items whose type is a number\n\n    Returns:\n        Dictionary of inverted inventory\n\n    \"\"\"\n\n    inverted = dict()\n    for binding, items in inventory.iteritems():\n        for item in items:\n            if isinstance(item, dict):\n                item = item.keys()[0]\n            item = str(item)  # Key may be number\n\n            if item in inverted:\n                echo(\"Warning: Duplicate item found, \"\n                     \"for \\\"%s: %s\\\"\" % (binding, item))\n                continue\n            inverted[item] = binding\n\n    return inverted"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pos_development_directory(templates,\n                              inventory,\n                              context,\n                              topics,\n                              user,\n                              item):\n    \"\"\"Return absolute path to development directory\n\n    Arguments:\n        templates (dict): templates.yaml\n        inventory (dict): inventory.yaml\n        context (dict): The be context, from context()\n        topics (list): Arguments to `in`\n        user (str): Current `be` user\n        item (str): Item from template-binding address\n\n    \"\"\"\n\n    replacement_fields = replacement_fields_from_context(context)\n    binding = binding_from_item(inventory, item)\n    pattern = pattern_from_template(templates, binding)\n\n    positional_arguments = find_positional_arguments(pattern)\n    highest_argument = find_highest_position(positional_arguments)\n    highest_available = len(topics) - 1\n    if highest_available < highest_argument:\n        echo(\"Template for \\\"%s\\\" requires at least %i arguments\" % (\n            item, highest_argument + 1))\n        sys.exit(USER_ERROR)\n\n    try:\n        return pattern.format(*topics, **replacement_fields).replace(\"\\\\\", \"/\")\n    except KeyError as exc:\n        echo(\"TEMPLATE ERROR: %s is not an available key\\n\" % exc)\n        echo(\"Available tokens:\")\n        for key in replacement_fields:\n            echo(\"\\n- %s\" % key)\n        sys.exit(TEMPLATE_ERROR)", "response": "Return absolute path to development directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns absolute path to development directory", "response": "def fixed_development_directory(templates, inventory, topics, user):\n    \"\"\"Return absolute path to development directory\n\n    Arguments:\n        templates (dict): templates.yaml\n        inventory (dict): inventory.yaml\n        context (dict): The be context, from context()\n        topics (list): Arguments to `in`\n        user (str): Current `be` user\n\n    \"\"\"\n\n    echo(\"Fixed syntax has been deprecated, see positional syntax\")\n\n    project, item, task = topics[0].split(\"/\")\n\n    template = binding_from_item(inventory, item)\n    pattern = pattern_from_template(templates, template)\n\n    if find_positional_arguments(pattern):\n        echo(\"\\\"%s\\\" uses a positional syntax\" % project)\n        echo(\"Try this:\")\n        echo(\"  be in %s\" % \" \".join([project, item, task]))\n        sys.exit(USER_ERROR)\n\n    keys = {\n        \"cwd\": os.getcwd(),\n        \"project\": project,\n        \"item\": item.replace(\"\\\\\", \"/\"),\n        \"user\": user,\n        \"task\": task,\n        \"type\": task,  # deprecated\n    }\n\n    try:\n        return pattern.format(**keys).replace(\"\\\\\", \"/\")\n    except KeyError as exc:\n        echo(\"TEMPLATE ERROR: %s is not an available key\\n\" % exc)\n        echo(\"Available keys\")\n        for key in keys:\n            echo(\"\\n- %s\" % key)\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replacement_fields_from_context(context):\n\n    return dict((k[3:].lower(), context[k])\n                for k in context if k.startswith(\"BE_\"))", "response": "Convert context replacement fields from BE_KEY to key = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef item_from_topics(key, topics):\n\n    if re.match(\"{\\d+}\", key):\n        pos = int(key.strip(\"{}\"))\n        try:\n            binding = topics[pos]\n        except IndexError:\n            raise IndexError(pos + 1)\n\n    else:\n        echo(\"be.yaml template key not recognised\")\n        sys.exit(PROJECT_ERROR)\n\n    return binding", "response": "Get binding from topics via key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pattern_from_template(templates, name):\n\n    if name not in templates:\n        echo(\"No template named \\\"%s\\\"\" % name)\n        sys.exit(1)\n\n    return templates[name]", "response": "Return pattern for name\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef binding_from_item(inventory, item):\n\n    if item in self.bindings:\n        return self.bindings[item]\n\n    bindings = invert_inventory(inventory)\n\n    try:\n        self.bindings[item] = bindings[item]\n        return bindings[item]\n\n    except KeyError as exc:\n        exc.bindings = bindings\n        raise exc", "response": "Return the binding for item"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_environment(fields, context, topics):\n\n    def _resolve_environment_lists(context):\n        \"\"\"Concatenate environment lists\"\"\"\n        for key, value in context.copy().iteritems():\n            if isinstance(value, list):\n                context[key] = os.pathsep.join(value)\n        return context\n\n    def _resolve_environment_references(fields, context):\n        \"\"\"Resolve $ occurences by expansion\n\n        Given a dictionary {\"PATH\": \"$PATH;somevalue;{0}\"}\n        Return {\"PATH\": \"value_of_PATH;somevalue;myproject\"},\n        given that the first topic - {0} - is \"myproject\"\n\n        Arguments:\n            fields (dict): Environment from be.yaml\n            context (dict): Source context\n\n        \"\"\"\n\n        def repl(match):\n            key = pattern[match.start():match.end()].strip(\"$\")\n            return context.get(key)\n\n        pat = re.compile(\"\\$\\w+\", re.IGNORECASE)\n        for key, pattern in fields.copy().iteritems():\n            fields[key] = pat.sub(repl, pattern) \\\n                          .strip(os.pathsep)  # Remove superflous separators\n\n        return fields\n\n    def _resolve_environment_fields(fields, context, topics):\n        \"\"\"Resolve {} occurences\n\n        Supports both positional and BE_-prefixed variables.\n\n        Example:\n            BE_MYKEY -> \"{mykey}\" from `BE_MYKEY`\n            {1} -> \"{mytask}\" from `be in myproject mytask`\n\n        Returns:\n            Dictionary of resolved fields\n\n        \"\"\"\n\n        source_dict = replacement_fields_from_context(context)\n        source_dict.update(dict((str(topics.index(topic)), topic)\n                                for topic in topics))\n\n        def repl(match):\n            key = pattern[match.start():match.end()].strip(\"{}\")\n            try:\n                return source_dict[key]\n            except KeyError:\n                echo(\"PROJECT ERROR: Unavailable reference \\\"%s\\\" \"\n                     \"in be.yaml\" % key)\n                sys.exit(PROJECT_ERROR)\n\n        for key, pattern in fields.copy().iteritems():\n            fields[key] = re.sub(\"{[\\d\\w]+}\", repl, pattern)\n\n        return fields\n\n    fields = _resolve_environment_lists(fields)\n    fields = _resolve_environment_references(fields, context)\n    fields = _resolve_environment_fields(fields, context, topics)\n\n    return fields", "response": "Resolve environment variables and fields from the be. yaml file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_redirect(redirect, topics, context):\n\n    for map_source, map_dest in redirect.items():\n        if re.match(\"{\\d+}\", map_source):\n            topics_index = int(map_source.strip(\"{}\"))\n            topics_value = topics[topics_index]\n            context[map_dest] = topics_value\n            continue\n\n        context[map_dest] = context[map_source]", "response": "Resolve the be. yaml redirect key\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef slice(index, template):\n\n    try:\n        return re.match(\"^.*{[%i]}\" % index, template).group()\n    except AttributeError:\n        raise ValueError(\"Index %i not found in template: %s\"\n                         % (index, template))", "response": "Slice a template based on it s positional argument"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a urllib3 ProxyManager for the given proxy.", "response": "def proxy_manager_for(self, proxy, **proxy_kwargs):\n        \"\"\"Return urllib3 ProxyManager for the given proxy.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The proxy to return a urllib3 ProxyManager for.\n        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n        :returns: ProxyManager\n        \"\"\"\n        if not proxy in self.proxy_manager:\n            proxy_headers = self.proxy_headers(proxy)\n            self.proxy_manager[proxy] = proxy_from_url(\n                proxy,\n                proxy_headers=proxy_headers,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n                **proxy_kwargs)\n\n        return self.proxy_manager[proxy]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cert_verify(self, conn, url, verify, cert):\n        if url.lower().startswith('https') and verify:\n\n            cert_loc = None\n\n            # Allow self-specified cert location.\n            if verify is not True:\n                cert_loc = verify\n\n            if not cert_loc:\n                cert_loc = DEFAULT_CA_BUNDLE_PATH\n\n            if not cert_loc:\n                raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n            conn.ca_certs = cert_loc\n        else:\n            conn.cert_reqs = 'CERT_NONE'\n            conn.ca_certs = None\n\n        if cert:\n            if not isinstance(cert, basestring):\n                conn.cert_file = cert[0]\n                conn.key_file = cert[1]\n            else:\n                conn.cert_file = cert", "response": "Verify a SSL certificate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_connection(self, url, proxies=None):\n        proxies = proxies or {}\n        proxy = proxies.get(urlparse(url.lower()).scheme)\n\n        if proxy:\n            proxy = prepend_scheme_if_needed(proxy, 'http')\n            proxy_manager = self.proxy_manager_for(proxy)\n            conn = proxy_manager.connection_from_url(url)\n        else:\n            # Only scheme should be lower case\n            parsed = urlparse(url)\n            url = parsed.geturl()\n            conn = self.poolmanager.connection_from_url(url)\n\n        return conn", "response": "Returns a urllib3 connection for the given URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request_url(self, request, proxies):\n        proxies = proxies or {}\n        scheme = urlparse(request.url).scheme\n        proxy = proxies.get(scheme)\n\n        if proxy and scheme != 'https':\n            url = urldefragauth(request.url)\n        else:\n            url = request.path_url\n\n        return url", "response": "Obtain the url to use when making the final request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef proxy_headers(self, proxy):\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers", "response": "Returns a dictionary of the headers to add to any request sent\n        through a proxy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct and sends a new request object.", "response": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n\n    :param method: method for the new :class:`Request` object.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n    :param json: (optional) json data to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': ('filename', fileobj)}``) for multipart encoding upload.\n    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n    :param timeout: (optional) How long to wait for the server to send data\n        before giving up, as a float, or a (`connect timeout, read timeout\n        <user/advanced.html#timeouts>`_) tuple.\n    :type timeout: float or tuple\n    :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n    :type allow_redirects: bool\n    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n    :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n    :param stream: (optional) if ``False``, the response content will be immediately downloaded.\n    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n\n    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'http://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n    session = sessions.Session()\n    response = session.request(method=method, url=url, **kwargs)\n    # By explicitly closing the session, we avoid leaving sockets open which\n    # can trigger a ResourceWarning in some cases, and look like a memory leak\n    # in others.\n    session.close()\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the connection is dropped and should be closed.", "response": "def is_connection_dropped(conn):  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n\n    :param conn:\n        :class:`httplib.HTTPConnection` object.\n\n    Note: For platforms like AppEngine, this will always return ``False`` to\n    let the platform handle connection recycling transparently for us.\n    \"\"\"\n    sock = getattr(conn, 'sock', False)\n    if sock is False:  # Platform-specific: AppEngine\n        return False\n    if sock is None:  # Connection already closed (such as by httplib).\n        return True\n\n    if not poll:\n        if not select:  # Platform-specific: AppEngine\n            return False\n\n        try:\n            return select([sock], [], [], 0.0)[0]\n        except socket.error:\n            return True\n\n    # This version is better on platforms that support it.\n    p = poll()\n    p.register(sock, POLLIN)\n    for (fno, ev) in p.poll(0.0):\n        if fno == sock.fileno():\n            # Either data is buffered (bad), or the connection is dropped.\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef morsel_to_cookie(morsel):\n\n    expires = None\n    if morsel['max-age']:\n        expires = time.time() + morsel['max-age']\n    elif morsel['expires']:\n        time_template = '%a, %d-%b-%Y %H:%M:%S GMT'\n        expires = time.mktime(\n            time.strptime(morsel['expires'], time_template)) - time.timezone\n    return create_cookie(\n        comment=morsel['comment'],\n        comment_url=bool(morsel['comment']),\n        discard=False,\n        domain=morsel['domain'],\n        expires=expires,\n        name=morsel.key,\n        path=morsel['path'],\n        port=None,\n        rest={'HttpOnly': morsel['httponly']},\n        rfc2109=False,\n        secure=bool(morsel['secure']),\n        value=morsel.value,\n        version=morsel['version'] or 0,\n    )", "response": "Convert a Morsel object into a Cookie containing the one k - v pair."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_dict(self, domain=None, path=None):\n        dictionary = {}\n        for cookie in iter(self):\n            if (domain is None or cookie.domain == domain) and (path is None\n                                                or cookie.path == path):\n                dictionary[cookie.name] = cookie.value\n        return dictionary", "response": "Takes as an argument an optional domain and path and returns a plain\n        old Python dict of name - value pairs of cookies that meet the\n        requirements."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef feed(self, aBuf, aCharLen):\n        if aCharLen == 2:\n            # we only care about 2-bytes character in our distribution analysis\n            order = self.get_order(aBuf)\n        else:\n            order = -1\n        if order >= 0:\n            self._mTotalChars += 1\n            # order is valid\n            if order < self._mTableSize:\n                if 512 > self._mCharToFreqOrder[order]:\n                    self._mFreqChars += 1", "response": "feed a character with known length"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_confidence(self):\n        # if we didn't receive any character in our consideration range,\n        # return negative answer\n        if self._mTotalChars <= 0 or self._mFreqChars <= MINIMUM_DATA_THRESHOLD:\n            return SURE_NO\n\n        if self._mTotalChars != self._mFreqChars:\n            r = (self._mFreqChars / ((self._mTotalChars - self._mFreqChars)\n                 * self._mTypicalDistributionRatio))\n            if r < SURE_YES:\n                return r\n\n        # normalize confidence (we don't want to be 100% sure)\n        return SURE_YES", "response": "return confidence based on existing data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_stderr_logger(level=logging.DEBUG):\n    # This method needs to be in this __init__.py to get the __name__ correct\n    # even if urllib3 is vendored within another package.\n    logger = logging.getLogger(__name__)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(message)s'))\n    logger.addHandler(handler)\n    logger.setLevel(level)\n    logger.debug('Added a stderr logging handler to logger: %s' % __name__)\n    return handler", "response": "Helper for quickly adding a StreamHandler to the logger. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if given fingerprint matches the supplied certificate.", "response": "def assert_fingerprint(cert, fingerprint):\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n\n    # Maps the length of a digest to a possible hash function producing\n    # this digest.\n    hashfunc_map = {\n        16: md5,\n        20: sha1,\n        32: sha256,\n    }\n\n    fingerprint = fingerprint.replace(':', '').lower()\n    digest_length, odd = divmod(len(fingerprint), 2)\n\n    if odd or digest_length not in hashfunc_map:\n        raise SSLError('Fingerprint is of invalid length.')\n\n    # We need encode() here for py32; works on py2 and p33.\n    fingerprint_bytes = unhexlify(fingerprint.encode())\n\n    hashfunc = hashfunc_map[digest_length]\n\n    cert_digest = hashfunc(cert).digest()\n\n    if not cert_digest == fingerprint_bytes:\n        raise SSLError('Fingerprints did not match. Expected \"{0}\", got \"{1}\".'\n                       .format(hexlify(fingerprint_bytes),\n                               hexlify(cert_digest)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new SSLContext object with the specified options and cipher suites.", "response": "def create_urllib3_context(ssl_version=None, cert_reqs=ssl.CERT_REQUIRED,\n                           options=None, ciphers=None):\n    \"\"\"All arguments have the same meaning as ``ssl_wrap_socket``.\n\n    By default, this function does a lot of the same work that\n    ``ssl.create_default_context`` does on Python 3.4+. It:\n\n    - Disables SSLv2, SSLv3, and compression\n    - Sets a restricted set of server ciphers\n\n    If you wish to enable SSLv3, you can do::\n\n        from urllib3.util import ssl_\n        context = ssl_.create_urllib3_context()\n        context.options &= ~ssl_.OP_NO_SSLv3\n\n    You can do the same to enable compression (substituting ``COMPRESSION``\n    for ``SSLv3`` in the last line above).\n\n    :param ssl_version:\n        The desired protocol version to use. This will default to\n        PROTOCOL_SSLv23 which will negotiate the highest protocol that both\n        the server and your installation of OpenSSL support.\n    :param cert_reqs:\n        Whether to require the certificate verification. This defaults to\n        ``ssl.CERT_REQUIRED``.\n    :param options:\n        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,\n        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.\n    :param ciphers:\n        Which cipher suites to allow the server to select.\n    :returns:\n        Constructed SSLContext object with specified options\n    :rtype: SSLContext\n    \"\"\"\n    context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)\n\n    if options is None:\n        options = 0\n        # SSLv2 is easily broken and is considered harmful and dangerous\n        options |= OP_NO_SSLv2\n        # SSLv3 has several problems and is now dangerous\n        options |= OP_NO_SSLv3\n        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+\n        # (issue #309)\n        options |= OP_NO_COMPRESSION\n\n    context.options |= options\n\n    if getattr(context, 'supports_set_ciphers', True):  # Platform-specific: Python 2.6\n        context.set_ciphers(ciphers or _DEFAULT_CIPHERS)\n\n    context.verify_mode = cert_reqs\n    if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2\n        # We do our own verification, including fingerprints and alternative\n        # hostnames. So disable it here\n        context.check_hostname = False\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap for ssl. wrap_socket.", "response": "def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,\n                    ca_certs=None, server_hostname=None,\n                    ssl_version=None, ciphers=None, ssl_context=None):\n    \"\"\"\n    All arguments except for server_hostname and ssl_context have the same\n    meaning as they do when using :func:`ssl.wrap_socket`.\n\n    :param server_hostname:\n        When SNI is supported, the expected hostname of the certificate\n    :param ssl_context:\n        A pre-made :class:`SSLContext` object. If none is provided, one will\n        be created using :func:`create_urllib3_context`.\n    :param ciphers:\n        A string of ciphers we wish the client to support. This is not\n        supported on Python 2.6 as the ssl module does not support it.\n    \"\"\"\n    context = ssl_context\n    if context is None:\n        context = create_urllib3_context(ssl_version, cert_reqs,\n                                         ciphers=ciphers)\n\n    if ca_certs:\n        try:\n            context.load_verify_locations(ca_certs)\n        except IOError as e:  # Platform-specific: Python 2.6, 2.7, 3.2\n            raise SSLError(e)\n        # Py33 raises FileNotFoundError which subclasses OSError\n        # These are not equivalent unless we check the errno attribute\n        except OSError as e:  # Platform-specific: Python 3.3 and beyond\n            if e.errno == errno.ENOENT:\n                raise SSLError(e)\n            raise\n    if certfile:\n        context.load_cert_chain(certfile, keyfile)\n    if HAS_SNI:  # Platform-specific: OpenSSL with enabled SNI\n        return context.wrap_socket(sock, server_hostname=server_hostname)\n    return context.wrap_socket(sock)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connection_from_url(url, **kw):\n    scheme, host, port = get_host(url)\n    if scheme == 'https':\n        return HTTPSConnectionPool(host, port=port, **kw)\n    else:\n        return HTTPConnectionPool(host, port=port, **kw)", "response": "Given a url return an instance of a : class :. ConnectionPool instance of its host."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nputs a connection into the pool.", "response": "def _put_conn(self, conn):\n        \"\"\"\n        Put a connection back into the pool.\n\n        :param conn:\n            Connection object for the current host and port as returned by\n            :meth:`._new_conn` or :meth:`._get_conn`.\n\n        If the pool is already full, the connection is closed and discarded\n        because we exceeded maxsize. If connections are discarded frequently,\n        then maxsize should be increased.\n\n        If the pool is closed, then the connection will be closed and discarded.\n        \"\"\"\n        try:\n            self.pool.put(conn, block=False)\n            return  # Everything is dandy, done.\n        except AttributeError:\n            # self.pool is None.\n            pass\n        except Full:\n            # This should never happen if self.block == True\n            log.warning(\n                \"Connection pool is full, discarding connection: %s\" %\n                self.host)\n\n        # Connection never got put back into the pool, close it.\n        if conn:\n            conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_request(self, conn, method, url, timeout=_Default,\n                      **httplib_request_kw):\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n\n        :param conn:\n            a connection from one of our connection pools\n\n        :param timeout:\n            Socket timeout in seconds for the request. This can be a\n            float or integer, which will set the same timeout value for\n            the socket connect and the socket read, or an instance of\n            :class:`urllib3.util.Timeout`, which gives you more fine-grained\n            control over your timeouts.\n        \"\"\"\n        self.num_requests += 1\n\n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = timeout_obj.connect_timeout\n\n        # Trigger any extra validation we need to do.\n        try:\n            self._validate_conn(conn)\n        except (SocketTimeout, BaseSSLError) as e:\n            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n        # conn.request() calls httplib.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        conn.request(method, url, **httplib_request_kw)\n\n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n\n        # App Engine doesn't have a sock attr\n        if getattr(conn, 'sock', None):\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout)\n            if read_timeout is Timeout.DEFAULT_TIMEOUT:\n                conn.sock.settimeout(socket.getdefaulttimeout())\n            else:  # None or a value\n                conn.sock.settimeout(read_timeout)\n\n        # Receive the response from the server\n        try:\n            try:  # Python 2.7, use buffering of HTTP responses\n                httplib_response = conn.getresponse(buffering=True)\n            except TypeError:  # Python 2.6 and older\n                httplib_response = conn.getresponse()\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        # AppEngine doesn't have a version attr.\n        http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')\n        log.debug(\"\\\"%s %s %s\\\" %s %s\" % (method, url, http_version,\n                                          httplib_response.status,\n                                          httplib_response.length))\n        return httplib_response", "response": "Perform a request on a given urllib connection object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef urlopen(self, method, url, body=None, headers=None, retries=None,\n                redirect=True, assert_same_host=True, timeout=_Default,\n                pool_timeout=None, release_conn=None, **response_kw):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n\n        .. note::\n\n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param body:\n            Data to send in the request body (useful for creating\n            POST requests, see HTTPConnectionPool.post_url for\n            more convenience).\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When False, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n\n        :param \\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if release_conn is None:\n            release_conn = response_kw.get('preload_content', True)\n\n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        conn = None\n\n        # Merge the proxy headers. Only do this in HTTP. We have to copy the\n        # headers dict so we can safely change it without those changes being\n        # reflected in anyone else's copy.\n        if self.scheme == 'http':\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n\n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n\n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n\n            conn.timeout = timeout_obj.connect_timeout\n\n            is_new_proxy_conn = self.proxy is not None and not getattr(conn, 'sock', None)\n            if is_new_proxy_conn:\n                self._prepare_proxy(conn)\n\n            # Make the request on the httplib connection object.\n            httplib_response = self._make_request(conn, method, url,\n                                                  timeout=timeout_obj,\n                                                  body=body, headers=headers)\n\n            # If we're going to release the connection in ``finally:``, then\n            # the request doesn't need to know about the connection. Otherwise\n            # it will also try to release it and we'll have a double-release\n            # mess.\n            response_conn = not release_conn and conn\n\n            # Import httplib's response into our own wrapper object\n            response = HTTPResponse.from_httplib(httplib_response,\n                                                 pool=self,\n                                                 connection=response_conn,\n                                                 **response_kw)\n\n            # else:\n            #     The connection will be put back into the pool when\n            #     ``response.release_conn()`` is called (implicitly by\n            #     ``response.read()``)\n\n        except Empty:\n            # Timed out by queue.\n            raise EmptyPoolError(self, \"No pool connections are available.\")\n\n        except (BaseSSLError, CertificateError) as e:\n            # Close the connection. If a connection is reused on which there\n            # was a Certificate error, the next request will certainly raise\n            # another Certificate error.\n            if conn:\n                conn.close()\n                conn = None\n            raise SSLError(e)\n\n        except SSLError:\n            # Treat SSLError separately from BaseSSLError to preserve\n            # traceback.\n            if conn:\n                conn.close()\n                conn = None\n            raise\n\n        except (TimeoutError, HTTPException, SocketError, ConnectionError) as e:\n            if conn:\n                # Discard the connection for these exceptions. It will be\n                # be replaced during the next _get_conn() call.\n                conn.close()\n                conn = None\n\n            if isinstance(e, SocketError) and self.proxy:\n                e = ProxyError('Cannot connect to proxy.', e)\n            elif isinstance(e, (SocketError, HTTPException)):\n                e = ProtocolError('Connection aborted.', e)\n\n            retries = retries.increment(method, url, error=e, _pool=self,\n                                        _stacktrace=sys.exc_info()[2])\n            retries.sleep()\n\n            # Keep track of the error for the retry warning.\n            err = e\n\n        finally:\n            if release_conn:\n                # Put the connection back to be reused. If the connection is\n                # expired then it will be None, which will get replaced with a\n                # fresh connection during _get_conn.\n                self._put_conn(conn)\n\n        if not conn:\n            # Try again\n            log.warning(\"Retrying (%r) after connection \"\n                        \"broken by '%r': %s\" % (retries, err, url))\n            return self.urlopen(method, url, body, headers, retries,\n                                redirect, assert_same_host,\n                                timeout=timeout, pool_timeout=pool_timeout,\n                                release_conn=release_conn, **response_kw)\n\n        # Handle redirect?\n        redirect_location = redirect and response.get_redirect_location()\n        if redirect_location:\n            if response.status == 303:\n                method = 'GET'\n\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_redirect:\n                    raise\n                return response\n\n            log.info(\"Redirecting %s -> %s\" % (url, redirect_location))\n            return self.urlopen(method, redirect_location, body, headers,\n                    retries=retries, redirect=redirect,\n                    assert_same_host=assert_same_host,\n                    timeout=timeout, pool_timeout=pool_timeout,\n                    release_conn=release_conn, **response_kw)\n\n        # Check if we should retry the HTTP response.\n        if retries.is_forced_retry(method, status_code=response.status):\n            retries = retries.increment(method, url, response=response, _pool=self)\n            retries.sleep()\n            log.info(\"Forced retry: %s\" % url)\n            return self.urlopen(method, url, body, headers,\n                    retries=retries, redirect=redirect,\n                    assert_same_host=assert_same_host,\n                    timeout=timeout, pool_timeout=pool_timeout,\n                    release_conn=release_conn, **response_kw)\n\n        return response", "response": "A method that returns a response from the HTTP connection pool."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _new_conn(self):\n        self.num_connections += 1\n        log.info(\"Starting new HTTPS connection (%d): %s\"\n                 % (self.num_connections, self.host))\n\n        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:\n            # Platform-specific: Python without ssl\n            raise SSLError(\"Can't connect to HTTPS URL because the SSL \"\n                           \"module is not available.\")\n\n        actual_host = self.host\n        actual_port = self.port\n        if self.proxy is not None:\n            actual_host = self.proxy.host\n            actual_port = self.proxy.port\n\n        conn = self.ConnectionCls(host=actual_host, port=actual_port,\n                                  timeout=self.timeout.connect_timeout,\n                                  strict=self.strict, **self.conn_kw)\n\n        return self._prepare_conn(conn)", "response": "Create a new connection."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall right before a request is made after the socket is created.", "response": "def _validate_conn(self, conn):\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        super(HTTPSConnectionPool, self)._validate_conn(conn)\n\n        # Force connect early to allow us to validate the connection.\n        if not getattr(conn, 'sock', None):  # AppEngine might not have  `.sock`\n            conn.connect()\n\n        if not conn.is_verified:\n            warnings.warn((\n                'Unverified HTTPS request is being made. '\n                'Adding certificate verification is strongly advised. See: '\n                'https://urllib3.readthedocs.org/en/latest/security.html'),\n                InsecureRequestWarning)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef description_of(lines, name='stdin'):\n    u = UniversalDetector()\n    for line in lines:\n        u.feed(line)\n    u.close()\n    result = u.result\n    if result['encoding']:\n        return '{0}: {1} with confidence {2}'.format(name, result['encoding'],\n                                                     result['confidence'])\n    else:\n        return '{0}: no result'.format(name)", "response": "Returns a string describing the probable encoding of a file or a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles command line arguments and gets things started. :param argv: List of arguments, as if specified on the command-line. If None, ``sys.argv[1:]`` is used instead. :type argv: list of str", "response": "def main(argv=None):\n    '''\n    Handles command line arguments and gets things started.\n\n    :param argv: List of arguments, as if specified on the command-line.\n                 If None, ``sys.argv[1:]`` is used instead.\n    :type argv: list of str\n    '''\n    # Get command line arguments\n    parser = argparse.ArgumentParser(\n        description=\"Takes one or more file paths and reports their detected \\\n                     encodings\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        conflict_handler='resolve')\n    parser.add_argument('input',\n                        help='File whose encoding we would like to determine.',\n                        type=argparse.FileType('rb'), nargs='*',\n                        default=[sys.stdin])\n    parser.add_argument('--version', action='version',\n                        version='%(prog)s {0}'.format(__version__))\n    args = parser.parse_args(argv)\n\n    for f in args.input:\n        if f.isatty():\n            print(\"You are running chardetect interactively. Press \" +\n                  \"CTRL-D twice at the start of a blank line to signal the \" +\n                  \"end of your input. If you want help, run chardetect \" +\n                  \"--help\\n\", file=sys.stderr)\n        print(description_of(f, f.name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_terminal_size():\n    # If shutil has get_terminal_size() (Python 3.3 and later) use that\n    if sys.version_info >= (3, 3):\n        import shutil\n        shutil_get_terminal_size = getattr(shutil, 'get_terminal_size', None)\n        if shutil_get_terminal_size:\n            sz = shutil_get_terminal_size()\n            return sz.columns, sz.lines\n\n    if get_winterm_size is not None:\n        return get_winterm_size()\n\n    def ioctl_gwinsz(fd):\n        try:\n            import fcntl\n            import termios\n            cr = struct.unpack(\n                'hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))\n        except Exception:\n            return\n        return cr\n\n    cr = ioctl_gwinsz(0) or ioctl_gwinsz(1) or ioctl_gwinsz(2)\n    if not cr:\n        try:\n            fd = os.open(os.ctermid(), os.O_RDONLY)\n            try:\n                cr = ioctl_gwinsz(fd)\n            finally:\n                os.close(fd)\n        except Exception:\n            pass\n    if not cr or not cr[0] or not cr[1]:\n        cr = (os.environ.get('LINES', 25),\n              os.environ.get('COLUMNS', DEFAULT_COLUMNS))\n    return int(cr[1]), int(cr[0])", "response": "Returns the current size of the terminal as tuple in the form\n    ( width height ) in columns and rows."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef style(text, fg=None, bg=None, bold=None, dim=None, underline=None,\n          blink=None, reverse=None, reset=True):\n    \"\"\"Styles a text with ANSI styles and returns the new string.  By\n    default the styling is self contained which means that at the end\n    of the string a reset code is issued.  This can be prevented by\n    passing ``reset=False``.\n\n    Examples::\n\n        click.echo(click.style('Hello World!', fg='green'))\n        click.echo(click.style('ATTENTION!', blink=True))\n        click.echo(click.style('Some things', reverse=True, fg='cyan'))\n\n    Supported color names:\n\n    * ``black`` (might be a gray)\n    * ``red``\n    * ``green``\n    * ``yellow`` (might be an orange)\n    * ``blue``\n    * ``magenta``\n    * ``cyan``\n    * ``white`` (might be light gray)\n    * ``reset`` (reset the color code only)\n\n    .. versionadded:: 2.0\n\n    :param text: the string to style with ansi codes.\n    :param fg: if provided this will become the foreground color.\n    :param bg: if provided this will become the background color.\n    :param bold: if provided this will enable or disable bold mode.\n    :param dim: if provided this will enable or disable dim mode.  This is\n                badly supported.\n    :param underline: if provided this will enable or disable underline.\n    :param blink: if provided this will enable or disable blinking.\n    :param reverse: if provided this will enable or disable inverse\n                    rendering (foreground becomes background and the\n                    other way round).\n    :param reset: by default a reset-all code is added at the end of the\n                  string which means that styles do not carry over.  This\n                  can be disabled to compose styles.\n    \"\"\"\n    bits = []\n    if fg:\n        try:\n            bits.append('\\033[%dm' % (_ansi_colors.index(fg) + 30))\n        except ValueError:\n            raise TypeError('Unknown color %r' % fg)\n    if bg:\n        try:\n            bits.append('\\033[%dm' % (_ansi_colors.index(bg) + 40))\n        except ValueError:\n            raise TypeError('Unknown color %r' % bg)\n    if bold is not None:\n        bits.append('\\033[%dm' % (1 if bold else 22))\n    if dim is not None:\n        bits.append('\\033[%dm' % (2 if dim else 22))\n    if underline is not None:\n        bits.append('\\033[%dm' % (4 if underline else 24))\n    if blink is not None:\n        bits.append('\\033[%dm' % (5 if blink else 25))\n    if reverse is not None:\n        bits.append('\\033[%dm' % (7 if reverse else 27))\n    bits.append(text)\n    if reset:\n        bits.append(_ansi_reset_all)\n    return ''.join(bits)", "response": "Style a string with ANSI codes and returns the new string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef secho(text, file=None, nl=True, err=False, color=None, **styles):\n    return echo(style(text, **styles), file=file, nl=nl, err=err, color=color)", "response": "A wrapper around click. secho and click. style"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmerging two settings into one.", "response": "def merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"\n    Determines appropriate setting for a given request, taking into account the\n    explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n\n    if session_setting is None:\n        return request_setting\n\n    if request_setting is None:\n        return session_setting\n\n    # Bypass if not a dictionary (e.g. verify)\n    if not (\n            isinstance(session_setting, Mapping) and\n            isinstance(request_setting, Mapping)\n    ):\n        return request_setting\n\n    merged_setting = dict_class(to_key_val_list(session_setting))\n    merged_setting.update(to_key_val_list(request_setting))\n\n    # Remove keys that are set to None.\n    for (k, v) in request_setting.items():\n        if v is None:\n            del merged_setting[k]\n\n    merged_setting = dict((k, v) for (k, v) in merged_setting.items() if v is not None)\n\n    return merged_setting"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresolving the redirects in a response.", "response": "def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        hist = [] # keep track of history\n\n        while resp.is_redirect:\n            prepared_request = req.copy()\n\n            if i > 0:\n                # Update history and keep track of redirects.\n                hist.append(resp)\n                new_hist = list(hist)\n                resp.history = new_hist\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = req.method\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith('//'):\n                parsed_rurl = urlparse(resp.url)\n                url = '%s:%s' % (parsed_rurl.scheme, url)\n\n            # The scheme should be lower case...\n            parsed = urlparse(url)\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n            # Cache the url, unless it redirects to itself.\n            if resp.is_permanent_redirect and req.url != prepared_request.url:\n                self.redirect_cache[req.url] = prepared_request.url\n\n            # http://tools.ietf.org/html/rfc7231#section-6.4.4\n            if (resp.status_code == codes.see_other and\n                    method != 'HEAD'):\n                method = 'GET'\n\n            # Do what the browsers do, despite standards...\n            # First, turn 302s into GETs.\n            if resp.status_code == codes.found and method != 'HEAD':\n                method = 'GET'\n\n            # Second, if a POST is responded to with a 301, turn it into a GET.\n            # This bizarre behaviour is explained in Issue 1704.\n            if resp.status_code == codes.moved and method == 'POST':\n                method = 'GET'\n\n            prepared_request.method = method\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n                if 'Content-Length' in prepared_request.headers:\n                    del prepared_request.headers['Content-Length']\n\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            try:\n                del headers['Cookie']\n            except KeyError:\n                pass\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            prepared_request._cookies.update(self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # Override the original request.\n            req = prepared_request\n\n            resp = self.send(\n                req,\n                stream=stream,\n                timeout=timeout,\n                verify=verify,\n                cert=cert,\n                proxies=proxies,\n                allow_redirects=False,\n            )\n\n            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n            i += 1\n            yield resp"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, request, **kwargs):\n        # Set defaults that the hooks can utilize to ensure they always have\n        # the correct parameters to reproduce the previous request.\n        kwargs.setdefault('stream', self.stream)\n        kwargs.setdefault('verify', self.verify)\n        kwargs.setdefault('cert', self.cert)\n        kwargs.setdefault('proxies', self.proxies)\n\n        # It's possible that users might accidentally send a Request object.\n        # Guard against that specific failure case.\n        if not isinstance(request, PreparedRequest):\n            raise ValueError('You can only send PreparedRequests.')\n\n        checked_urls = set()\n        while request.url in self.redirect_cache:\n            checked_urls.add(request.url)\n            new_url = self.redirect_cache.get(request.url)\n            if new_url in checked_urls:\n                break\n            request.url = new_url\n\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        timeout = kwargs.get('timeout')\n        verify = kwargs.get('verify')\n        cert = kwargs.get('cert')\n        proxies = kwargs.get('proxies')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = datetime.utcnow()\n\n        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        r.elapsed = datetime.utcnow() - start\n\n        # Response manipulation hooks\n        r = dispatch_hook('response', hooks, r, **kwargs)\n\n        # Persist cookies\n        if r.history:\n\n            # If the hooks create history then we want those cookies too\n            for resp in r.history:\n                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n\n        extract_cookies_to_jar(self.cookies, request, r.raw)\n\n        # Redirect resolving generator.\n        gen = self.resolve_redirects(r, request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies)\n\n        # Resolve redirects if allowed.\n        history = [resp for resp in gen] if allow_redirects else []\n\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n            r.history = history\n\n        if not stream:\n            r.content\n\n        return r", "response": "Send a PreparedRequest object to the local cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares the given HTTP method.", "response": "def prepare_method(self, method):\n        \"\"\"Prepares the given HTTP method.\"\"\"\n        self.method = method\n        if self.method is not None:\n            self.method = self.method.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare the given HTTP headers.", "response": "def prepare_headers(self, headers):\n        \"\"\"Prepares the given HTTP headers.\"\"\"\n\n        if headers:\n            self.headers = CaseInsensitiveDict((to_native_string(name), value) for name, value in headers.items())\n        else:\n            self.headers = CaseInsensitiveDict()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter_content(self, chunk_size=1, decode_unicode=False):\n        def generate():\n            try:\n                # Special case for urllib3.\n                try:\n                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n                        yield chunk\n                except ProtocolError as e:\n                    raise ChunkedEncodingError(e)\n                except DecodeError as e:\n                    raise ContentDecodingError(e)\n                except ReadTimeoutError as e:\n                    raise ConnectionError(e)\n            except AttributeError:\n                # Standard file-like object.\n                while True:\n                    chunk = self.raw.read(chunk_size)\n                    if not chunk:\n                        break\n                    yield chunk\n\n            self._content_consumed = True\n\n        if self._content_consumed and isinstance(self._content, bool):\n            raise StreamConsumedError()\n        # simulate reading small chunks of the content\n        reused_chunks = iter_slices(self._content, chunk_size)\n\n        stream_chunks = generate()\n\n        chunks = reused_chunks if self._content_consumed else stream_chunks\n\n        if decode_unicode:\n            chunks = stream_decode_response_unicode(chunks, self)\n\n        return chunks", "response": "Iterates over the response data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the json - encoded content of a response if any.", "response": "def json(self, **kwargs):\n        \"\"\"Returns the json-encoded content of a response, if any.\n\n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        \"\"\"\n\n        if not self.encoding and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using chardet to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return json.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n        return json.loads(self.text, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises an exception if one occurred.", "response": "def raise_for_status(self):\n        \"\"\"Raises stored :class:`HTTPError`, if one occurred.\"\"\"\n\n        http_error_msg = ''\n\n        if 400 <= self.status_code < 500:\n            http_error_msg = '%s Client Error: %s' % (self.status_code, self.reason)\n\n        elif 500 <= self.status_code < 600:\n            http_error_msg = '%s Server Error: %s' % (self.status_code, self.reason)\n\n        if http_error_msg:\n            raise HTTPError(http_error_msg, response=self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _new_pool(self, scheme, host, port):\n        pool_cls = pool_classes_by_scheme[scheme]\n        kwargs = self.connection_pool_kw\n        if scheme == 'http':\n            kwargs = self.connection_pool_kw.copy()\n            for kw in SSL_KEYWORDS:\n                kwargs.pop(kw, None)\n\n        return pool_cls(host, port, **kwargs)", "response": "Create a new connection pool based on host port and scheme."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a ConnectionPool based on the given host and port and scheme.", "response": "def connection_from_host(self, host, port=None, scheme='http'):\n        \"\"\"\n        Get a :class:`ConnectionPool` based on the host, port, and scheme.\n\n        If ``port`` isn't given, it will be derived from the ``scheme`` using\n        ``urllib3.connectionpool.port_by_scheme``.\n        \"\"\"\n\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        scheme = scheme or 'http'\n        port = port or port_by_scheme.get(scheme, 80)\n        pool_key = (scheme, host, port)\n\n        with self.pools.lock:\n            # If the scheme, host, or port doesn't match existing open\n            # connections, open a new ConnectionPool.\n            pool = self.pools.get(pool_key)\n            if pool:\n                return pool\n\n            # Make a fresh ConnectionPool of the desired type\n            pool = self._new_pool(scheme, host, port)\n            self.pools[pool_key] = pool\n\n        return pool"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(program=None,\n         version=None,\n         doc_template=None,\n         commands=None,\n         argv=None,\n         exit_at_end=True):\n    \"\"\"Top-level driver for creating subcommand-based programs.\n\n    Args:\n        program: The name of your program.\n        version: The version string for your program.\n        doc_template: The top-level docstring template for your program. If\n            `None`, a standard default version is applied.\n        commands: A `Subcommands` instance.\n        argv: The command-line arguments to parse. If `None`, this defaults to\n            `sys.argv[1:]`\n        exit_at_end: Whether to call `sys.exit()` at the end of the function.\n\n    There are two ways to use this function. First, you can pass `program`,\n    `version`, and `doc_template`, in which case `docopt_subcommands` will use\n    these arguments along with the subcommands registered with `command()` to\n    define you program.\n\n    The second way to use this function is to pass in a `Subcommands` objects\n    via the `commands` argument. In this case the `program`, `version`, and\n    `doc_template` arguments are ignored, and the `Subcommands` instance takes\n    precedence.\n\n    In both cases the `argv` argument can be used to specify the arguments to\n    be parsed.\n\n    \"\"\"\n    if commands is None:\n        if program is None:\n            raise ValueError(\n                '`program` required if subcommand object not provided')\n        if version is None:\n            raise ValueError(\n                '`version` required if subcommand object not provided')\n        commands = Subcommands(program,\n                               version,\n                               doc_template=doc_template)\n        for name, handler in _commands:\n            commands.add_command(handler, name)\n\n    if argv is None:\n        argv = sys.argv[1:]\n\n    result = commands(argv)\n    if exit_at_end:\n        sys.exit(result)\n    else:\n        return result", "response": "Main function for creating a new If            instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noverride process_response would pipe response. body through BeautifulSoup.", "response": "def process_response(self, request, response, spider):\n        \"\"\"Overridden process_response would \"pipe\" response.body through BeautifulSoup.\"\"\"\n        return response.replace(body=str(BeautifulSoup(response.body, self.parser)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating test_methods for the given test_functions.", "response": "def _expand_datasets(test_functions):\n    \"\"\"\n    Generator producing test_methods, with an optional dataset.\n\n    :param test_functions:\n        Iterator over tuples of test name and test unbound function.\n    :type test_functions:\n        `iterator` of `tuple` of (`unicode`, `function`)\n    :return:\n        Generator yielding a tuple of\n        - method_name      : Name of the test method\n        - unbound function : Unbound function that will be the test method.\n        - dataset name     : String representation of the given dataset\n        - dataset          : Tuple representing the args for a test\n        - param factory    : Function that returns params for the test method\n    :rtype:\n        `generator` of `tuple` of (\n            `unicode`,\n            `function`,\n            `unicode` or None,\n            `tuple` or None,\n            `function` or None,\n        )\n    \"\"\"\n    for name, func in test_functions:\n\n        dataset_tuples = chain(\n            [(None, getattr(func, 'genty_datasets', {}))],\n            getattr(func, 'genty_dataproviders', []),\n        )\n\n        no_datasets = True\n        for dataprovider, datasets in dataset_tuples:\n            for dataset_name, dataset in six.iteritems(datasets):\n                no_datasets = False\n                yield name, func, dataset_name, dataset, dataprovider\n\n        if no_datasets:\n            # yield the original test method, unaltered\n            yield name, func, None, None, None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate test_methods for the given test_functions.", "response": "def _expand_repeats(test_functions):\n    \"\"\"\n    Generator producing test_methods, with any repeat count unrolled.\n\n    :param test_functions:\n        Sequence of tuples of\n        - method_name      : Name of the test method\n        - unbound function : Unbound function that will be the test method.\n        - dataset name     : String representation of the given dataset\n        - dataset          : Tuple representing the args for a test\n        - param factory    : Function that returns params for the test method\n    :type test_functions:\n        `iterator` of `tuple` of\n        (`unicode`, `function`, `unicode` or None, `tuple` or None, `function`)\n    :return:\n        Generator yielding a tuple of\n        (method_name, unbound function, dataset, name dataset, repeat_suffix)\n    :rtype:\n        `generator` of `tuple` of (`unicode`, `function`,\n        `unicode` or None, `tuple` or None, `function`, `unicode`)\n    \"\"\"\n    for name, func, dataset_name, dataset, dataprovider in test_functions:\n        repeat_count = getattr(func, 'genty_repeat_count', 0)\n        if repeat_count:\n            for i in range(1, repeat_count + 1):\n                repeat_suffix = _build_repeat_suffix(i, repeat_count)\n                yield (\n                    name,\n                    func,\n                    dataset_name,\n                    dataset,\n                    dataprovider,\n                    repeat_suffix,\n                )\n        else:\n            yield name, func, dataset_name, dataset, dataprovider, None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _is_referenced_in_argv(method_name):\n    expr = '.*[:.]{0}$'.format(method_name)\n    regex = re.compile(expr)\n    return any(regex.match(arg) for arg in sys.argv)", "response": "Checks if the given method name is referenced by the command line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a repeat suffix for the current iteration.", "response": "def _build_repeat_suffix(iteration, count):\n    \"\"\"\n    Return the suffix string to identify iteration X out of Y.\n\n    For example, with a count of 100, this will build strings like\n    \"iteration_053\" or \"iteration_008\".\n\n    :param iteration:\n        Current iteration.\n    :type iteration:\n        `int`\n    :param count:\n        Total number of iterations.\n    :type count:\n        `int`\n    :return:\n        Repeat suffix.\n    :rtype:\n        `unicode`\n    \"\"\"\n    format_width = int(math.ceil(math.log(count + 1, 10)))\n    new_suffix = 'iteration_{0:0{width}d}'.format(\n        iteration,\n        width=format_width\n    )\n    return new_suffix"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_final_method_name(\n        method_name,\n        dataset_name,\n        dataprovider_name,\n        repeat_suffix,\n):\n    \"\"\"\n    Return a nice human friendly name, that almost looks like code.\n\n    Example: a test called 'test_something' with a dataset of (5, 'hello')\n         Return:  \"test_something(5, 'hello')\"\n\n    Example: a test called 'test_other_stuff' with dataset of (9) and repeats\n         Return: \"test_other_stuff(9) iteration_<X>\"\n\n    :param method_name:\n        Base name of the method to add.\n    :type method_name:\n        `unicode`\n    :param dataset_name:\n        Base name of the data set.\n    :type dataset_name:\n        `unicode` or None\n    :param dataprovider_name:\n        If there's a dataprovider involved, then this is its name.\n    :type dataprovider_name:\n        `unicode` or None\n    :param repeat_suffix:\n        Suffix to append to the name of the generated method.\n    :type repeat_suffix:\n        `unicode` or None\n    :return:\n        The fully composed name of the generated test method.\n    :rtype:\n        `unicode`\n    \"\"\"\n    # For tests using a dataprovider, append \"_<dataprovider_name>\" to\n    #  the test method name\n    suffix = ''\n    if dataprovider_name:\n        suffix = '_{0}'.format(dataprovider_name)\n\n    if not dataset_name and not repeat_suffix:\n        return '{0}{1}'.format(method_name, suffix)\n\n    if dataset_name:\n        # Nosetest multi-processing code parses the full test name\n        # to discern package/module names. Thus any periods in the test-name\n        # causes that code to fail. So replace any periods with the unicode\n        # middle-dot character. Yes, this change is applied independent\n        # of the test runner being used... and that's fine since there is\n        # no real contract as to how the fabricated tests are named.\n        dataset_name = dataset_name.replace('.', REPLACE_FOR_PERIOD_CHAR)\n\n    # Place data_set info inside parens, as if it were a function call\n    suffix = '{0}({1})'.format(suffix, dataset_name or \"\")\n\n    if repeat_suffix:\n        suffix = '{0} {1}'.format(suffix, repeat_suffix)\n\n    test_method_name_for_dataset = \"{0}{1}\".format(\n        method_name,\n        suffix,\n    )\n\n    return test_method_name_for_dataset", "response": "Build the final test method name for the specified data set and dataset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _build_dataset_method(method, dataset):\n    if isinstance(dataset, GentyArgs):\n        test_method = lambda my_self: method(\n            my_self,\n            *dataset.args,\n            **dataset.kwargs\n        )\n    else:\n        test_method = lambda my_self: method(\n            my_self,\n            *dataset\n        )\n    return test_method", "response": "Builds a test method that can be used to build the dataset for given method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _build_dataprovider_method(method, dataset, dataprovider):\n    if isinstance(dataset, GentyArgs):\n        final_args = dataset.args\n        final_kwargs = dataset.kwargs\n    else:\n        final_args = dataset\n        final_kwargs = {}\n\n    def test_method_wrapper(my_self):\n        args = dataprovider(\n            my_self,\n            *final_args,\n            **final_kwargs\n        )\n\n        kwargs = {}\n\n        if isinstance(args, GentyArgs):\n            kwargs = args.kwargs\n            args = args.args\n        elif not isinstance(args, (tuple, list)):\n            args = (args, )\n\n        return method(my_self, *args, **kwargs)\n\n    return test_method_wrapper", "response": "Build a test method that calls the dataprovider with the given dataset and returns the return value from that method."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a method to the given class.", "response": "def _add_method_to_class(\n        target_cls,\n        method_name,\n        func,\n        dataset_name,\n        dataset,\n        dataprovider,\n        repeat_suffix,\n):\n    \"\"\"\n    Add the described method to the given class.\n\n    :param target_cls:\n        Test class to which to add a method.\n    :type target_cls:\n        `class`\n    :param method_name:\n        Base name of the method to add.\n    :type method_name:\n        `unicode`\n    :param func:\n        The underlying test function to call.\n    :type func:\n        `callable`\n    :param dataset_name:\n        Base name of the data set.\n    :type dataset_name:\n        `unicode` or None\n    :param dataset:\n        Tuple containing the args of the dataset.\n    :type dataset:\n        `tuple` or None\n    :param repeat_suffix:\n        Suffix to append to the name of the generated method.\n    :type repeat_suffix:\n        `unicode` or None\n    :param dataprovider:\n        The unbound function that's responsible for generating the actual\n        params that will be passed to the test function. Can be None.\n    :type dataprovider:\n        `callable`\n    \"\"\"\n    # pylint: disable=too-many-arguments\n    test_method_name_for_dataset = _build_final_method_name(\n        method_name,\n        dataset_name,\n        dataprovider.__name__ if dataprovider else None,\n        repeat_suffix,\n    )\n\n    test_method_for_dataset = _build_test_method(func, dataset, dataprovider)\n\n    test_method_for_dataset = functools.update_wrapper(\n        test_method_for_dataset,\n        func,\n    )\n\n    test_method_name_for_dataset = encode_non_ascii_string(\n        test_method_name_for_dataset,\n    )\n    test_method_for_dataset.__name__ = test_method_name_for_dataset\n    test_method_for_dataset.genty_generated_test = True\n\n    # Add the method to the class under the proper name\n    setattr(target_cls, test_method_name_for_dataset, test_method_for_dataset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef close(self):\n        if self._process:\n            # Be nice first.\n            self._process.send_signal(signal.SIGINT)\n\n            # If it doesn't close itself promptly, be brutal.\n            # Python 3.2+ added the timeout option to wait() and the\n            # corresponding TimeoutExpired exception. If they exist, use them.\n            if hasattr(subprocess, 'TimeoutExpired'):\n                try:\n                    self._process.wait(timeout=1)\n                except subprocess.TimeoutExpired:\n                    self._process.send_signal(signal.SIGKILL)\n\n            # Otherwise, roll our own polling loop.\n            else:\n                # Give it 1s, checking every 10ms.\n                count = 0\n                while count < 100:\n                    if self._process.poll() is not None:\n                        break\n                    time.sleep(0.01)\n\n                # Still hasn't quit.\n                if self._process.poll() is None:\n                    self._process.send_signal(signal.SIGKILL)\n\n            # Clean up.\n            self._process = None", "response": "Close any open window."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _run_nonblocking(self, args, input=None):\n        # Close any existing dialog.\n        if self._process:\n            self.close()\n\n        # Start the new one.\n        self._process = subprocess.Popen(args, stdout=subprocess.PIPE)", "response": "Internal API to run a non - blocking command with subprocess. Popen"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef error(self, message, rofi_args=None, **kwargs):\n        rofi_args = rofi_args or []\n        # Generate arguments list.\n        args = ['rofi', '-e', message]\n        args.extend(self._common_args(allow_fullscreen=False, **kwargs))\n        args.extend(rofi_args)\n\n        # Close any existing window and show the error.\n        self._run_blocking(args)", "response": "Show an error window."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef status(self, message, rofi_args=None, **kwargs):\n        rofi_args = rofi_args or []\n        # Generate arguments list.\n        args = ['rofi', '-e', message]\n        args.extend(self._common_args(allow_fullscreen=False, **kwargs))\n        args.extend(rofi_args)\n\n        # Update the status.\n        self._run_nonblocking(args)", "response": "Show a status message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select(self, prompt, options, rofi_args=None, message=\"\", select=None, **kwargs):\n        rofi_args = rofi_args or []\n        # Replace newlines and turn the options into a single string.\n        optionstr = '\\n'.join(option.replace('\\n', ' ') for option in options)\n\n        # Set up arguments.\n        args = ['rofi', '-dmenu', '-p', prompt, '-format', 'i']\n        if select is not None:\n            args.extend(['-selected-row', str(select)])\n\n        # Key bindings to display.\n        display_bindings = []\n\n        # Configure the key bindings.\n        user_keys = set()\n        for k, v in kwargs.items():\n            # See if the keyword name matches the needed format.\n            if not k.startswith('key'):\n                continue\n            try:\n                keynum = int(k[3:])\n            except ValueError:\n                continue\n\n            # Add it to the set.\n            key, action = v\n            user_keys.add(keynum)\n            args.extend(['-kb-custom-{0:s}'.format(k[3:]), key])\n            if action:\n                display_bindings.append(\"<b>{0:s}</b>: {1:s}\".format(key, action))\n\n        # And the global exit bindings.\n        exit_keys = set()\n        next_key = 10\n        for key in self.exit_hotkeys:\n            while next_key in user_keys:\n                next_key += 1\n            exit_keys.add(next_key)\n            args.extend(['-kb-custom-{0:d}'.format(next_key), key])\n            next_key += 1\n\n        # Add any displayed key bindings to the message.\n        message = message or \"\"\n        if display_bindings:\n            message += \"\\n\" + \"  \".join(display_bindings)\n        message = message.strip()\n\n        # If we have a message, add it to the arguments.\n        if message:\n            args.extend(['-mesg', message])\n\n        # Add in common arguments.\n        args.extend(self._common_args(**kwargs))\n        args.extend(rofi_args)\n\n        # Run the dialog.\n        returncode, stdout = self._run_blocking(args, input=optionstr)\n\n        # Figure out which option was selected.\n        stdout = stdout.strip()\n        index = int(stdout) if stdout else -1\n\n        # And map the return code to a key.\n        if returncode == 0:\n            key = 0\n        elif returncode == 1:\n            key = -1\n        elif returncode > 9:\n            key = returncode - 9\n            if key in exit_keys:\n                raise SystemExit()\n        else:\n            self.exit_with_error(\"Unexpected rofi returncode {0:d}.\".format(results.returncode))\n\n        # And return.\n        return index, key", "response": "Show a list of options and return user selection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generic_entry(self, prompt, validator=None, message=None, rofi_args=None, **kwargs):\n        error = \"\"\n        rofi_args = rofi_args or []\n\n        # Keep going until we get something valid.\n        while True:\n            args = ['rofi', '-dmenu', '-p', prompt, '-format', 's']\n\n            # Add any error to the given message.\n            msg = message or \"\"\n            if error:\n                msg = '<span color=\"#FF0000\" font_weight=\"bold\">{0:s}</span>\\n{1:s}'.format(error, msg)\n                msg = msg.rstrip('\\n')\n\n            # If there is actually a message to show.\n            if msg:\n                args.extend(['-mesg', msg])\n\n            # Add in common arguments.\n            args.extend(self._common_args(**kwargs))\n            args.extend(rofi_args)\n\n            # Run it.\n            returncode, stdout = self._run_blocking(args, input=\"\")\n\n            # Was the dialog cancelled?\n            if returncode == 1:\n                return None\n\n            # Get rid of the trailing newline and check its validity.\n            text = stdout.rstrip('\\n')\n            if validator:\n                value, error = validator(text)\n                if not error:\n                    return value\n            else:\n                return text", "response": "A generic entry box."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef text_entry(self, prompt, message=None, allow_blank=False, strip=True,\n            rofi_args=None, **kwargs):\n        \"\"\"Prompt the user to enter a piece of text.\n\n        Parameters\n        ----------\n        prompt: string\n            Prompt to display to the user.\n        message: string, optional\n            Message to display under the entry line.\n        allow_blank: Boolean\n            Whether to allow blank entries.\n        strip: Boolean\n            Whether to strip leading and trailing whitespace from the entered\n            value.\n\n        Returns\n        -------\n        string, or None if the dialog was cancelled.\n\n        \"\"\"\n        def text_validator(text):\n            if strip:\n                text = text.strip()\n            if not allow_blank:\n                if not text:\n                    return None, \"A value is required.\"\n\n            return text, None\n\n        return self.generic_entry(prompt, text_validator, message, rofi_args, **kwargs)", "response": "Prompt the user to enter a piece of text."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprompt the user to enter an integer value.", "response": "def integer_entry(self, prompt, message=None, min=None, max=None, rofi_args=None, **kwargs):\n        \"\"\"Prompt the user to enter an integer.\n\n        Parameters\n        ----------\n        prompt: string\n            Prompt to display to the user.\n        message: string, optional\n            Message to display under the entry line.\n        min, max: integer, optional\n            Minimum and maximum values to allow. If None, no limit is imposed.\n\n        Returns\n        -------\n        integer, or None if the dialog is cancelled.\n\n        \"\"\"\n        # Sanity check.\n        if (min is not None) and (max is not None) and not (max > min):\n            raise ValueError(\"Maximum limit has to be more than the minimum limit.\")\n\n        def integer_validator(text):\n            error = None\n\n            # Attempt to convert to integer.\n            try:\n                value = int(text)\n            except ValueError:\n                return None, \"Please enter an integer value.\"\n\n            # Check its within limits.\n            if (min is not None) and (value < min):\n                return None, \"The minimum allowable value is {0:d}.\".format(min)\n            if (max is not None) and (value > max):\n                return None, \"The maximum allowable value is {0:d}.\".format(max)\n\n            return value, None\n\n        return self.generic_entry(prompt, integer_validator, message, rofi_args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprompts the user to enter a floating point number.", "response": "def float_entry(self, prompt, message=None, min=None, max=None, rofi_args=None, **kwargs):\n        \"\"\"Prompt the user to enter a floating point number.\n\n        Parameters\n        ----------\n        prompt: string\n            Prompt to display to the user.\n        message: string, optional\n            Message to display under the entry line.\n        min, max: float, optional\n            Minimum and maximum values to allow. If None, no limit is imposed.\n\n        Returns\n        -------\n        float, or None if the dialog is cancelled.\n\n        \"\"\"\n        # Sanity check.\n        if (min is not None) and (max is not None) and not (max > min):\n            raise ValueError(\"Maximum limit has to be more than the minimum limit.\")\n\n        def float_validator(text):\n            error = None\n\n            # Attempt to convert to float.\n            try:\n                value = float(text)\n            except ValueError:\n                return None, \"Please enter a floating point value.\"\n\n            # Check its within limits.\n            if (min is not None) and (value < min):\n                return None, \"The minimum allowable value is {0}.\".format(min)\n            if (max is not None) and (value > max):\n                return None, \"The maximum allowable value is {0}.\".format(max)\n\n            return value, None\n\n        return self.generic_entry(prompt, float_validator, message, rofi_args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decimal_entry(self, prompt, message=None, min=None, max=None, rofi_args=None, **kwargs):\n        # Sanity check.\n        if (min is not None) and (max is not None) and not (max > min):\n            raise ValueError(\"Maximum limit has to be more than the minimum limit.\")\n\n        def decimal_validator(text):\n            error = None\n\n            # Attempt to convert to decimal.\n            try:\n                value = Decimal(text)\n            except InvalidOperation:\n                return None, \"Please enter a decimal value.\"\n\n            # Check its within limits.\n            if (min is not None) and (value < min):\n                return None, \"The minimum allowable value is {0}.\".format(min)\n            if (max is not None) and (value > max):\n                return None, \"The maximum allowable value is {0}.\".format(max)\n\n            return value, None\n\n        return self.generic_entry(prompt, decimal_validator, message, rofi_args, **kwargs)", "response": "Prompt the user to enter a decimal number."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprompts the user to enter a date.", "response": "def date_entry(self, prompt, message=None, formats=['%x', '%d/%m/%Y'],\n            show_example=False, rofi_args=None, **kwargs):\n        \"\"\"Prompt the user to enter a date.\n\n        Parameters\n        ----------\n        prompt: string\n            Prompt to display to the user.\n        message: string, optional\n            Message to display under the entry line.\n        formats: list of strings, optional\n            The formats that the user can enter dates in. These should be\n            format strings as accepted by the datetime.datetime.strptime()\n            function from the standard library. They are tried in order, and\n            the first that returns a date object without error is selected.\n            Note that the '%x' in the default list is the current locale's date\n            representation.\n        show_example: Boolean\n            If True, today's date in the first format given is appended to the\n            message.\n\n        Returns\n        -------\n        datetime.date, or None if the dialog is cancelled.\n\n        \"\"\"\n        def date_validator(text):\n            # Try them in order.\n            for format in formats:\n                try:\n                    dt = datetime.strptime(text, format)\n                except ValueError:\n                    continue\n                else:\n                    # This one worked; good enough for us.\n                    return (dt.date(), None)\n\n            # None of the formats worked.\n            return (None, 'Please enter a valid date.')\n\n        # Add an example to the message?\n        if show_example:\n            message = message or \"\"\n            message += \"Today's date in the correct format: \" + datetime.now().strftime(formats[0])\n\n        return self.generic_entry(prompt, date_validator, message, rofi_args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprompt the user to enter a time.", "response": "def time_entry(self, prompt, message=None, formats=['%X', '%H:%M', '%I:%M', '%H.%M',\n        '%I.%M'], show_example=False, rofi_args=None, **kwargs):\n        \"\"\"Prompt the user to enter a time.\n\n        Parameters\n        ----------\n        prompt: string\n            Prompt to display to the user.\n        message: string, optional\n            Message to display under the entry line.\n        formats: list of strings, optional\n            The formats that the user can enter times in. These should be\n            format strings as accepted by the datetime.datetime.strptime()\n            function from the standard library. They are tried in order, and\n            the first that returns a time object without error is selected.\n            Note that the '%X' in the default list is the current locale's time\n            representation.\n        show_example: Boolean\n            If True, the current time in the first format given is appended to\n            the message.\n\n        Returns\n        -------\n        datetime.time, or None if the dialog is cancelled.\n\n        \"\"\"\n        def time_validator(text):\n            # Try them in order.\n            for format in formats:\n                try:\n                    dt = datetime.strptime(text, format)\n                except ValueError:\n                    continue\n                else:\n                    # This one worked; good enough for us.\n                    return (dt.time(), None)\n\n            # None of the formats worked.\n            return (None, 'Please enter a valid time.')\n\n        # Add an example to the message?\n        if show_example:\n            message = message or \"\"\n            message += \"Current time in the correct format: \" + datetime.now().strftime(formats[0])\n\n        return self.generic_entry(prompt, time_validator, message, rofi_args=None, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef datetime_entry(self, prompt, message=None, formats=['%x %X'], show_example=False,\n            rofi_args=None, **kwargs):\n        \"\"\"Prompt the user to enter a date and time.\n\n        Parameters\n        ----------\n        prompt: string\n            Prompt to display to the user.\n        message: string, optional\n            Message to display under the entry line.\n        formats: list of strings, optional\n            The formats that the user can enter the date and time in. These\n            should be format strings as accepted by the\n            datetime.datetime.strptime() function from the standard library.\n            They are tried in order, and the first that returns a datetime\n            object without error is selected.  Note that the '%x %X' in the\n            default list is the current locale's date and time representation.\n        show_example: Boolean\n            If True, the current date and time in the first format given is appended to\n            the message.\n\n        Returns\n        -------\n        datetime.datetime, or None if the dialog is cancelled.\n\n        \"\"\"\n        def datetime_validator(text):\n            # Try them in order.\n            for format in formats:\n                try:\n                    dt = datetime.strptime(text, format)\n                except ValueError:\n                    continue\n                else:\n                    # This one worked; good enough for us.\n                    return (dt, None)\n\n            # None of the formats worked.\n            return (None, 'Please enter a valid date and time.')\n\n        # Add an example to the message?\n        if show_example:\n            message = message or \"\"\n            message += \"Current date and time in the correct format: \" + datetime.now().strftime(formats[0])\n\n        return self.generic_entry(prompt, datetime_validator, message, rofi_args, **kwargs)", "response": "Prompt the user to enter a date and time."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreporting an error and exit.", "response": "def exit_with_error(self, error, **kwargs):\n        \"\"\"Report an error and exit.\n\n        This raises a SystemExit exception to ask the interpreter to quit.\n\n        Parameters\n        ----------\n        error: string\n            The error to report before quitting.\n\n        \"\"\"\n        self.error(error, **kwargs)\n        raise SystemExit(error)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a key = value pair in a .", "response": "def format_kwarg(key, value):\n    \"\"\"\n    Return a string of form:  \"key=<value>\"\n\n    If 'value' is a string, we want it quoted. The goal is to make\n    the string a named parameter in a method call.\n    \"\"\"\n    translator = repr if isinstance(value, six.string_types) else six.text_type\n    arg_value = translator(value)\n\n    return '{0}={1}'.format(key, arg_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_arg(value):\n    translator = repr if isinstance(value, six.string_types) else six.text_type\n    return translator(value)", "response": "Formats the value in a dataset."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode a non - ASCII string into a base64 - encoded version of the string.", "response": "def encode_non_ascii_string(string):\n    \"\"\"\n    :param string:\n        The string to be encoded\n    :type string:\n        unicode or str\n    :return:\n        The encoded string\n    :rtype:\n        str\n    \"\"\"\n    encoded_string = string.encode('utf-8', 'replace')\n    if six.PY3:\n        encoded_string = encoded_string.decode()\n\n    return encoded_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef genty_dataset(*args, **kwargs):\n    datasets = _build_datasets(*args, **kwargs)\n\n    def wrap(test_method):\n        # Save the datasets in the test method. This data will be consumed\n        # by the @genty decorator.\n        if not hasattr(test_method, 'genty_datasets'):\n            test_method.genty_datasets = OrderedDict()\n\n        test_method.genty_datasets.update(datasets)\n\n        return test_method\n    return wrap", "response": "Decorator for the genty_dataset method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the datasets into a dict where the keys are the name of the data set and the values are the data sets themselves.", "response": "def _build_datasets(*args, **kwargs):\n    \"\"\"Build the datasets into a dict, where the keys are the name of the\n    data set and the values are the data sets themselves.\n\n    :param args:\n        Tuple of unnamed data sets.\n    :type args:\n        `tuple` of varies\n    :param kwargs:\n        Dict of pre-named data sets.\n    :type kwargs:\n        `dict` of `unicode` to varies\n    :return:\n        The dataset dict.\n    :rtype:\n        `dict`\n    \"\"\"\n    datasets = OrderedDict()\n    _add_arg_datasets(datasets, args)\n    _add_kwarg_datasets(datasets, kwargs)\n    return datasets"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd data sets of the given args to the given datasets.", "response": "def _add_arg_datasets(datasets, args):\n    \"\"\"Add data sets of the given args.\n\n    :param datasets:\n        The dict where to accumulate data sets.\n    :type datasets:\n        `dict`\n    :param args:\n        Tuple of unnamed data sets.\n    :type args:\n        `tuple` of varies\n    \"\"\"\n    for dataset in args:\n        # turn a value into a 1-tuple.\n        if not isinstance(dataset, (tuple, GentyArgs)):\n            dataset = (dataset,)\n\n        # Create a test_name_suffix - basically the parameter list\n        if isinstance(dataset, GentyArgs):\n            dataset_strings = dataset     # GentyArgs supports iteration\n        else:\n            dataset_strings = [format_arg(data) for data in dataset]\n        test_method_suffix = \", \".join(dataset_strings)\n\n        datasets[test_method_suffix] = dataset"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd data sets of the given kwargs to the given datasets.", "response": "def _add_kwarg_datasets(datasets, kwargs):\n    \"\"\"Add data sets of the given kwargs.\n\n    :param datasets:\n        The dict where to accumulate data sets.\n    :type datasets:\n        `dict`\n    :param kwargs:\n        Dict of pre-named data sets.\n    :type kwargs:\n        `dict` of `unicode` to varies\n    \"\"\"\n    for test_method_suffix, dataset in six.iteritems(kwargs):\n        datasets[test_method_suffix] = dataset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dedent(s):\n    head, _, tail = s.partition('\\n')\n    dedented_tail = textwrap.dedent(tail)\n    result = \"{head}\\n{tail}\".format(\n        head=head,\n        tail=dedented_tail)\n    return result", "response": "Removes the hanging dedent from all the first line of a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef top_level_doc(self):\n        return self._doc_template.format(\n            available_commands='\\n  '.join(sorted(self._commands)),\n            program=self.program)", "response": "The top - level documentation string for the program."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef command(self, name=None):\n        def decorator(f):\n            self.add_command(f, name)\n            return f\n        return decorator", "response": "A decorator to add subcommands."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a subcommand handler which invokes handler.", "response": "def add_command(self, handler, name=None):\n        \"\"\"Add a subcommand `name` which invokes `handler`.\n        \"\"\"\n        if name is None:\n            name = docstring_to_subcommand(handler.__doc__)\n\n        # TODO: Prevent overwriting 'help'?\n        self._commands[name] = handler"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates variations of the word based on letter combinations like oo ou etc.", "response": "def variations(word):\n    \"\"\"Create variations of the word based on letter combinations like oo,\nsh, etc.\"\"\"\n\n    if len(word) == 1:\n        return [[word[0]]]\n    elif word == 'aa':\n        return [['A']]\n    elif word == 'ee':\n        return [['i']]\n    elif word == 'ei':\n        return [['ei']]\n    elif word in ['oo', 'ou']:\n        return [['u']]\n    elif word == 'kha':\n        return [['kha'], ['kh', 'a']]\n    elif word in ['kh', 'gh', 'ch', 'sh', 'zh', 'ck']:\n        return [[word]]\n    elif word in [\"'ee\", \"'ei\"]:\n        return [[\"'i\"]]\n    elif word in [\"'oo\", \"'ou\"]:\n        return [[\"'u\"]]\n    elif word in [\"a'\", \"e'\", \"o'\", \"i'\", \"u'\", \"A'\"]:\n        return [[word[0] + \"'\"]]\n    elif word in [\"'a\", \"'e\", \"'o\", \"'i\", \"'u\", \"'A\"]:\n        return [[\"'\" + word[1]]]\n    elif len(word) == 2 and word[0] == word[1]:\n        return [[word[0]]]\n\n    if word[:2] == 'aa':\n        return [['A'] + i for i in variations(word[2:])]\n    elif word[:2] == 'ee':\n        return [['i'] + i for i in variations(word[2:])]\n    elif word[:2] in ['oo', 'ou']:\n        return [['u'] + i for i in variations(word[2:])]\n    elif word[:3] == 'kha':\n        return \\\n            [['kha'] + i for i in variations(word[3:])] + \\\n            [['kh', 'a'] + i for i in variations(word[3:])] + \\\n            [['k', 'h', 'a'] + i for i in variations(word[3:])]\n    elif word[:2] in ['kh', 'gh', 'ch', 'sh', 'zh', 'ck']:\n        return \\\n            [[word[:2]] + i for i in variations(word[2:])] + \\\n            [[word[0]] + i for i in variations(word[1:])]\n    elif word[:2] in [\"a'\", \"e'\", \"o'\", \"i'\", \"u'\", \"A'\"]:\n        return [[word[:2]] + i for i in variations(word[2:])]\n    elif word[:3] in [\"'ee\", \"'ei\"]:\n        return [[\"'i\"] + i for i in variations(word[3:])]\n    elif word[:3] in [\"'oo\", \"'ou\"]:\n        return [[\"'u\"] + i for i in variations(word[3:])]\n    elif word[:2] in [\"'a\", \"'e\", \"'o\", \"'i\", \"'u\", \"'A\"]:\n        return [[word[:2]] + i for i in variations(word[2:])]\n    elif len(word) >= 2 and word[0] == word[1]:\n        return [[word[0]] + i for i in variations(word[2:])]\n    else:\n        return [[word[0]] + i for i in variations(word[1:])]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef f2p_word(word, max_word_size=15, cutoff=3):\n\n    original_word = word\n    word = word.lower()\n\n    c = dictionary.get(word)\n    if c:\n        return [(c, 1.0)]\n\n    if word == '':\n        return []\n    elif len(word) > max_word_size:\n        return [(original_word, 1.0)]\n\n    results = []\n    for w in variations(word):\n        results.extend(f2p_word_internal(w, original_word))\n\n    # sort results based on the confidence value\n    results.sort(key=lambda r: r[1], reverse=True)\n\n    # return the top three results in order to cut down on the number\n    # of possibilities.\n    return results[:cutoff]", "response": "Convert a single word from Finglish to Persian."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a phrase from Finglish to Persian.", "response": "def f2p_list(phrase, max_word_size=15, cutoff=3):\n    \"\"\"Convert a phrase from Finglish to Persian.\n\n    phrase: The phrase to convert.\n\n    max_word_size: Maximum size of the words to consider. Words larger\n    than this will be kept unchanged.\n\n    cutoff: The cut-off point. For each word, there could be many\n    possibilities. By default 3 of these possibilities are considered\n    for each word. This number can be changed by this argument.\n\n    Returns a list of lists, each sub-list contains a number of\n    possibilities for each word as a pair of (word, confidence)\n    values.\n\n    \"\"\"\n\n    # split the phrase into words\n    results = [w for w in sep_regex.split(phrase) if w]\n\n    # return an empty list if no words\n    if results == []:\n        return []\n\n    # convert each word separately\n    results = [f2p_word(w, max_word_size, cutoff) for w in results]\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a Finglish phrase to the most probable Persian phrase.", "response": "def f2p(phrase, max_word_size=15, cutoff=3):\n    \"\"\"Convert a Finglish phrase to the most probable Persian phrase.\n\n    \"\"\"\n\n    results = f2p_list(phrase, max_word_size, cutoff)\n    return ' '.join(i[0][0] for i in results)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to get the version of the named distribution returs None on failure", "response": "def distribution_version(name):\n    \"\"\"try to get the version of the named distribution,\n    returs None on failure\"\"\"\n    from pkg_resources import get_distribution, DistributionNotFound\n    try:\n        dist = get_distribution(name)\n    except DistributionNotFound:\n        pass\n    else:\n        return dist.version"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing given package from the export definitions.", "response": "def initpkg(pkgname, exportdefs, attr=None, eager=False):\n    \"\"\" initialize given package from the export definitions. \"\"\"\n    attr = attr or {}\n    oldmod = sys.modules.get(pkgname)\n    d = {}\n    f = getattr(oldmod, '__file__', None)\n    if f:\n        f = _py_abspath(f)\n    d['__file__'] = f\n    if hasattr(oldmod, '__version__'):\n        d['__version__'] = oldmod.__version__\n    if hasattr(oldmod, '__loader__'):\n        d['__loader__'] = oldmod.__loader__\n    if hasattr(oldmod, '__path__'):\n        d['__path__'] = [_py_abspath(p) for p in oldmod.__path__]\n    if hasattr(oldmod, '__package__'):\n        d['__package__'] = oldmod.__package__\n    if '__doc__' not in exportdefs and getattr(oldmod, '__doc__', None):\n        d['__doc__'] = oldmod.__doc__\n    d.update(attr)\n    if hasattr(oldmod, \"__dict__\"):\n        oldmod.__dict__.update(d)\n    mod = ApiModule(pkgname, exportdefs, implprefix=pkgname, attr=d)\n    sys.modules[pkgname] = mod\n    # eagerload in bypthon to avoid their monkeypatching breaking packages\n    if 'bpython' in sys.modules or eager:\n        for module in list(sys.modules.values()):\n            if isinstance(module, ApiModule):\n                module.__dict__"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef importobj(modpath, attrname):\n    module = __import__(modpath, None, None, ['__doc__'])\n    if not attrname:\n        return module\n\n    retval = module\n    names = attrname.split(\".\")\n    for x in names:\n        retval = getattr(retval, x)\n    return retval", "response": "imports a module then resolves the attrname on it"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _request(self, http_method, relative_url='', **kwargs):\n        # It could be possible to call api.resource.get('/index')\n        # but it would be non-intuitive that the path would resolve\n        # to root of domain\n        relative_url = self._remove_leading_slash(relative_url)\n\n        # Add default kwargs with possible custom kwargs returned by\n        # before_request\n        new_kwargs = self.default_kwargs().copy()\n        custom_kwargs = self.before_request(\n            http_method,\n            relative_url,\n            kwargs.copy()\n        )\n        new_kwargs.update(custom_kwargs)\n\n        response = requests.request(\n            http_method,\n            self._join_url(relative_url),\n            **new_kwargs\n        )\n\n        return self.after_request(response)", "response": "Does actual HTTP request using requests library."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _new_url(self, relative_url):\n\n        return Url(\n            urljoin(self._base_url, relative_url),\n            **self._default_kwargs\n        )", "response": "Create new Url which points to new url."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_permissions(self, role):\n        target_role = AuthGroup.objects(role=role, creator=self.client).first()\n        if not target_role:\n            return '[]'\n        targets = AuthPermission.objects(groups=target_role, creator=self.client).only('name')\n        return json.loads(targets.to_json())", "response": "gets permissions of role"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_user_permissions(self, user):\n        memberShipRecords = AuthMembership.objects(creator=self.client, user=user).only('groups')\n        results = []\n        for each in memberShipRecords:\n            for group in each.groups:\n                targetPermissionRecords = AuthPermission.objects(creator=self.client,\n                                            groups=group).only('name')\n\n                for each_permission in targetPermissionRecords:\n                    results.append({'name':each_permission.name})\n        return results", "response": "get permissions of a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user_roles(self, user):\n        memberShipRecords = AuthMembership.objects(creator=self.client, user=user).only('groups')\n        results = []\n        for each in memberShipRecords:\n            for group in each.groups:\n                results.append({'role':group.role})\n        return results", "response": "get permissions of a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_role_members(self, role):\n        targetRoleDb = AuthGroup.objects(creator=self.client, role=role)\n        members = AuthMembership.objects(groups__in=targetRoleDb).only('user')\n        return json.loads(members.to_json())", "response": "get permissions of a user"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_role(self, role):\n        role = AuthGroup.objects(role=role, creator=self.client).first()\n        return role", "response": "Returns a role object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_role(self, role, description=None):\n        new_group = AuthGroup(role=role, creator=self.client)\n        try:\n            new_group.save()\n            return True\n        except NotUniqueError:\n            return False", "response": "Adds a role to the group"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_membership(self, user, role):\n        targetGroup = AuthGroup.objects(role=role, creator=self.client).first()\n        if not targetGroup:\n            return False\n\n        target = AuthMembership.objects(user=user, creator=self.client).first()\n        if not target:\n            target = AuthMembership(user=user, creator=self.client)\n\n        if not role in [i.role for i in target.groups]:\n            target.groups.append(targetGroup)\n            target.save()\n        return True", "response": "add a user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef del_membership(self, user, role):\n        if not self.has_membership(user, role):\n            return True\n        targetRecord = AuthMembership.objects(creator=self.client, user=user).first()\n        if not targetRecord:\n            return True\n        for group in targetRecord.groups:\n            if group.role==role:\n                targetRecord.groups.remove(group)\n        targetRecord.save()\n        return True", "response": "delete a user from a group"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if user is member of a group", "response": "def has_membership(self, user, role):\n        \"\"\" checks if user is member of a group\"\"\"\n        targetRecord = AuthMembership.objects(creator=self.client, user=user).first()\n        if targetRecord:\n            return role in [i.role for i in targetRecord.groups]\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_permission(self, role, name):\n        if self.has_permission(role, name):\n            return True\n        targetGroup = AuthGroup.objects(role=role, creator=self.client).first()\n        if not targetGroup:\n            return False\n        # Create or update\n        permission = AuthPermission.objects(name=name).update(\n                add_to_set__groups=[targetGroup], creator=self.client, upsert=True\n        )\n        return True", "response": "authorize a group for something"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef del_permission(self, role, name):\n        if not self.has_permission(role, name):\n            return True\n        targetGroup = AuthGroup.objects(role=role, creator=self.client).first()\n        target = AuthPermission.objects(groups=targetGroup, name=name, creator=self.client).first()\n        if not target:\n            return True\n        target.delete()\n        return True", "response": "revoke authorization of a group"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef user_has_permission(self, user, name):\n        targetRecord = AuthMembership.objects(creator=self.client, user=user).first()\n        if not targetRecord:\n            return False\n        for group in targetRecord.groups:\n            if self.has_permission(group.role, name):\n                return True\n        return False", "response": "verify user has permission"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bump_version(version, bump='patch'):\n    try:\n        parts = map(int, version.split('.'))\n    except ValueError:\n        fail('Current version is not numeric')\n\n    if bump == 'patch':\n        parts[2] += 1\n    elif bump == 'minor':\n        parts[1] += 1\n        parts[2] = 0\n    elif bump == 'major':\n        parts[0] +=1\n        parts[1] = 0\n        parts[2] = 0\n\n    return '.'.join(map(str, parts))", "response": "Bump the current version of the current language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsignaling decorator to allow use of callback functions as class decorators.", "response": "def handler(event):\n    \"\"\"Signal decorator to allow use of callback functions as class decorators.\"\"\"\n    def decorator(fn):\n        def apply(cls):\n            event.connect(fn, sender=cls)\n            return cls\n\n        fn.apply = apply\n        return fn\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndump all valid jsons This is the latest after hook", "response": "def stringify(req, resp):\n    \"\"\"\n    dumps all valid jsons\n    This is the latest after hook\n    \"\"\"\n    if isinstance(resp.body, dict):\n        try:\n            resp.body = json.dumps(resp.body)\n        except(nameError):\n            resp.status = falcon.HTTP_500"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_response(self, req, resp, resource):\n        if isinstance(resp.body, dict):\n            try:\n                resp.body = json.dumps(resp.body)\n            except(nameError):\n                resp.status = falcon.HTTP_500", "response": "Post - processing of the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the given command.", "response": "def run(command=None, *arguments):\n    \"\"\"\n    Run the given command.\n\n    Parameters:\n    :param command: A string describing a command.\n    :param arguments: A list of strings describing arguments to the command.\n    \"\"\"\n\n    if command is None:\n        sys.exit('django-shortcuts: No argument was supplied, please specify one.')\n\n    if command in ALIASES:\n        command = ALIASES[command]\n\n    if command == 'startproject':\n        return call('django-admin.py startproject %s' % ' '.join(arguments), shell=True)\n\n    script_path = os.getcwd()\n    while not os.path.exists(os.path.join(script_path, 'manage.py')):\n        base_dir = os.path.dirname(script_path)\n        if base_dir != script_path:\n            script_path = base_dir\n        else:\n            sys.exit('django-shortcuts: No \\'manage.py\\' script found in this directory or its parents.')\n\n    return call('%(python)s %(script_path)s %(command)s %(arguments)s' % {\n        'python': sys.executable,\n        'script_path': os.path.join(script_path, 'manage.py'),\n        'command': command or '',\n        'arguments': ' '.join(arguments)\n    }, shell=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef instantiate(self, scope, args, interp):\n        param_instances = []\n\n        BYREF = \"byref\"\n\n        # TODO are default values for function parameters allowed in 010?\n        for param_name, param_cls in self._params:\n            # we don't instantiate a copy of byref params\n            if getattr(param_cls, \"byref\", False):\n                param_instances.append(BYREF)\n            else:\n                field = param_cls()\n                field._pfp__name = param_name\n                param_instances.append(field)\n\n        if len(args) != len(param_instances):\n            raise errors.InvalidArguments(\n                self._coords,\n                [x.__class__.__name__ for x in args],\n                [x.__class__.__name__ for x in param_instances]\n            )\n\n        # TODO type checking on provided types\n\n        for x in six.moves.range(len(args)):\n            param = param_instances[x]\n             \n            # arrays are simply passed through into the function. We shouldn't\n            # have to worry about frozenness/unfrozenness at this point\n            if param is BYREF or isinstance(param, pfp.fields.Array):\n                param = args[x]\n                param_instances[x] = param\n                scope.add_local(self._params[x][0], param)\n            else:\n                param._pfp__set_value(args[x])\n                scope.add_local(param._pfp__name, param)\n            param._pfp__interp = interp\n\n        return ParamList(param_instances)", "response": "Create a ParamList instance for actual interpretation of the parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_experiments(folders):\n    '''load_experiments\n    a wrapper for load_experiment to read multiple experiments\n    :param experiment_folders: a list of experiment folders to load, full paths\n    '''\n    experiments = []\n    if isinstance(folders,str):\n        folders = [experiment_folders]\n    for folder in folders:\n        exp = load_experiment(folder)\n        experiments.append(exp)\n    return experiments", "response": "load_experiments\n    a wrapper for load_experiment to read multiple experiments\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_experiment(folder, return_path=False):\n    '''load_experiment:\n    reads in the config.json for a folder, returns None if not found.\n    :param folder: full path to experiment folder\n    :param return_path: if True, don't load the config.json, but return it\n    '''\n    fullpath = os.path.abspath(folder)\n    config = \"%s/config.json\" %(fullpath)\n    if not os.path.exists(config):\n        bot.error(\"config.json could not be found in %s\" %(folder))\n        config = None\n    if return_path is False and config is not None:\n        config = read_json(config)\n    return config", "response": "load_experiment reads in the config. json for a folder returns None if not found."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_selection(available, selection, base='/scif/apps'):\n    '''we compare the basename (the exp_id) of the selection and available, \n       regardless of parent directories'''\n\n    if isinstance(selection, str):\n        selection = selection.split(',')\n\n    available = [os.path.basename(x) for x in available]\n    selection = [os.path.basename(x) for x in selection]\n    finalset = [x for x in selection if x in available]\n    if len(finalset) == 0:\n        bot.warning(\"No user experiments selected, providing all %s\" %(len(available)))\n        finalset = available\n    return [\"%s/%s\" %(base,x) for x in finalset]", "response": "we compare the basename of the exp_id of the selection and available and \n       regardless of parent directories"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(folder=None, cleanup=False):\n    '''validate\n    :param folder: full path to experiment folder with config.json. If path begins\n                   with https, we assume to be starting from a repository.\n    '''\n    from expfactory.validator import ExperimentValidator\n    cli = ExperimentValidator()\n    return cli.validate(folder, cleanup=cleanup)", "response": "validate\n    :param folder: full path to experiment folder with config.json. If path begins\n                   with https, we assume to be starting from a repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_library(lookup=True, key='exp_id'):\n    ''' return the raw library, without parsing'''\n    library = None\n    response = requests.get(EXPFACTORY_LIBRARY)\n    if response.status_code == 200:\n        library = response.json()\n        if lookup is True:\n            return make_lookup(library,key=key)\n    return library", "response": "return the raw library without parsing"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef int3(params, ctxt, scope, stream, coord, interp):\n    if interp._no_debug:\n        return\n\n    if interp._int3:\n        interp.debugger = PfpDbg(interp)\n        interp.debugger.cmdloop()", "response": "Int3 is a wrapper around the Int2 function in the interpreter."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initdb(self):\n        '''initdb will check for writability of the data folder, meaning\n           that it is bound to the local machine. If the folder isn't bound,\n           expfactory runs in demo mode (not saving data)\n        '''\n\n        self.database = EXPFACTORY_DATABASE\n        bot.info(\"DATABASE: %s\" %self.database)\n\n        # Supported database options\n        valid = ('sqlite', 'postgres', 'mysql', 'filesystem')\n        if not self.database.startswith(valid):\n            bot.warning('%s is not yet a supported type, saving to filesystem.' % self.database)\n            self.database = 'filesystem'\n\n        # Add functions specific to database type\n        self.init_db() # uses url in self.database\n\n        bot.log(\"Data base: %s\" % self.database)", "response": "initdb will check for writability of the data folder and meaning that it is bound to the local machine."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup(self):\n        ''' obtain database and filesystem preferences from defaults,\n            and compare with selection in container.\n        '''\n\n        self.selection = EXPFACTORY_EXPERIMENTS\n        self.ordered = len(EXPFACTORY_EXPERIMENTS) > 0\n        self.data_base = EXPFACTORY_DATA\n        self.study_id = EXPFACTORY_SUBID\n        self.base = EXPFACTORY_BASE\n        self.randomize = EXPFACTORY_RANDOMIZE\n        self.headless = EXPFACTORY_HEADLESS\n\n        # Generate variables, if they exist\n        self.vars = generate_runtime_vars() or None\n\n        available = get_experiments(\"%s\" % self.base)\n        self.experiments = get_selection(available, self.selection)\n        self.logger.debug(self.experiments)\n        self.lookup = make_lookup(self.experiments)\n        final = \"\\n\".join(list(self.lookup.keys()))       \n\n        bot.log(\"Headless mode: %s\" % self.headless)\n        bot.log(\"User has selected: %s\" % self.selection)\n        bot.log(\"Experiments Available: %s\" %\"\\n\".join(available))\n        bot.log(\"Randomize: %s\" % self.randomize)\n        bot.log(\"Final Set \\n%s\" % final)", "response": "setup the internal variables and database preferences"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_next(self, session):\n        '''return the name of the next experiment, depending on the user's\n           choice to randomize. We don't remove any experiments here, that is\n           done on finish, in the case the user doesn't submit data (and\n           thus finish). A return of None means the user has completed the\n           battery of experiments.\n        '''\n        next = None\n        experiments = session.get('experiments', [])\n        if len(experiments) > 0:    \n            if app.randomize is True:\n                next = random.choice(range(0,len(experiments)))\n                next = experiments[next]\n            else:\n                next = experiments[0]\n        return next", "response": "return the name of the next experiment depending on the user s is\n           choice to randomize."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove an experiment from the list after completion.", "response": "def finish_experiment(self, session, exp_id):\n        '''remove an experiment from the list after completion.\n        '''\n        self.logger.debug('Finishing %s' %exp_id)\n        experiments = session.get('experiments', [])\n        experiments = [x for x in experiments if x != exp_id]\n        session['experiments'] = experiments\n        return experiments"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_subdirectories(basepath):\n    '''\n    Return directories (and sub) starting from a base\n    '''\n    directories = []\n    for root, dirnames, filenames in os.walk(basepath):\n        new_directories = [d for d in dirnames if d not in directories]\n        directories = directories + new_directories\n    return directories", "response": "Return directories and sub directories starting from a basepath"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding all directories in a user s directory tree.", "response": "def find_directories(root,fullpath=True):\n    '''\n    Return directories at one level specified by user\n    (not recursive)\n    '''\n    directories = []\n    for item in os.listdir(root):\n        # Don't include hidden directories\n        if not re.match(\"^[.]\",item):\n            if os.path.isdir(os.path.join(root, item)):\n                if fullpath:\n                    directories.append(os.path.abspath(os.path.join(root, item)))\n                else:\n                    directories.append(item)\n    return directories"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncopy a directory recursively.", "response": "def copy_directory(src, dest, force=False):\n    ''' Copy an entire directory recursively\n    '''\n    if os.path.exists(dest) and force is True:\n        shutil.rmtree(dest)\n\n    try:\n        shutil.copytree(src, dest)\n    except OSError as e:\n        # If the error was caused because the source wasn't a directory\n        if e.errno == errno.ENOTDIR:\n            shutil.copy(src, dest)\n        else:\n            bot.error('Directory not copied. Error: %s' % e)\n            sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clone(url, tmpdir=None):\n    '''clone a repository from Github'''\n    if tmpdir is None:\n        tmpdir = tempfile.mkdtemp()\n    name = os.path.basename(url).replace('.git', '')\n    dest = '%s/%s' %(tmpdir,name)\n    return_code = os.system('git clone %s %s' %(url,dest))\n    if return_code == 0:\n        return dest\n    bot.error('Error cloning repo.')\n    sys.exit(return_code)", "response": "clone a repository from Github"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_command(cmd):\n    '''run_command uses subprocess to send a command to the terminal.\n    :param cmd: the command to send, should be a list for subprocess\n    '''\n    output = Popen(cmd,stderr=STDOUT,stdout=PIPE)\n    t = output.communicate()[0],output.returncode\n    output = {'message':t[0],\n              'return_code':t[1]}\n\n    return output", "response": "run_command uses subprocess to send a command to the terminal."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_template(name, base=None):\n    '''read in and return a template file\n    '''\n    # If the file doesn't exist, assume relative to base\n    template_file = name\n    if not os.path.exists(template_file):\n        if base is None:\n            base = get_templatedir()\n        template_file = \"%s/%s\" %(base, name)\n\n    # Then try again, if it still doesn't exist, bad name\n    if os.path.exists(template_file):\n        with open(template_file,\"r\") as filey:\n            template = \"\".join(filey.readlines())\n        return template\n    bot.error(\"%s does not exist.\" %template_file)", "response": "read in and return a template file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a substitution for a template_tag in a template", "response": "def sub_template(template,template_tag,substitution):\n    '''make a substitution for a template_tag in a template\n    '''\n    template = template.replace(template_tag,substitution)\n    return template"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_post_fields(request):\n    '''parse through a request, and return fields from post in a dictionary\n    '''\n    fields = dict()\n    for field,value in request.form.items():\n        fields[field] = value\n    return fields", "response": "parse through a request and return fields from post in a dictionary\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(\n        data            = None,\n        template        = None,\n        data_file       = None,\n        template_file   = None,\n        interp          = None,\n        debug           = False,\n        predefines      = True,\n        int3            = True,\n        keep_successful = False,\n        printf          = True,\n    ):\n    \"\"\"Parse the data stream using the supplied template. The data stream\n    WILL NOT be automatically closed.\n\n    :data: Input data, can be either a string or a file-like object (StringIO, file, etc)\n    :template: template contents (str)\n    :data_file: PATH to the data to be used as the input stream\n    :template_file: template file path\n    :interp: the interpretor to be used (a default one will be created if ``None``)\n    :debug: if debug information should be printed while interpreting the template (false)\n    :predefines: if built-in type information should be inserted (true)\n    :int3: if debugger breaks are allowed while interpreting the template (true)\n    :keep_successful: return any succesfully parsed data instead of raising an error. If an error occurred and ``keep_successful`` is True, then ``_pfp__error`` will be contain the exception object\n    :printf: if ``False``, all calls to ``Printf`` (:any:`pfp.native.compat_interface.Printf`) will be noops. (default=``True``)\n    :returns: pfp DOM\n    \"\"\"\n    if data is None and data_file is None:\n        raise Exception(\"No input data was specified\")\n    \n    if data is not None and data_file is not None:\n        raise Exception(\"Only one input data may be specified\")\n\n    if isinstance(data, six.string_types):\n        data = six.StringIO(data)\n    \n    if data_file is not None:\n        data = open(os.path.expanduser(data_file), \"rb\")\n\n    if template is None and template_file is None:\n        raise Exception(\"No template specified!\")\n    \n    if template is not None and template_file is not None:\n        raise Exception(\"Only one template may be specified!\")\n    \n    orig_filename = \"string\"\n    if template_file is not None:\n        orig_filename = template_file\n        try:\n            with open(os.path.expanduser(template_file), \"r\") as f:\n                template = f.read()\n        except Exception as e:\n            raise Exception(\"Could not open template file '{}'\".format(template_file))\n\n    # the user may specify their own instance of PfpInterp to be\n    # used\n    if interp is None:\n        interp = pfp.interp.PfpInterp(\n            debug  = debug,\n            parser = PARSER,\n            int3   = int3,\n        )\n    \n    # so we can consume single bits at a time\n    data = BitwrappedStream(data)\n\n    dom = interp.parse(\n        data,\n        template,\n        predefines      = predefines,\n        orig_filename   = orig_filename,\n        keep_successful = keep_successful,\n        printf          = printf,\n    )\n\n    # close the data stream if a data_file was specified\n    if data_file is not None:\n        data.close()\n\n    return dom", "response": "Parse the data stream using the supplied template."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Checksum(params, ctxt, scope, stream, coord):\n    checksum_types = {\n        0: \"CHECKSUM_BYTE\", # Treats the file as a set of unsigned bytes\n        1: \"CHECKSUM_SHORT_LE\", # Treats the file as a set of unsigned little-endian shorts\n        2: \"CHECKSUM_SHORT_BE\", # Treats the file as a set of unsigned big-endian shorts\n        3: \"CHECKSUM_INT_LE\", # Treats the file as a set of unsigned little-endian ints\n        4: \"CHECKSUM_INT_BE\", # Treats the file as a set of unsigned big-endian ints\n        5: \"CHECKSUM_INT64_LE\", # Treats the file as a set of unsigned little-endian int64s\n        6: \"CHECKSUM_INT64_BE\", # Treats the file as a set of unsigned big-endian int64s\n        7: \"CHECKSUM_SUM8\", # Same as CHECKSUM_BYTE except result output as 8-bits\n        8: \"CHECKSUM_SUM16\", # Same as CHECKSUM_BYTE except result output as 16-bits\n        9: \"CHECKSUM_SUM32\", # Same as CHECKSUM_BYTE except result output as 32-bits\n        10: \"CHECKSUM_SUM64\", # Same as CHECKSUM_BYTE\n        11: \"CHECKSUM_CRC16\",\n        12: \"CHECKSUM_CRCCCITT\",\n        13: _crc32,\n        14: _checksum_Adler32\n    }\n\n    if len(params) < 1:\n        raise errors.InvalidArguments(coord, \"at least 1 argument\", \"{} args\".format(len(params)))\n    \n    alg = PYVAL(params[0])\n    if alg not in checksum_types:\n        raise errors.InvalidArguments(coord, \"checksum alg must be one of (0-14)\", \"{}\".format(alg))\n    \n    start = 0\n    if len(params) > 1:\n        start = PYVAL(params[1])\n    \n    size = 0\n    if len(params) > 2:\n        size = PYVAL(params[2])\n    \n    crc_poly = -1\n    if len(params) > 3:\n        crc_poly = PYVAL(params[3])\n    \n    crc_init = -1\n    if len(params) > 4:\n        crc_init = PYVAL(params[4])\n    \n    stream_pos = stream.tell()\n\n    if start + size == 0:\n        stream.seek(0, 0)\n        data = stream.read()\n    else:\n        stream.seek(start, 0)\n        data = stream.read(size)\n    \n    try:\n        return checksum_types[alg](data, crc_init, crc_poly)\n    \n    finally:\n        # yes, this does execute even though a return statement\n        # exists within the try\n        stream.seek(stream_pos, 0)", "response": "This function runs a simple checksum on a file and returns the result as an int64."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef FindFirst(params, ctxt, scope, stream, coord, interp):\n    global FIND_MATCHES_ITER\n    FIND_MATCHES_ITER = _find_helper(params, ctxt, scope, stream, coord, interp)\n\n    try:\n        first = six.next(FIND_MATCHES_ITER)\n        return first.start() + FIND_MATCHES_START_OFFSET\n    except StopIteration as e:\n        return -1", "response": "This function is identical to the FindAll function except that the return value is the position of the first occurrence of the target\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef FindNext(params, ctxt, scope, stream, coord):\n    if FIND_MATCHES_ITER is None:\n        raise errors.InvalidState()\n    \n    direction = 1\n    if len(params) > 0:\n        direction = PYVAL(params[0])\n    \n    if direction != 1:\n        # TODO maybe instead of storing the iterator in FIND_MATCHES_ITER,\n        # we should go ahead and find _all the matches in the file and store them\n        # in a list, keeping track of the idx of the current match.\n        #\n        # This would be highly inefficient on large files though.\n        raise NotImplementedError(\"Reverse searching is not yet implemented\")\n    \n    try:\n        next_match = six.next(FIND_MATCHES_ITER)\n        return next_match.start() + FIND_MATCHES_START_OFFSET\n    except StopIteration as e:\n        return -1", "response": "This function returns the position of the next occurrence of the target value specified with the FindFirst function."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_subid(self, token=None):\n    '''assumes a flat (file system) database, organized by experiment id, and\n       subject id, with data (json) organized by subject identifier\n    ''' \n\n    # Not headless auto-increments\n    if not token:\n        token = str(uuid.uuid4())\n\n    # Headless doesn't use any folder_id, just generated token folder\n    return \"%s/%s\" % (self.study_id, token)", "response": "generate a unique id for the current object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_users(self):\n    '''list users, each associated with a filesystem folder\n    ''' \n    folders = glob('%s/*' %(self.database))\n    folders.sort()\n    return [self.print_user(x) for x in folders]", "response": "list users each associated with a filesystem folder"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a filesystem database user", "response": "def print_user(self, user):\n    '''print a filesystem database user. A \"database\" folder that might end with\n       the participant status (e.g. _finished) is extracted to print in format\n \n       [folder]                        [identifier][studyid]\n       /scif/data/expfactory/xxxx-xxxx   xxxx-xxxx[studyid]\n       \n    ''' \n    status = \"active\"\n\n    if user.endswith('_finished'):\n        status = \"finished\"\n\n    elif user.endswith('_revoked'):\n        status = \"revoked\"\n\n    subid = os.path.basename(user)\n    for ext in ['_revoked','_finished']:\n        subid = subid.replace(ext, '')\n  \n    subid = '%s\\t%s[%s]' %(user, subid, status)\n    print(subid)\n    return subid"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a new user on the filesystem", "response": "def generate_user(self, subid=None):\n    '''generate a new user on the filesystem, still session based so we\n       create a new identifier. This function is called from the users new \n       entrypoint, and it assumes we want a user generated with a token.\n       since we don't have a database proper, we write the folder name to \n       the filesystem\n    '''\n    # Only generate token if subid being created\n    if subid is None:\n        token = str(uuid.uuid4())\n        subid = self.generate_subid(token=token)\n\n    if os.path.exists(self.data_base):    # /scif/data\n        data_base = \"%s/%s\" %(self.data_base, subid)\n        # expfactory/00001\n        if not os.path.exists(data_base):\n            mkdir_p(data_base)\n\n    return data_base"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinishing user and return the path to the finished file", "response": "def finish_user(self, subid, ext='finished'):\n    '''finish user will append \"finished\" (or other) to the data folder when\n       the user has completed (or been revoked from) the battery. \n       For headless, this means that the session is ended and the token \n       will not work again to rewrite the result. If the user needs to update\n       or redo an experiment, this can be done with a new session. Note that if\n       this function is called internally by the application at experiment\n       finish, the subid includes a study id (e.g., expfactory/xxxx-xxxx)\n       but if called by the user, it may not (e.g., xxxx-xxxx). We check\n       for this to ensure it works in both places.\n    '''\n    if os.path.exists(self.data_base):    # /scif/data\n\n        # Only relevant to filesystem save - the studyid is the top folder\n        if subid.startswith(self.study_id):\n            data_base = \"%s/%s\" %(self.data_base, subid)\n        else:\n            data_base = \"%s/%s/%s\" %(self.data_base,\n                                     self.study_id,\n                                     subid)\n\n        # The renamed file will be here\n        finished = \"%s_%s\" % (data_base, ext)\n\n        # Participant already finished\n        if os.path.exists(finished):\n            self.logger.warning('[%s] is already finished: %s' % (subid, data_base))\n\n        # Exists and can finish\n        elif os.path.exists(data_base):\n            os.rename(data_base, finished)\n\n        # Not finished, doesn't exist\n        else:\n            finished = None\n            self.logger.warning('%s does not exist, cannot finish. %s' % (data_base, subid))\n\n    return finished"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrestarts user will remove any \"finished\" or \"revoked\" extensions from the user folder to restart the session. This command always comes from the client users function, so we know subid does not start with the study identifer first", "response": "def restart_user(self, subid):\n    '''restart user will remove any \"finished\" or \"revoked\" extensions from \n    the user folder to restart the session. This command always comes from\n    the client users function, so we know subid does not start with the\n    study identifer first\n    '''        \n    if os.path.exists(self.data_base): # /scif/data/<study_id>\n        data_base = \"%s/%s\" %(self.data_base, subid)\n        for ext in ['revoked','finished']:\n            folder = \"%s_%s\" % (data_base, ext)\n            if os.path.exists(folder):\n                os.rename(folder, data_base)\n                self.logger.info('Restarting %s, folder is %s.' % (subid, data_base))\n\n        self.logger.warning('%s does not have revoked or finished folder, no changes necessary.' % (subid))\n        return data_base    \n\n    self.logger.warning('%s does not exist, cannot restart. %s' % (self.database, subid))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_token(self, token):\n    '''retrieve a subject based on a token. Valid means we return a participant\n       invalid means we return None\n    '''\n    # A token that is finished or revoked is not valid\n    subid = None\n    if not token.endswith(('finished','revoked')):\n        subid = self.generate_subid(token=token)\n        data_base = \"%s/%s\" %(self.data_base, subid)\n        if not os.path.exists(data_base):\n            subid = None\n    return subid", "response": "retrieve a subject based on a token. Valid means we return a participant\n       invalid means we return None\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefreshing or generate a new token for a user.", "response": "def refresh_token(self, subid):\n    '''refresh or generate a new token for a user. If the user is finished,\n       this will also make the folder available again for using.'''\n    if os.path.exists(self.data_base):    # /scif/data\n        data_base = \"%s/%s\" %(self.data_base, subid)\n        if os.path.exists(data_base):\n            refreshed = \"%s/%s\" %(self.database, str(uuid.uuid4()))\n            os.rename(data_base, refreshed)\n            return refreshed\n        self.logger.warning('%s does not exist, cannot rename %s' % (data_base, subid))\n    else:\n        self.logger.warning('%s does not exist, cannot rename %s' % (self.database, subid))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_data(self, session, exp_id, content):\n    '''save data will obtain the current subid from the session, and save it\n       depending on the database type. Currently we just support flat files'''\n\n    subid = session.get('subid')\n\n    # We only attempt save if there is a subject id, set at start\n    data_file = None\n    if subid is not None:\n\n        data_base = \"%s/%s\" %(self.data_base, subid)\n\n        # If not running in headless, ensure path exists\n        if not self.headless and not os.path.exists(data_base):\n            mkdir_p(data_base)\n\n        # Conditions for saving:\n        do_save = False\n\n        # If headless with token pre-generated OR not headless\n        if self.headless and os.path.exists(data_base) or not self.headless:\n            do_save = True\n        if data_base.endswith(('revoked','finished')):\n            do_save = False  \n\n        # If headless with token pre-generated OR not headless\n        if do_save is True:\n            data_file = \"%s/%s-results.json\" %(data_base, exp_id)\n            if os.path.exists(data_file):\n                self.logger.warning('%s exists, and is being overwritten.' %data_file)\n            write_json(content, data_file)\n\n    return data_file", "response": "save data will obtain the current subid from the session and save it as json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing as a decorator to add the decorated function to the pfp interpreter so that it can be used from within scripts. :param str name: The name of the function as it will be exposed in template scripts. :param pfp.fields.Field ret: The return type of the function (a class) :param pfp.interp.PfpInterp interp: The specific interpreter to add the function to :param bool send_interp: If the current interpreter should be passed to the function. Examples: The example below defines a ``Sum`` function that will return the sum of all parameters passed to the function: :: from pfp.fields import PYVAL @native(name=\"Sum\", ret=pfp.fields.Int64) def sum_numbers(params, ctxt, scope, stream, coord): res = 0 for param in params: res += PYVAL(param) return res The code below is the code for the :any:`Int3 <pfp.native.dbg.int3>` function. Notice that it requires that the interpreter be sent as a parameter: :: @native(name=\"Int3\", ret=pfp.fields.Void, send_interp=True) def int3(params, ctxt, scope, stream, coord, interp): if interp._no_debug: return if interp._int3: interp.debugger = PfpDbg(interp) interp.debugger.cmdloop()", "response": "def native(name, ret, interp=None, send_interp=False):\n    \"\"\"Used as a decorator to add the decorated function to the\n    pfp interpreter so that it can be used from within scripts.\n\n    :param str name: The name of the function as it will be exposed in template scripts.\n    :param pfp.fields.Field ret: The return type of the function (a class)\n    :param pfp.interp.PfpInterp interp: The specific interpreter to add the function to\n    :param bool send_interp: If the current interpreter should be passed to the function.\n\n    Examples:\n\n        The example below defines a ``Sum`` function that will return the sum of\n        all parameters passed to the function: ::\n\n            from pfp.fields import PYVAL\n\n            @native(name=\"Sum\", ret=pfp.fields.Int64)\n            def sum_numbers(params, ctxt, scope, stream, coord):\n                res = 0\n                for param in params:\n                    res += PYVAL(param)\n                return res\n        \n        The code below is the code for the :any:`Int3 <pfp.native.dbg.int3>` function. Notice that it\n        requires that the interpreter be sent as a parameter: ::\n\n            @native(name=\"Int3\", ret=pfp.fields.Void, send_interp=True)\n            def int3(params, ctxt, scope, stream, coord, interp):\n                if interp._no_debug:\n                    return\n\n                if interp._int3:\n                    interp.debugger = PfpDbg(interp)\n                    interp.debugger.cmdloop()\n    \"\"\"\n    def native_decorator(func):\n        @functools.wraps(func)\n        def native_wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n\n        pfp.interp.PfpInterp.add_native(name, func, ret, interp=interp, send_interp=send_interp)\n        return native_wrapper\n    return native_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_peek(self, args):\n        s = self._interp._stream\n        # make a copy of it\n        pos = s.tell()\n        saved_bits = collections.deque(s._bits)\n        data = s.read(0x10)\n        s.seek(pos, 0)\n        s._bits = saved_bits\n\n        parts = [\"{:02x}\".format(ord(data[x:x+1])) for x in range(len(data))]\n        if len(parts) != 0x10:\n            parts += [\"  \"] * (0x10 - len(parts))\n        hex_line = \" \".join(parts)\n\n        res = utils.binary(\"\")\n        for x in range(len(data)):\n            char = data[x:x+1]\n            val = ord(char)\n            if 0x20 <= val <= 0x7e:\n                res += char\n            else:\n                res += utils.binary(\".\")\n        \n        if len(res) < 0x10:\n            res += utils.binary(\" \" * (0x10 - len(res)))\n\n        res = \"{} {}\".format(hex_line, utils.string(res))\n        if len(saved_bits) > 0:\n            reverse_bits = reversed(list(saved_bits))\n            print(\"bits: {}\".format(\" \".join(str(x) for x in reverse_bits)))\n        print(res)", "response": "Peek at the next 16 hex bytes in the input stream::\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_next(self, args):\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "response": "Step over the next statement in the log"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_step(self, args):\n        self._do_print_from_last_cmd = True\n        self._interp.step_into()\n        return True", "response": "Step into the next statement"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nevaluate the user - supplied statement.", "response": "def do_eval(self, args):\n        \"\"\"Eval the user-supplied statement. Note that you can do anything with\n        this command that you can do in a template.\n\n        The resulting value of your statement will be displayed.\n        \"\"\"\n        try:\n            res = self._interp.eval(args)\n            if res is not None:\n                if hasattr(res, \"_pfp__show\"):\n                    print(res._pfp__show())\n                else:\n                    print(repr(res))\n        except errors.UnresolvedID as e:\n            print(\"ERROR: \" + e.message)\n        except Exception as e:\n            raise\n            print(\"ERROR: \" + e.message)\n            \n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_show(self, args):\n        args = args.strip()\n\n        to_show = self._interp._root\n        if args != \"\":\n            try:\n                to_show = self._interp.eval(args)\n            except Exception as e:\n                print(\"ERROR: \" + e.message)\n                return False\n\n        if hasattr(to_show, \"_pfp__show\"):\n            print(to_show._pfp__show())\n        else:\n            print(repr(to_show))", "response": "Show the current structure of __root or show the result of the expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, url):\n        ''' takes in a Github repository for validation of preview and \n            runtime (and possibly tests passing?\n        '''\n\n        # Preview must provide the live URL of the repository\n        if not url.startswith('http') or not 'github' in url:\n            bot.error('Test of preview must be given a Github repostitory.')\n            return False\n\n        if not self._validate_preview(url):\n            return False\n\n        return True", "response": "Validate the URL of a Github repository and return True if validation passes False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mask_dict_password(dictionary, secret='***'):\n    d = dictionary.copy()\n    for k in d:\n        if 'password' in k:\n            d[k] = secret\n    return d", "response": "Replace passwords with a secret in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save():\n    '''save is a view to save data. We might want to adjust this to allow for\n       updating saved data, but given single file is just one post for now\n    '''\n    if request.method == 'POST':\n        exp_id = session.get('exp_id')\n        app.logger.debug('Saving data for %s' %exp_id)\n\n        fields = get_post_fields(request)\n        result_file = app.save_data(session=session, content=fields, exp_id=exp_id)\n\n        experiments = app.finish_experiment(session, exp_id)\n        app.logger.info('Finished %s, %s remaining.' % (exp_id, len(experiments)))\n\n        # Note, this doesn't seem to be enough to trigger ajax success\n        return json.dumps({'success':True}), 200, {'ContentType':'application/json'} \n    return json.dumps({'success':False}), 403, {'ContentType':'application/json'}", "response": "save is a view to save data. We need to adjust this to allow for\n       updating saved data but we need to adjust this to allow for\n       updating saved data but we need to adjust this to allow for\n       updating saved data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_data(self,session, exp_id, content):\n    '''save data will obtain the current subid from the session, and save it\n       depending on the database type.'''\n    from expfactory.database.models import (\n        Participant,\n        Result\n    )\n    subid = session.get('subid') \n    bot.info('Saving data for subid %s' % subid)    \n\n    # We only attempt save if there is a subject id, set at start\n    if subid is not None:\n        p = Participant.query.filter(Participant.id == subid).first() # better query here\n\n        # Preference is to save data under 'data', otherwise do all of it\n        if \"data\" in content:\n            content = content['data']\n\n        if isinstance(content,dict):\n            content = json.dumps(content)\n\n        result = Result(data=content,\n                        exp_id=exp_id,\n                        participant_id=p.id) # check if changes from str/int\n        self.session.add(result)\n        p.results.append(result)\n        self.session.commit()\n\n        bot.info(\"Participant: %s\" %p)\n        bot.info(\"Result: %s\" %result)", "response": "save data for the current subject"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the database, with the default database path or custom of the format sqlite:////scif/data/expfactory.db", "response": "def init_db(self):\n    '''initialize the database, with the default database path or custom of\n       the format sqlite:////scif/data/expfactory.db\n\n    '''\n\n    # Database Setup, use default if uri not provided\n    if self.database == 'sqlite':\n        db_path = os.path.join(EXPFACTORY_DATA, '%s.db' % EXPFACTORY_SUBID)\n        self.database = 'sqlite:///%s' % db_path\n\n    bot.info(\"Database located at %s\" % self.database)\n    self.engine = create_engine(self.database, convert_unicode=True)\n    self.session = scoped_session(sessionmaker(autocommit=False,\n                                               autoflush=False,\n                                               bind=self.engine))\n    \n    Base.query = self.session.query_property()\n\n    # import all modules here that might define models so that\n    # they will be registered properly on the metadata.  Otherwise\n    # you will have to import them first before calling init_db()\n    import expfactory.database.models\n    Base.metadata.create_all(bind=self.engine)\n    self.Base = Base"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reserve_bits(self, num_bits, stream):\n        padded = self.interp.get_bitfield_padded()\n        num_bits = PYVAL(num_bits)\n\n        if padded:\n            num_bits = PYVAL(num_bits)\n            if num_bits + self.reserved_bits > self.max_bits:\n                return False\n\n        # if unpadded, always allow it\n        if not padded:\n            if self._cls_bits is None:\n                self._cls_bits = []\n\n            # reserve bits will only be called just prior to reading the bits,\n            # so check to see if we have enough bits in self._cls_bits, else\n            # read what's missing\n            diff = len(self._cls_bits) - num_bits\n            if diff < 0:\n                self._cls_bits += stream.read_bits(-diff)\n\n        self.reserved_bits += num_bits\n        return True", "response": "Used to reserve num_bits amount of bits in the track\n           ."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread num_bits bits from the given stream.", "response": "def read_bits(self, stream, num_bits, padded, left_right, endian):\n        \"\"\"Return ``num_bits`` bits, taking into account endianness and \n        left-right bit directions\n        \"\"\"\n        if self._cls_bits is None and padded:\n            raw_bits = stream.read_bits(self.cls.width*8)\n            self._cls_bits = self._endian_transform(raw_bits, endian)\n\n        if self._cls_bits is not None:\n            if num_bits > len(self._cls_bits):\n                raise errors.PfpError(\"BitfieldRW reached invalid state\")\n\n            if left_right:\n                res = self._cls_bits[:num_bits]\n                self._cls_bits = self._cls_bits[num_bits:]\n            else:\n                res = self._cls_bits[-num_bits:]\n                self._cls_bits = self._cls_bits[:-num_bits]\n\n            return res\n\n        else:\n            return stream.read_bits(num_bits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting the bits to the stream.", "response": "def write_bits(self, stream, raw_bits, padded, left_right, endian):\n        \"\"\"Write the bits. Once the size of the written bits is equal\n        to the number of the reserved bits, flush it to the stream\n        \"\"\"\n        if padded:\n            if left_right:\n                self._write_bits += raw_bits\n            else:\n                self._write_bits = raw_bits + self._write_bits\n\n            if len(self._write_bits) == self.reserved_bits:\n                bits = self._endian_transform(self._write_bits, endian)\n\n                # if it's padded, and all of the bits in the field weren't used,\n                # we need to flush out the unused bits\n                # TODO should we save the value of the unused bits so the data that\n                # is written out matches exactly what was read?\n                if self.reserved_bits < self.cls.width * 8:\n                    filler = [0] * ((self.cls.width * 8) - self.reserved_bits)\n                    if left_right:\n                        bits += filler\n                    else:\n                        bits = filler + bits\n\n                stream.write_bits(bits)\n                self._write_bits = []\n\n        else:\n            # if an unpadded field ended up using the same BitfieldRW and\n            # as a previous padded field, there will be unwritten bits left in\n            # self._write_bits. These need to be flushed out as well\n            if len(self._write_bits) > 0:\n                stream.write_bits(self._write_bits)\n                self._write_bits = []\n\n            stream.write_bits(raw_bits)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _pfp__snapshot(self, recurse=True):\n        if hasattr(self, \"_pfp__value\"):\n            self._pfp__snapshot_value = self._pfp__value", "response": "Save off the current value of the field\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the metadata once the entire struct has been declared.", "response": "def _pfp__process_metadata(self):\n        \"\"\"Process the metadata once the entire struct has been\n        declared.\n        \"\"\"\n        if self._pfp__metadata_processor is None:\n            return\n\n        metadata_info = self._pfp__metadata_processor()\n        if isinstance(metadata_info, list):\n            for metadata in metadata_info:\n                if metadata[\"type\"] == \"watch\":\n                    self._pfp__set_watch(\n                        metadata[\"watch_fields\"],\n                        metadata[\"update_func\"],\n                        *metadata[\"func_call_info\"]\n                    )\n\n                elif metadata[\"type\"] == \"packed\":\n                    del metadata[\"type\"]\n                    self._pfp__set_packer(**metadata)\n                    if self._pfp__can_unpack():\n                        self._pfp__unpack_data(self.raw_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _pfp__watch(self, watcher):\n        if self._pfp__parent is not None and isinstance(self._pfp__parent, Union):\n            self._pfp__parent._pfp__watch(watcher)\n        else:\n            self._pfp__watchers.append(watcher)", "response": "Add the watcher to the list of fields that are watching this field\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _pfp__set_watch(self, watch_fields, update_func, *func_call_info):\n        self._pfp__watch_fields = watch_fields\n\n        for watch_field in watch_fields:\n            watch_field._pfp__watch(self)\n        self._pfp__update_func = update_func\n        self._pfp__update_func_call_info = func_call_info", "response": "Subscribe to update events on each field in watch_fields using update_func to update self s value when watch_field changes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pfp__set_packer(self, pack_type, packer=None, pack=None, unpack=None, func_call_info=None):\n        self._pfp__pack_type = pack_type\n        self._pfp__unpack = unpack\n        self._pfp__pack = pack\n        self._pfp__packer = packer\n        self._pfp__pack_func_call_info = func_call_info", "response": "Set the packer and unpack functions for this field as\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pfp__pack_data(self):\n        if self._pfp__pack_type is None:\n            return\n\n        tmp_stream = six.BytesIO()\n        self._._pfp__build(bitwrap.BitwrappedStream(tmp_stream))\n        raw_data = tmp_stream.getvalue()\n\n        unpack_func = self._pfp__packer\n        unpack_args = []\n        if self._pfp__packer is not None:\n            unpack_func = self._pfp__packer\n            unpack_args = [true(), raw_data]\n        elif self._pfp__pack is not None:\n            unpack_func = self._pfp__pack\n            unpack_args = [raw_data]\n\n        # does not need to be converted to a char array\n        if not isinstance(unpack_func, functions.NativeFunction):\n            io_stream = bitwrap.BitwrappedStream(six.BytesIO(raw_data))\n            unpack_args[-1] = Array(len(raw_data), Char, io_stream)\n\n        res = unpack_func.call(unpack_args, *self._pfp__pack_func_call_info, no_cast=True)\n        if isinstance(res, Array):\n            res = res._pfp__build()\n\n        io_stream = six.BytesIO(res)\n        tmp_stream = bitwrap.BitwrappedStream(io_stream)\n\n        self._pfp__no_unpack = True\n        self._pfp__parse(tmp_stream)\n        self._pfp__no_unpack = False", "response": "Pack the nested field containing the data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pfp__unpack_data(self, raw_data):\n        if self._pfp__pack_type is None:\n            return\n        if self._pfp__no_unpack:\n            return\n\n        unpack_func = self._pfp__packer\n        unpack_args = []\n        if self._pfp__packer is not None:\n            unpack_func = self._pfp__packer\n            unpack_args = [false(), raw_data]\n\n        elif self._pfp__unpack is not None:\n            unpack_func = self._pfp__unpack\n            unpack_args = [raw_data]\n\n        # does not need to be converted to a char array\n        if not isinstance(unpack_func, functions.NativeFunction):\n            io_stream = bitwrap.BitwrappedStream(six.BytesIO(raw_data))\n            unpack_args[-1] = Array(len(raw_data), Char, io_stream)\n\n        res = unpack_func.call(unpack_args, *self._pfp__pack_func_call_info, no_cast=True)\n        if isinstance(res, Array):\n            res = res._pfp__build()\n\n        io_stream = six.BytesIO(res)\n        tmp_stream = bitwrap.BitwrappedStream(io_stream)\n\n        tmp_stream.padded = self._pfp__interp.get_bitfield_padded()\n\n        self._ = self._pfp__parsed_packed = self._pfp__pack_type(tmp_stream)\n\n        self._._pfp__watch(self)", "response": "Parses the raw data into a set of attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the watched field that was updated", "response": "def _pfp__handle_updated(self, watched_field):\n        \"\"\"Handle the watched field that was updated\n        \"\"\"\n        self._pfp__no_notify = True\n\n        # nested data has been changed, so rebuild the\n        # nested data to update the field\n        # TODO a global setting to determine this behavior?\n        # could slow things down a bit for large nested structures\n\n        # notice the use of _is_ here - 'is' != '=='. '==' uses\n        # the __eq__ operator, while is compares id(object) results\n        if watched_field is self._:\n            self._pfp__pack_data()\n        elif self._pfp__update_func is not None:\n            self._pfp__update_func.call(\n                [self] + self._pfp__watch_fields,\n                *self._pfp__update_func_call_info\n            )\n\n        self._pfp__no_notify = False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _pfp__width(self):\n        raw_output = six.BytesIO()\n        output = bitwrap.BitwrappedStream(raw_output)\n        self._pfp__build(output)\n        output.flush()\n        return len(raw_output.getvalue())", "response": "Return the width of the field"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _pfp__set_value(self, new_val):\n        if self._pfp__frozen:\n            raise errors.UnmodifiableConst()\n        self._pfp__value = self._pfp__get_root_value(new_val)\n        self._pfp__notify_parent()", "response": "Set the new value if type checking is passes potentially\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _pfp__snapshot(self, recurse=True):\n        super(Struct, self)._pfp__snapshot(recurse=recurse)\n\n        if recurse:\n            for child in self._pfp__children:\n                child._pfp__snapshot(recurse=recurse)", "response": "Save off the current value of the field\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrestore the snapshotted value without triggering any events.", "response": "def _pfp__restore_snapshot(self, recurse=True):\n        \"\"\"Restore the snapshotted value without triggering any events\n        \"\"\"\n        super(Struct, self)._pfp__restore_snapshot(recurse=recurse)\n\n        if recurse:\n            for child in self._pfp__children:\n                child._pfp__restore_snapshot(recurse=recurse)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the struct. Value should be an array of fields one each for each struct member.", "response": "def _pfp__set_value(self, value):\n        \"\"\"Initialize the struct. Value should be an array of\n        fields, one each for each struct member.\n\n        :value: An array of fields to initialize the struct with\n        :returns: None\n        \"\"\"\n        if self._pfp__frozen:\n            raise errors.UnmodifiableConst()\n        if len(value) != len(self._pfp__children):\n            raise errors.PfpError(\"struct initialization has wrong number of members\")\n\n        for x in six.moves.range(len(self._pfp__children)):\n            self._pfp__children[x]._pfp__set_value(value[x])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _pfp__add_child(self, name, child, stream=None, overwrite=False):\n        if not overwrite and self._pfp__is_non_consecutive_duplicate(name, child):\n            return self._pfp__handle_non_consecutive_duplicate(name, child)\n        elif not overwrite and name in self._pfp__children_map:\n            return self._pfp__handle_implicit_array(name, child)\n        else:\n            child._pfp__parent = self\n            self._pfp__children.append(child)\n            child._pfp__name = name\n            self._pfp__children_map[name] = child\n            return child", "response": "Add a child to the Struct field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _pfp__handle_non_consecutive_duplicate(self, name, child, insert=True):\n        if name in self._pfp__children_map:\n            previous_child = self._pfp__children_map[name]\n\n            # DO NOT cause __eq__ to be called, we want to test actual objects, not comparison\n            # operators\n            if previous_child is not child:\n                self._pfp__handle_non_consecutive_duplicate(name, previous_child, insert=False)\n                del self._pfp__children_map[name]\n        \n        next_suffix = self._pfp__name_collisions.setdefault(name, 0)\n        new_name = \"{}_{}\".format(name, next_suffix)\n        child._pfp__name = new_name\n        self._pfp__name_collisions[name] = next_suffix + 1\n        self._pfp__children_map[new_name] = child\n        child._pfp__parent = self\n\n        if insert:\n            self._pfp__children.append(child)\n\n        return child", "response": "This method handles a non - consecutive duplicate of a new child and potentially one already existing child."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the child is a non - consecutive duplicate of the named field.", "response": "def _pfp__is_non_consecutive_duplicate(self, name, child):\n        \"\"\"Return True/False if the child is a non-consecutive duplicately named\n        field. Consecutive duplicately-named fields are stored in an implicit array,\n        non-consecutive duplicately named fields have a numeric suffix appended to their name\"\"\"\n\n        if len(self._pfp__children) == 0:\n            return False\n         \n        # it should be an implicit array\n        if self._pfp__children[-1]._pfp__name == name:\n            return False\n\n        # if it's elsewhere in the children name map OR a collision sequence has already been\n        # started for this name, it should have a numeric suffix\n        # appended\n        elif name in self._pfp__children_map or name in self._pfp__name_collisions:\n            return True\n\n        # else, no collision\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _pfp__handle_implicit_array(self, name, child):\n        existing_child = self._pfp__children_map[name]\n        if isinstance(existing_child, Array):\n            # I don't think we should check this\n            #\n            #if existing_child.field_cls != child.__class__:\n            #    raise errors.PfpError(\"implicit arrays must be sequential!\")\n            existing_child.append(child)\n            return existing_child\n        else:\n            cls = child._pfp__class if hasattr(child, \"_pfp__class\") else child.__class__\n            ary = Array(0, cls)\n            # since the array starts with the first item\n            ary._pfp__offset = existing_child._pfp__offset\n            ary._pfp__parent = self\n            ary._pfp__name = name\n            ary.implicit = True\n            ary.append(existing_child)\n            ary.append(child)\n\n            exist_idx = -1\n            for idx,child in enumerate(self._pfp__children):\n                if child is existing_child:\n                    exist_idx = idx\n                    break\n\n            self._pfp__children[exist_idx] = ary\n            self._pfp__children_map[name] = ary\n            return ary", "response": "Handle inserting implicit array elements."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pfp__parse(self, stream, save_offset=False):\n        if save_offset:\n            self._pfp__offset = stream.tell()\n\n        res = 0\n        for child in self._pfp__children:\n            res += child._pfp__parse(stream, save_offset)\n        return res", "response": "Parse the incoming stream containing the n - bit tag and return the number of bytes parsed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pfp__build(self, stream=None, save_offset=False):\n        if save_offset and stream is not None:\n            self._pfp__offset = stream.tell()\n\n        # returns either num bytes written or total data\n        res = utils.binary(\"\") if stream is None else 0\n\n        # iterate IN ORDER\n        for child in self._pfp__children:\n            child_res = child._pfp__build(stream, save_offset)\n            res += child_res\n\n        return res", "response": "Builds the field and writes the result into the stream"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing the contents of the struct", "response": "def _pfp__show(self, level=0, include_offset=False):\n        \"\"\"Show the contents of the struct\n        \"\"\"\n        res = []\n        res.append(\"{}{} {{\".format(\n            \"{:04x} \".format(self._pfp__offset) if include_offset else \"\",\n            self._pfp__show_name\n        ))\n        for child in self._pfp__children:\n            res.append(\"{}{}{:10s} = {}\".format(\n                \"    \"*(level+1),\n                \"{:04x} \".format(child._pfp__offset) if include_offset else \"\",\n                child._pfp__name,\n                child._pfp__show(level+1, include_offset)\n            ))\n        res.append(\"{}}}\".format(\"    \"*level))\n        return \"\\n\".join(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a child to the Union field", "response": "def _pfp__add_child(self, name, child, stream=None):\n        \"\"\"Add a child to the Union field\n\n        :name: The name of the child\n        :child: A :class:`.Field` instance\n        :returns: The resulting field\n        \"\"\"\n        res = super(Union, self)._pfp__add_child(name, child)\n        self._pfp__buff.seek(0, 0)\n        child._pfp__build(stream=self._pfp__buff)\n        size = len(self._pfp__buff.getvalue())\n        self._pfp__buff.seek(0, 0)\n\n        if stream is not None:\n            curr_pos = stream.tell()\n            stream.seek(curr_pos-size, 0)\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling a child with an updated value", "response": "def _pfp__notify_update(self, child=None):\n        \"\"\"Handle a child with an updated value\n        \"\"\"\n        if getattr(self, \"_pfp__union_update_other_children\", True):\n            self._pfp__union_update_other_children = False\n\n            new_data = child._pfp__build()\n            new_stream =  bitwrap.BitwrappedStream(six.BytesIO(new_data))\n            for other_child in self._pfp__children:\n                if other_child is child:\n                    continue\n\n                if isinstance(other_child, Array) and other_child.is_stringable():\n                    other_child._pfp__set_value(new_data)\n                else:\n                    other_child._pfp__parse(new_stream)\n                new_stream.seek(0)\n\n            self._pfp__no_update_other_children = True\n        \n        super(Union, self)._pfp__notify_update(child=child)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pfp__parse(self, stream, save_offset=False):\n        if save_offset:\n            self._pfp__offset = stream.tell()\n\n        max_res = 0\n        for child in self._pfp__children:\n            child_res = child._pfp__parse(stream, save_offset)\n            if child_res > max_res:\n                max_res = child_res\n\n            # rewind the stream\n            stream.seek(child_res, -1)\n        self._pfp__size = max_res\n\n        self._pfp__buff = six.BytesIO(stream.read(self._pfp__size))\n        return max_res", "response": "Parse the incoming stream containing the current set of entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _pfp__build(self, stream=None, save_offset=False):\n        max_size = -1\n        if stream is None:\n            core_stream = six.BytesIO()\n            new_stream = bitwrap.BitwrappedStream(core_stream)\n        else:\n            new_stream = stream\n\n        for child in self._pfp__children:\n            curr_pos = new_stream.tell()\n            child._pfp__build(new_stream, save_offset)\n            size = new_stream.tell() - curr_pos\n            new_stream.seek(-size, 1)\n\n            if size > max_size:\n                max_size = size\n\n        new_stream.seek(max_size, 1)\n\n        if stream is None:\n            return core_stream.getvalue()\n        else:\n            return max_size", "response": "Builds the union and writes the result into the stream."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pfp__parse(self, stream, save_offset=False):\n        if save_offset:\n            self._pfp__offset = stream.tell()\n\n        if self.bitsize is None:\n            raw_data = stream.read(self.width)\n            data = utils.binary(raw_data)\n\n        else:\n            bits = self.bitfield_rw.read_bits(stream, self.bitsize, self.bitfield_padded, self.bitfield_left_right, self.endian)\n            width_diff = self.width  - (len(bits)//8) - 1\n            bits_diff = 8 - (len(bits) % 8)\n\n            padding = [0] * (width_diff * 8 + bits_diff)\n\n            bits = padding + bits\n\n            data = bitwrap.bits_to_bytes(bits)\n            if self.endian == LITTLE_ENDIAN:\n                # reverse the data\n                data = data[::-1]\n\n        if len(data) < self.width:\n            raise errors.PrematureEOF()\n\n        self._pfp__data = data\n        self._pfp__value = struct.unpack(\n            \"{}{}\".format(self.endian, self.format),\n            data\n        )[0]\n\n        return self.width", "response": "Parse the data for the numeric field."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pfp__build(self, stream=None, save_offset=False):\n        if stream is not None and save_offset:\n            self._pfp__offset = stream.tell()\n\n        if self.bitsize is None:\n            data = struct.pack(\n                \"{}{}\".format(self.endian, self.format),\n                self._pfp__value\n            )\n            if stream is not None:\n                stream.write(data)\n                return len(data)\n            else:\n                return data\n        else:\n            data = struct.pack(\n                \"{}{}\".format(BIG_ENDIAN, self.format),\n                self._pfp__value\n            )\n\n            num_bytes = int(math.ceil(self.bitsize / 8.0))\n            bit_data = data[-num_bytes:]\n\n            raw_bits = bitwrap.bytes_to_bits(bit_data)\n            bits = raw_bits[-self.bitsize:]\n\n            if stream is not None:\n                self.bitfield_rw.write_bits(stream, bits, self.bitfield_padded, self.bitfield_left_right, self.endian)\n                return len(bits) // 8\n            else:\n                # TODO this can't be right....\n                return bits", "response": "Builds the field and writes the result into the stream"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _dom_class(self, obj1, obj2):\n        if isinstance(obj1, Double) or isinstance(obj2, Double):\n            return Double\n        if isinstance(obj1, Float) or isinstance(obj2, Float):\n            return Float", "response": "Returns the dominating numeric class between the two objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pfp__set_value(self, new_val):\n        if self._pfp__frozen:\n            raise errors.UnmodifiableConst()\n\n        if isinstance(new_val, IntBase):\n            # will automatically convert correctly between ints of\n            # different sizes, unsigned/signed, etc\n            raw = new_val._pfp__build()\n            while len(raw) < self.width:\n                if self.endian == BIG_ENDIAN:\n                    raw = b\"\\x00\" + raw\n                else:\n                    raw += b\"\\x00\"\n\n            while len(raw) > self.width:\n                if self.endian == BIG_ENDIAN:\n                    raw = raw[1:]\n                else:\n                    raw = raw[:-1]\n\n            self._pfp__parse(six.BytesIO(raw))\n        else:\n            mask = 1 << (8*self.width)\n\n            if self.signed:\n                max_val = (mask//2)-1\n                min_val = -(mask//2)\n            else:\n                max_val = mask-1\n                min_val = 0\n            \n            if new_val < min_val:\n                new_val += -(min_val)\n                new_val &= (mask-1)\n                new_val -= -(min_val)\n            elif new_val > max_val:\n                new_val &= (mask-1)\n\n            self._pfp__value = new_val\n\n        self._pfp__notify_parent()", "response": "Set the value of the internal field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the IO stream for this enum", "response": "def _pfp__parse(self, stream, save_offset=False):\n        \"\"\"Parse the IO stream for this enum\n\n        :stream: An IO stream that can be read from\n        :returns: The number of bytes parsed\n        \"\"\"\n        res = super(Enum, self)._pfp__parse(stream, save_offset)\n\n        if self._pfp__value in self.enum_vals:\n            self.enum_name = self.enum_vals[self._pfp__value]\n        else:\n            self.enum_name = \"?? UNK_ENUM ??\"\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves off the current value of the field", "response": "def _pfp__snapshot(self, recurse=True):\n        \"\"\"Save off the current value of the field\n        \"\"\"\n        super(Array, self)._pfp__snapshot(recurse=recurse)\n        self.snapshot_raw_data = self.raw_data\n\n        if recurse:\n            for item in self.items:\n                item._pfp__snapshot(recurse=recurse)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pfp__set_value(self, new_val):\n        if not isinstance(new_val, Field):\n            new_val = utils.binary(utils.string_escape(new_val))\n        super(String, self)._pfp__set_value(new_val)", "response": "Set the value of the String."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread from the input stream until the string is null - terminated.", "response": "def _pfp__parse(self, stream, save_offset=False):\n        \"\"\"Read from the stream until the string is null-terminated\n\n        :stream: The input stream\n        :returns: None\n\n        \"\"\"\n        if save_offset:\n            self._pfp__offset = stream.tell()\n\n        res = utils.binary(\"\")\n        while True:\n            byte = utils.binary(stream.read(self.read_size))\n            if len(byte) < self.read_size:\n                raise errors.PrematureEOF()\n            # note that the null terminator must be added back when\n            # built again!\n            if byte == self.terminator:\n                break\n            res += byte\n        self._pfp__value = res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pfp__build(self, stream=None, save_offset=False):\n        if stream is not None and save_offset:\n            self._pfp__offset = stream.tell()\n\n        data = self._pfp__value + utils.binary(\"\\x00\")\n        if stream is None:\n            return data\n        else:\n            stream.write(data)\n            return len(data)", "response": "Builds the String field\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting a format string to stdout.", "response": "def Printf(params, ctxt, scope, stream, coord, interp):\n    \"\"\"Prints format string to stdout\n\n    :params: TODO\n    :returns: TODO\n\n    \"\"\"\n    if len(params) == 1:\n        if interp._printf:\n            sys.stdout.write(PYSTR(params[0]))\n        return len(PYSTR(params[0]))\n\n    parts = []\n    for part in params[1:]:\n        if isinstance(part, pfp.fields.Array) or isinstance(part, pfp.fields.String):\n            parts.append(PYSTR(part))\n        else:\n            parts.append(PYVAL(part))\n\n    to_print = PYSTR(params[0]) % tuple(parts)\n    res = len(to_print)\n\n    if interp._printf:\n        sys.stdout.write(to_print)\n        sys.stdout.flush()\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mutate(field, strat_name_or_cls, num=100, at_once=1, yield_changed=False):\n    import pfp.fuzz.rand as rand\n\n    init()\n\n    strat = get_strategy(strat_name_or_cls)\n    to_mutate = strat.which(field)\n\n    with_strats = []\n    for to_mutate_field in to_mutate:\n        field_strat = strat.get_field_strat(to_mutate_field)\n        if field_strat is not None:\n            with_strats.append((to_mutate_field, field_strat))\n\n    # we don't need these ones anymore\n    del to_mutate\n\n    # save the current value of all subfields without\n    # triggering events\n    field._pfp__snapshot(recurse=True)\n\n    count = 0\n    for x in six.moves.range(num):\n\n        chosen_fields = set()\n        idx_pool = set([x for x in six.moves.xrange(len(with_strats))])\n\n        # modify `at_once` number of fields OR len(with_strats) number of fields,\n        # whichever is lower\n        for at_onces in six.moves.xrange(min(len(with_strats), at_once)):\n            # we'll never pull the same idx from idx_pool more than once\n            # since we're removing the idx after choosing it\n            rand_idx = rand.sample(idx_pool, 1)[0]\n            idx_pool.remove(rand_idx)\n\n            rand_field,field_strat = with_strats[rand_idx]\n            chosen_fields.add(rand_field)\n\n            field_strat.mutate(rand_field)\n        \n        if yield_changed:\n            yield field, chosen_fields\n        else:\n            # yield back the original field\n            yield field\n\n        # restore the saved value of all subfields without\n        # triggering events\n        field._pfp__restore_snapshot(recurse=True)", "response": "Mutate the provided field using the specified strategy."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the strategy identified by its name or class.", "response": "def get_strategy(name_or_cls):\n    \"\"\"Return the strategy identified by its name. If ``name_or_class`` is a class,\n    it will be simply returned.\n    \"\"\"\n    if isinstance(name_or_cls, six.string_types):\n        if name_or_cls not in STRATS:\n            raise MutationError(\"strat is not defined\")\n        return STRATS[name_or_cls]()\n\n    return name_or_cls()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmutate the given field modifying it directly. This is intended to preserve the value of the field.", "response": "def mutate(self, field):\n        \"\"\"Mutate the given field, modifying it directly. This is not\n        intended to preserve the value of the field.\n\n        :field: The pfp.fields.Field instance that will receive the new value\n        \"\"\"\n        new_val = self.next_val(field)\n        field._pfp__set_value(new_val)\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next_val(self, field):\n        import pfp.fuzz.rand as rand\n\n        if self.choices is not None:\n            choices = self._resolve_member_val(self.choices, field)\n            new_val = rand.choice(choices)\n            return self._resolve_val(new_val)\n\n        elif self.prob is not None:\n            prob = self._resolve_member_val(self.prob, field)\n            rand_val = rand.random()\n            curr_total = 0.0\n            # iterate through each of the probability choices until\n            # we reach one that matches the current rand_val\n            for prob_percent, prob_val in prob:\n                if rand_val <= curr_total + prob_percent:\n                    return self._resolve_val(prob_val)\n                curr_total += prob_percent\n\n            raise MutationError(\"probabilities did not add up to 100%! {}\".format(\n                [str(x[0]) + \" - \" + str(x[1])[:10] for x in prob]\n            ))", "response": "Return a new value to mutate a field with."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_subid(self, token=None, return_user=False):\n    '''generate a new user in the database, still session based so we\n       create a new identifier.\n    '''    \n    from expfactory.database.models import Participant\n    if not token:\n        p = Participant()\n    else:\n        p = Participant(token=token)\n    self.session.add(p)\n    self.session.commit()\n    if return_user is True:\n        return p\n    return p.id", "response": "generate a new user in the database"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint a relational database user", "response": "def print_user(self, user):\n    '''print a relational database user\n    ''' \n    status = \"active\"\n    token = user.token\n\n    if token in ['finished', 'revoked']:\n        status = token\n\n    if token is None:\n        token = ''\n  \n    subid = \"%s\\t%s[%s]\" %(user.id, token, status)\n    print(subid)\n    return subid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_users(self, user=None):\n    '''list users, each having a model in the database. A headless experiment\n       will use protected tokens, and interactive will be based on auto-\n       incremented ids.\n    ''' \n    from expfactory.database.models import Participant\n    participants = Participant.query.all()\n    users = []\n    for user in participants:\n        users.append(self.print_user(user))\n    return users", "response": "list users in the database"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a new user in the database", "response": "def generate_user(self):\n    '''generate a new user in the database, still session based so we\n       create a new identifier. This function is called from the users new \n       entrypoint, and it assumes we want a user generated with a token.\n    '''\n    token = str(uuid.uuid4())\n    return self.generate_subid(token=token, return_user=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinishing user will remove a user s token and make the user entry accesible", "response": "def finish_user(self, subid):\n    '''finish user will remove a user's token, making the user entry not\n       accesible if running in headless model'''        \n\n    p = self.revoke_token(subid)\n    p.token = \"finished\"\n    self.session.commit()\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrestarting a user which means revoking and issuing a new token.", "response": "def restart_user(self, subid):\n    '''restart a user, which means revoking and issuing a new token.'''\n    p = self.revoke_token(subid)\n    p = self.refresh_token(subid)\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a subject based on a token. Valid means we return a participant invalid means we return None eer", "response": "def validate_token(self, token):\n    '''retrieve a subject based on a token. Valid means we return a participant\n       invalid means we return None\n    '''\n    from expfactory.database.models import Participant\n    p = Participant.query.filter(Participant.token == token).first()\n    if p is not None:\n        if p.token.endswith(('finished','revoked')):\n            p = None\n        else:\n            p = p.id\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef revoke_token(self, subid):\n    '''revoke a token by removing it. Is done at finish, and also available\n    as a command line option'''\n    from expfactory.database.models import Participant\n    p = Participant.query.filter(Participant.id == subid).first()\n    if p is not None:\n        p.token = 'revoked'\n    self.session.commit()\n    return p", "response": "revoke a token by removing it. Is done at finish and also available\n    as a command line option"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_token(self, subid):\n    '''refresh or generate a new token for a user'''\n    from expfactory.database.models import Participant\n    p = Participant.query.filter(Participant.id == subid).first()\n    if p is not None:\n        p.token = str(uuid.uuid4())\n    self.session.commit()\n    return p", "response": "refresh or generate a new token for a user"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_data(self,session, exp_id, content):\n    '''save data will obtain the current subid from the session, and save it\n       depending on the database type. Currently we just support flat files'''\n    from expfactory.database.models import (\n        Participant,\n        Result\n    )\n    subid = session.get('subid')\n    token = session.get('token') \n\n    self.logger.info('Saving data for subid %s' % subid)    \n\n    # We only attempt save if there is a subject id, set at start\n    if subid is not None:\n        p = Participant.query.filter(Participant.id == subid).first() # better query here\n\n        # Does \n        if self.headless and p.token != token:\n            self.logger.warning('%s attempting to use mismatched token [%s] skipping save' %(p.id, token))\n        elif self.headless and p.token.endswith(('finished','revoked')):\n            self.logger.warning('%s attempting to use expired token [%s] skipping save' %(p.id, token))\n        else:\n\n            # Preference is to save data under 'data', otherwise do all of it\n            if \"data\" in content:\n                content = content['data']\n\n            result = Result(data=content,\n                            exp_id=exp_id,\n                            participant_id=p.id) # check if changes from str/int\n\n            # Create and save the result\n            self.session.add(result)\n            p.results.append(result)\n            self.session.commit()\n\n            self.logger.info(\"Save [participant] %s [result] %s\" %(p, result))", "response": "save data for a specific subject"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_db(self):\n    '''initialize the database, with the default database path or custom with\n       a format corresponding to the database type:\n\n       Examples:\n\n       sqlite:////scif/data/expfactory.db\n    '''\n\n    # The user can provide a custom string\n    if self.database is None:\n        self.logger.error(\"You must provide a database url, exiting.\")\n        sys.exit(1)\n\n    self.engine = create_engine(self.database, convert_unicode=True)\n    self.session = scoped_session(sessionmaker(autocommit=False,\n                                               autoflush=False,\n                                               bind=self.engine))\n\n    # Database Setup\n    Base.query = self.session.query_property()\n\n    # import all modules here that might define models so that\n    # they will be registered properly on the metadata.  Otherwise\n    # you will have to import them first before calling init_db()\n    import expfactory.database.models\n    self.Base = Base\n    self.Base.metadata.create_all(bind=self.engine)", "response": "initialize the database with the default database path or custom with\n       a format corresponding to the database type"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwraps the creation of the type so that we can provide a null - stream to initialize it", "response": "def _wrap_type_instantiation(self, type_cls):\n        \"\"\"Wrap the creation of the type so that we can provide\n        a null-stream to initialize it\"\"\"\n        def wrapper(*args, **kwargs):\n            # use args for struct arguments??\n            return type_cls(stream=self._null_stream)\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef level(self):\n        res = len(self._scope_stack)\n        if self._parent is not None:\n            res += self._parent.level()\n        return res", "response": "Return the current scope level"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new scope and push it on the stack.", "response": "def push(self, new_scope=None):\n        \"\"\"Create a new scope\n        :returns: TODO\n\n        \"\"\"\n        if new_scope is None:\n            new_scope = {\n                \"types\": {},\n                \"vars\": {}\n            }\n        self._curr_scope = new_scope\n        self._dlog(\"pushing new scope, scope level = {}\".format(self.level()))\n        self._scope_stack.append(self._curr_scope)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new Scope object that has the curr_scope_stack pinned at the current one .", "response": "def clone(self):\n        \"\"\"Return a new Scope object that has the curr_scope\n        pinned at the current one\n        :returns: A new scope object\n        \"\"\"\n        self._dlog(\"cloning the stack\")\n        # TODO is this really necessary to create a brand new one?\n        # I think it is... need to think about it more.\n        # or... are we going to need ref counters and a global\n        # scope object that allows a view into (or a snapshot of)\n        # a specific scope stack?\n        res = Scope(self._log)\n        res._scope_stack = self._scope_stack\n        res._curr_scope = self._curr_scope\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nleave the current scope", "response": "def pop(self):\n        \"\"\"Leave the current scope\n        :returns: TODO\n\n        \"\"\"\n        res = self._scope_stack.pop()\n        self._dlog(\"popping scope, scope level = {}\".format(self.level()))\n        self._curr_scope = self._scope_stack[-1]\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a var to the current scope", "response": "def add_var(self, field_name, field, root=False):\n        \"\"\"Add a var to the current scope (vars are fields that\n        parse the input stream)\n\n        :field_name: TODO\n        :field: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"adding var '{}' (root={})\".format(field_name, root))\n\n        # do both so it's not clobbered by intermediate values of the same name\n        if root:\n            self._scope_stack[0][\"vars\"][field_name] = field\n\n        # TODO do we allow clobbering of vars???\n        self._curr_scope[\"vars\"][field_name] = field"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first var of name in the current scope stack.", "response": "def get_var(self, name, recurse=True):\n        \"\"\"Return the first var of name ``name`` in the current\n        scope stack (remember, vars are the ones that parse the\n        input stream)\n\n        :name: The name of the id\n        :recurse: Whether parent scopes should also be searched (defaults to True)\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"getting var '{}'\".format(name))\n        return self._search(\"vars\", name, recurse)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a local variable in the current scope", "response": "def add_local(self, field_name, field):\n        \"\"\"Add a local variable in the current scope\n\n        :field_name: The field's name\n        :field: The field\n        :returns: None\n\n        \"\"\"\n        self._dlog(\"adding local '{}'\".format(field_name))\n        field._pfp__name = field_name\n        # TODO do we allow clobbering of locals???\n        self._curr_scope[\"vars\"][field_name] = field"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the local field from the scope stack. An alias for get_var", "response": "def get_local(self, name, recurse=True):\n        \"\"\"Get the local field (search for it) from the scope stack. An alias\n        for ``get_var``\n\n        :name: The name of the local field\n        \"\"\"\n        self._dlog(\"getting local '{}'\".format(name))\n        return self._search(\"vars\", name, recurse)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_type_struct_or_union(self, name, interp, node):\n        self.add_type_class(name, StructUnionDef(name, interp, node))", "response": "Store the node with the name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrecord the typedefd name for orig_names and save those.", "response": "def add_type(self, new_name, orig_names):\n        \"\"\"Record the typedefd name for orig_names. Resolve orig_names\n        to their core names and save those.\n\n        :new_name: TODO\n        :orig_names: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"adding a type '{}'\".format(new_name))\n        # TODO do we allow clobbering of types???\n        res = copy.copy(orig_names)\n        resolved_names = self._resolve_name(res[-1])\n        if resolved_names is not None:\n            res.pop()\n            res += resolved_names\n\n        self._curr_scope[\"types\"][new_name] = res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_type(self, name, recurse=True):\n        self._dlog(\"getting type '{}'\".format(name))\n        return self._search(\"types\", name, recurse)", "response": "Get the names for the typename created by typedef"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_id(self, name, recurse=True):\n        self._dlog(\"getting id '{}'\".format(name))\n        var = self._search(\"vars\", name, recurse)\n        return var", "response": "Get the first id matching name. Will either be a local\n        or a var."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching the scope stack for the specified name in the specified category.", "response": "def _search(self, category, name, recurse=True):\n        \"\"\"Search the scope stack for the name in the specified\n        category (types/locals/vars).\n\n        :category: the category to search in (locals/types/vars)\n        :name: name to search for\n        :returns: None if not found, the result of the found local/type/id\n        \"\"\"\n        idx = len(self._scope_stack) - 1\n        curr = self._curr_scope\n        for scope in reversed(self._scope_stack):\n            res = scope[category].get(name, None)\n            if res is not None:\n                return res\n\n        if recurse and self._parent is not None:\n            return self._parent._search(category, name, recurse)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a native python function func to the interpreter with the given name and return value ret.", "response": "def add_native(cls, name, func, ret, interp=None, send_interp=False):\n        \"\"\"Add the native python function ``func`` into the pfp interpreter with the\n        name ``name`` and return value ``ret`` so that it can be called from\n        within a template script.\n\n        .. note::\n            The :any:`@native <pfp.native.native>` decorator exists to simplify this.\n\n        All native functions must have the signature ``def func(params, ctxt, scope, stream, coord [,interp])``,\n        optionally allowing an interpreter param if ``send_interp`` is ``True``.\n\n        Example:\n\n            The example below defines a function ``Sum`` using the ``add_native`` method. ::\n\n                import pfp.fields\n                from pfp.fields import PYVAL\n\n                def native_sum(params, ctxt, scope, stream, coord):\n                    return PYVAL(params[0]) + PYVAL(params[1])\n\n                pfp.interp.PfpInterp.add_native(\"Sum\", native_sum, pfp.fields.Int64)\n\n        :param basestring name: The name the function will be exposed as in the interpreter.\n        :param function func: The native python function that will be referenced.\n        :param type(pfp.fields.Field) ret: The field class that the return value should be cast to.\n        :param pfp.interp.PfpInterp interp: The specific pfp interpreter the function should be defined in.\n        :param bool send_interp: If true, the current pfp interpreter will be added as an argument to the function.\n        \"\"\"\n        if interp is None:\n            natives = cls._natives\n        else:\n            # the instance's natives\n            natives = interp._natives\n\n        natives[name] = functions.NativeFunction(\n            name, func, ret, send_interp\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef define_natives(cls):\n        if len(cls._natives) > 0:\n            return\n\n        glob_pattern = os.path.join(os.path.dirname(__file__), \"native\", \"*.py\")\n        for filename in glob.glob(glob_pattern):\n            basename = os.path.basename(filename).replace(\".py\", \"\")\n            if basename == \"__init__\":\n                continue\n\n            try:\n                mod_base = __import__(\"pfp.native\", globals(), locals(), fromlist=[basename])\n            except Exception as e:\n                sys.stderr.write(\"cannot import native module {} at '{}'\".format(basename, filename))\n                raise e\n                continue\n\n            mod = getattr(mod_base, basename)\n            setattr(mod, \"PYVAL\", fields.get_value)\n            setattr(mod, \"PYSTR\", fields.get_str)", "response": "Define the native functions for PFP\n           ."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs the message to the log", "response": "def _dlog(self, msg, indent_increase=0):\n        \"\"\"log the message to the log\"\"\"\n        self._log.debug(\"interp\", msg, indent_increase, filename=self._orig_filename, coord=self._coord)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the data stream using the template.", "response": "def parse(self, stream, template, predefines=True, orig_filename=None, keep_successful=False, printf=True):\n        \"\"\"Parse the data stream using the template (e.g. parse the 010 template\n        and interpret the template using the stream as the data source).\n\n        :stream: The input data stream\n        :template: The template to parse the stream with\n        :keep_successful: Return whatever was successfully parsed before an error. ``_pfp__error`` will contain the exception (if one was raised)\n        :param bool printf: If ``False``, printfs will be noops (default=``True``)\n        :returns: Pfp Dom\n\n        \"\"\"\n        self._dlog(\"parsing\")\n\n        self._printf = printf\n        self._orig_filename = orig_filename\n        self._stream = stream\n        self._template = template\n        self._template_lines = self._template.split(\"\\n\")\n        self._ast = self._parse_string(template, predefines)\n        self._dlog(\"parsed template into ast\")\n\n        res = self._run(keep_successful)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating a single statement.", "response": "def eval(self, statement, ctxt=None):\n        \"\"\"Eval a single statement (something returnable)\n        \"\"\"\n        self._no_debug = True\n\n        statement = statement.strip()\n\n        if not statement.endswith(\";\"):\n            statement += \";\"\n\n        ast = self._parse_string(statement, predefines=False)\n\n        self._dlog(\"evaluating statement: {}\".format(statement))\n        \n        try:\n            res = None\n            for child in ast.children():\n                res = self._handle_node(child, self._scope, self._ctxt, self._stream)\n            return res\n        except errors.InterpReturn as e:\n            return e.value\n        finally:\n            self._no_debug = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the interpreter should break.", "response": "def set_break(self, break_type):\n        \"\"\"Set if the interpreter should break.\n\n        :returns: TODO\n        \"\"\"\n        self._break_type = break_type\n        self._break_level = self._scope.level()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the current line number in the template and the surrounding source lines as well as the surrounding source lines", "response": "def get_curr_lines(self):\n        \"\"\"Return the current line number in the template,\n        as well as the surrounding source lines\n        \"\"\"\n        start = max(0, self._coord.line - 5)\n        end = min(len(self._template_lines), self._coord.line + 4)\n\n        lines = [(x, self._template_lines[x]) for x in six.moves.range(start, end, 1)]\n        return self._coord.line, lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_bitfield_padded(self, val):\n        self._padded_bitfield = val\n        self._stream.padded = val\n        self._ctxt._pfp__padded_bitfield = val", "response": "Sets whether the bitfield input or output stream should be padded."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninterpret the parsed 010 AST and return the root and set _pfp__error if keep_successfull is True.", "response": "def _run(self, keep_successfull):\n        \"\"\"Interpret the parsed 010 AST\n        :returns: PfpDom\n\n        \"\"\"\n\n        # example self._ast.show():\n        #    FileAST:\n        #      Decl: data, [], [], []\n        #        TypeDecl: data, []\n        #          Struct: DATA\n        #            Decl: a, [], [], []\n        #              TypeDecl: a, []\n        #                IdentifierType: ['char']\n        #            Decl: b, [], [], []\n        #              TypeDecl: b, []\n        #                IdentifierType: ['char']\n        #            Decl: c, [], [], []\n        #              TypeDecl: c, []\n        #                IdentifierType: ['char']\n        #            Decl: d, [], [], []\n        #              TypeDecl: d, []\n        #                IdentifierType: ['char']\n\n        self._dlog(\"interpreting template\")\n\n        try:\n            # it is important to pass the stream in as the stream\n            # may change (e.g. compressed data)\n            res = self._handle_node(self._ast, None, None, self._stream)\n        except errors.InterpReturn as e:\n            # TODO handle exit/return codes (e.g. return -1)\n            res = self._root\n        except errors.InterpExit as e:\n            res = self._root\n        except Exception as e:\n            if keep_successfull:\n                # return the root and set _pfp__error\n                res = self._root\n                res._pfp__error = e\n\n            else:\n                exc_type, exc_obj, traceback = sys.exc_info()\n                more_info = \"\\nException at {}:{}\".format(\n                    self._orig_filename,\n                    self._coord.line\n                )\n                six.reraise(\n                    errors.PfpError,\n                    errors.PfpError(exc_obj.__class__.__name__ + \": \" + exc_obj.args[0] + more_info if len(exc_obj.args) > 0 else more_info),\n                    traceback\n                )\n\n        # final drop-in after everything has executed\n        if self._break_type != self.BREAK_NONE:\n            self.debugger.cmdloop(\"execution finished\")\n\n        types = self.get_types()\n        res._pfp__types = types\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_file_ast(self, node, scope, ctxt, stream):\n        self._root = ctxt = fields.Dom(stream)\n        ctxt._pfp__scope = scope\n        self._root._pfp__name = \"__root\"\n        self._root._pfp__interp = self\n        self._dlog(\"handling file AST with {} children\".format(len(node.children())))\n\n        for child in node.children():\n            self._handle_node(child, scope, ctxt, stream)\n\n        ctxt._pfp__process_fields_metadata()\n\n        return ctxt", "response": "Handle the file AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles cast nodes :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_cast(self, node, scope, ctxt, stream):\n        \"\"\"Handle cast nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling cast\")\n        to_type = self._handle_node(node.to_type, scope, ctxt, stream)\n        val_to_cast = self._handle_node(node.expr, scope, ctxt, stream)\n\n        res = to_type()\n        res._pfp__set_value(val_to_cast)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the typename node.", "response": "def _handle_typename(self, node, scope, ctxt, stream):\n        \"\"\"TODO: Docstring for _handle_typename\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling typename\")\n\n        return self._handle_node(node.type, scope, ctxt, stream)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the name of the node - check for node. name and node. type. declname. Not why the second one occurs exactly - it occurs with declaring a new struct field with parameters", "response": "def _get_node_name(self, node):\n        \"\"\"Get the name of the node - check for node.name and\n        node.type.declname. Not sure why the second one occurs\n        exactly - it happens with declaring a new struct field\n        with parameters\"\"\"\n        res = getattr(node, \"name\", None)\n        if res is None:\n            return res\n\n        if isinstance(res, AST.TypeDecl):\n            return res.declname\n        \n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles a decl node.", "response": "def _handle_decl(self, node, scope, ctxt, stream):\n        \"\"\"TODO: Docstring for _handle_decl.\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling decl\")\n\n        metadata_processor = None\n        if node.metadata is not None:\n            #metadata_info = self._handle_metadata(node, scope, ctxt, stream)\n            def process_metadata():\n                metadata_info = self._handle_metadata(node, scope, ctxt, stream)\n                return metadata_info\n            metadata_processor = process_metadata\n\n        field_name = self._get_node_name(node)\n        field = self._handle_node(node.type, scope, ctxt, stream)\n        bitsize = None\n        bitfield_rw = None\n        if getattr(node, \"bitsize\", None) is not None:\n            bitsize = self._handle_node(node.bitsize, scope, ctxt, stream)\n            has_prev = len(ctxt._pfp__children) > 0\n\n            bitfield_rw = None\n            if has_prev:\n                prev = ctxt._pfp__children[-1]\n                # if it was a bitfield as well\n                # TODO I don't think this will handle multiple bitfield groups in a row.\n                # E.g.\n                #     char a: 8, b:8;\n                #    char c: 8, d:8;\n                if ((self._padded_bitfield and prev.__class__.width == field.width) or not self._padded_bitfield) \\\n                        and prev.bitsize is not None and prev.bitfield_rw.reserve_bits(bitsize, stream):\n                    bitfield_rw = prev.bitfield_rw\n\n            # either because there was no previous bitfield, or the previous was full\n            if bitfield_rw is None:\n                bitfield_rw = fields.BitfieldRW(self, field)\n                bitfield_rw.reserve_bits(bitsize, stream)\n\n        if getattr(node, \"is_func_param\", False):\n            # we want to keep this as a class and not instantiate it\n            # instantiation will be done in functions.ParamListDef.instantiate\n            field = (field_name, field)\n        \n        # locals and consts still get a field instance, but DON'T parse the\n        # stream!\n        elif \"local\" in node.quals or \"const\" in node.quals:\n            is_struct = issubclass(field, fields.Struct)\n            if not isinstance(field, fields.Field) and not is_struct:\n                field = field()\n            scope.add_local(field_name, field)\n\n            # this should only be able to be done with locals, right?\n            # if not, move it to the bottom of the function\n            if node.init is not None:\n                val = self._handle_node(node.init, scope, ctxt, stream)\n                if is_struct:\n                    field = val\n                    scope.add_local(field_name, field)\n                else:\n                    field._pfp__set_value(val)\n\n            if \"const\" in node.quals:\n                field._pfp__freeze()\n\n            field._pfp__interp = self\n\n        elif isinstance(field, functions.Function):\n            # eh, just add it as a local...\n            # maybe the whole local/vars thinking needs to change...\n            # and we should only have ONE map TODO\n            field.name = field_name\n            scope.add_local(field_name, field)\n\n        elif field_name is not None:\n            added_child = False\n\n    \n            # by this point, structs are already instantiated (they need to be\n            # in order to set the new context)\n            if not isinstance(field, fields.Field):\n                if issubclass(field, fields.NumberBase):\n                    # use the default bitfield direction\n                    if self._bitfield_direction is self.BITFIELD_DIR_DEFAULT:\n                        bitfield_left_right = True if field.endian == fields.BIG_ENDIAN else False\n                    else:\n                        bitfield_left_right = (self._bitfield_direction is self.BITFIELD_DIR_LEFT_RIGHT)\n\n                    field = field(\n                        stream,\n                        bitsize=bitsize,\n                        metadata_processor=metadata_processor,\n                        bitfield_rw=bitfield_rw,\n                        bitfield_padded=self._padded_bitfield,\n                        bitfield_left_right=bitfield_left_right\n                    )\n\n                # TODO\n                # for now if there's a struct inside of a union that is being\n                # parsed when there's an error, the user will lose information\n                # about how far the parsing got. Here we are explicitly checking for\n                # adding structs and unions to a parent union.\n                elif (issubclass(field, fields.Struct) or issubclass(field, fields.Union)) \\\n                        and not isinstance(ctxt, fields.Union) \\\n                        and hasattr(field, \"_pfp__init\"):\n\n                    # this is so that we can have all nested structs added to\n                    # the root DOM, even if there's an error in parsing the data.\n                    # If we didn't do this, any errors parsing the data would cause\n                    # the new struct to not be added to its parent, and the user would\n                    # not be able to see how far the script got\n                    field = field(stream, metadata_processor=metadata_processor, do_init=False)\n                    field._pfp__interp = self\n                    field_res = ctxt._pfp__add_child(field_name, field, stream)\n\n                    # when adding a new field to a struct/union/fileast, add it to the\n                    # root of the ctxt's scope so that it doesn't get lost by being declared\n                    # from within a function\n                    scope.add_var(field_name, field_res, root=True)\n\n                    field_res._pfp__interp = self\n                    field._pfp__init(stream)\n                    added_child = True\n                else:\n                    field = field(stream, metadata_processor=metadata_processor)\n\n            if not added_child:\n                field._pfp__interp = self\n                field_res = ctxt._pfp__add_child(field_name, field, stream)\n                field_res._pfp__interp = self\n\n                # when adding a new field to a struct/union/fileast, add it to the\n                # root of the ctxt's scope so that it doesn't get lost by being declared\n                # from within a function\n                scope.add_var(field_name, field_res, root=True)\n\n                # this shouldn't be used elsewhere, but should still be explicit with\n                # this flag\n                added_child = True\n\n        # enums will get here. If there is no name, then no\n        # field is being declared (but the enum values _will_\n        # get defined). E.g.:\n        #     enum <uchar blah {\n        #         BLAH1,\n        #        BLAH2,\n        #        BLAH3\n        #     };\n        elif field_name is None:\n            pass\n\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle the metadata for the node", "response": "def _handle_metadata(self, node, scope, ctxt, stream):\n        \"\"\"Handle metadata for the node\n        \"\"\"\n        self._dlog(\"handling node metadata {}\".format(node.metadata.keyvals))\n\n        keyvals = node.metadata.keyvals\n\n        metadata_info = []\n\n        if \"watch\" in node.metadata.keyvals or \"update\" in keyvals:\n            metadata_info.append(\n                self._handle_watch_metadata(node, scope, ctxt, stream)\n            )\n\n        if \"packtype\" in node.metadata.keyvals or \"packer\" in keyvals:\n            metadata_info.append(\n                self._handle_packed_metadata(node, scope, ctxt, stream)\n            )\n\n        return metadata_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_watch_metadata(self, node, scope, ctxt, stream):\n        keyvals = node.metadata.keyvals\n        if \"watch\" not in keyvals:\n            raise errors.PfpError(\"Packed fields require a packer function set\")\n        if \"update\" not in keyvals:\n            raise errors.PfpError(\"Packed fields require a packer function set\")\n\n        watch_field_name = keyvals[\"watch\"]\n        update_func_name = keyvals[\"update\"]\n\n        watch_fields = list(map(lambda x: self.eval(x.strip()), watch_field_name.split(\";\")))\n        update_func = scope.get_id(update_func_name)\n\n        return {\n            \"type\": \"watch\",\n            \"watch_fields\": watch_fields,\n            \"update_func\": update_func,\n            \"func_call_info\": (ctxt, scope, stream, self, self._coord)\n        }", "response": "Handle watch vars for fields\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_packed_metadata(self, node, scope, ctxt, stream):\n        keyvals = node.metadata.keyvals\n        if \"packer\" not in keyvals and (\"pack\" not in keyvals or \"unpack\" not in keyvals):\n            raise errors.PfpError(\"Packed fields require a packer function to be set or pack and unpack functions to be set\")\n        if \"packtype\" not in keyvals:\n            raise errors.PfpError(\"Packed fields require a packtype to be set\")\n\n        args_ = {}\n        if \"packer\" in keyvals:\n            packer_func_name = keyvals[\"packer\"]\n            packer_func = scope.get_id(packer_func_name)\n            args_[\"packer\"] = packer_func\n        elif \"pack\" in keyvals and \"unpack\" in keyvals:\n            pack_func = scope.get_id(keyvals[\"pack\"])\n            unpack_func = scope.get_id(keyvals[\"unpack\"])\n            args_[\"pack\"] = pack_func\n            args_[\"unpack\"] = unpack_func\n\n        packtype_cls_name = keyvals[\"packtype\"]\n        packtype_cls = scope.get_type(packtype_cls_name)\n        args_[\"pack_type\"] = packtype_cls\n\n        args_[\"type\"] = \"packed\"\n        args_[\"func_call_info\"] = (ctxt, scope, stream, self, self._coord)\n        return args_", "response": "Handle packed metadata node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_byref_decl(self, node, scope, ctxt, stream):\n        self._dlog(\"handling byref decl\")\n        field = self._handle_node(node.type.type, scope, ctxt, stream)\n\n        # this will not really be used (maybe except for introspection)\n        # with byref function params\n        # see issue #35 - we need to wrap the field cls so that the byref\n        # doesn't permanently stay on the class\n        field = functions.ParamClsWrapper(field)\n        field.byref = True\n        return field", "response": "TODO: Docstring for _handle_byref_decl.\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _handle_type_decl(self, node, scope, ctxt, stream):\n        self._dlog(\"handling type decl\")\n        decl = self._handle_node(node.type, scope, ctxt, stream)\n        return decl", "response": "TODO: Docstring for _handle_type_decl.\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle a struct ref node.", "response": "def _handle_struct_ref(self, node, scope, ctxt, stream):\n        \"\"\"TODO: Docstring for _handle_struct_ref.\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling struct ref\")\n\n        # name\n        # field\n        struct = self._handle_node(node.name, scope, ctxt, stream)\n\n        try:\n            sub_field = getattr(struct, node.field.name)\n        except AttributeError as e:\n            # should be able to access implicit array items by index OR\n            # access the last one's members directly without index\n            #\n            # E.g.:\n            # \n            # local int total_length = 0;\n            # while(!FEof()) {\n            #     HEADER header;\n            #   total_length += header.length;\n            # }\n            if isinstance(struct, fields.Array) and struct.implicit:\n                last_item = struct[-1]\n                sub_field = getattr(last_item, node.field.name)\n            else:\n                raise\n\n        return sub_field"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_init_list(self, node, scope, ctxt, stream):\n        self._dlog(\"handling init list\")\n        res = []\n        for _,init_child in node.children():\n            init_field = self._handle_node(init_child, scope, ctxt, stream)\n            res.append(init_field)\n        return res", "response": "Handle the InitList nodes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_struct_call_type_decl(self, node, scope, ctxt, stream):\n        self._dlog(\"handling struct with parameters\")\n\n        struct_cls = self._handle_node(node.type, scope, ctxt, stream)\n        struct_args = self._handle_node(node.args, scope, ctxt, stream)\n\n        res = StructDeclWithParams(scope, struct_cls, struct_args)\n        return res", "response": "Handle struct type call"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle the struct node.", "response": "def _handle_struct(self, node, scope, ctxt, stream):\n        \"\"\"TODO: Docstring for _handle_struct.\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling struct\")\n\n        if node.args is not None:\n            for param in node.args.params:\n                param.is_func_param = True\n\n        # it's actually being defined\n        if node.decls is not None:\n            struct_cls = StructUnionDef(\"struct\", self, node)\n\n            if node.name is not None:\n                scope.add_type_class(node.name, struct_cls)\n\n            return struct_cls\n\n        # it's declaring a struct field. E.g.\n        #    struct IFD subDir;\n        else:\n            return scope.get_type(node.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the TypeDef and TypeUnion nodes.", "response": "def _handle_typedef(self, node, scope, ctxt, stream):\n        \"\"\"TODO: Docstring for _handle_typedef.\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        is_union_or_struct = (node.type.type.__class__ in [AST.Union, AST.Struct])\n        is_enum = (node.type.type.__class__ is AST.Enum)\n\n        if is_union_or_struct:\n            self._dlog(\"handling typedef struct/union '{}'\".format(node.name))\n            scope.add_type_struct_or_union(node.name, self, node.type.type)\n        elif is_enum:\n            enum_cls = self._handle_node(node.type, scope, ctxt, stream)\n            scope.add_type_class(node.name, enum_cls)\n        elif isinstance(node.type, AST.ArrayDecl):\n            # this does not parse data, just creates the ArrayDecl class\n            array_cls = self._handle_node(node.type, scope, ctxt, stream)\n            scope.add_type_class(node.name, array_cls)\n        else:\n            names = node.type.type.names\n\n            self._dlog(\"handling typedef '{}' ({})\".format(node.name, names))\n            # don't actually handle the TypeDecl and Identifier nodes,\n            # just directly add the types. Example structure:\n            #\n            #     Typedef: BLAH, [], ['typedef']\n            #        TypeDecl: BLAH, []\n            #            IdentifierType: ['unsigned', 'char']\n            #    \n            scope.add_type(node.name, names)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a string to an integer.", "response": "def _str_to_int(self, string):\n        \"\"\"Check for the hex\n        \"\"\"\n        string = string.lower()\n        if string.endswith(\"l\"):\n            string = string[:-1]\n        if string.lower().startswith(\"0x\"):\n            # should always match\n            match = re.match(r'0[xX]([a-fA-F0-9]+)', string)\n            return int(match.group(1), 0x10)\n        else:\n            return int(string)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_constant(self, node, scope, ctxt, stream):\n        self._dlog(\"handling constant type {}\".format(node.type))\n        switch = {\n            \"int\": (self._str_to_int, self._choose_const_int_class),\n            \"long\": (self._str_to_int, self._choose_const_int_class),\n            # TODO this isn't quite right, but py010parser wouldn't have\n            # parsed it if it wasn't correct...\n            \"float\": (lambda x: float(x.lower().replace(\"f\", \"\")), fields.Float),\n            \"double\": (float, fields.Double),\n\n            # cut out the quotes\n            \"char\": (lambda x: ord(utils.string_escape(x[1:-1])), fields.Char),\n\n            # TODO should this be unicode?? will probably bite me later...\n            # cut out the quotes\n            \"string\": (lambda x: str(utils.string_escape(x[1:-1])), fields.String)\n        }\n\n        if node.type in switch:\n            #return switch[node.type](node.value)\n            conversion,field_cls = switch[node.type]\n            val = conversion(node.value)\n\n            if hasattr(field_cls, \"__call__\") and not type(field_cls) is type:\n                field_cls = field_cls(val)\n\n            field = field_cls()\n            field._pfp__set_value(val)\n            return field\n\n        raise UnsupportedConstantType(node.coord, node.type)", "response": "Handle a constant node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_binary_op(self, node, scope, ctxt, stream):\n        self._dlog(\"handling binary operation {}\".format(node.op))\n        switch = {\n            \"+\": lambda x,y: x+y,\n            \"-\": lambda x,y: x-y,\n            \"*\": lambda x,y: x*y,\n            \"/\": lambda x,y: x/y,\n            \"|\": lambda x,y: x|y,\n            \"^\": lambda x,y: x^y,\n            \"&\": lambda x,y: x&y,\n            \"%\": lambda x,y: x%y,\n            \">\": lambda x,y: x>y,\n            \"<\": lambda x,y: x<y,\n            \"||\": lambda x,y: x or y,\n            \">=\": lambda x,y: x>=y,\n            \"<=\": lambda x,y: x<=y,\n            \"==\": lambda x,y: x == y,\n            \"!=\": lambda x,y: x != y,\n            \"&&\": lambda x,y: x and y,\n            \">>\": lambda x,y: x >> y,\n            \"<<\": lambda x,y: x << y,\n        }\n\n        left_val = self._handle_node(node.left, scope, ctxt, stream)\n        right_val = self._handle_node(node.right, scope, ctxt, stream)\n\n        if node.op not in switch:\n            raise errors.UnsupportedBinaryOperator(node.coord, node.op)\n\n        res = switch[node.op](left_val, right_val)\n\n        if type(res) is bool:\n            new_res = fields.Int()\n            if res:\n                new_res._pfp__set_value(1)\n            else:\n                new_res._pfp__set_value(0)\n            res = new_res\n\n        return res", "response": "Handle binary operator nodes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _handle_unary_op(self, node, scope, ctxt, stream):\n        self._dlog(\"handling unary op {}\".format(node.op))\n\n        special_switch = {\n            \"parentof\"            : self._handle_parentof,\n            \"exists\"            : self._handle_exists,\n            \"function_exists\"    : self._handle_function_exists,\n            \"p++\"                : self._handle_post_plus_plus,\n            \"p--\"                : self._handle_post_minus_minus,\n        }\n\n        switch = {\n            # for ++i and --i\n            \"++\":        lambda x,v: x.__iadd__(1),\n            \"--\":        lambda x,v: x.__isub__(1),\n\n            \"~\":        lambda x,v: ~x,\n            \"!\":        lambda x,v: not x,\n            \"-\":        lambda x,v: -x,\n            \"sizeof\":    lambda x,v: (fields.UInt64()+x._pfp__width()),\n            \"startof\":    lambda x,v: (fields.UInt64()+x._pfp__offset),\n        }\n\n        if node.op not in switch and node.op not in special_switch:\n            raise errors.UnsupportedUnaryOperator(node.coord, node.op)\n\n        if node.op in special_switch:\n            return special_switch[node.op](node, scope, ctxt, stream)\n\n        field = self._handle_node(node.expr, scope, ctxt, stream)\n        if type(field) is type:\n            field = field()\n        res = switch[node.op](field, 1)\n        if type(res) is bool:\n            new_res = field.__class__()\n            new_res._pfp__set_value(1 if res == True else 0)\n            res = new_res\n        return res", "response": "Handle unary operator nodes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the parentof unary operator.", "response": "def _handle_parentof(self, node, scope, ctxt, stream):\n        \"\"\"Handle the parentof unary operator\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        # if someone does something like parentof(this).blah,\n        # we'll end up with a StructRef instead of an ID ref\n        # for node.expr, but we'll also end up with a structref\n        # if the user does parentof(a.b.c)...\n        # \n        # TODO how to differentiate between the two??\n        #\n        # the proper way would be to do (parentof(a.b.c)).a or\n        # (parentof a.b.c).a\n\n        field = self._handle_node(node.expr, scope, ctxt, stream)\n        parent = field._pfp__parent\n        return parent"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_exists(self, node, scope, ctxt, stream):\n        res = fields.Int()\n        try:\n            self._handle_node(node.expr, scope, ctxt, stream)\n            res._pfp__set_value(1)\n        except AttributeError:\n            res._pfp__set_value(0)\n        return res", "response": "Handle the exists unary operator"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_function_exists(self, node, scope, ctxt, stream):\n        res = fields.Int()\n        try:\n            func = self._handle_node(node.expr, scope, ctxt, stream)\n            if isinstance(func, functions.BaseFunction):\n                res._pfp__set_value(1)\n            else:\n                res._pfp__set_value(0)\n        except errors.UnresolvedID:\n            res._pfp__set_value(0)\n        return res", "response": "Handle the function_exists unary operator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle an ID node.", "response": "def _handle_id(self, node, scope, ctxt, stream):\n        \"\"\"Handle an ID node (return a field object for the ID)\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        if node.name == \"__root\":\n            return self._root\n        if node.name == \"__this\" or node.name == \"this\":\n            return ctxt\n\n        self._dlog(\"handling id {}\".format(node.name))\n        field = scope.get_id(node.name)\n\n        is_lazy = getattr(node, \"is_lazy\", False)\n\n        if field is None and not is_lazy:\n            raise errors.UnresolvedID(node.coord, node.name)\n        elif is_lazy:\n            return LazyField(node.name, scope)\n\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles assignment nodes :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_assignment(self, node, scope, ctxt, stream):\n        \"\"\"Handle assignment nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        def add_op(x,y): x += y\n        def sub_op(x,y): x -= y\n        def div_op(x,y): x /= y\n        def mod_op(x,y): x %= y\n        def mul_op(x,y): x *= y\n        def xor_op(x,y): x ^= y\n        def and_op(x,y): x &= y\n        def or_op(x,y): x |= y\n        def lshift_op(x,y): x <<= y\n        def rshift_op(x,y): x >>= y\n        def assign_op(x,y): x._pfp__set_value(y)\n\n        switch = {\n            \"+=\"    : add_op,\n            \"-=\"    : sub_op,\n            \"/=\"    : div_op,\n            \"%=\"    : mod_op,\n            \"*=\"    : mul_op,\n            \"^=\"    : xor_op,\n            \"&=\"    : and_op,\n            \"|=\"    : or_op,\n            \"<<=\"    : lshift_op,\n            \">>=\"    : rshift_op,\n            \"=\"        : assign_op\n        }\n\n        self._dlog(\"handling assignment\")\n        field = self._handle_node(node.lvalue, scope, ctxt, stream)\n        self._dlog(\"field = {}\".format(field))\n        value = self._handle_node(node.rvalue, scope, ctxt, stream)\n\n        if node.op is None:\n            self._dlog(\"value = {}\".format(value))\n            field._pfp__set_value(value)\n        else:\n            self._dlog(\"value {}= {}\".format(node.op, value))\n            if node.op not in switch:\n                raise errors.UnsupportedAssignmentOperator(node.coord, node.op)\n            switch[node.op](field, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_func_def(self, node, scope, ctxt, stream):\n        self._dlog(\"handling function definition\")\n        func = self._handle_node(node.decl, scope, ctxt, stream)\n        func.body = node.body", "response": "Handle FuncDef nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle the ParamList nodes", "response": "def _handle_param_list(self, node, scope, ctxt, stream):\n        \"\"\"Handle ParamList nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling param list\")\n        # params should be a list of tuples:\n        # [(<name>, <field_class>), ...]\n        params = []\n        for param in node.params:\n            self._mark_id_as_lazy(param)\n            param_info = self._handle_node(param, scope, ctxt, stream)\n            params.append(param_info)\n\n        param_list = functions.ParamListDef(params, node.coord)\n        return param_list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling FuncDecl nodes :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_func_decl(self, node, scope, ctxt, stream):\n        \"\"\"Handle FuncDecl nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling func decl\")\n\n        if node.args is not None:\n            # could just call _handle_param_list directly...\n            for param in node.args.params:\n                # see the check in _handle_decl for how this is kept from\n                # being added to the local context/scope\n                param.is_func_param = True\n            params = self._handle_node(node.args, scope, ctxt, stream)\n        else:\n            params = functions.ParamListDef([], node.coord)\n\n        func_type = self._handle_node(node.type, scope, ctxt, stream)\n\n        func = functions.Function(func_type, params, scope)\n\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_func_call(self, node, scope, ctxt, stream):\n        self._dlog(\"handling function call to '{}'\".format(node.name.name))\n        if node.args is None:\n            func_args = []\n        else:\n            func_args = self._handle_node(node.args, scope, ctxt, stream)\n        func = self._handle_node(node.name, scope, ctxt, stream)\n        return func.call(func_args, ctxt, scope, stream, self, node.coord)", "response": "Handle FuncCall nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the ExprList nodes", "response": "def _handle_expr_list(self, node, scope, ctxt, stream):\n        \"\"\"Handle ExprList nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling expression list\")\n        exprs = [\n            self._handle_node(expr, scope, ctxt, stream) for expr in node.exprs\n        ]\n        return exprs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the compound nodes", "response": "def _handle_compound(self, node, scope, ctxt, stream):\n        \"\"\"Handle Compound nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling compound statement\")\n        #scope.push()\n\n        try:\n            for child in node.children():\n                self._handle_node(child, scope, ctxt, stream)\n\n        # in case a return occurs, be sure to pop the scope\n        # (returns are implemented by raising an exception)\n        finally:\n            #scope.pop()\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling Return nodes :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_return(self, node, scope, ctxt, stream):\n        \"\"\"Handle Return nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling return\")\n        if node.expr is None:\n            ret_val = None\n        else:\n            ret_val = self._handle_node(node.expr, scope, ctxt, stream)\n        self._dlog(\"return value = {}\".format(ret_val))\n        raise errors.InterpReturn(ret_val)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _handle_enum(self, node, scope, ctxt, stream):\n        self._dlog(\"handling enum\")\n        if node.type is None:\n            enum_cls = fields.Int\n        else:\n            enum_cls = self._handle_node(node.type, scope, ctxt, stream)\n\n        enum_vals = {}\n        curr_val = enum_cls()\n        curr_val._pfp__value = -1\n        for enumerator in node.values.enumerators:\n            if enumerator.value is not None:\n                curr_val = self._handle_node(enumerator.value, scope, ctxt, stream)\n            else:\n                curr_val = curr_val + 1\n            curr_val._pfp__freeze()\n            enum_vals[enumerator.name] = curr_val\n            enum_vals[fields.PYVAL(curr_val)] = enumerator.name\n            scope.add_local(enumerator.name, curr_val)\n\n        if node.name is not None:\n            enum_cls = EnumDef(node.name, enum_cls, enum_vals)\n            scope.add_type_class(node.name, enum_cls)\n\n        else:\n            enum_cls = EnumDef(\"enum_\" + enum_cls.__name__, enum_cls, enum_vals)\n            # don't add to scope if we don't have a name\n\n        return enum_cls", "response": "Handles the Enum nodes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_array_decl(self, node, scope, ctxt, stream):\n        self._dlog(\"handling array declaration '{}'\".format(node.type.declname))\n\n        if node.dim is None:\n            # will be used\n            array_size = None\n        else:\n            array_size = self._handle_node(node.dim, scope, ctxt, stream)\n        self._dlog(\"array size = {}\".format(array_size))\n        # TODO node.dim_quals\n        # node.type\n        field_cls = self._handle_node(node.type, scope, ctxt, stream)\n        self._dlog(\"field class = {}\".format(field_cls))\n        array = ArrayDecl(field_cls, array_size)\n        #array = fields.Array(array_size, field_cls)\n        array._pfp__name = node.type.declname\n        #array._pfp__parse(stream)\n        return array", "response": "Handle ArrayDecl nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_array_ref(self, node, scope, ctxt, stream):\n        ary = self._handle_node(node.name, scope, ctxt, stream)\n        subscript = self._handle_node(node.subscript, scope, ctxt, stream)\n        return ary[fields.PYVAL(subscript)]", "response": "Handle ArrayRef nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _handle_if(self, node, scope, ctxt, stream):\n        self._dlog(\"handling if/ternary_op\")\n        cond = self._handle_node(node.cond, scope, ctxt, stream)\n        if cond:\n            # there should always be an iftrue\n            return self._handle_node(node.iftrue, scope, ctxt, stream)\n        else:\n            if node.iffalse is not None:\n                return self._handle_node(node.iffalse, scope, ctxt, stream)", "response": "Handle If nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle For nodes :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_for(self, node, scope, ctxt, stream):\n        \"\"\"Handle For nodes\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling for\")\n        if node.init is not None:\n            # perform the init\n            self._handle_node(node.init, scope, ctxt, stream)\n\n        while node.cond is None or self._handle_node(node.cond, scope, ctxt, stream):\n            if node.stmt is not None:\n                try:\n                    # do the for body\n                    self._handle_node(node.stmt, scope, ctxt, stream)\n                except errors.InterpBreak as e:\n                    break\n                \n                # we still need to interpret the \"next\" statement,\n                # so just pass\n                except errors.InterpContinue as e:\n                    pass\n\n            if node.next is not None:\n                # do the next statement\n                self._handle_node(node.next, scope, ctxt, stream)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle a while node.", "response": "def _handle_while(self, node, scope, ctxt, stream):\n        \"\"\"Handle break node\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling while\")\n        while node.cond is None or self._handle_node(node.cond, scope, ctxt, stream):\n            if node.stmt is not None:\n                try:\n                    self._handle_node(node.stmt, scope, ctxt, stream)\n                except errors.InterpBreak as e:\n                    break\n                except errors.InterpContinue as e:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling break node :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_switch(self, node, scope, ctxt, stream):\n        \"\"\"Handle break node\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        def exec_case(idx, cases):\n            # keep executing cases until a break is found,\n            # or they've all been executed\n            for case in cases[idx:]:\n                stmts = case.stmts\n                try:\n                    for stmt in stmts:\n                        self._handle_node(stmt, scope, ctxt, stream)\n                except errors.InterpBreak as e:\n                    break\n\n        def get_stmts(stmts, res=None):\n            if res is None:\n                res = []\n\n            stmts = self._flatten_list(stmts)\n            for stmt in stmts:\n                if isinstance(stmt, tuple):\n                    stmt = stmt[1]\n\n                res.append(stmt)\n\n                if stmt.__class__ in [AST.Case, AST.Default]:\n                    get_stmts(stmt.stmts, res)\n\n            return res\n\n        def get_cases(nodes, acc=None):\n            cases = []\n\n            stmts = get_stmts(nodes)\n            for stmt in stmts:\n                if stmt.__class__ in [AST.Case, AST.Default]:\n                    cases.append(stmt)\n                    stmt.stmts = []\n                else:\n                    cases[-1].stmts.append(stmt)\n\n            return cases\n\n        cond = self._handle_node(node.cond, scope, ctxt, stream)\n    \n        default_idx = None\n        found_match = False\n\n        cases = getattr(node, \"pfp_cases\", None)\n        if cases is None:\n            cases = get_cases(node.stmt.children())\n            node.pfp_cases = cases\n\n        for idx,child in enumerate(cases):\n            if child.__class__ == AST.Default:\n                default_idx = idx\n                continue\n            elif child.__class__ == AST.Case:\n                expr = self._handle_node(child.expr, scope, ctxt, stream)\n                if expr == cond:\n                    found_match = True\n                    exec_case(idx, cases)\n                    break\n\n        if default_idx is not None and not found_match:\n            exec_case(default_idx, cases)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_break(self, node, scope, ctxt, stream):\n        self._dlog(\"handling break\")\n        raise errors.InterpBreak()", "response": "Handle a break node"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle continue node :node: TODO :scope: TODO :ctxt: TODO :stream: TODO :returns: TODO", "response": "def _handle_continue(self, node, scope, ctxt, stream):\n        \"\"\"Handle continue node\n\n        :node: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :stream: TODO\n        :returns: TODO\n\n        \"\"\"\n        self._dlog(\"handling continue\")\n        raise errors.InterpContinue()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _handle_decl_list(self, node, scope, ctxt, stream):\n        self._dlog(\"handling decl list\")\n        # just handle each declaration\n        for decl in node.decls:\n            self._handle_node(decl, scope, ctxt, stream)", "response": "Handle declarations in a list node"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new scope object for the current natives and log.", "response": "def _create_scope(self):\n        \"\"\"TODO: Docstring for _create_scope.\n        :returns: TODO\n\n        \"\"\"\n        res = Scope(self._log)\n\n        for func_name,native_func in six.iteritems(self._natives):\n            res.add_local(func_name, native_func)\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value of the node. It is expected to be either an AST. ID instance or a constant .", "response": "def _get_value(self, node, scope, ctxt, stream):\n        \"\"\"Return the value of the node. It is expected to be\n        either an AST.ID instance or a constant\n\n        :node: TODO\n        :returns: TODO\n\n        \"\"\"\n\n        res = self._handle_node(node, scope, ctxt, stream)\n\n        if isinstance(res, fields.Field):\n            return res._pfp__value\n\n        # assume it's a constant\n        else:\n            return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresolves the names to a class in fields. py", "response": "def _resolve_to_field_class(self, names, scope):\n        \"\"\"Resolve the names to a class in fields.py, resolving past\n        typedefs, etc\n\n        :names: TODO\n        :scope: TODO\n        :ctxt: TODO\n        :returns: TODO\n\n        \"\"\"\n        switch = {\n            \"char\"    : \"Char\",\n            \"int\"     : \"Int\",\n            \"long\"    : \"Int\",\n            \"int64\"   : \"Int64\",\n            \"uint64\"  : \"UInt64\",\n            \"short\"   : \"Short\",\n            \"double\"  : \"Double\",\n            \"float\"   : \"Float\",\n            \"void\"    : \"Void\",\n            \"string\"  : \"String\",\n            \"wstring\" : \"WString\"\n        }\n\n        core = names[-1]\n        \n        if core not in switch:\n            # will return a list of resolved names\n            type_info = scope.get_type(core)\n            if type(type_info) is type and issubclass(type_info, fields.Field):\n                return type_info\n            resolved_names = type_info\n            if resolved_names is None:\n                raise errors.UnresolvedType(self._coord, \" \".join(names), \" \")\n            if resolved_names[-1] not in switch:\n                raise errors.UnresolvedType(self._coord, \" \".join(names), \" \".join(resolved_names))\n            names = copy.copy(names)\n            names.pop()\n            names += resolved_names\n        \n        if len(names) >= 2 and names[-1] == names[-2] and names[-1] == \"long\":\n            res = \"Int64\"\n        else:        \n            res = switch[names[-1]]\n\n        if names[-1] in [\"char\", \"short\", \"int\", \"long\"] and \"unsigned\" in names[:-1]:\n            res = \"U\" + res\n\n        cls = getattr(fields, res)\n        return cls"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the bit list into bytes.", "response": "def bits_to_bytes(bits):\n    \"\"\"Convert the bit list into bytes. (Assumes bits is a list\n    whose length is a multiple of 8)\n    \"\"\"\n    if len(bits) % 8 != 0:\n        raise Exception(\"num bits must be multiple of 8\")\n\n    res = \"\"\n\n    for x in six.moves.range(0, len(bits), 8):\n        byte_bits = bits[x:x+8]\n        byte_val = int(''.join(map(str, byte_bits)), 2)\n        res += chr(byte_val)\n\n    return utils.binary(res)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a list of bytes to a list of bits", "response": "def bytes_to_bits(bytes_):\n    \"\"\"Convert bytes to a list of bits\n    \"\"\"\n    res = []\n    for x in bytes_:\n        if not isinstance(x, int):\n            x = ord(x)\n        res += byte_to_bits(x)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the stream has reached EOF or False otherwise.", "response": "def is_eof(self):\n        \"\"\"Return if the stream has reached EOF or not\n        without discarding any unflushed bits\n\n        :returns: True/False\n        \"\"\"\n        pos = self._stream.tell()\n        byte = self._stream.read(1)\n        self._stream.seek(pos, 0)\n\n        return utils.binary(byte) == utils.binary(\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, num):\n        start_pos = self.tell()\n\n        if self.padded:\n            # we toss out any uneven bytes\n            self._bits.clear()\n            res = utils.binary(self._stream.read(num))\n        else:\n            bits = self.read_bits(num * 8)\n            res = bits_to_bytes(bits)\n            res = utils.binary(res)\n\n        end_pos = self.tell()\n        self._update_consumed_ranges(start_pos, end_pos)\n\n        return res", "response": "Reads num number of bytes from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_bits(self, num):\n        if num > len(self._bits):\n            needed = num - len(self._bits)\n            num_bytes = int(math.ceil(needed / 8.0))\n            read_bytes = self._stream.read(num_bytes)\n\n            for bit in bytes_to_bits(read_bytes):\n                self._bits.append(bit)\n\n        res = []\n        while len(res) < num and len(self._bits) > 0:\n            res.append(self._bits.popleft())\n\n        return res", "response": "Read num number of bits from the stream and return them as a list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the data to the stream.", "response": "def write(self, data):\n        \"\"\"Write data to the stream\n\n        :data: the data to write to the stream\n        :returns: None\n        \"\"\"\n        if self.padded:\n            # flush out any remaining bits first\n            if len(self._bits) > 0:\n                self._flush_bits_to_stream()\n            self._stream.write(data)\n        else:\n            # nothing to do here\n            if len(data) == 0:\n                return\n\n            bits = bytes_to_bits(data)\n            self.write_bits(bits)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_bits(self, bits):\n        for bit in bits:\n            self._bits.append(bit)\n\n        while len(self._bits) >= 8:\n            byte_bits = [self._bits.popleft() for x in six.moves.range(8)]\n            byte = bits_to_bytes(byte_bits)\n            self._stream.write(byte)", "response": "Write the bits to the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tell(self):\n        res = self._stream.tell()\n        if len(self._bits) > 0:\n            res -= 1\n        return res", "response": "Return the current position in the stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef seek(self, pos, seek_type=0):\n        self._bits.clear()\n        return self._stream.seek(pos, seek_type)", "response": "Seek to the specified position in the stream with seek_type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef size(self):\n        pos = self._stream.tell()\n        # seek to the end of the stream\n        self._stream.seek(0,2)\n        size = self._stream.tell()\n        self._stream.seek(pos, 0)\n\n        return size", "response": "Return the size of the resource store in bytes or - 1 if it cannot be determined."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unconsumed_ranges(self):\n        res = IntervalTree()\n\n        prev = None\n\n        # normal iteration is not in a predictable order\n        ranges = sorted([x for x in self.range_set], key=lambda x: x.begin)\n\n        for rng in ranges:\n            if prev is None:\n                prev = rng\n                continue\n            res.add(Interval(prev.end, rng.begin))\n            prev = rng\n        \n        # means we've seeked past the end\n        if len(self.range_set[self.tell()]) != 1:\n            res.add(Interval(prev.end, self.tell()))\n\n        return res", "response": "Return an IntervalTree of unconsumed ranges of the format\n        start end with the end value being included\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the self. consumed_ranges array with which byte ranges have been consecutively consumed.", "response": "def _update_consumed_ranges(self, start_pos, end_pos):\n        \"\"\"Update the ``self.consumed_ranges`` array with which\n        byte ranges have been consecutively consumed.\n        \"\"\"\n        self.range_set.add(Interval(start_pos, end_pos+1))\n        self.range_set.merge_overlaps()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nflushing the bits to the stream. This is used when the bits are not written to the stream.", "response": "def _flush_bits_to_stream(self):\n        \"\"\"Flush the bits to the stream. This is used when\n        a few bits have been read and ``self._bits`` contains unconsumed/\n        flushed bits when data is to be written to the stream\n        \"\"\"\n        if len(self._bits) == 0:\n            return 0\n\n        bits = list(self._bits)\n\n        diff = 8 - (len(bits) % 8)\n        padding = [0] * diff\n\n        bits = bits + padding\n\n        self._stream.write(bits_to_bytes(bits))\n\n        self._bits.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate_markdown(self, expfile):\n        '''ensure that fields are present in markdown file'''\n\n        try:\n            import yaml\n        except:\n            bot.error('Python yaml is required for testing yml/markdown files.')\n            sys.exit(1)\n\n        self.metadata = {}\n        uid = os.path.basename(expfile).strip('.md')\n     \n        if os.path.exists(expfile):\n            with open(expfile, \"r\") as stream:\n                docs = yaml.load_all(stream)\n                for doc in docs:\n                    if isinstance(doc,dict):\n                        for k,v in doc.items():\n                            print('%s: %s' %(k,v))\n                            self.metadata[k] = v\n            self.metadata['uid'] = uid\n       \n            fields = ['github', 'preview', 'name', 'layout',\n                      'tags', 'uid', 'maintainer']\n\n            # Tests for all fields\n            for field in fields:\n                if field not in self.metadata:\n                    return False\n                if self.metadata[field] in ['',None]:\n                    return False\n\n            if 'github' not in self.metadata['github']:\n                return notvalid('%s: not a valid github repository' % name)\n            if not isinstance(self.metadata['tags'],list):\n                return notvalid('%s: tags must be a list' % name)\n            if not re.search(\"(\\w+://)(.+@)*([\\w\\d\\.]+)(:[\\d]+){0,1}/*(.*)\", self.metadata['github']):\n                return notvalid('%s is not a valid URL.' %(self.metadata['github']))\n\n        return True", "response": "ensure that all fields in the given file are present in the given file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform all checks for required variables before returning to", "response": "def perform_checks(template,\n                   do_redirect=False,\n                   context=None,\n                   next=None,\n                   quiet=False):\n\n    '''return all checks for required variables before returning to \n       desired view\n\n       Parameters\n       ==========\n       template: the html template to render\n       do_redirect: if True, perform a redirect and not render\n       context: dictionary of context variables to pass to render_template\n       next: a pre-defined next experiment, will calculate if None\n       quiet: decrease verbosity\n\n    '''\n    from expfactory.server import app\n    username = session.get('username')\n    subid = session.get('subid')\n\n    # If redirect, \"last\" is currently active (about to start)\n    # If render, \"last\" is last completed / active experiment (just finished)\n    last = session.get('exp_id')\n    if next is None:\n        next = app.get_next(session)\n    session['exp_id'] = next\n\n    # Headless mode requires token\n    if \"token\" not in session and app.headless is True:\n        flash('A token is required for these experiments.')\n        return redirect('/')\n\n    # Update the user / log\n    if quiet is False:\n        app.logger.info(\"[router] %s --> %s [subid] %s [user] %s\" %(last,\n                                                                    next, \n                                                                    subid,\n                                                                    username))\n\n    if username is None and app.headless is False:\n        flash('You must start a session before doing experiments.')\n        return redirect('/')\n\n    if subid is None:\n        flash('You must have a participant identifier before doing experiments')\n        return redirect('/')\n\n    if next is None:\n        flash('Congratulations, you have finished the battery!')\n        return redirect('/finish')\n\n    if do_redirect is True:\n        app.logger.debug('Redirecting to %s' %template)\n        return redirect(template)\n\n    if context is not None and isinstance(context, dict):\n        app.logger.debug('Rendering %s' %template)\n        return render_template(template, **context)\n    return render_template(template)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef FSeek(params, ctxt, scope, stream, coord):\n    if len(params) != 1:\n        raise errors.InvalidArguments(coord, \"{} args\".format(len(params)), \"FSeek accepts only one argument\")\n    \n    pos = PYVAL(params[0])\n    curr_pos = stream.tell()\n\n    fsize = stream.size()\n\n    if pos > fsize:\n        stream.seek(fsize)\n        return -1\n    elif pos < 0:\n        stream.seek(0)\n        return -1\n\n    diff = pos - curr_pos\n    if diff < 0:\n        stream.seek(pos)\n        return 0\n\n    data = stream.read(diff)\n\n    # let the ctxt automatically append numbers, as needed, unless the previous\n    # child was also a skipped field\n    skipped_name = \"_skipped\"\n\n    if len(ctxt._pfp__children) > 0 and ctxt._pfp__children[-1]._pfp__name.startswith(\"_skipped\"):\n        old_name = ctxt._pfp__children[-1]._pfp__name\n        data = ctxt._pfp__children[-1].raw_data + data\n        skipped_name = old_name\n        ctxt._pfp__children = ctxt._pfp__children[:-1]\n        del ctxt._pfp__children_map[old_name]\n\n    tmp_stream = bitwrap.BitwrappedStream(six.BytesIO(data))\n    new_field = pfp.fields.Array(len(data), pfp.fields.Char, tmp_stream)\n    ctxt._pfp__add_child(skipped_name, new_field, stream)\n    scope.add_var(skipped_name, new_field)\n\n    return 0", "response": "Returns 0 if successful or - 1 if unsuccessful."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef FSkip(params, ctxt, scope, stream, coord):\n    if len(params) != 1:\n        raise errors.InvalidArguments(coord, \"{} args\".format(len(params)), \"FSkip accepts only one argument\")\n\n    skip_amt = PYVAL(params[0])\n    pos = skip_amt + stream.tell()\n    return FSeek([pos], ctxt, scope, stream, coord)", "response": "Returns 0 if successful or - 1 if unsuccessful."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef packer_gzip(params, ctxt, scope, stream, coord):\n    if len(params) <= 1:\n        raise errors.InvalidArguments(coord, \"{} args\".format(len(params)), \"at least two arguments\")\n\n    # to gzip it (pack it)\n    if params[0]:\n        return pack_gzip(params[1:], ctxt, scope, stream, coord)\n    else:\n        return unpack_gzip(params[1:], ctxt, scope, stream, coord)", "response": "Packs and unpacks the data of the current node into a new node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pack_gzip(params, ctxt, scope, stream, coord):\n    if len(params) == 0:\n        raise errors.InvalidArguments(coord, \"{} args\".format(len(params)), \"at least one argument\")\n    \n    built = utils.binary(\"\")\n    for param in params:\n        if isinstance(param, pfp.fields.Field):\n            built += param._pfp__build()\n        else:\n            built += param\n    \n    return zlib.compress(built)", "response": "Packs the params and returns a gzipped version of the resulting data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwatch the total length of each parameter.", "response": "def watch_length(params, ctxt, scope, stream, coord):\n    \"\"\"WatchLength - Watch the total length of each of the params.\n    \n    Example:\n        The code below uses the ``WatchLength`` update function to update\n        the ``length`` field to the length of the ``data`` field ::\n\n            int length<watch=data, update=WatchLength>;\n            char data[length];\n    \"\"\"\n    if len(params) <= 1:\n        raise errors.InvalidArguments(coord, \"{} args\".format(len(params)), \"at least two arguments\")\n    \n    to_update = params[0]\n\n    total_size = 0\n    for param in params[1:]:\n        total_size += param._pfp__width()\n    \n    to_update._pfp__set_value(total_size)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwatch the total CRC32 of the params.", "response": "def watch_crc(params, ctxt, scope, stream, coord):\n    \"\"\"WatchCrc32 - Watch the total crc32 of the params.\n    \n    Example:\n        The code below uses the ``WatchCrc32`` update function to update\n        the ``crc`` field to the crc of the ``length`` and ``data`` fields ::\n\n            char length;\n            char data[length];\n            int crc<watch=length;data, update=WatchCrc32>;\n    \"\"\"\n    if len(params) <= 1:\n        raise errors.InvalidArguments(coord, \"{} args\".format(len(params)), \"at least two arguments\")\n    \n    to_update = params[0]\n\n    total_data = utils.binary(\"\")\n    for param in params[1:]:\n        total_data += param._pfp__build()\n    \n    to_update._pfp__set_value(binascii.crc32(total_data))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates folder takes a cloned github repo ensures the existence of the config. json and validates it.", "response": "def _validate_folder(self, folder=None):\n        ''' validate folder takes a cloned github repo, ensures\n            the existence of the config.json, and validates it.\n        '''\n        from expfactory.experiment import load_experiment\n\n        if folder is None:\n            folder=os.path.abspath(os.getcwd())\n\n        config = load_experiment(folder, return_path=True)\n\n        if not config:\n            return notvalid(\"%s is not an experiment.\" %(folder))\n\n        return self._validate_config(folder)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self, folder, cleanup=False, validate_folder=True):\n        ''' validate is the entrypoint to all validation, for\n            a folder, config, or url. If a URL is found, it is\n            cloned and cleaned up.\n           :param validate_folder: ensures the folder name (github repo)\n                                   matches.\n        '''\n         \n        # Obtain any repository URL provided\n        if folder.startswith('http') or 'github' in folder:\n            folder = clone(folder, tmpdir=self.tmpdir)\n\n        # Load config.json if provided directly\n        elif os.path.basename(folder) == 'config.json':\n            config = os.path.dirname(folder)\n            return self._validate_config(config, validate_folder)\n\n        # Otherwise, validate folder and cleanup\n        valid = self._validate_folder(folder)\n        if cleanup is True:\n            shutil.rmtree(folder)\n        return valid", "response": "Validate a folder and optionally a config. json or url."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates config is the primary validation function that checks for presence and format of required fields. Parameters ========== :folder: full path to folder with config.json :name: if provided, the folder name to check against exp_id", "response": "def _validate_config(self, folder, validate_folder=True):\n        ''' validate config is the primary validation function that checks\n            for presence and format of required fields.\n\n        Parameters\n        ==========\n        :folder: full path to folder with config.json\n        :name: if provided, the folder name to check against exp_id\n        '''\n        config = \"%s/config.json\" % folder\n        name = os.path.basename(folder)\n        if not os.path.exists(config):\n            return notvalid(\"%s: config.json not found.\" %(folder))\n\n        # Load the config\n        try:\n            config = read_json(config)\n        except:\n            return notvalid(\"%s: cannot load json, invalid.\" %(name))\n \n        # Config.json should be single dict\n        if isinstance(config, list):\n            return notvalid(\"%s: config.json is a list, not valid.\" %(name))\n\n        # Check over required fields\n        fields = self.get_validation_fields()\n        for field,value,ftype in fields:\n\n            bot.verbose('field: %s, required: %s' %(field,value))\n\n            # Field must be in the keys if required\n            if field not in config.keys():\n                if value == 1:\n                    return notvalid(\"%s: config.json is missing required field %s\" %(name,field))\n\n            # Field is present, check type\n            else:\n                if not isinstance(config[field], ftype):\n                    return notvalid(\"%s: invalid type, must be %s.\" %(name,str(ftype)))\n\n            # Expid gets special treatment\n            if field == \"exp_id\" and validate_folder is True:\n                if config[field] != name:\n                    return notvalid(\"%s: exp_id parameter %s does not match folder name.\" \n                                    %(name,config[field]))\n\n                # name cannot have special characters, only _ and letters/numbers\n                if not re.match(\"^[a-z0-9_-]*$\", config[field]): \n                    message = \"%s: exp_id parameter %s has invalid characters\" \n                    message += \"only lowercase [a-z],[0-9], -, and _ allowed.\"\n                    return notvalid(message %(name,config[field]))\n                \n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_validation_fields(self):\n        '''get_validation_fields returns a list of tuples (each a field)\n           we only require the exp_id to coincide with the folder name, for the sake\n           of reproducibility (given that all are served from sample image or Github\n           organization). All other fields are optional.\n           To specify runtime variables, add to \"experiment_variables\"\n\n                 0: not required, no warning\n                 1: required, not valid\n                 2: not required, warning      \n                type: indicates the variable type\n        '''\n        return [(\"name\",1,str),   # required\n                (\"time\",1,int), \n                (\"url\",1,str), \n                (\"description\",1, str),\n                (\"instructions\",1, str),\n                (\"exp_id\",1,str),\n\n                (\"install\",0, list),  # list of commands to install / build experiment \n                (\"contributors\",0, list), # not required\n                (\"reference\",0, list), \n                (\"cognitive_atlas_task_id\",0,str),\n                (\"template\",0,str)]", "response": "get_validation_fields returns a list of tuples that are required to be passed to the validation function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_runtime_vars(variable_file=None, sep=','):\n    '''generate a lookup data structure from a \n       delimited file. We typically obtain the file name and delimiter from\n       the environment by way of EXPFACTORY_RUNTIME_VARS, and\n       EXPFACTORY_RUNTIME_DELIM, respectively, but the user can also parse\n       from a custom variable file by way of specifying it to the function\n       (preference is given here). The file should be csv, with the\n       only required first header field as \"token\" and second as \"exp_id\" to\n       distinguish the participant ID and experiment id. The subsequent\n       columns should correspond to experiment variable names. No special parsing\n       of either is done. \n\n       Parameters\n       ==========\n       variable_file: full path to the tabular file with token, exp_id, etc.\n       sep: the default delimiter to use, if not set in enironment.\n\n       Returns\n       =======\n       varset: a dictionary lookup by exp_id and then participant ID.\n\n       { 'test-parse-url': {\n                             '123': {\n                                      'color': 'red',\n                                      'globalname': 'globalvalue',\n                                      'words': 'at the thing'\n                                    },\n\n                             '456': {'color': 'blue',\n                                     'globalname': 'globalvalue',\n                                     'words': 'omg tacos'}\n                              }\n       }\n\n    '''\n\n    # First preference goes to runtime, then environment, then unset\n\n    if variable_file is None:    \n        if EXPFACTORY_RUNTIME_VARS is not None:\n            variable_file = EXPFACTORY_RUNTIME_VARS\n\n    if variable_file is not None:\n        if not os.path.exists(variable_file):\n            bot.warning('%s is set, but not found' %variable_file)\n            return variable_file\n\n    # If still None, no file\n    if variable_file is None:\n        return variable_file\n\n    # If we get here, we have a variable file that exists\n    delim = sep\n    if EXPFACTORY_RUNTIME_DELIM is not None:\n        delim = EXPFACTORY_RUNTIME_DELIM\n    bot.debug('Delim for variables file set to %s' %sep)\n\n    # Read in the file, generate config\n\n    varset = dict()\n    rows = _read_runtime_vars(variable_file)\n    \n    if len(rows) > 0:\n\n        # When we get here, we are sure to have \n        # 'exp_id', 'var_name', 'var_value', 'token'\n\n        for row in rows:\n\n            exp_id = row[0].lower()   # exp-id must be lowercase\n            var_name = row[1]\n            var_value = row[2]\n            token = row[3]\n\n            # Level 1: Experiment ID\n            if exp_id not in varset:\n                varset[exp_id] = {}\n\n            # Level 2: Participant ID\n            if token not in varset[exp_id]:\n                varset[exp_id][token] = {}\n\n            # If found global setting, courtesy debug message\n            if token == \"*\":\n                bot.debug('Found global variable %s' %var_name)\n\n            # Level 3: is the variable, issue warning if already defined\n            if var_name in varset[exp_id][token]:\n                bot.warning('%s defined twice %s:%s' %(var_name, exp_id, token))\n            varset[exp_id][token][var_name] = var_value\n\n\n    return varset", "response": "generate a lookup data structure from a delimited file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the entire runtime variable file and return a list of lists each corresponding to a row.", "response": "def _read_runtime_vars(variable_file, sep=','):\n    '''read the entire runtime variable file, and return a list of lists,\n       each corresponding to a row. We also check the header, and exit\n       if anything is missing or malformed.\n\n       Parameters\n       ==========\n\n       variable_file: full path to the tabular file with token, exp_id, etc.\n       sep: the default delimiter to use, if not set in enironment.\n\n       Returns\n       =======\n\n       valid_rows: a list of lists, each a valid row\n\n           [['test-parse-url', 'globalname', 'globalvalue', '*'],\n            ['test-parse-url', 'color', 'red', '123'], \n            ['test-parse-url', 'color', 'blue', '456'],\n            ['test-parse-url', 'words', 'at the thing', '123'],\n            ['test-parse-url', 'words', 'omg tacos', '456']]\n\n    '''\n\n    rows = [x for x in read_file(variable_file).split('\\n') if x.strip()]\n    valid_rows = []\n\n    if len(rows) > 0:\n\n        # Validate header and rows, exit if not valid\n\n        header = rows.pop(0).split(sep)\n        validate_header(header)\n        for row in rows:\n            row = _validate_row(row, sep=sep, required_length=4)\n\n            # If the row is returned, it is valid\n\n            if row:\n                valid_rows.append(row)\n\n    return valid_rows"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a row into a list of strings", "response": "def _parse_row(row, sep=','):\n    '''parse row is a helper function to simply clean up a string, and parse\n       into a row based on a delimiter. If a required length is provided,\n       we check for this too.\n\n    '''\n    parsed = row.split(sep)\n    parsed = [x for x in parsed if x.strip()]\n    return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_header(header, required_fields=None):\n    '''validate_header ensures that the first row contains the exp_id,\n       var_name, var_value, and token. Capitalization isn't important, but\n       ordering is. This criteria is very strict, but it's reasonable\n       to require.\n \n       Parameters\n       ==========\n       header: the header row, as a list\n       required_fields: a list of required fields. We derive the required\n                        length from this list.\n\n       Does not return, instead exits if malformed. Runs silently if OK.\n\n    '''\n    if required_fields is None:\n        required_fields = ['exp_id', 'var_name', 'var_value', 'token']\n\n    # The required length of the header based on required fields\n\n    length = len(required_fields)\n\n    # This is very strict, but no reason not to be\n\n    header = _validate_row(header, required_length=length) \n    header = [x.lower() for x in header]\n\n    for idx in range(length):\n        field = header[idx].lower().strip()\n        if required_fields[idx] != field:\n            bot.error('Malformed header field %s, exiting.' %field)\n            sys.exit(1)", "response": "validate_header verifies that the header row contains the exp_id var_name var_value and token."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompile the pattern lines.", "response": "def from_lines(cls, pattern_factory, lines):\n\t\t\"\"\"\n\t\tCompiles the pattern lines.\n\n\t\t*pattern_factory* can be either the name of a registered pattern\n\t\tfactory (:class:`str`), or a :class:`~collections.abc.Callable` used\n\t\tto compile patterns. It must accept an uncompiled pattern (:class:`str`)\n\t\tand return the compiled pattern (:class:`.Pattern`).\n\n\t\t*lines* (:class:`~collections.abc.Iterable`) yields each uncompiled\n\t\tpattern (:class:`str`). This simply has to yield each line so it can\n\t\tbe a :class:`file` (e.g., from :func:`open` or :class:`io.StringIO`)\n\t\tor the result from :meth:`str.splitlines`.\n\n\t\tReturns the :class:`PathSpec` instance.\n\t\t\"\"\"\n\t\tif isinstance(pattern_factory, string_types):\n\t\t\tpattern_factory = util.lookup_pattern(pattern_factory)\n\t\tif not callable(pattern_factory):\n\t\t\traise TypeError(\"pattern_factory:{!r} is not callable.\".format(pattern_factory))\n\n\t\tif isinstance(lines, (bytes, unicode)):\n\t\t\traise TypeError(\"lines:{!r} is not an iterable.\".format(lines))\n\n\t\tlines = [pattern_factory(line) for line in lines if line]\n\t\treturn cls(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match_file(self, file, separators=None):\n\t\tnorm_file = util.normalize_file(file, separators=separators)\n\t\treturn util.match_file(self.patterns, norm_file)", "response": "Matches the file to this path - spec."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match_files(self, files, separators=None):\n\t\tif isinstance(files, (bytes, unicode)):\n\t\t\traise TypeError(\"files:{!r} is not an iterable.\".format(files))\n\n\t\tfile_map = util.normalize_files(files, separators=separators)\n\t\tmatched_files = util.match_files(self.patterns, iterkeys(file_map))\n\t\tfor path in matched_files:\n\t\t\tyield file_map[path]", "response": "Matches the files to this path - spec."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwalks the specified root path for all files and matches them to thispath - spec.", "response": "def match_tree(self, root, on_error=None, follow_links=None):\n\t\t\"\"\"\n\t\tWalks the specified root path for all files and matches them to this\n\t\tpath-spec.\n\n\t\t*root* (:class:`str`) is the root directory to search for files.\n\n\t\t*on_error* (:class:`~collections.abc.Callable` or :data:`None`)\n\t\toptionally is the error handler for file-system exceptions. See\n\t\t:func:`~pathspec.util.iter_tree` for more information.\n\n\n\t\t*follow_links* (:class:`bool` or :data:`None`) optionally is whether\n\t\tto walk symbolik links that resolve to directories. See\n\t\t:func:`~pathspec.util.iter_tree` for more information.\n\n\t\tReturns the matched files (:class:`~collections.abc.Iterable` of\n\t\t:class:`str`).\n\t\t\"\"\"\n\t\tfiles = util.iter_tree(root, on_error=on_error, follow_links=follow_links)\n\t\treturn self.match_files(files)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pattern_to_regex(cls, pattern):\n\t\tif isinstance(pattern, unicode):\n\t\t\treturn_type = unicode\n\t\telif isinstance(pattern, bytes):\n\t\t\treturn_type = bytes\n\t\t\tpattern = pattern.decode(_BYTES_ENCODING)\n\t\telse:\n\t\t\traise TypeError(\"pattern:{!r} is not a unicode or byte string.\".format(pattern))\n\n\t\tpattern = pattern.strip()\n\n\t\tif pattern.startswith('#'):\n\t\t\t# A pattern starting with a hash ('#') serves as a comment\n\t\t\t# (neither includes nor excludes files). Escape the hash with a\n\t\t\t# back-slash to match a literal hash (i.e., '\\#').\n\t\t\tregex = None\n\t\t\tinclude = None\n\n\t\telif pattern == '/':\n\t\t\t# EDGE CASE: According to `git check-ignore` (v2.4.1), a single\n\t\t\t# '/' does not match any file.\n\t\t\tregex = None\n\t\t\tinclude = None\n\n\t\telif pattern:\n\n\t\t\tif pattern.startswith('!'):\n\t\t\t\t# A pattern starting with an exclamation mark ('!') negates the\n\t\t\t\t# pattern (exclude instead of include). Escape the exclamation\n\t\t\t\t# mark with a back-slash to match a literal exclamation mark\n\t\t\t\t# (i.e., '\\!').\n\t\t\t\tinclude = False\n\t\t\t\t# Remove leading exclamation mark.\n\t\t\t\tpattern = pattern[1:]\n\t\t\telse:\n\t\t\t\tinclude = True\n\n\t\t\tif pattern.startswith('\\\\'):\n\t\t\t\t# Remove leading back-slash escape for escaped hash ('#') or\n\t\t\t\t# exclamation mark ('!').\n\t\t\t\tpattern = pattern[1:]\n\n\t\t\t# Split pattern into segments.\n\t\t\tpattern_segs = pattern.split('/')\n\n\t\t\t# Normalize pattern to make processing easier.\n\n\t\t\tif not pattern_segs[0]:\n\t\t\t\t# A pattern beginning with a slash ('/') will only match paths\n\t\t\t\t# directly on the root directory instead of any descendant\n\t\t\t\t# paths. So, remove empty first segment to make pattern relative\n\t\t\t\t# to root.\n\t\t\t\tdel pattern_segs[0]\n\n\t\t\telif len(pattern_segs) == 1 or (len(pattern_segs) == 2 and not pattern_segs[1]):\n\t\t\t\t# A single pattern without a beginning slash ('/') will match\n\t\t\t\t# any descendant path. This is equivalent to \"**/{pattern}\". So,\n\t\t\t\t# prepend with double-asterisks to make pattern relative to\n\t\t\t\t# root.\n\t\t\t\t# EDGE CASE: This also holds for a single pattern with a\n\t\t\t\t# trailing slash (e.g. dir/).\n\t\t\t\tif pattern_segs[0] != '**':\n\t\t\t\t\tpattern_segs.insert(0, '**')\n\n\t\t\telse:\n\t\t\t\t# EDGE CASE: A pattern without a beginning slash ('/') but\n\t\t\t\t# contains at least one prepended directory (e.g.\n\t\t\t\t# \"dir/{pattern}\") should not match \"**/dir/{pattern}\",\n\t\t\t\t# according to `git check-ignore` (v2.4.1).\n\t\t\t\tpass\n\n\t\t\tif not pattern_segs[-1] and len(pattern_segs) > 1:\n\t\t\t\t# A pattern ending with a slash ('/') will match all descendant\n\t\t\t\t# paths if it is a directory but not if it is a regular file.\n\t\t\t\t# This is equivilent to \"{pattern}/**\". So, set last segment to\n\t\t\t\t# double asterisks to include all descendants.\n\t\t\t\tpattern_segs[-1] = '**'\n\n\t\t\t# Build regular expression from pattern.\n\t\t\toutput = ['^']\n\t\t\tneed_slash = False\n\t\t\tend = len(pattern_segs) - 1\n\t\t\tfor i, seg in enumerate(pattern_segs):\n\t\t\t\tif seg == '**':\n\t\t\t\t\tif i == 0 and i == end:\n\t\t\t\t\t\t# A pattern consisting solely of double-asterisks ('**')\n\t\t\t\t\t\t# will match every path.\n\t\t\t\t\t\toutput.append('.+')\n\t\t\t\t\telif i == 0:\n\t\t\t\t\t\t# A normalized pattern beginning with double-asterisks\n\t\t\t\t\t\t# ('**') will match any leading path segments.\n\t\t\t\t\t\toutput.append('(?:.+/)?')\n\t\t\t\t\t\tneed_slash = False\n\t\t\t\t\telif i == end:\n\t\t\t\t\t\t# A normalized pattern ending with double-asterisks ('**')\n\t\t\t\t\t\t# will match any trailing path segments.\n\t\t\t\t\t\toutput.append('/.*')\n\t\t\t\t\telse:\n\t\t\t\t\t\t# A pattern with inner double-asterisks ('**') will match\n\t\t\t\t\t\t# multiple (or zero) inner path segments.\n\t\t\t\t\t\toutput.append('(?:/.+)?')\n\t\t\t\t\t\tneed_slash = True\n\t\t\t\telif seg == '*':\n\t\t\t\t\t# Match single path segment.\n\t\t\t\t\tif need_slash:\n\t\t\t\t\t\toutput.append('/')\n\t\t\t\t\toutput.append('[^/]+')\n\t\t\t\t\tneed_slash = True\n\t\t\t\telse:\n\t\t\t\t\t# Match segment glob pattern.\n\t\t\t\t\tif need_slash:\n\t\t\t\t\t\toutput.append('/')\n\t\t\t\t\toutput.append(cls._translate_segment_glob(seg))\n\t\t\t\t\tif i == end and include is True:\n\t\t\t\t\t\t# A pattern ending without a slash ('/') will match a file\n\t\t\t\t\t\t# or a directory (with paths underneath it). E.g., \"foo\"\n\t\t\t\t\t\t# matches \"foo\", \"foo/bar\", \"foo/bar/baz\", etc.\n\t\t\t\t\t\t# EDGE CASE: However, this does not hold for exclusion cases\n\t\t\t\t\t\t# according to `git check-ignore` (v2.4.1).\n\t\t\t\t\t\toutput.append('(?:/.*)?')\n\t\t\t\t\tneed_slash = True\n\t\t\toutput.append('$')\n\t\t\tregex = ''.join(output)\n\n\t\telse:\n\t\t\t# A blank pattern is a null-operation (neither includes nor\n\t\t\t# excludes files).\n\t\t\tregex = None\n\t\t\tinclude = None\n\n\t\tif regex is not None and return_type is bytes:\n\t\t\tregex = regex.encode(_BYTES_ENCODING)\n\n\t\treturn regex, include", "response": "Convert a pattern into a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntranslate the glob pattern to a regular expression. This is used in the constructor to translate a path segment glob pattern to its corresponding regular expression. *pattern* (:class:`str`) is the glob pattern. Returns the regular expression (:class:`str`).", "response": "def _translate_segment_glob(pattern):\n\t\t\"\"\"\n\t\tTranslates the glob pattern to a regular expression. This is used in\n\t\tthe constructor to translate a path segment glob pattern to its\n\t\tcorresponding regular expression.\n\n\t\t*pattern* (:class:`str`) is the glob pattern.\n\n\t\tReturns the regular expression (:class:`str`).\n\t\t\"\"\"\n\t\t# NOTE: This is derived from `fnmatch.translate()` and is similar to\n\t\t# the POSIX function `fnmatch()` with the `FNM_PATHNAME` flag set.\n\n\t\tescape = False\n\t\tregex = ''\n\t\ti, end = 0, len(pattern)\n\t\twhile i < end:\n\t\t\t# Get next character.\n\t\t\tchar = pattern[i]\n\t\t\ti += 1\n\n\t\t\tif escape:\n\t\t\t\t# Escape the character.\n\t\t\t\tescape = False\n\t\t\t\tregex += re.escape(char)\n\n\t\t\telif char == '\\\\':\n\t\t\t\t# Escape character, escape next character.\n\t\t\t\tescape = True\n\n\t\t\telif char == '*':\n\t\t\t\t# Multi-character wildcard. Match any string (except slashes),\n\t\t\t\t# including an empty string.\n\t\t\t\tregex += '[^/]*'\n\n\t\t\telif char == '?':\n\t\t\t\t# Single-character wildcard. Match any single character (except\n\t\t\t\t# a slash).\n\t\t\t\tregex += '[^/]'\n\n\t\t\telif char == '[':\n\t\t\t\t# Braket expression wildcard. Except for the beginning\n\t\t\t\t# exclamation mark, the whole braket expression can be used\n\t\t\t\t# directly as regex but we have to find where the expression\n\t\t\t\t# ends.\n\t\t\t\t# - \"[][!]\" matchs ']', '[' and '!'.\n\t\t\t\t# - \"[]-]\" matchs ']' and '-'.\n\t\t\t\t# - \"[!]a-]\" matchs any character except ']', 'a' and '-'.\n\t\t\t\tj = i\n\t\t\t\t# Pass brack expression negation.\n\t\t\t\tif j < end and pattern[j] == '!':\n\t\t\t\t\tj += 1\n\t\t\t\t# Pass first closing braket if it is at the beginning of the\n\t\t\t\t# expression.\n\t\t\t\tif j < end and pattern[j] == ']':\n\t\t\t\t\tj += 1\n\t\t\t\t# Find closing braket. Stop once we reach the end or find it.\n\t\t\t\twhile j < end and pattern[j] != ']':\n\t\t\t\t\tj += 1\n\n\t\t\t\tif j < end:\n\t\t\t\t\t# Found end of braket expression. Increment j to be one past\n\t\t\t\t\t# the closing braket:\n\t\t\t\t\t#\n\t\t\t\t\t#  [...]\n\t\t\t\t\t#   ^   ^\n\t\t\t\t\t#   i   j\n\t\t\t\t\t#\n\t\t\t\t\tj += 1\n\t\t\t\t\texpr = '['\n\n\t\t\t\t\tif pattern[i] == '!':\n\t\t\t\t\t\t# Braket expression needs to be negated.\n\t\t\t\t\t\texpr += '^'\n\t\t\t\t\t\ti += 1\n\t\t\t\t\telif pattern[i] == '^':\n\t\t\t\t\t\t# POSIX declares that the regex braket expression negation\n\t\t\t\t\t\t# \"[^...]\" is undefined in a glob pattern. Python's\n\t\t\t\t\t\t# `fnmatch.translate()` escapes the caret ('^') as a\n\t\t\t\t\t\t# literal. To maintain consistency with undefined behavior,\n\t\t\t\t\t\t# I am escaping the '^' as well.\n\t\t\t\t\t\texpr += '\\\\^'\n\t\t\t\t\t\ti += 1\n\n\t\t\t\t\t# Build regex braket expression. Escape slashes so they are\n\t\t\t\t\t# treated as literal slashes by regex as defined by POSIX.\n\t\t\t\t\texpr += pattern[i:j].replace('\\\\', '\\\\\\\\')\n\n\t\t\t\t\t# Add regex braket expression to regex result.\n\t\t\t\t\tregex += expr\n\n\t\t\t\t\t# Set i to one past the closing braket.\n\t\t\t\t\ti = j\n\n\t\t\t\telse:\n\t\t\t\t\t# Failed to find closing braket, treat opening braket as a\n\t\t\t\t\t# braket literal instead of as an expression.\n\t\t\t\t\tregex += '\\\\['\n\n\t\t\telse:\n\t\t\t\t# Regular character, escape it for regex.\n\t\t\t\tregex += re.escape(char)\n\n\t\treturn regex"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pattern_to_regex(cls, *args, **kw):\n\t\tcls._deprecated()\n\t\treturn super(GitIgnorePattern, cls).pattern_to_regex(*args, **kw)", "response": "Override to add deprecation warning to GitIgnorePattern. pattern_to_regex."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_tree(root, on_error=None, follow_links=None):\n\tif on_error is not None and not callable(on_error):\n\t\traise TypeError(\"on_error:{!r} is not callable.\".format(on_error))\n\n\tif follow_links is None:\n\t\tfollow_links = True\n\n\tfor file_rel in _iter_tree_next(os.path.abspath(root), '', {}, on_error, follow_links):\n\t\tyield file_rel", "response": "Walks the specified directory for all files and yields the absolute paths to each file in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _iter_tree_next(root_full, dir_rel, memo, on_error, follow_links):\n\tdir_full = os.path.join(root_full, dir_rel)\n\tdir_real = os.path.realpath(dir_full)\n\n\t# Remember each encountered ancestor directory and its canonical\n\t# (real) path. If a canonical path is encountered more than once,\n\t# recursion has occurred.\n\tif dir_real not in memo:\n\t\tmemo[dir_real] = dir_rel\n\telse:\n\t\traise RecursionError(real_path=dir_real, first_path=memo[dir_real], second_path=dir_rel)\n\n\tfor node in os.listdir(dir_full):\n\t\tnode_rel = os.path.join(dir_rel, node)\n\t\tnode_full = os.path.join(root_full, node_rel)\n\n\t\t# Inspect child node.\n\t\ttry:\n\t\t\tnode_stat = os.lstat(node_full)\n\t\texcept OSError as e:\n\t\t\tif on_error is not None:\n\t\t\t\ton_error(e)\n\t\t\tcontinue\n\n\t\tif stat.S_ISLNK(node_stat.st_mode):\n\t\t\t# Child node is a link, inspect the target node.\n\t\t\tis_link = True\n\t\t\ttry:\n\t\t\t\tnode_stat = os.stat(node_full)\n\t\t\texcept OSError as e:\n\t\t\t\tif on_error is not None:\n\t\t\t\t\ton_error(e)\n\t\t\t\tcontinue\n\t\telse:\n\t\t\tis_link = False\n\n\t\tif stat.S_ISDIR(node_stat.st_mode) and (follow_links or not is_link):\n\t\t\t# Child node is a directory, recurse into it and yield its\n\t\t\t# decendant files.\n\t\t\tfor file_rel in _iter_tree_next(root_full, node_rel, memo, on_error, follow_links):\n\t\t\t\tyield file_rel\n\n\t\telif stat.S_ISREG(node_stat.st_mode):\n\t\t\t# Child node is a file, yield it.\n\t\t\tyield node_rel\n\n\t# NOTE: Make sure to remove the canonical (real) path of the directory\n\t# from the ancestors memo once we are done with it. This allows the\n\t# same directory to appear multiple times. If this is not done, the\n\t# second occurance of the directory will be incorrectly interpreted as\n\t# a recursion. See <https://github.com/cpburnz/python-path-specification/pull/7>.\n\tdel memo[dir_real]", "response": "Iterate the directory tree and return the next entry in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch the file to the patterns. contains the patterns to use. contains the patterns to use. returns a boolean indicating if the file is matched.", "response": "def match_file(patterns, file):\n\t\"\"\"\n\tMatches the file to the patterns.\n\n\t*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)\n\tcontains the patterns to use.\n\n\t*file* (:class:`str`) is the normalized file path to be matched\n\tagainst *patterns*.\n\n\tReturns :data:`True` if *file* matched; otherwise, :data:`False`.\n\t\"\"\"\n\tmatched = False\n\tfor pattern in patterns:\n\t\tif pattern.include is not None:\n\t\t\tif file in pattern.match((file,)):\n\t\t\t\tmatched = pattern.include\n\treturn matched"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmatches the files to the patterns.", "response": "def match_files(patterns, files):\n\t\"\"\"\n\tMatches the files to the patterns.\n\n\t*patterns* (:class:`~collections.abc.Iterable` of :class:`~pathspec.pattern.Pattern`)\n\tcontains the patterns to use.\n\n\t*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains\n\tthe normalized file paths to be matched against *patterns*.\n\n\tReturns the matched files (:class:`set` of :class:`str`).\n\t\"\"\"\n\tall_files = files if isinstance(files, collection_type) else list(files)\n\treturn_files = set()\n\tfor pattern in patterns:\n\t\tif pattern.include is not None:\n\t\t\tresult_files = pattern.match(all_files)\n\t\t\tif pattern.include:\n\t\t\t\treturn_files.update(result_files)\n\t\t\telse:\n\t\t\t\treturn_files.difference_update(result_files)\n\treturn return_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_file(file, separators=None):\n\t# Normalize path separators.\n\tif separators is None:\n\t\tseparators = NORMALIZE_PATH_SEPS\n\tnorm_file = file\n\tfor sep in separators:\n\t\tnorm_file = norm_file.replace(sep, posixpath.sep)\n\n\t# Remove current directory prefix.\n\tif norm_file.startswith('./'):\n\t\tnorm_file = norm_file[2:]\n\n\treturn norm_file", "response": "Normalizes the file path to use the POSIX path separator."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nnormalizes the file paths to use the POSIX path separator.", "response": "def normalize_files(files, separators=None):\n\t\"\"\"\n\tNormalizes the file paths to use the POSIX path separator.\n\n\t*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains\n\tthe file paths to be normalized.\n\n\t*separators* (:class:`~collections.abc.Collection` of :class:`str`; or\n\t:data:`None`) optionally contains the path separators to normalize.\n\tSee :func:`normalize_file` for more information.\n\n\tReturns a :class:`dict` mapping the each normalized file path (:class:`str`)\n\tto the original file path (:class:`str`)\n\t\"\"\"\n\tnorm_files = {}\n\tfor path in files:\n\t\tnorm_files[normalize_file(path, separators=separators)] = path\n\treturn norm_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a pattern factory.", "response": "def register_pattern(name, pattern_factory, override=None):\n\t\"\"\"\n\tRegisters the specified pattern factory.\n\n\t*name* (:class:`str`) is the name to register the pattern factory\n\tunder.\n\n\t*pattern_factory* (:class:`~collections.abc.Callable`) is used to\n\tcompile patterns. It must accept an uncompiled pattern (:class:`str`)\n\tand return the compiled pattern (:class:`.Pattern`).\n\n\t*override* (:class:`bool` or :data:`None`) optionally is whether to\n\tallow overriding an already registered pattern under the same name\n\t(:data:`True`), instead of raising an :exc:`AlreadyRegisteredError`\n\t(:data:`False`). Default is :data:`None` for :data:`False`.\n\t\"\"\"\n\tif not isinstance(name, string_types):\n\t\traise TypeError(\"name:{!r} is not a string.\".format(name))\n\tif not callable(pattern_factory):\n\t\traise TypeError(\"pattern_factory:{!r} is not callable.\".format(pattern_factory))\n\tif name in _registered_patterns and not override:\n\t\traise AlreadyRegisteredError(name, _registered_patterns[name])\n\t_registered_patterns[name] = pattern_factory"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the error message.", "response": "def message(self):\n\t\t\"\"\"\n\t\t*message* (:class:`str`) is the error message.\n\t\t\"\"\"\n\t\treturn \"Real path {real!r} was encountered at {first!r} and then {second!r}.\".format(\n\t\t\treal=self.real_path,\n\t\t\tfirst=self.first_path,\n\t\t\tsecond=self.second_path,\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmatches this pattern against the specified files.", "response": "def match(self, files):\n\t\t\"\"\"\n\t\tMatches this pattern against the specified files.\n\n\t\t*files* (:class:`~collections.abc.Iterable` of :class:`str`) contains\n\t\teach file relative to the root directory (e.g., ``\"relative/path/to/file\"``).\n\n\t\tReturns an :class:`~collections.abc.Iterable` yielding each matched\n\t\tfile path (:class:`str`).\n\t\t\"\"\"\n\t\traise NotImplementedError(\"{}.{} must override match().\".format(self.__class__.__module__, self.__class__.__name__))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch this pattern against the specified files.", "response": "def match(self, files):\n\t\t\"\"\"\n\t\tMatches this pattern against the specified files.\n\n\t\t*files* (:class:`~collections.abc.Iterable` of :class:`str`)\n\t\tcontains each file relative to the root directory (e.g., \"relative/path/to/file\").\n\n\t\tReturns an :class:`~collections.abc.Iterable` yielding each matched\n\t\tfile path (:class:`str`).\n\t\t\"\"\"\n\t\tif self.include is not None:\n\t\t\tfor path in files:\n\t\t\t\tif self.regex.match(path) is not None:\n\t\t\t\t\tyield path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a User to a cached instance representation.", "response": "def user_default_serializer(self, obj):\n        \"\"\"Convert a User to a cached instance representation.\"\"\"\n        if not obj:\n            return None\n        self.user_default_add_related_pks(obj)\n        return dict((\n            ('id', obj.id),\n            ('username', obj.username),\n            self.field_to_json('DateTime', 'date_joined', obj.date_joined),\n            self.field_to_json(\n                'PKList', 'votes', model=Choice, pks=obj._votes_pks),\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_default_loader(self, pk):\n        try:\n            obj = User.objects.get(pk=pk)\n        except User.DoesNotExist:\n            return None\n        else:\n            self.user_default_add_related_pks(obj)\n            return obj", "response": "Load a User from the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_default_add_related_pks(self, obj):\n        if not hasattr(obj, '_votes_pks'):\n            obj._votes_pks = list(obj.votes.values_list('pk', flat=True))", "response": "Add related primary keys to a User instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninvalidating cached items when the Group changes.", "response": "def group_default_invalidator(self, obj):\n        \"\"\"Invalidated cached items when the Group changes.\"\"\"\n        user_pks = User.objects.values_list('pk', flat=True)\n        return [('User', pk, False) for pk in user_pks]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef question_default_serializer(self, obj):\n        if not obj:\n            return None\n        self.question_default_add_related_pks(obj)\n        return dict((\n            ('id', obj.id),\n            ('question_text', obj.question_text),\n            self.field_to_json('DateTime', 'pub_date', obj.pub_date),\n            self.field_to_json(\n                'PKList', 'choices', model=Choice, pks=obj._choice_pks),\n        ))", "response": "Convert a Question to a cached instance representation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a Question from the database.", "response": "def question_default_loader(self, pk):\n        \"\"\"Load a Question from the database.\"\"\"\n        try:\n            obj = Question.objects.get(pk=pk)\n        except Question.DoesNotExist:\n            return None\n        else:\n            self.question_default_add_related_pks(obj)\n            return obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef question_default_add_related_pks(self, obj):\n        if not hasattr(obj, '_choice_pks'):\n            obj._choice_pks = list(obj.choices.values_list('pk', flat=True))", "response": "Add related primary keys to a Question instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef choice_default_serializer(self, obj):\n        if not obj:\n            return None\n        self.choice_default_add_related_pks(obj)\n        return dict((\n            ('id', obj.id),\n            ('choice_text', obj.choice_text),\n            self.field_to_json(\n                'PK', 'question', model=Question, pk=obj.question_id),\n            self.field_to_json(\n                'PKList', 'voters', model=User, pks=obj._voter_pks)\n        ))", "response": "Convert a Choice to a cached instance representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a Choice from the database.", "response": "def choice_default_loader(self, pk):\n        \"\"\"Load a Choice from the database.\"\"\"\n        try:\n            obj = Choice.objects.get(pk=pk)\n        except Choice.DoesNotExist:\n            return None\n        else:\n            self.choice_default_add_related_pks(obj)\n            return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef choice_default_add_related_pks(self, obj):\n        if not hasattr(obj, '_voter_pks'):\n            obj._voter_pks = obj.voters.values_list('pk', flat=True)", "response": "Add related primary keys to a Choice instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef choice_default_invalidator(self, obj):\n        invalid = [('Question', obj.question_id, True)]\n        for pk in obj.voters.values_list('pk', flat=True):\n            invalid.append(('User', pk, False))\n        return invalid", "response": "Invalidated cached items when the Choice changes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the Django cache interface.", "response": "def cache(self):\n        \"\"\"Get the Django cache interface.\n\n        This allows disabling the cache with\n        settings.USE_DRF_INSTANCE_CACHE=False.  It also delays import so that\n        Django Debug Toolbar will record cache requests.\n        \"\"\"\n        if not self._cache:\n            use_cache = getattr(settings, 'USE_DRF_INSTANCE_CACHE', True)\n            if use_cache:\n                from django.core.cache import cache\n                self._cache = cache\n        return self._cache"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting all versions of a cached instance.", "response": "def delete_all_versions(self, model_name, obj_pk):\n        \"\"\"Delete all versions of a cached instance.\"\"\"\n        if self.cache:\n            for version in self.versions:\n                key = self.key_for(version, model_name, obj_pk)\n                self.cache.delete(key)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the model - specific caching function.", "response": "def model_function(self, model_name, version, func_name):\n        \"\"\"Return the model-specific caching function.\"\"\"\n        assert func_name in ('serializer', 'loader', 'invalidator')\n        name = \"%s_%s_%s\" % (model_name.lower(), version, func_name)\n        return getattr(self, name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the field function.", "response": "def field_function(self, type_code, func_name):\n        \"\"\"Return the field function.\"\"\"\n        assert func_name in ('to_json', 'from_json')\n        name = \"field_%s_%s\" % (type_code.lower(), func_name)\n        return getattr(self, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef field_to_json(self, type_code, key, *args, **kwargs):\n        assert ':' not in key\n        to_json = self.field_function(type_code, 'to_json')\n        key_and_type = \"%s:%s\" % (key, type_code)\n        json_value = to_json(*args, **kwargs)\n        return key_and_type, json_value", "response": "Convert a field to a JSON - serializable representation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a JSON - serializable representation back to a field.", "response": "def field_from_json(self, key_and_type, json_value):\n        \"\"\"Convert a JSON-serializable representation back to a field.\"\"\"\n        assert ':' in key_and_type\n        key, type_code = key_and_type.split(':', 1)\n        from_json = self.field_function(type_code, 'from_json')\n        value = from_json(json_value)\n        return key, value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the cached native representation for one or more objects.", "response": "def get_instances(self, object_specs, version=None):\n        \"\"\"Get the cached native representation for one or more objects.\n\n        Keyword arguments:\n        object_specs - A sequence of triples (model name, pk, obj):\n        - model name - the name of the model\n        - pk - the primary key of the instance\n        - obj - the instance, or None to load it\n        version - The cache version to use, or None for default\n\n        To get the 'new object' representation, set pk and obj to None\n\n        Return is a dictionary:\n        key - (model name, pk)\n        value - (native representation, pk, object or None)\n        \"\"\"\n        ret = dict()\n        spec_keys = set()\n        cache_keys = []\n        version = version or self.default_version\n\n        # Construct all the cache keys to fetch\n        for model_name, obj_pk, obj in object_specs:\n            assert model_name\n            assert obj_pk\n\n            # Get cache keys to fetch\n            obj_key = self.key_for(version, model_name, obj_pk)\n            spec_keys.add((model_name, obj_pk, obj, obj_key))\n            cache_keys.append(obj_key)\n\n        # Fetch the cache keys\n        if cache_keys and self.cache:\n            cache_vals = self.cache.get_many(cache_keys)\n        else:\n            cache_vals = {}\n\n        # Use cached representations, or recreate\n        cache_to_set = {}\n        for model_name, obj_pk, obj, obj_key in spec_keys:\n\n            # Load cached objects\n            obj_val = cache_vals.get(obj_key)\n            obj_native = json.loads(obj_val) if obj_val else None\n\n            # Invalid or not set - load from database\n            if not obj_native:\n                if not obj:\n                    loader = self.model_function(model_name, version, 'loader')\n                    obj = loader(obj_pk)\n                serializer = self.model_function(\n                    model_name, version, 'serializer')\n                obj_native = serializer(obj) or {}\n                if obj_native:\n                    cache_to_set[obj_key] = json.dumps(obj_native)\n\n            # Get fields to convert\n            keys = [key for key in obj_native.keys() if ':' in key]\n            for key in keys:\n                json_value = obj_native.pop(key)\n                name, value = self.field_from_json(key, json_value)\n                assert name not in obj_native\n                obj_native[name] = value\n\n            if obj_native:\n                ret[(model_name, obj_pk)] = (obj_native, obj_key, obj)\n\n        # Save any new cached representations\n        if cache_to_set and self.cache:\n            self.cache.set_many(cache_to_set)\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_instance(\n            self, model_name, pk, instance=None, version=None,\n            update_only=False):\n        \"\"\"Create or update a cached instance.\n\n        Keyword arguments are:\n        model_name - The name of the model\n        pk - The primary key of the instance\n        instance - The Django model instance, or None to load it\n        versions - Version to update, or None for all\n        update_only - If False (default), then missing cache entries will be\n            populated and will cause follow-on invalidation.  If True, then\n            only entries already in the cache will be updated and cause\n            follow-on invalidation.\n\n        Return is a list of tuples (model name, pk, immediate) that also needs\n        to be updated.\n        \"\"\"\n        versions = [version] if version else self.versions\n        invalid = []\n        for version in versions:\n            serializer = self.model_function(model_name, version, 'serializer')\n            loader = self.model_function(model_name, version, 'loader')\n            invalidator = self.model_function(\n                model_name, version, 'invalidator')\n            if serializer is None and loader is None and invalidator is None:\n                continue\n\n            if self.cache is None:\n                continue\n\n            # Try to load the instance\n            if not instance:\n                instance = loader(pk)\n\n            if serializer:\n                # Get current value, if in cache\n                key = self.key_for(version, model_name, pk)\n                current_raw = self.cache.get(key)\n                current = json.loads(current_raw) if current_raw else None\n\n                # Get new value\n                if update_only and current_raw is None:\n                    new = None\n                else:\n                    new = serializer(instance)\n                deleted = not instance\n\n                # If cache is invalid, update cache\n                invalidate = (current != new) or deleted\n                if invalidate:\n                    if deleted:\n                        self.cache.delete(key)\n                    else:\n                        self.cache.set(key, json.dumps(new))\n            else:\n                invalidate = True\n\n            # Invalidate upstream caches\n            if instance and invalidate:\n                for upstream in invalidator(instance):\n                    if isinstance(upstream, str):\n                        self.cache.delete(upstream)\n                    else:\n                        m, i, immediate = upstream\n                        if immediate:\n                            invalidate_key = self.key_for(version, m, i)\n                            self.cache.delete(invalidate_key)\n                        invalid.append((m, i, version))\n        return invalid", "response": "Create or update a cached instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef field_date_to_json(self, day):\n        if isinstance(day, six.string_types):\n            day = parse_date(day)\n        return [day.year, day.month, day.day] if day else None", "response": "Convert a date triple to a date triple."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a UTC timestamp to a UTC datetime.", "response": "def field_datetime_from_json(self, json_val):\n        \"\"\"Convert a UTC timestamp to a UTC datetime.\"\"\"\n        if type(json_val) == int:\n            seconds = int(json_val)\n            dt = datetime.fromtimestamp(seconds, utc)\n        elif json_val is None:\n            dt = None\n        else:\n            seconds, microseconds = [int(x) for x in json_val.split('.')]\n            dt = datetime.fromtimestamp(seconds, utc)\n            dt += timedelta(microseconds=microseconds)\n        return dt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef field_datetime_to_json(self, dt):\n        if isinstance(dt, six.string_types):\n            dt = parse_datetime(dt)\n        if not dt:\n            return None\n        ts = timegm(dt.utctimetuple())\n        if dt.microsecond:\n            return \"{0}.{1:0>6d}\".format(ts, dt.microsecond)\n        else:\n            return ts", "response": "Convert a datetime to a UTC timestamp w / microsecond resolution."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts json_val to a timedelta object.", "response": "def field_timedelta_from_json(self, json_val):\n        \"\"\"Convert json_val to a timedelta object.\n\n        json_val contains total number of seconds in the timedelta.\n        If json_val is a string it will be converted to a float.\n        \"\"\"\n        if isinstance(json_val, str):\n            return timedelta(seconds=float(json_val))\n        elif json_val is None:\n            return None\n        else:\n            return timedelta(seconds=json_val)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts timedelta to value containing total number of seconds.", "response": "def field_timedelta_to_json(self, td):\n        \"\"\"Convert timedelta to value containing total number of seconds.\n\n        If there are fractions of a second the return value will be a\n        string, otherwise it will be an int.\n        \"\"\"\n        if isinstance(td, six.string_types):\n            td = parse_duration(td)\n        if not td:\n            return None\n        if td.microseconds > 0:\n            return str(td.total_seconds())\n        else:\n            return int(td.total_seconds())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a PkOnlyQueryset from a JSON dict.", "response": "def field_pklist_from_json(self, data):\n        \"\"\"Load a PkOnlyQueryset from a JSON dict.\n\n        This uses the same format as cached_queryset_from_json\n        \"\"\"\n        model = get_model(data['app'], data['model'])\n        return PkOnlyQueryset(self, model, data['pks'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a list of primary keys to a JSON dict.", "response": "def field_pklist_to_json(self, model, pks):\n        \"\"\"Convert a list of primary keys to a JSON dict.\n\n        This uses the same format as cached_queryset_to_json\n        \"\"\"\n        app_label = model._meta.app_label\n        model_name = model._meta.model_name\n        return {\n            'app': app_label,\n            'model': model_name,\n            'pks': list(pks),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a PkOnlyModel from a JSON dict.", "response": "def field_pk_from_json(self, data):\n        \"\"\"Load a PkOnlyModel from a JSON dict.\"\"\"\n        model = get_model(data['app'], data['model'])\n        return PkOnlyModel(self, model, data['pk'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a primary key to a JSON dict.", "response": "def field_pk_to_json(self, model, pk):\n        \"\"\"Convert a primary key to a JSON dict.\"\"\"\n        app_label = model._meta.app_label\n        model_name = model._meta.model_name\n        return {\n            'app': app_label,\n            'model': model_name,\n            'pk': pk,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef choice_voters_changed_update_cache(\n        sender, instance, action, reverse, model, pk_set, **kwargs):\n    \"\"\"Update cache when choice.voters changes.\"\"\"\n    if action not in ('post_add', 'post_remove', 'post_clear'):\n        # post_clear is not handled, because clear is called in\n        # django.db.models.fields.related.ReverseManyRelatedObjects.__set__\n        # before setting the new order\n        return\n\n    if model == User:\n        assert type(instance) == Choice\n        choices = [instance]\n        if pk_set:\n            users = list(User.objects.filter(pk__in=pk_set))\n        else:\n            users = []\n    else:\n        if pk_set:\n            choices = list(Choice.objects.filter(pk__in=pk_set))\n        else:\n            choices = []\n        users = [instance]\n\n    from .tasks import update_cache_for_instance\n    for choice in choices:\n        update_cache_for_instance('Choice', choice.pk, choice)\n    for user in users:\n        update_cache_for_instance('User', user.pk, user)", "response": "Update cache when choice. voters changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post_delete_update_cache(sender, instance, **kwargs):\n    name = sender.__name__\n    if name in cached_model_names:\n        from .tasks import update_cache_for_instance\n        update_cache_for_instance(name, instance.pk, instance)", "response": "Update the cache when an instance is deleted."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the cache when an instance is created or modified.", "response": "def post_save_update_cache(sender, instance, created, raw, **kwargs):\n    \"\"\"Update the cache when an instance is created or modified.\"\"\"\n    if raw:\n        return\n    name = sender.__name__\n    if name in cached_model_names:\n        delay_cache = getattr(instance, '_delay_cache', False)\n        if not delay_cache:\n            from .tasks import update_cache_for_instance\n            update_cache_for_instance(name, instance.pk, instance)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the queryset for the action.", "response": "def get_queryset(self):\n        \"\"\"Get the queryset for the action.\n\n        If action is read action, return a CachedQueryset\n        Otherwise, return a Django queryset\n        \"\"\"\n        queryset = super(CachedViewMixin, self).get_queryset()\n        if self.action in ('list', 'retrieve'):\n            return CachedQueryset(self.get_queryset_cache(), queryset=queryset)\n        else:\n            return queryset"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the object that is displaying.", "response": "def get_object(self, queryset=None):\n        \"\"\"\n        Return the object the view is displaying.\n\n        Same as rest_framework.generics.GenericAPIView, but:\n        - Failed assertions instead of deprecations\n        \"\"\"\n        # Determine the base queryset to use.\n        assert queryset is None, \"Passing a queryset is disabled\"\n        queryset = self.filter_queryset(self.get_queryset())\n\n        # Perform the lookup filtering.\n        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field\n        lookup = self.kwargs.get(lookup_url_kwarg, None)\n        assert lookup is not None, \"Other lookup methods are disabled\"\n        filter_kwargs = {self.lookup_field: lookup}\n        obj = self.get_object_or_404(queryset, **filter_kwargs)\n\n        # May raise a permission denied\n        self.check_object_permissions(self.request, obj)\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an object or raise a 404.", "response": "def get_object_or_404(self, queryset, *filter_args, **filter_kwargs):\n        \"\"\"Return an object or raise a 404.\n\n        Same as Django's standard shortcut, but make sure to raise 404\n        if the filter_kwargs don't match the required types.\n        \"\"\"\n        if isinstance(queryset, CachedQueryset):\n            try:\n                return queryset.get(*filter_args, **filter_kwargs)\n            except queryset.model.DoesNotExist:\n                raise Http404(\n                    'No %s matches the given query.' % queryset.model)\n        else:\n            return get_object_or_404(queryset, *filter_args, **filter_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves the object. This returns default if present otherwise raises a TypeError.", "response": "def r(self, **kwargs):\n        \"\"\"\n        Resolve the object.\n\n        This returns default (if present) or fails on an Empty.\n        \"\"\"\n        # by using kwargs we ensure that usage of positional arguments, as if\n        # this object were another kind of function, will fail-fast and raise\n        # a TypeError\n        if 'default' in kwargs:\n            default = kwargs.pop('default')\n            if kwargs:\n                raise TypeError(\n                    \"Unexpected argument: {}\".format(repr(next(iter(kwargs))))\n                )\n            return default\n        else:\n            raise JSaneException(\n                \"Key does not exist: {}\".format(repr(self._key_name))\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nresolve the object. This will always succeed, since, if a lookup fails, an Empty instance will be returned farther upstream.", "response": "def r(self, **kwargs):\n        \"\"\"\n        Resolve the object.\n\n        This will always succeed, since, if a lookup fails, an Empty\n        instance will be returned farther upstream.\n        \"\"\"\n        # by using kwargs we ensure that usage of positional arguments, as if\n        # this object were another kind of function, will fail-fast and raise\n        # a TypeError\n        kwargs.pop('default', None)\n        if kwargs:\n            raise TypeError(\n                \"Unexpected argument: {}\".format(repr(next(iter(kwargs))))\n            )\n        return self._obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the cache for an instance with cascading updates.", "response": "def update_cache_for_instance(\n        model_name, instance_pk, instance=None, version=None):\n    \"\"\"Update the cache for an instance, with cascading updates.\"\"\"\n    cache = SampleCache()\n    invalid = cache.update_instance(model_name, instance_pk, instance, version)\n    for invalid_name, invalid_pk, invalid_version in invalid:\n        update_cache_for_instance.delay(\n            invalid_name, invalid_pk, version=invalid_version)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the primary keys as a list.", "response": "def values_list(self, *args, **kwargs):\n        \"\"\"Return the primary keys as a list.\n\n        The only valid call is values_list('pk', flat=True)\n        \"\"\"\n        flat = kwargs.pop('flat', False)\n        assert flat is True\n        assert len(args) == 1\n        assert args[0] == self.model._meta.pk.name\n        return self.pks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count(self):\n        if self._primary_keys is None:\n            return self.queryset.count()\n        else:\n            return len(self.pks)", "response": "Return a count of instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters the base queryset.", "response": "def filter(self, **kwargs):\n        \"\"\"Filter the base queryset.\"\"\"\n        assert not self._primary_keys\n        self.queryset = self.queryset.filter(**kwargs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, *args, **kwargs):\n        assert not args\n        assert list(kwargs.keys()) == ['pk']\n        pk = kwargs['pk']\n        model_name = self.model.__name__\n        object_spec = (model_name, pk, None)\n        instances = self.cache.get_instances((object_spec,))\n        try:\n            model_data = instances[(model_name, pk)][0]\n        except KeyError:\n            raise self.model.DoesNotExist(\n                \"No match for %r with args %r, kwargs %r\" %\n                (self.model, args, kwargs))\n        else:\n            return CachedModel(self.model, model_data)", "response": "Return the single item from the filtered queryset."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload all constant generators from settings. WEBPACK_CONSTANT_PROCESSORS and concat their values.", "response": "def collect(cls):\n        \"\"\" Load all constant generators from settings.WEBPACK_CONSTANT_PROCESSORS\n            and concat their values.\n        \"\"\"\n        constants = {}\n\n        for method_path in WebpackConstants.get_constant_processors():\n            method = import_string(method_path)\n\n            if not callable(method):\n                raise ImproperlyConfigured('Constant processor \"%s\" is not callable' % method_path)\n\n            result = method(constants)\n\n            if isinstance(result, dict):\n                constants.update(result)\n\n        return constants"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the phone number.", "response": "def phonenumber_validation(data):\n    \"\"\" Validates phonenumber\n\n    Similar to phonenumber_field.validators.validate_international_phonenumber() but uses a different message if the\n    country prefix is absent.\n    \"\"\"\n    from phonenumber_field.phonenumber import to_python\n    phone_number = to_python(data)\n    if not phone_number:\n        return data\n    elif not phone_number.country_code:\n        raise serializers.ValidationError(_(\"Phone number needs to include valid country code (E.g +37255555555).\"))\n    elif not phone_number.is_valid():\n        raise serializers.ValidationError(_('The phone number entered is not valid.'))\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating Django translation catalogue for locale.", "response": "def get_catalog(self, locale):\n        \"\"\"Create Django translation catalogue for `locale`.\"\"\"\n        with translation.override(locale):\n            translation_engine = DjangoTranslation(locale, domain=self.domain, localedirs=self.paths)\n\n            trans_cat = translation_engine._catalog\n            trans_fallback_cat = translation_engine._fallback._catalog if translation_engine._fallback else {}\n\n            return trans_cat, trans_fallback_cat"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_paths(cls, packages):\n        allowable_packages = dict((app_config.name, app_config) for app_config in apps.get_app_configs())\n        app_configs = [allowable_packages[p] for p in packages if p in allowable_packages]\n        # paths of requested packages\n        return [os.path.join(app.path, 'locale') for app in app_configs]", "response": "Create list of matching packages for translation engine."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_catalogue_header_value(cls, catalog, key):\n        header_value = None\n        if '' in catalog:\n            for line in catalog[''].split('\\n'):\n                if line.startswith('%s:' % key):\n                    header_value = line.split(':', 1)[1].strip()\n\n        return header_value", "response": "Get. po header value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the number of plurals for this catalog language.", "response": "def _num_plurals(self, catalogue):\n        \"\"\"\n        Return the number of plurals for this catalog language, or 2 if no\n        plural string is available.\n        \"\"\"\n        match = re.search(r'nplurals=\\s*(\\d+)', self.get_plural(catalogue) or '')\n        if match:\n            return int(match.groups()[0])\n        return 2"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npopulates header with correct data from top - most locale file.", "response": "def make_header(self, locale, catalog):\n        \"\"\"Populate header with correct data from top-most locale file.\"\"\"\n        return {\n            \"po-revision-date\": self.get_catalogue_header_value(catalog, 'PO-Revision-Date'),\n            \"mime-version\": self.get_catalogue_header_value(catalog, 'MIME-Version'),\n            \"last-translator\": 'Automatic <hi@thorgate.eu>',\n            \"x-generator\": \"Python\",\n            \"language\": self.get_catalogue_header_value(catalog, 'Language') or locale,\n            \"lang\": locale,\n            \"content-transfer-encoding\": self.get_catalogue_header_value(catalog, 'Content-Transfer-Encoding'),\n            \"project-id-version\": self.get_catalogue_header_value(catalog, 'Project-Id-Version'),\n            \"pot-creation-date\": self.get_catalogue_header_value(catalog, 'POT-Creation-Date'),\n            \"domain\": self.domain,\n            \"report-msgid-bugs-to\": self.get_catalogue_header_value(catalog, 'Report-Msgid-Bugs-To'),\n            \"content-type\": self.get_catalogue_header_value(catalog, 'Content-Type'),\n            \"plural-forms\": self.get_plural(catalog),\n            \"language-team\": self.get_catalogue_header_value(catalog, 'Language-Team')\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collect_translations(self):\n        languages = {}\n        locale_data = {}\n\n        for language_code, label in settings.LANGUAGES:\n            languages[language_code] = '%s' % label\n\n            # Create django translation engine for `language_code`\n            trans_cat, trans_fallback_cat = self.get_catalog(language_code)\n\n            # Add the meta object\n            locale_data[language_code] = {}\n            locale_data[language_code][\"\"] = self.make_header(language_code, trans_cat)\n            num_plurals = self._num_plurals(trans_cat)\n\n            # Next code is largely taken from Django@master (01.10.2017) from `django.views.i18n JavaScriptCatalogue`\n            pdict = {}\n            seen_keys = set()\n\n            for key, value in itertools.chain(six.iteritems(trans_cat), six.iteritems(trans_fallback_cat)):\n                if key == '' or key in seen_keys:\n                    continue\n\n                if isinstance(key, six.string_types):\n                    locale_data[language_code][key] = [value]\n\n                elif isinstance(key, tuple):\n                    msgid, cnt = key\n                    pdict.setdefault(msgid, {})[cnt] = value\n\n                else:\n                    raise TypeError(key)\n                seen_keys.add(key)\n\n            for k, v in pdict.items():\n                locale_data[language_code][k] = [v.get(i, '') for i in range(num_plurals)]\n\n        for key, value in locale_data.items():\n            locale_data[key] = json.dumps(value)\n\n        return languages, locale_data", "response": "Collect all domain translations and return a tuple of languages and locale_data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_endpoint_obj(client, endpoint, object_id):\n    ''' Tiny helper function that gets used all over the place to join the object ID to the endpoint and run a GET request, returning the result '''\n    endpoint = '/'.join([endpoint, str(object_id)])\n    return client.authenticated_request(endpoint).json()", "response": "Tiny helper function that gets used all over the place to join the object ID to the endpoint and run a GET request"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_endpoint_obj(client, endpoint, object_id, revision, data):\n    ''' \n    Helper method to ease the repetitiveness of updating an... SO VERY DRY \n    \n    (That's a doubly-effective pun becuase my predecessor - https://github.com/bsmt/wunderpy - found maintaing a Python Wunderlist API to be \"as tedious and boring as a liberal arts school poetry slam\") \n    '''\n    data['revision'] = int(revision)\n    endpoint = '/'.join([endpoint, str(object_id)])\n    return client.authenticated_request(endpoint, 'PATCH', data=data).json()", "response": "Update an object in an endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_response(self, method, response):\n        ''' Helper method to validate the given to a Wunderlist API request is as expected '''\n        # TODO Fill this out using the error codes here: https://developer.wunderlist.com/documentation/concepts/formats\n        # The expected results can change based on API version, so validate this here\n        if self.api_version:\n            if response.status_code >= 400:\n                raise ValueError('{} {}'.format(response.status_code, str(response.json())))\n            if method == 'GET':\n                assert response.status_code == 200\n            elif method == 'POST':\n                assert response.status_code == 201\n            elif method == 'PATCH':\n                assert response.status_code == 200\n            elif method == 'DELETE':\n                assert response.status_code == 204", "response": "Helper method to validate the response to a Wunderlist API request is as expected"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request(self, endpoint, method='GET', headers=None, params=None, data=None):\n        '''\n        Send a request to the given Wunderlist API endpoint\n\n        Params:\n        endpoint -- API endpoint to send request to\n\n        Keyword Args:\n        headers -- headers to add to the request\n        method -- GET, PUT, PATCH, DELETE, etc.\n        params -- parameters to encode in the request\n        data -- data to send with the request\n        '''\n        if not headers:\n            headers = {}\n        if method in ['POST', 'PATCH', 'PUT']:\n            headers['Content-Type'] = 'application/json'\n        url = '/'.join([self.api_url, 'v' + self.api_version, endpoint])\n        data = json.dumps(data) if data else None\n        try:\n            response = requests.request(method=method, url=url, params=params, headers=headers, data=data)\n        # TODO Does recreating the exception classes 'requests' use suck? Yes, but it sucks more to expose the underlying library I use\n        except requests.exceptions.Timeout as e:\n            raise wp_exceptions.TimeoutError(e)\n        except requests.exceptions.ConnectionError as e:\n            raise wp_exceptions.ConnectionError(e)\n        self._validate_response(method, response)\n        return response", "response": "Send a request to the given Wunderlist API endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_access_token(self, code, client_id, client_secret):\n        ''' \n        Exchange a temporary code for an access token allowing access to a user's account\n\n        See https://developer.wunderlist.com/documentation/concepts/authorization for more info\n        '''\n        headers = {\n                'Content-Type' : 'application/json'\n                }\n        data = {\n                'client_id' : client_id,\n                'client_secret' : client_secret,\n                'code' : code,\n                }\n        str_data = json.dumps(data)\n        response = requests.request(method='POST', url=ACCESS_TOKEN_URL, headers=headers, data=str_data)\n        status_code = response.status_code\n        if status_code != 200:\n            raise ValueError(\"{} -- {}\".format(status_code, response.json()))\n        return body['access_token']", "response": "Get an access token for a user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a request to the given Wunderlist API endpoint with X - Access - Token and X - Client - ID headers and ensure the response code is as expected", "response": "def authenticated_request(self, endpoint, method='GET', params=None, data=None):\n        '''\n        Send a request to the given Wunderlist API with 'X-Access-Token' and 'X-Client-ID' headers and ensure the response code is as expected given the request type\n\n        Params:\n        endpoint -- API endpoint to send request to\n\n        Keyword Args:\n        method -- GET, PUT, PATCH, DELETE, etc.\n        params -- parameters to encode in the request\n        data -- data to send with the request\n        '''\n        headers = {\n                'X-Access-Token' : self.access_token,\n                'X-Client-ID' : self.client_id\n                }\n        return self.api.request(endpoint, method=method, headers=headers, params=params, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_list(self, list_id, revision, title=None, public=None):\n        ''' Updates the list with the given ID to have the given title and public flag '''\n        return lists_endpoint.update_list(self, list_id, revision, title=title, public=public)", "response": "Updates the list with the given ID to have the given title and public flag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the list of tasks for the given ID filtered by the given completion flag", "response": "def get_tasks(self, list_id, completed=False):\n        ''' Gets tasks for the list with the given ID, filtered by the given completion flag '''\n        return tasks_endpoint.get_tasks(self, list_id, completed=completed)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_task(self, list_id, title, assignee_id=None, completed=None, recurrence_type=None, recurrence_count=None, due_date=None, starred=None):\n        ''' Creates a new task with the given information in the list with the given ID '''\n        return tasks_endpoint.create_task(self, list_id, title, assignee_id=assignee_id, completed=completed, recurrence_type=recurrence_type, recurrence_count=recurrence_count, due_date=due_date, starred=starred)", "response": "Creates a new task with the given information in the given ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_task(self, task_id, revision, title=None, assignee_id=None, completed=None, recurrence_type=None, recurrence_count=None, due_date=None, starred=None, remove=None):\n        ''' \n        Updates the task with the given ID to have the given information \n        \n        NOTE: The 'remove' parameter is an optional list of parameters to remove from the given task, e.g. ['due_date']\n        '''\n        return tasks_endpoint.update_task(self, task_id, revision, title=title, assignee_id=assignee_id, completed=completed, recurrence_type=recurrence_type, recurrence_count=recurrence_count, due_date=due_date, starred=starred, remove=remove)", "response": "Updates the task with the given ID to have the given information \n "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_note(self, note_id, revision, content):\n        ''' Updates the note with the given ID to have the given content '''\n        return notes_endpoint.update_note(self, note_id, revision, content)", "response": "Updates the note with the given ID to have the given content."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_task_subtasks(self, task_id, completed=False):\n        ''' Gets subtasks for task with given ID '''\n        return subtasks_endpoint.get_task_subtasks(self, task_id, completed=completed)", "response": "Gets the subtasks for the given task with given ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_list_subtasks(self, list_id, completed=False):\n        ''' Gets subtasks for the list with given ID '''\n        return subtasks_endpoint.get_list_subtasks(self, list_id, completed=completed)", "response": "Gets the list s subtasks for the given ID"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new subtask with the given title under the task with the given ID", "response": "def create_subtask(self, task_id, title, completed=False):\n        ''' \n        Creates a subtask with the given title under the task with the given ID \n        \n        Return:\n        Newly-created subtask\n        '''\n        return subtasks_endpoint.create_subtask(self, task_id, title, completed=completed)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_subtask(self, subtask_id, revision, title=None, completed=None):\n        '''\n        Updates the subtask with the given ID\n\n        See https://developer.wunderlist.com/documentation/endpoints/subtask for detailed parameter information\n\n        Returns:\n        Subtask with given ID with properties and revision updated\n        '''\n        return subtasks_endpoint.update_subtask(self, subtask_id, revision, title=title, completed=completed)", "response": "Updates the subtask with the given ID with properties and revision"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_list_positions_obj(self, positions_obj_id, revision, values):\n        '''\n        Updates the ordering of lists to have the given value. The given ID and revision should match the singleton object defining how lists are laid out.\n\n        See https://developer.wunderlist.com/documentation/endpoints/positions for more info\n\n        Return:\n        The updated ListPositionsObj-mapped object defining the order of list layout\n        '''\n        return positions_endpoints.update_list_positions_obj(self, positions_obj_id, revision, values)", "response": "Updates the ordering of lists to have the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_task_positions_obj(self, positions_obj_id, revision, values):\n        '''\n        Updates the ordering of tasks in the positions object with the given ID to the ordering in the given values.\n\n        See https://developer.wunderlist.com/documentation/endpoints/positions for more info\n\n        Return:\n        The updated TaskPositionsObj-mapped object defining the order of list layout\n        '''\n        return positions_endpoints.update_task_positions_obj(self, positions_obj_id, revision, values)", "response": "Updates the ordering of tasks in the given positions object with the given ID to the given values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_subtask_positions_obj(self, positions_obj_id, revision, values):\n        '''\n        Updates the ordering of subtasks in the positions object with the given ID to the ordering in the given values.\n\n        See https://developer.wunderlist.com/documentation/endpoints/positions for more info\n\n        Return:\n        The updated SubtaskPositionsObj-mapped object defining the order of list layout\n        '''\n        return positions_endpoints.update_subtask_positions_obj(self, positions_obj_id, revision, values)", "response": "Updates the ordering of subtasks in the positions object with the given ID to the given values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking that the given date string conforms to the given API s date format specification.", "response": "def _check_date_format(date, api):\n    ''' Checks that the given date string conforms to the given API's date format specification '''\n    try:\n        datetime.datetime.strptime(date, api.DATE_FORMAT)\n    except ValueError:\n        raise ValueError(\"Date '{}' does not conform to API format: {}\".format(date, api.DATE_FORMAT))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tasks(client, list_id, completed=False):\n    ''' Gets un/completed tasks for the given list ID '''\n    params = { \n            'list_id' : str(list_id), \n            'completed' : completed \n            }\n    response = client.authenticated_request(client.api.Endpoints.TASKS, params=params)\n    return response.json()", "response": "Gets un / completed tasks for the given list ID"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_task(client, task_id):\n    ''' Gets task information for the given ID '''\n    endpoint = '/'.join([client.api.Endpoints.TASKS, str(task_id)])\n    response = client.authenticated_request(endpoint)\n    return response.json()", "response": "Gets the task information for the given ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a task in the given list.", "response": "def create_task(client, list_id, title, assignee_id=None, completed=None, recurrence_type=None, recurrence_count=None, due_date=None, starred=None):\n    ''' \n    Creates a task in the given list \n\n    See https://developer.wunderlist.com/documentation/endpoints/task for detailed parameter information\n    '''\n    _check_title_length(title, client.api)\n    if (recurrence_type is None and recurrence_count is not None) or (recurrence_type is not None and recurrence_count is None):\n        raise ValueError(\"recurrence_type and recurrence_count are required are required together\")\n    if due_date is not None:\n        _check_date_format(due_date, client.api)\n    data = {\n            'list_id' : int(list_id) if list_id else None,\n            'title' : title,\n            'assignee_id' : int(assignee_id) if assignee_id else None,\n            'completed' : completed,\n            'recurrence_type' : recurrence_type,\n            'recurrence_count' : int(recurrence_count) if recurrence_count else None,\n            'due_date' : due_date,\n            'starred' : starred,\n            }\n    data = { key: value for key, value in data.items() if value is not None }\n    response = client.authenticated_request(client.api.Endpoints.TASKS, 'POST', data=data)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_task(client, task_id, revision, title=None, assignee_id=None, completed=None, recurrence_type=None, recurrence_count=None, due_date=None, starred=None, remove=None):\n    '''\n    Updates the task with the given ID\n\n    See https://developer.wunderlist.com/documentation/endpoints/task for detailed parameter information\n    '''\n    if title is not None:\n        _check_title_length(title, client.api)\n    if (recurrence_type is None and recurrence_count is not None) or (recurrence_type is not None and recurrence_count is None):\n        raise ValueError(\"recurrence_type and recurrence_count are required are required together\")\n    if due_date is not None:\n        _check_date_format(due_date, client.api)\n    data = {\n            'revision' : int(revision),\n            'title' : title,\n            'assignee_id' : int(assignee_id) if assignee_id else None,\n            'completed' : completed,\n            'recurrence_type' : recurrence_type,\n            'recurrence_count' : int(recurrence_count) if recurrence_count else None,\n            'due_date' : due_date,\n            'starred' : starred,\n            'remove' : remove,\n            }\n    data = { key: value for key, value in data.items() if value is not None }\n    endpoint = '/'.join([client.api.Endpoints.TASKS, str(task_id)])\n    response = client.authenticated_request(endpoint, 'PATCH', data=data)\n    return response.json()", "response": "Updates the task with the given ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the given title against the given API specifications to ensure it s short enough.", "response": "def _check_title_length(title, api):\n    ''' Checks the given title against the given API specifications to ensure it's short enough '''\n    if len(title) > api.MAX_LIST_TITLE_LENGTH:\n        raise ValueError(\"Title cannot be longer than {} characters\".format(api.MAX_TASK_TITLE_LENGTH))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all the client s lists", "response": "def get_lists(client):\n    ''' Gets all the client's lists '''\n    response = client.authenticated_request(client.api.Endpoints.LISTS)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_list(client, list_id):\n    ''' Gets the given list '''\n    endpoint = '/'.join([client.api.Endpoints.LISTS, str(list_id)])\n    response = client.authenticated_request(endpoint)\n    return response.json()", "response": "Gets the given list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new list with the given title", "response": "def create_list(client, title):\n    ''' Creates a new list with the given title '''\n    _check_title_length(title, client.api)\n    data = {\n            'title' : title,\n            }\n    response = client.authenticated_request(client.api.Endpoints.LISTS, method='POST', data=data)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_list(client, list_id, revision, title=None, public=None):\n    '''\n    Updates the list with the given ID to have the given properties\n\n    See https://developer.wunderlist.com/documentation/endpoints/list for detailed parameter information\n    '''\n    if title is not None:\n        _check_title_length(title, client.api)\n    data = {\n            'revision' : revision,\n            'title' : title,\n            'public' : public,\n            }\n    data = { key: value for key, value in data.items() if value is not None }\n    endpoint = '/'.join([client.api.Endpoints.LISTS, str(list_id)])\n    response = client.authenticated_request(endpoint, 'PATCH', data=data)\n    return response.json()", "response": "Updates the list with the given ID to have the given properties."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the object that defines how lists are ordered", "response": "def get_list_positions_obj(client, positions_obj_id):\n    '''\n    Gets the object that defines how lists are ordered (there will always be only one of these)\n\n    See https://developer.wunderlist.com/documentation/endpoints/positions for more info\n\n    Return:\n    A ListPositionsObj-mapped object defining the order of list layout\n    '''\n    return endpoint_helpers.get_endpoint_obj(client, client.api.Endpoints.LIST_POSITIONS, positions_obj_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_list_positions_obj(client, positions_obj_id, revision, values):\n    '''\n    Updates the ordering of lists to have the given value. The given ID and revision should match the singleton object defining how lists are laid out.\n\n    See https://developer.wunderlist.com/documentation/endpoints/positions for more info\n\n    Return:\n    The updated ListPositionsObj-mapped object defining the order of list layout\n    '''\n    return _update_positions_obj(client, client.api.Endpoints.LIST_POSITIONS, positions_obj_id, revision, values)", "response": "Updates the ordering of lists to have the given value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_task_positions_objs(client, list_id):\n    '''\n    Gets a list containing the object that encapsulates information about the order lists are laid out in. This list will always contain exactly one object.\n\n    See https://developer.wunderlist.com/documentation/endpoints/positions for more info\n\n    Return:\n    A list containing a single ListPositionsObj-mapped object\n    '''\n    params = {\n            'list_id' : int(list_id)\n            }\n    response = client.authenticated_request(client.api.Endpoints.TASK_POSITIONS, params=params)\n    return response.json()", "response": "Gets a list containing the object that encapsulates information about the order lists are laid out in."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all subtask positions objects for the tasks within a given list.", "response": "def get_list_subtask_positions_objs(client, list_id):\n    '''\n    Gets all subtask positions objects for the tasks within a given list. This is a convenience method so you don't have to get all the list's tasks before getting subtasks, though I can't fathom how mass subtask reordering is useful.\n\n    Returns:\n    List of SubtaskPositionsObj-mapped objects representing the order of subtasks for the tasks within the given list\n    '''\n    params = {\n            'list_id' : int(list_id)\n            }\n    response = client.authenticated_request(client.api.Endpoints.SUBTASK_POSITIONS, params=params)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the given title against the given API specifications to ensure it s short enough.", "response": "def _check_title_length(title, api):\n    ''' Checks the given title against the given API specifications to ensure it's short enough '''\n    if len(title) > api.MAX_SUBTASK_TITLE_LENGTH:\n        raise ValueError(\"Title cannot be longer than {} characters\".format(api.MAX_SUBTASK_TITLE_LENGTH))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_task_subtasks(client, task_id, completed=False):\n    ''' Gets subtasks for task with given ID '''\n    params = {\n            'task_id' : int(task_id),\n            'completed' : completed,\n            }\n    response = client.authenticated_request(client.api.Endpoints.SUBTASKS, params=params)\n    return response.json()", "response": "Gets the subtasks for a task with given ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the subtasks for the list with given ID", "response": "def get_list_subtasks(client, list_id, completed=False):\n    ''' Gets subtasks for the list with given ID '''\n    params = {\n            'list_id' : int(list_id),\n            'completed' : completed,\n            }\n    response = client.authenticated_request(client.api.Endpoints.SUBTASKS, params=params)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_subtask(client, subtask_id):\n    ''' Gets the subtask with the given ID '''\n    endpoint = '/'.join([client.api.Endpoints.SUBTASKS, str(subtask_id)])\n    response = client.authenticated_request(endpoint)\n    return response.json()", "response": "Gets the subtask with the given ID"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a subtask under the task with the given title under the task with the given ID", "response": "def create_subtask(client, task_id, title, completed=False):\n    ''' Creates a subtask with the given title under the task with the given ID '''\n    _check_title_length(title, client.api)\n    data = {\n            'task_id' : int(task_id) if task_id else None,\n            'title' : title,\n            'completed' : completed,\n            }\n    data = { key: value for key, value in data.items() if value is not None }\n    response = client.authenticated_request(client.api.Endpoints.SUBTASKS, 'POST', data=data)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_subtask(client, subtask_id, revision, title=None, completed=None):\n    '''\n    Updates the subtask with the given ID\n\n    See https://developer.wunderlist.com/documentation/endpoints/subtask for detailed parameter information\n    '''\n    if title is not None:\n        _check_title_length(title, client.api)\n    data = {\n            'revision' : int(revision),\n            'title' : title,\n            'completed' : completed,\n            }\n    data = { key: value for key, value in data.items() if value is not None }\n    endpoint = '/'.join([client.api.Endpoints.SUBTASKS, str(subtask_id)])\n    response = client.authenticated_request(endpoint, 'PATCH', data=data)\n    return response.json()", "response": "Updates the subtask with the given ID\nWorkItem."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_subtask(client, subtask_id, revision):\n    ''' Deletes the subtask with the given ID provided the given revision equals the revision the server has '''\n    params = {\n            'revision' : int(revision),\n            }\n    endpoint = '/'.join([client.api.Endpoints.SUBTASKS, str(subtask_id)])\n    client.authenticated_request(endpoint, 'DELETE', params=params)", "response": "Deletes the subtask with the given ID provided the given revision equals the revision of the server has."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wait(animation='elipses', text='', speed=0.2):\n    def decorator(func):\n        func.animation = animation\n        func.speed = speed\n        func.text = text\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            animation = func.animation\n            text = func.text\n            if not isinstance(animation, (list, tuple)) and \\\n                    not hasattr(animations, animation):\n                text = animation if text == '' else text\n                animation = 'elipses'\n            wait = Wait(animation=animation, text=text, speed=func.speed)\n            wait.start()\n            try:\n                ret = func(*args, **kwargs)\n            finally:\n                wait.stop()\n            sys.stdout.write('\\n')\n            return ret\n        return wrapper\n    return decorator", "response": "Decorator for adding wait animation to long running functions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge(tup):\n    if not all(tuple(ts.shape[1:] == tup[0].shape[1:] for ts in tup[1:])):\n        raise ValueError('Timeseries to merge must have compatible shapes')\n    indices = np.vstack(tuple(ts.tspan for ts in tup)).argsort()\n    return np.vstack((tup))[indices]", "response": "Merge several Timeseries into a single timeseries with the same shape except for axis 0."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_analyses(cls, source):\n        if isinstance(source, types.FunctionType):\n            _add_single_method(source.__name__, source)\n        else:\n            if isinstance(source, types.ModuleType):\n                mod = source\n            elif isinstance(source, types.StringTypes):\n                import os\n                import imp\n                path = os.path.abspath(source)\n                if os.path.isfile(path) and path[-3:] == '.py':\n                    dir, file = os.path.split(path)\n                    name = file[:-3]\n                    module_info = imp.find_module(name, [dir])\n                    mod = imp.load_module('nsim.' + name, *module_info)\n                elif (os.path.isdir(path) and \n                        '__init__.py' in os.listdir(path)):\n                    module_info = imp.find_module('__init__', [path])\n                    name = os.path.basename(path)\n                    mod = imp.load_module('nsim.' + name, *module_info)\n                else:\n                    raise Error('\"%s\" is not a file or directory' % source)\n            else:\n                raise ValueError('`source` argument not a function or module')\n            for name, obj in mod.__dict__.items():\n                if name[0] != '_' and isinstance(obj, types.FunctionType):\n                    cls._add_single_method(name, obj)", "response": "Dynamically add new analysis methods to the Timeseries class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef absolute(self):\n        return Timeseries(np.absolute(self), self.tspan, self.labels)", "response": "Calculate the absolute value element - wise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the angle of the complex argument.", "response": "def angle(self, deg=False):\n        \"\"\"Return the angle of the complex argument.\n\n        Args:\n          deg (bool, optional):\n            Return angle in degrees if True, radians if False (default).\n\n        Returns:\n          angle (Timeseries):\n            The counterclockwise angle from the positive real axis on\n            the complex plane, with dtype as numpy.float64.\n        \"\"\"\n        if self.dtype.str[1] != 'c':\n            warnings.warn('angle() is intended for complex-valued timeseries',\n                          RuntimeWarning, 1)\n        return Timeseries(np.angle(self, deg=deg), self.tspan, self.labels)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef swapaxes(self, axis1, axis2):\n        if self.ndim <=1 or axis1 == axis2:\n            return self\n        ar = np.asarray(self).swapaxes(axis1, axis2)\n        if axis1 != 0 and axis2 != 0:\n            # then axis 0 is unaffected by the swap\n            labels = self.labels[:]\n            labels[axis1], labels[axis2] = labels[axis2], labels[axis1]\n            return Timeseries(ar, self.tspan, labels)\n        return ar", "response": "Interchange two axes of a Timeseries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npermute the dimensions of a Timeseries.", "response": "def transpose(self, *axes):\n        \"\"\"Permute the dimensions of a Timeseries.\"\"\"\n        if self.ndim <= 1:\n            return self\n        ar = np.asarray(self).transpose(*axes)\n        if axes[0] != 0:\n            # then axis 0 is unaffected by the transposition\n            newlabels = [self.labels[ax] for ax in axes]\n            return Timeseries(ar, self.tspan, newlabels)\n        else:\n            return ar"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmerge another timeseries with this one returning a new one whose time points are the same.", "response": "def merge(self, ts):\n        \"\"\"Merge another timeseries with this one\n        Arguments:\n          ts (Timeseries): The two timeseries being merged must have the\n            same shape except for axis 0.\n        Returns: \n          Resulting merged timeseries which can have duplicate time points.\n        \"\"\"\n        if ts.shape[1:] != self.shape[1:]:\n            raise ValueError('Timeseries to merge must have compatible shapes')\n        indices = np.vstack((self.tspan, ts.tspan)).argsort()\n        return np.vstack((self, ts))[indices]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef expand_dims(self, axis):\n        if axis == -1:\n            axis = self.ndim\n        array = np.expand_dims(self, axis)\n        if axis == 0:\n            # prepended an axis: no longer a Timeseries\n            return array\n        else:\n            new_labels = self.labels.insert(axis, None)\n            return Timeseries(array, self.tspan, new_labels)", "response": "Returns a new array with the same shape as self."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef concatenate(self, tup, axis=0):\n        if not isinstance(tup, Sequence):\n            tup = (tup,)\n        if tup is (None,) or len(tup) is 0:\n            return self\n        tup = (self,) + tuple(tup)\n        new_array = np.concatenate(tup, axis)\n        if not all(hasattr(ts, 'tspan') and \n                   hasattr(ts, 'labels') for ts in tup):\n            return new_array\n        if axis == 0:\n            starts = [ts.tspan[0] for ts in tup]\n            ends = [ts.tspan[-1] for ts in tup]\n            if not all(starts[i] > ends[i-1] for i in range(1, len(starts))):\n                # series being joined are not ordered in time. not Timeseries\n                return new_array\n            else:\n                new_tspan = np.concatenate([ts.tspan for ts in tup])\n        else:\n            new_tspan = self.tspan\n        new_labels = [None]\n        for ax in range(1, new_array.ndim):\n            if ax == axis:\n                axislabels = []\n                for ts in tup:\n                    if ts.labels[axis] is None:\n                        axislabels.extend('' * ts.shape[axis])\n                    else:\n                        axislabels.extend(ts.labels[axis])\n                if all(lab == '' for lab in axislabels):\n                    new_labels.append(None)\n                else:\n                    new_labels.append(axislabels)\n            else:\n                # non-concatenation axis\n                axlabels = tup[0].labels[ax]\n                if not all(ts.labels[ax] == axlabels for ts in tup[1:]):\n                    # series to be joined do not agree on labels for this axis\n                    axlabels = None\n                new_labels.append(axlabels)\n        return self.__new__(self.__class__, new_array, new_tspan, new_labels)", "response": "Returns a new array with the elements of tup joined along the specified axis."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef split(self, indices_or_sections, axis=0):\n        if not isinstance(indices_or_sections, numbers.Integral):\n            raise Error('splitting by array of indices is not yet implemented')\n        n = indices_or_sections\n        if self.shape[axis] % n != 0:\n            raise ValueError(\"Array split doesn't result in an equal division\")\n        step = self.shape[axis] / n\n        pieces = []\n        start = 0\n        while start < self.shape[axis]:\n            stop = start + step\n            ix = [slice(None)] * self.ndim\n            ix[axis] = slice(start, stop)\n            ix = tuple(ix)\n            pieces.append(self[ix])\n            start += step\n        return pieces", "response": "Split a timeseries into multiple sub - timeseries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot(dts, title=None, points=None, show=True):\n    if points is not None and len(dts.tspan) > points:\n        # then downsample  (TODO: use interpolation)\n        ix = np.linspace(0, len(dts.tspan) - 1, points).astype(np.int64)\n        dts = dts[ix, ...]\n    ts = distob.gather(dts)\n    return ts.plot(title, show)", "response": "Plot a distributed timeseries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef phase_histogram(dts, times=None, nbins=30, colormap=mpl.cm.Blues):\n    if times is None:\n        times = np.linspace(dts.tspan[0], dts.tspan[-1], num=4)\n    elif isinstance(times, numbers.Number):\n        times = np.array([times], dtype=np.float64)\n    indices = distob.gather(dts.tspan.searchsorted(times))\n    if indices[-1] == len(dts.tspan):\n        indices[-1] -= 1\n    nplots = len(indices)\n    fig = plt.figure()\n    n = np.zeros((nbins, nplots))\n    for i in range(nplots):\n        index = indices[i]\n        time = dts.tspan[index]\n        phases = distob.gather(dts.mod2pi()[index, 0, :])\n        ax = fig.add_subplot(1, nplots, i + 1, projection='polar')\n        n[:,i], bins, patches = ax.hist(phases, nbins, (-np.pi, np.pi), \n                                        density=True, histtype='bar')\n        ax.set_title('time = %d s' % time)\n        ax.set_xticklabels(['0', r'$\\frac{\\pi}{4}$', r'$\\frac{\\pi}{2}$', \n                            r'$\\frac{3\\pi}{4}$', r'$\\pi$', r'$\\frac{-3\\pi}{4}$',\n                            r'$\\frac{-\\pi}{2}$', r'$\\frac{-\\pi}{4}$'])\n    nmin, nmax = n.min(), n.max()\n    #TODO should make a custom colormap instead of reducing color dynamic range:\n    norm = mpl.colors.Normalize(1.2*nmin - 0.2*nmax, \n                                0.6*nmin + 0.4*nmax, clip=True)\n    for i in range(nplots):\n        ax = fig.get_axes()[i]\n        ax.set_ylim(0, nmax)\n        for this_n, thispatch in zip(n[:,i], ax.patches):\n            color = colormap(norm(this_n))\n            thispatch.set_facecolor(color)\n            thispatch.set_edgecolor(color)\n    fig.show()", "response": "Plot a polar histogram of a phase variable s probability distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots Welch estimate of power spectral density using nperseg samples per segment with noverlap samples overlap and Hamming window.", "response": "def psd(ts, nperseg=1500, noverlap=1200, plot=True):\n    \"\"\"plot Welch estimate of power spectral density, using nperseg samples per\n    segment, with noverlap samples overlap and Hamming window.\"\"\"\n    ts = ts.squeeze()\n    if ts.ndim is 1:\n        ts = ts.reshape((-1, 1))\n    fs = (len(ts) - 1.0) / (ts.tspan[-1] - ts.tspan[0])\n    window = signal.hamming(nperseg, sym=False)\n    nfft = max(256, 2**np.int(np.log2(nperseg) + 1))\n    freqs, pxx = signal.welch(ts, fs, window, nperseg, noverlap, nfft,\n                              detrend='linear', axis=0)\n    # Discard estimates for freq bins that are too low for the window size.\n    # (require two full cycles to fit within the window)\n    index = np.nonzero(freqs >= 2.0*fs/nperseg)[0][0]\n    if index > 0:\n        freqs = freqs[index:]\n        pxx = pxx[index:]\n    # Discard estimate for last freq bin as too high for Nyquist frequency:\n    freqs = freqs[:-1]\n    pxx = pxx[:-1]\n    if plot is True:\n        _plot_psd(ts, freqs, pxx)\n    return freqs, pxx"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nforward - backward butterworth low - pass filter", "response": "def lowpass(ts, cutoff_hz, order=3):\n    \"\"\"forward-backward butterworth low-pass filter\"\"\"\n    orig_ndim = ts.ndim\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis]\n    channels = ts.shape[1]\n    fs = (len(ts) - 1.0) / (ts.tspan[-1] - ts.tspan[0])\n    nyq = 0.5 * fs\n    cutoff = cutoff_hz/nyq\n    b, a = signal.butter(order, cutoff, btype='low')\n    if not np.all(np.abs(np.roots(a)) < 1.0):\n        raise ValueError('Filter will not be stable with these values.')\n    dtype = ts.dtype\n    output = np.zeros((len(ts), channels), dtype)\n    for i in range(channels):\n        output[:, i] = signal.filtfilt(b, a, ts[:, i])\n    if orig_ndim is 1:\n        output = output[:, 0]\n    return Timeseries(output, ts.tspan, labels=ts.labels)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bandpass(ts, low_hz, high_hz, order=3):\n    orig_ndim = ts.ndim\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis]\n    channels = ts.shape[1]\n    fs = (len(ts) - 1.0) / (ts.tspan[-1] - ts.tspan[0])\n    nyq = 0.5 * fs\n    low = low_hz/nyq\n    high = high_hz/nyq\n    b, a = signal.butter(order, [low, high], btype='band')\n    if not np.all(np.abs(np.roots(a)) < 1.0):\n        raise ValueError('Filter will not be stable with these values.')\n    dtype = ts.dtype\n    output = np.zeros((len(ts), channels), dtype)\n    for i in range(channels):\n        output[:, i] = signal.filtfilt(b, a, ts[:, i])\n    if orig_ndim is 1:\n        output = output[:, 0]\n    return Timeseries(output, ts.tspan, labels=ts.labels)", "response": "forward - backward butterworth band - pass filter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef notch(ts, freq_hz, bandwidth_hz=1.0):\n    orig_ndim = ts.ndim\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis]\n    channels = ts.shape[1]\n    fs = (len(ts) - 1.0) / (ts.tspan[-1] - ts.tspan[0])\n    nyq = 0.5 * fs\n    freq = freq_hz/nyq\n    bandwidth = bandwidth_hz/nyq\n    R = 1.0 - 3.0*(bandwidth/2.0)\n    K = ((1.0 - 2.0*R*np.cos(np.pi*freq) + R**2) /\n         (2.0 - 2.0*np.cos(np.pi*freq)))\n    b, a = np.zeros(3), np.zeros(3)\n    a[0] = 1.0\n    a[1] = -2.0*R*np.cos(np.pi*freq)\n    a[2] = R**2\n    b[0] = K\n    b[1] = -2*K*np.cos(np.pi*freq)\n    b[2] = K\n    if not np.all(np.abs(np.roots(a)) < 1.0):\n        raise ValueError('Filter will not be stable with these values.')\n    dtype = ts.dtype\n    output = np.zeros((len(ts), channels), dtype)\n    for i in range(channels):\n        output[:, i] = signal.filtfilt(b, a, ts[:, i])\n    if orig_ndim is 1:\n        output = output[:, 0]\n    return Timeseries(output, ts.tspan, labels=ts.labels)", "response": "notch filter to remove a particular frequency\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hilbert(ts):\n    output = signal.hilbert(signal.detrend(ts, axis=0), axis=0)\n    return Timeseries(output, ts.tspan, labels=ts.labels)", "response": "Analytic signal using the Hilbert transform"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hilbert_amplitude(ts):\n    output = np.abs(signal.hilbert(signal.detrend(ts, axis=0), axis=0))\n    return Timeseries(output, ts.tspan, labels=ts.labels)", "response": "Amplitude of the analytic signal using the Hilbert transform"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hilbert_phase(ts):\n    output = np.angle(signal.hilbert(signal.detrend(ts, axis=0), axis=0))\n    return Timeseries(output, ts.tspan, labels=ts.labels)", "response": "Phase of the analytic signal using the Hilbert transform"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cwt_distributed(ts, freqs=np.logspace(0, 2), wavelet=cwtmorlet, plot=True):\n    if ts.ndim is 1 or ts.shape[1] is 1:\n        return cwt(ts, freqs, wavelet, plot)\n    import distob\n    vcwt = distob.vectorize(cwt)\n    coefs = vcwt(ts, freqs, wavelet, plot=False)\n    if plot:\n        _plot_cwt(ts, coefs, freqs)\n    return coefs", "response": "Continuous wavelet transform using distributed computation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots time resolved power spectral density from cwt results.", "response": "def _plot_cwt(ts, coefs, freqs, tsize=1024, fsize=512):\n    \"\"\"Plot time resolved power spectral density from cwt results\n    Args:\n      ts: the original Timeseries\n      coefs:  continuous wavelet transform coefficients as calculated by cwt()\n      freqs: list of frequencies (in Hz) corresponding to coefs.\n      tsize, fsize: size of the plot (time axis and frequency axis, in pixels)\n    \"\"\"\n    import matplotlib.style\n    import matplotlib as mpl\n    mpl.style.use('classic')\n    import matplotlib.pyplot as plt\n    from scipy import interpolate\n    channels = ts.shape[1]\n    fig = plt.figure()\n    for i in range(channels):\n        rect = (0.1, 0.85*(channels - i - 1)/channels + 0.1, \n                0.8, 0.85/channels)\n        ax = fig.add_axes(rect)\n        logpowers = np.log((coefs[:, :, i] * coefs[:, :, i].conj()).real)\n        tmin, tmax = ts.tspan[0], ts.tspan[-1]\n        fmin, fmax = freqs[0], freqs[-1]\n        tgrid, fgrid = np.mgrid[tmin:tmax:tsize*1j, fmin:fmax:fsize*1j]\n        gd = interpolate.interpn((ts.tspan, freqs), logpowers, \n                                 (tgrid, fgrid)).T\n        ax.imshow(gd, cmap='gnuplot2', aspect='auto', origin='lower',\n                   extent=(tmin, tmax, fmin, fmax))\n        ax.set_ylabel('freq (Hz)')\n    fig.axes[0].set_title(u'log(power spectral density)')\n    fig.axes[channels - 1].set_xlabel('time (s)')\n    fig.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef first_return_times(dts, c=None, d=0.0):\n    if c is None:\n        c = dts.mean()\n    vmrt = distob.vectorize(analyses1.first_return_times)\n    all_intervals = vmrt(dts, c, d)\n    if hasattr(type(all_intervals), '__array_interface__'):\n        return np.ravel(all_intervals)\n    else:\n        return np.hstack([distob.gather(ilist) for ilist in all_intervals])", "response": "For an ensemble of time series return the set of all time intervals between successive returns to value c for all instances in the ensemble."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef variability_fp(ts, freqs=None, ncycles=6, plot=True):\n    if ts.ndim <= 2:\n        return analyses1.variability_fp(ts, freqs, ncycles, plot)\n    else:\n        return distob.vectorize(analyses1.variability_fp)(\n                ts, freqs, ncycles, plot)", "response": "Example variability function.\n    Gives two continuous, time-resolved measures of the variability of a\n    time series, ranging between -1 and 1. \n    The two measures are based on variance of the centroid frequency and \n    variance of the height of the spectral peak, respectively.\n    (Centroid frequency meaning the power-weighted average frequency)\n    These measures are calculated over sliding time windows of variable size.\n    See also: Blenkinsop et al. (2012) The dynamic evolution of focal-onset \n              epilepsies - combining theoretical and clinical observations\n    Args:\n      ts  Timeseries of m variables, shape (n, m). Assumed constant timestep.\n      freqs   (optional) List of frequencies to examine. If None, defaults to\n              50 frequency bands ranging 1Hz to 60Hz, logarithmically spaced.\n      ncycles  Window size, in number of cycles of the centroid frequency.\n      plot  bool  Whether to display the output\n\n    Returns:\n      variability   Timeseries of shape (n, m, 2)  \n                    variability[:, :, 0] gives a measure of variability \n                    between -1 and 1 based on variance of centroid frequency.\n                    variability[:, :, 1] gives a measure of variability \n                    between -1 and 1 based on variance of maximum power."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nidentifies stationary epochs within a time series.", "response": "def epochs(ts, variability=None, threshold=0.0, minlength=1.0, plot=True):\n    \"\"\"Identify \"stationary\" epochs within a time series, based on a \n    continuous measure of variability.\n    Epochs are defined to contain the points of minimal variability, and to \n    extend as wide as possible with variability not exceeding the threshold.\n\n    Args:\n      ts  Timeseries of m variables, shape (n, m). \n      variability  (optional) Timeseries of shape (n, m, q),  giving q scalar \n                   measures of the variability of timeseries `ts` near each \n                   point in time. (if None, we will use variability_fp())\n                   Epochs require the mean of these to be below the threshold.\n      threshold   The maximum variability permitted in stationary epochs.\n      minlength   Shortest acceptable epoch length (in seconds)\n      plot  bool  Whether to display the output\n\n    Returns: (variability, allchannels_epochs) \n      variability: as above\n      allchannels_epochs: (list of) list of tuples\n      For each variable, a list of tuples (start, end) that give the \n      starting and ending indices of stationary epochs.\n      (epochs are inclusive of start point but not the end point)\n    \"\"\"\n    if ts.ndim <= 2:\n        return analyses1.epochs_distributed(\n                ts, variability, threshold, minlength, plot)\n    else:\n        return distob.vectorize(analyses1.epochs)(\n                ts, variability, threshold, minlength, plot)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nidentify epochs within a multivariate time series where at least a certain proportion of channels are stationary.", "response": "def epochs_joint(ts, variability=None, threshold=0.0, minlength=1.0,\n                 proportion=0.75, plot=True):\n    \"\"\"Identify epochs within a multivariate time series where at least a \n    certain proportion of channels are \"stationary\", based on a previously \n    computed variability measure.\n\n    (Note: This requires an IPython cluster to be started first, \n     e.g. on a workstation type 'ipcluster start')\n\n    Args:\n      ts  Timeseries of m variables, shape (n, m). \n      variability  (optional) Timeseries of shape (n, m),  giving a scalar \n                   measure of the variability of timeseries `ts` near each \n                   point in time. (if None, we will use variability_fp())\n      threshold   The maximum variability permitted in stationary epochs.\n      minlength   Shortest acceptable epoch length (in seconds)\n      proportion  Require at least this fraction of channels to be \"stationary\"\n      plot  bool  Whether to display the output\n\n    Returns: (variability, joint_epochs)\n      joint_epochs: list of tuples\n      A list of tuples (start, end) that give the starting and ending indices \n      of time epochs that are stationary for at least `proportion` of channels.\n      (epochs are inclusive of start point but not the end point)\n    \"\"\"\n    if ts.ndim <= 2:\n        return analyses1.epochs_joint(\n                ts, variability, threshold, minlength, plot)\n    else:\n        return distob.vectorize(analyses1.epochs_joint)(\n                ts, variability, threshold, minlength, plot)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef order_param(dts, axis=2):\n    return np.abs(np.exp(1.0j * dts).mean(axis=axis))", "response": "Order parameter of phase synchronization"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef G(self, v, t):\n        ret = np.zeros((8, 1))\n        ret[4,0] = self.ke1 * self.He1 * self.u_sdev\n        ret[5,0] = self.ke2 * self.He2 * self.p_sdev\n        return ret", "response": "Aburn2012 equations right hand side noise term\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the Hurst exponent of X.", "response": "def hurst(X):\n    \"\"\" Compute the Hurst exponent of X. If the output H=0.5,the behavior\n    of the time-series is similar to random walk. If H<0.5, the time-series\n    cover less \"distance\" than a random walk, vice verse.\n\n    Parameters\n    ----------\n\n    X\n\n        list\n\n        a time series\n\n    Returns\n    -------\n    H\n\n        float\n\n        Hurst exponent\n\n    Notes\n    --------\n    Author of this function is Xin Liu\n\n    Examples\n    --------\n\n    >>> import pyeeg\n    >>> from numpy.random import randn\n    >>> a = randn(4096)\n    >>> pyeeg.hurst(a)\n    0.5057444\n\n    \"\"\"\n    X = numpy.array(X)\n    N = X.size\n    T = numpy.arange(1, N + 1)\n    Y = numpy.cumsum(X)\n    Ave_T = Y / T\n\n    S_T = numpy.zeros(N)\n    R_T = numpy.zeros(N)\n\n    for i in range(N):\n        S_T[i] = numpy.std(X[:i + 1])\n        X_T = Y - T * Ave_T[i]\n        R_T[i] = numpy.ptp(X_T[:i + 1])\n\n    R_S = R_T / S_T\n    R_S = numpy.log(R_S)[1:]\n    n = numpy.log(T)[1:]\n    A = numpy.column_stack((n, numpy.ones(n.size)))\n    [m, c] = numpy.linalg.lstsq(A, R_S)[0]\n    H = m\n    return H"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef embed_seq(X, Tau, D):\n    shape = (X.size - Tau * (D - 1), D)\n    strides = (X.itemsize, Tau * X.itemsize)\n    return numpy.lib.stride_tricks.as_strided(X, shape=shape, strides=strides)", "response": "Build a set of embedding sequences from given time series X with lag Tau\n    and embedding dimension D."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the power of each frequency bin specified by Band from FFT result of X.", "response": "def bin_power(X, Band, Fs):\n    \"\"\"Compute power in each frequency bin specified by Band from FFT result of\n    X. By default, X is a real signal.\n\n    Note\n    -----\n    A real signal can be synthesized, thus not real.\n\n    Parameters\n    -----------\n\n    Band\n        list\n\n        boundary frequencies (in Hz) of bins. They can be unequal bins, e.g.\n        [0.5,4,7,12,30] which are delta, theta, alpha and beta respectively.\n        You can also use range() function of Python to generate equal bins and\n        pass the generated list to this function.\n\n        Each element of Band is a physical frequency and shall not exceed the\n        Nyquist frequency, i.e., half of sampling frequency.\n\n     X\n        list\n\n        a 1-D real time series.\n\n    Fs\n        integer\n\n        the sampling rate in physical frequency\n\n    Returns\n    -------\n\n    Power\n        list\n\n        spectral power in each frequency bin.\n\n    Power_ratio\n        list\n\n        spectral power in each frequency bin normalized by total power in ALL\n        frequency bins.\n\n    \"\"\"\n\n    C = numpy.fft.fft(X)\n    C = abs(C)\n    Power = numpy.zeros(len(Band) - 1)\n    for Freq_Index in range(0, len(Band) - 1):\n        Freq = float(Band[Freq_Index])\n        Next_Freq = float(Band[Freq_Index + 1])\n        Power[Freq_Index] = sum(\n            C[numpy.floor(\n                Freq / Fs * len(X)\n            ): numpy.floor(Next_Freq / Fs * len(X))]\n        )\n    Power_Ratio = Power / sum(Power)\n    return Power, Power_Ratio"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pfd(X, D=None):\n    if D is None:\n        D = numpy.diff(X)\n        D = D.tolist()\n    N_delta = 0  # number of sign changes in derivative of the signal\n    for i in range(1, len(D)):\n        if D[i] * D[i - 1] < 0:\n            N_delta += 1\n    n = len(X)\n    return numpy.log10(n) / (\n        numpy.log10(n) + numpy.log10(n / n + 0.4 * N_delta)\n    )", "response": "Compute Petrosian Fractal Dimension of a time series X."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing Hjorth Fractal Dimension of a time series X and kmax is an HFD parameter", "response": "def hfd(X, Kmax):\n    \"\"\" Compute Hjorth Fractal Dimension of a time series X, kmax\n     is an HFD parameter\n    \"\"\"\n    L = []\n    x = []\n    N = len(X)\n    for k in range(1, Kmax):\n        Lk = []\n        for m in range(0, k):\n            Lmk = 0\n            for i in range(1, int(numpy.floor((N - m) / k))):\n                Lmk += abs(X[m + i * k] - X[m + i * k - k])\n            Lmk = Lmk * (N - 1) / numpy.floor((N - m) / float(k)) / k\n            Lk.append(Lmk)\n        L.append(numpy.log(numpy.mean(Lk)))\n        x.append([numpy.log(float(1) / k), 1])\n\n    (p, r1, r2, s) = numpy.linalg.lstsq(x, L)\n    return p[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hjorth(X, D=None):\n\n    if D is None:\n        D = numpy.diff(X)\n        D = D.tolist()\n\n    D.insert(0, X[0])  # pad the first difference\n    D = numpy.array(D)\n\n    n = len(X)\n\n    M2 = float(sum(D ** 2)) / n\n    TP = sum(numpy.array(X) ** 2)\n    M4 = 0\n    for i in range(1, len(D)):\n        M4 += (D[i] - D[i - 1]) ** 2\n    M4 = M4 / n\n\n    return numpy.sqrt(M2 / TP), numpy.sqrt(\n        float(M4) * TP / M2 / M2\n    )", "response": "Compute Hjorth mobility and complexity of a time series X and D."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the spectral entropy of a time series X in a frequency domain band and frequency spectrum Fs.", "response": "def spectral_entropy(X, Band, Fs, Power_Ratio=None):\n    \"\"\"Compute spectral entropy of a time series from either two cases below:\n    1. X, the time series (default)\n    2. Power_Ratio, a list of normalized signal power in a set of frequency\n    bins defined in Band (if Power_Ratio is provided, recommended to speed up)\n\n    In case 1, Power_Ratio is computed by bin_power() function.\n\n    Notes\n    -----\n    To speed up, it is recommended to compute Power_Ratio before calling this\n    function because it may also be used by other functions whereas computing\n    it here again will slow down.\n\n    Parameters\n    ----------\n\n    Band\n        list\n\n        boundary frequencies (in Hz) of bins. They can be unequal bins, e.g.\n        [0.5,4,7,12,30] which are delta, theta, alpha and beta respectively.\n        You can also use range() function of Python to generate equal bins and\n        pass the generated list to this function.\n\n        Each element of Band is a physical frequency and shall not exceed the\n        Nyquist frequency, i.e., half of sampling frequency.\n\n     X\n        list\n\n        a 1-D real time series.\n\n    Fs\n        integer\n\n        the sampling rate in physical frequency\n\n    Returns\n    -------\n\n    As indicated in return line\n\n    See Also\n    --------\n    bin_power: pyeeg function that computes spectral power in frequency bins\n\n    \"\"\"\n\n    if Power_Ratio is None:\n        Power, Power_Ratio = bin_power(X, Band, Fs)\n\n    Spectral_Entropy = 0\n    for i in range(0, len(Power_Ratio) - 1):\n        Spectral_Entropy += Power_Ratio[i] * numpy.log(Power_Ratio[i])\n    Spectral_Entropy /= numpy.log(\n        len(Power_Ratio)\n    )  # to save time, minus one is omitted\n    return -1 * Spectral_Entropy"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef svd_entropy(X, Tau, DE, W=None):\n\n    if W is None:\n        Y = embed_seq(X, Tau, DE)\n        W = numpy.linalg.svd(Y, compute_uv=0)\n        W /= sum(W)  # normalize singular values\n\n    return -1 * sum(W * numpy.log(W))", "response": "Compute SVD Entropy from two cases below."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ap_entropy(X, M, R):\n    N = len(X)\n\n    Em = embed_seq(X, 1, M)\n    A = numpy.tile(Em, (len(Em), 1, 1))\n    B = numpy.transpose(A, [1, 0, 2])\n    D = numpy.abs(A - B) #  D[i,j,k] = |Em[i][k] - Em[j][k]|\n    InRange = numpy.max(D, axis=2) <= R\n    Cm = InRange.mean(axis=0) #  Probability that random M-sequences are in range\n\n    # M+1-sequences in range iff M-sequences are in range & last values are close\n    Dp = numpy.abs(numpy.tile(X[M:], (N - M, 1)) - numpy.tile(X[M:], (N - M, 1)).T)\n    Cmp = numpy.logical_and(Dp <= R, InRange[:-1, :-1]).mean(axis=0)\n\n    # Uncomment for old (miscounted) version\n    #Cm += 1 / (N - M +1); Cm[-1] -= 1 / (N - M + 1)\n    #Cmp += 1 / (N - M)\n\n    Phi_m, Phi_mp = numpy.sum(numpy.log(Cm)), numpy.sum(numpy.log(Cmp))\n\n    Ap_En = (Phi_m - Phi_mp) / (N - M)\n\n    return Ap_En", "response": "Computeer approximate entropy of series X specified by M and R."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes Detrended Fluctuation Analysis from a time series X and length of boxes L.", "response": "def dfa(X, Ave=None, L=None):\n    \"\"\"Compute Detrended Fluctuation Analysis from a time series X and length of\n    boxes L.\n\n    The first step to compute DFA is to integrate the signal. Let original\n    series be X= [x(1), x(2), ..., x(N)].\n\n    The integrated signal Y = [y(1), y(2), ..., y(N)] is obtained as follows\n    y(k) = \\sum_{i=1}^{k}{x(i)-Ave} where Ave is the mean of X.\n\n    The second step is to partition/slice/segment the integrated sequence Y\n    into boxes. At least two boxes are needed for computing DFA. Box sizes are\n    specified by the L argument of this function. By default, it is from 1/5 of\n    signal length to one (x-5)-th of the signal length, where x is the nearest\n    power of 2 from the length of the signal, i.e., 1/16, 1/32, 1/64, 1/128,\n    ...\n\n    In each box, a linear least square fitting is employed on data in the box.\n    Denote the series on fitted line as Yn. Its k-th elements, yn(k),\n    corresponds to y(k).\n\n    For fitting in each box, there is a residue, the sum of squares of all\n    offsets, difference between actual points and points on fitted line.\n\n    F(n) denotes the square root of average total residue in all boxes when box\n    length is n, thus\n    Total_Residue = \\sum_{k=1}^{N}{(y(k)-yn(k))}\n    F(n) = \\sqrt(Total_Residue/N)\n\n    The computing to F(n) is carried out for every box length n. Therefore, a\n    relationship between n and F(n) can be obtained. In general, F(n) increases\n    when n increases.\n\n    Finally, the relationship between F(n) and n is analyzed. A least square\n    fitting is performed between log(F(n)) and log(n). The slope of the fitting\n    line is the DFA value, denoted as Alpha. To white noise, Alpha should be\n    0.5. Higher level of signal complexity is related to higher Alpha.\n\n    Parameters\n    ----------\n\n    X:\n        1-D Python list or numpy array\n        a time series\n\n    Ave:\n        integer, optional\n        The average value of the time series\n\n    L:\n        1-D Python list of integers\n        A list of box size, integers in ascending order\n\n    Returns\n    -------\n\n    Alpha:\n        integer\n        the result of DFA analysis, thus the slope of fitting line of log(F(n))\n        vs. log(n). where n is the\n\n    Examples\n    --------\n    >>> import pyeeg\n    >>> from numpy.random import randn\n    >>> print(pyeeg.dfa(randn(4096)))\n    0.490035110345\n\n    Reference\n    ---------\n    Peng C-K, Havlin S, Stanley HE, Goldberger AL. Quantification of scaling\n    exponents and crossover phenomena in nonstationary heartbeat time series.\n    _Chaos_ 1995;5:82-87\n\n    Notes\n    -----\n\n    This value depends on the box sizes very much. When the input is a white\n    noise, this value should be 0.5. But, some choices on box sizes can lead to\n    the value lower or higher than 0.5, e.g. 0.38 or 0.58.\n\n    Based on many test, I set the box sizes from 1/5 of    signal length to one\n    (x-5)-th of the signal length, where x is the nearest power of 2 from the\n    length of the signal, i.e., 1/16, 1/32, 1/64, 1/128, ...\n\n    You may generate a list of box sizes and pass in such a list as a\n    parameter.\n\n    \"\"\"\n\n    X = numpy.array(X)\n\n    if Ave is None:\n        Ave = numpy.mean(X)\n\n    Y = numpy.cumsum(X)\n    Y -= Ave\n\n    if L is None:\n        L = numpy.floor(len(X) * 1 / (\n            2 ** numpy.array(list(range(4, int(numpy.log2(len(X))) - 4))))\n        )\n\n    F = numpy.zeros(len(L))  # F(n) of different given box length n\n\n    for i in range(0, len(L)):\n        n = int(L[i])                        # for each box length L[i]\n        if n == 0:\n            print(\"time series is too short while the box length is too big\")\n            print(\"abort\")\n            exit()\n        for j in range(0, len(X), n):  # for each box\n            if j + n < len(X):\n                c = list(range(j, j + n))\n                # coordinates of time in the box\n                c = numpy.vstack([c, numpy.ones(n)]).T\n                # the value of data in the box\n                y = Y[j:j + n]\n                # add residue in this box\n                F[i] += numpy.linalg.lstsq(c, y)[1]\n        F[i] /= ((len(X) / n) * n)\n    F = numpy.sqrt(F)\n\n    Alpha = numpy.linalg.lstsq(numpy.vstack(\n        [numpy.log(L), numpy.ones(len(L))]\n    ).T, numpy.log(F))[0][0]\n\n    return Alpha"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef permutation_entropy(x, n, tau):\n\n    PeSeq = []\n    Em = embed_seq(x, tau, n)\n\n    for i in range(0, len(Em)):\n        r = []\n        z = []\n\n        for j in range(0, len(Em[i])):\n            z.append(Em[i][j])\n\n        for j in range(0, len(Em[i])):\n            z.sort()\n            r.append(z.index(Em[i][j]))\n            z[z.index(Em[i][j])] = -1\n\n        PeSeq.append(r)\n\n    RankMat = []\n\n    while len(PeSeq) > 0:\n        RankMat.append(PeSeq.count(PeSeq[0]))\n        x = PeSeq[0]\n        for j in range(0, PeSeq.count(PeSeq[0])):\n            PeSeq.pop(PeSeq.index(x))\n\n    RankMat = numpy.array(RankMat)\n    RankMat = numpy.true_divide(RankMat, RankMat.sum())\n    EntropyMat = numpy.multiply(numpy.log2(RankMat), RankMat)\n    PE = -1 * EntropyMat.sum()\n\n    return PE", "response": "Compute the Permutation Entropy of a given time series x."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef information_based_similarity(x, y, n):\n\n    Wordlist = []\n    Space = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    Sample = [0, 1]\n\n    if (n == 1):\n        Wordlist = Sample\n\n    if (n == 2):\n        Wordlist = Space\n\n    elif (n > 1):\n        Wordlist = Space\n        Buff = []\n        for k in range(0, n - 2):\n            Buff = []\n\n            for i in range(0, len(Wordlist)):\n                Buff.append(tuple(Wordlist[i]))\n            Buff = tuple(Buff)\n\n            Wordlist = []\n            for i in range(0, len(Buff)):\n                for j in range(0, len(Sample)):\n                    Wordlist.append(list(Buff[i]))\n                    Wordlist[len(Wordlist) - 1].append(Sample[j])\n\n    Wordlist.sort()\n\n    Input = [[], []]\n    Input[0] = x\n    Input[1] = y\n\n    SymbolicSeq = [[], []]\n    for i in range(0, 2):\n        Encoder = numpy.diff(Input[i])\n        for j in range(0, len(Input[i]) - 1):\n            if(Encoder[j] > 0):\n                SymbolicSeq[i].append(1)\n            else:\n                SymbolicSeq[i].append(0)\n\n    Wm = []\n    Wm.append(embed_seq(SymbolicSeq[0], 1, n).tolist())\n    Wm.append(embed_seq(SymbolicSeq[1], 1, n).tolist())\n\n    Count = [[], []]\n    for i in range(0, 2):\n        for k in range(0, len(Wordlist)):\n            Count[i].append(Wm[i].count(Wordlist[k]))\n\n    Prob = [[], []]\n    for i in range(0, 2):\n        Sigma = 0\n        for j in range(0, len(Wordlist)):\n            Sigma += Count[i][j]\n        for k in range(0, len(Wordlist)):\n            Prob[i].append(numpy.true_divide(Count[i][k], Sigma))\n\n    Entropy = [[], []]\n    for i in range(0, 2):\n        for k in range(0, len(Wordlist)):\n            if (Prob[i][k] == 0):\n                Entropy[i].append(0)\n            else:\n                Entropy[i].append(Prob[i][k] * (numpy.log2(Prob[i][k])))\n\n    Rank = [[], []]\n    Buff = [[], []]\n    Buff[0] = tuple(Count[0])\n    Buff[1] = tuple(Count[1])\n    for i in range(0, 2):\n        Count[i].sort()\n        Count[i].reverse()\n        for k in range(0, len(Wordlist)):\n            Rank[i].append(Count[i].index(Buff[i][k]))\n            Count[i][Count[i].index(Buff[i][k])] = -1\n\n    IBS = 0\n    Z = 0\n    n = 0\n    for k in range(0, len(Wordlist)):\n        if ((Buff[0][k] != 0) & (Buff[1][k] != 0)):\n            F = -Entropy[0][k] - Entropy[1][k]\n            IBS += numpy.multiply(numpy.absolute(Rank[0][k] - Rank[1][k]), F)\n            Z += F\n        else:\n            n += 1\n\n    IBS = numpy.true_divide(IBS, Z)\n    IBS = numpy.true_divide(IBS, len(Wordlist) - n)\n\n    return IBS", "response": "Calculates the information based similarity between two time series x and y."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the largest Lyauponov exponent of a given time series x using the Losenstein algorithm.", "response": "def LLE(x, tau, n, T, fs):\n    \"\"\"Calculate largest Lyauponov exponent of a given time series x using\n    Rosenstein algorithm.\n\n    Parameters\n    ----------\n\n    x\n        list\n\n        a time series\n\n    n\n        integer\n\n        embedding dimension\n\n    tau\n        integer\n\n        Embedding lag\n\n    fs\n        integer\n\n        Sampling frequency\n\n    T\n        integer\n\n        Mean period\n\n    Returns\n    ----------\n\n    Lexp\n       float\n\n       Largest Lyapunov Exponent\n\n    Notes\n    ----------\n    A n-dimensional trajectory is first reconstructed from the observed data by\n    use of embedding delay of tau, using pyeeg function, embed_seq(x, tau, n).\n    Algorithm then searches for nearest neighbour of each point on the\n    reconstructed trajectory; temporal separation of nearest neighbours must be\n    greater than mean period of the time series: the mean period can be\n    estimated as the reciprocal of the mean frequency in power spectrum\n\n    Each pair of nearest neighbours is assumed to diverge exponentially at a\n    rate given by largest Lyapunov exponent. Now having a collection of\n    neighbours, a least square fit to the average exponential divergence is\n    calculated. The slope of this line gives an accurate estimate of the\n    largest Lyapunov exponent.\n\n    References\n    ----------\n    Rosenstein, Michael T., James J. Collins, and Carlo J. De Luca. \"A\n    practical method for calculating largest Lyapunov exponents from small data\n    sets.\" Physica D: Nonlinear Phenomena 65.1 (1993): 117-134.\n\n\n    Examples\n    ----------\n    >>> import pyeeg\n    >>> X = numpy.array([3,4,1,2,4,51,4,32,24,12,3,45])\n    >>> pyeeg.LLE(X,2,4,1,1)\n    >>> 0.18771136179353307\n\n    \"\"\"\n\n    Em = embed_seq(x, tau, n)\n    M = len(Em)\n    A = numpy.tile(Em, (len(Em), 1, 1))\n    B = numpy.transpose(A, [1, 0, 2])\n    square_dists = (A - B) ** 2 #  square_dists[i,j,k] = (Em[i][k]-Em[j][k])^2\n    D = numpy.sqrt(square_dists[:,:,:].sum(axis=2)) #  D[i,j] = ||Em[i]-Em[j]||_2\n\n    # Exclude elements within T of the diagonal\n    band = numpy.tri(D.shape[0], k=T) - numpy.tri(D.shape[0], k=-T-1)\n    band[band == 1] = numpy.inf\n    neighbors = (D + band).argmin(axis=0) #  nearest neighbors more than T steps away\n\n    # in_bounds[i,j] = (i+j <= M-1 and i+neighbors[j] <= M-1)\n    inc = numpy.tile(numpy.arange(M), (M, 1))\n    row_inds = (numpy.tile(numpy.arange(M), (M, 1)).T + inc)\n    col_inds = (numpy.tile(neighbors, (M, 1)) + inc.T)\n    in_bounds = numpy.logical_and(row_inds <= M - 1, col_inds <= M - 1)\n    # Uncomment for old (miscounted) version\n    #in_bounds = numpy.logical_and(row_inds < M - 1, col_inds < M - 1)\n    row_inds[-in_bounds] = 0\n    col_inds[-in_bounds] = 0\n\n    # neighbor_dists[i,j] = ||Em[i+j]-Em[i+neighbors[j]]||_2\n    neighbor_dists = numpy.ma.MaskedArray(D[row_inds, col_inds], -in_bounds)\n    J = (-neighbor_dists.mask).sum(axis=1) #  number of in-bounds indices by row\n    # Set invalid (zero) values to 1; log(1) = 0 so sum is unchanged\n    neighbor_dists[neighbor_dists == 0] = 1\n    d_ij = numpy.sum(numpy.log(neighbor_dists.data), axis=1)\n    mean_d = d_ij[J > 0] / J[J > 0]\n\n    x = numpy.arange(len(mean_d))\n    X = numpy.vstack((x, numpy.ones(len(mean_d)))).T\n    [m, c] = numpy.linalg.lstsq(X, mean_d)[0]\n    Lexp = fs * m\n    return Lexp"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of time series representing the period of each successive oscillation in the given time series.", "response": "def periods(ts, phi=0.0):\n    \"\"\"For a single variable timeseries representing the phase of an oscillator,\n    measure the period of each successive oscillation.\n\n    An individual oscillation is defined to start and end when the phase \n    passes phi (by default zero) after completing a full cycle.\n\n    If the timeseries begins (or ends) exactly at phi, then the first\n    (or last) oscillation will be included.\n\n    Arguments: \n      ts: Timeseries (single variable)\n          The timeseries of an angle variable (radians)\n\n      phi (float): A single oscillation starts and ends at phase phi (by \n        default zero).\n    \"\"\"\n    ts = np.squeeze(ts)\n    if ts.ndim <= 1:\n        return np.diff(phase_crossings(ts, phi))\n    else:\n        return np.hstack([ts[...,i].periods(phi) for i in range(ts.shape[-1])])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef order_param(ts, axis=2):\n    return np.abs(np.exp(1.0j * ts).mean(axis=axis))", "response": "Order parameter of phase synchronization"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cwtmorlet(points, width):\n    omega = 5.0\n    s = points / (2.0 * omega * width)\n    return wavelets.morlet(points, omega, s, complete=True)", "response": "Complex morlet wavelet function compatible with scipy. signal. cwt\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef roughcwt(data, wavelet, widths):\n    out_dtype = wavelet(widths[0], widths[0]).dtype\n    output = np.zeros([len(widths), len(data)], dtype=out_dtype)\n    for ind, width in enumerate(widths):\n        wavelet_data = wavelet(min(3 * width, len(data)), width)\n        output[ind, :] = convolve(data, wavelet_data,\n                                              mode='same')\n    return output", "response": "A CWT implementation that uses a continuous wavelet transform on data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _rescale(ar):\n    max = np.nanmax(ar)\n    min = np.nanmin(ar)\n    midpoint = (max + min) / 2.0\n    return 2.0 * (ar - midpoint) / (max - min)", "response": "Shift and rescale array ar to the interval - 1 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_color_list():\n    if 'axes.prop_cycle' in plt.rcParams:\n        return [p['color'] for p in list(plt.rcParams['axes.prop_cycle'])]\n    else:\n        return plt.rcParams['axes.color_cycle']", "response": "Get cycle of colors in a way compatible with all matplotlib versions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot the timeseries and variability. Optionally plot epochs.", "response": "def _plot_variability(ts, variability, threshold=None, epochs=None):\n    \"\"\"Plot the timeseries and variability. Optionally plot epochs.\"\"\"\n    import matplotlib.style\n    import matplotlib as mpl\n    mpl.style.use('classic')\n    import matplotlib.pyplot as plt\n    if variability.ndim is 1:\n        variability = variability[:, np.newaxis, np.newaxis]\n    elif variability.ndim is 2:\n        variability = variability[:, np.newaxis, :]\n    vmeasures = variability.shape[2]\n    channels = ts.shape[1]\n    dt = (1.0*ts.tspan[-1] - ts.tspan[0]) / (len(ts) - 1)\n    fig = plt.figure()\n    ylabelprops = dict(rotation=0, \n                       horizontalalignment='right', \n                       verticalalignment='center', \n                       x=-0.01)\n    for i in range(channels):\n        rect = (0.1, 0.85*(channels - i - 1)/channels + 0.1, \n                0.8, 0.85/channels)\n        axprops = dict()\n        if channels > 10:\n            axprops['yticks'] = []\n        ax = fig.add_axes(rect, **axprops)\n        ax.plot(ts.tspan, ts[:, i])\n        if ts.labels[1] is None:\n            ax.set_ylabel(u'channel %d' % i, **ylabelprops)\n        else:\n            ax.set_ylabel(ts.labels[1][i], **ylabelprops)\n        plt.setp(ax.get_xticklabels(), visible=False)\n        if i is channels - 1:\n            plt.setp(ax.get_xticklabels(), visible=True)\n            ax.set_xlabel('time (s)')\n        ax2 = ax.twinx()\n        if vmeasures > 1:\n            mean_v = np.nanmean(variability[:, i, :], axis=1)\n            ax2.plot(ts.tspan, mean_v, color='g')\n            colors = _get_color_list()\n            for j in range(vmeasures):\n                ax2.plot(ts.tspan, variability[:, i, j], linestyle='dotted',\n                         color=colors[(3 + j) % len(colors)])\n            if i is 0:\n                ax2.legend(['variability (mean)'] + \n                          ['variability %d' % j for j in range(vmeasures)], \n                          loc='best')\n        else:\n            ax2.plot(ts.tspan, variability[:, i, 0])\n            ax2.legend(('variability',), loc='best')\n        if threshold is not None:\n            ax2.axhline(y=threshold, color='Gray', linestyle='dashed')\n        ax2.set_ylabel('variability')\n        ymin = np.nanmin(ts[:, i])\n        ymax = np.nanmax(ts[:, i])\n        tstart = ts.tspan[0]\n        if epochs:\n            # highlight epochs using rectangular patches\n            for e in epochs[i]:\n                t1 = tstart + (e[0] - 1) * dt\n                ax.add_patch(mpl.patches.Rectangle(\n                    (t1, ymin), (e[1] - e[0])*dt, ymax - ymin, alpha=0.2,\n                    color='green', ec='none'))\n    fig.axes[0].set_title(u'variability (threshold = %g)' % threshold)\n    fig.show()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef epochs(ts, variability=None, threshold=0.0, minlength=1.0, plot=True):\n    if variability is None:\n        variability = ts.variability_fp(plot=False)\n    orig_ndim = ts.ndim\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis]\n    if variability.ndim is 1:\n        variability = variability[:, np.newaxis, np.newaxis]\n    elif variability.ndim is 2:\n        variability = variability[:, np.newaxis, :]\n    channels = ts.shape[1]\n    n = len(ts)\n    dt = (1.0*ts.tspan[-1] - ts.tspan[0]) / (n - 1)\n    fs = 1.0 / dt\n    allchannels_epochs = []\n    for i in range(channels):\n        v = variability[:, i, :]\n        v = np.nanmean(v, axis=1) # mean of q different variability measures\n        # then smooth the variability with a low-pass filter\n        nonnan_ix = np.nonzero(~np.isnan(v))[0]\n        nonnans = slice(nonnan_ix.min(), nonnan_ix.max())\n        crit_freq = 1.0 # Hz\n        b, a = signal.butter(3, 2.0 * crit_freq / fs)\n        #v[nonnans] = signal.filtfilt(b, a, v[nonnans])\n        v[nonnan_ix] = signal.filtfilt(b, a, v[nonnan_ix])\n        # find all local minima of the variability not exceeding the threshold\n        m = v[1:-1]\n        l = v[0:-2]\n        r = v[2:]\n        minima = np.nonzero(~np.isnan(m) & ~np.isnan(l) & ~np.isnan(r) &\n                            (m <= threshold) & (m-l < 0) & (r-m > 0))[0] + 1\n        if len(minima) is 0:\n            print(u'Channel %d: no epochs found using threshold %g' % (\n                i, threshold))\n            allchannels_epochs.append([])\n        else:\n            # Sort the list of minima by ascending variability\n            minima = minima[np.argsort(v[minima])]\n            epochs = []\n            for m in minima:\n                # Check this minimum is not inside an existing epoch\n                overlap = False\n                for e in epochs:\n                    if m >= e[0] and m <= e[1]:\n                        overlap = True\n                        break\n                if not overlap:\n                    # Get largest subthreshold interval surrounding the minimum\n                    startix = m - 1\n                    endix = m + 1\n                    for startix in range(m - 1, 0, -1):\n                        if np.isnan(v[startix]) or v[startix] > threshold:\n                            startix += 1\n                            break\n                    for endix in range(m + 1, len(v), 1):\n                        if np.isnan(v[endix]) or v[endix] > threshold:\n                            break\n                    if (endix - startix) * dt >= minlength: \n                        epochs.append((startix, endix))\n            allchannels_epochs.append(epochs)\n    if plot:\n        _plot_variability(ts, variability, threshold, allchannels_epochs)\n    if orig_ndim is 1:\n        allchannels_epochs = allchannels_epochs[0]\n    return (variability, allchannels_epochs)", "response": "Identify stationary epochs within a time series."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndistribute epochs for a time series.", "response": "def epochs_distributed(ts, variability=None, threshold=0.0, minlength=1.0, \n                       plot=True):\n    \"\"\"Same as `epochs()`, but computes channels in parallel for speed.\n\n    (Note: This requires an IPython cluster to be started first, \n           e.g. on a workstation type 'ipcluster start')\n\n    Identify \"stationary\" epochs within a time series, based on a \n    continuous measure of variability.\n    Epochs are defined to contain the points of minimal variability, and to \n    extend as wide as possible with variability not exceeding the threshold.\n\n    Args:\n      ts  Timeseries of m variables, shape (n, m). \n      variability  (optional) Timeseries of shape (n, m, q),  giving q scalar \n                   measures of the variability of timeseries `ts` near each \n                   point in time. (if None, we will use variability_fp())\n                   Epochs require the mean of these to be below the threshold.\n      threshold   The maximum variability permitted in stationary epochs.\n      minlength   Shortest acceptable epoch length (in seconds)\n      plot  bool  Whether to display the output\n\n    Returns: (variability, allchannels_epochs) \n      variability: as above\n      allchannels_epochs: (list of) list of tuples\n      For each variable, a list of tuples (start, end) that give the \n      starting and ending indices of stationary epochs.\n      (epochs are inclusive of start point but not the end point)\n    \"\"\"\n    import distob\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis]\n    if variability is None:\n        dts = distob.scatter(ts, axis=1)\n        vepochs = distob.vectorize(epochs)\n        results = vepochs(dts, None, threshold, minlength, plot=False)\n    else: \n        def f(pair):\n            return epochs(pair[0], pair[1], threshold, minlength, plot=False)\n        allpairs = [(ts[:, i], variability[:, i]) for i in range(ts.shape[1])]\n        vf = distob.vectorize(f)\n        results = vf(allpairs)\n    vars, allchannels_epochs = zip(*results)\n    variability = distob.hstack(vars)\n    if plot:\n        _plot_variability(ts, variability, threshold, allchannels_epochs)\n    return (variability, allchannels_epochs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nidentify epochs within a multivariate time series where at least one of the specified variability is stationary.", "response": "def epochs_joint(ts, variability=None, threshold=0.0, minlength=1.0,\n                 proportion=0.75, plot=True):\n    \"\"\"Identify epochs within a multivariate time series where at least a \n    certain proportion of channels are \"stationary\", based on a previously \n    computed variability measure.\n\n    (Note: This requires an IPython cluster to be started first, \n     e.g. on a workstation type 'ipcluster start')\n\n    Args:\n      ts  Timeseries of m variables, shape (n, m). \n      variability  (optional) Timeseries of shape (n, m),  giving a scalar \n                   measure of the variability of timeseries `ts` near each \n                   point in time. (if None, we will use variability_fp())\n      threshold   The maximum variability permitted in stationary epochs.\n      minlength   Shortest acceptable epoch length (in seconds)\n      proportion  Require at least this fraction of channels to be \"stationary\"\n      plot  bool  Whether to display the output\n\n    Returns: (variability, joint_epochs)\n      joint_epochs: list of tuples\n      A list of tuples (start, end) that give the starting and ending indices \n      of time epochs that are stationary for at least `proportion` of channels.\n      (epochs are inclusive of start point but not the end point)\n    \"\"\"\n    variability, allchannels_epochs = ts.epochs_distributed(\n            variability, threshold, minlength, plot=False)\n    orig_ndim = ts.ndim\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis]\n        allchannels_epochs = [allchannels_epochs]\n        variability = variability[:, np.newaxis]\n    channels = ts.shape[1]\n    dt = (1.0*ts.tspan[-1] - ts.tspan[0]) / (len(ts) - 1)\n    starts = [(e[0], 1) for channel in allchannels_epochs for e in channel]\n    ends = [(e[1], -1) for channel in allchannels_epochs for e in channel]\n    all = sorted(starts + ends)\n    joint_epochs = []\n    in_joint_epoch = False\n    joint_start = 0.0\n    inside_count = 0\n    for bound in all:\n        inside_count += bound[1]\n        if not in_joint_epoch and 1.0*inside_count/channels >= proportion:\n            in_joint_epoch = True\n            joint_start = bound[0]\n        if in_joint_epoch and 1.0*inside_count/channels < proportion:\n            in_joint_epoch = False\n            joint_end = bound[0]\n            if (joint_end - joint_start)*dt >= minlength:\n                joint_epochs.append((joint_start, joint_end))\n    if plot:\n        joint_epochs_repeated = [joint_epochs] * channels\n        _plot_variability(ts, variability, threshold, joint_epochs_repeated)\n    return (variability, joint_epochs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots a Timeseries containing a single variable and a single simulation time series.", "response": "def plot(ts, title=None, show=True):\n    \"\"\"Plot a Timeseries\n    Args: \n      ts  Timeseries\n      title  str\n      show  bool whether to display the figure or just return a figure object  \n      \"\"\"\n    ts = _remove_pi_crossings(ts)\n    fig = plt.figure()\n    ylabelprops = dict(rotation=0, \n                       horizontalalignment='right', \n                       verticalalignment='center', \n                       x=-0.01)\n    if ts.ndim > 2: # multiple sim timeseries. collapse vars onto each subplot.\n        num_subplots = ts.shape[ts.ndim - 1]\n        if title is None:\n            title = u'time series at each node'\n        for i in range(num_subplots):\n            ax = fig.add_subplot(num_subplots, 1, i+1)\n            ax.plot(ts.tspan, ts[...,i])\n            if ts.labels[-1] is not None:\n                ax.set_ylabel(ts.labels[-1][i], **ylabelprops)\n            else:\n                ax.set_ylabel('node ' + str(i), **ylabelprops)\n            plt.setp(ax.get_xticklabels(), visible=False)\n        fig.axes[0].set_title(title)\n        plt.setp(fig.axes[num_subplots-1].get_xticklabels(), visible=True)\n        fig.axes[num_subplots-1].set_xlabel('time (s)')\n    else: # single sim timeseries. show each variable separately.\n        if ts.ndim is 1:\n            ts = ts.reshape((-1, 1))\n        num_ax = ts.shape[1]\n        if title is None:\n            title=u'time series'\n        axprops = dict()\n        if num_ax > 10:\n            axprops['yticks'] = []\n        colors = _get_color_list()\n        for i in range(num_ax):\n            rect = 0.1, 0.85*(num_ax - i - 1)/num_ax + 0.1, 0.8, 0.85/num_ax\n            ax = fig.add_axes(rect, **axprops)\n            ax.plot(ts.tspan, ts[...,i], color=colors[i % len(colors)])\n            plt.setp(ax.get_xticklabels(), visible=False)\n            if ts.labels[1] is not None:\n                ax.set_ylabel(ts.labels[1][i], **ylabelprops)\n        fig.axes[0].set_title(title)\n        plt.setp(fig.axes[num_ax-1].get_xticklabels(), visible=True)\n        fig.axes[num_ax-1].set_xlabel('time (s)')\n    if show:\n        fig.show()\n    return fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _remove_pi_crossings(ts):\n    orig_ts = ts\n    if ts.ndim is 1:\n        ts = ts[:, np.newaxis, np.newaxis]\n    elif ts.ndim is 2:\n        ts = ts[:, np.newaxis]\n    # Get the indices of those variables that have range of approx -pi to pi\n    tsmax = ts.max(axis=0)\n    tsmin = ts.min(axis=0)\n    phase_vars = np.transpose(np.nonzero((np.abs(tsmax - np.pi) < 0.01) & \n                                         (np.abs(tsmin + np.pi) < 0.01)))\n    if len(phase_vars) is 0:\n        return orig_ts\n    else:\n        ts = ts.copy()\n        for v in phase_vars:\n            ts1 = np.asarray(ts[:, v[0], v[1]]) # time series of single variable\n            ts1a = ts1[0:-1]\n            ts1b = ts1[1:]\n            p2 = np.pi/2\n            # Find time indices where phase crosses pi. Set those values to nan.\n            pc = np.nonzero((ts1a > p2) & (ts1b < -p2) | \n                            (ts1a < -p2) & (ts1b > p2))[0] + 1\n            ts1[pc] = np.nan\n            ts[:, v[0], v[1]] = ts1\n        return ts", "response": "Removes all pi crossings from the time series ts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef timeseries_from_mat(filename, varname=None, fs=1.0):\n    import scipy.io as sio\n    if varname is None:\n        mat_dict = sio.loadmat(filename)\n        if len(mat_dict) > 1:\n            raise ValueError('Must specify varname: file contains '\n                             'more than one variable. ')\n    else:\n        mat_dict = sio.loadmat(filename, variable_names=(varname,))\n        array = mat_dict.popitem()[1]\n    return Timeseries(array, fs=fs)", "response": "Load a multi - channel Timeseries from a MATLAB. mat file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_mat(ts, filename):\n    import scipy.io as sio\n    tspan = ts.tspan\n    fs = (1.0*len(tspan) - 1) / (tspan[-1] - tspan[0])\n    mat_dict = {'data': np.asarray(ts),\n                'fs': fs,\n                'labels': ts.labels[1]}\n    sio.savemat(filename, mat_dict, do_compression=True)\n    return", "response": "save a Timeseries to a MATLAB. mat file"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a multi - channel Timeseries from a file.", "response": "def timeseries_from_file(filename):\n    \"\"\"Load a multi-channel Timeseries from any file type supported by `biosig`\n\n    Supported file formats include EDF/EDF+, BDF/BDF+, EEG, CNT and GDF.\n    Full list is here: http://pub.ist.ac.at/~schloegl/biosig/TESTED\n\n    For EDF, EDF+, BDF and BDF+ files, we will use python-edf \n    if it is installed, otherwise will fall back to python-biosig.\n\n    Args: \n      filename\n\n    Returns: \n      Timeseries\n    \"\"\"\n    if not path.isfile(filename):\n        raise Error(\"file not found: '%s'\" % filename)\n    is_edf_bdf = (filename[-4:].lower() in ['.edf', '.bdf'])\n    if is_edf_bdf:\n        try:\n            import edflib\n            return _load_edflib(filename)\n        except ImportError:\n            print('python-edf not installed. trying python-biosig instead...')\n    try:\n        import biosig\n        return _load_biosig(filename)\n    except ImportError:\n        message = (\n            \"\"\"To load timeseries from file, ensure python-biosig is installed\n            e.g. on Ubuntu or Debian type `apt-get install python-biosig`\n            or get it from http://biosig.sf.net/download.html\"\"\")\n        if is_edf_bdf:\n            message += \"\"\"\\n(For EDF/BDF files, can instead install python-edf:\n                       https://bitbucket.org/cleemesser/python-edf/ )\"\"\"\n        raise Error(message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a multi - channel Timeseries from an EDF file using edflib.", "response": "def _load_edflib(filename):\n    \"\"\"load a multi-channel Timeseries from an EDF (European Data Format) file\n    or EDF+ file, using edflib.\n\n    Args:\n      filename: EDF+ file\n\n    Returns:\n      Timeseries\n    \"\"\"\n    import edflib\n    e = edflib.EdfReader(filename, annotations_mode='all')\n    if np.ptp(e.get_samples_per_signal()) != 0:\n        raise Error('channels have differing numbers of samples')\n    if np.ptp(e.get_signal_freqs()) != 0:\n        raise Error('channels have differing sample rates')\n    n = e.samples_in_file(0)\n    m = e.signals_in_file\n    channelnames = e.get_signal_text_labels()\n    dt = 1.0/e.samplefrequency(0)\n    # EDF files hold <=16 bits of information for each sample. Representing as\n    # double precision (64bit) is unnecessary use of memory. use 32 bit float:\n    ar = np.zeros((n, m), dtype=np.float32)\n    # edflib requires input buffer of float64s\n    buf = np.zeros((n,), dtype=np.float64)\n    for i in range(m):\n        e.read_phys_signal(i, 0, n, buf)\n        ar[:,i] = buf\n    tspan = np.arange(0, (n - 1 + 0.5) * dt, dt, dtype=np.float32)\n    return Timeseries(ar, tspan, labels=[None, channelnames])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef annotations_from_file(filename):\n    import edflib\n    e = edflib.EdfReader(filename, annotations_mode='all')\n    return e.read_annotations()", "response": "Get a list of event annotations from an EDF file using edflib."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _ufunc_wrap(out_arr, ufunc, method, i, inputs, **kwargs):\n    # Assigns tspan/labels to an axis only if inputs do not disagree on them.\n    shape = out_arr.shape\n    ndim = out_arr.ndim\n    if ndim is 0 or shape[0] is 0:\n        # not a timeseries\n        return out_arr\n    candidates = [a.tspan for a in inputs if (hasattr(a, 'tspan') and\n                                              a.shape[0] == shape[0])]\n    # Expensive to validate all tspans are the same. check start and end t\n    starts = [tspan[0] for tspan in candidates]\n    ends = [tspan[-1] for tspan in candidates]\n    if len(set(starts)) != 1 or len(set(ends)) != 1:\n        # inputs cannot agree on tspan\n        return out_arr\n    else:\n        new_tspan = candidates[0]\n    new_labels = [None]\n    for i in range(1, ndim):\n        candidates = [a.labels[i] for a in inputs if (hasattr(a, 'labels') and \n                 a.shape[i] == shape[i] and a.labels[i] is not None)] \n        if len(candidates) is 1:\n            new_labels.append(candidates[0])\n        elif (len(candidates) > 1 and all(labs[j] == candidates[0][j] for \n                labs in candidates[1:] for j in range(shape[i]))):\n            new_labels.append(candidates[0])\n        else:\n            new_labels.append(None)\n    if isinstance(out_arr, np.ndarray):\n        return Timeseries(out_arr, new_tspan, new_labels)\n    elif isinstance(out_arr, distob.RemoteArray):\n        return _rts_from_ra(out_arr, new_tspan, new_labels)\n    elif (isinstance(out_arr, distob.DistArray) and\n          all(isinstance(ra, RemoteTimeseries) for ra in out_arr._subarrays)):\n        return _dts_from_da(out_arr, new_tspan, new_labels)\n    else:\n        return out_arr", "response": "This function wraps the ufunc function in a Timeseries and DistTimeseries instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconstructing a RemoteTimeseries from a RemoteArray", "response": "def _rts_from_ra(ra, tspan, labels, block=True):\n    \"\"\"construct a RemoteTimeseries from a RemoteArray\"\"\"\n    def _convert(a, tspan, labels):\n        from nsim import Timeseries\n        return Timeseries(a, tspan, labels)\n    return distob.call(\n            _convert, ra, tspan, labels, prefer_local=False, block=block)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dts_from_da(da, tspan, labels):\n    sublabels = labels[:]\n    new_subarrays = []\n    for i, ra in enumerate(da._subarrays):\n        if isinstance(ra, RemoteTimeseries):\n            new_subarrays.append(ra)\n        else:\n            if labels[da._distaxis]:\n                sublabels[da._distaxis] = labels[da._distaxis][\n                        da._si[i]:da._si[i+1]]\n            new_subarrays.append(_rts_from_ra(ra, tspan, sublabels, False))\n    new_subarrays = [distob.convert_result(ar) for ar in new_subarrays]\n    da._subarrays = new_subarrays\n    da.__class__ = DistTimeseries\n    da.tspan = tspan\n    da.labels = labels\n    da.t = _Timeslice(da)\n    return da", "response": "construct a DistTimeseries from a DistArray"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a simulation of the system defined by functions f and G.", "response": "def newsim(f, G, y0, name='NewModel', modelType=ItoModel, T=60.0, dt=0.005, repeat=1, identical=True):\n    \"\"\"Make a simulation of the system defined by functions f and G.\n\n    dy = f(y,t)dt + G(y,t).dW with initial condition y0\n    This helper function is for convenience, making it easy to define \n    one-off simulations interactively in ipython.\n\n    Args:\n      f: callable(y, t) (defined in global scope) returning (n,) array\n        Vector-valued function to define the deterministic part of the system \n      G: callable(y, t) (defined in global scope) returning (n,m) array\n        Optional matrix-valued function to define noise coefficients of an Ito\n        SDE system.\n      y0 (array):  Initial condition \n      name (str): Optional class name for the new model\n      modelType (type): The type of model to simulate. Must be a subclass of\n        nsim.Model, for example nsim.ODEModel, nsim.ItoModel or \n        nsim.StratonovichModel. The default is nsim.ItoModel.\n      T: Total length of time to simulate, in seconds.\n      dt: Timestep for numerical integration.\n      repeat (int, optional)\n      identical (bool, optional)\n\n    Returns: \n      Simulation\n\n    Raises:\n      SimValueError, SimTypeError\n    \"\"\"\n    NewModel = newmodel(f, G, y0, name, modelType)\n    if repeat == 1:\n        return Simulation(NewModel(), T, dt)\n    else:\n        return RepeatedSim(NewModel, T, dt, repeat, identical)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing the functions f and G to define a new Model class for simulations. It will take functions f and G from global scope and make a new Model class out of them. It will automatically gather any globals used in the definition of f and G and turn them into attributes of the new Model. Args: f: callable(y, t) (defined in global scope) returning (n,) array Scalar or vector-valued function to define the deterministic part G: callable(y, t) (defined in global scope) returning (n,m) array Optional scalar or matrix-valued function to define noise coefficients of a stochastic system. This should be ``None`` for an ODE system. y0 (Number or array): Initial condition name (str): Optional class name for the new model modelType (type): The type of model to simulate. Must be a subclass of nsim.Model, for example nsim.ODEModel, nsim.ItoModel or nsim.StratonovichModel. The default is nsim.ItoModel. Returns: new class (subclass of Model) Raises: SimValueError, SimTypeError", "response": "def newmodel(f, G, y0, name='NewModel', modelType=ItoModel):\n    \"\"\"Use the functions f and G to define a new Model class for simulations. \n\n    It will take functions f and G from global scope and make a new Model class\n    out of them. It will automatically gather any globals used in the definition\n    of f and G and turn them into attributes of the new Model.\n\n    Args:\n      f: callable(y, t) (defined in global scope) returning (n,) array\n         Scalar or vector-valued function to define the deterministic part\n      G: callable(y, t) (defined in global scope) returning (n,m) array\n         Optional scalar or matrix-valued function to define noise coefficients\n         of a stochastic system. This should be ``None`` for an ODE system.\n      y0 (Number or array): Initial condition\n      name (str): Optional class name for the new model\n      modelType (type): The type of model to simulate. Must be a subclass of\n        nsim.Model, for example nsim.ODEModel, nsim.ItoModel or \n        nsim.StratonovichModel. The default is nsim.ItoModel.\n\n    Returns: \n      new class (subclass of Model)\n\n    Raises:\n      SimValueError, SimTypeError\n    \"\"\"\n    if not issubclass(modelType, Model):\n        raise SimTypeError('modelType must be a subclass of nsim.Model')\n    if not callable(f) or (G is not None and not callable(G)):\n        raise SimTypeError('f and G must be functions of y and t.')\n    if G is not None and f.__globals__ is not G.__globals__:\n        raise SimValueError('f and G must be defined in the same place')\n    # TODO: validate that f and G are defined at global scope.\n    # TODO: Handle nonlocals used in f,G so that we can lift this restriction.\n    if modelType is ODEModel and G is not None and not np.all(G == 0.0):\n        raise SimValueError('For an ODEModel, noise matrix G should be None')\n    if G is None or modelType is ODEModel:\n        newclass = type(name, (ODEModel,), dict())\n        setattr(newclass, 'f', staticmethod(__clone_function(f, 'f')))\n    else:\n        newclass = type(name, (modelType,), dict())\n        setattr(newclass, 'f', staticmethod(__clone_function(f, 'f')))\n        setattr(newclass, 'G', staticmethod(__clone_function(G, 'G')))\n    setattr(newclass, 'y0', copy.deepcopy(y0))\n    # For any global that is used by the functions f or G, create a \n    # corresponding attribute in our new class.\n    globals_used = [x for x in f.__globals__ if (x in f.__code__.co_names or \n        G is not None and x in G.__code__.co_names)]\n    for x in globals_used:\n        if G is None:\n            setattr(newclass, x, __AccessDict(x, newclass.f.__globals__))\n        else:\n            setattr(newclass, x, __AccessDicts(x, newclass.f.__globals__, \n                                                  newclass.G.__globals__))\n    # Put the new class into namespace __main__ (to cause dill to pickle it)\n    newclass.__module__ = '__main__'\n    import __main__\n    __main__.__dict__[name] = newclass \n    return newclass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes a new version of a function that has its own independent copy of any globals that it uses directly and has its own independent copy of any globals that it uses directly and has its own name assigned from the original function.", "response": "def __clone_function(f, name=None):\n    \"\"\"Make a new version of a function that has its own independent copy \n    of any globals that it uses directly, and has its own name. \n    All other attributes are assigned from the original function.\n\n    Args:\n      f: the function to clone\n      name (str):  the name for the new function (if None, keep the same name)\n\n    Returns:\n      A copy of the function f, having its own copy of any globals used\n\n    Raises:\n      SimValueError\n    \"\"\"\n    if not isinstance(f, types.FunctionType):\n        raise SimTypeError('Given parameter is not a function.')\n    if name is None:\n        name = f.__name__\n    newglobals = f.__globals__.copy()\n    globals_used = [x for x in f.__globals__ if x in f.__code__.co_names]\n    for x in globals_used:\n        gv = f.__globals__[x]\n        if isinstance(gv, types.FunctionType):\n            # Recursively clone any global functions used by this function.\n            newglobals[x] = __clone_function(gv)\n        elif isinstance(gv, types.ModuleType):\n            newglobals[x] = gv\n        else:\n            # If it is something else, deep copy it.\n            newglobals[x] = copy.deepcopy(gv)\n    newfunc = types.FunctionType(\n        f.__code__, newglobals, name, f.__defaults__, f.__closure__)\n    return newfunc"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef expand_dims(self, axis):\n        if axis <= self._distaxis:\n            subaxis = axis\n            new_distaxis = self._distaxis + 1\n        else:\n            subaxis = axis - 1\n            new_distaxis = self._distaxis\n        new_subts = [rts.expand_dims(subaxis) for rts in self._subarrays]\n        if axis == 0:\n            # prepended an axis: no longer a Timeseries\n            return distob.DistArray(new_subts, new_distaxis)\n        else:\n            axislabels = self.labels[self._distaxis]\n            return DistTimeseries(new_subts, new_distaxis, axislabels)", "response": "Insert a new axis at a given position in the array shape."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the absolute value element - wise.", "response": "def absolute(self):\n        \"\"\"Calculate the absolute value element-wise.\n\n        Returns:\n          absolute (Timeseries):\n            Absolute value. For complex input (a + b*j) gives sqrt(a**a + b**2)\n        \"\"\"\n        da = distob.vectorize(np.absolute)(self)\n        return _dts_from_da(da, self.tspan, self.labels)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the angle of a complex Timeseries", "response": "def angle(self, deg=False):\n        \"\"\"Return the angle of a complex Timeseries\n\n        Args:\n          deg (bool, optional):\n            Return angle in degrees if True, radians if False (default).\n\n        Returns:\n          angle (Timeseries):\n            The counterclockwise angle from the positive real axis on\n            the complex plane, with dtype as numpy.float64.\n        \"\"\"\n        if self.dtype.str[1] != 'c':\n            warnings.warn('angle() is intended for complex-valued timeseries',\n                          RuntimeWarning, 1)\n        da = distob.vectorize(np.angle)(self, deg)\n        return _dts_from_da(da, self.tspan, self.labels)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef coupling(self, source_y, target_y, weight):\n        return np.ones_like(target_y)*np.mean(source_y)*weight", "response": "This example coupling function is used to couple the output of one subsystem to the input of another subsystem."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef f(self, y, t):\n        coupling = self.coupling_function[0]\n        res = np.empty_like(self.y0)\n        for j, m in enumerate(self.submodels):\n            slicej = slice(self._si[j], self._si[j+1])\n            target_y = y[slicej] # target node state\n            res[slicej] = m.f(target_y, t) # deterministic part of submodel j\n            # get indices of all source nodes that provide input to node j:\n            sources = np.nonzero(self.network[:,j])[0]\n            for i in sources:\n                weight = self.network[i, j]\n                source_y = y[slice(self._si[i], self._si[i+1])] # source state\n                res[slicej] += coupling(source_y, target_y, weight)\n        return res", "response": "Deterministic term f of the complete network system."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnoises coefficient matrix G of the complete network system.", "response": "def G(self, y, t):\n        \"\"\"Noise coefficient matrix G of the complete network system\n        dy = f(y, t)dt + G(y, t).dot(dW)\n\n        (for an ODE network system without noise this function is not used)\n\n        Args:\n          y (array of shape (d,)): where d is the dimension of the overall\n            state space of the complete network system. \n\n        Returns:\n          G (array of shape (d, m)): where m is the number of independent\n            Wiener processes driving the complete network system. The noise\n            coefficient matrix G defines the stochastic term of the system.\n        \"\"\"\n        if self._independent_noise:\n            # then G matrix consists of submodel Gs diagonally concatenated:\n            res = np.zeros((self.dimension, self.nnoises))\n            offset = 0\n            for j, m in enumerate(self.submodels):\n                slicej = slice(self._si[j], self._si[j+1])\n                ix = (slicej, slice(offset, offset + self._nsubnoises[j]))\n                res[ix] = m.G(y[slicej], t) # submodel noise coefficient matrix\n                offset += self._nsubnoises[j]\n        else:\n            # identical driving: G consists of submodel Gs stacked vertically\n            res = np.empty((self.dimension, self.nnoises))\n            for j, m in enumerate(self.submodels):\n                slicej = slice(self._si[j], self._si[j+1])\n                ix = (slicej, slice(None))\n                res[ix] = m.G(y[slicej], t) # submodel noise coefficient matrix\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a scalar model to 1D vector systems.", "response": "def _scalar_to_vector(self, m):\n        \"\"\"Allow submodels with scalar equations. Convert to 1D vector systems.\n        Args:\n          m (Model)\n        \"\"\"\n        if not isinstance(m.y0, numbers.Number):\n            return m\n        else:\n            m = copy.deepcopy(m)\n            t0 = 0.0\n            if isinstance(m.y0, numbers.Integral):\n                numtype = np.float64\n            else:\n                numtype = type(m.y0)\n            y0_orig = m.y0\n            m.y0 = np.array([m.y0], dtype=numtype)\n            def make_vector_fn(fn):\n                def newfn(y, t):\n                    return np.array([fn(y[0], t)], dtype=numtype)\n                newfn.__name__ = fn.__name__\n                return newfn\n            def make_matrix_fn(fn):\n                def newfn(y, t):\n                    return np.array([[fn(y[0], t)]], dtype=numtype)\n                newfn.__name__ = fn.__name__\n                return newfn\n            def make_coupling_fn(fn):\n                def newfn(source_y, target_y, weight):\n                    return np.array([fn(source_y[0], target_y[0], weight)])\n                newfn.__name__ = fn.__name__\n                return newfn\n            if isinstance(m.f(y0_orig, t0), numbers.Number):\n                m.f = make_vector_fn(m.f)\n            if hasattr(m, 'G') and isinstance(m.G(y0_orig,t0), numbers.Number):\n                m.G = make_matrix_fn(m.G)\n            if (hasattr(m, 'coupling') and\n                    isinstance(m.coupling(y0_orig, y0_orig, 0.5),\n                               numbers.Number)):\n                m.coupling = make_coupling_fn(m.coupling)\n            return m"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _reshape_timeseries(self, ts):\n        if np.count_nonzero(np.diff(self._sublengths)) == 0:\n            # then all submodels have the same dimension, so can reshape array\n            # in place without copying data:\n            subdim = self.dimension // self._n\n            shp = list(ts.shape)\n            shp[1] = self._n\n            shp.insert(2, subdim)\n            ts = ts.reshape(tuple(shp)).swapaxes(1, 2)\n            # label variables only if all sub-models agree on the labels:\n            all_var_labels = [m.labels for m in self.submodels]\n            var_labels = all_var_labels[0]\n            if all(v == var_labels for v in all_var_labels[1:]):\n                ts.labels[1] = var_labels\n            ts.labels[2] = self._node_labels()\n            return ts\n        else:\n            # will pad with zeros for submodels with less variables\n            subdim = max(self._sublengths)\n            shp = list(ts.shape)\n            shp[1] = subdim\n            shp.insert(2, self._n)\n            ar = np.zeros(shp)\n            labels = ts.labels\n            labels.insert(2, self._node_labels())\n            for k in range(self._n):\n                sl = slice(self._si[k], self._si[k+1])\n                ar[:,:,k,...] = ts[:,sl,...]\n            return Timeseries(ar, ts.tspan, labels)", "response": "Introduce a new axis 2 that ranges across nodes of the network"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nintroduce a new axis 2 that ranges across nodes of the network", "response": "def _reshape_output(self, ts):\n        \"\"\"Introduce a new axis 2 that ranges across nodes of the network\"\"\"\n        subodim = len(self.submodels[0].output_vars)\n        shp = list(ts.shape)\n        shp[1] = subodim\n        shp.insert(2, self._n)\n        ts = ts.reshape(tuple(shp))\n        ts.labels[2] = self._node_labels()\n        return ts"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef output(self):\n        subts = [s.output for s in self.sims]\n        sub_ndim = subts[0].ndim\n        if sub_ndim is 1:\n            subts = [distob.expand_dims(ts, 1) for ts in subts]\n            sub_ndim += 1\n        nodeaxis = sub_ndim\n        subts = [distob.expand_dims(ts, nodeaxis) for ts in subts]\n        ts = subts[0].concatenate(subts[1:], axis=nodeaxis)\n        ts.labels[nodeaxis] = self._node_labels()\n        return ts", "response": "Rank 3 array representing output time series. Axis 0 is time axis 1 ranges across output variables of a single simulation instance axis 2 ranges across different simulation instances."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving an integer index ix into the list of sims returns the relevant subsim and subindex into s where s is the relevant subsim and m is the relevant subindex into s where s is the relevant subsim.", "response": "def _tosub(self, ix):\n        \"\"\"Given an integer index ix into the list of sims, returns the pair\n        (s, m) where s is the relevant subsim and m is the subindex into s.\n        So self[ix] == self._subsims[s][m]\n        \"\"\"\n        N = self._n\n        if ix >= N or ix < -N:\n            raise IndexError(\n                    'index %d out of bounds for list of %d sims' % (ix, N))\n        if ix < 0:\n            ix += N\n        for s in range(0, self._n):\n            if self._si[s + 1] - 1 >= ix:\n                break\n        m = ix - self._si[s]\n        return s, m"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _tosubs(self, ixlist):\n        n = len(ixlist)\n        N = self._n\n        ss = []\n        ms = []\n        if n == 0:\n            return ss, ms\n        j = 0 # the position in ixlist currently being processed\n        ix = ixlist[j]\n        if ix >= N or ix < -N:\n            raise IndexError(\n                    'index %d out of bounds for list of %d sims' % (ix, N))\n        if ix < 0:\n            ix += N\n        while j < n:\n            for s in range(0, self._n):\n                low = self._si[s]\n                high = self._si[s + 1]\n                if ix >= low and ix < high:\n                    ss.append(s)\n                    msj = [ix - low]\n                    j += 1\n                    while j < n:\n                        ix = ixlist[j]\n                        if ix >= N or ix < -N:\n                            raise IndexError(\n                              'index %d out of bounds for list of %d sims' % (\n                                ix, N))\n                        if ix < 0:\n                            ix += N\n                        if ix < low or ix >= high:\n                            break\n                        msj.append(ix - low)\n                        j += 1\n                    ms.append(msj)\n                if ix < low:\n                    break\n        return ss, ms", "response": "Maps a list of integer indices to sub - indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef output(self):\n        subts = [rms.output for rms in self._subsims]\n        distaxis = subts[0].ndim - 1\n        return DistTimeseries(subts, distaxis, self._node_labels())", "response": "Rank 3 array representing output time series. Axis 0 is time axis 1 ranges across output variables of a single simulation axis 2 isSetNodeCounts = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a time series ts find the times at which the value c crosses at least d.", "response": "def crossing_times(ts, c=0.0, d=0.0):\n    \"\"\"For a single variable timeseries, find the times at which the\n    value crosses ``c`` from above or below. Can optionally set a non-zero\n    ``d`` to impose the condition that the value must wander at least ``d`` \n    units away from ``c`` between crossings.\n\n    If the timeseries begins (or ends) exactly at ``c``, then time zero \n    (or the ending time) is also included as a crossing event, \n    so that the boundaries of the first and last excursions are included.\n\n    If the actual crossing time falls between two time steps, linear\n    interpolation is used to estimate the crossing time.\n\n    Args:\n      ts: Timeseries (single variable)\n\n      c (float): Critical value at which to report crossings.\n\n      d (float): Optional min distance from c to be attained between crossings.\n\n    Returns:\n      array of float\n    \"\"\"\n    #TODO support multivariate time series\n    ts = ts.squeeze()\n    if ts.ndim is not 1:\n        raise ValueError('Currently can only use on single variable timeseries')\n\n    # Translate to put the critical value at zero:\n    ts = ts - c\n\n    tsa = ts[0:-1]\n    tsb = ts[1:]\n    # Time indices where phase crosses or reaches zero from below or above\n    zc = np.nonzero((tsa < 0) & (tsb >= 0) | (tsa > 0) & (tsb <= 0))[0] + 1\n    # Estimate crossing time interpolated linearly within a single time step\n    va = ts[zc-1]\n    vb = ts[zc]\n    ct = (np.abs(vb)*ts.tspan[zc-1] +\n          np.abs(va)*ts.tspan[zc]) / np.abs(vb - va) # denominator always !=0\n    # Also include starting time if we started exactly at zero\n    if ts[0] == 0.0:\n        zc = np.r_[np.array([0]), zc]\n        ct = np.r_[np.array([ts.tspan[0]]), ct]\n\n    if d == 0.0 or ct.shape[0] is 0:\n        return ct\n\n    # Time indices where value crosses c+d or c-d:\n    dc = np.nonzero((tsa < d) & (tsb >= d) | (tsa > -d) & (tsb <= -d))[0] + 1\n    # Select those zero-crossings separated by at least one d-crossing\n    splice = np.searchsorted(dc, zc)\n    which_zc = np.r_[np.array([0]), np.nonzero(splice[0:-1] - splice[1:])[0] +1]\n    return ct[which_zc]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef autocorrelation(ts, normalized=False, unbiased=False):\n    ts = np.squeeze(ts)\n    if ts.ndim <= 1:\n        if normalized:\n            ts = (ts - ts.mean())/ts.std()\n        N = ts.shape[0]\n        ar = np.asarray(ts)\n        acf = np.correlate(ar, ar, mode='full')\n        outlen = (acf.shape[0] + 1) / 2\n        acf = acf[(outlen - 1):]\n        if unbiased:\n            factor = np.array([1.0/(N - m) for m in range(0, outlen)])\n            acf = acf * factor\n        dt = (ts.tspan[-1] - ts.tspan[0]) / (len(ts) - 1.0)\n        lags = np.arange(outlen)*dt\n        return Timeseries(acf, tspan=lags, labels=ts.labels)\n    else:\n        # recursively handle arrays of dimension > 1\n        lastaxis = ts.ndim - 1\n        m = ts.shape[lastaxis]\n        acfs = [ts[...,i].autocorrelation(normalized, unbiased)[...,np.newaxis]\n                for i in range(m)]\n        res = distob.concatenate(acfs, axis=lastaxis)\n        res.labels[lastaxis] = ts.labels[lastaxis]\n        return res", "response": "Returns the discrete linear convolution of a time series with itself optionally using unbiased normalization."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fan_speed(self, value):\n        if value not in range(1, 10):\n            raise exceptions.RoasterValueError\n\n        self._fan_speed.value = value", "response": "Verifies the value is between 1 and 9 inclusively."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef heat_setting(self, value):\n        if value not in range(0, 4):\n            raise exceptions.RoasterValueError\n\n        self._heat_setting.value = value", "response": "Verifies that the heat setting is between 0 and 3."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef heater_level(self, value):\n        if self._ext_sw_heater_drive:\n            if value not in range(0, self._heater_bangbang_segments+1):\n                raise exceptions.RoasterValueError\n            self._heater_level.value = value\n        else:\n            raise exceptions.RoasterValueError", "response": "Verifies that the heater_level is between 0 and heater_segments. Will throw RoasterValueError otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the state transition function for every available freshroastsr700 state.", "response": "def set_state_transition_func(self, func):\n        \"\"\"THIS FUNCTION MUST BE CALLED BEFORE CALLING\n        freshroastsr700.auto_connect().\n\n        Set, or re-set, the state transition function callback.\n        The supplied function will be called from a separate thread within\n        freshroastsr700, triggered by a separate, internal child process.\n        This function will fail if the freshroastsr700 device is already\n        connected to hardware, because by that time, the timer process\n        and thread have already been spawned.\n\n        Args:\n            state_transition_func (func): the function to call for every\n            state transition.  A state transition occurs whenever the\n            freshroastsr700's time_remaining value counts down to 0.\n\n        Returns:\n            nothing\n       \"\"\"\n        if self._connected.value:\n            logging.error(\"freshroastsr700.set_state_transition_func must be \"\n                          \"called before freshroastsr700.auto_connect().\"\n                          \" Not registering func.\")\n            return False\n        # no connection yet. so OK to set func pointer\n        self._create_state_transition_system(func)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_data_run(self, event_to_wait_on):\n        # with the daemon=Turue setting, this thread should\n        # quit 'automatically'\n        while event_to_wait_on.wait():\n            event_to_wait_on.clear()\n            if self.update_data_callback_kill_event.is_set():\n                return\n            self.update_data_func()", "response": "This is the main thread that listens to an event from\n           the comm process to execute the update_data_func callback\n           in the context of the main process."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef state_transition_run(self, event_to_wait_on):\n        # with the daemon=Turue setting, this thread should\n        # quit 'automatically'\n        while event_to_wait_on.wait():\n            event_to_wait_on.clear()\n            if self.state_transition_callback_kill_event.is_set():\n                return\n            self.state_transition_func()", "response": "This is the main thread that listens to an event from\n           the state_transition_func callback\n           is called when the state_transition_func is called."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _connect(self):\n        # the following call raises a RoasterLookupException when the device\n        # is not found. It is\n        port = utils.find_device('1A86:5523')\n        # on some systems, after the device port is added to the device list,\n        # it can take up to 20 seconds after USB insertion for\n        # the port to become available... (!)\n        # let's put a safety timeout in here as a precaution\n        wait_timeout = time.time() + 40.0  # should be PLENTY of time!\n        # let's update the _connect_state while we're at it...\n        self._connect_state.value = self.CS_CONNECTING\n        connect_success = False\n        while time.time() < wait_timeout:\n            try:\n                self._ser = serial.Serial(\n                    port=port,\n                    baudrate=9600,\n                    bytesize=8,\n                    parity='N',\n                    stopbits=1.5,\n                    timeout=0.25,\n                    xonxoff=False,\n                    rtscts=False,\n                    dsrdtr=False)\n                connect_success = True\n                break\n            except serial.SerialException:\n                time.sleep(0.5)\n        if not connect_success:\n            # timeout on attempts\n            raise exceptions.RoasterLookupError\n\n        self._initialize()", "response": "Connect to the roaster and creates a communication thread."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _initialize(self):\n        self._header.value = b'\\xAA\\x55'\n        self._current_state.value = b'\\x00\\x00'\n        s = self._generate_packet()\n        self._ser.write(s)\n        self._header.value = b'\\xAA\\xAA'\n        self._current_state.value = b'\\x02\\x01'\n\n        return self._read_existing_recipe()", "response": "Sends the initialization packet to the roaster."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect(self):\n        self._start_connect(self.CA_SINGLE_SHOT)\n        while(self._connect_state.value == self.CS_ATTEMPTING_CONNECT or\n              self._connect_state.value == self.CS_CONNECTING):\n            time.sleep(0.1)\n        if self.CS_CONNECTED != self._connect_state.value:\n            raise exceptions.RoasterLookupError", "response": "Attempts to connect to the computer immediately. Will not retry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _start_connect(self, connect_type):\n        if self._connect_state.value != self.CS_NOT_CONNECTED:\n            # already done or in process, assume success\n            return\n\n        self._connected.value = 0\n        self._connect_state.value = self.CS_ATTEMPTING_CONNECT\n        # tell comm process to attempt connection\n        self._attempting_connect.value = connect_type\n\n        # EXTREMELY IMPORTANT - for this to work at all in Windows,\n        # where the above processes are spawned (vs forked in Unix),\n        # the thread objects (as sattributes of this object) must be\n        # assigned to this object AFTER we have spawned the processes.\n        # That way, multiprocessing can pickle the freshroastsr700\n        # successfully. (It can't pickle thread-related stuff.)\n        if self.update_data_func is not None:\n            # Need to launch the thread that will listen to the event\n            self._create_update_data_system(\n                None, setFunc=False, createThread=True)\n            self.update_data_thread.start()\n        if self.state_transition_func is not None:\n            # Need to launch the thread that will listen to the event\n            self._create_state_transition_system(\n                None, setFunc=False, createThread=True)\n            self.state_transition_thread.start()", "response": "Starts the connection process."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nattempts to connect to the roaster every quarter of a second. Returns True if successful False otherwise.", "response": "def _auto_connect(self):\n        \"\"\"Attempts to connect to the roaster every quarter of a second.\"\"\"\n        while not self._teardown.value:\n            try:\n                self._connect()\n                return True\n            except exceptions.RoasterLookupError:\n                time.sleep(.25)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo not call this directly - call auto_connect(), which will spawn comm() for you. This is the main communications loop to the roaster. whenever a valid packet is received from the device, if an update_data_event is available, it will be signalled. Args: thermostat (bool): thermostat mode. if set to True, turns on thermostat mode. In thermostat mode, freshroastsr700 takes control of heat_setting and does software PID control to hit the demanded target_temp. ext_sw_heater_drive (bool): enable direct control over the internal heat_controller object. Defaults to False. When set to True, the thermostat field is IGNORED, and assumed to be False. Direct control over the software heater_level means that the PID controller cannot control the heater. Since thermostat and ext_sw_heater_drive cannot be allowed to both be True, this arg is given precedence over the thermostat arg. kp (float): Kp value to use for PID control. Defaults to 0.06. ki (float): Ki value to use for PID control. Defaults to 0.0075. kd (float): Kd value to use for PID control. Defaults to 0.01. heater_segments (int): the pseudo-control range for the internal heat_controller object. Defaults to 8. update_data_event (multiprocessing.Event): If set, allows the comm_process to signal to the parent process that new device data is available. Returns: nothing", "response": "def _comm(self, thermostat=False,\n              kp=0.06, ki=0.0075, kd=0.01,\n              heater_segments=8, ext_sw_heater_drive=False,\n              update_data_event=None):\n        \"\"\"Do not call this directly - call auto_connect(), which will spawn\n        comm() for you.\n\n        This is the main communications loop to the roaster.\n        whenever a valid packet is received from the device, if an\n        update_data_event is available, it will be signalled.\n\n        Args:\n            thermostat (bool): thermostat mode.\n            if set to True, turns on thermostat mode.  In thermostat\n            mode, freshroastsr700 takes control of heat_setting and does\n            software PID control to hit the demanded target_temp.\n\n            ext_sw_heater_drive (bool): enable direct control over the internal\n            heat_controller object.  Defaults to False. When set to True, the\n            thermostat field is IGNORED, and assumed to be False.  Direct\n            control over the software heater_level means that the\n            PID controller cannot control the heater.  Since thermostat and\n            ext_sw_heater_drive cannot be allowed to both be True, this arg\n            is given precedence over the thermostat arg.\n\n            kp (float): Kp value to use for PID control. Defaults to 0.06.\n\n            ki (float): Ki value to use for PID control. Defaults to 0.0075.\n\n            kd (float): Kd value to use for PID control. Defaults to 0.01.\n\n            heater_segments (int): the pseudo-control range for the internal\n            heat_controller object.  Defaults to 8.\n\n            update_data_event (multiprocessing.Event): If set, allows the\n            comm_process to signal to the parent process that new device data\n            is available.\n\n        Returns:\n            nothing\n        \"\"\"\n        # since this process is started with daemon=True, it should exit\n        # when the owning process terminates. Therefore, safe to loop forever.\n        while not self._teardown.value:\n\n            # waiting for command to attempt connect\n            # print( \"waiting for command to attempt connect\")\n            while self._attempting_connect.value == self.CA_NONE:\n                time.sleep(0.25)\n                if self._teardown.value:\n                    break\n            # if we're tearing down, bail now.\n            if self._teardown.value:\n                break\n\n            # we got the command to attempt to connect\n            # change state to 'attempting_connect'\n            self._connect_state.value = self.CS_ATTEMPTING_CONNECT\n            # attempt connection\n            if self.CA_AUTO == self._attempting_connect.value:\n                # this call will block until a connection is achieved\n                # it will also set _connect_state to CS_CONNECTING\n                # if appropriate\n                if self._auto_connect():\n                    # when we unblock, it is an indication of a successful\n                    # connection\n                    self._connected.value = 1\n                    self._connect_state.value = self.CS_CONNECTED\n                else:\n                    # failure, normally due to a timeout\n                    self._connected.value = 0\n                    self._connect_state.value = self.CS_NOT_CONNECTED\n                    # we failed to connect - start over from the top\n                    # reset flag\n                    self._attempting_connect.value = self.CA_NONE\n                    continue\n\n            elif self.CA_SINGLE_SHOT == self._attempting_connect.value:\n                # try once, now, if failure, start teh big loop over\n                try:\n                    self._connect()\n                    self._connected.value = 1\n                    self._connect_state.value = self.CS_CONNECTED\n                except exceptions.RoasterLookupError:\n                    self._connected.value = 0\n                    self._connect_state.value = self.CS_NOT_CONNECTED\n                if self._connect_state.value != self.CS_CONNECTED:\n                    # we failed to connect - start over from the top\n                    # reset flag\n                    self._attempting_connect.value = self.CA_NONE\n                    continue\n            else:\n                # shouldn't be here\n                # reset flag\n                self._attempting_connect.value = self.CA_NONE\n                continue\n\n            # We are connected!\n            # print( \"We are connected!\")\n            # reset flag right away\n            self._attempting_connect.value = self.CA_NONE\n\n            # Initialize PID controller if thermostat function was specified at\n            # init time\n            pidc = None\n            heater = None\n            if(thermostat):\n                pidc = pid.PID(kp, ki, kd,\n                               Output_max=heater_segments,\n                               Output_min=0\n                               )\n            if thermostat or ext_sw_heater_drive:\n                heater = heat_controller(number_of_segments=heater_segments)\n\n            read_state = self.LOOKING_FOR_HEADER_1\n            r = []\n            write_errors = 0\n            read_errors = 0\n            while not self._disconnect.value:\n                start = datetime.datetime.now()\n                # write to device\n                if not self._write_to_device():\n                    logging.error('comm - _write_to_device() failed!')\n                    write_errors += 1\n                    if write_errors > 3:\n                        # it's time to consider the device as being \"gone\"\n                        logging.error('comm - 3 successive write '\n                                      'failures, disconnecting.')\n                        self._disconnect.value = 1\n                        continue\n                else:\n                    # reset write_errors\n                    write_errors = 0\n\n                # read from device\n                try:\n                    while self._ser.in_waiting:\n                        _byte = self._ser.read(1)\n                        read_state, r, err = (\n                            self._process_reponse_byte(\n                                read_state, _byte, r, update_data_event))\n                except IOError:\n                    # typically happens when device is suddenly unplugged\n                    logging.error('comm - read from device failed!')\n                    read_errors += 1\n                    if write_errors > 3:\n                        # it's time to consider the device as being \"gone\"\n                        logging.error('comm - 3 successive read '\n                                      'failures, disconnecting.')\n                        self._disconnect.value = 1\n                        continue\n                else:\n                    read_errors = 0\n\n                # next, drive SW heater when using\n                # thermostat mode (PID controller calcs)\n                # or in external sw heater drive mode,\n                # when roasting.\n                if thermostat or ext_sw_heater_drive:\n                    if 'roasting' == self.get_roaster_state():\n                        if heater.about_to_rollover():\n                            # it's time to use the PID controller value\n                            # and set new output level on heater!\n                            if ext_sw_heater_drive:\n                                # read user-supplied value\n                                heater.heat_level = self._heater_level.value\n                            else:\n                                # thermostat\n                                output = pidc.update(\n                                    self.current_temp, self.target_temp)\n                                heater.heat_level = output\n                                # make this number visible to other processes...\n                                self._heater_level.value = heater.heat_level\n                        # read bang-bang heater output array element & apply it\n                        if heater.generate_bangbang_output():\n                            # ON\n                            self.heat_setting = 3\n                        else:\n                            # OFF\n                            self.heat_setting = 0\n                    else:\n                        # for all other states, heat_level = OFF\n                        heater.heat_level = 0\n                        # make this number visible to other processes...\n                        self._heater_level.value = heater.heat_level\n                        self.heat_setting = 0\n\n                # calculate sleep time to stick to 0.25sec period\n                comp_time = datetime.datetime.now() - start\n                sleep_duration = 0.25 - comp_time.total_seconds()\n                if sleep_duration > 0:\n                    time.sleep(sleep_duration)\n\n            self._ser.close()\n            # reset disconnect flag\n            self._disconnect.value = 0\n            # reset connection values\n            self._connected.value = 0\n            self._connect_state.value = self.CS_NOT_CONNECTED"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _timer(self, state_transition_event=None):\n        while not self._teardown.value:\n            state = self.get_roaster_state()\n            if(state == 'roasting' or state == 'cooling'):\n                time.sleep(1)\n                self.total_time += 1\n                if(self.time_remaining > 0):\n                    self.time_remaining -= 1\n                else:\n                    if(state_transition_event is not None):\n                        state_transition_event.set()\n                    else:\n                        self.idle()\n            else:\n                time.sleep(0.01)", "response": "This is the main timer loop used to keep track of the time while the roaster is in a cooling state."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a string based upon the current state of the roaster. Will throw an exception if the state is unknown.", "response": "def get_roaster_state(self):\n        \"\"\"Returns a string based upon the current state of the roaster. Will\n        raise an exception if the state is unknown.\n\n        Returns:\n            'idle' if idle,\n            'sleeping' if sleeping,\n            'cooling' if cooling,\n            'roasting' if roasting,\n            'connecting' if in hardware connection phase,\n            'unknown' otherwise\n        \"\"\"\n        value = self._current_state.value\n        if(value == b'\\x02\\x01'):\n            return 'idle'\n        elif(value == b'\\x04\\x04'):\n            return 'cooling'\n        elif(value == b'\\x08\\x01'):\n            return 'sleeping'\n        # handle null bytes as empty strings\n        elif(value == b'\\x00\\x00' or value == b''):\n            return 'connecting'\n        elif(value == b'\\x04\\x02'):\n            return 'roasting'\n        else:\n            return 'unknown'"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _generate_packet(self):\n        roaster_time = utils.seconds_to_float(self._time_remaining.value)\n        packet = (\n            self._header.value +\n            self._temp_unit.value +\n            self._flags.value +\n            self._current_state.value +\n            struct.pack(\">B\", self._fan_speed.value) +\n            struct.pack(\">B\", int(round(roaster_time * 10.0))) +\n            struct.pack(\">B\", self._heat_setting.value) +\n            b'\\x00\\x00' +\n            self._footer)\n\n        return packet", "response": "Generates a packet based upon the current class variables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the desired output level. Must be between 0 and number_of_segments inclusive.", "response": "def heat_level(self, value):\n        \"\"\"Set the desired output level. Must be between 0 and\n        number_of_segments inclusive.\"\"\"\n        if value < 0:\n            self._heat_level = 0\n        elif round(value) > self._num_segments:\n            self._heat_level = self._num_segments\n        else:\n            self._heat_level = int(round(value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_bangbang_output(self):\n        if self._current_index >= self._num_segments:\n            # we're due to switch over to the next\n            # commanded heat_level\n            self._heat_level_now = self._heat_level\n            # reset array index\n            self._current_index = 0\n        # return output\n        out = self._output_array[self._heat_level_now][self._current_index]\n        self._current_index += 1\n        return out", "response": "Generates the latest on or off pulse in\n           the string of on or off or off."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef next_state(self):\n        self.active_recipe_item += 1\n        if self.active_recipe_item >= len(self.recipe):\n            # we're done!\n            return\n        # show state step on screen\n        print(\"--------------------------------------------\")\n        print(\"Setting next process step: %d\" % self.active_recipe_item)\n        print(\"time:%d, target: %ddegF, fan: %d, state: %s\" %\n              (self.recipe[self.active_recipe_item]['time_remaining'],\n               self.recipe[self.active_recipe_item]['target_temp'],\n               self.recipe[self.active_recipe_item]['fan_speed'],\n               self.recipe[self.active_recipe_item]['state']\n               ))\n        print(\"--------------------------------------------\")\n        # set values for next state\n        self.roaster.time_remaining = (\n            self.recipe[self.active_recipe_item]['time_remaining'])\n        self.roaster.target_temp = (\n            self.recipe[self.active_recipe_item]['target_temp'])\n        self.roaster.fan_speed = (\n            self.recipe[self.active_recipe_item]['fan_speed'])\n        # set state\n        if(self.recipe[self.active_recipe_item]['state'] == 'roasting'):\n            self.roaster.roast()\n        elif(self.recipe[self.active_recipe_item]['state'] == 'cooling'):\n            self.roaster.cool()\n        elif(self.recipe[self.active_recipe_item]['state'] == 'idle'):\n            self.roaster.idle()\n        elif(self.recipe[self.active_recipe_item]['state'] == 'cooling'):\n            self.roaster.sleep()", "response": "This method is called when the time remaining ends. It is a method that will be called when the time remaining ends."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_results(self):\n        for result in self._results:\n            provider = result.provider\n            self.providers.append(provider)\n            if result.error:\n                self.failed_providers.append(provider)\n                continue\n            if not result.response:\n                continue\n            # set blacklisted to True if ip is detected with at least one dnsbl\n            self.blacklisted = True\n            provider_categories = provider.process_response(result.response)\n            assert provider_categories.issubset(DNSBL_CATEGORIES)\n            self.categories = self.categories.union(provider_categories)\n            self.detected_by[provider.host] = list(provider_categories)", "response": "Process results by providers and categories."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking a DNSBL request to check the DNSBL s cache for a specific IP address.", "response": "async def dnsbl_request(self, addr, provider):\n        \"\"\"\n        Make lookup to dnsbl provider\n        Parameters:\n            * addr (string) - ip address to check\n            * provider (string) - dnsbl provider\n\n        Returns:\n            * DNSBLResponse object\n\n        Raises:\n            * ValueError\n        \"\"\"\n        response = None\n        error = None\n        try:\n            socket.inet_aton(addr)\n        except socket.error:\n            raise ValueError('wrong ip format')\n        ip_reversed = '.'.join(reversed(addr.split('.')))\n        dnsbl_query = \"%s.%s\" % (ip_reversed, provider.host)\n        try:\n            async with self._semaphore:\n                response = await self._resolver.query(dnsbl_query, 'A')\n        except aiodns.error.DNSError as exc:\n            if exc.args[0] != 4: # 4: domain name not found:\n                error = exc\n\n        return DNSBLResponse(addr=addr, provider=provider, response=response, error=error)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef frange(start, stop, step, precision):\n    value = start\n    while round(value, precision) < stop:\n        yield round(value, precision)\n        value += step", "response": "A generator that will generate a range of floats."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_device(vidpid):\n    for port in list_ports.comports():\n        if re.search(vidpid, port[2], flags=re.IGNORECASE):\n            return port[0]\n\n    raise exceptions.RoasterLookupError", "response": "Finds a connected device with the given VID : PID. Returns the serial\n    port url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, currentTemp, targetTemp):\n        # in this implementation, ki includes the dt multiplier term,\n        # and kd includes the dt divisor term.  This is typical practice in\n        # industry.\n        self.targetTemp = targetTemp\n        self.error = targetTemp - currentTemp\n\n        self.P_value = self.Kp * self.error\n        # it is common practice to compute derivative term against PV,\n        # instead of de/dt.  This is because de/dt spikes\n        # when the set point changes.\n\n        # PV version with no dPV/dt filter - note 'previous'-'current',\n        # that's desired, how the math works out\n        self.D_value = self.Kd * (self.Derivator - currentTemp)\n        self.Derivator = currentTemp\n\n        self.Integrator = self.Integrator + self.error\n        if self.Integrator > self.Integrator_max:\n            self.Integrator = self.Integrator_max\n        elif self.Integrator < self.Integrator_min:\n            self.Integrator = self.Integrator_min\n\n        self.I_value = self.Integrator * self.Ki\n\n        output = self.P_value + self.I_value + self.D_value\n        if output > self.Output_max:\n            output = self.Output_max\n        if output < self.Output_min:\n            output = self.Output_min\n        return(output)", "response": "Calculate PID output value for given reference input and feedback."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads dict from file for random words.", "response": "def load_nouns(self, file):\n        \"\"\"\n        Load dict from file for random words.\n\n        :param str file: filename\n        \"\"\"\n        with open(os.path.join(main_dir, file + '.dat'), 'r') as f:\n            self.nouns = json.load(f)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_dmails(self, file):\n        with open(os.path.join(main_dir, file + '.dat'), 'r') as f:\n            self.dmails = frozenset(json.load(f))", "response": "Load list of random mails from file for random mails"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads dict from file for random nicknames.", "response": "def load_nicknames(self, file):\n        \"\"\"\n        Load dict from file for random nicknames.\n\n        :param str file: filename\n        \"\"\"\n        with open(os.path.join(main_dir, file + '.dat'), 'r') as f:\n            self.nicknames = json.load(f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef random_words(self, letter=None, count=1):\n        self.check_count(count)\n\n        words = []\n\n        if letter is None:\n            all_words = list(\n                chain.from_iterable(self.nouns.values()))\n\n            try:\n                words = sample(all_words, count)\n            except ValueError:\n                len_sample = len(all_words)\n                raise ValueError('Param \"count\" must be less than {0}. \\\n(It is only {0} words)'.format(len_sample + 1, letter))\n\n        elif type(letter) is not str:\n            raise ValueError('Param \"letter\" must be string.')\n\n        elif letter not in self.available_letters:\n            raise ValueError(\n                'Param \"letter\" must be in {0}.'.format(\n                    self.available_letters))\n\n        elif letter in self.available_letters:\n            try:\n                words = sample(self.nouns[letter], count)\n            except ValueError:\n                len_sample = len(self.nouns[letter])\n                raise ValueError('Param \"count\" must be less than {0}. \\\n(It is only {0} words for letter \"{1}\")'.format(len_sample + 1, letter))\n\n        return words", "response": "Returns a list of random words."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of random nicks.", "response": "def random_nicks(self, letter=None, gender='u', count=1):\n        \"\"\"\n        Return list of random nicks.\n\n        :param str letter: letter\n        :param str gender: ``'f'`` for female, ``'m'`` for male and None for both\n        :param int count: how much nicks\n        :rtype: list\n        :returns: list of random nicks\n        :raises: ValueError\n        \"\"\"\n        self.check_count(count)\n\n        nicks = []\n\n        if gender not in ('f', 'm', 'u'):\n            raise ValueError('Param \"gender\" must be in (f, m, u)')\n\n        if letter is None:\n\n            all_nicks = list(\n                chain.from_iterable(self.nicknames[gender].values()))\n\n            try:\n                nicks = sample(all_nicks, count)\n            except ValueError:\n                len_sample = len(all_nicks)\n                raise ValueError('Param \"count\" must be less than {0}. \\\n(It is only {0} words.\")'.format(len_sample + 1))\n\n        elif type(letter) is not str:\n            raise ValueError('Param \"letter\" must be string.')\n\n        elif letter not in self.available_letters:\n            raise ValueError(\n                'Param \"letter\" must be in \"{0}\".'.format(\n                    self.available_letters))\n\n        elif letter in self.available_letters:\n            try:\n                nicks = sample(self.nicknames[gender][letter], count)\n            except ValueError:\n                len_sample = len(self.nicknames[gender][letter])\n                raise ValueError('Param \"count\" must be less than {0}. \\\n(It is only {0} nicks for letter \"{1}\")'.format(len_sample + 1, letter))\n\n        return nicks"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn random e - mails.", "response": "def randomMails(self, count=1):\n        \"\"\"\n        Return random e-mails.\n\n        :rtype: list\n        :returns: list of random e-mails\n        \"\"\"\n        self.check_count(count)\n\n        random_nicks = self.rn.random_nicks(count=count)\n        random_domains = sample(self.dmails, count)\n\n        return [\n            nick.lower() + \"@\" + domain for nick, domain in zip(random_nicks,\n                                                                random_domains)\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sentences_list(self, sentences=1):\n        if sentences < 1:\n            raise ValueError('Param \"sentences\" must be greater than 0.')\n\n        sentences_list = []\n\n        while sentences:\n            num_rand_words = random.randint(self.MIN_WORDS, self.MAX_WORDS)\n\n            random_sentence = self.make_sentence(\n                random.sample(self.words, num_rand_words))\n\n            sentences_list.append(random_sentence)\n            sentences -= 1\n\n        return sentences_list", "response": "Returns a list of sentences in the language."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_sentence(list_words):\n        lw_len = len(list_words)\n\n        if lw_len > 6:\n            list_words.insert(lw_len // 2 + random.choice(range(-2, 2)), ',')\n\n        sentence = ' '.join(list_words).replace(' ,', ',')\n\n        return sentence.capitalize() + '.'", "response": "Return a sentence from list of words."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the cover image in the OPF file.", "response": "def _discover_cover_image(zf, opf_xmldoc, opf_filepath):\n    '''\n    Find the cover image path in the OPF file.\n    Returns a tuple: (image content in base64, file extension)\n    '''\n    content = None\n    filepath = None\n    extension = None\n\n    # Strategies to discover the cover-image path:\n\n    # e.g.: <meta name=\"cover\" content=\"cover\"/>\n    tag = find_tag(opf_xmldoc, 'meta', 'name', 'cover')\n    if tag and 'content' in tag.attributes.keys():\n        item_id = tag.attributes['content'].value\n        if item_id:\n            # e.g.: <item href=\"cover.jpg\" id=\"cover\" media-type=\"image/jpeg\"/>\n            filepath, extension = find_img_tag(opf_xmldoc, 'item', 'id', item_id)\n    if not filepath:\n        filepath, extension = find_img_tag(opf_xmldoc, 'item', 'id', 'cover-image')\n    if not filepath:\n        filepath, extension = find_img_tag(opf_xmldoc, 'item', 'id', 'cover')\n\n    # If we have found the cover image path:\n    if filepath:\n        # The cover image path is relative to the OPF file\n        base_dir = os.path.dirname(opf_filepath)\n        # Also, normalize the path (ie opfpath/../cover.jpg -> cover.jpg)\n        coverpath = os.path.normpath(os.path.join(base_dir, filepath))\n        content = zf.read(coverpath)\n        content = base64.b64encode(content)\n\n    return content, extension"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _discover_toc(zf, opf_xmldoc, opf_filepath):\n    '''\n    Returns a list of objects: {title: str, src: str, level: int, index: int}\n    '''\n    toc = None\n\n    # ePub 3.x\n    tag = find_tag(opf_xmldoc, 'item', 'properties', 'nav')\n    if tag and 'href' in tag.attributes.keys():\n        filepath = unquote(tag.attributes['href'].value)\n        # The xhtml file path is relative to the OPF file\n        base_dir = os.path.dirname(opf_filepath)\n        # print('- Reading Nav file: {}/{}'.format(base_dir, filepath))\n        npath = os.path.normpath(os.path.join(base_dir, filepath))\n        nav_content = zf.read(npath)\n        toc_xmldoc = minidom.parseString(nav_content)\n\n        _toc = []\n\n        for n in toc_xmldoc.getElementsByTagName('a'):\n            if n.firstChild and ('href' in n.attributes.keys()):\n                href = unquote(n.attributes['href'].value)\n                # Discarding CFI links\n                if '.html' in href or '.xhtml' in href:\n                    title = n.firstChild.nodeValue\n                    # try the second node too (maybe the first child is an empty span)\n                    if not title and n.firstChild.firstChild:\n                        title = n.firstChild.firstChild.nodeValue\n\n                    title = title.strip() if title else None\n\n                    if title:\n                        level = -1\n                        parentNode = n.parentNode\n                        avoid_infinite_loop = 0 # simple security issue to avoid infinite loop for bad epub files\n                        while parentNode and parentNode.nodeName != 'nav' and avoid_infinite_loop < 50:\n                            if parentNode.nodeName == 'ol': # count the depth of the a link related to ol items\n                                level += 1\n                            parentNode = parentNode.parentNode\n                            avoid_infinite_loop += 1\n                        level = max(level, 0) # root level is 0, not -1\n\n                        _toc.append({'title': title, 'src': href, 'level': level})\n        if _toc:\n            toc = _toc\n\n    if not toc:\n        # ePub 2.x\n        tag = find_tag(opf_xmldoc, 'item', 'id', 'ncx')\n        if not tag:\n            tag = find_tag(opf_xmldoc, 'item', 'id', 'ncxtoc')\n        if tag and 'href' in tag.attributes.keys():\n            filepath = unquote(tag.attributes['href'].value)\n            # The ncx file path is relative to the OPF file\n            base_dir = os.path.dirname(opf_filepath)\n            # print('- Reading NCX file: {}/{}'.format(base_dir, filepath))\n            npath = os.path.normpath(os.path.join(base_dir, filepath))\n            ncx_content = zf.read(npath)\n\n            toc_xmldoc = minidom.parseString(ncx_content)\n\n            def read_nav_point(nav_point_node, level = 0):\n                items = []\n                item = {'title': None, 'src': None, 'level': level}\n                children_points = []\n                for item_node in nav_point_node.childNodes:\n                    if item_node.nodeName in ('navLabel', 'ncx:navLabel'):\n                        try:\n                            text = item_node.getElementsByTagName('text')[0].firstChild\n                        except IndexError:\n                            try:\n                                text = item_node.getElementsByTagName('ncx:text')[0].firstChild\n                            except IndexError:\n                                text = None\n\n                        item['title'] = text.nodeValue.strip() if text and text.nodeValue else None\n                    elif item_node.nodeName in ('content', 'ncx:content'):\n                        if item_node.hasAttribute('src'):\n                            item['src'] = item_node.attributes['src'].value\n                    elif item_node.nodeName in ('navPoint', 'ncx:navPoint'):\n                        children_points.append(item_node)\n\n                if item['title']:\n                    items.append(item)\n                    for child_node in children_points:\n                        subitems = read_nav_point(child_node, level=level + 1)\n                        items.extend(subitems)\n                return items\n\n            def read_nav_map(toc_xmldoc, level=0):\n                items = []\n                try:\n                    nav_map_node = toc_xmldoc.getElementsByTagName('navMap')[0]\n                except IndexError:\n                    # Some ebooks use the ncx: namespace so try that too\n                    try:\n                        nav_map_node = toc_xmldoc.getElementsByTagName('ncx:navMap')[0]\n                    except IndexError:\n                        print('Failed reading TOC')\n                        return items\n\n                for nav_point in nav_map_node.childNodes:\n                    if nav_point.nodeName in ('navPoint', 'ncx:navPoint'):\n                        subitems = read_nav_point(nav_point, level=level)\n                        items.extend(subitems)\n                return items\n\n            toc = read_nav_map(toc_xmldoc)\n\n    # add indexes\n    if toc:\n        for i, t in enumerate(toc):\n            t['index'] = i\n\n    return toc", "response": "Discovers the contents of the OPF file and returns a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_epub_metadata(filepath, read_cover_image=True, read_toc=True):\n    '''\n    References: http://idpf.org/epub/201 and http://idpf.org/epub/301\n    1. Parse META-INF/container.xml file and find the .OPF file path.\n    2. In the .OPF file, find the metadata\n    '''\n    if not zipfile.is_zipfile(filepath):\n        raise EPubException('Unknown file')\n\n    # print('Reading ePub file: {}'.format(filepath))\n    zf = zipfile.ZipFile(filepath, 'r', compression=zipfile.ZIP_DEFLATED, allowZip64=True)\n    container = zf.read('META-INF/container.xml')\n    container_xmldoc = minidom.parseString(container)\n    # e.g.: <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n    opf_filepath = container_xmldoc.getElementsByTagName('rootfile')[0].attributes['full-path'].value\n\n    opf = zf.read(os.path.normpath(opf_filepath))\n    opf_xmldoc = minidom.parseString(opf)\n\n    # This file is specific to the authors if it exists.\n    authors_html = None\n    try:\n        authors_html = minidom.parseString(zf.read('OEBPS/pr02.html'))\n    except KeyError:\n        # Most books store authors using epub tags, so no worries.\n        pass\n\n    # This file is specific to the publish date if it exists.\n    publish_date_html = None\n    try:\n        publish_date_html = minidom.parseString(zf.read('OEBPS/pr01.html'))\n    except KeyError:\n        # Most books store authors using epub tags, so no worries.\n        pass\n\n\n    file_size_in_bytes = os.path.getsize(filepath)\n\n    data = odict({\n        'epub_version': _discover_epub_version(opf_xmldoc),\n        'title': _discover_title(opf_xmldoc),\n        'language': _discover_language(opf_xmldoc),\n        'description': _discover_description(opf_xmldoc),\n        'authors': _discover_authors(opf_xmldoc, authors_html=authors_html),\n        'publisher': _discover_publisher(opf_xmldoc),\n        'publication_date': _discover_publication_date(opf_xmldoc,\n                                                       date_html=publish_date_html),\n        'identifiers': _discover_identifiers(opf_xmldoc),\n        'subject': _discover_subject(opf_xmldoc),\n        'file_size_in_bytes': file_size_in_bytes,\n    })\n\n    if read_cover_image:\n        cover_image_content, cover_image_extension = _discover_cover_image(zf, opf_xmldoc, opf_filepath)\n        data.cover_image_content = cover_image_content\n        data.cover_image_extension = cover_image_extension\n\n    if read_toc:\n        data.toc = _discover_toc(zf, opf_xmldoc, opf_filepath)\n\n    return data", "response": "Read the metadata from an ePub file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the file. OPF contents of the ePub file", "response": "def get_epub_opf_xml(filepath):\n    '''\n    Returns the file.OPF contents of the ePub file\n    '''\n    if not zipfile.is_zipfile(filepath):\n        raise EPubException('Unknown file')\n\n    # print('Reading ePub file: {}'.format(filepath))\n    zf = zipfile.ZipFile(filepath, 'r', compression=zipfile.ZIP_DEFLATED, allowZip64=True)\n    container = zf.read('META-INF/container.xml')\n    container_xmldoc = minidom.parseString(container)\n    # e.g.: <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n    opf_filepath = container_xmldoc.getElementsByTagName('rootfile')[0].attributes['full-path'].value\n    return zf.read(opf_filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef firstname(self, value, case, gender=None):\n        if not value:\n            raise ValueError('Firstname cannot be empty.')\n\n        return self.__inflect(value, case, 'firstname', gender)", "response": "\u041f\u0430\u0434\u0435\u0436 \u0434\u043b\u044f \u0441\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u0438\u043c\u0435\u043d\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u0430 Case gender \u041f\u0430\u0434\u0435\u0436 \u0434\u043b\u044f \u0441\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u043a"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lastname(self, value, case, gender=None):\n        if not value:\n            raise ValueError('Lastname cannot be empty.')\n\n        return self.__inflect(value, case, 'lastname', gender)", "response": "\u041f\u0430\u0434\u0435\u0436 \u0434\u043b\u044f \u043a\u043b\u0430\u0441\u0441\u0430 Case Lastname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef middlename(self, value, case, gender=None):\n        if not value:\n            raise ValueError('Middlename cannot be empty.')\n\n        return self.__inflect(value, case, 'middlename', gender)", "response": "\u041f\u0430\u0434\u0435\u0436 \u0434\u043b\u044f \u043a\u043b\u0430\u0441\u0441\u0430 Case \u0434\u043b\u044f \u043a\u043b\u0430\u0441\u0441\u0430 Case"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexpanding a reference expression to individual spans.", "response": "def expand(expression):\n    \"\"\"\n    Expand a reference expression to individual spans.\n    Also works on space-separated ID lists, although a sequence of space\n    characters will be considered a delimiter.\n\n    >>> expand('a1')\n    'a1'\n    >>> expand('a1[3:5]')\n    'a1[3:5]'\n    >>> expand('a1[3:5+6:7]')\n    'a1[3:5]+a1[6:7]'\n    >>> expand('a1 a2  a3')\n    'a1 a2  a3'\n\n    \"\"\"\n    tokens = []\n    for (pre, _id, _range) in robust_ref_re.findall(expression):\n        if not _range:\n            tokens.append('{}{}'.format(pre, _id))\n        else:\n            tokens.append(pre)\n            tokens.extend(\n                '{}{}[{}:{}]'.format(delim, _id, start, end)\n                for delim, start, end in span_re.findall(_range)\n            )\n    return ''.join(tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompress a reference expression to group spans on the same id.", "response": "def compress(expression):\n    \"\"\"\n    Compress a reference expression to group spans on the same id.\n    Also works on space-separated ID lists, although a sequence of space\n    characters will be considered a delimiter.\n\n    >>> compress('a1')\n    'a1'\n    >>> compress('a1[3:5]')\n    'a1[3:5]'\n    >>> compress('a1[3:5+6:7]')\n    'a1[3:5+6:7]'\n    >>> compress('a1[3:5]+a1[6:7]')\n    'a1[3:5+6:7]'\n    >>> compress('a1 a2  a3')\n    'a1 a2  a3'\n\n    \"\"\"\n    tokens = []\n    selection = []\n    last_id = None\n    for (pre, _id, _range) in robust_ref_re.findall(expression):\n        if _range and _id == last_id:\n            selection.extend([pre, _range])\n            continue\n        if selection:\n            tokens.extend(selection + [']'])\n            selection = []\n        tokens.extend([pre, _id])\n        if _range:\n            selection = ['[', _range]\n            last_id = _id\n        else:\n            last_id = None\n    if selection:\n        tokens.extend(selection + [']'])\n    return ''.join(tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit the expression into individual selection expressions.", "response": "def selections(expression, keep_delimiters=True):\n    \"\"\"\n    Split the expression into individual selection expressions. The\n    delimiters will be kept as separate items if keep_delimters=True.\n    Also works on space-separated ID lists, although a sequence of space\n    characters will be considered a delimiter.\n\n    >>> selections('a1')\n    ['a1']\n    >>> selections('a1[3:5]')\n    ['a1[3:5]']\n    >>> selections('a1[3:5+6:7]')\n    ['a1[3:5+6:7]']\n    >>> selections('a1[3:5+6:7]+a2[1:4]')\n    ['a1[3:5+6:7]', '+', 'a2[1:4]']\n    >>> selections('a1[3:5+6:7]+a2[1:4]', keep_delimiters=False)\n    ['a1[3:5+6:7]', 'a2[1:4]']\n    >>> selections('a1 a2  a3')\n    ['a1', ' ', 'a2', '  ', 'a3']\n\n    \"\"\"\n    tokens = []\n    for (pre, _id, _range) in robust_ref_re.findall(expression):\n        if keep_delimiters and pre:\n            tokens.append(pre)\n        if _id:\n            if _range:\n                tokens.append('{}[{}]'.format(_id, _range))\n            else:\n                tokens.append(_id)\n    return tokens"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the string that is the resolution of the alignment expression expression which selects ids from container.", "response": "def resolve(container, expression):\n    \"\"\"\n    Return the string that is the resolution of the alignment expression\n    `expression`, which selects ids from `container`.\n    \"\"\"\n    itemgetter = getattr(container, 'get_item', container.get)\n    tokens = []\n    expression = expression.strip()\n    for sel_delim, _id, _range in selection_re.findall(expression):\n        tokens.append(delimiters.get(sel_delim, ''))\n        item = itemgetter(_id)\n        if item is None:\n            raise XigtStructureError(\n                'Referred Item (id: {}) from reference \"{}\" does not '\n                'exist in the given container.'\n                .format(_id, expression)\n            )\n        # treat None values as empty strings for resolution\n        value = item.value() or ''\n        if _range:\n            for spn_delim, start, end in span_re.findall(_range):\n                start = int(start) if start else None\n                end = int(end) if end else None\n                tokens.extend([\n                    delimiters.get(spn_delim, ''),\n                    value[start:end]\n                ])\n        else:\n            tokens.append(value)\n    return ''.join(tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of ids denoting objects in igt that are referred by id.", "response": "def referents(igt, id, refattrs=None):\n    \"\"\"\n    Return a list of ids denoting objects (tiers or items) in `igt` that\n    are referred by the object denoted by `id` using a reference\n    attribute in `refattrs`. If `refattrs` is None, then consider all\n    known reference attributes for the type of object denoted by _id_.\n    In other words, if 'b1' refers to 'a1' using 'alignment', then\n    `referents(igt, 'b1', ['alignment'])` returns `['a1']`.\n    \"\"\"\n    obj = igt.get_any(id)\n    if obj is None:\n        raise XigtLookupError(id)\n    if refattrs is None:\n        refattrs = obj.allowed_reference_attributes()\n    return {ra: ids(obj.attributes.get(ra, '')) for ra in refattrs}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef referrers(igt, id, refattrs=None):\n    if refattrs is None:\n        result = {}\n    else:\n        result = {ra: [] for ra in refattrs}\n\n    # if the id is a tier, only look at tiers; otherwise only look at items\n    try:\n        obj = igt[id]\n        others = igt.tiers\n    except KeyError:\n        obj = igt.get_item(id)\n        others = [i for t in igt.tiers for i in t.items]\n\n    if obj is None:\n        raise XigtLookupError(id)\n\n    for other in others:\n        if other.id is None:\n            continue  # raise a warning?\n\n        _refattrs = refattrs\n        if _refattrs is None:\n            _refattrs = other.allowed_reference_attributes()\n\n        attrget = other.attributes.get  # just loop optimization\n        for ra in _refattrs:\n            result.setdefault(ra, [])\n            if id in ids(attrget(ra, '')):\n                result[ra].append(other.id)\n    return result", "response": "Return a list of ids denoting objects in igt that refer to the given id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ancestors(obj, refattrs=(ALIGNMENT, SEGMENTATION)):\n    if hasattr(obj, 'tier'):\n        tier = obj.tier\n        items = [obj]\n    else:\n        tier = obj\n        items = tier.items\n    # a tier may be visited twice (e.g. A > B > A), but then it stops;\n    # this is to avoid cycles\n    visited = set([tier.id])\n    while True:\n        # get the first specified attribute\n        refattr = next((ra for ra in refattrs if ra in tier.attributes), None)\n        if not refattr:\n            break\n        reftier = ref.dereference(tier, refattr)\n        ids = set(chain.from_iterable(\n            ref.ids(item.attributes.get(refattr, '')) for item in items\n        ))\n        refitems = [item for item in reftier.items if item.id in ids]\n        yield (tier, refattr, reftier, refitems)\n        # cycle detection; break if we've now encountered something twice\n        if reftier.id in visited:\n            break\n        visited.update(reftier.id)\n        tier = reftier\n        items = refitems", "response": "get ancestors of an item"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of descendants of an item", "response": "def descendants(obj, refattrs=(SEGMENTATION, ALIGNMENT), follow='first'):\n    \"\"\"\n    >>> for des in query.descendants(igt.get_item('p1'), refattrs=(SEGMENTATION, ALIGNMENT)):\n    ...     print(des)\n    (<Tier object (id: p type: phrases) at ...>, 'segmentation', <Tier object (id: w type: words) at ...>, [<Item object (id: w1) at ...>])\n    (<Tier object (id: p type: phrases) at ...>, 'alignment', <Tier object (id: t type: translations) at ...>, [<Item object (id: t1) at ...>])\n    (<Tier object (id: w type: words) at ...>, 'segmentation', <Tier object (id: m type: morphemes) at ...>, [<Item object (id: m1) at ...>])\n    (<Tier object (id: m type: morphemes) at ...>, 'alignment', <Tier object (id: g type: glosses) at ...>, [<Item object (id: g1) at ...>])\n    \"\"\"\n\n    if hasattr(obj, 'tier'):\n        tier = obj.tier\n        items = [obj]\n    else:\n        tier = obj\n        items = tier.items\n    igt = tier.igt\n    visited = set()\n    agenda = deque([(tier, items)])\n    while agenda:\n        tier, items = agenda.popleft()\n        tier_refs = tier.referrers(refattrs)\n        item_ids = set(item.id for item in items)\n        # get followable refattrs with something on the referrers list\n        ras = [ra for ra in refattrs if tier_refs[ra]]\n        if follow == 'first' and ras:\n            ras = [ras[0]]\n        if not ras:\n            continue\n        # unlike ancestors, descendants for a refattr may have 1+ tiers\n        for refattr in ras:\n            # try to avoid cycles\n            if (tier.id, refattr) in visited:\n                continue\n            else:\n                visited.add((tier.id, refattr))\n            for reftier_id in tier_refs[refattr]:\n                reftier = igt[reftier_id]\n                refitems = [\n                    item for item in reftier.items\n                    if set(ref.ids(item.attributes.get(refattr,'')))\n                       .intersection(item_ids)\n                ]\n                yield (tier, refattr, reftier, refitems)\n                agenda.append((reftier, refitems))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode a XigtCorpus element.", "response": "def default_decode(events, mode='full'):\n    \"\"\"Decode a XigtCorpus element.\"\"\"\n    event, elem = next(events)\n    root = elem  # store root for later instantiation\n    while (event, elem.tag) not in [('start', 'igt'), ('end', 'xigt-corpus')]:\n        event, elem = next(events)\n    igts = None\n    if event == 'start' and elem.tag == 'igt':\n        igts = (\n            decode_igt(e)\n            for e in iter_elements(\n                'igt', events, root, break_on=[('end', 'xigt-corpus')]\n            )\n        )\n    xc = decode_xigtcorpus(root, igts=igts, mode=mode)\n    return xc"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_file_content(source):\n    filepath = os.path.join('siglists', source + '.txt')\n\n    lines = []\n    with resource_stream(__name__, filepath) as f:\n        for i, line in enumerate(f):\n            line = line.decode('utf-8', 'strict').strip()\n            if not line or line.startswith('#'):\n                continue\n\n            try:\n                re.compile(line)\n            except Exception as ex:\n                raise BadRegularExpressionLineError(\n                    'Regex error: {} in file {} at line {}'.format(\n                        str(ex),\n                        filepath,\n                        i\n                    )\n                )\n\n            lines.append(line)\n\n    if source in _SPECIAL_EXTENDED_VALUES:\n        lines = lines + _SPECIAL_EXTENDED_VALUES[source]\n\n    return tuple(lines)", "response": "Return a tuple each value being a line of the source file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks quickly whether file is rar archive.", "response": "def _get_rar_version(xfile):\n    \"\"\"Check quickly whether file is rar archive.\n    \"\"\"\n    buf = xfile.read(len(RAR5_ID))\n    if buf.startswith(RAR_ID):\n        return 3\n    elif buf.startswith(RAR5_ID):\n        xfile.read(1)\n        return 5\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nproceeds to next volume.", "response": "def _open_next(self):\n        \"\"\"Proceed to next volume.\"\"\"\n\n        # is the file split over archives?\n        if (self._cur.flags & rarfile.RAR_FILE_SPLIT_AFTER) == 0:\n            return False\n\n        if self._fd:\n            self._fd.close()\n            self._fd = None\n\n        # open next part\n        self._volfile = self._parser._next_volname(self._volfile)\n        fd = rarfile.XFile(self._volfile)\n        self._fd = fd\n        sig = fd.read(len(self._parser._expect_sig))\n        if sig != self._parser._expect_sig:\n            raise rarfile.BadRarFile(\"Invalid signature\")\n\n        # loop until first file header\n        while 1:\n            cur = self._parser._parse_header(fd)\n            if not cur:\n                raise rarfile.BadRarFile(\"Unexpected EOF\")\n            if cur.type in (rarfile.RAR_BLOCK_MARK, rarfile.RAR_BLOCK_MAIN):\n                if cur.add_size:\n                    fd.seek(cur.add_size, 1)\n                continue\n            if cur.orig_filename != self._inf.orig_filename:\n                raise rarfile.BadRarFile(\"Did not found file entry\")\n            self._cur = cur\n            self._cur_avail = cur.add_size\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check(self): # TODO: fix?\n        if self._returncode:\n            rarfile.check_returncode(self, '')\n        if self._remain != 0:\n            raise rarfile.BadRarFile(\"Failed the read enough data\")", "response": "Check CRC and return code."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a matrix that contains RGB channels and colors scaled by 0 to 255", "response": "def to_24bit_gray(mat: np.ndarray):\n    \"\"\"returns a matrix that contains RGB channels, and colors scaled\n    from 0 to 255\"\"\"\n    return np.repeat(np.expand_dims(_normalize(mat), axis=2), 3, axis=2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_color_map(name: str, mat: np.ndarray = None):\n    def apply_map(mat):\n        return (cm.get_cmap(name)(_normalize(mat))[:, :, :3] * 255).astype(np.uint8)\n        \n    return apply_map if mat is None else apply_map(mat)", "response": "returns an RGB matrix scaled by a matplotlib color map"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a 2d numpy array to a pygame. Surface", "response": "def mat_to_surface(mat: np.ndarray, transformer=to_24bit_gray):\n    \"\"\"Can be used to create a pygame.Surface from a 2d numpy array.\n\n    By default a grey image with scaled colors is returned, but using the\n    transformer argument any transformation can be used.\n\n    :param mat: the matrix to create the surface of.\n    :type mat: np.ndarray\n\n    :param transformer: function that transforms the matrix to a valid color\n        matrix, i.e. it must have 3dimension, were the 3rd dimension are the color\n        channels. For each channel a value between 0 and 255 is allowed\n    :type transformer: Callable[np.ndarray[np.ndarray]]\"\"\"\n\n    return pygame.pixelcopy.make_surface(transformer(mat.transpose()) \n        if transformer is not None else mat.transpose())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef random_id(length=16, charset=alphanum_chars, first_charset=alpha_chars, sep='', group=0):\r\n    t = []\r\n\r\n    first_chars = list(set(charset).intersection(first_charset))\r\n    if len(first_chars) == 0:\r\n        first_chars = charset\r\n\r\n    t.append(first_chars[random.randrange(len(first_chars))])\r\n\r\n    for i in range(len(t), length):\r\n        if (group > 0) and (i % group == 0) and (i < length):\r\n            t.append(sep)\r\n        t.append(charset[random.randrange(len(charset))])\r\n\r\n    return ''.join(t)", "response": "Creates a random id with the given length and charset."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges any number of dictionaries with the given ones.", "response": "def merge_dict(data, *args):\n    \"\"\"Merge any number of dictionaries\n    \"\"\"\n    results = {}\n    for current in (data,) + args:\n        results.update(current)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\njoin individual URL strings together and returns a single string.", "response": "def make_url(url, *paths):\n    \"\"\"Joins individual URL strings together, and returns a single string.\n    \"\"\"\n    for path in paths:\n        url = re.sub(r'/?$', re.sub(r'^/?', '/', path), url)\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naggregates result for all servers.", "response": "def aggregate_result(self, return_code, output, service_description='', specific_servers=None):\n        '''\n        aggregate result\n        '''\n        if specific_servers == None:\n            specific_servers = self.servers\n        else:\n            specific_servers = set(self.servers).intersection(specific_servers)\n\n        for server in specific_servers:\n            if not self.servers[server]['send_errors_only'] or return_code > 0:\n                self.servers[server]['results'].append({'return_code': return_code,\n                           'output': output,\n                           'service_description': service_description,\n                           'return_status': STATUSES[return_code][0],\n                           'custom_fqdn': self.servers[server]['custom_fqdn']})\n                LOG.info(\"[email][%s][%s]: Aggregate result: %r\", service_description, server, self.servers[server]['results'][-1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending results to all servers", "response": "def send_results(self):\n        '''\n        send results\n        '''\n\n        for server in self.servers:\n            if self.servers[server]['results']:\n                if len(self.servers[server]['results']) == 1:\n                    msg = MIMEText('')\n                    msg['Subject'] = '[%(custom_fqdn)s] [%(service_description)s] %(return_status)s: %(output)s' % self.servers[server]['results'][0]\n                else:\n                    txt = ''\n                    summary = [0, 0, 0, 0]\n                    for results in self.servers[server]['results']:\n                        txt += '[%(service_description)s] %(return_status)s: %(output)s\\n' % results\n                        summary[results['return_code']] += 1\n                    msg = MIMEText(txt)\n                    subject = '[%(custom_fqdn)s]' % self.servers[server]['results'][0]\n                    for i, status in enumerate(STATUSES):\n                        subject += ' %s:%s' % (status[0], summary[i])\n                    msg['Subject'] = subject\n\n                msg['From'] = self.servers[server]['from']\n                msg['To'] = ', '.join(self.servers[server]['to'])\n                if self.servers[server]['tls']:\n                    smtp_server = smtplib.SMTP_SSL(self.servers[server]['host'], self.servers[server]['port'])\n                else:\n                    smtp_server = smtplib.SMTP(self.servers[server]['host'], self.servers[server]['port'])\n\n                if self.servers[server]['login'] and len(self.servers[server]['login']) > 0:\n                    smtp_server.login(self.servers[server]['login'], self.servers[server]['password'])\n                smtp_server.sendmail(self.servers[server]['from'], self.servers[server]['to'], msg.as_string())\n                smtp_server.quit()\n                LOG.info(\"[email][%s]: e-mail sent from: %s to: %s\", server, self.servers[server]['from'], self.servers[server]['to'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n    config = {\n        \"api\": {\n            \"services\": [\n                {\n                    \"name\": \"my_api\",\n                    \"testkey\": \"testval\",\n                },\n            ],\n            \"calls\": {\n                \"hello_world\": {\n                    \"delay\": 5,\n                    \"priority\": 1,\n                    \"arguments\": None,\n                },\n                \"marco\": {\n                    \"delay\": 1,\n                    \"priority\": 1,\n                },\n                \"pollo\": {\n                    \"delay\": 1,\n                    \"priority\": 1,\n                },\n            }\n        }\n    }\n    app = AppBuilder([MyAPI], Strategy(Print()), AppConf(config))\n    app.run()", "response": "Main function for the main function of the main function."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a request from the incoming data", "response": "def make_request(self, data):\n        \"\"\"Parse the outgoing schema\"\"\"\n        sch = MockItemSchema()\n        return Request(**{\n            \"callname\": self.context.get(\"callname\"),\n            \"payload\": sch.dump(data),\n        })"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate the result with the data from the incoming data.", "response": "def populate_data(self, data):\n        \"\"\"Parse the outgoing schema\"\"\"\n        sch = MockItemSchema()\n        return Result(**{\n            \"callname\": self.context.get(\"callname\"),\n            \"result\": sch.dump(data),\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef key_press(keys):\n        return lambda e: e.key if e.type == pygame.KEYDOWN \\\n            and e.key in keys else EventConsumerInfo.DONT_CARE", "response": "returns a handler that can be used with EventListener. listen()\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unicode_char(ignored_chars=None):\n        return lambda e: e.unicode if e.type == pygame.KEYDOWN \\\n            and ((ignored_chars is None) \n                  or (e.unicode not in ignored_chars))\\\n            else EventConsumerInfo.DONT_CARE", "response": "returns a handler that listens for unicode characters"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mouse_area(self, handler, group=0, ident=None):\n        key = ident or id(handler)\n        if key not in self.mouse_proxies[group]:\n            self.mouse_proxies[group][key] = MouseProxy(handler, ident)\n        return self.mouse_proxies[group][key]", "response": "Adds a new MouseProxy for the given group to the \n        EventListener. mouse_proxies dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling listen repeatedly until listen returns something else than None. Then returns None.", "response": "def listen_until_return(self, *temporary_handlers, timeout=0):\n        \"\"\"Calls listen repeatedly until listen returns something else than None.\n        Then returns listen's result. If timeout is not zero listen_until_return\n        stops after timeout seconds and returns None.\"\"\"\n        start = time.time()\n        while timeout == 0 or time.time() - start < timeout:\n            res = self.listen(*temporary_handlers)\n            if res is not None:\n                return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwait till one key was pressed n times.", "response": "def wait_for_n_keypresses(self, key, n=1):\n        \"\"\"Waits till one key was pressed n times.\n\n        :param key: the key to be pressed as defined by pygame. E.g.\n            pygame.K_LEFT for the left arrow key\n        :type key: int\n        :param n: number of repetitions till the function returns\n        :type n: int\n        \"\"\"\n        my_const = \"key_consumed\"\n        counter = 0\n\n        def keypress_listener(e): return my_const \\\n            if e.type == pygame.KEYDOWN and e.key == key \\\n            else EventConsumerInfo.DONT_CARE\n\n        while counter < n:\n            if self.listen(keypress_listener) == my_const:\n                counter += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_for_keys(self, *keys, timeout=0):\n        if len(keys) == 1 and _is_iterable(keys[0]):\n            keys = keys[0]\n\n        return self.listen_until_return(Handler.key_press(keys), timeout=timeout)", "response": "Waits until one of the specified keys was pressed and returns \n        which key was pressed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits until a single character is pressed in the specified list of ignored_chars.", "response": "def wait_for_unicode_char(self, ignored_chars=None, timeout=0):\n        \"\"\"Returns a str that contains the single character that was pressed.\n        This already respects modifier keys and keyboard layouts. If timeout is\n        not none and no key is pressed within the specified timeout, None is\n        returned. If a key is ingnored_chars it will be ignored. As argument for\n        irgnored_chars any object that has a __contains__ method can be used,\n        e.g. a string, a set, a list, etc\"\"\"\n        return  self.listen_until_return(Handler.unicode_char(ignored_chars), \n                                        timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _find_all_first_files(self, item):\n        for listed_item in item.list():\n            new_style = re.findall(r'(?i)\\.part(\\d+)\\.rar^', listed_item.id)\n            if new_style:\n                if int(new_style[0]) == 1:\n                    yield 'new', listed_item\n            elif listed_item.id.lower().endswith('.rar'):\n                yield 'old', listed_item", "response": "Yields all the first files in the item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind all matching data files in search_path", "response": "def find_datafile(name, search_path, codecs=get_codecs()):\n    \"\"\"\n    find all matching data files in search_path\n    search_path: path of directories to load from\n    codecs: allow to override from list of installed\n    returns array of tuples (codec_object, filename)\n    \"\"\"\n    return munge.find_datafile(name, search_path, codecs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_datafile(name, search_path, codecs=get_codecs(), **kwargs):\n    return munge.load_datafile(name, search_path, codecs, **kwargs)", "response": "load datafile from codec\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cred_init(\n            self,\n            *,\n            secrets_dir: str,\n            log: Logger,\n            bot_name: str,\n    ) -> None:\n        \"\"\"\n        Initialize what requires credentials/secret files.\n\n        :param secrets_dir: dir to expect credentials in and store logs/history in.\n        :param log: logger to use for log output.\n        :param bot_name: name of this bot,\n            used for various kinds of labelling.\n        :returns: none.\n        \"\"\"\n        super().__init__(secrets_dir=secrets_dir, log=log, bot_name=bot_name)\n\n        self.ldebug(\"Retrieving CONSUMER_KEY...\")\n        with open(path.join(self.secrets_dir, \"CONSUMER_KEY\")) as f:\n            CONSUMER_KEY = f.read().strip()\n\n        self.ldebug(\"Retrieving CONSUMER_SECRET...\")\n        with open(path.join(self.secrets_dir, \"CONSUMER_SECRET\")) as f:\n            CONSUMER_SECRET = f.read().strip()\n\n        self.ldebug(\"Retrieving ACCESS_TOKEN...\")\n        with open(path.join(self.secrets_dir, \"ACCESS_TOKEN\")) as f:\n            ACCESS_TOKEN = f.read().strip()\n\n        self.ldebug(\"Retrieving ACCESS_SECRET...\")\n        with open(path.join(self.secrets_dir, \"ACCESS_SECRET\")) as f:\n            ACCESS_SECRET = f.read().strip()\n\n        self.ldebug(\"Looking for OWNER_HANDLE...\")\n        owner_handle_path = path.join(self.secrets_dir, \"OWNER_HANDLE\")\n        if path.isfile(owner_handle_path):\n            with open(owner_handle_path) as f:\n                self.owner_handle = f.read().strip()\n        else:\n            self.ldebug(\"Couldn't find OWNER_HANDLE, unable to DM...\")\n            self.owner_handle = \"\"\n\n        self.auth = tweepy.OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)\n        self.auth.set_access_token(ACCESS_TOKEN, ACCESS_SECRET)\n\n        self.api = tweepy.API(self.auth)", "response": "Initialize what requires credentials and secret files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(\n            self,\n            *,\n            text: str,\n    ) -> List[OutputRecord]:\n        \"\"\"\n        Send birdsite message.\n\n        :param text: text to send in post.\n        :returns: list of output records,\n            each corresponding to either a single post,\n            or an error.\n        \"\"\"\n        try:\n            status = self.api.update_status(text)\n            self.ldebug(f\"Status object from tweet: {status}.\")\n            return [TweetRecord(record_data={\"tweet_id\": status._json[\"id\"], \"text\": text})]\n\n        except tweepy.TweepError as e:\n            return [self.handle_error(\n                message=(f\"Bot {self.bot_name} encountered an error when \"\n                 f\"sending post {text} without media:\\n{e}\\n\"),\n                error=e)]", "response": "Send a message to a specific birdsite."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_with_media(\n            self,\n            *,\n            text: str,\n            files: List[str],\n            captions: List[str]=[]\n    ) -> List[OutputRecord]:\n        \"\"\"\n        Upload media to birdsite,\n        and send status and media,\n        and captions if present.\n\n        :param text: tweet text.\n        :param files: list of files to upload with post.\n        :param captions: list of captions to include as alt-text with files.\n        :returns: list of output records,\n            each corresponding to either a single post,\n            or an error.\n        \"\"\"\n\n        # upload media\n        media_ids = None\n        try:\n            self.ldebug(f\"Uploading files {files}.\")\n            media_ids = [self.api.media_upload(file).media_id_string for file in files]\n        except tweepy.TweepError as e:\n            return [self.handle_error(\n                message=f\"Bot {self.bot_name} encountered an error when uploading {files}:\\n{e}\\n\",\n                error=e)]\n\n        # apply captions, if present\n        self._handle_caption_upload(media_ids=media_ids, captions=captions)\n\n        # send status\n        try:\n            status = self.api.update_status(status=text, media_ids=media_ids)\n            self.ldebug(f\"Status object from tweet: {status}.\")\n            return [TweetRecord(record_data={\n                \"tweet_id\": status._json[\"id\"],\n                \"text\": text,\n                \"media_ids\": media_ids,\n                \"captions\": captions,\n                \"files\": files\n            })]\n\n        except tweepy.TweepError as e:\n            return [self.handle_error(\n                message=(f\"Bot {self.bot_name} encountered an error when \"\n                 f\"sending post {text} with media ids {media_ids}:\\n{e}\\n\"),\n                error=e)]", "response": "Uploads media to birdsite and sends status and media and captions to post."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a batch reply on the target account.", "response": "def perform_batch_reply(\n            self,\n            *,\n            callback: Callable[..., str],\n            lookback_limit: int,\n            target_handle: str,\n    ) -> List[OutputRecord]:\n        \"\"\"\n        Performs batch reply on target account.\n        Looks up the recent messages of the target user,\n        applies the callback,\n        and replies with\n        what the callback generates.\n\n        :param callback: a callback taking a message id,\n            message contents,\n            and optional extra keys,\n            and returning a message string.\n        :param target: the id of the target account.\n        :param lookback_limit: a lookback limit of how many messages to consider.\n        :returns: list of output records,\n            each corresponding to either a single post,\n            or an error.\n        \"\"\"\n        self.log.info(f\"Attempting to batch reply to birdsite user {target_handle}\")\n\n        if \"@\" in target_handle:\n            base_target_handle = target_handle[1:]\n        else:\n            base_target_handle = target_handle\n\n        records: List[OutputRecord] = []\n        statuses = self.api.user_timeline(screen_name=base_target_handle, count=lookback_limit)\n        self.log.debug(f\"Retrieved {len(statuses)} statuses.\")\n        for i, status in enumerate(statuses):\n            self.log.debug(f\"Processing status {i} of {len(statuses)}\")\n            status_id = status.id\n\n            # find possible replies we've made.\n            # the 10 * lookback_limit is a guess,\n            # might not be enough and I'm not sure we can guarantee it is.\n            our_statuses = self.api.user_timeline(since_id=status_id,\n                                                  count=lookback_limit * 10)\n            in_reply_to_ids = list(map(lambda x: x.in_reply_to_status_id, our_statuses))\n\n            if status_id not in in_reply_to_ids:\n                # the twitter API and tweepy will attempt to give us the truncated text of the\n                # message if we don't do this roundabout thing.\n                encoded_status_text = self.api.get_status(status_id,\n                                                  tweet_mode=\"extended\")._json[\"full_text\"]\n\n                status_text = html.unescape(encoded_status_text)\n                message = callback(message_id=status_id, message=status_text, extra_keys={})\n\n                full_message = f\"@{base_target_handle} {message}\"\n                self.log.info(f\"Trying to reply with {message} to status {status_id} \"\n                              f\"from {target_handle}.\")\n                try:\n                    new_status = self.api.update_status(status=full_message,\n                                                        in_reply_to_status_id=status_id)\n\n                    records.append(TweetRecord(record_data={\n                        \"tweet_id\": new_status.id,\n                        \"in_reply_to\": f\"@{base_target_handle}\",\n                        \"in_reply_to_id\": status_id,\n                        \"text\": full_message,\n                    }))\n\n                except tweepy.TweepError as e:\n                    records.append(self.handle_error(\n                        message=(f\"Bot {self.bot_name} encountered an error when \"\n                         f\"trying to reply to {status_id} with {message}:\\n{e}\\n\"),\n                        error=e))\n            else:\n                self.log.info(f\"Not replying to status {status_id} from {target_handle} \"\n                              f\"- we already replied.\")\n\n        return records"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend DM to owner if something happens.", "response": "def send_dm_sos(self, message: str) -> None:\n        \"\"\"\n        Send DM to owner if something happens.\n\n        :param message: message to send to owner.\n        :returns: None.\n        \"\"\"\n        if self.owner_handle:\n            try:\n                # twitter changed the DM API and tweepy (as of 2019-03-08)\n                # has not adapted.\n                # fixing with\n                # https://github.com/tweepy/tweepy/issues/1081#issuecomment-423486837\n                owner_id = self.api.get_user(screen_name=self.owner_handle).id\n                event = {\n                    \"event\": {\n                        \"type\": \"message_create\",\n                        \"message_create\": {\n                            \"target\": {\n                                \"recipient_id\": f\"{owner_id}\",\n                            },\n                            \"message_data\": {\n                                \"text\": message\n                            }\n                        }\n                    }\n                }\n\n                self._send_direct_message_new(event)\n\n            except tweepy.TweepError as de:\n                self.lerror(f\"Error trying to send DM about error!: {de}\")\n\n        else:\n            self.lerror(\"Can't send DM SOS, no owner handle.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_error(\n            self,\n            *,\n            message: str,\n            error: tweepy.TweepError,\n    ) -> OutputRecord:\n        \"\"\"\n        Handle error while trying to do something.\n\n        :param message: message to send in DM regarding error.\n        :param e: tweepy error object.\n        :returns: OutputRecord containing an error.\n        \"\"\"\n        self.lerror(f\"Got an error! {error}\")\n\n        # Handle errors if we know how.\n        try:\n            code = error[0][\"code\"]\n            if code in self.handled_errors:\n                self.handled_errors[code]\n            else:\n                self.send_dm_sos(message)\n\n        except Exception:\n            self.send_dm_sos(message)\n\n        return TweetRecord(error=error)", "response": "Handle an error while trying to do something."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _handle_caption_upload(\n            self,\n            *,\n            media_ids: List[str],\n            captions: Optional[List[str]],\n    ) -> None:\n        \"\"\"\n        Handle uploading all captions.\n\n        :param media_ids: media ids of uploads to attach captions to.\n        :param captions: captions to be attached to those media ids.\n        :returns: None.\n        \"\"\"\n        if captions is None:\n            captions = []\n\n        if len(media_ids) > len(captions):\n            captions.extend([self.default_caption_message] * (len(media_ids) - len(captions)))\n\n        for i, media_id in enumerate(media_ids):\n            caption = captions[i]\n            self._upload_caption(media_id=media_id, caption=caption)", "response": "Handle uploading all captions.\n\n        :param media_ids: media ids of uploads to attach captions to.\n        :param captions: captions to be attached to those media ids.\n        :returns: None."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a new message to the direct message queue.", "response": "def _send_direct_message_new(self, messageobject: Dict[str, Dict]) -> Any:\n        \"\"\"\n        :reference: https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event.html\n        \"\"\"\n        headers, post_data = _buildmessageobject(messageobject)\n        newdm_path = \"/direct_messages/events/new.json\"\n\n        return tweepy.binder.bind_api(\n            api=self.api,\n            path=newdm_path,\n            method=\"POST\",\n            require_auth=True,\n        )(post_data=post_data, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n    parser = argparse.ArgumentParser(description=DESCRIPTION)\n    parser.add_argument(\n        '-v', '--verbose', help='increase output verbosity', action='store_true'\n    )\n    args = parser.parse_args()\n\n    generator = SignatureGenerator(debug=args.verbose)\n\n    crash_data = json.loads(sys.stdin.read())\n\n    ret = generator.generate(crash_data)\n\n    print(json.dumps(ret, indent=2))", "response": "Takes crash data via stdin and generates a Socorro signature"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_config(self, config):\n        for attr in self.__fixed_attrs:\n            if attr in config:\n                raise Exception(\"cannot set '%s' outside of init\", attr)\n\n        # pre checkout\n\n        stages = config.get('stages', None)\n        if stages:\n            self.stages = stages\n\n        # maybe pre checkout\n\n        # validate options\n        self.__dry_run = config.get('dry_run', False)\n\n        self.system = str.lower(platform.system())\n\n        self.__start = config.get('start', None)\n        self.__end = config.get('end', None)\n        self.__only = config.get('only', None)\n\n        self.__build_docs = config.get('build_docs', False)\n        self.__chatty = config.get('chatty', False)\n        self.__clean = config.get('clean', False)\n        self.__devel = config.get('devel', False)\n        self.__debug = config.get('debug', False)\n        self.__skip_libcheck = config.get('skip_libcheck', False)\n        self.__debuginfo = config.get('debuginfo', False)\n        self.__release = config.get('release', False)\n        self.__skip_unit = config.get('skip_unit', False)\n        self.__static = config.get('static', False)\n        self.__make_dash_j = int(config.get('j', 0))\n        self.__target_only = config.get('target_only', None)\n\n        bits = config.get('bits', None)\n        if bits:\n            self.bits = int(bits)\n        else:\n            self.bits = self.sys_bits\n\n        self.compiler = config.get('compiler', None)\n        self.test_config = config.get('test_config', '-')\n        if not self.test_config:\n            self.test_config = '-'\n        self.use_ccache = config.get('use_ccache', False)\n        self.tmpl_engine = config.get('tmpl_engine', 'jinja2')\n        self.__write_codec = config.get('write_codec', None)\n        self.__codec = None\n\n        # TODO move out of init\n        if not config.get('skip_env_check', False):\n            if \"LD_LIBRARY_PATH\" in os.environ:\n                raise Exception(\"environment variable LD_LIBRARY_PATH is set\")\n\n        self.check_config()", "response": "Add a configuration dict to the internal configuration dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_config(self):\n\n        # sanity checks - no config access past here\n        if not getattr(self, 'stages', None):\n            raise NotImplementedError(\"member variable 'stages' must be defined\")\n        # start at stage\n        if self.__start:\n            self.__stage_start = self.find_stage(self.__start)\n        else:\n            self.__stage_start = 0\n        # end at stage\n        if self.__end:\n            self.__stage_end = self.find_stage(self.__end) + 1\n            self.opt_end = self.__end\n        else:\n            self.__stage_end = len(self.stages)\n        # only stage\n        if self.__only:\n            if self.__start or self.__end:\n                raise Exception(\n                    \"stage option 'only' cannot be used with start or end\")\n            self.__stage_start = self.find_stage(self.__only)\n            self.__stage_end = self.__stage_start + 1\n\n        if self.__devel:\n            self.__devel = True\n            # force deploy skip\n            if self.__stage_end >= len(self.stages):\n                self.status_msg(\"removing deploy stage for development build\")\n# XXX                self.__stage_end = self.__stage_end - 1\n\n\n        if self.stage_start >= self.stage_end:\n            raise Exception(\"start and end produce no stages\")\n\n        if self.bits not in [32, 64]:\n            raise Exception(\n                \"can't do a %d bit build: unknown build process\" % self.bits)\n\n        if self.bits == 64 and not self.is_64b:\n            raise Exception(\n                \"this machine is not 64 bit, cannot perform 64 bit build\")\n\n        if self.system == 'windows':\n            self.compilertag = 'vc10'\n        elif self.system == 'linux':\n            self.compilertag = 'gcc44'\n        else:\n            raise RuntimeError(\"can't decide compilertag on \" + self.system)\n\n        self.build_suffix = ''\n        if not self.is_unixy:\n            if self.__static:\n                runtime = 'MT'\n            else:\n                runtime = 'MD'\n            if self.__release:\n                self.configuration_name = 'Release'\n            else:\n                runtime += 'd'\n                self.configuration_name = 'Debug'\n\n            self.build_suffix = '-' + runtime\n            self.runtime = runtime\n        else:\n            self.configuration_name = 'CFNAME_INVALID_ON_LINUX'\n            self.runtime = 'RUNTIME_INVALID_ON_LINUX'\n\n        if self.test_config != '-':\n            self.test_config = os.path.abspath(self.test_config)\n\n        # split version\n        if self.version:\n            ver = self.version.split('.')\n            self.version_major = int(ver[0])\n            self.version_minor = int(ver[1])\n            self.version_patch = int(ver[2])\n            if(len(ver) == 4):\n                self.version_build = int(ver[3])", "response": "check the config for sanity checks"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the definition of a class is valid", "response": "def check_definition(self):\n        \"\"\"\n        called after Defintion was loaded to sanity check\n        raises on error\n        \"\"\"\n        if not self.write_codec:\n            self.__write_codec = self.defined.data_ext\n\n        # TODO need to add back a class scope target limited for subprojects with sub target sets\n        targets = self.get_defined_targets()\n        if self.__target_only:\n            if self.__target_only not in targets:\n                raise RuntimeError(\"invalid target '%s'\" % self.__target_only)\n\n            self.targets = [self.__target_only]\n        else:\n            self.targets = targets"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds all matching data files in search_path returns array of tuples", "response": "def find_datafile(self, name, search_path=None):\n        \"\"\"\n        find all matching data files in search_path\n        returns array of tuples (codec_object, filename)\n        \"\"\"\n        if not search_path:\n            search_path = self.define_dir\n\n        return codec.find_datafile(name, search_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a datafile from the codec", "response": "def load_datafile(self, name, search_path=None, **kwargs):\n        \"\"\"\n        find datafile and load them from codec\n        \"\"\"\n        if not search_path:\n            search_path = self.define_dir\n\n        self.debug_msg('loading datafile %s from %s' % (name, str(search_path)))\n        return codec.load_datafile(name, search_path, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns all configured stages", "response": "def run(self):\n        \"\"\" run all configured stages \"\"\"\n\n        self.sanity_check()\n\n# TODO - check for devel\n#        if not self.version:\n#            raise Exception(\"no version\")\n# XXX check attr exist\n        if not self.release_environment:\n            raise Exception(\"no instance name\")\n\n        time_start = time.time()\n\n        cwd = os.getcwd()\n\n        who = getpass.getuser()\n        self._make_outdirs()\n\n        append_notices = \"\"\n        if hasattr(self, 'opt_end'):\n            append_notices = \". shortened push, only to %s stage\" % self.opt_end\n        if self.is_devel:\n            append_notices += \". devel build\"\n        if hasattr(self, 'append_notices'):\n            append_notices += self.append_notices\n\n        line = \"%s %s %s by %s%s\" % (\n            sys.argv[0], self.version, self.release_environment, who, append_notices)\n        b = 'deploy begin %s' % line\n        e = 'deploy done %s' % line\n\n        if self.chatty:\n            self.alact(b)\n\n        ok = False\n        stage_passed = None\n        try:\n            for stage in self.stages[self.stage_start:self.stage_end]:\n                self.debug_msg(\"stage %s starting\" % (stage,))\n                getattr(self, stage)()\n                self.chdir(cwd)\n                stage_passed = stage\n                self.debug_msg(\"stage %s complete\" % (stage,))\n            ok = True\n        finally:\n            if not ok:\n                if self.chatty:\n                    if not stage_passed:\n                        self.alact(\n                            'deploy failed %s. completed no stages' % line)\n                    else:\n                        self.alact('deploy failed %s. completed %s' %\n                                   (line, stage_passed))\n        self.status_msg('[OK]')\n        if self.chatty:\n            self.alact('%s in %0.3f sec' % (e, time.time() - time_start))\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timestamp(dt):\n\tif dt.tzinfo is None:\n\t\treturn time.mktime((\n\t\t\tdt.year, dt.month, dt.day,\n\t\t\tdt.hour, dt.minute, dt.second,\n\t\t\t-1, -1, -1)) + dt.microsecond / 1e6\n\telse:\n\t\treturn (dt - _EPOCH).total_seconds()", "response": "Return POSIX timestamp as float."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrates limit a function.", "response": "def rate_limited(max_per_hour: int, *args: Any) -> Callable[..., Any]:\n    \"\"\"Rate limit a function.\"\"\"\n    return util.rate_limited(max_per_hour, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrepair a corrupted IterationRecord with a specific known issue.", "response": "def _repair(record: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Repair a corrupted IterationRecord with a specific known issue.\"\"\"\n    output_records = record.get(\"output_records\")\n    if record.get(\"_type\", None) == \"IterationRecord\" and output_records is not None:\n        birdsite_record = output_records.get(\"birdsite\")\n\n        # check for the bug\n        if isinstance(birdsite_record, dict) and birdsite_record.get(\"_type\") == \"IterationRecord\":\n\n            # get to the bottom of the corrupted record\n            failed = False\n            while birdsite_record.get(\"_type\") == \"IterationRecord\":\n                sub_record = birdsite_record.get(\"output_records\")\n                if sub_record is None:\n                    failed = True\n                    break\n\n                birdsite_record = sub_record.get(\"birdsite\")\n                if birdsite_record is None:\n                    failed = True\n                    break\n\n            if failed:\n                return record\n\n            # add type\n            birdsite_record[\"_type\"] = TweetRecord.__name__\n\n            # lift extra keys, just in case\n            if \"extra_keys\" in birdsite_record:\n                record_extra_values = record.get(\"extra_keys\", {})\n                for key, value in birdsite_record[\"extra_keys\"].items():\n                    if key not in record_extra_values:\n                        record_extra_values[key] = value\n\n                record[\"extra_keys\"] = record_extra_values\n\n                del birdsite_record[\"extra_keys\"]\n\n            output_records[\"birdsite\"] = birdsite_record\n\n        # pull that correct record up to the top level, fixing corruption\n        record[\"output_records\"] = output_records\n\n    return record"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, obj_dict: Dict[str, Any]) -> \"IterationRecord\":\n        obj = cls()\n        for key, item in obj_dict.items():\n            obj.__dict__[key] = item\n\n        return obj", "response": "Get object back from dict."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(\n            self,\n            *args: str,\n            text: str=None,\n    ) -> IterationRecord:\n        \"\"\"\n        Post text-only to all outputs.\n\n        :param args: positional arguments.\n            expected: text to send as message in post.\n            keyword text argument is preferred over this.\n        :param text: text to send as message in post.\n        :returns: new record of iteration\n        \"\"\"\n        if text is not None:\n            final_text = text\n        else:\n            if len(args) == 0:\n                raise BotSkeletonException((\"Please provide text either as a positional arg or \"\n                                            \"as a keyword arg (text=TEXT)\"))\n            else:\n                final_text = args[0]\n\n        # TODO there could be some annotation stuff here.\n        record = IterationRecord(extra_keys=self.extra_keys)\n        for key, output in self.outputs.items():\n            if output[\"active\"]:\n                self.log.info(f\"Output {key} is active, calling send on it.\")\n                entry: Any = output[\"obj\"]\n                output_result = entry.send(text=final_text)\n                record.output_records[key] = output_result\n\n            else:\n                self.log.info(f\"Output {key} is inactive. Not sending.\")\n\n        self.history.append(record)\n        self.update_history()\n\n        return record", "response": "Send a message to all outputs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_with_one_media(\n            self,\n            *args: str,\n            text: str=None,\n            file: str=None,\n            caption: str=None,\n    ) -> IterationRecord:\n        \"\"\"\n        Post with one media item to all outputs.\n        Provide filename so outputs can handle their own uploads.\n\n        :param args: positional arguments.\n            expected:\n                text to send as message in post.\n                file to be uploaded.\n                caption to be paired with file.\n            keyword arguments preferred over positional ones.\n        :param text: text to send as message in post.\n        :param file: file to be uploaded in post.\n        :param caption: caption to be uploaded alongside file.\n        :returns: new record of iteration\n        \"\"\"\n        final_text = text\n        if final_text is None:\n            if len(args) < 1:\n                raise TypeError((\"Please provide either positional argument \"\n                                 \"TEXT, or keyword argument text=TEXT\"))\n            else:\n                final_text = args[0]\n\n        final_file = file\n        if final_file is None:\n            if len(args) < 2:\n                raise TypeError((\"Please provide either positional argument \"\n                                            \"FILE, or keyword argument file=FILE\"))\n            else:\n                final_file = args[1]\n\n        # this arg is ACTUALLY optional,\n        # so the pattern is changed.\n        final_caption = caption\n        if final_caption is None:\n            if len(args) >= 3:\n                final_caption = args[2]\n\n        # TODO more error checking like this.\n        if final_caption is None or final_caption == \"\":\n            captions:List[str] = []\n        else:\n            captions = [final_caption]\n\n        record = IterationRecord(extra_keys=self.extra_keys)\n        for key, output in self.outputs.items():\n            if output[\"active\"]:\n                self.log.info(f\"Output {key} is active, calling media send on it.\")\n                entry: Any = output[\"obj\"]\n                output_result = entry.send_with_media(text=final_text,\n                                                      files=[final_file],\n                                                      captions=captions)\n                record.output_records[key] = output_result\n            else:\n                self.log.info(f\"Output {key} is inactive. Not sending with media.\")\n\n        self.history.append(record)\n        self.update_history()\n\n        return record", "response": "Post with one media item to all outputs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_with_many_media(\n            self,\n            *args: str,\n            text: str=None,\n            files: List[str]=None,\n            captions: List[str]=[],\n    ) -> IterationRecord:\n        \"\"\"\n        Post with several media.\n        Provide filenames so outputs can handle their own uploads.\n\n        :param args: positional arguments.\n            expected:\n                text to send as message in post.\n                files to be uploaded.\n                captions to be paired with files.\n            keyword arguments preferred over positional ones.\n        :param text: text to send as message in post.\n        :param files: files to be uploaded in post.\n        :param captions: captions to be uploaded alongside files.\n        :returns: new record of iteration\n        \"\"\"\n        if text is None:\n            if len(args) < 1:\n                raise TypeError((\"Please provide either required positional argument \"\n                                 \"TEXT, or keyword argument text=TEXT\"))\n            else:\n                final_text = args[0]\n        else:\n            final_text = text\n\n        if files is None:\n            if len(args) < 2:\n                raise TypeError((\"Please provide either positional argument \"\n                                 \"FILES, or keyword argument files=FILES\"))\n            else:\n                final_files = list(args[1:])\n        else:\n            final_files = files\n\n        # captions have never been permitted to be provided as positional args\n        # (kind of backed myself into that)\n        # so they just get defaulted and it's fine.\n\n        record = IterationRecord(extra_keys=self.extra_keys)\n        for key, output in self.outputs.items():\n            if output[\"active\"]:\n                self.log.info(f\"Output {key} is active, calling media send on it.\")\n                entry: Any = output[\"obj\"]\n                output_result = entry.send_with_media(text=final_text,\n                                                      files=final_files,\n                                                      captions=captions)\n                record.output_records[key] = output_result\n            else:\n                self.log.info(f\"Output {key} is inactive. Not sending with media.\")\n\n        self.history.append(record)\n        self.update_history()\n\n        return record", "response": "Post with several media."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef perform_batch_reply(\n            self,\n            *,\n            callback: Callable[..., str]=None,\n            target_handles: Dict[str, str]=None,\n            lookback_limit: int=20,\n            per_service_lookback_limit: Dict[str, int]=None,\n    ) -> IterationRecord:\n        \"\"\"\n        Performs batch reply on target accounts.\n        Looks up the recent messages of the target user,\n        applies the callback,\n        and replies with\n        what the callback generates.\n\n        :param callback: a callback taking a message id,\n            message contents,\n            and optional extra keys,\n            and returning a message string.\n        :param targets: a dictionary of service names to target handles\n            (currently only one per service).\n        :param lookback_limit: a lookback limit of how many messages to consider (optional).\n        :param per_service_lookback: and a dictionary of service names to per-service\n            lookback limits.\n            takes preference over lookback_limit (optional).\n        :returns: new record of iteration\n        :raises BotSkeletonException: raises BotSkeletonException if batch reply fails or cannot be\n            performed\n        \"\"\"\n        if callback is None:\n            raise BotSkeletonException(\"Callback must be provided.\"\"\")\n\n        if target_handles is None:\n            raise BotSkeletonException(\"Targets must be provided.\"\"\")\n\n        if lookback_limit > self.lookback_limit:\n            raise BotSkeletonException(\n                f\"Lookback_limit cannot exceed {self.lookback_limit}, \" +\n                f\"but it was {lookback_limit}\"\n            )\n\n        # use per-service lookback dict for convenience in a moment.\n        # if necessary, use lookback_limit to fill it out.\n        lookback_dict = per_service_lookback_limit\n        if (lookback_dict is None):\n            lookback_dict = {}\n\n        record = IterationRecord(extra_keys=self.extra_keys)\n        for key, output in self.outputs.items():\n            if key not in lookback_dict:\n                lookback_dict[key] = lookback_limit\n\n            if target_handles.get(key, None) is None:\n                self.log.info(f\"No target for output {key}, skipping this output.\")\n\n            elif not output.get(\"active\", False):\n                self.log.info(f\"Output {key} is inactive. Not calling batch reply.\")\n\n            elif output[\"active\"]:\n                self.log.info(f\"Output {key} is active, calling batch reply on it.\")\n                entry: Any = output[\"obj\"]\n                output_result = entry.perform_batch_reply(callback=callback,\n                                                          target_handle=target_handles[key],\n                                                          lookback_limit=lookback_dict[key],\n                                                          )\n                record.output_records[key] = output_result\n\n        self.history.append(record)\n        self.update_history()\n\n        return record", "response": "Performs a batch reply on the target accounts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngoing to sleep for the duration of self. delay seconds.", "response": "def nap(self) -> None:\n        \"\"\"\n        Go to sleep for the duration of self.delay.\n\n        :returns: None\n        \"\"\"\n        self.log.info(f\"Sleeping for {self.delay} seconds.\")\n        for _ in progress.bar(range(self.delay)):\n            time.sleep(1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef store_extra_info(self, key: str, value: Any) -> None:\n        self.extra_keys[key] = value", "response": "Store some extra info in the messaging storage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstore several extra keys in the messaging storage.", "response": "def store_extra_keys(self, d: Dict[str, Any]) -> None:\n        \"\"\"\n        Store several extra values in the messaging storage.\n\n        :param d: dictionary entry to merge with current self.extra_keys.\n        :returns: None\n        \"\"\"\n        new_dict = dict(self.extra_keys, **d)\n        self.extra_keys = new_dict.copy()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the history of the current message.", "response": "def update_history(self) -> None:\n        \"\"\"\n        Update messaging history on disk.\n\n        :returns: None\n        \"\"\"\n        self.log.debug(f\"Saving history. History is: \\n{self.history}\")\n\n        jsons = []\n        for item in self.history:\n            json_item = item.__dict__\n\n            # Convert sub-entries into JSON as well.\n            json_item[\"output_records\"] = self._parse_output_records(item)\n\n            jsons.append(json_item)\n\n        if not path.isfile(self.history_filename):\n            open(self.history_filename, \"a+\").close()\n\n        with open(self.history_filename, \"w\") as f:\n            json.dump(jsons, f, default=lambda x: x.__dict__.copy(), sort_keys=True, indent=4)\n            f.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_history(self) -> List[\"IterationRecord\"]:\n        if path.isfile(self.history_filename):\n            with open(self.history_filename, \"r\") as f:\n                try:\n                    dicts = json.load(f)\n\n                except json.decoder.JSONDecodeError as e:\n                    self.log.error(f\"Got error \\n{e}\\n decoding JSON history, overwriting it.\\n\"\n                                   f\"Former history available in {self.history_filename}.bak\")\n                    copyfile(self.history_filename, f\"{self.history_filename}.bak\")\n                    return []\n\n                history: List[IterationRecord] = []\n                for hdict_pre in dicts:\n\n                    if \"_type\" in hdict_pre and hdict_pre[\"_type\"] == IterationRecord.__name__:\n                        # repair any corrupted entries\n                        hdict = _repair(hdict_pre)\n                        record = IterationRecord.from_dict(hdict)\n                        history.append(record)\n\n                    # Be sure to handle legacy tweetrecord-only histories.\n                    # Assume anything without our new _type (which should have been there from the\n                    # start, whoops) is a legacy history.\n                    else:\n                        item = IterationRecord()\n\n                        # Lift extra keys up to upper record (if they exist).\n                        extra_keys = hdict_pre.pop(\"extra_keys\", {})\n                        item.extra_keys = extra_keys\n\n                        hdict_obj = TweetRecord.from_dict(hdict_pre)\n\n                        # Lift timestamp up to upper record.\n                        item.timestamp = hdict_obj.timestamp\n\n                        item.output_records[\"birdsite\"] = hdict_obj\n\n                        history.append(item)\n\n                self.log.debug(f\"Loaded history:\\n {history}\")\n\n                return history\n\n        else:\n            return []", "response": "Load the history from disk to self. history_filename."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset up all output methods.", "response": "def _setup_all_outputs(self) -> None:\n        \"\"\"Set up all output methods. Provide them credentials and anything else they need.\"\"\"\n\n        # The way this is gonna work is that we assume an output should be set up iff it has a\n        # credentials_ directory under our secrets dir.\n        for key in self.outputs.keys():\n            credentials_dir = path.join(self.secrets_dir, f\"credentials_{key}\")\n\n            # special-case birdsite for historical reasons.\n            if key == \"birdsite\" and not path.isdir(credentials_dir) \\\n                    and path.isfile(path.join(self.secrets_dir, \"CONSUMER_KEY\")):\n                credentials_dir = self.secrets_dir\n\n            if path.isdir(credentials_dir):\n                output_skeleton = self.outputs[key]\n\n                output_skeleton[\"active\"] = True\n\n                obj: Any = output_skeleton[\"obj\"]\n                obj.cred_init(secrets_dir=credentials_dir, log=self.log, bot_name=self.bot_name)\n\n                output_skeleton[\"obj\"] = obj\n\n                self.outputs[key] = output_skeleton"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the output records into dicts ready for JSON.", "response": "def _parse_output_records(self, item: IterationRecord) -> Dict[str, Any]:\n        \"\"\"Parse output records into dicts ready for JSON.\"\"\"\n        output_records = {}\n        for key, sub_item in item.output_records.items():\n            if isinstance(sub_item, dict) or isinstance(sub_item, list):\n                output_records[key] = sub_item\n            else:\n                output_records[key] = sub_item.__dict__\n\n        return output_records"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the directory of a fully qualified file name if it does not exist.", "response": "def make_dir(fname):\n    \"\"\"\n    Create the directory of a fully qualified file name if it does not exist.\n\n    :param fname: File name\n    :type  fname: string\n\n    Equivalent to these Bash shell commands:\n\n    .. code-block:: bash\n\n        $ fname=\"${HOME}/mydir/myfile.txt\"\n        $ dir=$(dirname \"${fname}\")\n        $ mkdir -p \"${dir}\"\n\n    :param fname: Fully qualified file name\n    :type  fname: string\n    \"\"\"\n    file_path, fname = os.path.split(os.path.abspath(fname))\n    if not os.path.exists(file_path):\n        os.makedirs(file_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize_windows_fname(fname, _force=False):\n    if (platform.system().lower() != \"windows\") and (not _force):  # pragma: no cover\n        return fname\n    # Replace unintended escape sequences that could be in\n    # the file name, like \"C:\\appdata\"\n    rchars = {\n        \"\\x07\": r\"\\\\a\",\n        \"\\x08\": r\"\\\\b\",\n        \"\\x0C\": r\"\\\\f\",\n        \"\\x0A\": r\"\\\\n\",\n        \"\\x0D\": r\"\\\\r\",\n        \"\\x09\": r\"\\\\t\",\n        \"\\x0B\": r\"\\\\v\",\n    }\n    ret = \"\"\n    for char in os.path.normpath(fname):\n        ret = ret + rchars.get(char, char)\n    # Remove superfluous double backslashes\n    network_share = False\n    tmp = None\n    network_share = fname.startswith(r\"\\\\\")\n    while tmp != ret:\n        tmp, ret = ret, ret.replace(r\"\\\\\\\\\", r\"\\\\\")\n    ret = ret.replace(r\"\\\\\\\\\", r\"\\\\\")\n    # Put back network share if needed\n    if network_share:\n        ret = r\"\\\\\" + ret.lstrip(r\"\\\\\")\n    return ret", "response": "r Normalize a Windows file name to be compatible with Windows."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nenforces line separators to be the right one depending on platform.", "response": "def _homogenize_linesep(line):\n    \"\"\"Enforce line separators to be the right one depending on platform.\"\"\"\n    token = str(uuid.uuid4())\n    line = line.replace(os.linesep, token).replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n    return line.replace(token, os.linesep)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing line range tokens.", "response": "def _proc_token(spec, mlines):\n    \"\"\"Process line range tokens.\"\"\"\n    spec = spec.strip().replace(\" \", \"\")\n    regexp = re.compile(r\".*[^0123456789\\-,]+.*\")\n    tokens = spec.split(\",\")\n    cond = any([not item for item in tokens])\n    if (\"--\" in spec) or (\"-,\" in spec) or (\",-\" in spec) or cond or regexp.match(spec):\n        raise RuntimeError(\"Argument `lrange` is not valid\")\n    lines = []\n    for token in tokens:\n        if token.count(\"-\") > 1:\n            raise RuntimeError(\"Argument `lrange` is not valid\")\n        if \"-\" in token:\n            subtokens = token.split(\"-\")\n            lmin, lmax = (\n                int(subtokens[0]),\n                int(subtokens[1]) if subtokens[1] else mlines,\n            )\n            for num in range(lmin, lmax + 1):\n                lines.append(num)\n        else:\n            lines.append(int(token))\n    if lines != sorted(lines):\n        raise RuntimeError(\"Argument `lrange` is not valid\")\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef incfile(fname, fpointer, lrange=None, sdir=None):\n    # pylint: disable=R0914\n    # Read file\n    file_dir = (\n        sdir\n        if sdir\n        else os.environ.get(\"PKG_DOC_DIR\", os.path.abspath(os.path.dirname(__file__)))\n    )\n    fname = os.path.join(file_dir, fname)\n    with open(fname, \"r\") as fobj:\n        lines = fobj.readlines()\n    # Eliminate spurious carriage returns in Microsoft Windows\n    lines = [_homogenize_linesep(line) for line in lines]\n    # Parse line specification\n    inc_lines = (\n        _proc_token(lrange, len(lines)) if lrange else list(range(1, len(lines) + 1))\n    )\n    # Produce output\n    fpointer(\".. code-block:: python\" + os.linesep)\n    fpointer(os.linesep)\n    for num, line in enumerate(lines):\n        if num + 1 in inc_lines:\n            fpointer(\n                \"    \" + line.replace(\"\\t\", \"    \").rstrip() + os.linesep\n                if line.strip()\n                else os.linesep\n            )\n    fpointer(os.linesep)", "response": "r Include a file in the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting STDOUT of a shell command formatted in reStructuredText.", "response": "def ste(command, nindent, mdir, fpointer, env=None):\n    \"\"\"\n    Print STDOUT of a shell command formatted in reStructuredText.\n\n    This is a simplified version of :py:func:`pmisc.term_echo`.\n\n    :param command: Shell command (relative to **mdir** if **env** is not given)\n    :type  command: string\n\n    :param nindent: Indentation level\n    :type  nindent: integer\n\n    :param mdir: Module directory, used if **env** is not given\n    :type  mdir: string\n\n    :param fpointer: Output function pointer. Normally is :code:`cog.out` but\n                     :code:`print` or other functions can be used for\n                     debugging\n    :type  fpointer: function object\n\n    :param env: Environment dictionary. If not provided, the environment\n                dictionary is the key \"PKG_BIN_DIR\" with the value of the\n                **mdir**\n    :type  env: dictionary\n\n    For example::\n\n        .. This is a reStructuredText file snippet\n        .. [[[cog\n        .. import os, sys\n        .. from docs.support.term_echo import term_echo\n        .. file_name = sys.modules['docs.support.term_echo'].__file__\n        .. mdir = os.path.realpath(\n        ..     os.path.dirname(\n        ..         os.path.dirname(os.path.dirname(file_name))\n        ..     )\n        .. )\n        .. [[[cog ste('build_docs.py -h', 0, mdir, cog.out) ]]]\n\n        .. code-block:: console\n\n        $ ${PKG_BIN_DIR}/build_docs.py -h\n        usage: build_docs.py [-h] [-d DIRECTORY] [-n NUM_CPUS]\n        ...\n        $\n\n        .. ]]]\n\n    \"\"\"\n    sdir = LDELIM + \"PKG_BIN_DIR\" + RDELIM\n    command = (\n        sdir + (\"{sep}{cmd}\".format(sep=os.path.sep, cmd=command))\n        if env is None\n        else command\n    )\n    env = {\"PKG_BIN_DIR\": mdir} if env is None else env\n    term_echo(command, nindent, env, fpointer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef term_echo(command, nindent=0, env=None, fpointer=None, cols=60):\n    # pylint: disable=R0204\n    # Set argparse width so that output does not need horizontal scroll\n    # bar in narrow windows or displays\n    os.environ[\"COLUMNS\"] = str(cols)\n    command_int = command\n    if env:\n        for var, repl in env.items():\n            command_int = command_int.replace('\"' + LDELIM + var + RDELIM + '\"', repl)\n            command_int = command_int.replace(LDELIM + var + RDELIM, repl)\n    tokens = command_int.split(\" \")\n    # Add Python interpreter executable for Python scripts on Windows since\n    # the shebang does not work\n    if (platform.system().lower() == \"windows\") and (\n        tokens[0].endswith(\".py\")\n    ):  # pragma: no cover\n        tokens = [sys.executable] + tokens\n    proc = subprocess.Popen(tokens, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    stdout = proc.communicate()[0]\n    if sys.hexversion >= 0x03000000:  # pragma: no cover\n        stdout = stdout.decode(\"utf-8\")\n    stdout = stdout.split(\"\\n\")\n    indent = nindent * \" \"\n    fpointer(os.linesep)\n    fpointer(\"{0}.. code-block:: console{1}\".format(indent, os.linesep))\n    fpointer(os.linesep)\n    fpointer(\"{0}    $ {1}{2}\".format(indent, command, os.linesep))\n    for line in stdout:\n        line = _homogenize_linesep(line)\n        if line.strip():\n            fpointer(indent + \"    \" + line.replace(\"\\t\", \"    \") + os.linesep)\n        else:\n            fpointer(os.linesep)", "response": "Print a shell command formatted in reStructuredText."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the string given by param formatted with the callers locals.", "response": "def flo(string):\n    '''Return the string given by param formatted with the callers locals.'''\n    callers_locals = {}\n    frame = inspect.currentframe()\n    try:\n        outerframe = frame.f_back\n        callers_locals = outerframe.f_locals\n    finally:\n        del frame\n    return string.format(**callers_locals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _wrap_with(color_code):\n    '''Color wrapper.\n\n    Example:\n        >>> blue = _wrap_with('34')\n        >>> print(blue('text'))\n        \\033[34mtext\\033[0m\n    '''\n    def inner(text, bold=False):\n        '''Inner color function.'''\n        code = color_code\n        if bold:\n            code = flo(\"1;{code}\")\n        return flo('\\033[{code}m{text}\\033[0m')\n    return inner", "response": "Color wrapper.\n\n    Example:\n        >>> blue = _wrap_with('34')\n        >>> print(blue('text'))\n        \\033[34mtext\\033[0m"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete temporary files and directories for packaging and editing.", "response": "def clean(deltox=False):\n    '''Delete temporary files not under version control.\n\n    Args:\n        deltox: If True, delete virtual environments used by tox\n    '''\n\n    basedir = dirname(__file__)\n\n    print(cyan('delete temp files and dirs for packaging'))\n    local(flo(\n        'rm -rf  '\n        '{basedir}/.eggs/  '\n        '{basedir}/utlz.egg-info/  '\n        '{basedir}/dist  '\n        '{basedir}/README  '\n        '{basedir}/build/  '\n    ))\n\n    print(cyan('\\ndelete temp files and dirs for editing'))\n    local(flo(\n        'rm -rf  '\n        '{basedir}/.cache  '\n        '{basedir}/.ropeproject  '\n    ))\n\n    print(cyan('\\ndelete bytecode compiled versions of the python src'))\n    # cf. http://stackoverflow.com/a/30659970\n    local(flo('find  {basedir}/utlz  {basedir}/tests  ') +\n          '\\( -name \\*pyc -o -name \\*.pyo -o -name __pycache__ '\n          '-o -name \\*.so -o -name \\*.o -o -name \\*.c \\) '\n          '-prune '\n          '-exec rm -rf {} +')\n\n    if deltox:\n        print(cyan('\\ndelete tox virual environments'))\n        local(flo('cd {basedir}  &&  rm -rf .tox/'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling latest pythons with pyenv.", "response": "def pythons():\n    '''Install latest pythons with pyenv.\n\n    The python version will be activated in the projects base dir.\n\n    Will skip already installed latest python versions.\n    '''\n    if not _pyenv_exists():\n        print('\\npyenv is not installed. You can install it with fabsetup '\n              '(https://github.com/theno/fabsetup):\\n\\n    ' +\n              cyan('mkdir ~/repos && cd ~/repos\\n    '\n                   'git clone  https://github.com/theno/fabsetup.git\\n    '\n                   'cd fabsetup  &&  fab setup.pyenv -H localhost'))\n        return 1\n\n    latest_pythons = _determine_latest_pythons()\n\n    print(cyan('\\n## install latest python versions'))\n    for version in latest_pythons:\n        local(flo('pyenv install --skip-existing {version}'))\n\n    print(cyan('\\n## activate pythons'))\n    basedir = dirname(__file__)\n    latest_pythons_str = '  '.join(latest_pythons)\n    local(flo('cd {basedir}  &&  pyenv local  system  {latest_pythons_str}'))\n\n    highest_python = latest_pythons[-1]\n    print(cyan(flo(\n        '\\n## prepare Python-{highest_python} for testing and packaging')))\n    packages_for_testing = 'pytest  tox'\n    packages_for_packaging = 'pypandoc  twine'\n    local(flo('~/.pyenv/versions/{highest_python}/bin/pip  install --upgrade  '\n              'pip  {packages_for_testing}  {packages_for_packaging}'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns tox. Build package and run unit tests against several pythons.", "response": "def tox(args=''):\n    '''Run tox.\n\n    Build package and run unit tests against several pythons.\n\n    Args:\n        args: Optional arguments passed to tox.\n        Example:\n\n            fab tox:'-e py36 -r'\n    '''\n    basedir = dirname(__file__)\n\n    latest_pythons = _determine_latest_pythons()\n    # e.g. highest_minor_python: '3.6'\n    highest_minor_python = _highest_minor(latest_pythons)\n\n    _local_needs_pythons(flo('cd {basedir}  &&  '\n                             'python{highest_minor_python} -m tox {args}'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pypi():\n    '''Build package and upload to pypi.'''\n    if query_yes_no('version updated in setup.py?'):\n\n        print(cyan('\\n## clean-up\\n'))\n        execute(clean)\n\n        basedir = dirname(__file__)\n\n        latest_pythons = _determine_latest_pythons()\n        # e.g. highest_minor: '3.6'\n        highest_minor = _highest_minor(latest_pythons)\n        python = flo('python{highest_minor}')\n\n        print(cyan('\\n## build package'))\n        _local_needs_pythons(flo('cd {basedir}  &&  {python}  setup.py  sdist'))\n\n        print(cyan('\\n## upload package'))\n        local(flo('cd {basedir}  &&  {python} -m twine upload  dist/*'))", "response": "Build and upload to pypi."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck that the input column numbers are out of range.", "response": "def chk_col_numbers(line_num, num_cols, tax_id_col, id_col, symbol_col):\n    \"\"\"\n    Check that none of the input column numbers is out of range.\n    (Instead of defining this function, we could depend on Python's built-in\n    IndexError exception for this issue, but the IndexError exception wouldn't\n    include line number information, which is helpful for users to find exactly\n    which line is the culprit.)\n    \"\"\"\n\n    bad_col = ''\n    if tax_id_col >= num_cols:\n        bad_col = 'tax_id_col'\n    elif id_col >= num_cols:\n        bad_col = 'discontinued_id_col'\n    elif symbol_col >= num_cols:\n        bad_col = 'discontinued_symbol_col'\n\n    if bad_col:\n        raise Exception(\n            'Input file line #%d: column number of %s is out of range' %\n            (line_num, bad_col))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_gene_history(file_handle, tax_id, tax_id_col, id_col, symbol_col):\n\n    # Make sure that tax_id is not \"\" or \"  \"\n    if not tax_id or tax_id.isspace():\n        raise Exception(\"Input tax_id is blank\")\n\n    # Make sure that tax_id exists in Organism table in the database.\n    try:\n        organism = Organism.objects.get(taxonomy_id=tax_id)\n    except Organism.DoesNotExist:\n        raise Exception('Input tax_id %s does NOT exist in Organism table. '\n                        'Please add it into Organism table first.' % tax_id)\n\n    if tax_id_col < 0 or id_col < 0 or symbol_col < 0:\n        raise Exception(\n            'tax_id_col, id_col and symbol_col must be positive integers')\n\n    for line_index, line in enumerate(file_handle):\n        if line.startswith('#'):  # Skip comment lines.\n            continue\n\n        fields = line.rstrip().split('\\t')\n        # Check input column numbers.\n        chk_col_numbers(line_index + 1, len(fields), tax_id_col, id_col,\n                        symbol_col)\n\n        # Skip lines whose tax_id's do not match input tax_id.\n        if tax_id != fields[tax_id_col]:\n            continue\n\n        entrez_id = fields[id_col]\n        # If the gene already exists in database, set its \"obsolete\" attribute\n        # to True; otherwise create a new obsolete Gene record in database.\n        try:\n            gene = Gene.objects.get(entrezid=entrez_id)\n            if not gene.obsolete:\n                gene.obsolete = True\n                gene.save()\n        except Gene.DoesNotExist:\n            Gene.objects.create(entrezid=entrez_id, organism=organism,\n                                systematic_name=fields[symbol_col],\n                                obsolete=True)", "response": "Read the gene history file into the database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cred_init(\n            self,\n            *,\n            secrets_dir: str,\n            log: Logger,\n            bot_name: str=\"\",\n    ) -> None:\n        \"\"\"Initialize what requires credentials/secret files.\"\"\"\n        super().__init__(secrets_dir=secrets_dir, log=log, bot_name=bot_name)\n\n        self.ldebug(\"Retrieving ACCESS_TOKEN ...\")\n        with open(path.join(self.secrets_dir, \"ACCESS_TOKEN\")) as f:\n            ACCESS_TOKEN = f.read().strip()\n\n        # Instance base url optional.\n        self.ldebug(\"Looking for INSTANCE_BASE_URL ...\")\n        instance_base_url_path = path.join(self.secrets_dir, \"INSTANCE_BASE_URL\")\n        if path.isfile(instance_base_url_path):\n            with open(instance_base_url_path) as f:\n                self.instance_base_url = f.read().strip()\n        else:\n            self.ldebug(\"Couldn't find INSTANCE_BASE_URL, defaulting to mastodon.social.\")\n            self.instance_base_url = \"https://mastodon.social\"\n\n        self.api = mastodon.Mastodon(access_token=ACCESS_TOKEN,\n                                     api_base_url=self.instance_base_url)\n        self.html_re = re.compile(\"<.*?>\")", "response": "Initialize what requires credentials and secret files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(\n            self,\n            *,\n            text: str,\n    ) -> List[OutputRecord]:\n        \"\"\"\n        Send mastodon message.\n\n        :param text: text to send in post.\n        :returns: list of output records,\n            each corresponding to either a single post,\n            or an error.\n        \"\"\"\n        try:\n            status = self.api.status_post(status=text)\n\n            return [TootRecord(record_data={\n                \"toot_id\": status[\"id\"],\n                \"text\": text\n            })]\n\n        except mastodon.MastodonError as e:\n            return [self.handle_error((f\"Bot {self.bot_name} encountered an error when \"\n                                      f\"sending post {text} without media:\\n{e}\\n\"),\n                                     e)]", "response": "Send a message to the specified toot."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads media to mastodon and sends status and media to the bot.", "response": "def send_with_media(\n            self,\n            *,\n            text: str,\n            files: List[str],\n            captions: List[str]=[],\n    ) -> List[OutputRecord]:\n        \"\"\"\n        Upload media to mastodon,\n        and send status and media,\n        and captions if present.\n\n        :param text: post text.\n        :param files: list of files to upload with post.\n        :param captions: list of captions to include as alt-text with files.\n        :returns: list of output records,\n            each corresponding to either a single post,\n            or an error.\n        \"\"\"\n        try:\n            self.ldebug(f\"Uploading files {files}.\")\n            if captions is None:\n                captions = []\n\n            if len(files) > len(captions):\n                captions.extend([self.default_caption_message] * (len(files) - len(captions)))\n\n            media_dicts = []\n            for i, file in enumerate(files):\n                caption = captions[i]\n                media_dicts.append(self.api.media_post(file, description=caption))\n\n            self.ldebug(f\"Media ids {media_dicts}\")\n\n        except mastodon.MastodonError as e:\n            return [self.handle_error(\n                f\"Bot {self.bot_name} encountered an error when uploading {files}:\\n{e}\\n\", e\n            )]\n\n        try:\n            status = self.api.status_post(status=text, media_ids=media_dicts)\n            self.ldebug(f\"Status object from toot: {status}.\")\n            return [TootRecord(record_data={\n                \"toot_id\": status[\"id\"],\n                \"text\": text,\n                \"media_ids\": media_dicts,\n                \"captions\": captions\n            })]\n\n        except mastodon.MastodonError as e:\n            return [self.handle_error((f\"Bot {self.bot_name} encountered an error when \"\n                                      f\"sending post {text} with media dicts {media_dicts}:\"\n                                      f\"\\n{e}\\n\"),\n                                     e)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef perform_batch_reply(\n            self,\n            *,\n            callback: Callable[..., str],\n            lookback_limit: int,\n            target_handle: str,\n    ) -> List[OutputRecord]:\n        \"\"\"\n        Performs batch reply on target account.\n        Looks up the recent messages of the target user,\n        applies the callback,\n        and replies with\n        what the callback generates.\n\n        :param callback: a callback taking a message id,\n            message contents,\n            and optional extra keys,\n            and returning a message string.\n        :param target: the id of the target account.\n        :param lookback_limit: a lookback limit of how many messages to consider.\n        :returns: list of output records,\n            each corresponding to either a single post,\n            or an error.\n        \"\"\"\n        self.log.info(f\"Attempting to batch reply to mastodon user {target_handle}\")\n\n        # target handle should be able to be provided either as @user or @user@domain\n        # note that this produces an empty first chunk\n        handle_chunks = target_handle.split(\"@\")\n        target_base_handle = handle_chunks[1]\n\n        records: List[OutputRecord] = []\n        our_id = self.api.account_verify_credentials()[\"id\"]\n\n        # be careful here - we're using a search to do this,\n        # and if we're not careful we'll pull up people just mentioning the target.\n        possible_accounts = self.api.account_search(target_handle, following=True)\n        their_id = None\n        for account in possible_accounts:\n            if account[\"username\"] == target_base_handle:\n                their_id = account[\"id\"]\n                break\n\n        if their_id is None:\n            return [self.handle_error(f\"Could not find target handle {target_handle}!\", None)]\n\n        statuses = self.api.account_statuses(their_id, limit=lookback_limit)\n        for status in statuses:\n\n            status_id = status.id\n\n            # find possible replies we've made.\n            our_statuses = self.api.account_statuses(our_id, since_id=status_id)\n            in_reply_to_ids = list(map(lambda x: x.in_reply_to_id, our_statuses))\n            if status_id not in in_reply_to_ids:\n\n                encoded_status_text = re.sub(self.html_re, \"\", status.content)\n                status_text = html.unescape(encoded_status_text)\n\n                message = callback(message_id=status_id, message=status_text, extra_keys={})\n                self.log.info(f\"Replying {message} to status {status_id} from {target_handle}.\")\n                try:\n                    new_status = self.api.status_post(status=message, in_reply_to_id=status_id)\n\n                    records.append(TootRecord(record_data={\n                        \"toot_id\": new_status.id,\n                        \"in_reply_to\": target_handle,\n                        \"in_reply_to_id\": status_id,\n                        \"text\": message,\n                    }))\n\n                except mastodon.MastodonError as e:\n                    records.append(\n                        self.handle_error((f\"Bot {self.bot_name} encountered an error when \"\n                                           f\"sending post {message} during a batch reply \"\n                                           f\":\\n{e}\\n\"),\n                                          e))\n            else:\n                self.log.info(f\"Not replying to status {status_id} from {target_handle} \"\n                              f\"- we already replied.\")\n\n        return records", "response": "Perform a batch reply on the target account."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_error(self, message: str, e: mastodon.MastodonError) -> OutputRecord:\n        self.lerror(f\"Got an error! {e}\")\n\n        # Handle errors if we know how.\n        try:\n            code = e[0][\"code\"]\n            if code in self.handled_errors:\n                self.handled_errors[code]\n            else:\n                pass\n\n        except Exception:\n            pass\n\n        return TootRecord(error=e)", "response": "Handle an error while trying to do something."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the header from the log file.", "response": "def _read_header(self):\n        '''\n        Little-endian\n        |... 4 bytes unsigned int ...|... 4 bytes unsigned int ...|\n        |        frames count        |      dimensions count      |\n        '''\n        self._fh.seek(0)\n        buf = self._fh.read(4*2)\n        fc, dc = struct.unpack(\"<II\", buf)\n        return fc, dc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a callback to the list of listeners that will be called when the value modification of a key is received.", "response": "def listen(self, you):\n        \"\"\"\n        Request a callback for value modification.\n\n        Parameters\n        ----------\n        you : object\n            An instance having ``__call__`` attribute.\n        \"\"\"\n        self._listeners.append(you)\n        self.raw.talk_to(you)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_term_by_id(self, id):\n        '''Simple utility function to load a term.\n        '''\n        url = (self.url + '/%s.json') % id\n        r = self.session.get(url)\n        return r.json()", "response": "Simple utility function to load a term.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all concepts or collections that form the top-level of a display hierarchy. As opposed to the :meth:`get_top_concepts`, this method can possibly return both concepts and collections. :rtype: Returns a list of concepts and collections. For each an id is present and a label. The label is determined by looking at the `**kwargs` parameter, the default language of the provider and falls back to `en` if nothing is present.", "response": "def get_top_display(self, **kwargs):\n        '''\n        Returns all concepts or collections that form the top-level of a display\n        hierarchy.\n\n        As opposed to the :meth:`get_top_concepts`, this method can possibly\n        return both concepts and collections.\n\n        :rtype: Returns a list of concepts and collections. For each an\n            id is present and a label. The label is determined by looking at\n            the `**kwargs` parameter, the default language of the provider\n            and falls back to `en` if nothing is present.\n        '''\n        language = self._get_language(**kwargs)\n        url = self.url + '/lijst.json'\n        args = {'type[]': ['HR']}\n        r = self.session.get(url, params=args)\n        result = r.json()\n        items = result\n        top = self.get_by_id(items[0]['id'])\n        res = []\n        def expand_coll(res, coll):\n            for nid in coll.members:\n                c = self.get_by_id(nid)\n                res.append({\n                    'id': c.id,\n                    'label': c.label(language)\n                })\n            return res\n        return expand_coll(res, top)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of concepts or collections that should be displayed under this concept or collection.", "response": "def get_children_display(self, id, **kwargs):\n        '''\n        Return a list of concepts or collections that should be displayed\n        under this concept or collection.\n\n        :param id: A concept or collection id.\n        :rtype: A list of concepts and collections. For each an\n            id is present and a label. The label is determined by looking at\n            the `**kwargs` parameter, the default language of the provider\n            and falls back to `en` if nothing is present. If the id does not\n            exist, return `False`.\n        '''\n        language = self._get_language(**kwargs)\n        item = self.get_by_id(id)\n        res = []\n        if isinstance(item, Collection):\n            for mid in item.members:\n                m = self.get_by_id(mid)\n                res.append({\n                    'id': m.id,\n                    'label': m.label(language)\n                })\n        else:\n            for cid in item.narrower:\n                c = self.get_by_id(cid)\n                res.append({\n                    'id': c.id,\n                    'label': c.label(language)\n                })\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntranslates a list of identifiers from one gene to another.", "response": "def translate_genes(id_list=None, from_id=None, to_id=None, organism=None):\n    \"\"\"\n    Pass a list of identifiers (id_list), the name of the database ('Entrez',\n    'Symbol', 'Standard name', 'Systematic name' or a loaded crossreference\n    database) that you wish to translate from, and the name of the database\n    that you wish to translate to.\n    \"\"\"\n\n    ids = set(id_list)\n    # Initialize set of identifiers not found by this translate_genes method.\n    not_found = set()\n    from_ids = None  # Get the map of from_ids to the gene pks\n\n    if organism is not None:\n        gene_objects_manager = Gene.objects.filter(\n            organism__scientific_name=organism)\n    else:\n        gene_objects_manager = Gene.objects\n\n    if (from_id == 'Entrez'):\n        int_list = []\n        for x in ids:\n            try:\n                int_list.append(int(x))\n            except(ValueError):\n                not_found.add(x)\n        ids = set(int_list)\n        from_ids = gene_objects_manager.filter(entrezid__in=ids).values_list(\n            'entrezid', 'id')\n    elif (from_id == 'Systematic name'):\n        from_ids = gene_objects_manager.filter(\n            systematic_name__in=ids).values_list('systematic_name', 'id')\n    elif (from_id == 'Standard name'):\n        from_ids = gene_objects_manager.filter(\n            standard_name__in=ids).values_list('standard_name', 'id')\n    elif (from_id == 'Symbol'):\n        # If standard_name exists, symbol will be standard_name; otherwise\n        # symbol will be systematic_name.\n        from_ids = gene_objects_manager.annotate(\n            symbol=Coalesce('standard_name', 'systematic_name')).filter(\n                symbol__in=ids).values_list('symbol', 'id')\n    else:  # a crossreference db?\n        xrdb = CrossRefDB.objects.get(name=from_id)\n        from_ids = CrossRef.objects.filter(crossrefdb=xrdb).values_list(\n            'xrid', 'gene__id')\n\n    # Dictionary that maps from type ID passed by user to gene__id.\n    from_id_map = {}\n    gene_ids = []\n    for item in from_ids:\n        from_id_map[item[0]] = item[1]\n        gene_ids.append(item[1])\n\n    # Now let's figure out what we need to go to:\n    to_ids = None\n    if (to_id == 'Entrez'):\n        to_ids = Gene.objects.filter(id__in=gene_ids).values_list(\n            'id', 'entrezid')\n    elif (to_id == 'Systematic name'):\n        to_ids = Gene.objects.filter(id__in=gene_ids).values_list(\n            'id', 'systematic_name')\n    elif (to_id == 'Standard name'):\n        to_ids = Gene.objects.filter(id__in=gene_ids).values_list(\n            'id', 'standard_name')\n    elif (to_id == 'Symbol'):\n        # If standard_name exists, symbol will be standard_name; otherwise\n        # symbol will be systematic_name.\n        to_ids = Gene.objects.annotate(\n            symbol=Coalesce('standard_name', 'systematic_name')).filter(\n                id__in=gene_ids).values_list('id', 'symbol')\n\n    else:  # A crossreference db?\n        xrdb = CrossRefDB.objects.get(name=to_id)\n        to_ids = CrossRef.objects.filter(crossrefdb=xrdb).values_list(\n            'gene__id', 'xrid')\n\n    to_id_map = {}\n    for item in to_ids:\n        if not item[0] in to_id_map:\n            to_id_map[item[0]] = [item[1], ]\n        else:\n            to_id_map[item[0]].append(item[1])\n\n    from_to = {}\n    for item in ids:\n        try:\n            gene_id = from_id_map[item]\n        except KeyError:\n            not_found.add(item)\n            continue\n        to_id = to_id_map[gene_id]\n        from_to[item] = to_id\n    from_to['not_found'] = list(not_found)\n\n    return from_to"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndraw a cross centered in the target area.", "response": "def Cross(width=3, color=0):\n    \"\"\"Draws a cross centered in the target area\n\n    :param width: width of the lines of the cross in pixels\n    :type width: int\n    :param color: color of the lines of the cross\n    :type color: pygame.Color\n    \"\"\"\n    return Overlay(Line(\"h\", width, color), Line(\"v\", width, color))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntop level function to create a tuple of nodes.", "response": "def compose(target, root=None):\n    \"\"\"Top level function to create a surface.\n    \n    :param target: the pygame.Surface to blit on. Or a (width, height) tuple\n        in which case a new surface will be created\n\n    :type target: -\n    \"\"\"\n    if type(root) == Surface:\n        raise ValueError(\"A Surface may not be used as root, please add \"\n                        +\"it as a single child i.e. compose(...)(Surface(...))\")\n    @_inner_func_anot\n    def inner_compose(*children):\n        if root:\n            root_context = root(*children)\n        else:\n            assert len(children) == 1\n            root_context = children[0]\n\n        if type(target) == pygame.Surface:\n            surface = target\n            size = target.get_size()\n        else:\n            size = target\n            surface = pygame.Surface(size)\n\n        root_context._draw(surface, pygame.Rect(0, 0, *size))\n        return surface\n    return inner_compose"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a font object for the current object.", "response": "def Font(name=None, source=\"sys\", italic=False, bold=False, size=20):\n    \"\"\"Unifies loading of fonts.\n\n    :param name: name of system-font or filepath, if None is passed the default\n        system-font is loaded\n\n    :type name: str\n    :param source: \"sys\" for system font, or \"file\" to load a file\n    :type source: str\n    \"\"\"\n    assert source in [\"sys\", \"file\"]\n    if not name:\n        return pygame.font.SysFont(pygame.font.get_default_font(), \n        size, bold=bold, italic=italic)\n    if source == \"sys\":\n        return pygame.font.SysFont(name, \n        size, bold=bold, italic=italic)\n    else:\n        f = pygame.font.Font(name, size)\n        f.set_italic(italic)\n        f.set_bold(bold)\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Text(text, font, color=pygame.Color(0, 0, 0), antialias=False, align=\"center\"):\n    assert align in [\"center\", \"left\", \"right\"]\n    margin_l, margin_r = 1, 1\n    if align == \"left\": margin_l = 0\n    elif align == \"right\": margin_r = 0\n    margin = Margin(margin_l, margin_r)\n    color_key = pygame.Color(0, 0, 1) if pygame.Color(0, 0, 1) != color else 0x000002\n    \n    text_surfaces = _lmap(lambda text: _text(text, font=font, \n                                   color=color, antialias=antialias),\n                                   map(methodcaller(\"strip\"), text.split(\"\\n\")))\n    w = max(surf.get_rect().w for surf in text_surfaces)\n    h = sum(surf.get_rect().h for surf in text_surfaces)\n    surf = compose((w, h), Fill(color_key))(LinLayout(\"v\")(\n        *_lmap(lambda s: Surface(margin)(s), text_surfaces)))\n    surf.set_colorkey(color_key)\n    return surf.convert_alpha()", "response": "Renders a text. Supports multiline text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a padding by the remaining space after scaling the content.", "response": "def from_scale(scale_w, scale_h=None):\n        \"\"\"Creates a padding by the remaining space after scaling the content.\n\n        E.g. Padding.from_scale(0.5) would produce Padding(0.25, 0.25, 0.25, 0.25) and\n        Padding.from_scale(0.5, 1) would produce Padding(0.25, 0.25, 0, 0)\n        because the content would not be scaled (since scale_h=1) and therefore\n        there would be no vertical padding.\n        \n        If scale_h is not specified scale_h=scale_w is used as default\n\n        :param scale_w: horizontal scaling factors\n        :type scale_w: float\n        :param scale_h: vertical scaling factor\n        :type scale_h: float\n        \"\"\"\n        if not scale_h: scale_h = scale_w\n        w_padding = [(1 - scale_w) * 0.5] * 2\n        h_padding = [(1 - scale_h) * 0.5] * 2\n        return Padding(*w_padding, *h_padding)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef radicals(self, levels=None):\n        url = WANIKANI_BASE.format(self.api_key, 'radicals')\n        if levels:\n            url += '/{0}'.format(levels)\n        data = self.get(url)\n\n        for item in data['requested_information']:\n            yield Radical(item)", "response": "Gets the list of radicals for a given set of levels."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an iterator over all Kanji items.", "response": "def kanji(self, levels=None):\n        \"\"\"\n        :param levels: An optional argument of declaring a single or\n            comma-delimited list of levels is available, as seen in the example\n            as 1. An example of a comma-delimited list of levels is 1,2,5,9.\n        :type levels: str or None\n\n        http://www.wanikani.com/api/v1.2#kanji-list\n        \"\"\"\n        url = WANIKANI_BASE.format(self.api_key, 'kanji')\n        if levels:\n            url += '/{0}'.format(levels)\n        data = self.get(url)\n\n        for item in data['requested_information']:\n            yield Kanji(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a generator that yields all available or obsolete vocabulary items.", "response": "def vocabulary(self, levels=None):\n        \"\"\"\n        :param levels: An optional argument of declaring a single or\n            comma-delimited list of levels is available, as seen in the example\n            as 1. An example of a comma-delimited list of levels is 1,2,5,9.\n        :type levels: str or None\n\n        http://www.wanikani.com/api/v1.2#vocabulary-list\n        \"\"\"\n\n        url = WANIKANI_BASE.format(self.api_key, 'vocabulary')\n        if levels:\n            url += '/{0}'.format(levels)\n        data = self.get(url)\n\n        if 'general' in data['requested_information']:\n            for item in data['requested_information']['general']:\n                yield Vocabulary(item)\n        else:\n            for item in data['requested_information']:\n                yield Vocabulary(item)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ishex(obj):\n    return isinstance(obj, str) and (len(obj) == 1) and (obj in string.hexdigits)", "response": "Test if the argument is a string representing a valid hexadecimal digit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if the argument is a number.", "response": "def isnumber(obj):\n    \"\"\"\n    Test if the argument is a number (complex, float or integer).\n\n    :param obj: Object\n    :type  obj: any\n\n    :rtype: boolean\n    \"\"\"\n    return (\n        (obj is not None)\n        and (not isinstance(obj, bool))\n        and isinstance(obj, (int, float, complex))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isreal(obj):\n    return (\n        (obj is not None)\n        and (not isinstance(obj, bool))\n        and isinstance(obj, (int, float))\n    )", "response": "Test if the argument is a real number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_api_context(self, cls):\n        return self.api_context_schema().load({\n            \"name\": cls.name,\n            \"cls\": cls,\n            \"inst\": [],\n            \"conf\": self.conf.get_api_service(cls.name),\n            \"calls\": self.conf.get_api_calls(),\n            \"shared\": {},  # Used per-API to monitor state\n            \"log_level\": self.conf.get_log_level(),\n            \"callback\": self.receive\n            })", "response": "Create and return an API context object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass an API result down the pipeline", "response": "def receive(self, data, api_context):\n        \"\"\"Pass an API result down the pipeline\"\"\"\n        self.log.debug(f\"Putting data on the pipeline: {data}\")\n        result = {\n            \"api_contexts\": self.api_contexts,\n            \"api_context\": api_context,\n            \"strategy\": dict(),  # Shared strategy data\n            \"result\": data,\n            \"log_level\": api_context[\"log_level\"],\n        }\n        self.strat.execute(self.strategy_context_schema().load(result).data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef course(self):\n        course = self.parent\n        while course.parent:\n            course = course.parent\n        return course", "response": "Returns the Course this node belongs to"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef path(self):\n        if self.parent is None:\n            return self.title\n        return join(self.parent.path, self.title)", "response": "Returns the path of this node on Studip."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef title(self):\n        tmp = c.namemap_lookup(self.id) if c.namemap_lookup(self.id) is not None else self._title\n        return secure_filename(tmp)", "response": "get the title of this node"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deep_documents(self):\n        tree = []\n        for entry in self.contents:\n            if isinstance(entry, Document):\n                tree.append(entry)\n            else:\n                tree += entry.deep_documents\n        return tree", "response": "returns a list of all documents find in subtrees of this node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef title(self):\n        name = c.namemap_lookup(self.id)\n        if name is None:\n            name = self._title + \" \" + client.get_semester_title(self)\n            c.namemap_set(self.id, name)\n        return secure_filename(name)", "response": "Returns the title of the course."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a get request against a url. Returns the response which can optionally be streamed", "response": "def _get(self, route, stream=False):\n        \"\"\"\n        run a get request against an url. Returns the response which can optionally be streamed\n        \"\"\"\n        log.debug(\"Running GET request against %s\" % route)\n        return r.get(self._url(route), auth=c.auth, stream=stream)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_contents(self, folder: Folder):\n        log.debug(\"Listing Contents of %s/%s\" % (folder.course.id, folder.id))\n        if isinstance(folder, Course):\n            response = json.loads(self._get('/api/documents/%s/folder' % folder.course.id).text)\n        else:\n            response = json.loads(self._get('/api/documents/%s/folder/%s' % (folder.course.id, folder.id)).text)\n            log.debug(\"Got response: %s\" % response)\n\n        documents = [Document.from_response(response, folder) for response in response[\"documents\"]]\n\n        folders = [Folder.from_response(response, folder) for response in response[\"folders\"]]\n\n        return documents + folders", "response": "Returns a list of all contents of a folder. Returns a list of all Documents and Folders in this order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download_document(self, document: Document, overwrite=True, path=None):\n        if not path:\n            path = os.path.join(os.path.expanduser(c[\"base_path\"]), document.path)\n        if (self.modified(document) and overwrite) or not os.path.exists(join(path, document.title)):\n            log.info(\"Downloading %s\" % join(path, document.title))\n            file = self._get('/api/documents/%s/download' % document.id, stream=True)\n            os.makedirs(path, exist_ok=True)\n            with open(join(path, document.title), 'wb') as f:\n                shutil.copyfileobj(file.raw, f)", "response": "Download a document to the given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_semester_title(self, node: BaseNode):\n        log.debug(\"Getting Semester Title for %s\" % node.course.id)\n        return self._get_semester_from_id(node.course.semester)", "response": "get the semester title of a node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_courses(self):\n        log.info(\"Listing Courses...\")\n        courses = json.loads(self._get('/api/courses').text)[\"courses\"]\n        courses = [Course.from_response(course) for course in courses]\n        log.debug(\"Courses: %s\" % [str(entry) for entry in courses])\n        return courses", "response": "List all courses in the user s site"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nminimizing a scalar function using Brent s method.", "response": "def _minimize_scalar(\n        self, desc=\"Progress\", rtol=1.4902e-08, atol=1.4902e-08, verbose=True\n    ):\n        \"\"\"\n        Minimize a scalar function using Brent's method.\n\n        Parameters\n        ----------\n        verbose : bool\n            ``True`` for verbose output; ``False`` otherwise.\n        \"\"\"\n        from tqdm import tqdm\n        from numpy import asarray\n        from brent_search import minimize as brent_minimize\n\n        variables = self._variables.select(fixed=False)\n        if len(variables) != 1:\n            raise ValueError(\"The number of variables must be equal to one.\")\n\n        var = variables[variables.names()[0]]\n        progress = tqdm(desc=desc, disable=not verbose)\n\n        def func(x):\n            progress.update(1)\n            var.value = x\n            return self.__sign * self.value()\n\n        r = asarray(\n            brent_minimize(func, a=var.bounds[0], b=var.bounds[1], rtol=rtol, atol=atol)\n        )\n        var.value = r[0]\n        progress.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef digest(self, alg='sha256', b64=True, strip=True):\r\n        import base64, hashlib\r\n\r\n        h = hashlib.new(alg)\r\n        h.update(str(self).encode('utf-8'))\r\n        if b64 == True:\r\n            # this returns a string with a predictable amount of = padding at the end\r\n            b = base64.urlsafe_b64encode(h.digest()).decode('ascii')\r\n            if strip == True:\r\n                b = b.rstrip('=')\r\n            return b\r\n        else:\r\n            return h.hexdigest()", "response": "Returns a url - safe base64 - encoded SHA - 256 hash of the string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nturns a string to CamelCase omitting non - word characters", "response": "def camelify(self):\r\n        \"\"\"turn a string to CamelCase, omitting non-word characters\"\"\"\r\n        outstring = self.titleify(allwords=True)\r\n        outstring = re.sub(r\"&[^;]+;\", \" \", outstring)\r\n        outstring = re.sub(r\"\\W+\", \"\", outstring)\r\n        return String(outstring)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a string and makes a title from it", "response": "def titleify(self, lang='en', allwords=False, lastword=True):\r\n        \"\"\"takes a string and makes a title from it\"\"\"\r\n        if lang in LOWERCASE_WORDS:\r\n            lc_words = LOWERCASE_WORDS[lang]\r\n        else:\r\n            lc_words = []\r\n        s = str(self).strip()\r\n        l = re.split(r\"([_\\W]+)\", s)\r\n        for i in range(len(l)):\r\n            l[i] = l[i].lower()\r\n            if (\r\n                allwords == True\r\n                or i == 0\r\n                or (lastword == True and i == len(l) - 1)\r\n                or l[i].lower() not in lc_words\r\n            ):\r\n                w = l[i]\r\n                if len(w) > 1:\r\n                    w = w[0].upper() + w[1:]\r\n                else:\r\n                    w = w.upper()\r\n                l[i] = w\r\n        s = \"\".join(l)\r\n        return String(s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef identifier(self, camelsplit=False, ascii=True):\r\n        return self.nameify(camelsplit=camelsplit, ascii=ascii, sep='_')", "response": "return a python identifier from the string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an XML name ( hyphen - separated by default initial underscore if non - letter", "response": "def nameify(self, camelsplit=False, ascii=True, sep='-'):\r\n        \"\"\"return an XML name (hyphen-separated by default, initial underscore if non-letter)\"\"\"\r\n        s = String(str(self))  # immutable\r\n        if camelsplit == True:\r\n            s = s.camelsplit()\r\n        s = s.hyphenify(ascii=ascii).replace('-', sep)\r\n        if len(s) == 0 or re.match(\"[A-Za-z_]\", s[0]) is None:\r\n            s = \"_\" + s\r\n        return String(s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hyphenify(self, ascii=False):\r\n        s = str(self)\r\n        s = re.sub(\"\"\"['\"\\u2018\\u2019\\u201c\\u201d]\"\"\", '', s)  # quotes\r\n        s = re.sub(r'(?:\\s|%20)+', '-', s)  # whitespace\r\n        if ascii == True:  # ASCII-only\r\n            s = s.encode('ascii', 'xmlcharrefreplace').decode('ascii')  # use entities\r\n        s = re.sub(\"&?([^;]*?);\", r'.\\1-', s)  # entities\r\n        s = s.replace('#', 'u')\r\n        s = re.sub(r\"\\W+\", '-', s).strip(' -')\r\n        return String(s)", "response": "Turn non - word characters into single hyphens."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef camelsplit(self):\r\n        s = str(self)\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if i != 0 and (\r\n                (s[i].isupper() and s[i - 1].isalnum() and not s[i - 1].isupper())\r\n                or (s[i].isnumeric() and s[i - 1].isalpha())\r\n            ):\r\n                s = s[:i] + ' ' + s[i:]\r\n        return String(s.strip())", "response": "Turn a CamelCase string into a string with spaces"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the event scheduler.", "response": "def run(self):\n        \"\"\"Executed on startup of application\"\"\"\n        self.api = self.context.get(\"cls\")(self.context)\n        self.context[\"inst\"].append(self)  # Adapters used by strategies\n\n        for call, calldata in self.context.get(\"calls\", {}).items():\n            def loop():\n                \"\"\"Loop on event scheduler, calling calls\"\"\"\n                while not self.stopped.wait(calldata.get(\"delay\", None)):\n                    self.call(call, calldata.get(\"arguments\", None))\n\n            self.thread[call] = Process(target=loop)\n            self.thread[call].start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef call(self, callname, arguments=None):\n        # See if a method override exists\n        action = getattr(self.api, callname, None)\n        if action is None:\n            try:\n                action = self.api.ENDPOINT_OVERRIDES.get(callname, None)\n            except AttributeError:\n                action = callname\n\n        if not callable(action):\n            request = self._generate_request(action, arguments)\n            if action is None:\n                return self._generate_result(\n                    callname, self.api.call(*call_args(callname, arguments)))\n            return self._generate_result(\n                callname, self.api.call(*call_args(action, arguments)))\n\n        request = self._generate_request(callname, arguments)\n        return self._generate_result(callname, action(request))", "response": "Executes on each scheduled iteration"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a request object for delivery to the API", "response": "def _generate_request(self, callname, request):\n        \"\"\"Generate a request object for delivery to the API\"\"\"\n        # Retrieve path from API class\n        schema = self.api.request_schema()\n        schema.context['callname'] = callname\n        return schema.dump(request).data.get(\"payload\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _generate_result(self, callname, result):\n        # Retrieve path from API class\n        schema = self.api.result_schema()\n        schema.context['callname'] = callname\n        self.callback(schema.load(result), self.context)", "response": "Generate a result object for delivery to the context object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef excel_key(index):\n    X = lambda n: ~n and X((n // 26)-1) + chr(65 + (n % 26)) or ''\n    return X(int(index))", "response": "create a key for index by converting index into base - 26 number using A - Z as the characters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a raw crash and processed crash to a crash data structure used by signature generation.", "response": "def convert_to_crash_data(raw_crash, processed_crash):\n    \"\"\"\n    Takes a raw crash and a processed crash (these are Socorro-centric\n    data structures) and converts them to a crash data structure used\n    by signature generation.\n\n    :arg raw_crash: raw crash data from Socorro\n    :arg processed_crash: processed crash data from Socorro\n\n    :returns: crash data structure that conforms to the schema\n\n    \"\"\"\n    # We want to generate fresh signatures, so we remove the \"normalized\" field\n    # from stack frames from the processed crash because this is essentially\n    # cached data from previous processing\n    for thread in glom(processed_crash, 'json_dump.threads', default=[]):\n        for frame in thread.get('frames', []):\n            if 'normalized' in frame:\n                del frame['normalized']\n\n    crash_data = {\n        # JavaStackTrace or None\n        'java_stack_trace': glom(processed_crash, 'java_stack_trace', default=None),\n\n        # int or None\n        'crashing_thread': glom(\n            processed_crash, 'json_dump.crash_info.crashing_thread', default=None\n        ),\n\n        # list of CStackTrace or None\n        'threads': glom(processed_crash, 'json_dump.threads', default=None),\n\n        # int or None\n        'hang_type': glom(processed_crash, 'hang_type', default=None),\n\n        # text or None\n        'os': glom(processed_crash, 'json_dump.system_info.os', default=None),\n\n        # int or None\n        'oom_allocation_size': int_or_none(glom(raw_crash, 'OOMAllocationSize', default=None)),\n\n        # text or None\n        'abort_message': glom(raw_crash, 'AbortMessage', default=None),\n\n        # text or None\n        'mdsw_status_string': glom(processed_crash, 'mdsw_status_string', default=None),\n\n        # text json with \"phase\", \"conditions\" (complicated--see code) or None\n        'async_shutdown_timeout': glom(raw_crash, 'AsyncShutdownTimeout', default=None),\n\n        # text or None\n        'jit_category': glom(processed_crash, 'classifications.jit.category', default=None),\n\n        # text or None\n        'ipc_channel_error': glom(raw_crash, 'ipc_channel_error', default=None),\n\n        # text or None\n        'ipc_message_name': glom(raw_crash, 'IPCMessageName', default=None),\n\n        # text\n        'moz_crash_reason': glom(processed_crash, 'moz_crash_reason', default=None),\n\n        # text; comma-delimited e.g. \"browser,flash1,flash2\"\n        'additional_minidumps': glom(raw_crash, 'additional_minidumps', default=''),\n\n        # pull out the original signature if there was one\n        'original_signature': glom(processed_crash, 'signature', default='')\n    }\n    return crash_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a text and drops all non - printable and non - ASCII characters and also any whitespace characters that aren t space.", "response": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a source file thing and returns the file name", "response": "def parse_source_file(source_file):\n    \"\"\"Parses a source file thing and returns the file name\n\n    Example:\n\n    >>> parse_file('hg:hg.mozilla.org/releases/mozilla-esr52:js/src/jit/MIR.h:755067c14b06')\n    'js/src/jit/MIR.h'\n\n    :arg str source_file: the source file (\"file\") from a stack frame\n\n    :returns: the filename or ``None`` if it couldn't determine one\n\n    \"\"\"\n    if not source_file:\n        return None\n\n    vcsinfo = source_file.split(':')\n    if len(vcsinfo) == 4:\n        # These are repositories or cloud file systems (e.g. hg, git, s3)\n        vcstype, root, vcs_source_file, revision = vcsinfo\n        return vcs_source_file\n\n    if len(vcsinfo) == 2:\n        # These are directories on someone's Windows computer and vcstype is a\n        # file system (e.g. \"c:\", \"d:\", \"f:\")\n        vcstype, vcs_source_file = vcsinfo\n        return vcs_source_file\n\n    if source_file.startswith('/'):\n        # These are directories on OSX or Linux\n        return source_file\n\n    # We have no idea what this is, so return None\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npredicates for whether the open token is in an exception context", "response": "def _is_exception(exceptions, before_token, after_token, token):\n    \"\"\"Predicate for whether the open token is in an exception context\n\n    :arg exceptions: list of strings or None\n    :arg before_token: the text of the function up to the token delimiter\n    :arg after_token: the text of the function after the token delimiter\n    :arg token: the token (only if we're looking at a close delimiter\n\n    :returns: bool\n\n    \"\"\"\n    if not exceptions:\n        return False\n    for s in exceptions:\n        if before_token.endswith(s):\n            return True\n        if s in token:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncollapsing the text between two delimiters in a frame function value returning a new frame with the text collapsed.", "response": "def collapse(\n    function,\n    open_string,\n    close_string,\n    replacement='',\n    exceptions=None,\n):\n    \"\"\"Collapses the text between two delimiters in a frame function value\n\n    This collapses the text between two delimiters and either removes the text\n    altogether or replaces it with a replacement string.\n\n    There are certain contexts in which we might not want to collapse the text\n    between two delimiters. These are denoted as \"exceptions\" and collapse will\n    check for those exception strings occuring before the token to be replaced\n    or inside the token to be replaced.\n\n    Before::\n\n        IPC::ParamTraits<nsTSubstring<char> >::Write(IPC::Message *,nsTSubstring<char> const &)\n               ^        ^ open token\n               exception string occurring before open token\n\n    Inside::\n\n        <rayon_core::job::HeapJob<BODY> as rayon_core::job::Job>::execute\n        ^                              ^^^^ exception string inside token\n        open token\n\n    :arg function: the function value from a frame to collapse tokens in\n    :arg open_string: the open delimiter; e.g. ``(``\n    :arg close_string: the close delimiter; e.g. ``)``\n    :arg replacement: what to replace the token with; e.g. ``<T>``\n    :arg exceptions: list of strings denoting exceptions where we don't want\n        to collapse the token\n\n    :returns: new function string with tokens collapsed\n\n    \"\"\"\n    collapsed = []\n    open_count = 0\n    open_token = []\n\n    for i, char in enumerate(function):\n        if not open_count:\n            if char == open_string and not _is_exception(exceptions, function[:i], function[i + 1:], ''):  # noqa\n                open_count += 1\n                open_token = [char]\n            else:\n                collapsed.append(char)\n\n        else:\n            if char == open_string:\n                open_count += 1\n                open_token.append(char)\n\n            elif char == close_string:\n                open_count -= 1\n                open_token.append(char)\n\n                if open_count == 0:\n                    token = ''.join(open_token)\n                    if _is_exception(exceptions, function[:i], function[i + 1:], token):\n                        collapsed.append(''.join(open_token))\n                    else:\n                        collapsed.append(replacement)\n                    open_token = []\n            else:\n                open_token.append(char)\n\n    if open_count:\n        token = ''.join(open_token)\n        if _is_exception(exceptions, function[:i], function[i + 1:], token):\n            collapsed.append(''.join(open_token))\n        else:\n            collapsed.append(replacement)\n\n    return ''.join(collapsed)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drop_prefix_and_return_type(function):\n    DELIMITERS = {\n        '(': ')',\n        '{': '}',\n        '[': ']',\n        '<': '>',\n        '`': \"'\"\n    }\n    OPEN = DELIMITERS.keys()\n    CLOSE = DELIMITERS.values()\n\n    # The list of tokens accumulated so far\n    tokens = []\n\n    # Keeps track of open delimiters so we can match and close them\n    levels = []\n\n    # The current token we're building\n    current = []\n\n    for i, char in enumerate(function):\n        if char in OPEN:\n            levels.append(char)\n            current.append(char)\n        elif char in CLOSE:\n            if levels and DELIMITERS[levels[-1]] == char:\n                levels.pop()\n                current.append(char)\n            else:\n                # This is an unmatched close.\n                current.append(char)\n        elif levels:\n            current.append(char)\n        elif char == ' ':\n            tokens.append(''.join(current))\n            current = []\n        else:\n            current.append(char)\n\n    if current:\n        tokens.append(''.join(current))\n\n    while len(tokens) > 1 and tokens[-1].startswith(('(', '[clone')):\n        # It's possible for the function signature to have a space between\n        # the function name and the parenthesized arguments or [clone ...]\n        # thing. If that's the case, we join the last two tokens. We keep doing\n        # that until the last token is nice.\n        #\n        # Example:\n        #\n        #     somefunc (int arg1, int arg2)\n        #             ^\n        #     somefunc(int arg1, int arg2) [clone .cold.111]\n        #                                 ^\n        #     somefunc(int arg1, int arg2) [clone .cold.111] [clone .cold.222]\n        #                                 ^                 ^\n        tokens = tokens[:-2] + [' '.join(tokens[-2:])]\n\n    return tokens[-1]", "response": "Takes the function value from a frame and drops the prefix and return type of the function value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaiting for all the connections made and their handshakes to finish.", "response": "def wait_connected(self, conns=None, timeout=None):\n        '''Wait for connections to be made and their handshakes to finish\n\n        :param conns:\n            a single or list of (host, port) tuples with the connections that\n            must be finished before the method will return. defaults to all the\n            peers the :class:`Hub` was instantiated with.\n        :param timeout:\n            maximum time to wait in seconds. with None, there is no timeout.\n        :type timeout: float or None\n\n        :returns:\n            ``True`` if all connections were made, ``False`` one or more\n            failed.\n        '''\n        if timeout:\n            deadline = time.time() + timeout\n        conns = conns or self._started_peers.keys()\n        if not hasattr(conns, \"__iter__\"):\n            conns = [conns]\n\n        for peer_addr in conns:\n            remaining = max(0, deadline - time.time()) if timeout else None\n            if not self._started_peers[peer_addr].wait_connected(remaining):\n                if timeout:\n                    log.warn(\"connect wait timed out after %.2f seconds\" %\n                            timeout)\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclosing all peer connections and stop listening for new ones", "response": "def shutdown(self):\n        'Close all peer connections and stop listening for new ones'\n        log.info(\"shutting down\")\n\n        for peer in self._dispatcher.peers.values():\n            peer.go_down(reconnect=False)\n\n        if self._listener_coro:\n            backend.schedule_exception(\n                    errors._BailOutOfListener(), self._listener_coro)\n        if self._udp_listener_coro:\n            backend.schedule_exception(\n                    errors._BailOutOfListener(), self._udp_listener_coro)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accept_publish(\n            self, service, mask, value, method, handler=None, schedule=False):\n        '''Set a handler for incoming publish messages\n\n        :param service: the incoming message must have this service\n        :type service: anything hash-able\n        :param mask:\n            value to be bitwise-and'ed against the incoming id, the result of\n            which must mask the 'value' param\n        :type mask: int\n        :param value:\n            the result of `routing_id & mask` must match this in order to\n            trigger the handler\n        :type value: int\n        :param method: the method name\n        :type method: string\n        :param handler:\n            the function that will be called on incoming matching messages\n        :type handler: callable\n        :param schedule:\n            whether to schedule a separate greenlet running ``handler`` for\n            each matching message. default ``False``.\n        :type schedule: bool\n\n        :raises:\n            - :class:`ImpossibleSubscription\n              <junction.errors.ImpossibleSubscription>` if there is no routing\n              ID which could possibly match the mask/value pair\n            - :class:`OverlappingSubscription\n              <junction.errors.OverlappingSubscription>` if a prior publish\n              registration that overlaps with this one (there is a\n              service/method/routing id that would match *both* this *and* a\n              previously-made registration).\n        '''\n        # support @hub.accept_publish(serv, mask, val, meth) decorator usage\n        if handler is None:\n            return lambda h: self.accept_publish(\n                    service, mask, value, method, h, schedule)\n\n        log.info(\"accepting publishes%s %r\" % (\n                \" scheduled\" if schedule else \"\",\n                (service, (mask, value), method),))\n\n        self._dispatcher.add_local_subscription(const.MSG_TYPE_PUBLISH,\n                service, mask, value, method, handler, schedule)\n\n        return handler", "response": "Set a handler for incoming publish messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a publish subscription from a service.", "response": "def unsubscribe_publish(self, service, mask, value):\n        '''Remove a publish subscription\n\n        :param service: the service of the subscription to remove\n        :type service: anything hash-able\n        :param mask: the mask of the subscription to remove\n        :type mask: int\n        :param value: the value in the subscription to remove\n        :type value: int\n\n        :returns:\n            a boolean indicating whether the subscription was there (True) and\n            removed, or not (False)\n        '''\n        log.info(\"unsubscribing from publish %r\" % (\n                (service, (mask, value)),))\n        return self._dispatcher.remove_local_subscription(\n                const.MSG_TYPE_PUBLISH, service, mask, value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef publish(self, service, routing_id, method, args=None, kwargs=None,\n            broadcast=False, udp=False):\n        '''Send a 1-way message\n\n        :param service: the service name (the routing top level)\n        :type service: anything hash-able\n        :param int routing_id:\n            the id used for routing within the registered handlers of the\n            service\n        :param string method: the method name to call\n        :param tuple args:\n            The positional arguments to send along with the request. If the\n            first positional argument is a generator object, the publish will\n            be sent in chunks :ref:`(more info) <chunked-messages>`.\n        :param dict kwargs: keyword arguments to send along with the request\n        :param bool broadcast:\n            if ``True``, send to every peer with a matching subscription.\n        :param bool udp: deliver the message over UDP instead of the usual TCP\n\n        :returns: None. use 'rpc' methods for requests with responses.\n\n        :raises:\n            :class:`Unroutable <junction.errors.Unroutable>` if no peers are\n            registered to receive the message\n        '''\n        if udp:\n            func = self._dispatcher.send_publish_udp\n        else:\n            func = self._dispatcher.send_publish\n        if not func(None, service, routing_id, method,\n                args or (), kwargs or {}, singular=not broadcast):\n            raise errors.Unroutable()", "response": "Send a 1 - way message to all peers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the number of peers that would handle a particular publish", "response": "def publish_receiver_count(self, service, routing_id):\n        '''Get the number of peers that would handle a particular publish\n\n        :param service: the service name\n        :type service: anything hash-able\n        :param routing_id: the id used for limiting the service handlers\n        :type routing_id: int\n        '''\n        peers = len(list(self._dispatcher.find_peer_routes(\n            const.MSG_TYPE_PUBLISH, service, routing_id)))\n        if self._dispatcher.locally_handles(const.MSG_TYPE_PUBLISH,\n                service, routing_id):\n            return peers + 1\n        return peers"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef accept_rpc(self, service, mask, value, method,\n            handler=None, schedule=True):\n        '''Set a handler for incoming RPCs\n\n        :param service: the incoming RPC must have this service\n        :type service: anything hash-able\n        :param mask:\n            value to be bitwise-and'ed against the incoming id, the result of\n            which must mask the 'value' param\n        :type mask: int\n        :param value:\n            the result of `routing_id & mask` must match this in order to\n            trigger the handler\n        :type value: int\n        :param method: the method name to trigger handler\n        :type method: string\n        :param handler:\n            the function that will be called on incoming matching RPC requests\n        :type handler: callable\n        :param schedule:\n            whether to schedule a separate greenlet running ``handler`` for\n            each matching message. default ``True``.\n        :type schedule: bool\n\n        :raises:\n            - :class:`ImpossibleSubscription\n              <junction.errors.ImpossibleSubscription>` if there is no routing\n              ID which could possibly match the mask/value pair\n            - :class:`OverlappingSubscription\n              <junction.errors.OverlappingSubscription>` if a prior rpc\n              registration that overlaps with this one (there is a\n              service/method/routing id that would match *both* this *and* a\n              previously-made registration).\n        '''\n        # support @hub.accept_rpc(serv, mask, val, meth) decorator usage\n        if handler is None:\n            return lambda h: self.accept_rpc(\n                    service, mask, value, method, h, schedule)\n\n        log.info(\"accepting RPCs%s %r\" % (\n                \" scheduled\" if schedule else \"\",\n                (service, (mask, value), method),))\n\n        self._dispatcher.add_local_subscription(const.MSG_TYPE_RPC_REQUEST,\n                service, mask, value, method, handler, schedule)\n\n        return handler", "response": "Set a handler for incoming RPCs with a routing id and a method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a rpc subscription :param service: the service of the subscription to remove :type service: anything hash-able :param mask: the mask of the subscription to remove :type mask: int :param value: the value in the subscription to remove :type value: int :param handler: the handler function of the subscription to remove :type handler: callable :returns: a boolean indicating whether the subscription was there (True) and removed, or not (False)", "response": "def unsubscribe_rpc(self, service, mask, value):\n        '''Remove a rpc subscription\n\n        :param service: the service of the subscription to remove\n        :type service: anything hash-able\n        :param mask: the mask of the subscription to remove\n        :type mask: int\n        :param value: the value in the subscription to remove\n        :type value: int\n        :param handler: the handler function of the subscription to remove\n        :type handler: callable\n\n        :returns:\n            a boolean indicating whether the subscription was there (True) and\n            removed, or not (False)\n        '''\n        log.info(\"unsubscribing from RPC %r\" % ((service, (mask, value)),))\n        return self._dispatcher.remove_local_subscription(\n                const.MSG_TYPE_RPC_REQUEST, service, mask, value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_rpc(self, service, routing_id, method, args=None, kwargs=None,\n            broadcast=False):\n        '''Send out an RPC request\n\n        :param service: the service name (the routing top level)\n        :type service: anything hash-able\n        :param routing_id:\n            The id used for routing within the registered handlers of the\n            service.\n        :type routing_id: int\n        :param method: the method name to call\n        :type method: string\n        :param args:\n            The positional arguments to send along with the request. If the\n            first argument is a generator, the request will be sent in chunks\n            :ref:`(more info) <chunked-messages>`.\n        :type args: tuple\n        :param kwargs: keyword arguments to send along with the request\n        :type kwargs: dict\n        :param broadcast:\n            if ``True``, send to every peer with a matching subscription\n        :type broadcast: bool\n\n        :returns:\n            a :class:`RPC <junction.futures.RPC>` object representing the\n            RPC and its future response.\n\n        :raises:\n            :class:`Unroutable <junction.errors.Unroutable>` if no peers are\n            registered to receive the message\n        '''\n        rpc = self._dispatcher.send_rpc(service, routing_id, method,\n                args or (), kwargs or {}, not broadcast)\n\n        if not rpc:\n            raise errors.Unroutable()\n\n        return rpc", "response": "Send out an RPC request to all peers that are subscribed to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rpc(self, service, routing_id, method, args=None, kwargs=None,\n            timeout=None, broadcast=False):\n        '''Send an RPC request and return the corresponding response\n\n        This will block waiting until the response has been received.\n\n        :param service: the service name (the routing top level)\n        :type service: anything hash-able\n        :param routing_id:\n            The id used for routing within the registered handlers of the\n            service.\n        :type routing_id: int\n        :param method: the method name to call\n        :type method: string\n        :param args:\n            The positional arguments to send along with the request. If the\n            first argument is a generator, the request will be sent in chunks\n            :ref:`(more info) <chunked-messages>`.\n        :type args: tuple\n        :param kwargs: keyword arguments to send along with the request\n        :type kwargs: dict\n        :param timeout:\n            maximum time to wait for a response in seconds. with None, there is\n            no timeout.\n        :type timeout: float or None\n        :param broadcast:\n            if ``True``, send to every peer with a matching subscription\n        :type broadcast: bool\n\n        :returns:\n            a list of the objects returned by the RPC's targets. these could be\n            of any serializable type.\n\n        :raises:\n            - :class:`Unroutable <junction.errors.Unroutable>` if no peers are\n              registered to receive the message\n            - :class:`WaitTimeout <junction.errors.WaitTimeout>` if a timeout\n              was provided and it expires\n        '''\n        rpc = self.send_rpc(service, routing_id, method,\n                args or (), kwargs or {}, broadcast)\n        return rpc.get(timeout)", "response": "Send an RPC request and return the corresponding response."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the number of peers that would handle a particular RPC", "response": "def rpc_receiver_count(self, service, routing_id):\n        '''Get the number of peers that would handle a particular RPC\n\n        :param service: the service name\n        :type service: anything hash-able\n        :param routing_id:\n            the id used for narrowing within the service handlers\n        :type routing_id: int\n\n        :returns:\n            the integer number of peers that would receive the described RPC\n        '''\n        peers = len(list(self._dispatcher.find_peer_routes(\n            const.MSG_TYPE_RPC_REQUEST, service, routing_id)))\n        if self._dispatcher.locally_handles(const.MSG_TYPE_RPC_REQUEST,\n                service, routing_id):\n            return peers + 1\n        return peers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self):\n        \"Start up the hub's server, and have it start initiating connections\"\n        log.info(\"starting\")\n\n        self._listener_coro = backend.greenlet(self._listener)\n        self._udp_listener_coro = backend.greenlet(self._udp_listener)\n        backend.schedule(self._listener_coro)\n        backend.schedule(self._udp_listener_coro)\n\n        for addr in self._peers:\n            self.add_peer(addr)", "response": "Start up the hub s server and have it start initiating connections"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a connection to the Hub at a given ( host port ) address", "response": "def add_peer(self, peer_addr):\n        \"Build a connection to the Hub at a given ``(host, port)`` address\"\n        peer = connection.Peer(\n                self._ident, self._dispatcher, peer_addr, backend.Socket())\n        peer.start()\n        self._started_peers[peer_addr] = peer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef peers(self):\n        \"list of the (host, port) pairs of all connected peer Hubs\"\n        return [addr for (addr, peer) in self._dispatcher.peers.items()\n                if peer.up]", "response": "list of the ( host port ) pairs of all connected peer Hubs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(argv=None):\n    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)\n    parser.add_argument(\n        '-v', '--verbose', help='increase output verbosity', action='store_true'\n    )\n    parser.add_argument(\n        '--format', help='specify output format: csv, text (default)'\n    )\n    parser.add_argument(\n        '--different-only', dest='different', action='store_true',\n        help='limit output to just the signatures that changed',\n    )\n    parser.add_argument(\n        'crashids', metavar='crashid', nargs='*', help='crash id to generate signatures for'\n    )\n\n    if argv is None:\n        args = parser.parse_args()\n    else:\n        args = parser.parse_args(argv)\n\n    if args.format == 'csv':\n        outputter = CSVOutput\n    else:\n        outputter = TextOutput\n\n    api_token = os.environ.get('SOCORRO_API_TOKEN', '')\n\n    generator = SignatureGenerator()\n    if args.crashids:\n        crashids_iterable = args.crashids\n    elif not sys.stdin.isatty():\n        # If a script is piping to this script, then isatty() returns False. If\n        # there is no script piping to this script, then isatty() returns True\n        # and if we do list(sys.stdin), it'll block waiting for input.\n        crashids_iterable = list(sys.stdin)\n    else:\n        crashids_iterable = []\n\n    if not crashids_iterable:\n        parser.print_help()\n        return 0\n\n    with outputter() as out:\n        for crash_id in crashids_iterable:\n            crash_id = crash_id.strip()\n\n            resp = fetch('/RawCrash/', crash_id, api_token)\n            if resp.status_code == 404:\n                out.warning('%s: does not exist.' % crash_id)\n                continue\n            if resp.status_code == 429:\n                out.warning('API rate limit reached. %s' % resp.content)\n                # FIXME(willkg): Maybe there's something better we could do here. Like maybe wait a\n                # few minutes.\n                return 1\n            if resp.status_code == 500:\n                out.warning('HTTP 500: %s' % resp.content)\n                continue\n\n            raw_crash = resp.json()\n\n            # If there's an error in the raw crash, then something is wrong--probably with the API\n            # token. So print that out and exit.\n            if 'error' in raw_crash:\n                out.warning('Error fetching raw crash: %s' % raw_crash['error'])\n                return 1\n\n            resp = fetch('/ProcessedCrash/', crash_id, api_token)\n            if resp.status_code == 404:\n                out.warning('%s: does not have processed crash.' % crash_id)\n                continue\n            if resp.status_code == 429:\n                out.warning('API rate limit reached. %s' % resp.content)\n                # FIXME(willkg): Maybe there's something better we could do here. Like maybe wait a\n                # few minutes.\n                return 1\n            if resp.status_code == 500:\n                out.warning('HTTP 500: %s' % resp.content)\n                continue\n\n            processed_crash = resp.json()\n\n            # If there's an error in the processed crash, then something is wrong--probably with the\n            # API token. So print that out and exit.\n            if 'error' in processed_crash:\n                out.warning('Error fetching processed crash: %s' % processed_crash['error'])\n                return 1\n\n            old_signature = processed_crash['signature']\n            crash_data = convert_to_crash_data(raw_crash, processed_crash)\n\n            result = generator.generate(crash_data)\n\n            if not args.different or old_signature != result.signature:\n                out.data(crash_id, old_signature, result, args.verbose)", "response": "This function takes crash data via args and generates a Socorro signature for it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_result(self, return_code, output, service_description='', time_stamp=0, specific_servers=None):\n        '''\n        Send result to the Skinken WS\n        '''\n        if time_stamp == 0:\n            time_stamp = int(time.time())\n\n        if specific_servers == None:\n            specific_servers = self.servers\n        else:\n            specific_servers = set(self.servers).intersection(specific_servers)\n\n        for server in specific_servers:\n            post_data = {}\n            post_data['time_stamp'] = time_stamp\n            post_data['host_name'] = self.servers[server]['custom_fqdn']\n            post_data['service_description'] = service_description\n            post_data['return_code'] = return_code\n            post_data['output'] = output\n\n            if self.servers[server]['availability']:\n                url = '%s://%s:%s%s' % (self.servers[server]['protocol'],\n                                         self.servers[server]['host'],\n                                         self.servers[server]['port'],\n                                         self.servers[server]['uri'])\n\n                auth = (self.servers[server]['username'],\n                        self.servers[server]['password'])\n\n                try:\n                    response = requests.post(url,\n                                             auth=auth,\n                                             headers=self.http_headers,\n                                             verify=self.servers[server]['verify'],\n                                             timeout=self.servers[server]['timeout'],\n                                             data=post_data)\n                    if response.status_code == 400:\n                        LOG.error(\"[ws_shinken][%s]: HTTP status: %s - The content of the WebService call is incorrect\",\n                                      server,\n                                      response.status_code)\n                    elif response.status_code == 401:\n                        LOG.error(\"[ws_shinken][%s]: HTTP status: %s - You must provide an username and password\",\n                                      server,\n                                      response.status_code)\n                    elif response.status_code == 403:\n                        LOG.error(\"[ws_shinken][%s]: HTTP status: %s - The username or password is wrong\",\n                                      server,\n                                      response.status_code)\n                    elif response.status_code != 200:\n                        LOG.error(\"[ws_shinken][%s]: HTTP status: %s\", server, response.status_code)\n                except (requests.ConnectionError, requests.Timeout), error:\n                    self.servers[server]['availability'] = False\n                    LOG.error(error)\n            else:\n                LOG.error(\"[ws_shinken][%s]: Data not sent, server is unavailable\", server)\n\n            if self.servers[server]['availability'] == False and self.servers[server]['cache'] == True:\n                self.servers[server]['csv'].writerow(post_data)\n                LOG.info(\"[ws_shinken][%s]: Data cached\", server)", "response": "Send the result to Skinken WS"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef close_cache(self):\n        '''\n        Close cache of WS Shinken\n        '''\n        # Close all WS_Shinken cache files\n        for server in self.servers:\n            if self.servers[server]['cache'] == True:\n                self.servers[server]['file'].close()", "response": "Close cache of WS Shinken"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare_dir(app, directory, delete=False):\n    logger.info(\"Preparing output directories for jinjaapidoc.\")\n    if os.path.exists(directory):\n        if delete:\n            logger.debug(\"Deleting dir %s\", directory)\n            shutil.rmtree(directory)\n            logger.debug(\"Creating dir %s\", directory)\n            os.mkdir(directory)\n    else:\n        logger.debug(\"Creating %s\", directory)\n        os.mkdir(directory)", "response": "Create apidoc dir and delete contents if delete is True."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef makename(package, module):\n    # Both package and module can be None/empty.\n    assert package or module, \"Specify either package or module\"\n    if package:\n        name = package\n        if module:\n            name += '.' + module\n    else:\n        name = module\n    return name", "response": "Join package and module with a dot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting the content of a file to a directory.", "response": "def write_file(app, name, text, dest, suffix, dryrun, force):\n    \"\"\"Write the output file for module/package <name>.\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param name: the file name without file extension\n    :type name: :class:`str`\n    :param text: the content of the file\n    :type text: :class:`str`\n    :param dest: the output directory\n    :type dest: :class:`str`\n    :param suffix: the file extension\n    :type suffix: :class:`str`\n    :param dryrun: If True, do not create any files, just log the potential location.\n    :type dryrun: :class:`bool`\n    :param force: Overwrite existing files\n    :type force: :class:`bool`\n    :returns: None\n    :raises: None\n    \"\"\"\n    fname = os.path.join(dest, '%s.%s' % (name, suffix))\n    if dryrun:\n        logger.info('Would create file %s.' % fname)\n        return\n    if not force and os.path.isfile(fname):\n        logger.info('File %s already exists, skipping.' % fname)\n    else:\n        logger.info('Creating file %s.' % fname)\n        f = open(fname, 'w')\n        try:\n            f.write(text)\n            relpath = os.path.relpath(fname, start=app.env.srcdir)\n            abspath = os.sep + relpath\n            docpath = app.env.relfn2path(abspath)[0]\n            docpath = docpath.rsplit(os.path.extsep, 1)[0]\n            logger.debug('Adding document %s' % docpath)\n            app.env.found_docs.add(docpath)\n        finally:\n            f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports the given name and return the name obj parent mod_name", "response": "def import_name(app, name):\n    \"\"\"Import the given name and return name, obj, parent, mod_name\n\n    :param name: name to import\n    :type name: str\n    :returns: the imported object or None\n    :rtype: object | None\n    :raises: None\n    \"\"\"\n    try:\n        logger.debug('Importing %r', name)\n        name, obj = autosummary.import_by_name(name)[:2]\n        logger.debug('Imported %s', obj)\n        return obj\n    except ImportError as e:\n        logger.warn(\"Jinjapidoc failed to import %r: %s\", name, e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_members(app, mod, typ, include_public=None):\n    def include_here(x):\n        \"\"\"Return true if the member should be included in mod.\n\n        A member will be included if it is declared in this module or package.\n        If the `jinjaapidoc_include_from_all` option is `True` then the member\n        can also be included if it is listed in `__all__`.\n\n        :param x: The member\n        :type x: A class, exception, or function.\n        :returns: True if the member should be included in mod. False otherwise.\n        :rtype: bool\n        \"\"\"\n        return (x.__module__ == mod.__name__ or (include_from_all and x.__name__ in all_list))\n\n    all_list = getattr(mod, '__all__', [])\n    include_from_all = app.config.jinjaapi_include_from_all\n\n    include_public = include_public or []\n    tests = {'class': lambda x: inspect.isclass(x) and not issubclass(x, BaseException) and include_here(x),\n             'function': lambda x: inspect.isfunction(x) and include_here(x),\n             'exception': lambda x: inspect.isclass(x) and issubclass(x, BaseException) and include_here(x),\n             'data': lambda x: not inspect.ismodule(x) and not inspect.isclass(x) and not inspect.isfunction(x),\n             'members': lambda x: True}\n    items = []\n    for name in dir(mod):\n        i = getattr(mod, name)\n        inspect.ismodule(i)\n\n        if tests.get(typ, lambda x: False)(i):\n            items.append(name)\n    public = [x for x in items\n              if x in include_public or not x.startswith('_')]\n    logger.debug('Got members of %s of type %s: public %s and %s', mod, typ, public, items)\n    return public, items", "response": "Return the members of the given type in the given module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all submodules of the given module", "response": "def _get_submodules(app, module):\n    \"\"\"Get all submodules for the given module/package\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param module: the module to query or module path\n    :type module: module | str\n    :returns: list of module names and boolean whether its a package\n    :rtype: list\n    :raises: TypeError\n    \"\"\"\n    if inspect.ismodule(module):\n        if hasattr(module, '__path__'):\n            p = module.__path__\n        else:\n            return []\n    elif isinstance(module, str):\n        p = module\n    else:\n        raise TypeError(\"Only Module or String accepted. %s given.\" % type(module))\n    logger.debug('Getting submodules of %s', p)\n    submodules = [(name, ispkg) for loader, name, ispkg in pkgutil.iter_modules(p)]\n    logger.debug('Found submodules of %s: %s', module, submodules)\n    return submodules"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all submodules without packages for the given module", "response": "def get_submodules(app, module):\n    \"\"\"Get all submodules without packages for the given module/package\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param module: the module to query or module path\n    :type module: module | str\n    :returns: list of module names excluding packages\n    :rtype: list\n    :raises: TypeError\n    \"\"\"\n    submodules = _get_submodules(app, module)\n    return [name for name, ispkg in submodules if not ispkg]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_subpackages(app, module):\n    submodules = _get_submodules(app, module)\n    return [name for name, ispkg in submodules if ispkg]", "response": "Get all subpackages for the given module"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_context(app, package, module, fullname):\n    var = {'package': package,\n           'module': module,\n           'fullname': fullname}\n    logger.debug('Creating context for: package %s, module %s, fullname %s', package, module, fullname)\n    obj = import_name(app, fullname)\n    if not obj:\n        for k in ('subpkgs', 'submods', 'classes', 'allclasses',\n                  'exceptions', 'allexceptions', 'functions', 'allfunctions',\n                  'data', 'alldata', 'memebers'):\n            var[k] = []\n        return var\n\n    var['subpkgs'] = get_subpackages(app, obj)\n    var['submods'] = get_submodules(app, obj)\n    var['classes'], var['allclasses'] = get_members(app, obj, 'class')\n    var['exceptions'], var['allexceptions'] = get_members(app, obj, 'exception')\n    var['functions'], var['allfunctions'] = get_members(app, obj, 'function')\n    var['data'], var['alldata'] = get_members(app, obj, 'data')\n    var['members'] = get_members(app, obj, 'members')\n    logger.debug('Created context: %s', var)\n    return var", "response": "Return a dict with variables for template rendering"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the text of the file and write it to dest.", "response": "def create_module_file(app, env, package, module, dest, suffix, dryrun, force):\n    \"\"\"Build the text of the file and write the file.\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param env: the jinja environment for the templates\n    :type env: :class:`jinja2.Environment`\n    :param package: the package name\n    :type package: :class:`str`\n    :param module: the module name\n    :type module: :class:`str`\n    :param dest: the output directory\n    :type dest: :class:`str`\n    :param suffix: the file extension\n    :type suffix: :class:`str`\n    :param dryrun: If True, do not create any files, just log the potential location.\n    :type dryrun: :class:`bool`\n    :param force: Overwrite existing files\n    :type force: :class:`bool`\n    :returns: None\n    :raises: None\n    \"\"\"\n    logger.debug('Create module file: package %s, module %s', package, module)\n    template_file = MODULE_TEMPLATE_NAME\n    template = env.get_template(template_file)\n    fn = makename(package, module)\n    var = get_context(app, package, module, fn)\n    var['ispkg'] = False\n    rendered = template.render(var)\n    write_file(app, makename(package, module), rendered, dest, suffix, dryrun, force)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_package_file(app, env, root_package, sub_package, private,\n                        dest, suffix, dryrun, force):\n    \"\"\"Build the text of the file and write the file.\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param env: the jinja environment for the templates\n    :type env: :class:`jinja2.Environment`\n    :param root_package: the parent package\n    :type root_package: :class:`str`\n    :param sub_package: the package name without root\n    :type sub_package: :class:`str`\n    :param private: Include \\\"_private\\\" modules\n    :type private: :class:`bool`\n    :param dest: the output directory\n    :type dest: :class:`str`\n    :param suffix: the file extension\n    :type suffix: :class:`str`\n    :param dryrun: If True, do not create any files, just log the potential location.\n    :type dryrun: :class:`bool`\n    :param force: Overwrite existing files\n    :type force: :class:`bool`\n    :returns: None\n    :raises: None\n    \"\"\"\n    logger.debug('Create package file: rootpackage %s, sub_package %s', root_package, sub_package)\n    template_file = PACKAGE_TEMPLATE_NAME\n    template = env.get_template(template_file)\n    fn = makename(root_package, sub_package)\n    var = get_context(app, root_package, sub_package, fn)\n    var['ispkg'] = True\n    for submod in var['submods']:\n        if shall_skip(app, submod, private):\n            continue\n        create_module_file(app, env, fn, submod, dest, suffix, dryrun, force)\n    rendered = template.render(var)\n    write_file(app, fn, rendered, dest, suffix, dryrun, force)", "response": "Create the text of the file and write it to dest."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef shall_skip(app, module, private):\n    logger.debug('Testing if %s should be skipped.', module)\n    # skip if it has a \"private\" name and this is selected\n    if module != '__init__.py' and module.startswith('_') and \\\n       not private:\n        logger.debug('Skip %s because its either private or __init__.', module)\n        return True\n    logger.debug('Do not skip %s', module)\n    return False", "response": "Check if we should skip this module."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlooks for every file in the directory tree and create the corresponding ReST files. :param app: the sphinx app :type app: :class:`sphinx.application.Sphinx` :param env: the jinja environment :type env: :class:`jinja2.Environment` :param src: the path to the python source files :type src: :class:`str` :param dest: the output directory :type dest: :class:`str` :param excludes: the paths to exclude :type excludes: :class:`list` :param followlinks: follow symbolic links :type followlinks: :class:`bool` :param force: overwrite existing files :type force: :class:`bool` :param dryrun: do not generate files :type dryrun: :class:`bool` :param private: include \"_private\" modules :type private: :class:`bool` :param suffix: the file extension :type suffix: :class:`str`", "response": "def recurse_tree(app, env, src, dest, excludes, followlinks, force, dryrun, private, suffix):\n    \"\"\"Look for every file in the directory tree and create the corresponding\n    ReST files.\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param env: the jinja environment\n    :type env: :class:`jinja2.Environment`\n    :param src: the path to the python source files\n    :type src: :class:`str`\n    :param dest: the output directory\n    :type dest: :class:`str`\n    :param excludes: the paths to exclude\n    :type excludes: :class:`list`\n    :param followlinks: follow symbolic links\n    :type followlinks: :class:`bool`\n    :param force: overwrite existing files\n    :type force: :class:`bool`\n    :param dryrun: do not generate files\n    :type dryrun: :class:`bool`\n    :param private: include \"_private\" modules\n    :type private: :class:`bool`\n    :param suffix: the file extension\n    :type suffix: :class:`str`\n    \"\"\"\n    # check if the base directory is a package and get its name\n    if INITPY in os.listdir(src):\n        root_package = src.split(os.path.sep)[-1]\n    else:\n        # otherwise, the base is a directory with packages\n        root_package = None\n\n    toplevels = []\n    for root, subs, files in walk(src, followlinks=followlinks):\n        # document only Python module files (that aren't excluded)\n        py_files = sorted(f for f in files\n                          if os.path.splitext(f)[1] in PY_SUFFIXES and  # noqa: W504\n                          not is_excluded(os.path.join(root, f), excludes))\n        is_pkg = INITPY in py_files\n        if is_pkg:\n            py_files.remove(INITPY)\n            py_files.insert(0, INITPY)\n        elif root != src:\n            # only accept non-package at toplevel\n            del subs[:]\n            continue\n        # remove hidden ('.') and private ('_') directories, as well as\n        # excluded dirs\n        if private:\n            exclude_prefixes = ('.',)\n        else:\n            exclude_prefixes = ('.', '_')\n        subs[:] = sorted(sub for sub in subs if not sub.startswith(exclude_prefixes) and not\n                         is_excluded(os.path.join(root, sub), excludes))\n        if is_pkg:\n            # we are in a package with something to document\n            if subs or len(py_files) > 1 or not \\\n               shall_skip(app, os.path.join(root, INITPY), private):\n                subpackage = root[len(src):].lstrip(os.path.sep).\\\n                    replace(os.path.sep, '.')\n                create_package_file(app, env, root_package, subpackage,\n                                    private, dest, suffix, dryrun, force)\n                toplevels.append(makename(root_package, subpackage))\n        else:\n            # if we are at the root level, we don't require it to be a package\n            assert root == src and root_package is None\n            for py_file in py_files:\n                if not shall_skip(app, os.path.join(src, py_file), private):\n                    module = os.path.splitext(py_file)[0]\n                    create_module_file(app, env, root_package, module, dest, suffix, dryrun, force)\n                    toplevels.append(module)\n    return toplevels"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_excludes(excludes):\n    return [os.path.normpath(os.path.abspath(exclude)) for exclude in excludes]", "response": "Normalize the excluded directory list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the directory is in the exclude list.", "response": "def is_excluded(root, excludes):\n    \"\"\"Check if the directory is in the exclude list.\n\n    Note: by having trailing slashes, we avoid common prefix issues, like\n          e.g. an exlude \"foo\" also accidentally excluding \"foobar\".\n    \"\"\"\n    root = os.path.normpath(root)\n    for exclude in excludes:\n        if root == exclude:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(app, src, dest, exclude=[], followlinks=False,\n             force=False, dryrun=False, private=False, suffix='rst',\n             template_dirs=None):\n    \"\"\"Generage the rst files\n\n    Raises an :class:`OSError` if the source path is not a directory.\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param src: path to python source files\n    :type src: :class:`str`\n    :param dest: output directory\n    :type dest: :class:`str`\n    :param exclude: list of paths to exclude\n    :type exclude: :class:`list`\n    :param followlinks: follow symbolic links\n    :type followlinks: :class:`bool`\n    :param force: overwrite existing files\n    :type force: :class:`bool`\n    :param dryrun: do not create any files\n    :type dryrun: :class:`bool`\n    :param private: include \\\"_private\\\" modules\n    :type private: :class:`bool`\n    :param suffix: file suffix\n    :type suffix: :class:`str`\n    :param template_dirs: directories to search for user templates\n    :type template_dirs: None | :class:`list`\n    :returns: None\n    :rtype: None\n    :raises: OSError\n    \"\"\"\n    suffix = suffix.strip('.')\n    if not os.path.isdir(src):\n        raise OSError(\"%s is not a directory\" % src)\n    if not os.path.isdir(dest) and not dryrun:\n        os.makedirs(dest)\n    src = os.path.normpath(os.path.abspath(src))\n    exclude = normalize_excludes(exclude)\n    loader = make_loader(template_dirs)\n    env = make_environment(loader)\n    recurse_tree(app, env, src, dest, exclude, followlinks, force, dryrun, private, suffix)", "response": "Generate the rst files for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the config of the app and initiate the generation process :param app: the sphinx app :type app: :class:`sphinx.application.Sphinx` :returns: None :rtype: None :raises: None", "response": "def main(app):\n    \"\"\"Parse the config of the app and initiate the generation process\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :returns: None\n    :rtype: None\n    :raises: None\n    \"\"\"\n    c = app.config\n    src = c.jinjaapi_srcdir\n\n    if not src:\n        return\n\n    suffix = \"rst\"\n\n    out = c.jinjaapi_outputdir or app.env.srcdir\n\n    if c.jinjaapi_addsummarytemplate:\n        tpath = pkg_resources.resource_filename(__package__, AUTOSUMMARYTEMPLATE_DIR)\n        c.templates_path.append(tpath)\n\n    tpath = pkg_resources.resource_filename(__package__, TEMPLATE_DIR)\n    c.templates_path.append(tpath)\n\n    prepare_dir(app, out, not c.jinjaapi_nodelete)\n    generate(app, src, out,\n             exclude=c.jinjaapi_exclude_paths,\n             force=c.jinjaapi_force,\n             followlinks=c.jinjaapi_followlinks,\n             dryrun=c.jinjaapi_dryrun,\n             private=c.jinjaapi_includeprivate,\n             suffix=suffix,\n             template_dirs=c.templates_path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _isclose(obja, objb, rtol=1e-05, atol=1e-08):\n    return abs(obja - objb) <= (atol + rtol * abs(objb))", "response": "Return floating point equality."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining if an object is a real number.", "response": "def _isreal(obj):\n    \"\"\"\n    Determine if an object is a real number.\n\n    Both Python standard data types and Numpy data types are supported.\n\n    :param obj: Object\n    :type  obj: any\n\n    :rtype: boolean\n    \"\"\"\n    # pylint: disable=W0702\n    if (obj is None) or isinstance(obj, bool):\n        return False\n    try:\n        cond = (int(obj) == obj) or (float(obj) == obj)\n    except:\n        return False\n    return cond"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _no_exp(number):\n    if isinstance(number, bool) or (not isinstance(number, (int, float))):\n        raise RuntimeError(\"Argument `number` is not valid\")\n    mant, exp = _to_scientific_tuple(number)\n    if not exp:\n        return str(number)\n    floating_mant = \".\" in mant\n    mant = mant.replace(\".\", \"\")\n    if exp < 0:\n        return \"0.\" + \"0\" * (-exp - 1) + mant\n    if not floating_mant:\n        return mant + \"0\" * exp + (\".0\" if isinstance(number, float) else \"\")\n    lfpart = len(mant) - 1\n    if lfpart < exp:\n        return (mant + \"0\" * (exp - lfpart)).rstrip(\".\")\n    return mant", "response": "r Converts a number to a string without using scientific notation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the greatest common divisor of a list of numbers or a Numpy vector of numbers.", "response": "def gcd(vector):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of a sequence of numbers.\n\n    The sequence can be a list of numbers or a Numpy vector of numbers. The\n    computations are carried out with a precision of 1E-12 if the objects are\n    not `fractions <https://docs.python.org/3/library/fractions.html>`_. When\n    possible it is best to use the `fractions\n    <https://docs.python.org/3/library/fractions.html>`_ data type with the\n    numerator and denominator arguments when computing the GCD of floating\n    point numbers.\n\n    :param vector: Vector of numbers\n    :type  vector: list of numbers or Numpy vector of numbers\n    \"\"\"\n    # pylint: disable=C1801\n    if not len(vector):\n        return None\n    if len(vector) == 1:\n        return vector[0]\n    if len(vector) == 2:\n        return pgcd(vector[0], vector[1])\n    current_gcd = pgcd(vector[0], vector[1])\n    for element in vector[2:]:\n        current_gcd = pgcd(current_gcd, element)\n    return current_gcd"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normalize(value, series, offset=0):\n    if not _isreal(value):\n        raise RuntimeError(\"Argument `value` is not valid\")\n    if not _isreal(offset):\n        raise RuntimeError(\"Argument `offset` is not valid\")\n    try:\n        smin = float(min(series))\n        smax = float(max(series))\n    except:\n        raise RuntimeError(\"Argument `series` is not valid\")\n    value = float(value)\n    offset = float(offset)\n    if not 0 <= offset <= 1:\n        raise ValueError(\"Argument `offset` has to be in the [0.0, 1.0] range\")\n    if not smin <= value <= smax:\n        raise ValueError(\n            \"Argument `value` has to be within the bounds of argument `series`\"\n        )\n    return offset + ((1.0 - offset) * (value - smin) / (smax - smin))", "response": "r Scale a value to the range defined by a series."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the greatest common divisor of two numbers.", "response": "def pgcd(numa, numb):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers.\n\n    :param numa: First number\n    :type  numa: number\n\n    :param numb: Second number\n    :type  numb: number\n\n    :rtype: number\n\n    For example:\n\n        >>> import pmisc, fractions\n        >>> pmisc.pgcd(10, 15)\n        5\n        >>> str(pmisc.pgcd(0.05, 0.02))\n        '0.01'\n        >>> str(pmisc.pgcd(5/3.0, 2/3.0))[:6]\n        '0.3333'\n        >>> pmisc.pgcd(\n        ...     fractions.Fraction(str(5/3.0)),\n        ...     fractions.Fraction(str(2/3.0))\n        ... )\n        Fraction(1, 3)\n        >>> pmisc.pgcd(\n        ...     fractions.Fraction(5, 3),\n        ...     fractions.Fraction(2, 3)\n        ... )\n        Fraction(1, 3)\n    \"\"\"\n    # Test for integers this way to be valid also for Numpy data types without\n    # actually importing (and package depending on) Numpy\n    int_args = (int(numa) == numa) and (int(numb) == numb)\n    fraction_args = isinstance(numa, Fraction) and isinstance(numb, Fraction)\n    # Force conversion for Numpy data types\n    if int_args:\n        numa, numb = int(numa), int(numb)\n    elif not fraction_args:\n        numa, numb = float(numa), float(numb)\n    # Limit floating numbers to a \"sane\" fractional part resolution\n    if (not int_args) and (not fraction_args):\n        numa, numb = (\n            Fraction(_no_exp(numa)).limit_denominator(),\n            Fraction(_no_exp(numb)).limit_denominator(),\n        )\n    while numb:\n        numa, numb = (\n            numb,\n            (numa % numb if int_args else (numa % numb).limit_denominator()),\n        )\n    return int(numa) if int_args else (numa if fraction_args else float(numa))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting to a websocket", "response": "def connect_ws(self, post_connect_callback, channels, reconnect=False):\n        \"\"\"\n        Connect to a websocket\n        :channels:  List of SockChannel instances\n        \"\"\"\n        self.post_conn_cb = post_connect_callback\n        self.channels = channels\n        self.wsendpoint = self.context[\"conf\"][\"endpoints\"].get(\"websocket\")\n\n        # Skip connecting if we don't have any channels to listen to\n        if not channels:\n            return\n\n        # Create socket, connect, setting callbacks along the way\n        self.sock = Socketcluster.socket(self.wsendpoint)\n        self.sock.setBasicListener(self._on_connect, self._on_connect_close,\n                                   self._on_connect_error)\n        self.sock.setAuthenticationListener(self._on_set_auth, self._on_auth)\n        self.sock.setreconnection(reconnect)\n        self.sock.connect()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wscall(self, method, query=None, callback=None):\n        if callback is None:\n            self.sock.emit(method, query)\n        else:\n            self.sock.emitack(method, query, callback)", "response": "Submit a request on the websocket"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects the provided channels to the socket.", "response": "def connect_channels(self, channels):\n        \"\"\"Connect the provided channels\"\"\"\n        self.log.info(f\"Connecting to channels...\")\n        for chan in channels:\n            chan.connect(self.sock)\n            self.log.info(f\"\\t{chan.channel}\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when the client wants to set the auth token from the websocket", "response": "def _on_set_auth(self, sock, token):\n        \"\"\"Set Auth request received from websocket\"\"\"\n        self.log.info(f\"Token received: {token}\")\n        sock.setAuthtoken(token)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _on_auth(self, sock, authenticated):  # pylint: disable=unused-argument\n        def ack(eventname, error, data):  # pylint: disable=unused-argument\n            \"\"\"Ack\"\"\"\n            if error:\n                self.log.error(f\"\"\"OnAuth: {error}\"\"\")\n            else:\n                self.connect_channels(self.channels)\n                self.post_conn_cb()\n\n        sock.emitack(\"auth\", self.creds, ack)", "response": "Called when the client is listening and the client is authenticated."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _on_connect_error(self, sock, err):  # pylint: disable=unused-argument\n        if isinstance(err, SystemExit):\n            self.log.error(f\"Shutting down websocket connection\")\n        else:\n            self.log.error(f\"Websocket error: {err}\")", "response": "Called when a websocket connection error occurs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self, sock):\n        def cbwrap(*args, **kwargs):\n            \"\"\"Callback wrapper; passes in response_type\"\"\"\n            self.callback(self.response_type, *args, **kwargs)\n\n        self.sock = sock\n        self.sock.subscribe(self.channel)\n        self.sock.onchannel(self.channel, cbwrap)", "response": "Attach a given socket to a channel"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_cmd(cmd, input=None, timeout=30, max_try=3, num_try=1):\n    '''Run command `cmd`.\n\n    It's like that, and that's the way it is.\n    '''\n    if type(cmd) == str:\n        cmd = cmd.split()\n    process = subprocess.Popen(cmd,\n                               stdin=open('/dev/null', 'r'),\n                               stdout=subprocess.PIPE,\n                               stderr=subprocess.PIPE)\n    communicate_has_timeout = func_has_arg(func=process.communicate,\n                                           arg='timeout')\n    exception = Exception\n    if communicate_has_timeout:\n        exception = subprocess.TimeoutExpired  # python 3.x\n    stdout = stderr = b''\n    exitcode = None\n    try:\n        if communicate_has_timeout:\n            # python 3.x\n            stdout, stderr = process.communicate(input, timeout)\n            exitcode = process.wait()\n        else:\n            # python 2.x\n            if timeout is None:\n                stdout, stderr = process.communicate(input)\n                exitcode = process.wait()\n            else:\n                # thread-recipe: https://stackoverflow.com/a/4825933\n                def target():\n                    # closure-recipe: https://stackoverflow.com/a/23558809\n                    target.out, target.err = process.communicate(input)\n                import threading\n                thread = threading.Thread(target=target)\n                thread.start()\n                thread.join(timeout)\n                if thread.is_alive():\n                    process.terminate()\n                    thread.join()\n                    exitcode = None\n                else:\n                    exitcode = process.wait()\n                stdout = target.out\n                stderr = target.err\n    except exception:\n        if num_try < max_try:\n            return run_cmd(cmd, input, timeout, max_try, num_try+1)\n        else:\n            return CmdResult(exitcode, stdout, stderr, cmd, input)\n    return CmdResult(exitcode, stdout, stderr, cmd, input)", "response": "Run command `cmd`.\n\n    It's like that, and that's the way it is."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pop_first_arg(argv):\n    for arg in argv:\n        if not arg.startswith('-'):\n            argv.remove(arg)\n            return (arg, argv)\n\n    return (None, argv)", "response": "pop first positional arg from the list of arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_options(options, parser):\n    if not options.get('release_environment', None):\n        print(\"release environment is required\")\n        parser.print_help()\n        return os.EX_USAGE\n\n    return 0", "response": "check options requirements print and return exit value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites all needed state info to filesystem", "response": "def write(self):\n        \"\"\" write all needed state info to filesystem \"\"\"\n        dumped = self._fax.codec.dump(self.__state, open(self.state_file, 'w'))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef package_config(path, template='__config__.ini.TEMPLATE', config_name='__config__.ini', **params):\r\n    config_fns = []\r\n    template_fns = rglob(path, template)\r\n    for template_fn in template_fns:\r\n        config_template = ConfigTemplate(fn=template_fn)\r\n        config = config_template.render(\r\n            fn=os.path.join(os.path.dirname(template_fn), config_name), \r\n            prompt=True, path=path, **params)\r\n        config.write()\r\n        config_fns.append(config.fn)\r\n        log.info('wrote %r' % config)\r\n    return config_fns", "response": "package the config file at the given path with a config template and file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting the contents of this config to fn or its __filename__.", "response": "def write(self, fn=None, sorted=False, wait=0):\r\n        \"\"\"write the contents of this config to fn or its __filename__.\r\n        \"\"\"\r\n        config = ConfigParser(interpolation=None)\r\n        if sorted==True: keys.sort()\r\n        for key in self.__dict__.get('ordered_keys') or self.keys():\r\n            config[key] = {}\r\n            ks = self[key].keys()\r\n            if sorted==True: ks.sort()\r\n            for k in ks:\r\n                if type(self[key][k])==list and self.__join_list__ is not None:\r\n                    config[key][k] = self.__join_list__.join([v for v in self[key][k] if v!=''])\r\n                else:\r\n                    config[key][k] = str(self[key][k])\r\n        fn = fn or self.__dict__.get('__filename__')\r\n        # use advisory locking on this file\r\n        i = 0\r\n        while os.path.exists(fn+'.LOCK') and i < wait:\r\n            i += 1\r\n            time.sleep(1)\r\n        if os.path.exists(fn+'.LOCK'):\r\n            raise FileExistsError(fn + ' is locked for writing')\r\n        else:\r\n            with open(fn+'.LOCK', 'w') as lf:\r\n                lf.write(time.strftime(\"%Y-%m-%d %H:%M:%S %Z\"))\r\n            with open(fn, 'w') as f:\r\n                config.write(f)\r\n            os.remove(fn+'.LOCK')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expected_param_keys(self):\r\n        expected_keys = []\r\n        r = re.compile('%\\(([^\\)]+)\\)s')\r\n        for block in self.keys():\r\n            for key in self[block].keys():\r\n                s = self[block][key]\r\n                if type(s)!=str: continue\r\n                md = re.search(r, s)\r\n                while md is not None:\r\n                    k = md.group(1)\r\n                    if k not in expected_keys:\r\n                        expected_keys.append(k)\r\n                    s = s[md.span()[1]:]\r\n                    md = re.search(r, s)\r\n        return expected_keys", "response": "returns a list of params that this ConfigTemplate expects to receive"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render(self, fn=None, prompt=False, **params):\r\n        from getpass import getpass\r\n        expected_keys = self.expected_param_keys()\r\n        compiled_params = Dict(**params)\r\n        for key in expected_keys:\r\n            if key not in compiled_params.keys():\r\n                if prompt==True:\r\n                    if key=='password':\r\n                        compiled_params[key] = getpass(\"%s: \" % key)\r\n                    else:\r\n                        compiled_params[key] = input(\"%s: \" % key)\r\n                        if 'path' in key:\r\n                            compiled_params[key] = compiled_params[key].replace('\\\\','')\r\n                else:\r\n                    compiled_params[key] = \"%%(%s)s\" % key\r\n\r\n        config = ConfigTemplate(fn=fn, **self)\r\n        config.__dict__['ordered_keys'] = self.__dict__.get('ordered_keys')\r\n        for block in config.keys():\r\n            for key in config[block].keys():\r\n                if type(config[block][key])==str:\r\n                    config[block][key] = config[block][key] % compiled_params\r\n        return config", "response": "Returns a Config object with the given params formatted via str. format"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a crash id pulls down data from Socorro generates signature data", "response": "def main():\n    \"\"\"Takes a crash id, pulls down data from Socorro, generates signature data\"\"\"\n    parser = argparse.ArgumentParser(\n        formatter_class=WrappedTextHelpFormatter,\n        description=DESCRIPTION\n    )\n    parser.add_argument(\n        '-v', '--verbose', help='increase output verbosity', action='store_true'\n    )\n    parser.add_argument(\n        'crashid', help='crash id to generate signatures for'\n    )\n\n    args = parser.parse_args()\n\n    api_token = os.environ.get('SOCORRO_API_TOKEN', '')\n\n    crash_id = args.crashid.strip()\n\n    resp = fetch('/RawCrash/', crash_id, api_token)\n    if resp.status_code == 404:\n        printerr('%s: does not exist.' % crash_id)\n        return 1\n    if resp.status_code == 429:\n        printerr('API rate limit reached. %s' % resp.content)\n        # FIXME(willkg): Maybe there's something better we could do here. Like maybe wait a\n        # few minutes.\n        return 1\n    if resp.status_code == 500:\n        printerr('HTTP 500: %s' % resp.content)\n        return 1\n\n    raw_crash = resp.json()\n\n    # If there's an error in the raw crash, then something is wrong--probably with the API\n    # token. So print that out and exit.\n    if 'error' in raw_crash:\n        print('Error fetching raw crash: %s' % raw_crash['error'], file=sys.stderr)\n        return 1\n\n    resp = fetch('/ProcessedCrash/', crash_id, api_token)\n    if resp.status_code == 404:\n        printerr('%s: does not have processed crash.' % crash_id)\n        return 1\n    if resp.status_code == 429:\n        printerr('API rate limit reached. %s' % resp.content)\n        # FIXME(willkg): Maybe there's something better we could do here. Like maybe wait a\n        # few minutes.\n        return 1\n    if resp.status_code == 500:\n        printerr('HTTP 500: %s' % resp.content)\n        return 1\n\n    processed_crash = resp.json()\n\n    # If there's an error in the processed crash, then something is wrong--probably with the\n    # API token. So print that out and exit.\n    if 'error' in processed_crash:\n        printerr('Error fetching processed crash: %s' % processed_crash['error'])\n        return 1\n\n    crash_data = convert_to_crash_data(raw_crash, processed_crash)\n\n    print(json.dumps(crash_data, indent=2))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap text like HelpFormatter but doesn t squash lines.", "response": "def _fill_text(self, text, width, indent):\n        \"\"\"Wraps text like HelpFormatter, but doesn't squash lines\n\n        This makes it easier to do lists and paragraphs.\n\n        \"\"\"\n        parts = text.split('\\n\\n')\n        for i, part in enumerate(parts):\n            # Check to see if it's a bulleted list--if so, then fill each line\n            if part.startswith('* '):\n                subparts = part.split('\\n')\n                for j, subpart in enumerate(subparts):\n                    subparts[j] = super(WrappedTextHelpFormatter, self)._fill_text(\n                        subpart, width, indent\n                    )\n                parts[i] = '\\n'.join(subparts)\n            else:\n                parts[i] = super(WrappedTextHelpFormatter, self)._fill_text(part, width, indent)\n\n        return '\\n\\n'.join(parts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_api_services_by_name(self):\n        if not self.services_by_name:\n            self.services_by_name = dict({s.get('name'): s for s in self.conf\n                                          .get(\"api\")\n                                          .get(\"services\")})\n        return self.services_by_name", "response": "Return a dict of services by name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the API endpoints for the given API name", "response": "def get_api_endpoints(self, apiname):\n        \"\"\"Returns the API endpoints\"\"\"\n        try:\n            return self.services_by_name\\\n                    .get(apiname)\\\n                    .get(\"endpoints\")\\\n                    .copy()\n        except AttributeError:\n            raise Exception(f\"Couldn't find the API endpoints\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the websocket subscriptions for the given application", "response": "def get_ws_subscriptions(self, apiname):\n        \"\"\"Returns the websocket subscriptions\"\"\"\n        try:\n            return self.services_by_name\\\n                    .get(apiname)\\\n                    .get(\"subscriptions\")\\\n                    .copy()\n        except AttributeError:\n            raise Exception(f\"Couldn't find the websocket subscriptions\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the API configuration", "response": "def get_api(self, name=None):\n        \"\"\"Returns the API configuration\"\"\"\n        if name is None:\n            try:\n                return self.conf.get(\"api\").copy()\n            except:  # NOQA\n                raise Exception(f\"Couldn't find the API configuration\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the specific API service configuration definition", "response": "def get_api_service(self, name=None):\n        \"\"\"Returns the specific service config definition\"\"\"\n        try:\n            svc = self.services_by_name.get(name, None)\n            if svc is None:\n                raise ValueError(f\"Couldn't find the API service configuration\")\n            return svc\n        except:  # NOQA\n            raise Exception(f\"Failed to retrieve the API service configuration\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ex_type_str(exobj):\n    regexp = re.compile(r\"<(?:\\bclass\\b|\\btype\\b)\\s+'?([\\w|\\.]+)'?>\")\n    exc_type = str(exobj)\n    if regexp.match(exc_type):\n        exc_type = regexp.match(exc_type).groups()[0]\n        exc_type = exc_type[11:] if exc_type.startswith(\"exceptions.\") else exc_type\n    if \".\" in exc_type:\n        exc_type = exc_type.split(\".\")[-1]\n    return exc_type", "response": "Return a string corresponding to the exception type."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts unicode to ASCII.", "response": "def _unicode_to_ascii(obj):  # pragma: no cover\n    \"\"\"Convert to ASCII.\"\"\"\n    # pylint: disable=E0602,R1717\n    if isinstance(obj, dict):\n        return dict(\n            [\n                (_unicode_to_ascii(key), _unicode_to_ascii(value))\n                for key, value in obj.items()\n            ]\n        )\n    if isinstance(obj, list):\n        return [_unicode_to_ascii(element) for element in obj]\n    if isinstance(obj, unicode):\n        return obj.encode(\"utf-8\")\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends results to specific servers", "response": "def send_result(self, return_code, output, service_description='', specific_servers=None):\n        '''\n        Send results\n        '''\n        if specific_servers == None:\n            specific_servers = self.servers\n        else:\n            specific_servers = set(self.servers).intersection(specific_servers)\n\n        for server in specific_servers:\n            if self.servers[server]['availability']:\n                try:\n                    self.servers[server]['notifier'].svc_result(self.servers[server]['custom_fqdn'],\n                                                                service_description,\n                                                                int(return_code),\n                                                                str(output))\n                    LOG.info(\"[nsca][%s][%s]: Data sent\", service_description, self.servers[server]['host'])\n                except (socket.gaierror, socket.error), error:\n                    self.servers[server]['availability'] = False\n                    LOG.error(\"[nsca][%s][%s]: %s\", service_description, self.servers[server]['host'], error[1])\n            else:\n                LOG.error(\"[nsca][%s][%s]: Data not sent, server is unavailable\", service_description, self.servers[server]['host'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_remote_executors(hub_ip, port = 4444):\r\n        ''' Get remote hosts from Selenium Grid Hub Console\r\n        @param hub_ip: hub ip of selenium grid hub\r\n        @param port: hub port of selenium grid hub\r\n        '''\r\n        resp = requests.get(\"http://%s:%s/grid/console\" %(hub_ip, port))\r\n        \r\n        remote_hosts = ()\r\n        if resp.status_code == 200:\r\n            remote_hosts = re.findall(\"remoteHost: ([\\w/\\.:]+)\",resp.text)\r\n        return [host + \"/wd/hub\" for host in remote_hosts]", "response": "Get remote hosts from Selenium Grid Hub Console\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_remote_driver(executor, capabilities):\r\n        ''' Generate remote drivers with desired capabilities(self.__caps) and command_executor\r\n        @param executor: command executor for selenium remote driver\r\n        @param capabilities: A dictionary of capabilities to request when starting the browser session.\r\n        @return: remote driver\r\n        '''        \r\n        # selenium requires browser's driver and PATH env. Firefox's driver is required for selenium3.0            \r\n        firefox_profile = capabilities.pop(\"firefox_profile\",None)            \r\n        return webdriver.Remote(executor, desired_capabilities=capabilities, browser_profile = firefox_profile)", "response": "Generate remote driver with desired capabilities and command executor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gen_local_driver(browser, capabilities):\r\n        ''' Generate localhost drivers with desired capabilities(self.__caps)\r\n        @param browser:  firefox or chrome\r\n        @param capabilities:  A dictionary of capabilities to request when starting the browser session.\r\n        @return:  localhost driver\r\n        '''\r\n        if browser == \"firefox\":\r\n            fp = capabilities.pop(\"firefox_profile\",None)\r\n            return webdriver.Firefox(desired_capabilities =capabilities, firefox_profile=fp)\r\n                   \r\n        elif browser == \"chrome\":            \r\n            return webdriver.Chrome(desired_capabilities=capabilities)\r\n        \r\n        else:\r\n            raise TypeError(\"Unsupport browser {}\".format(browser))", "response": "Generate localhost drivers with desired capabilities."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _production(self):\n        return self._nuclear + self._diesel + self._gas + self._wind + self._combined + self._vapor + self._solar + self._hydraulic + self._carbon + self._waste +  self._other", "response": "Calculate total energy production. Not rounded"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _links(self):\n        total = 0.0\n        for value in self.link.values():\n            total += value\n        return total", "response": "Calculate total energy production. Not Rounded"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nasks a yes or no question via raw_input and return their answer.", "response": "def query_yes_no(question, default=\"yes\"):\n    \"\"\"Ask a yes/no question via raw_input() and return their answer.\n    \"question\" is a string that is presented to the user.\n    \"default\" is the presumed answer if the user just hits <Enter>.\n        It must be \"yes\" (the default), \"no\" or None (meaning\n        an answer is required of the user).\n    The \"answer\" return value is True for \"yes\" or False for \"no\".\n    \"\"\"\n    valid = {\"yes\": True, \"y\": True, \"ye\": True,\n             \"no\": False, \"n\": False}\n    if default is None:\n        prompt = \" [y/n] \"\n    elif default == \"yes\":\n        prompt = \" [Y/n] \"\n    elif default == \"no\":\n        prompt = \" [y/N] \"\n    else:\n        raise ValueError(\"invalid default answer: '%s'\" % default)\n\n    while True:\n        print(question + prompt)\n        choice = input().lower()\n        if default is not None and choice == '':\n            return valid[default]\n        elif choice in valid:\n            return valid[choice]\n        else:\n            print(\"Please respond with 'yes' or 'no' (or 'y' or 'n').\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wall_of_name(self):\n        '''\n        Appends identifiers for the different databases (such as Entrez id's)\n        and returns them. Uses the CrossRef class below.\n        '''\n        names = []\n        if self.standard_name:\n            names.append(self.standard_name)\n        if self.systematic_name:\n            names.append(self.systematic_name)\n        names.extend([xref.xrid for xref in self.crossref_set.all()])\n        for i in range(len(names)):\n            names[i] = re.sub(nonalpha, '', names[i])\n\n        names_string = ' '.join(names)\n        if self.standard_name:\n            names_string += ' ' + re.sub(num, '', self.standard_name)\n        return names_string", "response": "Returns a string representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noverrides save method to make sure that standard_name and systematic_name aren t empty.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Override save() method to make sure that standard_name and\n        systematic_name won't be null or empty, or consist of only space\n        characters (such as space, tab, new line, etc).\n        \"\"\"\n        empty_std_name = False\n        if not self.standard_name or self.standard_name.isspace():\n            empty_std_name = True\n\n        empty_sys_name = False\n        if not self.systematic_name or self.systematic_name.isspace():\n            empty_sys_name = True\n\n        if empty_std_name and empty_sys_name:\n            raise ValueError(\n                \"Both standard_name and systematic_name are empty\")\n\n        super(Gene, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextending save method to check that the database name is not left blank.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Extends save() method of Django models to check that the database name\n        is not left blank.\n        Note: 'blank=False' is only checked at a form-validation-stage. A test\n        using Fixtureless that tries to randomly create a CrossRefDB with an\n        empty string name would unintentionally break the test.\n        \"\"\"\n        if self.name == '':\n            raise FieldError\n        else:\n            return super(CrossRefDB, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes a L{StaticProducer} that will produce the body of this response. This method will also set the response code and Content-* headers. @param request: The L{Request} object. @param fileForReading: The file object containing the resource. @return: A L{StaticProducer}. Calling C{.start()} on this will begin producing the response.", "response": "def makeProducer(self, request, fileForReading):\n        \"\"\"\n        Make a L{StaticProducer} that will produce the body of this response.\n\n        This method will also set the response code and Content-* headers.\n\n        @param request: The L{Request} object.\n        @param fileForReading: The file object containing the resource.\n        @return: A L{StaticProducer}.  Calling C{.start()} on this will begin\n            producing the response.\n        \"\"\"\n        byteRange = request.getHeader(b'range')\n        if byteRange is None or not self.getFileSize():\n            self._setContentHeaders(request)\n            request.setResponseCode(http.OK)\n            return NoRangeStaticProducer(request, fileForReading)\n        try:\n            parsedRanges = self._parseRangeHeader(byteRange)\n        except ValueError:\n            logger.warning(\"Ignoring malformed Range header %r\" % (byteRange,))\n            self._setContentHeaders(request)\n            request.setResponseCode(http.OK)\n            return NoRangeStaticProducer(request, fileForReading)\n\n        if len(parsedRanges) == 1:\n            offset, size = self._doSingleRangeRequest(\n                request, parsedRanges[0])\n            self._setContentHeaders(request, size)\n            return SingleRangeStaticProducer(\n                request, fileForReading, offset, size)\n        else:\n            rangeInfo = self._doMultipleRangeRequest(request, parsedRanges)\n            return MultipleRangeStaticProducer(\n                request, fileForReading, rangeInfo)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_GET(self, request):\n        request.setHeader(b'accept-ranges', b'bytes')\n\n        producer = self.makeProducer(request, self.fileObject)\n\n        if request.method == b'HEAD':\n            return b''\n\n        def done(ign):\n            producer.stopProducing()\n\n        request.notifyFinish().addCallbacks(done, done)\n        producer.start()\n        # and make sure the connection doesn't get closed\n        return server.NOT_DONE_YET", "response": "Render a GET request."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nimplements the interface for the adapter object", "response": "def interface(self, context):\n        \"\"\"Implement the interface for the adapter object\"\"\"\n        self.context = context\n        self.callback = self.context.get(\"callback\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef shutdown(self):\n        self.stopped.set()\n\n        if hasattr(self.api, \"shutdown\"):\n            self.api.shutdown()\n\n        for thread in self.thread.values():\n            thread.join()", "response": "Executed on shutdown of application"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _element(cls):\r\n        '''   find the element with controls '''\r\n        if not cls.__is_selector():\r\n            raise Exception(\"Invalid selector[%s].\" %cls.__control[\"by\"])\r\n        \r\n        driver = Web.driver\r\n        try:            \r\n            elements = WebDriverWait(driver, cls.__control[\"timeout\"]).until(lambda driver: getattr(driver,\"find_elements\")(cls.__control[\"by\"], cls.__control[\"value\"]))\r\n        except:                        \r\n            raise Exception(\"Timeout at %d seconds.Element(%s) not found.\" %(cls.__control[\"timeout\"],cls.__control[\"by\"]))\r\n        \r\n        if len(elements) < cls.__control[\"index\"] + 1:                    \r\n            raise Exception(\"Element [%s]: Element Index Issue! There are [%s] Elements! Index=[%s]\" % (cls.__name__, len(elements), cls.__control[\"index\"]))\r\n        \r\n        if len(elements) > 1:              \r\n            print(\"Element [%s]: There are [%d] elements, choosed index=%d\" %(cls.__name__,len(elements),cls.__control[\"index\"]))\r\n        \r\n        elm = elements[cls.__control[\"index\"]]\r\n        cls.__control[\"index\"] = 0        \r\n        return elm", "response": "Returns the first element with controls"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the elements with controls", "response": "def _elements(cls):\r\n        '''   find the elements with controls '''\r\n        if not cls.__is_selector():\r\n            raise Exception(\"Invalid selector[%s].\" %cls.__control[\"by\"])\r\n        \r\n        driver = Web.driver\r\n        try:            \r\n            elements = WebDriverWait(driver, cls.__control[\"timeout\"]).until(lambda driver: getattr(driver,\"find_elements\")(cls.__control[\"by\"], cls.__control[\"value\"]))\r\n        except:            \r\n            raise Exception(\"Timeout at %d seconds.Element(%s) not found.\" %(cls.__control[\"timeout\"],cls.__control[\"by\"]))\r\n            \r\n        return elements"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef DyStrData(cls, name, regx, index = 0):\r\n        ''' set dynamic value from the string data of response  \r\n        @param name: glob parameter name\r\n        @param regx: re._pattern_type\r\n            e.g.\r\n            DyStrData(\"a\",re.compile('123'))\r\n        '''\r\n        text = Web.PageSource()\r\n        if not text:\r\n            return\r\n        if not isinstance(regx, re._pattern_type):\r\n            raise Exception(\"DyStrData need the arg which have compiled the regular expression.\")\r\n            \r\n        values = regx.findall(text)\r\n        result = \"\"\r\n        if len(values)>index:\r\n            result = values[index]        \r\n        cls.glob.update({name:result})", "response": "set dynamic value from the string data of response  \r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets dynamic value from the json data of response", "response": "def DyJsonData(cls,name, sequence):\r\n        ''' set dynamic value from the json data of response\r\n        @note: \u83b7\u53d6innerHTML json\u7684\u6570\u636e \u5982\uff0c   <html><body>{  \"code\": 1,\"desc\": \"\u6210\u529f\"}</body></html>\r\n        @param name: glob parameter name\r\n        @param sequence: sequence for the json\r\n            e.g.\r\n            result={\"a\":1,\r\n               \"b\":[1,2,3,4],\r\n               \"c\":{\"d\":5,\"e\":6},\r\n               \"f\":{\"g\":[7,8,9]},\r\n               \"h\":[{\"i\":10,\"j\":11},{\"k\":12}]\r\n               }\r\n            \r\n            sequence1 =\"a\" # -> 1\r\n            sequence2 =\"b.3\" # -> 4\r\n            sequence3 = \"f.g.2\" # -> 9\r\n            sequence4 = \"h.0.j\" # -> 11\r\n        '''\r\n        \r\n        cls.SetControl(by = \"tag name\", value = \"body\")        \r\n        json_body  = cls._element().get_attribute('innerHTML')\r\n                \r\n        if not json_body:\r\n            return\r\n                \r\n        resp = json.loads(json_body)                    \r\n        sequence = [_parse_string_value(i) for i in sequence.split('.')]    \r\n        for i in sequence:\r\n            try:\r\n                if isinstance(i, int):\r\n                    resp = resp[i]   \r\n                else:\r\n                    resp = resp.get(i)\r\n            except:            \r\n                cls.glob.update({name:None})\r\n                return        \r\n        cls.glob.update({name:resp})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nverifying that the URL is the same as the current URL.", "response": "def VerifyURL(cls, url):\r\n        \"\"\" \u83b7\u53d6\u5f53\u524d\u9875\u9762\u7684url \"\"\"\r\n          \r\n        if Web.driver.current_url == url:\r\n            return True\r\n        else:\r\n            print(\"VerifyURL: %s\" % Web.driver.current_url)\r\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nselect a specific entry in the list.", "response": "def SelectByIndex(cls, index):\r\n        ''' \u901a\u8fc7\u7d22\u5f15\uff0c\u9009\u62e9\u4e0b\u62c9\u6846\u9009\u9879\uff0c\r\n        @param index: \u4e0b\u62c9\u6846  \u7d22\u5f15\r\n        '''\r\n        try:\r\n            Select(cls._element()).select_by_index(int(index))\r\n        except:\r\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef DeSelectByIndex(cls, index):\r\n        ''' \u901a\u8fc7\u7d22\u5f15\uff0c\u53d6\u6d88\u9009\u62e9\u4e0b\u62c9\u6846\u9009\u9879\uff0c\r\n        @param index: \u4e0b\u62c9\u6846  \u7d22\u5f15\r\n        '''\r\n        try:\r\n            Select(cls._element()).deselect_by_index(int(index))\r\n        except:\r\n            return False", "response": "De - selects the object by index."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Click(cls):\r\n        ''' \u5de6\u952e \u70b9\u51fb 1\u6b21   '''\r\n        \r\n        element= cls._element()        \r\n        action = ActionChains(Web.driver)\r\n        action.click(element)\r\n        action.perform()", "response": "1. 0. 0 \u6b21  "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef DoubleClick(cls):\r\n        ''' \u5de6\u952e\u70b9\u51fb2\u6b21 '''\r\n        \r\n        element = cls._element()        \r\n        action = ActionChains(Web.driver)\r\n        action.double_click(element)\r\n        action.perform()", "response": "Double Click \u51fb 2\u6b21"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenhance click on the element.", "response": "def EnhancedClick(cls):\r\n        '''\r\n        Description:\r\n            Sometimes, one click on the element doesn't work. So wait more time, then click again and again.\r\n        Risk:\r\n            It may operate more than one click operations.\r\n        '''\r\n        \r\n        element = cls._element()\r\n        for _ in range(3):\r\n            action = ActionChains(Web.driver)\r\n            action.move_to_element(element)\r\n            action.perform()           \r\n            time.sleep(0.5)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Focus(cls):\r\n        \r\n        element = cls._element()        \r\n#         element.send_keys(Keys.NULL)        \r\n        action = ActionChains(Web.driver)\r\n        action.send_keys_to_element(element, Keys.NULL)\r\n        action.perform()", "response": "Focuses the current page."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Upload(cls, filename):\r\n        raise Exception(\"to do\")\r\n    \r\n        TOOLS_PATH = \"\"\r\n        RESOURCE_PATH = \"\"\r\n        tool_4path = os.path.join(TOOLS_PATH, \"upload.exe\")        \r\n        file_4path = os.path.join(RESOURCE_PATH, filename)\r\n        #file_4path.decode('utf-8').encode('gbk')\r\n        \r\n        if os.path.isfile(file_4path):\r\n            cls.Click()\r\n            os.system(tool_4path + ' ' + file_4path)\r\n        else:\r\n            raise Exception('%s is not exists' % file_4path)", "response": "Upload a file to the named user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(xCqNck7t, **kwargs):\r\n        def dict_list_val(inlist):\r\n            l = []\r\n            for i in inlist:\r\n                if type(i)==dict:\r\n                    l.append(Dict(**i))\r\n                elif type(i)==list:\r\n                    l.append(make_list(i))\r\n                elif type(i)==bytes:\r\n                    l.append(i.decode('UTF-8'))\r\n                else:\r\n                    l.append(i)\r\n            return l\r\n        for k in list(kwargs.keys()):\r\n            if type(kwargs[k])==dict:\r\n                xCqNck7t[k] = Dict(**kwargs[k])\r\n            elif type(kwargs[k])==list:\r\n                xCqNck7t[k] = dict_list_val(kwargs[k])\r\n            else:\r\n                xCqNck7t[k] = kwargs[k]", "response": "Updates the Dict with the given values. Turns internal dicts into Dicts."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef keys(self, key=None, reverse=False):\r\n        ks = sorted(list(dict.keys(self)), key=key, reverse=reverse)\r\n        return ks", "response": "sort the keys before returning them"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hub(self, port):\r\n        ''' java -jar selenium-server.jar -role hub -port 4444\r\n        @param port:  listen port of selenium hub \r\n        '''\r\n        self._ip = \"localhost\"\r\n        self._port = port \r\n        self.command = [self._conf[\"java_path\"], \"-jar\", self._conf[\"jar_path\"], \"-port\", str(port), \"-role\", \"hub\"]        \r\n        return self", "response": "java - jar selenium - server. jar - role hub - port 4444"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef node(self,port, hub_address=(\"localhost\", 4444)):\r\n        ''' java -jar selenium-server.jar -role node -port 5555 -hub http://127.0.0.1:4444/grid/register/\r\n        @param port:  listen port of selenium node\r\n        @param hub_address: hub address which node will connect to \r\n        '''\r\n        self._ip, self._port = hub_address\r\n        self.command = [self._conf[\"java_path\"], \"-jar\", self._conf[\"jar_path\"], \"-port\", str(port), \"-role\", \"node\", \"-hub\", \"http://%s:%s/grid/register/\" %(self._ip, self._port)]        \r\n        return self", "response": "create a new node and add it to the list of nodes"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart the selenium Remote Server.", "response": "def start_server(self):\r\n        \"\"\"start the selenium Remote Server.\"\"\"        \r\n        self.__subp = subprocess.Popen(self.command)        \r\n        #print(\"\\tselenium jar pid[%s] is running.\" %self.__subp.pid)        \r\n        time.sleep(2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines whether hub server is running", "response": "def is_runnnig(self):\r\n        \"\"\"Determine whether hub server is running\r\n        :return:True or False\r\n        \"\"\"\r\n        resp = None\r\n        try:\r\n            resp = requests.get(\"http://%s:%s\" %(self._ip, self._port))\r\n\r\n            if resp.status_code == 200:\r\n                return True\r\n            else:\r\n                return False\r\n        except:\r\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef negate_gate(wordlen, input='x', output='~x'):\n    neg = bitwise_negate(wordlen, input, \"tmp\")\n    inc = inc_gate(wordlen, \"tmp\", output)\n    return neg >> inc", "response": "Implements two s complement negation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a circuit taking a wordlen bitvector where only k - models return True.", "response": "def kmodels(wordlen: int, k: int, input=None, output=None):\n    \"\"\"Return a circuit taking a wordlen bitvector where only k\n    valuations return True. Uses encoding from [1].\n\n    Note that this is equivalent to (~x < k).\n    - TODO: Add automated simplification so that the circuits\n            are equiv.\n\n    [1]: Chakraborty, Supratik, et al. \"From Weighted to Unweighted Model\n    Counting.\" IJCAI. 2015.\n    \"\"\"\n\n    assert 0 <= k < 2**wordlen\n    if output is None:\n        output = _fresh()\n\n    if input is None:\n        input = _fresh()\n\n    input_names = named_indexes(wordlen, input)\n    atoms = map(aiger.atom, input_names)\n\n    active = False\n    expr = aiger.atom(False)\n    for atom, bit in zip(atoms, encode_int(wordlen, k, signed=False)):\n        active |= bit\n        if not active:  # Skip until first 1.\n            continue\n        expr = (expr | atom) if bit else (expr & atom)\n\n    return aigbv.AIGBV(\n        aig=expr.aig,\n        input_map=frozenset([(input, tuple(input_names))]),\n        output_map=frozenset([(output, (expr.output,))]),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns username and password.", "response": "def auth(self):\n        \"\"\"\n        tuple of (username, password). if use_keyring is set to true the password will be queried from the local keyring instead of taken from the\n        configuration file.\n        \"\"\"\n        username = self._settings[\"username\"]\n\n        if not username:\n            raise ValueError(\"Username was not configured in %s\" % CONFIG_FILE)\n\n        if self._settings[\"use_keyring\"]:\n            password = self.keyring_get_password(username)\n            if not password:\n                self.keyring_set_password(username)\n                password = self.keyring_get_password(username)\n        else:\n            password = self._settings[\"password\"]\n\n        return self._settings[\"username\"], password"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a configuration file.", "response": "def load(self, file=CONFIG_FILE):\n        \"\"\"\n        load a configuration file. loads default config if file is not found\n        \"\"\"\n        if not os.path.exists(file):\n            print(\"Config file was not found under %s. Default file has been created\" % CONFIG_FILE)\n            self._settings = yaml.load(DEFAULT_CONFIG, yaml.RoundTripLoader)\n            self.save(file)\n            sys.exit()\n        with open(file, 'r') as f:\n            self._settings = yaml.load(f, yaml.RoundTripLoader)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, file=CONFIG_FILE):\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        with open(file, \"w\") as f:\n            yaml.dump(self._settings, f, Dumper=yaml.RoundTripDumper, width=float(\"inf\"))", "response": "Save the current configuration to a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nopen a curses picker based interface to select courses that should be downloaded.", "response": "def selection_dialog(self, courses):\n        \"\"\"\n        opens a curses/picker based interface to select courses that should be downloaded.\n        \"\"\"\n        selected = list(filter(lambda x: x.course.id in self._settings[\"selected_courses\"], courses))\n        selection = Picker(\n            title=\"Select courses to download\",\n            options=courses,\n            checked=selected).getSelected()\n        if selection:\n            self._settings[\"selected_courses\"] = list(map(lambda x: x.course.id, selection))\n            self.save()\n            log.info(\"Updated course selection\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the corresponding index. Will overwrite existing indexes of the same name.", "response": "def create(self):\n        \"\"\"Create the corresponding index. Will overwrite existing indexes of the same name.\"\"\"\n        body = dict()\n        if self.mapping is not None:\n            body['mappings'] = self.mapping\n        if self.settings is not None:\n            body['settings'] = self.settings\n        else:\n            body['settings'] = self._default_settings()\n        self.instance.indices.create(self.index, body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching the index with a query.", "response": "def search(self, query=None, size=100, unpack=True):\n        \"\"\"Search the index with a query.\n\n        Can at most return 10'000 results from a search. If the search would yield more than 10'000 hits, only the first 10'000 are returned.\n        The default number of hits returned is 100.\n        \"\"\"\n        logging.info('Download all documents from index %s.', self.index)\n        if query is None:\n            query = self.match_all\n        results = list()\n        data = self.instance.search(index=self.index, doc_type=self.doc_type, body=query, size=size)\n        if unpack:\n            for items in data['hits']['hits']:\n                if '_source' in items:\n                    results.append(items['_source'])\n                else:\n                    results.append(items)\n        else:\n            results = data['hits']['hits']\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef scan_index(self, query: Union[Dict[str, str], None] = None) -> List[Dict[str, str]]:\n        if query is None:\n            query = self.match_all\n        logging.info('Download all documents from index %s with query %s.', self.index, query)\n        results = list()\n        data = scan(self.instance, index=self.index, doc_type=self.doc_type, query=query)\n        for items in data:\n            if '_source' in items:\n                results.append(items['_source'])\n            else:\n                results.append(items)\n        return results", "response": "Scan the index with the query and return all the documents with metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nscrolls an index with the specified search query.", "response": "def scroll(self, query=None, scroll='5m', size=100, unpack=True):\n        \"\"\"Scroll an index with the specified search query.\n\n        Works as a generator. Will yield `size` results per iteration until all hits are returned.\n        \"\"\"\n        query = self.match_all if query is None else query\n        response = self.instance.search(index=self.index, doc_type=self.doc_type, body=query, size=size, scroll=scroll)\n        while len(response['hits']['hits']) > 0:\n            scroll_id = response['_scroll_id']\n            logging.debug(response)\n            if unpack:\n                yield [source['_source'] if '_source' in source else source for source in response['hits']['hits']]\n            else:\n                yield response['hits']['hits']\n            response = self.instance.scroll(scroll_id=scroll_id, scroll=scroll)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a single record by _id.", "response": "def get(self, identifier):\n        \"\"\"Fetch document by _id.\n\n        Returns None if it is not found. (Will log a warning if not found as well. Should not be used\n        to search an id.)\"\"\"\n        logging.info('Download document with id ' + str(identifier) + '.')\n        try:\n            record = self.instance.get(index=self.index, doc_type=self.doc_type, id=identifier)\n            if '_source' in record:\n                return record['_source']\n            else:\n                return record\n        except NotFoundError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nindex a single document into the index.", "response": "def index_into(self, document, id) -> bool:\n        \"\"\"Index a single document into the index.\"\"\"\n        try:\n            self.instance.index(index=self.index, doc_type=self.doc_type, body=json.dumps(document, ensure_ascii=False), id=id)\n        except RequestError as ex:\n            logging.error(ex)\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete(self, doc_id: str) -> bool:\n\n        try:\n            self.instance.delete(self.index, self.doc_type, doc_id)\n        except RequestError as ex:\n            logging.error(ex)\n            return False\n        else:\n            return True", "response": "Delete a document with id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing painless script to update a document.", "response": "def script_update(self, script: str, params: Union[dict, None], doc_id: str):\n        \"\"\"Uses painless script to update a document.\n\n        See documentation for more information.\n        \"\"\"\n        body = {\n            'script': {\n                'source': script,\n                'lang': 'painless'\n            }\n        }\n        if params is not None:\n            body['script']['params'] = params\n        self.instance.update(self.index, self.doc_type, doc_id, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbulking index the data in the specified index.", "response": "def bulk(self, data: List[Dict[str, str]], identifier_key: str, op_type='index', upsert=False, keep_id_key=False) -> bool:\n        \"\"\"\n        Takes a list of dictionaries and an identifier key and indexes everything into this index.\n\n        :param data:            List of dictionaries containing the data to be indexed.\n        :param identifier_key:  The name of the dictionary element which should be used as _id. This will be removed from\n                                the body. Is ignored when None or empty string. This will cause elastic\n                                to create their own _id.\n        :param op_type:         What should be done: 'index', 'delete', 'update'.\n        :param upsert:          The update op_type can be upserted, which will create a document if not already present.\n        :param keep_id_key      Determines if the value designated as the identifier_key should be kept\n                                as part of the document or removed from it.\n        :returns                Returns True if all the messages were indexed without errors. False otherwise.\n        \"\"\"\n        bulk_objects = []\n        for document in data:\n            bulk_object = dict()\n            bulk_object['_op_type'] = op_type\n            if identifier_key is not None and identifier_key != '':\n                bulk_object['_id'] = document[identifier_key]\n                if not keep_id_key:\n                    document.pop(identifier_key)\n                if bulk_object['_id'] == '':\n                    bulk_object.pop('_id')\n            if op_type == 'index':\n                bulk_object['_source'] = document\n            elif op_type == 'update':\n                bulk_object['doc'] = document\n                if upsert:\n                    bulk_object['doc_as_upsert'] = True\n            bulk_objects.append(bulk_object)\n            logging.debug(str(bulk_object))\n        logging.info('Start bulk index for ' + str(len(bulk_objects)) + ' objects.')\n        errors = bulk(self.instance, actions=bulk_objects, index=self.index, doc_type=self.doc_type,\n                      raise_on_error=False)\n        logging.info(str(errors[0]) + ' documents were successfully indexed/updated/deleted.')\n        if errors[0] - len(bulk_objects) != 0:\n            logging.error(str(len(bulk_objects) - errors[0]) + ' documents could not be indexed/updated/deleted.')\n            for error in errors[1]:\n                logging.error(str(error))\n            return False\n        else:\n            logging.debug('Finished bulk %s.', op_type)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reindex(self, new_index_name: str, identifier_key: str, **kwargs) -> 'ElasticIndex':\n        if 'url' not in kwargs:\n            kwargs['url'] = self.url\n        if 'doc_type' not in kwargs:\n            kwargs['doc_type'] = self.doc_type\n        if 'mapping' not in kwargs:\n            kwargs['mapping'] = self.mapping\n        new_index = ElasticIndex(new_index_name, **kwargs)\n\n        for results in self.scroll(size=500):\n            new_index.bulk(results, identifier_key)\n        return new_index", "response": "Reindex the entire index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps the entire index into a json file.", "response": "def dump(self, path: str, file_name: str = \"\", **kwargs: dict):\n        \"\"\"\n        Dumps the entire index into a json file. \n\n        :param path: The path to directory where the dump should be stored.\n        :param file_name: Name of the file the dump should be stored in. If empty the index name is used.\n        :param kwargs: Keyword arguments for the json converter. (ex. indent=4, ensure_ascii=False)\n        \"\"\"\n        export = list()\n        for results in self.scroll():\n            export.extend(results)\n\n        if not path.endswith('/'):\n            path += '/'\n\n        if file_name == '':\n            file_name = self.index\n\n        if not file_name.endswith('.json'):\n            file_name += '.json'\n\n        store = path + file_name\n        with open(store, 'w') as fp:\n            json.dump(export, fp, **kwargs)\n\n        logging.info(\"Extracted %s records from the index %s and stored them in %s/%s.\", len(export), self.index, path, file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses command line options and either launch some configuration dialog or start an instance of _MainLoop as a daemon", "response": "def main():\n    \"\"\"\n    parse command line options and either launch some configuration dialog or start an instance of _MainLoop as a daemon\n    \"\"\"\n    (options, _) = _parse_args()\n\n    if options.change_password:\n        c.keyring_set_password(c[\"username\"])\n        sys.exit(0)\n\n    if options.select:\n        courses = client.get_courses()\n        c.selection_dialog(courses)\n        c.save()\n        sys.exit(0)\n\n    if options.stop:\n        os.system(\"kill -2 `cat ~/.studdp/studdp.pid`\")\n        sys.exit(0)\n\n    task = _MainLoop(options.daemonize, options.update_courses)\n\n    if options.daemonize:\n        log.info(\"daemonizing...\")\n        with daemon.DaemonContext(working_directory=\".\", pidfile=PIDLockFile(PID_FILE)):\n            # we have to create a new logger in the daemon context\n            handler = logging.FileHandler(LOG_PATH)\n            handler.setFormatter('%(asctime)s [%(levelname)s] %(name)s: %(message)s')\n            log.addHandler(handler)\n            task()\n    else:\n        task()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate(self, signature_data):\n        result = Result()\n\n        for rule in self.pipeline:\n            rule_name = rule.__class__.__name__\n\n            try:\n                if rule.predicate(signature_data, result):\n                    rule.action(signature_data, result)\n\n            except Exception as exc:\n                if self.error_handler:\n                    self.error_handler(\n                        signature_data,\n                        exc_info=sys.exc_info(),\n                        extra={'rule': rule_name}\n                    )\n                result.info(rule_name, 'Rule failed: %s', exc)\n\n        return result", "response": "Takes data and returns a result object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _blast(bvname2vals, name_map):\n    if len(name_map) == 0:\n        return dict()\n    return fn.merge(*(dict(zip(names, bvname2vals[bvname]))\n                      for bvname, names in name_map))", "response": "Helper function to expand BLAST str - > int map into str - > bool map. This function is used to send word level inputs to aiger."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a logger instance from the singleton", "response": "def create_logger(self):\n        \"\"\"Generates a logger instance from the singleton\"\"\"\n        name = \"bors\"\n        if hasattr(self, \"name\"):\n            name = self.name\n\n        self.log = logging.getLogger(name)\n        try:\n            lvl = self.conf.get_log_level()\n        except AttributeError:\n            lvl = self.context.get(\"log_level\", None)\n\n        self.log.setLevel(getattr(logging, lvl, logging.INFO))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets class from name and data sets base level attrs defaults to facsimile. base. Facsimile", "response": "def get_cls(project_name, project_data):\n    \"\"\"\n    gets class from name and data, sets base level attrs\n    defaults to facsimile.base.Facsimile\n    \"\"\"\n    if project_name:\n        cls = getattr(facsimile.base, project_data.get('class', 'Facsimile'))\n        cls.name = project_name\n    else:\n        cls = facsimile.base.Facsimile\n    return cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_recaptcha(view_func):\n    @wraps(view_func)\n    def _wrapped_view(request, *args, **kwargs):\n        request.recaptcha_is_valid = None\n        if request.method == 'POST':\n            recaptcha_response = request.POST.get('g-recaptcha-response')\n            data = {\n                'secret': settings.GOOGLE_RECAPTCHA_SECRET_KEY,\n                'response': recaptcha_response\n            }\n            r = requests.post(\n                'https://www.google.com/recaptcha/api/siteverify',\n                data=data\n            )\n            result = r.json()\n            if result['success']:\n                request.recaptcha_is_valid = True\n            else:\n                request.recaptcha_is_valid = False\n                error_message = 'Invalid reCAPTCHA. Please try again. '\n                error_message += str(result['error-codes'])\n                print(error_message)\n        return view_func(request, *args, **kwargs)\n    return _wrapped_view", "response": "Chech that the entered recaptcha data is correct"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef request(self, endpoint, method=\"GET\", params=None):\n\n        # In case they want to pass a full Safecast URL\n        # i.e. https://api.safecast.org/measurements.json\n        if endpoint.startswith(\"http\"):\n            url = endpoint\n        else:\n            url = \"%s/%s.json\" % (self.api_url, endpoint)\n\n        if method != \"GET\":\n            if self.api_key is None:\n                raise SafecastPyAuthError(\"Require an api_key\")\n            url = url + \"?api_key={0}\".format(self.api_key)\n\n        content = self._request(url, method=method, params=params, api_call=url)\n        return content", "response": "Send a request to the specified endpoint and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling a POST request to get the list of the available resources.", "response": "def post_list(self, request, **kwargs):\n        \"\"\"\n        (Copied from implementation in\n        https://github.com/greenelab/adage-server/blob/master/adage/analyze/api.py)\n\n        Handle an incoming POST as a GET to work around URI length limitations\n        \"\"\"\n        # The convert_post_to_VERB() technique is borrowed from\n        # resources.py in tastypie source. This helps us to convert the POST\n        # to a GET in the proper way internally.\n        request.method = 'GET'  # override the incoming POST\n        dispatch_request = convert_post_to_VERB(request, 'GET')\n        return self.dispatch('list', dispatch_request, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the strategies on the given context", "response": "def execute(self, context):\n        \"\"\"Execute the strategies on the given context\"\"\"\n        for ware in self.middleware:\n            ware.premessage(context)\n            context = ware.bind(context)\n            ware.postmessage(context)\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shutdown(self):\n        for ware in self.middleware:\n            ware.preshutdown()\n            self._shutdown()\n            ware.postshutdown()", "response": "Perform cleanup! We re goin down!!!"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating documentation for signature generation pipeline", "response": "def main(argv=None):\n    \"\"\"Generates documentation for signature generation pipeline\"\"\"\n    parser = argparse.ArgumentParser(description=DESCRIPTION)\n    parser.add_argument(\n        'pipeline',\n        help='Python dotted path to rules pipeline to document'\n    )\n    parser.add_argument('output', help='output file')\n\n    if argv is None:\n        args = parser.parse_args()\n    else:\n        args = parser.parse_args(argv)\n\n    print('Generating documentation for %s in %s...' % (args.pipeline, args.output))\n\n    rules = import_rules(args.pipeline)\n\n    with open(args.output, 'w') as fp:\n        fp.write('.. THIS IS AUTOGEMERATED USING:\\n')\n        fp.write('   \\n')\n        fp.write('   %s\\n' % (' '.join(sys.argv)))\n        fp.write('   \\n')\n        fp.write('Signature generation rules pipeline\\n')\n        fp.write('===================================\\n')\n        fp.write('\\n')\n        fp.write('\\n')\n        fp.write(\n            'This is the signature generation pipeline defined at ``%s``:\\n' %\n            args.pipeline\n        )\n        fp.write('\\n')\n\n        for i, rule in enumerate(rules):\n            li = '%s. ' % (i + 1)\n            fp.write('%s%s\\n' % (\n                li,\n                indent(get_doc(rule), ' ' * len(li))\n            ))\n            fp.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(self, *args, **options):\n        taxonomy_id = options['taxonomy_id']\n\n        # Remove leading and trailing blank characters in \"common_name\"\n        # and \"scientific_name\n        common_name = options['common_name'].strip()\n        scientific_name = options['scientific_name'].strip()\n\n        if common_name and scientific_name:\n            # A 'slug' is a label for an object in django, which only contains\n            # letters, numbers, underscores, and hyphens, thus making it URL-\n            # usable.  The slugify method in django takes any string and\n            # converts it to this format.  For more information, see:\n            # http://stackoverflow.com/questions/427102/what-is-a-slug-in-django\n            slug = slugify(scientific_name)\n            logger.info(\"Slug generated: %s\", slug)\n\n            # If organism exists, update with passed parameters\n            try:\n                org = Organism.objects.get(taxonomy_id=taxonomy_id)\n                org.common_name = common_name\n                org.scientific_name = scientific_name\n                org.slug = slug\n            # If organism doesn't exist, construct an organism object\n            # (see organisms/models.py).\n            except Organism.DoesNotExist:\n                org = Organism(taxonomy_id=taxonomy_id,\n                               common_name=common_name,\n                               scientific_name=scientific_name,\n                               slug=slug\n                )\n            org.save()  # Save to the database.\n        else:\n            # Report an error if the user did not fill out all fields.\n            logger.error(\n                \"Failed to add or update organism. \"\n                \"Please check that all fields are filled correctly.\"\n            )", "response": "This function is called by the django API to specify how this object is saved to the database. It will create an organism object and update it with the passed parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a window of given resolution.", "response": "def init(resolution, pygame_flags=0, display_pos=(0, 0), interactive_mode=False):\n    \"\"\"Creates a window of given resolution.\n\n    :param resolution: the resolution of the windows as (width, height) in\n        pixels\n    :type resolution: tuple\n    :param pygame_flags: modify the creation of the window.\n        For further information see :ref:`creating_a_window`\n    :type pygame_flags: int\n    :param display_pos: determines the position on the desktop where the\n        window is created. In a multi monitor system this can be used to position\n        the window on a different monitor. E.g. the monitor to the right of the\n        main-monitor would be at position (1920, 0) if the main monitor has the\n        width 1920.\n    :type display_pos: tuple\n    :param interactive_mode: Will install a thread, that emptys the\n        event-queue every 100ms. This is neccessary to be able to use the\n        display() function in an interactive console on windows systems.\n        If interactive_mode is set, init() will return a reference to the\n        background thread. This thread has a stop() method which can be used to\n        cancel it. If you use ctrl+d or exit() within ipython, while the thread\n        is still running, ipython will become unusable, but not close. \n    :type interactive_mode: bool\n\n    :return: a reference to the display screen, or a reference to the background\n        thread if interactive_mode was set to true. In the second scenario you\n        can obtain a reference to the display surface via\n        pygame.display.get_surface()\n        \n    :rtype: pygame.Surface\n    \"\"\"\n\n    os.environ['SDL_VIDEO_WINDOW_POS'] = \"{}, {}\".format(*display_pos)\n    pygame.init()\n    pygame.font.init()\n    disp = pygame.display.set_mode(resolution, pygame_flags)\n    return _PumpThread() if interactive_mode else disp"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndisplays a pygame. Surface in the window.", "response": "def display(surface):\n    \"\"\"Displays a pygame.Surface in the window.\n    \n    in pygame the window is represented through a surface, on which you can draw\n    as on any other pygame.Surface. A refernce to to the screen can be optained\n    via the :py:func:`pygame.display.get_surface` function. To display the\n    contents of the screen surface in the window :py:func:`pygame.display.flip`\n    needs to be called.\n    \n    :py:func:`display` draws the surface onto the screen surface at the postion\n    (0, 0), and then calls :py:func:`flip`.\n    \n    :param surface: the pygame.Surface to display\n    :type surface: pygame.Surface\n    \"\"\"\n    screen = pygame.display.get_surface()\n    screen.blit(surface, (0, 0))\n    pygame.display.flip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an empty surface filled with fill_color.", "response": "def empty_surface(fill_color, size=None):\n    \"\"\"Returns an empty surface filled with fill_color.\n\n    :param fill_color: color to fill the surface with\n    :type fill_color: pygame.Color\n\n    :param size: the size of the new surface, if None its created\n        to be the same size as the screen\n    :type size: int-2-tuple\n    \"\"\"\n    sr = pygame.display.get_surface().get_rect()\n    surf = pygame.Surface(size or (sr.w, sr.h))\n    surf.fill(fill_color)\n    return surf"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_char(buffer: str, char: str, mappings=_char_mappings):\n    if char in mappings:\n        return buffer + mappings[char]\n    elif char == \"\\u0008\":\n        return buffer[:-1] if len(buffer) > 0 else buffer\n    else:\n        return buffer + char", "response": "This method processes a unicode character in a string and returns a new string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        self.api = self.context.get(\"cls\")(self.context)\n        self.context[\"inst\"].append(self)  # Adapters used by strategies\n\n        def on_ws_connect(*args, **kwargs):\n            \"\"\"Callback on connect hook to set is_connected_ws\"\"\"\n            self.is_connected_ws = True\n            self.api.on_ws_connect(*args, **kwargs)\n\n        # Initialize websocket in a thread with channels\n        if hasattr(self.api, \"on_ws_connect\"):\n            self.thread = Process(target=self.api.connect_ws, args=(\n                on_ws_connect, [\n                    SockChannel(channel, res_type, self._generate_result)\n                    for channel, res_type in\n                    self\n                    .context\n                    .get(\"conf\")\n                    .get(\"subscriptions\")\n                    .items()\n                ]))\n            self.thread.start()", "response": "Initialize websockets in a thread with channels and subscriptions"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the given channels to the websock listener and connect them to the websock listener", "response": "def add_channels(self, channels):\n        \"\"\"\n        Take a list of SockChannel objects and extend the websock listener\n        \"\"\"\n        chans = [\n            SockChannel(chan, res, self._generate_result)\n            for chan, res in channels.items()\n        ]\n        self.api.channels.extend(chans)\n        self.api.connect_channels(chans)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _generate_result(self, res_type, channel, result):\n        schema = self.api.ws_result_schema()\n        schema.context['channel'] = channel\n        schema.context['response_type'] = res_type\n        self.callback(schema.load(result), self.context)", "response": "Generate the result object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a random element from seq n times.", "response": "def rand_elem(seq, n=None):\n    \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"\n    return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns first paragraph of multiline_str as a oneliner.", "response": "def first_paragraph(multiline_str, without_trailing_dot=True, maxlength=None):\n    '''Return first paragraph of multiline_str as a oneliner.\n\n    When without_trailing_dot is True, the last char of the first paragraph\n    will be removed, if it is a dot ('.').\n\n    Examples:\n        >>> multiline_str = 'first line\\\\nsecond line\\\\n\\\\nnext paragraph'\n        >>> print(first_paragraph(multiline_str))\n        first line second line\n\n        >>> multiline_str = 'first \\\\n second \\\\n  \\\\n next paragraph '\n        >>> print(first_paragraph(multiline_str))\n        first second\n\n        >>> multiline_str = 'first line\\\\nsecond line\\\\n\\\\nnext paragraph'\n        >>> print(first_paragraph(multiline_str, maxlength=3))\n        fir\n\n        >>> multiline_str = 'first line\\\\nsecond line\\\\n\\\\nnext paragraph'\n        >>> print(first_paragraph(multiline_str, maxlength=78))\n        first line second line\n\n        >>> multiline_str = 'first line.'\n        >>> print(first_paragraph(multiline_str))\n        first line\n\n        >>> multiline_str = 'first line.'\n        >>> print(first_paragraph(multiline_str, without_trailing_dot=False))\n        first line.\n\n        >>> multiline_str = ''\n        >>> print(first_paragraph(multiline_str))\n        <BLANKLINE>\n    '''\n    stripped = '\\n'.join([line.strip() for line in multiline_str.splitlines()])\n    paragraph = stripped.split('\\n\\n')[0]\n    res = paragraph.replace('\\n', ' ')\n    if without_trailing_dot:\n        res = res.rsplit('.', 1)[0]\n    if maxlength:\n        res = res[0:maxlength]\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints the first paragraph of the docstring of the decorated function.", "response": "def print_doc1(*args, **kwargs):\n    '''Print the first paragraph of the docstring of the decorated function.\n\n    The paragraph will be printed as a oneliner.\n\n    May be invoked as a simple, argument-less decorator (i.e. ``@print_doc1``)\n    or with named arguments ``color``, ``bold``, ``prefix`` of ``tail``\n    (eg. ``@print_doc1(color=utils.red, bold=True, prefix=' ')``).\n\n    Examples:\n    #    >>> @print_doc1\n    #    ... def foo():\n    #    ...     \"\"\"First line of docstring.\n    #    ...\n    #    ...     another line.\n    #    ...     \"\"\"\n    #    ...     pass\n    #    ...\n    #    >>> foo()\n    #    \\033[34mFirst line of docstring\\033[0m\n\n    #    >>> @print_doc1\n    #    ... def foo():\n    #    ...     \"\"\"First paragraph of docstring which contains more than one\n    #    ...     line.\n    #    ...\n    #    ...     Another paragraph.\n    #    ...     \"\"\"\n    #    ...     pass\n    #    ...\n    #    >>> foo()\n    #    \\033[34mFirst paragraph of docstring which contains more than one line\\033[0m\n    '''\n    # output settings from kwargs or take defaults\n    color = kwargs.get('color', blue)\n    bold = kwargs.get('bold', False)\n    prefix = kwargs.get('prefix', '')\n    tail = kwargs.get('tail', '\\n')\n\n    def real_decorator(func):\n        '''real decorator function'''\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            '''the wrapper function'''\n            try:\n                prgf = first_paragraph(func.__doc__)\n                print(color(prefix + prgf + tail, bold))\n            except AttributeError as exc:\n                name = func.__name__\n                print(red(flo('{name}() has no docstring')))\n                raise(exc)\n            return func(*args, **kwargs)\n        return wrapper\n\n    invoked = bool(not args or kwargs)\n    if not invoked:\n        # invoke decorator function which returns the wrapper function\n        return real_decorator(func=args[0])\n\n    return real_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filled_out_template_str(template, **substitutions):\n    '''Return str template with applied substitutions.\n\n    Example:\n        >>> template = 'Asyl for {{name}} {{surname}}!'\n        >>> filled_out_template_str(template, name='Edward', surname='Snowden')\n        'Asyl for Edward Snowden!'\n\n        >>> template = '[[[foo]]] was substituted by {{foo}}'\n        >>> filled_out_template_str(template, foo='bar')\n        '{{foo}} was substituted by bar'\n\n        >>> template = 'names wrapped by {single} {curly} {braces} {{curly}}'\n        >>> filled_out_template_str(template, curly='remains unchanged')\n        'names wrapped by {single} {curly} {braces} remains unchanged'\n    '''\n    template = template.replace('{', '{{')\n    template = template.replace('}', '}}')\n    template = template.replace('{{{{', '{')\n    template = template.replace('}}}}', '}')\n    template = template.format(**substitutions)\n    template = template.replace('{{', '{')\n    template = template.replace('}}', '}')\n    template = template.replace('[[[', '{{')\n    template = template.replace(']]]', '}}')\n    return template", "response": "Return str template with applied substitutions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns content of file filename with applied substitutions.", "response": "def filled_out_template(filename, **substitutions):\n    '''Return content of file filename with applied substitutions.'''\n    res = None\n    with open(filename, 'r') as fp:\n        template = fp.read()\n        res = filled_out_template_str(template, **substitutions)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_or_append_line(filename, prefix, new_line, keep_backup=True,\n                          append=True):\n    '''Search in file 'filename' for a line starting with 'prefix' and replace\n    the line by 'new_line'.\n\n    If a line starting with 'prefix' not exists 'new_line' will be appended.\n    If the file not exists, it will be created.\n\n    Return False if new_line was appended, else True (i.e. if the prefix was\n    found within of the file).\n    '''\n    same_line_exists, line_updated = False, False\n    filename = os.path.expanduser(filename)\n    if os.path.isfile(filename):\n        backup = filename + '~'\n        shutil.move(filename, backup)\n    #    with open(filename, 'w') as dest, open(backup, 'r') as source:\n        with open(filename, 'w') as dest:\n            with open(backup, 'r') as source:\n                # try update..\n                for line in source:\n                    if line == new_line:\n                        same_line_exists = True\n                    if line.startswith(prefix):\n                        dest.write(new_line + '\\n')\n                        line_updated = True\n                    else:\n                        dest.write(line)\n                # ..or append\n                if not (same_line_exists or line_updated) and append:\n                    dest.write(new_line + '\\n')\n        if not keep_backup:\n            os.remove(backup)\n    else:\n        with open(filename, 'w') as dest:\n            dest.write(new_line + '\\n')\n    return same_line_exists or line_updated", "response": "Search in file filename for a line starting with prefix and replace the line by new_line. Return True if the line was updated False if the line was not appended True if the line was not found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncommenting out a line in a file.", "response": "def comment_out_line(filename, line, comment='#',\n                     update_or_append_line=update_or_append_line):\n    '''Comment line out by putting a comment sign in front of the line.\n\n    If the file does not contain the line, the files content will not be\n    changed (but the file will be touched in every case).\n    '''\n    update_or_append_line(filename, prefix=line, new_line=comment+line,\n                          append=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the comment of an existing line and make the line active.", "response": "def uncomment_or_update_or_append_line(filename, prefix, new_line, comment='#',\n                                       keep_backup=True,\n                                       update_or_append_line=update_or_append_line):\n    '''Remove the comment of an commented out line and make the line \"active\".\n\n    If such an commented out line not exists it would be appended.\n    '''\n    uncommented = update_or_append_line(filename, prefix=comment+prefix,\n                                        new_line=new_line,\n                                        keep_backup=keep_backup, append=False)\n    if not uncommented:\n        update_or_append_line(filename, prefix, new_line,\n                              keep_backup=keep_backup, append=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_unicode_2_utf8(input):\n    '''Return a copy of `input` with every str component encoded from unicode to\n    utf-8.\n    '''\n    if isinstance(input, dict):\n        try:\n            # python-2.6\n            return dict((convert_unicode_2_utf8(key), convert_unicode_2_utf8(value))\n                        for key, value\n                        in input.iteritems())\n        except AttributeError:\n            # since python-2.7 cf. http://stackoverflow.com/a/1747827\n            # [the ugly eval('...') is required for a valid syntax on\n            # python-2.6, cf. http://stackoverflow.com/a/25049535]\n            return eval('''{convert_unicode_2_utf8(key): convert_unicode_2_utf8(value)\n                           for key, value\n                           in input.items()}''')\n    elif isinstance(input, list):\n        return [convert_unicode_2_utf8(element) for element in input]\n    # elif order relevant: python2 vs. python3\n    # cf. http://stackoverflow.com/a/19877309\n    elif isinstance(input, str):\n        return input\n    else:\n        try:\n            if eval('''isinstance(input, unicode)'''):\n                return input.encode('utf-8')\n        except NameError:\n            # unicode does not exist in python-3.x\n            pass\n        return input", "response": "Return a copy of input with every str component encoded from unicode to\n    utf - 8."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_json(filename, gzip_mode=False):\n    '''Return the json-file data, with all strings utf-8 encoded.'''\n\n    open_file = open\n    if gzip_mode:\n        open_file = gzip.open\n\n    try:\n        with open_file(filename, 'rt') as fh:\n            data = json.load(fh)\n            data = convert_unicode_2_utf8(data)\n            return data\n    except AttributeError:\n        # Python-2.6\n        fh = open_file(filename, 'rt')\n        data = json.load(fh)\n        fh.close()\n        data = convert_unicode_2_utf8(data)\n        return data", "response": "Return the json - file data with all strings utf - 8 encoded."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the python data structure as a json - Object to filename.", "response": "def write_json(data, filename, gzip_mode=False):\n    '''Write the python data structure as a json-Object to filename.'''\n\n    open_file = open\n    if gzip_mode:\n        open_file = gzip.open\n\n    try:\n        with open_file(filename, 'wt') as fh:\n            json.dump(obj=data, fp=fh, sort_keys=True)\n    except AttributeError:\n        # Python-2.6\n        fh = open_file(filename, 'wt')\n        json.dump(obj=data, fp=fh, sort_keys=True)\n        fh.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef text_with_newlines(text, line_length=78, newline='\\n'):\n    '''Return text with a `newline` inserted after each `line_length` char.\n\n    Return `text` unchanged if line_length == 0.\n    '''\n    if line_length > 0:\n        if len(text) <= line_length:\n            return text\n        else:\n            return newline.join([text[idx:idx+line_length]\n                                 for idx\n                                 in range(0, len(text), line_length)])\n    else:\n        return text", "response": "Return text with a newline inserted after each line_length char."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lazy_val(func, with_del_hook=False):\n    '''A memoize decorator for class properties.\n\n    Return a cached property that is calculated by function `func` on first\n    access.\n    '''\n\n    def hook_for(that):\n        try:\n            orig_del = that.__del__\n        except AttributeError:\n            orig_del = None\n\n        def del_hook(*args, **kwargs):\n            del that._cache[id(that)]\n            del that._del_hook_cache[id(that)]\n            if orig_del is not None:\n                orig_del(that, *args, **kwargs)\n\n        try:\n            if orig_del is not None:\n                that.__del__ = del_hook\n        except AttributeError:\n            # that.__del__ is a class property and cannot be changed by instance\n            orig_del = None\n        return del_hook\n\n    def add_to_del_hook_cache(that):\n        if with_del_hook:\n            try:\n                that._del_hook_cache[id(that)] = hook_for(that)\n            except AttributeError:\n                # when that._del_hook_cache not exists, it means it is not a\n                # class property.  Then, we don't need a del_hook().\n                pass\n\n    @functools.wraps(func)\n    def get(self):\n        try:\n            return self._cache[id(self)][func]\n        except AttributeError:\n            self._cache = {id(self): {}, }\n            add_to_del_hook_cache(self)\n        except KeyError:\n            try:\n                self._cache[id(self)]\n            except KeyError:\n                self._cache[id(self)] = {}\n                add_to_del_hook_cache(self)\n        val = self._cache[id(self)][func] = func(self)\n        return val\n\n    return property(get)", "response": "A memoize decorator for class properties."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads all lines from file.", "response": "def _readlines(fname, fpointer1=open, fpointer2=open):  # pragma: no cover\n    \"\"\"Read all lines from file.\"\"\"\n    # fpointer1, fpointer2 arguments to ease testing\n    try:\n        with fpointer1(fname, \"r\") as fobj:\n            return fobj.readlines()\n    except UnicodeDecodeError:  # pragma: no cover\n        with fpointer2(fname, \"r\", encoding=\"utf-8\") as fobj:\n            return fobj.readlines()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the files that match a given path and regexp pattern", "response": "def match(Class, path, pattern, flags=re.I, sortkey=None, ext=None):\n        \"\"\"for a given path and regexp pattern, return the files that match\"\"\"\n        return sorted(\n            [\n                Class(fn=fn)\n                for fn in rglob(path, f\"*{ext or ''}\")\n                if re.search(pattern, os.path.basename(fn), flags=flags) is not None\n                and os.path.basename(fn)[0] != '~'  # omit temp files\n            ],\n            key=sortkey,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncopy the file to the new_fn preserving atime and mtime", "response": "def copy(self, new_fn):\n        \"\"\"copy the file to the new_fn, preserving atime and mtime\"\"\"\n        new_file = self.__class__(fn=str(new_fn))\n        new_file.write(data=self.read())\n        new_file.utime(self.atime, self.mtime)\n        return new_file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a filesystem - compliant basename for this file", "response": "def make_basename(self, fn=None, ext=None):\n        \"\"\"make a filesystem-compliant basename for this file\"\"\"\n        fb, oldext = os.path.splitext(os.path.basename(fn or self.fn))\n        ext = ext or oldext.lower()\n        fb = String(fb).hyphenify(ascii=True)\n        return ''.join([fb, ext])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the contents of the file to a tempfile and return the tempfile filename", "response": "def tempfile(self, mode='wb', **args):\n        \"write the contents of the file to a tempfile and return the tempfile filename\"\n        tf = tempfile.NamedTemporaryFile(mode=mode)\n        self.write(tf.name, mode=mode, **args)\n        return tfn"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self):\n        if self.isfile:\n            os.remove(self.fn)\n        elif self.isdir:\n            shutil.rmtree(self.fn)", "response": "delete the file from the filesystem."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef readable_size(C, bytes, suffix='B', decimals=1, sep='\\u00a0'):\n        if bytes is None:\n            return\n        size = float(bytes)\n        for unit in C.SIZE_UNITS:\n            if abs(size) < 1024 or unit == C.SIZE_UNITS[-1]:\n                return \"{size:.{decimals}f}{sep}{unit}{suffix}\".format(\n                    size=size,\n                    unit=unit,\n                    suffix=suffix,\n                    sep=sep,\n                    decimals=C.SIZE_UNITS.index(unit) > 0 and decimals or 0,  # B with no decimal\n                )\n            size /= 1024", "response": "given a number of bytes return the file size in readable units"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a readable_size returns the number of bytes.", "response": "def bytes_from_readable_size(C, size, suffix='B'):\n        \"\"\"given a readable_size (as produced by File.readable_size()), return the number of bytes.\"\"\"\n        s = re.split(\"^([0-9\\.]+)\\s*([%s]?)%s?\" % (''.join(C.SIZE_UNITS), suffix), size, flags=re.I)\n        bytes, unit = round(float(s[1])), s[2].upper()\n        while unit in C.SIZE_UNITS and C.SIZE_UNITS.index(unit) > 0:\n            bytes *= 1024\n            unit = C.SIZE_UNITS[C.SIZE_UNITS.index(unit) - 1]\n        return bytes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute on startup of application", "response": "def run(self):\n        \"\"\"Executed on startup of application\"\"\"\n        for wsock in self.wsocks:\n            wsock.run()\n        for api in self.apis:\n            api.run()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shutdown(self):\n        for wsock in self.wsocks:\n            wsock.shutdown()\n        for api in self.apis:\n            api.shutdown()", "response": "Executed on shutdown of application"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a HTTP call and formats response and does error handling.", "response": "def request(self, url, method, data=None, headers=None):\n        \"\"\"Makes a HTTP call, formats response and does error handling.\n        \"\"\"\n        http_headers = merge_dict(self.default_headers, headers or {})\n        request_data = merge_dict({'api_key': self.apikey}, data or {})\n\n        logger.info('HTTP %s REQUEST TO %s' % (method, url))\n\n        start = datetime.datetime.now()\n\n        try:\n            response = requests.request(method=method, url=url, data=json.dumps(request_data),\n                                        headers=http_headers)\n        except exceptions.BadRequestError as e:\n            return json.loads({'errors': e.content})\n\n        duration = datetime.datetime.now() - start\n\n        logger.info('RESPONSE %s DURATION %s.%s' % (response.encoding, duration.seconds,\n                                                    duration.microseconds))\n\n        return json.loads(response.content) if response.content else {}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, action, params=None, headers=None):\n        return self.request(make_url(self.endpoint, action), method='GET', data=params,\n                            headers=headers)", "response": "Makes a GET request on the object with the given action."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a POST request", "response": "def post(self, action, data=None, headers=None):\n        \"\"\"Makes a GET request\n        \"\"\"\n        return self.request(make_url(self.endpoint, action), method='POST', data=data,\n                            headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes a DELETE request returning the response.", "response": "def delete(self, action, headers=None):\n        \"\"\"Makes a GET request\n        \"\"\"\n        return self.request(make_url(self.endpoint, action), method='DELETE',\n                            headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates a good piece size for a size.", "response": "def calc_piece_size(size, min_piece_size=20, max_piece_size=29, max_piece_count=1000):\n    \"\"\"\n    Calculates a good piece size for a size\n    \"\"\"\n    logger.debug('Calculating piece size for %i' % size)\n\n    for i in range(min_piece_size, max_piece_size): # 20 = 1MB\n        if size / (2**i) < max_piece_count:\n            break\n    return 2**i"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef split_pieces(piece_list, segments, num):\n    piece_groups = []\n    pieces = list(piece_list)\n    while pieces:\n        for i in range(segments):\n            p = pieces[i::segments][:num]\n            if not p:\n                break\n            piece_groups.append(p)\n        pieces = pieces[num * segments:]\n\n    return piece_groups", "response": "Prepare a list of all pieces grouped together together"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new future whose completion depends on parent futures", "response": "def after(parents, func=None):\n    '''Create a new Future whose completion depends on parent futures\n\n    The new future will have a function that it calls once all its parents\n    have completed, the return value of which will be its final value.\n    There is a special case, however, in which the dependent future's\n    callback returns a future or list of futures. In those cases, waiting\n    on the dependent will also wait for all those futures, and the result\n    (or list of results) of those future(s) will then be the final value.\n\n    :param parents:\n        A list of futures, all of which must be complete before the\n        dependent's function runs.\n    :type parents: list\n\n    :param function func:\n        The function to determine the value of the dependent future. It\n        will take as many arguments as it has parents, and they will be the\n        results of those futures.\n\n    :returns:\n        a :class:`Dependent`, which is a subclass of :class:`Future` and\n        has all its capabilities.\n    '''\n    if func is None:\n        return lambda f: after(parents, f)\n\n    dep = Dependent(parents, func)\n    for parent in parents:\n        if parent.complete:\n            dep._incoming(parent, parent.value)\n        else:\n            parent._children.append(weakref.ref(dep))\n    return dep"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for the completion of any of the provided futures.", "response": "def wait_any(futures, timeout=None):\n    '''Wait for the completion of any (the first) one of multiple futures\n\n    :param list futures: A list of :class:`Future`\\s\n    :param timeout:\n        The maximum time to wait. With ``None``, will block indefinitely.\n    :type timeout: float or None\n\n    :returns:\n        One of the futures from the provided list -- the first one to become\n        complete (or any of the ones that were already complete).\n\n    :raises WaitTimeout: if a timeout is provided and hit\n    '''\n    for fut in futures:\n        if fut.complete:\n            return fut\n\n    wait = _Wait(futures)\n\n    for fut in futures:\n        fut._waits.add(wait)\n\n    if wait.done.wait(timeout):\n        raise errors.WaitTimeout()\n\n    return wait.completed_future"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_all(futures, timeout=None):\n    '''Wait for the completion of all futures in a list\n\n    :param list future: a list of :class:`Future`\\s\n    :param timeout:\n        The maximum time to wait. With ``None``, can block indefinitely.\n    :type timeout: float or None\n\n    :raises WaitTimeout: if a timeout is provided and hit\n    '''\n    if timeout is not None:\n        deadline = time.time() + timeout\n        for fut in futures:\n            fut.wait(deadline - time.time())\n    else:\n        for fut in futures:\n            fut.wait()", "response": "Wait for the completion of all futures in a list of : class : Future \\ s\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives the future it s value and trigger any associated callbacks is set to None.", "response": "def finish(self, value):\n        '''Give the future it's value and trigger any associated callbacks\n\n        :param value: the new value for the future\n        :raises:\n            :class:`AlreadyComplete <junction.errors.AlreadyComplete>` if\n            already complete\n        '''\n        if self._done.is_set():\n            raise errors.AlreadyComplete()\n\n        self._value = value\n\n        for cb in self._cbacks:\n            backend.schedule(cb, args=(value,))\n        self._cbacks = None\n\n        for wait in list(self._waits):\n            wait.finish(self)\n        self._waits = None\n\n        for child in self._children:\n            child = child()\n            if child is None:\n                continue\n            child._incoming(self, value)\n        self._children = None\n\n        self._done.set()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef abort(self, klass, exc, tb=None):\n        '''Finish this future (maybe early) in an error state\n\n        Takes a standard exception triple as arguments (like returned by\n        ``sys.exc_info``) and will re-raise them as the value.\n\n        Any :class:`Dependents` that are children of this one will also be\n        aborted.\n\n        :param class klass: the class of the exception\n        :param Exception exc: the exception instance itself\n        :param traceback tb: the traceback associated with the exception\n\n        :raises:\n            :class:`AlreadyComplete <junction.errors.AlreadyComplete>` if\n            already complete\n        '''\n        if self._done.is_set():\n            raise errors.AlreadyComplete()\n\n        self._failure = (klass, exc, tb)\n\n        for eb in self._errbacks:\n            backend.schedule(eb, args=(klass, exc, tb))\n        self._errbacks = None\n\n        for wait in list(self._waits):\n            wait.finish(self)\n        self._waits = None\n\n        for child in self._children:\n            child = child()\n            if child is None:\n                continue\n            child.abort(klass, exc, tb)\n        self._children = None\n\n        self._done.set()", "response": "Finish this future in an error state."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_finish(self, func):\n        '''Assign a callback function to be run when successfully complete\n\n        :param function func:\n            A callback to run when complete. It will be given one argument (the\n            value that has arrived), and it's return value is ignored.\n        '''\n        if self._done.is_set():\n            if self._failure is None:\n                backend.schedule(func, args=(self._value,))\n        else:\n            self._cbacks.append(func)", "response": "Assign a callback function to be run when successfully complete\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nassigning a callback function to be run when abort \\ ed is set", "response": "def on_abort(self, func):\n        '''Assign a callback function to be run when :meth:`abort`\\ed\n\n        :param function func:\n            A callback to run when aborted. It will be given three arguments:\n\n                - ``klass``: the exception class\n                - ``exc``: the exception instance\n                - ``tb``: the traceback object associated with the exception\n        '''\n        if self._done.is_set():\n            if self._failure is not None:\n                backend.schedule(func, args=self._failure)\n        else:\n            self._errbacks.append(func)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef after(self, func=None, other_parents=None):\n        '''Create a new Future whose completion depends on this one\n\n        The new future will have a function that it calls once all its parents\n        have completed, the return value of which will be its final value.\n        There is a special case, however, in which the dependent future's\n        callback returns a future or list of futures. In those cases, waiting\n        on the dependent will also wait for all those futures, and the result\n        (or list of results) of those future(s) will then be the final value.\n\n        :param function func:\n            The function to determine the value of the dependent future. It\n            will take as many arguments as it has parents, and they will be the\n            results of those futures.\n\n        :param other_parents:\n            A list of futures, all of which (along with this one) must be\n            complete before the dependent's function runs.\n        :type other_parents: list or None\n\n        :returns:\n            a :class:`Dependent`, which is a subclass of :class:`Future` and\n            has all its capabilities.\n        '''\n        parents = [self]\n        if other_parents is not None:\n            parents += other_parents\n        return after(parents, func)", "response": "Create a new future whose completion depends on this one and the function func will be called with the return value of which the future s result is set to the final value of that one s parents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef os_path_transform(self, s, sep=os.path.sep):\n        if sep == '/':\n            return s\n        else:\n            return s.replace(sep, '/')", "response": "transforms any os path into unix style"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transform(self, tr_list, files):\n        singular = False\n        if not isinstance(files, list) and not isinstance(files, tuple):\n            singular = True\n            files = [files]\n\n        for _find, _replace in tr_list:\n            files = [opt.replace(_find, _replace) for opt in files]\n\n        if singular:\n            return files[0]\n        else:\n            return files", "response": "Transform a list of files into a list of config files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresolving the destination based on source and returns the file name.", "response": "def resolve_dst(self, dst_dir, src):\n        \"\"\"\n        finds the destination based on source\n        if source is an absolute path, and there's no pattern, it copies the file to base dst_dir\n        \"\"\"\n        if os.path.isabs(src):\n            return os.path.join(dst_dir, os.path.basename(src))\n        return os.path.join(dst_dir, src)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy the zip file from its filename to the given filename.", "response": "def write(self, fn=None):\n        \"\"\"copy the zip file from its filename to the given filename.\"\"\"\n        fn = fn or self.fn\n        if not os.path.exists(os.path.dirname(fn)):\n            os.makedirs(os.path.dirname(fn))\n        f = open(self.fn, 'rb')\n        b = f.read()\n        f.close()\n        f = open(fn, 'wb')\n        f.write(b)\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assign(self, attrs):\n        for k, v in attrs.items():\n            setattr(self, k, v)", "response": "Assign attributes to the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nnormalize a single rust frame with a function", "response": "def normalize_rust_function(self, function, line):\n        \"\"\"Normalizes a single rust frame with a function\"\"\"\n        # Drop the prefix and return type if there is any\n        function = drop_prefix_and_return_type(function)\n\n        # Collapse types\n        function = collapse(\n            function,\n            open_string='<',\n            close_string='>',\n            replacement='<T>',\n            exceptions=(' as ',)\n        )\n\n        # Collapse arguments\n        if self.collapse_arguments:\n            function = collapse(\n                function,\n                open_string='(',\n                close_string=')',\n                replacement=''\n            )\n\n        if self.signatures_with_line_numbers_re.match(function):\n            function = '{}:{}'.format(function, line)\n\n        # Remove spaces before all stars, ampersands, and commas\n        function = self.fixup_space.sub('', function)\n\n        # Ensure a space after commas\n        function = self.fixup_comma.sub(', ', function)\n\n        # Remove rust-generated uniqueness hashes\n        function = self.fixup_hash.sub('', function)\n\n        return function"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize_cpp_function(self, function, line):\n        # Drop member function cv/ref qualifiers like const, const&, &, and &&\n        for ref in ('const', 'const&', '&&', '&'):\n            if function.endswith(ref):\n                function = function[:-len(ref)].strip()\n\n        # Drop the prefix and return type if there is any if it's not operator\n        # overloading--operator overloading syntax doesn't have the things\n        # we're dropping here and can look curious, so don't try\n        if '::operator' not in function:\n            function = drop_prefix_and_return_type(function)\n\n        # Collapse types\n        function = collapse(\n            function,\n            open_string='<',\n            close_string='>',\n            replacement='<T>',\n            exceptions=('name omitted', 'IPC::ParamTraits')\n        )\n\n        # Collapse arguments\n        if self.collapse_arguments:\n            function = collapse(\n                function,\n                open_string='(',\n                close_string=')',\n                replacement='',\n                exceptions=('anonymous namespace', 'operator')\n            )\n\n        # Remove PGO cold block labels like \"[clone .cold.222]\". bug #1397926\n        if 'clone .cold' in function:\n            function = collapse(\n                function,\n                open_string='[',\n                close_string=']',\n                replacement=''\n            )\n\n        if self.signatures_with_line_numbers_re.match(function):\n            function = '{}:{}'.format(function, line)\n\n        # Remove spaces before all stars, ampersands, and commas\n        function = self.fixup_space.sub('', function)\n\n        # Ensure a space after commas\n        function = self.fixup_comma.sub(', ', function)\n\n        return function", "response": "Normalizes a single cpp frame with a function"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize_frame(\n        self,\n        module=None,\n        function=None,\n        file=None,\n        line=None,\n        module_offset=None,\n        offset=None,\n        normalized=None,\n        **kwargs  # eat any extra kwargs passed in\n    ):\n        \"\"\"Normalizes a single frame\n\n        Returns a structured conglomeration of the input parameters to serve as\n        a signature. The parameter names of this function reflect the exact\n        names of the fields from the jsonMDSW frame output. This allows this\n        function to be invoked by passing a frame as ``**a_frame``.\n\n        Sometimes, a frame may already have a normalized version cached. If\n        that exists, return it instead.\n\n        \"\"\"\n        # If there's a cached normalized value, use that so we don't spend time\n        # figuring it out again\n        if normalized is not None:\n            return normalized\n\n        if function:\n            # If there's a filename and it ends in .rs, then normalize using\n            # Rust rules\n            if file and (parse_source_file(file) or '').endswith('.rs'):\n                return self.normalize_rust_function(\n                    function=function,\n                    line=line\n                )\n\n            # Otherwise normalize it with C/C++ rules\n            return self.normalize_cpp_function(\n                function=function,\n                line=line\n            )\n\n        # If there's a file and line number, use that\n        if file and line:\n            filename = file.rstrip('/\\\\')\n            if '\\\\' in filename:\n                file = filename.rsplit('\\\\')[-1]\n            else:\n                file = filename.rsplit('/')[-1]\n            return '{}#{}'.format(file, line)\n\n        # If there's an offset and no module/module_offset, use that\n        if not module and not module_offset and offset:\n            return '@{}'.format(offset)\n\n        # Return module/module_offset\n        return '{}@{}'.format(module or '', module_offset)", "response": "Normalizes a single frame by using the specified function and line number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _do_generate(self, source_list, hang_type, crashed_thread, delimiter=' | '):\n        notes = []\n        debug_notes = []\n\n        # shorten source_list to the first signatureSentinel\n        sentinel_locations = []\n        for a_sentinel in self.signature_sentinels:\n            if type(a_sentinel) == tuple:\n                a_sentinel, condition_fn = a_sentinel\n                if not condition_fn(source_list):\n                    continue\n            try:\n                sentinel_locations.append(source_list.index(a_sentinel))\n            except ValueError:\n                pass\n        if sentinel_locations:\n            min_index = min(sentinel_locations)\n            debug_notes.append(\n                'sentinel; starting at \"{}\" index {}'.format(source_list[min_index], min_index)\n            )\n            source_list = source_list[min_index:]\n\n        # Get all the relevant frame signatures. Note that these function signatures\n        # have already been normalized at this point.\n        new_signature_list = []\n        for a_signature in source_list:\n            # If the signature matches the irrelevant signatures regex, skip to the next frame.\n            if self.irrelevant_signature_re.match(a_signature):\n                debug_notes.append('irrelevant; ignoring: \"{}\"'.format(a_signature))\n                continue\n\n            # If the frame signature is a dll, remove the @xxxxx part.\n            if '.dll' in a_signature.lower():\n                a_signature = a_signature.split('@')[0]\n\n                # If this trimmed DLL signature is the same as the previous frame's, skip it.\n                if new_signature_list and a_signature == new_signature_list[-1]:\n                    continue\n\n            new_signature_list.append(a_signature)\n\n            # If the signature does not match the prefix signatures regex, then it is the last\n            # one we add to the list.\n            if not self.prefix_signature_re.match(a_signature):\n                debug_notes.append('not a prefix; stop: \"{}\"'.format(a_signature))\n                break\n\n            debug_notes.append('prefix; continue iterating: \"{}\"'.format(a_signature))\n\n        # Add a special marker for hang crash reports.\n        if hang_type:\n            debug_notes.append(\n                'hang_type {}: prepending {}'.format(hang_type, self.hang_prefixes[hang_type])\n            )\n            new_signature_list.insert(0, self.hang_prefixes[hang_type])\n\n        signature = delimiter.join(new_signature_list)\n\n        # Handle empty signatures to explain why we failed generating them.\n        if signature == '' or signature is None:\n            if crashed_thread is None:\n                notes.append(\n                    \"CSignatureTool: No signature could be created because we do not know which \"\n                    \"thread crashed\"\n                )\n                signature = \"EMPTY: no crashing thread identified\"\n            else:\n                notes.append(\n                    \"CSignatureTool: No proper signature could be created because no good data \"\n                    \"for the crashing thread ({}) was found\".format(crashed_thread)\n                )\n                try:\n                    signature = source_list[0]\n                except IndexError:\n                    signature = \"EMPTY: no frame data available\"\n\n        return signature, notes, debug_notes", "response": "Generate the list of relevant frame names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _clean_tag(t):\n    # TODO: when score present, include info.\n    t = _scored_patt.sub(string=t, repl='')\n    if t == '_country_' or t.startswith('_country:'):\n        t = 'nnp_country'\n    elif t == 'vpb':\n        t = 'vb'  # \"carjack\" is listed with vpb tag.\n    elif t == 'nnd':\n        t = 'nns'  # \"abbes\" is listed with nnd tag.\n    elif t == 'nns_root:':\n        t = 'nns'  # 'micros' is listed as nns_root.\n    elif t == 'root:zygote':\n        t = 'nn'  # 'root:zygote' for zygote. :-/\n    elif t.startswith('root:'):\n        t = 'uh'  # Don't know why, but these are all UH tokens.\n    elif t in ('abbr_united_states_marine_corps', 'abbr_orange_juice'):\n        t = \"abbreviation\"\n    elif t == '+abbreviation':\n        t = 'abbreviation'\n    elif t.startswith('fw_misspelling:'):\n        t = 'fw'\n    return t", "response": "Fix up some garbage errors."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlocalize the settings for the dotted prefix.", "response": "def local_settings(settings, prefix):\n    \"\"\"Localizes the settings for the dotted prefix.\n    For example, if the prefix where 'xyz'::\n\n        {'xyz.foo': 'bar', 'other': 'something'}\n\n    Would become::\n\n        {'foo': 'bar'}\n\n    Note, that non-prefixed items are left out and the prefix is dropped.\n    \"\"\"\n    prefix = \"{}.\".format(prefix)\n    new_settings = {k[len(prefix):]: v for k, v in settings.items()\n                    if k.startswith(prefix)}\n    return new_settings"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef humanize_bytes(bytes, precision=1):\n    abbrevs = (\n        (1<<50, 'PB'),\n        (1<<40, 'TB'),\n        (1<<30, 'GB'),\n        (1<<20, 'MB'),\n        (1<<10, 'kB'),\n        (1, 'bytes')\n    )\n    if bytes == 1:\n        return '1 byte'\n    for factor, suffix in abbrevs:\n        if bytes >= factor:\n            break\n    return '%.*f %s' % (precision, bytes / factor, suffix)", "response": "Return a humanized string representation of a number of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parent(self):\r\n        path = '/'.join(self.path.split('/')[:-1])\r\n        s = path.strip('/').split(':')\r\n        if len(s)==2 and s[1]=='':\r\n            return None\r\n        else:\r\n            return self.__class__(self, path=path)", "response": "return the parent URL with params query and fragment in place"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef join(C, *args, **kwargs):\r\n        u = C('/'.join([str(arg).strip('/') for arg in args]), **kwargs)\r\n        return u", "response": "join a list of url elements and include any keyword arguments as a new URL"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchoosing a target from the available peers for a singular message.", "response": "def select_peer(peer_addrs, service, routing_id, method):\n    '''Choose a target from the available peers for a singular message\n\n    :param peer_addrs:\n        the ``(host, port)``s of the peers eligible to handle the RPC, and\n        possibly a ``None`` entry if this hub can handle it locally\n    :type peer_addrs: list\n    :param service: the service of the message\n    :type service: anything hash-able\n    :param routing_id: the routing_id of the message\n    :type routing_id: int\n    :param method: the message method name\n    :type method: string\n\n    :returns: one of the provided peer_addrs\n\n    There is no reason to call this method directly, but it may be useful to\n    override it in a Hub subclass.\n\n    This default implementation uses ``None`` if it is available (prefer local\n    handling), then falls back to a random selection.\n    '''\n    if any(p is None for p in peer_addrs):\n        return None\n    return random.choice(peer_addrs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, key=None, **params):\n\t\tself.params.update(**params)\n\t\tkey = key or self.stack_key\n\t\tif key is not None:\n\t\t\tself.current_times[key] = time()", "response": "initialize process timing for the current stack"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreports the total progress for the current stack optionally given the local fraction completed.", "response": "def report(self, fraction=None):\n\t\t\"\"\"report the total progress for the current stack, optionally given the local fraction completed.\n\t\tfraction=None: if given, used as the fraction of the local method so far completed.\n\t\truntimes=None: if given, used as the expected runtimes for the current stack.\n\t\t\"\"\"\n\t\tr = Dict()\n\t\tlocal_key = self.stack_key\n\t\tif local_key is None: return {}\n\t\truntimes = self.runtimes()\n\t\tfor key in self.stack_keys:\n\t\t\tif self.current_times.get(key) is None: \n\t\t\t\tself.start(key=key)\n\t\t\truntime = runtimes.get(key) or self.runtime(key)\n\t\t\tif key == local_key and fraction is not None:\n\t\t\t\tr[key] = fraction\n\t\t\telif runtime is not None:\n\t\t\t\tr[key] = (time() - self.current_times[key]) / runtime\n\t\treturn r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef finish(self):\n\t\tself.report(fraction=1.0)\n\t\tkey = self.stack_key\n\t\tif key is not None:\n\t\t\tif self.data.get(key) is None:\n\t\t\t\tself.data[key] = []\n\t\t\tstart_time = self.current_times.get(key) or time()\n\t\t\tself.data[key].append(Dict(runtime=time()-start_time, **self.params))", "response": "record the current stack process as finished"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_directive_header(self, sig):\n        domain = getattr(self, 'domain', 'py')\n        directive = getattr(self, 'directivetype', \"module\")\n        name = self.format_name()\n        self.add_line(u'.. %s:%s:: %s%s' % (domain, directive, name, sig),\n                      '<autodoc>')\n        if self.options.noindex:\n            self.add_line(u'   :noindex:', '<autodoc>')\n        if self.objpath:\n            # Be explicit about the module, this is necessary since .. class::\n            # etc. don't support a prepended module name\n            self.add_line(u'   :module: %s' % self.modname, '<autodoc>')", "response": "Add the directive header and options to the generated content."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitiate the connection to a proxying hub", "response": "def connect(self):\n        \"Initiate the connection to a proxying hub\"\n        log.info(\"connecting\")\n\n        # don't have the connection attempt reconnects, because when it goes\n        # down we are going to cycle to the next potential peer from the Client\n        self._peer = connection.Peer(\n                None, self._dispatcher, self._addrs.popleft(),\n                backend.Socket(), reconnect=False)\n        self._peer.start()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwait for all the active connection and their handshakes to finish.", "response": "def wait_connected(self, timeout=None):\n        '''Wait for connections to be made and their handshakes to finish\n\n        :param timeout:\n            maximum time to wait in seconds. with None, there is no timeout.\n        :type timeout: float or None\n\n        :returns:\n            ``True`` if all connections were made, ``False`` if one or more\n            failed.\n        '''\n        result = self._peer.wait_connected(timeout)\n        if not result:\n            if timeout is not None:\n                log.warn(\"connect wait timed out after %.2f seconds\" % timeout)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclosing the current failed connection and prepare for a new one", "response": "def reset(self):\n        \"Close the current failed connection and prepare for a new one\"\n        log.info(\"resetting client\")\n        rpc_client = self._rpc_client\n        self._addrs.append(self._peer.addr)\n        self.__init__(self._addrs)\n        self._rpc_client = rpc_client\n        self._dispatcher.rpc_client = rpc_client\n        rpc_client._client = weakref.ref(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shutdown(self):\n        'Close the hub connection'\n        log.info(\"shutting down\")\n        self._peer.go_down(reconnect=False, expected=True)", "response": "Close the hub connection"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a 1 - way message to the hub.", "response": "def publish(self, service, routing_id, method, args=None, kwargs=None,\n            broadcast=False):\n        '''Send a 1-way message\n\n        :param service: the service name (the routing top level)\n        :type service: anything hash-able\n        :param routing_id:\n            The id used for routing within the registered handlers of the\n            service.\n        :type routing_id: int\n        :param method: the method name to call\n        :type method: string\n        :param args: the positional arguments to send along with the request\n        :type args: tuple\n        :param kwargs: keyword arguments to send along with the request\n        :type kwargs: dict\n        :param broadcast:\n            if ``True``, send to every peer with a matching subscription\n        :type broadcast: bool\n\n        :returns: None. use 'rpc' methods for requests with responses.\n\n        :raises:\n            :class:`Unroutable <junction.errors.Unroutable>` if the client\n            doesn't have a connection to a hub\n        '''\n        if not self._peer.up:\n            raise errors.Unroutable()\n\n        self._dispatcher.send_proxied_publish(service, routing_id, method,\n                args or (), kwargs or {}, singular=not broadcast)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the number of peers that would handle a particular publish", "response": "def publish_receiver_count(\n            self, service, routing_id, method, timeout=None):\n        '''Get the number of peers that would handle a particular publish\n\n        This method will block until a response arrives\n\n        :param service: the service name\n        :type service: anything hash-able\n        :param routing_id:\n            the id used for narrowing within the service handlers\n        :type routing_id: int\n        :param method: the method name\n        :type method: string\n        :param timeout: maximum time to wait for the response\n        :type timeout: int, float or None\n\n        :raises:\n            - :class:`Unroutable <junction.errors.Unroutable>` if no peers are\n              registered to receive the message\n            - :class:`WaitTimeout <junction.errors.WaitTimeout>` if a timeout\n              was provided and it expires\n        '''\n        if not self._peer.up:\n            raise errors.Unroutable()\n\n        return self._rpc_client.recipient_count(self._peer,\n                const.MSG_TYPE_PUBLISH, service, routing_id, method).wait(\n                        timeout)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_rpc(self, service, routing_id, method, args=None, kwargs=None,\n            broadcast=False):\n        '''Send out an RPC request\n\n        :param service: the service name (the routing top level)\n        :type service: anything hash-able\n        :param routing_id:\n            The id used for routing within the registered handlers of the\n            service.\n        :type routing_id: int\n        :param method: the method name to call\n        :type method: string\n        :param args: the positional arguments to send along with the request\n        :type args: tuple\n        :param kwargs: keyword arguments to send along with the request\n        :type kwargs: dict\n        :param broadcast:\n            if ``True``, send to all peers with matching subscriptions\n        :type broadcast: bool\n\n        :returns:\n            a :class:`RPC <junction.futures.RPC>` object representing the\n            RPC and its future response.\n\n        :raises:\n            :class:`Unroutable <junction.errors.Unroutable>` if the client\n            doesn't have a connection to a hub\n        '''\n        if not self._peer.up:\n            raise errors.Unroutable()\n\n        return self._dispatcher.send_proxied_rpc(service, routing_id, method,\n                args or (), kwargs or {}, not broadcast)", "response": "Send out an RPC request to all connected peers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rpc_receiver_count(self, service, routing_id, method, timeout=None):\n        '''Get the number of peers that would handle a particular RPC\n\n        This method will block until a response arrives\n\n        :param service: the service name\n        :type service: anything hash-able\n        :param routing_id:\n            the id used for narrowing within the service handlers\n        :type routing_id: int\n        :param method: the method name\n        :type method: string\n\n        :returns:\n            the integer number of peers that would receive the described RPC\n\n        :raises:\n            - :class:`Unroutable <junction.errors.Unroutable>` if no peers are\n              registered to receive the message\n            - :class:`WaitTimeout <junction.errors.WaitTimeout>` if a timeout\n              was provided and it expires\n        '''\n        if not self._peer.up:\n            raise errors.Unroutable()\n\n        return self._rpc_client.recipient_count(self._peer,\n                const.MSG_TYPE_RPC_REQUEST, service, routing_id, method).wait(\n                        timeout)[0]", "response": "Get the number of peers that would handle a particular RPC message. This method blocks until a response arrives."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _headers(self, others={}):\n        headers = {\n            'Content-Type': 'application/json'\n        }\n\n        for p in others.keys():\n            headers[p] = others[p]\n        return headers", "response": "Return the default headers and others as necessary"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(config_file, configspec, server_mode=False, default_section='default_settings', list_values=True):\n    '''\n    Read the config file with spec validation\n    '''\n#    configspec = ConfigObj(path.join(path.abspath(path.dirname(__file__)), configspec),\n#                           encoding='UTF8',\n#                           interpolation='Template',\n#                           list_values=False,\n#                           _inspec=True)\n    config = ConfigObj(config_file,\n                       configspec=path.join(path.abspath(path.dirname(__file__)),\n                                            configspec),\n                                            list_values=list_values)\n    validation = config.validate(validate.Validator(), preserve_errors=True)\n\n    if validation == True:\n        config = dict(config)\n        for section in config:\n            if section != default_section:\n                if server_mode: # When it's a servers config file, retrieve the correct fqdn\n                    config[section]['availability'] = True\n                    if config[section]['custom_fqdn'] == None:\n                        config[section]['custom_fqdn'] = socket.getfqdn()\n                for option in config[section]:  # retrieve default configuration for missing values\n                    if config[section][option] == None:\n                        config[section][option] = config[default_section][option]\n\n        del(config[default_section])\n\n        return config\n    else:\n        raise ConfiguratorException(config_file, validation)", "response": "Read the config file with spec validation\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pcolor(text, color, indent=0):\n    esc_dict = {\n        \"black\": 30,\n        \"red\": 31,\n        \"green\": 32,\n        \"yellow\": 33,\n        \"blue\": 34,\n        \"magenta\": 35,\n        \"cyan\": 36,\n        \"white\": 37,\n        \"none\": -1,\n    }\n    if not isinstance(text, str):\n        raise RuntimeError(\"Argument `text` is not valid\")\n    if not isinstance(color, str):\n        raise RuntimeError(\"Argument `color` is not valid\")\n    if not isinstance(indent, int):\n        raise RuntimeError(\"Argument `indent` is not valid\")\n    color = color.lower()\n    if color not in esc_dict:\n        raise ValueError(\"Unknown color {color}\".format(color=color))\n    if esc_dict[color] != -1:\n        return \"\\033[{color_code}m{indent}{text}\\033[0m\".format(\n            color_code=esc_dict[color], indent=\" \" * indent, text=text\n        )\n    return \"{indent}{text}\".format(indent=\" \" * indent, text=text)", "response": "r Colorize a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string with a frame record pretty - formatted.", "response": "def strframe(obj, extended=False):\n    \"\"\"\n    Return a string with a frame record pretty-formatted.\n\n    The record is typically an item in a list generated by `inspect.stack()\n    <https://docs.python.org/3/library/inspect.html#inspect.stack>`_).\n\n    :param obj: Frame record\n    :type  obj: tuple\n\n    :param extended: Flag that indicates whether contents of the frame object\n                     are printed (True) or not (False)\n    :type  extended: boolean\n\n    :rtype:     string\n    \"\"\"\n    # Stack frame -> (frame object [0], filename [1], line number of current\n    # line [2], function name [3], list of lines of context from source\n    # code [4], index of current line within list [5])\n    fname = normalize_windows_fname(obj[1])\n    ret = list()\n    ret.append(pcolor(\"Frame object ID: {0}\".format(hex(id(obj[0]))), \"yellow\"))\n    ret.append(\"File name......: {0}\".format(fname))\n    ret.append(\"Line number....: {0}\".format(obj[2]))\n    ret.append(\"Function name..: {0}\".format(obj[3]))\n    ret.append(\"Context........: {0}\".format(obj[4]))\n    ret.append(\"Index..........: {0}\".format(obj[5]))\n    if extended:\n        ret.append(\"f_back ID......: {0}\".format(hex(id(obj[0].f_back))))\n        ret.append(\"f_builtins.....: {0}\".format(obj[0].f_builtins))\n        ret.append(\"f_code.........: {0}\".format(obj[0].f_code))\n        ret.append(\"f_globals......: {0}\".format(obj[0].f_globals))\n        ret.append(\"f_lasti........: {0}\".format(obj[0].f_lasti))\n        ret.append(\"f_lineno.......: {0}\".format(obj[0].f_lineno))\n        ret.append(\"f_locals.......: {0}\".format(obj[0].f_locals))\n        if hasattr(obj[0], \"f_restricted\"):  # pragma: no cover\n            ret.append(\"f_restricted...: {0}\".format(obj[0].f_restricted))\n        ret.append(\"f_trace........: {0}\".format(obj[0].f_trace))\n    return \"\\n\".join(ret)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets variable values via a dictionary mapping name to value.", "response": "def set(self, x):\n        \"\"\"\n        Set variable values via a dictionary mapping name to value.\n        \"\"\"\n        for name, value in iter(x.items()):\n            if hasattr(value, \"ndim\"):\n                if self[name].value.ndim < value.ndim:\n                    self[name].value.itemset(value.squeeze())\n                else:\n                    self[name].value = value\n            else:\n                self[name].value.itemset(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a subset of variables according to fixed.", "response": "def select(self, fixed):\n        \"\"\"\n        Return a subset of variables according to ``fixed``.\n        \"\"\"\n        names = [n for n in self.names() if self[n].isfixed == fixed]\n        return Variables({n: self[n] for n in names})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if this is a valid USPS tracking number.", "response": "def validate(self, tracking_number):\n        \"Return True if this is a valid USPS tracking number.\"\n        tracking_num = tracking_number[:-1].replace(' ', '')\n        odd_total = 0\n        even_total = 0\n        for ii, digit in enumerate(tracking_num):\n            if ii % 2:\n                odd_total += int(digit)\n            else:\n                even_total += int(digit)\n        total = odd_total + even_total * 3\n        check = ((total - (total % 10) + 10) - total) % 10\n        return (check == int(tracking_number[-1:]))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self, tracking_number):\n        \"Return True if this is a valid UPS tracking number.\"\n        tracking_num = tracking_number[2:-1]\n        odd_total = 0\n        even_total = 0\n\n        for ii, digit in enumerate(tracking_num.upper()):\n            try:\n                value = int(digit)\n            except ValueError:\n                value = int((ord(digit) - 63) % 10)\n            if (ii + 1) % 2:\n                odd_total += value\n            else:\n                even_total += value\n\n        total = odd_total + even_total * 2\n        check = ((total - (total % 10) + 10) - total) % 10\n        return (check == int(tracking_number[-1:]))", "response": "Return True if this is a valid UPS tracking number."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef track(self, tracking_number):\n        \"Track a UPS package by number. Returns just a delivery date.\"\n        resp = self.send_request(tracking_number)\n        return self.parse_response(resp)", "response": "Track a UPS package by number. Returns just a delivery date."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a matrix and wordlist from a. vec file.", "response": "def _load(pathtovector,\n              wordlist,\n              num_to_load=None,\n              truncate_embeddings=None,\n              sep=\" \"):\n        \"\"\"Load a matrix and wordlist from a .vec file.\"\"\"\n        vectors = []\n        addedwords = set()\n        words = []\n\n        try:\n            wordlist = set(wordlist)\n        except ValueError:\n            wordlist = set()\n\n        logger.info(\"Loading {0}\".format(pathtovector))\n\n        firstline = open(pathtovector).readline().strip()\n        try:\n            num, size = firstline.split(sep)\n            num, size = int(num), int(size)\n            logger.info(\"Vector space: {} by {}\".format(num, size))\n            header = True\n        except ValueError:\n            size = len(firstline.split(sep)) - 1\n            logger.info(\"Vector space: {} dim, # items unknown\".format(size))\n            word, rest = firstline.split(sep, 1)\n            # If the first line is correctly parseable, set header to False.\n            header = False\n\n        if truncate_embeddings is None or truncate_embeddings == 0:\n            truncate_embeddings = size\n\n        for idx, line in enumerate(open(pathtovector, encoding='utf-8')):\n\n            if header and idx == 0:\n                continue\n\n            word, rest = line.rstrip(\" \\n\").split(sep, 1)\n\n            if wordlist and word not in wordlist:\n                continue\n\n            if word in addedwords:\n                raise ValueError(\"Duplicate: {} on line {} was in the \"\n                                 \"vector space twice\".format(word, idx))\n\n            if len(rest.split(sep)) != size:\n                raise ValueError(\"Incorrect input at index {}, size \"\n                                 \"is {}, expected \"\n                                 \"{}\".format(idx+1,\n                                             len(rest.split(sep)), size))\n\n            words.append(word)\n            addedwords.add(word)\n            vectors.append(np.fromstring(rest, sep=sep)[:truncate_embeddings])\n\n            if num_to_load is not None and len(addedwords) >= num_to_load:\n                break\n\n        vectors = np.array(vectors).astype(np.float32)\n\n        logger.info(\"Loading finished\")\n        if wordlist:\n            diff = wordlist - addedwords\n            if diff:\n                logger.info(\"Not all items from your wordlist were in your \"\n                            \"vector space: {}.\".format(diff))\n\n        return vectors, words"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bow(self, tokens, remove_oov=False):\n        if remove_oov:\n            tokens = [x for x in tokens if x in self.items]\n\n        for t in tokens:\n            try:\n                yield self.items[t]\n            except KeyError:\n                if self.unk_index is None:\n                    raise ValueError(\"You supplied OOV items but didn't \"\n                                     \"provide the index of the replacement \"\n                                     \"glyph. Either set remove_oov to True, \"\n                                     \"or set unk_index to the index of the \"\n                                     \"item which replaces any OOV items.\")\n                yield self.unk_index", "response": "Create a BOW representation of a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform(self, corpus, remove_oov=False, norm=False):\n        return [self.vectorize(s, remove_oov=remove_oov, norm=norm)\n                for s in corpus]", "response": "Transform a corpus by repeated calls to vectorize."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef most_similar(self,\n                     items,\n                     num=10,\n                     batch_size=100,\n                     show_progressbar=False,\n                     return_names=True):\n        \"\"\"\n        Return the num most similar items to a given list of items.\n\n        Parameters\n        ----------\n        items : list of objects or a single object.\n            The items to get the most similar items to.\n        num : int, optional, default 10\n            The number of most similar items to retrieve.\n        batch_size : int, optional, default 100.\n            The batch size to use. 100 is a good default option. Increasing\n            the batch size may increase the speed.\n        show_progressbar : bool, optional, default False\n            Whether to show a progressbar.\n        return_names : bool, optional, default True\n            Whether to return the item names, or just the distances.\n\n        Returns\n        -------\n        sim : array\n            For each items in the input the num most similar items are returned\n            in the form of (NAME, DISTANCE) tuples. If return_names is false,\n            the returned list just contains distances.\n\n        \"\"\"\n        # This line allows users to input single items.\n        # We used to rely on string identities, but we now also allow\n        # anything hashable as keys.\n        # Might fail if a list of passed items is also in the vocabulary.\n        # but I can't think of cases when this would happen, and what\n        # user expectations are.\n        try:\n            if items in self.items:\n                items = [items]\n        except TypeError:\n            pass\n        x = np.stack([self.norm_vectors[self.items[x]] for x in items])\n\n        result = self._batch(x,\n                             batch_size,\n                             num+1,\n                             show_progressbar,\n                             return_names)\n\n        # list call consumes the generator.\n        return [x[1:] for x in result]", "response": "Returns the num most similar items to a given list of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef threshold(self,\n                  items,\n                  threshold=.5,\n                  batch_size=100,\n                  show_progressbar=False,\n                  return_names=True):\n        \"\"\"\n        Return all items whose similarity is higher than threshold.\n\n        Parameters\n        ----------\n        items : list of objects or a single object.\n            The items to get the most similar items to.\n        threshold : float, optional, default .5\n            The radius within which to retrieve items.\n        batch_size : int, optional, default 100.\n            The batch size to use. 100 is a good default option. Increasing\n            the batch size may increase the speed.\n        show_progressbar : bool, optional, default False\n            Whether to show a progressbar.\n        return_names : bool, optional, default True\n            Whether to return the item names, or just the distances.\n\n        Returns\n        -------\n        sim : array\n            For each items in the input the num most similar items are returned\n            in the form of (NAME, DISTANCE) tuples. If return_names is false,\n            the returned list just contains distances.\n\n        \"\"\"\n        # This line allows users to input single items.\n        # We used to rely on string identities, but we now also allow\n        # anything hashable as keys.\n        # Might fail if a list of passed items is also in the vocabulary.\n        # but I can't think of cases when this would happen, and what\n        # user expectations are.\n        try:\n            if items in self.items:\n                items = [items]\n        except TypeError:\n            pass\n        x = np.stack([self.norm_vectors[self.items[x]] for x in items])\n\n        result = self._threshold_batch(x,\n                                       batch_size,\n                                       threshold,\n                                       show_progressbar,\n                                       return_names)\n\n        # list call consumes the generator.\n        return [x[1:] for x in result]", "response": "This function returns all items whose similarity is higher than threshold."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nearest_neighbor(self,\n                         vectors,\n                         num=10,\n                         batch_size=100,\n                         show_progressbar=False,\n                         return_names=True):\n        \"\"\"\n        Find the nearest neighbors to some arbitrary vector.\n\n        This function is meant to be used in composition operations. The\n        most_similar function can only handle items that are in vocab, and\n        looks up their vector through a dictionary. Compositions, e.g.\n        \"King - man + woman\" are necessarily not in the vocabulary.\n\n        Parameters\n        ----------\n        vectors : list of arrays or numpy array\n            The vectors to find the nearest neighbors to.\n        num : int, optional, default 10\n            The number of most similar items to retrieve.\n        batch_size : int, optional, default 100.\n            The batch size to use. 100 is a good default option. Increasing\n            the batch size may increase speed.\n        show_progressbar : bool, optional, default False\n            Whether to show a progressbar.\n        return_names : bool, optional, default True\n            Whether to return the item names, or just the distances.\n\n        Returns\n        -------\n        sim : list of tuples.\n            For each item in the input the num most similar items are returned\n            in the form of (NAME, DISTANCE) tuples. If return_names is set to\n            false, only the distances are returned.\n\n        \"\"\"\n        vectors = np.array(vectors)\n        if np.ndim(vectors) == 1:\n            vectors = vectors[None, :]\n\n        result = []\n\n        result = self._batch(vectors,\n                             batch_size,\n                             num+1,\n                             show_progressbar,\n                             return_names)\n\n        return list(result)", "response": "This function returns the list of tuples that are the nearest neighbors to some arbitrary vector."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nearest_neighbor_threshold(self,\n                                   vectors,\n                                   threshold=.5,\n                                   batch_size=100,\n                                   show_progressbar=False,\n                                   return_names=True):\n        \"\"\"\n        Find the nearest neighbors to some arbitrary vector.\n\n        This function is meant to be used in composition operations. The\n        most_similar function can only handle items that are in vocab, and\n        looks up their vector through a dictionary. Compositions, e.g.\n        \"King - man + woman\" are necessarily not in the vocabulary.\n\n        Parameters\n        ----------\n        vectors : list of arrays or numpy array\n            The vectors to find the nearest neighbors to.\n        threshold : float, optional, default .5\n            The threshold within to retrieve items.\n        batch_size : int, optional, default 100.\n            The batch size to use. 100 is a good default option. Increasing\n            the batch size may increase speed.\n        show_progressbar : bool, optional, default False\n            Whether to show a progressbar.\n        return_names : bool, optional, default True\n            Whether to return the item names, or just the distances.\n\n        Returns\n        -------\n        sim : list of tuples.\n            For each item in the input the num most similar items are returned\n            in the form of (NAME, DISTANCE) tuples. If return_names is set to\n            false, only the distances are returned.\n\n        \"\"\"\n        vectors = np.array(vectors)\n        if np.ndim(vectors) == 1:\n            vectors = vectors[None, :]\n\n        result = []\n\n        result = self._threshold_batch(vectors,\n                                       batch_size,\n                                       threshold,\n                                       show_progressbar,\n                                       return_names)\n\n        return list(result)", "response": "This function returns the list of items that are nearest neighbors to some arbitrary vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _threshold_batch(self,\n                         vectors,\n                         batch_size,\n                         threshold,\n                         show_progressbar,\n                         return_names):\n        \"\"\"Batched cosine distance.\"\"\"\n        vectors = self.normalize(vectors)\n\n        # Single transpose, makes things faster.\n        reference_transposed = self.norm_vectors.T\n\n        for i in tqdm(range(0, len(vectors), batch_size),\n                      disable=not show_progressbar):\n\n            distances = vectors[i: i+batch_size].dot(reference_transposed)\n            # For safety we clip\n            distances = np.clip(distances, a_min=.0, a_max=1.0)\n            for lidx, dists in enumerate(distances):\n                indices = np.flatnonzero(dists >= threshold)\n                sorted_indices = indices[np.argsort(-dists[indices])]\n                if return_names:\n                    yield [(self.indices[d], dists[d])\n                           for d in sorted_indices]\n                else:\n                    yield list(dists[sorted_indices])", "response": "Yields the batched cosine distance of the given set of entries."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nnormalize a matrix of row vectors to unit length.", "response": "def normalize(vectors):\n        \"\"\"\n        Normalize a matrix of row vectors to unit length.\n\n        Contains a shortcut if there are no zero vectors in the matrix.\n        If there are zero vectors, we do some indexing tricks to avoid\n        dividing by 0.\n\n        Parameters\n        ----------\n        vectors : np.array\n            The vectors to normalize.\n\n        Returns\n        -------\n        vectors : np.array\n            The input vectors, normalized to unit length.\n\n        \"\"\"\n        if np.ndim(vectors) == 1:\n            norm = np.linalg.norm(vectors)\n            if norm == 0:\n                return np.zeros_like(vectors)\n            return vectors / norm\n\n        norm = np.linalg.norm(vectors, axis=1)\n\n        if np.any(norm == 0):\n\n            nonzero = norm > 0\n\n            result = np.zeros_like(vectors)\n\n            n = norm[nonzero]\n            p = vectors[nonzero]\n            result[nonzero] = p / n[:, None]\n\n            return result\n        else:\n            return vectors / norm[:, None]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vector_similarity(self, vector, items):\n        vector = self.normalize(vector)\n        items_vec = np.stack([self.norm_vectors[self.items[x]] for x in items])\n        return vector.dot(items_vec.T)", "response": "Compute the similarity between a vector and a set of items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the similarity between two sets of items.", "response": "def similarity(self, i1, i2):\n        \"\"\"\n        Compute the similarity between two sets of items.\n\n        Parameters\n        ----------\n        i1 : object\n            The first set of items.\n        i2 : object\n            The second set of item.\n\n        Returns\n        -------\n        sim : array of floats\n            An array of similarity scores between 1 and 0.\n\n        \"\"\"\n        try:\n            if i1 in self.items:\n                i1 = [i1]\n        except TypeError:\n            pass\n        try:\n            if i2 in self.items:\n                i2 = [i2]\n        except TypeError:\n            pass\n        i1_vec = np.stack([self.norm_vectors[self.items[x]] for x in i1])\n        i2_vec = np.stack([self.norm_vectors[self.items[x]] for x in i2])\n        return i1_vec.dot(i2_vec.T)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npruning the current reach instance by removing items.", "response": "def prune(self, wordlist):\n        \"\"\"\n        Prune the current reach instance by removing items.\n\n        Parameters\n        ----------\n        wordlist : list of str\n            A list of words to keep. Note that this wordlist need not include\n            all words in the Reach instance. Any words which are in the\n            wordlist, but not in the reach instance are ignored.\n\n        \"\"\"\n        # Remove duplicates\n        wordlist = set(wordlist).intersection(set(self.items.keys()))\n        indices = [self.items[w] for w in wordlist if w in self.items]\n        if self.unk_index is not None and self.unk_index not in indices:\n            raise ValueError(\"Your unknown item is not in your list of items. \"\n                             \"Set it to None before pruning, or pass your \"\n                             \"unknown item.\")\n        self.vectors = self.vectors[indices]\n        self.norm_vectors = self.norm_vectors[indices]\n        self.items = {w: idx for idx, w in enumerate(wordlist)}\n        self.indices = {v: k for k, v in self.items.items()}\n        if self.unk_index is not None:\n            self.unk_index = self.items[wordlist[self.unk_index]]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, path, write_header=True):\n        with open(path, 'w') as f:\n\n            if write_header:\n                f.write(u\"{0} {1}\\n\".format(str(self.vectors.shape[0]),\n                        str(self.vectors.shape[1])))\n\n            for i in range(len(self.items)):\n\n                w = self.indices[i]\n                vec = self.vectors[i]\n\n                f.write(u\"{0} {1}\\n\".format(w,\n                                            \" \".join([str(x) for x in vec])))", "response": "Save the current vector space in word2vec format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_fast_format(self, filename):\n        items, _ = zip(*sorted(self.items.items(), key=lambda x: x[1]))\n        items = {\"items\": items,\n                 \"unk_index\": self.unk_index,\n                 \"name\": self.name}\n\n        json.dump(items, open(\"{}_items.json\".format(filename), 'w'))\n        np.save(open(\"{}_vectors.npy\".format(filename), 'wb'), self.vectors)", "response": "Save a Reach instance in a fast format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a reach instance in fast format.", "response": "def load_fast_format(filename):\n        \"\"\"\n        Load a reach instance in fast format.\n\n        As described above, the fast format stores the words and vectors of the\n        Reach instance separately, and is drastically faster than loading from\n        .txt files.\n\n        Parameters\n        ----------\n        filename : str\n            The filename prefix from which to load. Note that this is not a\n            real filepath as such, but a shared prefix for both files.\n            In order for this to work, both {filename}_words.json and\n            {filename}_vectors.npy should be present.\n\n        \"\"\"\n        words, unk_index, name, vectors = Reach._load_fast(filename)\n        return Reach(vectors, words, unk_index=unk_index, name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_fast(filename):\n        it = json.load(open(\"{}_items.json\".format(filename)))\n        words, unk_index, name = it[\"items\"], it[\"unk_index\"], it[\"name\"]\n        vectors = np.load(open(\"{}_vectors.npy\".format(filename), 'rb'))\n        return words, unk_index, name, vectors", "response": "Sub for fast loader."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting a noisy sine curve and the fitting to it. Also presents the error and the error in the approximation of its first derivative (cosine curve) Usage example for benchmarking: $ time python sine.py --nhead 3 --ntail 3 --n-fit 500000 --n-data 50000 Usage example for plotting: $ python sine.py --nhead 1 --ntail 1 --plot", "response": "def demo_usage(n_data=50, n_fit=537, nhead=5, ntail=5, plot=False, alt=0):\n    \"\"\"\n    Plots a noisy sine curve and the fitting to it.\n    Also presents the error and the error in the\n    approximation of its first derivative (cosine curve)\n\n    Usage example for benchmarking:\n\n    $ time python sine.py --nhead 3 --ntail 3 --n-fit 500000 --n-data 50000\n\n    Usage example for plotting:\n\n    $ python sine.py --nhead 1 --ntail 1 --plot\n\n    \"\"\"\n\n    x0, xend = 0, 5\n    # shaky linspace -5% to +5% noise\n    x_data = (np.linspace(x0, xend, n_data) +\n              np.random.rand(n_data)*(xend-x0)/n_data/1.5)\n    y_data = np.sin(x_data) * (1.0+0.1*(np.random.rand(n_data)-0.5))\n\n    x_fit = np.linspace(x0, xend, n_fit)\n\n    # Edges behave badly, work around:\n    x_fit[0] = x_fit[0] + (x_fit[1]-x_fit[0])/2\n    x_fit[-1] = x_fit[-2]+(x_fit[-1]-x_fit[-2])/2\n\n    if alt:\n        y_fit = np.empty(n_fit)\n        dydx_fit = np.empty(n_fit)\n        for i, xf in enumerate(x_fit):\n            # get index j of first data point beyond xf\n            j = np.where(x_data > xf)[0][0]\n            lower_bound = max(0,   j-alt)\n            upper_bound = min(n_data-1, j+alt)\n            y_fit[i] = derivatives_at_point_by_finite_diff(\n                x_data[lower_bound:upper_bound],\n                y_data[lower_bound:upper_bound], xf, 0)\n            dydx_fit[i] = derivatives_at_point_by_finite_diff(\n                x_data[lower_bound:upper_bound],\n                y_data[lower_bound:upper_bound], xf, 1)[1]\n    else:\n        interp = interpolate_by_finite_diff(x_data, y_data, x_fit,\n                                            1, nhead, ntail)\n        y_fit = interp[:, 0]\n        dydx_fit = interp[:, 1]\n\n    if plot:\n        import matplotlib.pyplot as plt\n\n        plt.subplot(221)\n        plt.plot(x_data, y_data, 'x', label='Data points (sin)')\n        plt.plot(x_fit, y_fit, '-', label='Fitted curve (order=0)')\n        plt.plot(x_data, np.sin(x_data), '-', label='Analytic sin(x)')\n        plt.legend()\n\n        plt.subplot(222)\n        plt.plot(x_fit, y_fit-np.sin(x_fit), label='Error in order=0')\n        plt.legend()\n\n        plt.subplot(223)\n        plt.plot(x_fit, dydx_fit, '-', label='Fitted derivative (order=1)')\n        plt.plot(x_data, np.cos(x_data), '-', label='Analytic cos(x)')\n        plt.legend()\n\n        plt.subplot(224)\n        plt.plot(x_fit, dydx_fit-np.cos(x_fit), label='Error in order=1')\n        plt.legend()\n\n        plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef display_results(repo_name, contributors, api_len):\n    print(\"\\n\")\n\n    print(\"All Contributors:\")\n\n    # Sort and consolidate on Name\n    seen = []\n    for user in sorted(contributors, key=_sort_by_name):\n        if user.get(\"name\"):\n            key = user[\"name\"]\n        else:\n            key = user[\"user_name\"]\n        if key not in seen:\n            seen.append(key)\n            if key != user[\"user_name\"]:\n                print(\"%s (%s)\" % (user[\"name\"], user[\"user_name\"]))\n            else:\n                print(user[\"user_name\"])\n\n    print(\"\")\n\n    print(\"Repo: %s\" % repo_name)\n    print(\"GitHub Contributors: %s\" % api_len)\n    print(\"All Contributors: %s \ud83d\udc4f\" % len(seen))", "response": "Display the results of the contributors and the number of contributors in the repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_json(uri):\n    response = requests.get(API + uri, headers=HEADERS)\n\n    limit = int(response.headers.get(\"x-ratelimit-remaining\"))\n    if limit == 0:\n        sys.stdout.write(\"\\n\")\n        message = \"You have run out of GitHub request tokens. \"\n\n        if int(response.headers.get(\"x-ratelimit-limit\")) == 60:\n            message += \"Set a GITHUB_TOKEN to increase your limit to 5000/hour. \"\n\n        wait_seconds = int(response.headers.get(\"x-ratelimit-reset\")) - int(time.time())\n        wait_minutes = math.ceil(wait_seconds / 60)\n        message += \"Try again in ~%d minutes. \" % wait_minutes\n\n        if \"--wait-for-reset\" in sys.argv:\n            progress_message(message.replace(\"Try \", \"Trying \"))\n            time.sleep(wait_seconds + 1)\n            progress_message(\"Resuming\")\n            return get_json(uri)\n        else:\n            raise ValueError(message)\n\n    progress()\n    return response.json()", "response": "Get a JSON object from GitHub."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef api_walk(uri, per_page=100, key=\"login\"):\n    page = 1\n    result = []\n\n    while True:\n        response = get_json(uri + \"?page=%d&per_page=%d\" % (page, per_page))\n        if len(response) == 0:\n            break\n        else:\n            page += 1\n            for r in response:\n                if key == USER_LOGIN:\n                    result.append(user_login(r))\n                else:\n                    result.append(r[key])\n\n    return list(set(result))", "response": "This function walks all the pages until there s no more content"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reducejson(j):\n\n    authors = []\n\n    for key in j[\"data\"][\"repository\"][\"commitComments\"][\"edges\"]:\n            authors.append(key[\"node\"][\"author\"])\n\n    for key in j[\"data\"][\"repository\"][\"issues\"][\"nodes\"]:\n            authors.append(key[\"author\"])\n            for c in key[\"comments\"][\"nodes\"]:\n                    authors.append(c[\"author\"])\n            \n    for key in j[\"data\"][\"repository\"][\"pullRequests\"][\"edges\"]:\n            authors.append(key[\"node\"][\"author\"])\n            for c in key[\"node\"][\"comments\"][\"nodes\"]:\n                    authors.append(c[\"author\"])\n\n    unique = list({v['login']:v for v in authors if v is not None}.values())\n    return unique", "response": "Reduce the JSON structure of a single object into a single object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a path to a dotted path.", "response": "def stringify_with_dot_if_path(x):\n    '''Pathlib never renders a leading './' in front of a local path. That's an\n    issue because on POSIX subprocess.py (like bash) won't execute scripts in\n    the current directory without it. In the same vein, we also don't want\n    Path('echo') to match '/usr/bin/echo' from the $PATH. To work around both\n    issues, we explicitly join a leading dot to any relative pathlib path.'''\n    if isinstance(x, PurePath):\n        # Note that join does nothing if the path is absolute.\n        return os.path.join('.', str(x))\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef safe_popen(*args, **kwargs):\n    '''This wrapper works around two major deadlock issues to do with pipes.\n    The first is that, before Python 3.2 on POSIX systems, os.pipe() creates\n    inheritable file descriptors, which leak to all child processes and prevent\n    reads from reaching EOF. The workaround for this is to set close_fds=True\n    on POSIX, which was not the default in those versions. See PEP 0446 for\n    many details.\n\n    The second issue arises on Windows, where we're not allowed to set\n    close_fds=True while also setting stdin/stdout/stderr. Descriptors from\n    os.pipe() on Windows have never been inheritable, so it would seem that\n    we're safe. However, the Windows implementation of subprocess.Popen()\n    creates temporary inheritable copies of its descriptors, and these can\n    leak. The workaround for this is to protect Popen() with a global lock. See\n    https://bugs.python.org/issue25565.'''\n\n    close_fds = (os.name != 'nt')\n    with popen_lock:\n        return subprocess.Popen(*args, close_fds=close_fds, **kwargs)", "response": "Wrapper for subprocess. Popen that does not lock popen_lock."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self):\n        '''Execute the expression and return a Result, which includes the exit\n        status and any captured output. Raise an exception if the status is\n        non-zero.'''\n        with spawn_output_reader() as (stdout_capture, stdout_thread):\n            with spawn_output_reader() as (stderr_capture, stderr_thread):\n                context = starter_iocontext(stdout_capture, stderr_capture)\n                status = self._exec(context)\n        stdout_bytes = stdout_thread.join()\n        stderr_bytes = stderr_thread.join()\n        result = Result(status.code, stdout_bytes, stderr_bytes)\n        if is_checked_error(status):\n            raise StatusError(result, self)\n        return result", "response": "Execute the expression and return a Result which includes the exitStatus status and any captured output. Raise an exception if the status is\n        non - zero."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute the expression and capture its output and return it as a string.", "response": "def read(self):\n        '''Execute the expression and capture its output, similar to backticks\n        or $() in the shell. This is a wrapper around run() which captures\n        stdout, decodes it, trims it, and returns it directly.'''\n        result = self.stdout_capture().run()\n        stdout_str = decode_with_universal_newlines(result.stdout)\n        return stdout_str.rstrip('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        '''Equivalent to `run`, but instead of blocking the current thread,\n        return a WaitHandle that doesn't block until `wait` is called. This is\n        currently implemented with a simple background thread, though in theory\n        it could avoid using threads in most cases.'''\n        thread = ThreadWithReturn(self.run)\n        thread.start()\n        return WaitHandle(thread)", "response": "Equivalent to run but instead of blocking the current thread returns a WaitHandle that doesn t block until wait is called."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes a command at the device using the RESTful API", "response": "def _exec(self, cmd, url, json_data=None):\n        \"\"\"\n        execute a command at the device using the RESTful API\n\n        :param str cmd: one of the REST commands, e.g. GET or POST\n        :param str url: URL of the REST API the command should be applied to\n        :param dict json_data: json data that should be attached to the command\n        \"\"\"\n        assert(cmd in (\"GET\", \"POST\", \"PUT\", \"DELETE\"))\n        assert(self.dev is not None)\n\n        if json_data is None:\n            json_data = {}\n\n        # add device address to the URL\n        url = url.format(self.dev[\"ipv4_internal\"])\n\n        # set basic authentication\n        auth = HTTPBasicAuth(\"dev\", self.dev[\"api_key\"])\n\n        # execute HTTP request\n        res = None\n        if cmd == \"GET\":\n            res = self._local_session.session.get(\n                url, auth=auth, verify=False\n            )\n\n        elif cmd == \"POST\":\n            res = self._local_session.session.post(\n                url, auth=auth, json=json_data, verify=False\n            )\n\n        elif cmd == \"PUT\":\n            res = self._local_session.session.put(\n                url, auth=auth, json=json_data, verify=False\n            )\n\n        elif cmd == \"DELETE\":\n            res = self._local_session.session.delete(\n                url, auth=auth, verify=False\n            )\n\n        if res is not None:\n            # raise an exception on error\n            res.raise_for_status()\n\n        return res.json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the current device", "response": "def set_device(self, dev):\n        \"\"\"\n        set the current device (that will be used for following API calls)\n\n        :param dict dev: device that should be used for the API calls\n                         (can be obtained via get_devices function)\n        \"\"\"\n        log.debug(\"setting device to '{}'\".format(dev))\n        self.dev = dev\n        self.set_apps_list()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the first widget id for the given package_name", "response": "def _get_widget_id(self, package_name):\n        \"\"\"\n        returns widget_id for given package_name does not care\n        about multiple widget ids at the moment, just picks the first\n\n        :param str package_name: package to check for\n        :return: id of first widget which belongs to the given package_name\n        :rtype: str\n        \"\"\"\n        widget_id = \"\"\n        for app in self.get_apps_list():\n            if app.package == package_name:\n                widget_id = list(app.widgets.keys())[0]\n\n        return widget_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_user(self):\n        log.debug(\"getting user information from LaMetric cloud...\")\n        _, url = CLOUD_URLS[\"get_user\"]\n        res = self._cloud_session.session.get(url)\n        if res is not None:\n            # raise an exception on error\n            res.raise_for_status()\n\n        return res.json()", "response": "get the user details via the cloud"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_devices(self, force_reload=False, save_devices=True):\n        if (\n            (not os.path.exists(self._devices_filename)) or\n            (force_reload is True)\n        ):\n            # -- load devices from LaMetric cloud --\n            log.debug(\"getting devices from LaMetric cloud...\")\n            _, url = CLOUD_URLS[\"get_devices\"]\n            res = self._cloud_session.session.get(url)\n            if res is not None:\n                # raise an exception on error\n                res.raise_for_status()\n\n            # store obtained devices internally\n            self._devices = res.json()\n            if save_devices is True:\n                # save obtained devices to the local file\n                self.save_devices()\n\n            return self._devices\n\n        else:\n            # -- load devices from local file --\n            log.debug(\n                \"getting devices from '{}'...\".format(self._devices_filename)\n            )\n            return self.load_devices()", "response": "get all devices that are linked to the user"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_devices(self):\n        log.debug(\"saving devices to ''...\".format(self._devices_filename))\n        if self._devices != []:\n            with codecs.open(self._devices_filename, \"wb\", \"utf-8\") as f:\n                json.dump(self._devices, f)", "response": "save the list of devices that have been obtained from LaMetric to a local file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_endpoint_map(self):\n        log.debug(\"getting end points...\")\n        cmd, url = DEVICE_URLS[\"get_endpoint_map\"]\n        return self._exec(cmd, url)", "response": "returns API version and endpoint map"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload stored devices from the local file", "response": "def load_devices(self):\n        \"\"\"\n        load stored devices from the local file\n        \"\"\"\n        self._devices = []\n        if os.path.exists(self._devices_filename):\n            log.debug(\n                \"loading devices from '{}'...\".format(self._devices_filename)\n            )\n            with codecs.open(self._devices_filename, \"rb\", \"utf-8\") as f:\n                self._devices = json.load(f)\n\n        return self._devices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the full device state", "response": "def get_device_state(self):\n        \"\"\"\n        returns the full device state\n        \"\"\"\n        log.debug(\"getting device state...\")\n        cmd, url = DEVICE_URLS[\"get_device_state\"]\n        return self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_notification(\n        self, model, priority=\"warning\", icon_type=None, lifetime=None\n    ):\n        \"\"\"\n        sends new notification to the device\n\n        :param Model model: an instance of the Model class that should be used\n        :param str priority: the priority of the notification\n                             [info, warning or critical] (default: warning)\n        :param str icon_type: the icon type of the notification\n                              [none, info or alert] (default: None)\n        :param int lifetime: the lifetime of the notification in ms\n                             (default: 2 min)\n        \"\"\"\n        assert(priority in (\"info\", \"warning\", \"critical\"))\n        assert(icon_type in (None, \"none\", \"info\", \"alert\"))\n        assert((lifetime is None) or (lifetime > 0))\n\n        log.debug(\"sending notification...\")\n\n        cmd, url = DEVICE_URLS[\"send_notification\"]\n\n        json_data = {\"model\": model.json(), \"priority\": priority}\n\n        if icon_type is not None:\n            json_data[\"icon_type\"] = icon_type\n        if lifetime is not None:\n            json_data[\"lifetime\"] = lifetime\n\n        return self._exec(cmd, url, json_data=json_data)", "response": "sends a new notification to the device"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_notifications(self):\n        log.debug(\"getting notifications in queue...\")\n        cmd, url = DEVICE_URLS[\"get_notifications_queue\"]\n        return self._exec(cmd, url)", "response": "returns the list of all notifications in queue"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the current notification", "response": "def get_current_notification(self):\n        \"\"\"\n        returns the current notification (i.e. the one that is visible)\n        \"\"\"\n        log.debug(\"getting visible notification...\")\n        cmd, url = DEVICE_URLS[\"get_current_notification\"]\n        return self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_notification(self, notification_id):\n        log.debug(\"getting notification '{}'...\".format(notification_id))\n        cmd, url = DEVICE_URLS[\"get_notification\"]\n        return self._exec(cmd, url.replace(\":id\", notification_id))", "response": "get a specific notification by given ID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning information about the display including brightness screensaver etc.", "response": "def get_display(self):\n        \"\"\"\n        returns information about the display, including\n        brightness, screensaver etc.\n        \"\"\"\n        log.debug(\"getting display information...\")\n        cmd, url = DEVICE_URLS[\"get_display\"]\n        return self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nallow to change display state", "response": "def set_display(self, brightness=100, brightness_mode=\"auto\"):\n        \"\"\"\n        allows to modify display state (change brightness)\n\n        :param int brightness: display brightness [0, 100] (default: 100)\n        :param str brightness_mode: the brightness mode of the display\n                                    [auto, manual] (default: auto)\n        \"\"\"\n        assert(brightness_mode in (\"auto\", \"manual\"))\n        assert(brightness in range(101))\n\n        log.debug(\"setting display information...\")\n\n        cmd, url = DEVICE_URLS[\"set_display\"]\n        json_data = {\n            \"brightness_mode\": brightness_mode,\n            \"brightness\": brightness\n        }\n\n        return self._exec(cmd, url, json_data=json_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_screensaver(\n        self, mode, is_mode_enabled, start_time=None, end_time=None,\n        is_screensaver_enabled=True\n    ):\n        \"\"\"\n        set the display's screensaver mode\n\n        :param str mode: mode of the screensaver\n                         [when_dark, time_based]\n        :param bool is_mode_enabled: specifies if mode is enabled or disabled\n        :param str start_time: start time, only used in time_based mode\n                               (format: %H:%M:%S)\n        :param str end_time: end time, only used in time_based mode\n                             (format: %H:%M:%S)\n        :param bool is_screensaver_enabled: is overall screensaver turned on\n                                            overrules mode specific settings\n        \"\"\"\n        assert(mode in (\"when_dark\", \"time_based\"))\n\n        log.debug(\"setting screensaver to '{}'...\".format(mode))\n\n        cmd, url = DEVICE_URLS[\"set_display\"]\n        json_data = {\n            \"screensaver\": {\n                \"enabled\": is_screensaver_enabled,\n                \"mode\": mode,\n                \"mode_params\": {\n                    \"enabled\": is_mode_enabled\n                },\n            }\n        }\n        if mode == \"time_based\":\n            # TODO: add time checks\n            assert((start_time is not None) and (end_time is not None))\n            json_data[\"screensaver\"][\"mode_params\"][\"start_time\"] = start_time\n            json_data[\"screensaver\"][\"mode_params\"][\"end_time\"] = end_time\n\n        return self._exec(cmd, url, json_data=json_data)", "response": "set the display s screensaver mode"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the current volume", "response": "def get_volume(self):\n        \"\"\"\n        returns the current volume\n        \"\"\"\n        log.debug(\"getting volumne...\")\n        cmd, url = DEVICE_URLS[\"get_volume\"]\n        return self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nallows to change the volume for the current device", "response": "def set_volume(self, volume=50):\n        \"\"\"\n        allows to change the volume\n\n        :param int volume: volume to be set for the current device\n                           [0..100] (default: 50)\n        \"\"\"\n        assert(volume in range(101))\n\n        log.debug(\"setting volume...\")\n\n        cmd, url = DEVICE_URLS[\"set_volume\"]\n        json_data = {\n            \"volume\": volume,\n        }\n        return self._exec(cmd, url, json_data=json_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the bluetooth state", "response": "def get_bluetooth_state(self):\n        \"\"\"\n        returns the bluetooth state\n        \"\"\"\n        log.debug(\"getting bluetooth state...\")\n        cmd, url = DEVICE_URLS[\"get_bluetooth_state\"]\n        return self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_bluetooth(self, active=None, name=None):\n        assert(active is not None or name is not None)\n\n        log.debug(\"setting bluetooth state...\")\n\n        cmd, url = DEVICE_URLS[\"set_bluetooth\"]\n        json_data = {}\n        if name is not None:\n            json_data[\"name\"] = name\n        if active is not None:\n            json_data[\"active\"] = active\n\n        return self._exec(cmd, url, json_data=json_data)", "response": "allows to activate or deactivate bluetooth and change the name\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_wifi_state(self):\n        log.debug(\"getting wifi state...\")\n        cmd, url = DEVICE_URLS[\"get_wifi_state\"]\n        return self._exec(cmd, url)", "response": "returns the current Wi - Fi state of the device connected to\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_apps_list(self):\n        log.debug(\"getting apps and setting them in the internal app list...\")\n\n        cmd, url = DEVICE_URLS[\"get_apps_list\"]\n        result = self._exec(cmd, url)\n\n        self.available_apps = [\n            AppModel(result[app])\n            for app in result\n        ]", "response": "gets installed apps and puts them into the available_apps list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef switch_to_app(self, package):\n        log.debug(\"switching to app '{}'...\".format(package))\n        cmd, url = DEVICE_URLS[\"switch_to_app\"]\n        widget_id = self._get_widget_id(package)\n\n        url = url.format('{}', package, widget_id)\n\n        self.result = self._exec(cmd, url)", "response": "Switches the app that is specified by package. Selects the first app that is found in the app list\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nswitching to the next app", "response": "def switch_to_next_app(self):\n        \"\"\"\n        switches to the next app\n        \"\"\"\n        log.debug(\"switching to next app...\")\n        cmd, url = DEVICE_URLS[\"switch_to_next_app\"]\n        self.result = self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nactivating the widget of the given package", "response": "def activate_widget(self, package):\n        \"\"\"\n        activate the widget of the given package\n\n        :param str package: name of the package\n        \"\"\"\n        cmd, url = DEVICE_URLS[\"activate_widget\"]\n\n        # get widget id for the package\n        widget_id = self._get_widget_id(package)\n        url = url.format('{}', package, widget_id)\n\n        self.result = self._exec(cmd, url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _app_exec(self, package, action, params=None):\n        # get list of possible commands from app.actions\n        allowed_commands = []\n        for app in self.get_apps_list():\n            if app.package == package:\n                allowed_commands = list(app.actions.keys())\n                break\n\n        # check if action is in this list\n        assert(action in allowed_commands)\n\n        cmd, url = DEVICE_URLS[\"do_action\"]\n        # get widget id for the package\n        widget_id = self._get_widget_id(package)\n        url = url.format('{}', package, widget_id)\n\n        json_data = {\"id\": action}\n        if params is not None:\n            json_data[\"params\"] = params\n\n        self.result = self._exec(cmd, url, json_data=json_data)", "response": "This method is used to execute a specific action on all apps with the same package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the alarm clock alid", "response": "def alarm_set(self, time, wake_with_radio=False):\n        \"\"\"\n        set the alarm clock\n\n        :param str time: time of the alarm (format: %H:%M:%S)\n        :param bool wake_with_radio: if True, radio will be used for the alarm\n                                     instead of beep sound\n        \"\"\"\n        # TODO: check for correct time format\n        log.debug(\"alarm => set...\")\n        params = {\n            \"enabled\": True,\n            \"time\": time,\n            \"wake_with_radio\": wake_with_radio\n        }\n        self._app_exec(\"com.lametric.clock\", \"clock.alarm\", params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the countdown for a given time period", "response": "def countdown_set(self, duration, start_now):\n        \"\"\"\n        set the countdown\n\n        :param str duration:\n        :param str start_now:\n        \"\"\"\n        log.debug(\"countdown => set...\")\n        params = {'duration': duration, 'start_now': start_now}\n        self._app_exec(\n            \"com.lametric.countdown\", \"countdown.configure\", params\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls external script. :param includes: testcase's includes :param variables: variables :return: script's output", "response": "def action(self, includes: dict, variables: dict) -> tuple:\n        \"\"\"\n        Call external script.\n\n        :param includes: testcase's includes\n        :param variables: variables\n        :return: script's output\n        \"\"\"\n        json_args = fill_template_str(json.dumps(self.data), variables)\n        p = subprocess.Popen([self.module, json_args], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        if p.wait() == 0:\n            out = p.stdout.read().decode()\n            debug(out)\n            return variables, json.loads(out)\n        else:\n            out = p.stdout.read().decode()\n            warning(out)\n            raise Exception('Execution failed.')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset credentials and reset the session", "response": "def set_credentials(self, client_id=None, client_secret=None):\n        \"\"\"\n        set given credentials and reset the session\n        \"\"\"\n        self._client_id = client_id\n        self._client_secret = client_secret\n\n        # make sure to reset session due to credential change\n        self._session = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_session(self, get_token=True):\n        if (self._client_id is None) or (self._client_secret is None):\n            sys.exit(\n                \"Please make sure to set the client id and client secret \"\n                \"via the constructor, the environment variables or the config \"\n                \"file; otherwise, the LaMetric cloud cannot be accessed. \"\n                \"Abort!\"\n            )\n\n        self._session = OAuth2Session(\n            client=BackendApplicationClient(client_id=self._client_id)\n        )\n\n        if get_token is True:\n            # get oauth token\n            self.get_token()", "response": "init a new oauth2 session that is required to access the cloud"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets current oauth token", "response": "def get_token(self):\n        \"\"\"\n        get current oauth token\n        \"\"\"\n        self.token = self._session.fetch_token(\n            token_url=CLOUD_URLS[\"get_token\"][1],\n            client_id=self._client_id,\n            client_secret=self._client_secret\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse this method to get simple input as python object with all templates filled in", "response": "def simple_input(self, variables):\n        \"\"\"\n        Use this method to get simple input as python object, with all\n        templates filled in\n\n        :param variables:\n        :return: python object\n\n        \"\"\"\n        json_args = fill_template_str(json.dumps(self.data), variables)\n        return try_get_objects(json_args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self):\n        if not self.exists():\n            # create new empyt config file based on template\n            self.config.add_section(\"lametric\")\n            self.config.set(\"lametric\", \"client_id\", \"\")\n            self.config.set(\"lametric\", \"client_secret\", \"\")\n\n            # save new config\n            self.save()\n\n            # stop here, so user can set his config\n            sys.exit(\n                \"An empty config file '{}' has been created. Please set \"\n                \"the corresponding LaMetric API credentials.\".format(\n                    self._filename\n                )\n            )", "response": "Creates an empty configuration file based on template\n            and saves it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving current config to the file", "response": "def save(self):\n        \"\"\"\n        save current config to the file\n        \"\"\"\n        with open(self._filename, \"w\") as f:\n            self.config.write(f)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rate_limit_wait(self):\n        if self._rate_limit_dt and self._last_query is not None:\n            dt = time.time() - self._last_query\n            wait = self._rate_limit_dt - dt\n            if wait > 0:\n                time.sleep(wait)", "response": "Sleep if rate limiting is required based on current time and last query."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery a route from a Shapely line to a Shapely point.", "response": "def route(self, arg, destination=None, waypoints=None, raw=False, **kwargs):\n        \"\"\"\n        Query a route.\n\n        route(locations): points can be\n            - a sequence of locations\n            - a Shapely LineString\n        route(origin, destination, waypoints=None)\n             - origin and destination are a single destination\n             - waypoints are the points to be inserted between the\n               origin and destination\n             \n             If waypoints is specified, destination must also be specified\n\n        Each location can be:\n            - string (will be geocoded by the routing provider. Not all\n              providers accept this as input)\n            - (longitude, latitude) sequence (tuple, list, numpy array, etc.)\n            - Shapely Point with x as longitude, y as latitude\n\n        Additional parameters\n        ---------------------\n        raw : bool, default False\n            Return the raw json dict response from the service\n\n        Returns\n        -------\n        list of Route objects\n        If raw is True, returns the json dict instead of converting to Route\n        objects\n\n        Examples\n        --------\n        mq = directions.Mapquest(key)\n        routes = mq.route('1 magazine st. cambridge, ma', \n                          'south station boston, ma')\n\n        routes = mq.route('1 magazine st. cambridge, ma', \n                          'south station boston, ma', \n                          waypoints=['700 commonwealth ave. boston, ma'])\n\n        # Uses each point in the line as a waypoint. There is a limit to the\n        # number of waypoints for each service. Consult the docs.\n        line = LineString(...)\n        routes = mq.route(line)  \n\n        # Feel free to mix different location types\n        routes = mq.route(line.coords[0], 'south station boston, ma',\n                          waypoints=[(-71.103972, 42.349324)])\n\n        \"\"\"\n        points = _parse_points(arg, destination, waypoints)\n        if len(points) < 2:\n            raise ValueError('You must specify at least 2 points')\n\n        self.rate_limit_wait()\n        data = self.raw_query(points, **kwargs)\n        self._last_query = time.time()\n\n        if raw:\n            return data\n        return self.format_output(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_geojson(cls, data):\n        properties = data['properties']\n        distance = properties.pop('distance')\n        duration = properties.pop('duration')\n\n        maneuvers = []\n        for feature in data['features']:\n            geom = feature['geometry']\n            if geom['type'] == 'LineString':\n                coords = geom['coordinates']\n            else:\n                maneuvers.append(Maneuver.from_geojson(feature))\n\n        return Route(coords, distance, duration, maneuvers, **properties)", "response": "Return a Route object from a GeoJSON dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prepare_modules(module_paths: list, available: dict) -> dict:\n    indexed = {}\n    for path in module_paths:\n        if not os.path.exists(path) and path not in available:\n            err = 'No such path: ' + path\n            error(err)\n        else:\n            for f in os.listdir(path):\n                mod_path = join(path, f)\n                if f in indexed:\n                    warning('Override ' + indexed[f] + ' with ' + mod_path)\n                indexed[f] = mod_path\n    return indexed", "response": "Scan all paths for external modules and form key - value dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discover_upnp_devices(\n        self, st=\"upnp:rootdevice\", timeout=2, mx=1, retries=1\n    ):\n        \"\"\"\n        sends an SSDP discovery packet to the network and collects\n        the devices that replies to it. A dictionary is returned\n        using the devices unique usn as key\n        \"\"\"\n        # prepare UDP socket to transfer the SSDP packets\n        s = socket.socket(\n            socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP\n        )\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)\n        s.settimeout(timeout)\n\n        # prepare SSDP discover message\n        msg = SSDPDiscoveryMessage(mx=mx, st=st)\n\n        # try to get devices with multiple retries in case of failure\n        devices = {}\n        for _ in range(retries):\n            # send SSDP discovery message\n            s.sendto(msg.bytes, SSDP_MULTICAST_ADDR)\n\n            devices = {}\n            try:\n                while True:\n                    # parse response and store it in dict\n                    r = SSDPResponse(s.recvfrom(65507))\n                    devices[r.usn] = r\n\n            except socket.timeout:\n                break\n\n        return devices", "response": "Send an SSDP discovery packet to the network and collects the devices that replies to it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a dict of devices that contain the given model name.", "response": "def get_filtered_devices(\n        self, model_name, device_types=\"upnp:rootdevice\", timeout=2\n    ):\n        \"\"\"\n        returns a dict of devices that contain the given model name\n        \"\"\"\n\n        # get list of all UPNP devices in the network\n        upnp_devices = self.discover_upnp_devices(st=device_types)\n\n        # go through all UPNP devices and filter wanted devices\n        filtered_devices = collections.defaultdict(dict)\n        for dev in upnp_devices.values():\n            try:\n                # download XML file with information about the device\n                # from the device's location\n                r = requests.get(dev.location, timeout=timeout)\n\n                if r.status_code == requests.codes.ok:\n                    # parse returned XML\n                    root = ET.fromstring(r.text)\n\n                    # add shortcut for XML namespace to access sub nodes\n                    ns = {\"upnp\": \"urn:schemas-upnp-org:device-1-0\"}\n\n                    # get device element\n                    device = root.find(\"upnp:device\", ns)\n\n                    if model_name in device.find(\n                        \"upnp:modelName\", ns\n                    ).text:\n                        # model name is wanted => add to list\n\n                        # get unique UDN of the device that is used as key\n                        udn = device.find(\"upnp:UDN\", ns).text\n\n                        # add url base\n                        url_base = root.find(\"upnp:URLBase\", ns)\n                        if url_base is not None:\n                            filtered_devices[udn][\n                                \"URLBase\"\n                            ] = url_base.text\n\n                        # add interesting device attributes and\n                        # use unique UDN as key\n                        for attr in (\n                            \"deviceType\", \"friendlyName\", \"manufacturer\",\n                            \"manufacturerURL\", \"modelDescription\",\n                            \"modelName\", \"modelNumber\"\n                        ):\n                            el = device.find(\"upnp:%s\" % attr, ns)\n                            if el is not None:\n                                filtered_devices[udn][\n                                    attr\n                                ] = el.text.strip()\n\n            except ET.ParseError:\n                # just skip devices that are invalid xml\n                pass\n            except requests.exceptions.ConnectTimeout:\n                # just skip devices that are not replying in time\n                print(\"Timeout for '%s'. Skipping.\" % dev.location)\n\n        return filtered_devices"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lazy_map(data_processor, data_generator, n_cpus=1, stepsize=None):\n    if not n_cpus:\n        n_cpus = mp.cpu_count()\n    elif n_cpus < 0:\n        n_cpus = mp.cpu_count() - n_cpus\n\n    if stepsize is None:\n        stepsize = n_cpus\n\n    results = []\n\n    with mp.Pool(processes=n_cpus) as p:\n        while True:\n            r = p.map(data_processor, islice(data_generator, stepsize))\n            if r:\n                results.extend(r)\n            else:\n                break\n    return results", "response": "A variant of multiprocessing. Pool. map that supports lazy evaluation of a single object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lazy_imap(data_processor, data_generator, n_cpus=1, stepsize=None):\n    if not n_cpus:\n        n_cpus = mp.cpu_count()\n    elif n_cpus < 0:\n        n_cpus = mp.cpu_count() - n_cpus\n\n    if stepsize is None:\n        stepsize = n_cpus\n\n    with mp.Pool(processes=n_cpus) as p:\n        while True:\n            r = p.map(data_processor, islice(data_generator, stepsize))\n            if r:\n                yield r\n            else:\n                break", "response": "A variant of multiprocessing. Pool. imap that supports lazy evaluation of a single object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_variables(func):\n\n    @wraps(func)\n    def wrapper(self, *args, **kwargs):\n        result = func(self, *args, **kwargs)\n        if isinstance(result, tuple):\n            return self.process_register(result[0], result[1])\n        else:\n            return self.process_register(result)\n\n    return wrapper", "response": "Decorator to update variables of the\n ArcGIS application."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the properties of the app model by the given data dict", "response": "def _set_properties(self, data):\n        \"\"\"\n        set the properties of the app model by the given data dict\n        \"\"\"\n        for property in data.keys():\n            if property in vars(self):\n                setattr(self, property, data[property])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting long description from README. rst file", "response": "def get_long_description():\n    \"\"\"\n    get long description from README.rst file\n    \"\"\"\n    with codecs.open(os.path.join(here, \"README.rst\"), \"r\", \"utf-8\") as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_order_by(model, order_by):\n    # the list of filters for the models\n    out = []\n    # for each attribute we have to order by\n    for key in order_by:\n        # remove any whitespace\n        key = key.strip()\n        # if the key starts with a plus\n        if key.startswith(\"+\"):\n            # add the ascending filter to the list\n            out.append(getattr(model, key[1:]))\n        # otherwise if the key starts with a minus\n        elif key.startswith(\"-\"):\n            # add the descending filter to the list\n            out.append(getattr(model, key[1:]).desc())\n        # otherwise the key needs the default filter\n        else:\n            # add the default filter to the list\n            out.append(getattr(model, key))\n\n    # returnt the list of filters\n    return out", "response": "This function parses the order_by argument and returns a list of filters for the given model and the list of orderings for the given language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef model(model_names):\n    # for each model name we need to create\n    for model_name in model_names:\n        # the template context\n        context = {\n            'name': model_name,\n        }\n\n        # render the model template\n        render_template(template='common', context=context)\n        render_template(template='model', context=context)", "response": "Creates the example directory structure necessary for a model service."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the folder directories for an ApiGateway service.", "response": "def api():\n    \"\"\"\n        Create the folder/directories for an ApiGateway service.\n    \"\"\"\n    # the template context\n    context = {\n        'name': 'api',\n        'secret_key': random_string(32)\n    }\n\n    render_template(template='common', context=context)\n    render_template(template='api', context=context)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef auth():\n    # the template context\n    context = {\n        'name': 'auth',\n    }\n\n    render_template(template='common', context=context)\n    render_template(template='auth', context=context)", "response": "Create the folder directories for an Auth service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connection(model_connections):\n\n    # for each connection group\n    for connection_str in model_connections:\n\n        # the services to connect\n        services = connection_str.split(':')\n        services.sort()\n\n        service_name = ''.join([service.title() for service in services])\n\n        # the template context\n        context = {\n            # make sure the first letter is lowercase\n            'name': service_name[0].lower() + service_name[1:],\n            'services': services,\n        }\n\n        render_template(template='common', context=context)\n        render_template(template='connection', context=context)", "response": "Creates the example directory structure necessary for a connection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_model_string(model):\n    name = model if isinstance(model, str) else model.__name__\n    return normalize_string(name)", "response": "This function returns the conventional action designator for a given model"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart the broker interaction with the kafka stream", "response": "def start(self):\n        \"\"\"\n            This function starts the brokers interaction with the kafka stream\n        \"\"\"\n        self.loop.run_until_complete(self._consumer.start())\n        self.loop.run_until_complete(self._producer.start())\n        self._consumer_task = self.loop.create_task(self._consume_event_callback())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstopping the broker interaction with the kafka stream", "response": "def stop(self):\n        \"\"\"\n            This method stops the brokers interaction with the kafka stream\n        \"\"\"\n        self.loop.run_until_complete(self._consumer.stop())\n        self.loop.run_until_complete(self._producer.stop())\n\n        # attempt\n        try:\n            # to cancel the service\n            self._consumer_task.cancel()\n        # if there was no service\n        except AttributeError:\n            # keep going\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def send(self, payload='', action_type='', channel=None, **kwds):\n        # use a custom channel if one was provided\n        channel = channel or self.producer_channel\n\n        # serialize the action type for the\n        message = serialize_action(action_type=action_type, payload=payload, **kwds)\n        # send the message\n        return await self._producer.send(channel, message.encode())", "response": "This method sends a message over the kafka stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the fields that are part of the provided base model that are part of the base model.", "response": "def fields_for_model(model):\n    \"\"\"\n        This function returns the fields for a schema that matches the provided\n        nautilus model.\n\n        Args:\n            model (nautilus.model.BaseModel): The model to base the field list on\n\n        Returns:\n            (dict<field_name: str, graphqlType>): A mapping of field names to\n                graphql types\n    \"\"\"\n\n    # the attribute arguments (no filters)\n    args = {field.name.lower() : convert_peewee_field(field) \\\n                                        for field in model.fields()}\n    # use the field arguments, without the segments\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an SQL Alchemy table that connects the provides services", "response": "def create_connection_model(service):\n    \"\"\" Create an SQL Alchemy table that connects the provides services \"\"\"\n    # the services connected\n    services = service._services\n\n    # the mixins / base for the model\n    bases = (BaseModel,)\n    # the fields of the derived\n    attributes = {model_service_name(service): fields.CharField() for service in services}\n\n    # create an instance of base model with the right attributes\n    return type(BaseModel)(connection_service_name(service), bases, attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_handler(Model, name=None, **kwds):\n    async def action_handler(service, action_type, payload, props, notify=True, **kwds):\n        # if the payload represents a new instance of `Model`\n        if action_type == get_crud_action('create', name or Model):\n            # print('handling create for ' + name or Model)\n            try:\n                # the props of the message\n                message_props = {}\n                # if there was a correlation id in the request\n                if 'correlation_id' in props:\n                    # make sure it ends up in the reply\n                    message_props['correlation_id'] = props['correlation_id']\n\n                # for each required field\n                for requirement in Model.required_fields():\n\n                    # save the name of the field\n                    field_name = requirement.name\n                    # ensure the value is in the payload\n                    # TODO: check all required fields rather than failing on the first\n                    if not field_name in payload and field_name != 'id':\n                        # yell loudly\n                        raise ValueError(\n                            \"Required field not found in payload: %s\" %field_name\n                        )\n\n                # create a new model\n                new_model = Model(**payload)\n\n                # save the new model instance\n                new_model.save()\n\n                # if we need to tell someone about what happened\n                if notify:\n                    # publish the scucess event\n                    await service.event_broker.send(\n                        payload=ModelSerializer().serialize(new_model),\n                        action_type=change_action_status(action_type, success_status()),\n                        **message_props\n                    )\n\n            # if something goes wrong\n            except Exception as err:\n                # if we need to tell someone about what happened\n                if notify:\n                    # publish the error as an event\n                    await service.event_broker.send(\n                        payload=str(err),\n                        action_type=change_action_status(action_type, error_status()),\n                        **message_props\n                    )\n                # otherwise we aren't supposed to notify\n                else:\n                    # raise the exception normally\n                    raise err\n\n\n\n    # return the handler\n    return action_handler", "response": "This factory returns an action handler that creates a new instance of a specified model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_id(self, result, uid):\n        # if the result is a list\n        if isinstance(result, list):\n            # if the list has a valid entry\n            if any([self._find_id(value, uid) for value in result]):\n                # then we're done\n                return True\n\n        # otherwise results could be dictionaries\n        if isinstance(result, dict):\n            # the children of the result that are lists\n            list_children = [value for value in result.values() if isinstance(value, list)]\n\n            # go to every value that is a list\n            for value in list_children:\n                # if the value is a match\n                if self._find_id(value, uid):\n                    # we're done\n                    return True\n\n            # the children of the result that are dicts\n            dict_children = [value for value in result.values() if isinstance(value, dict)]\n\n            # perform the check on every child that is a dict\n            for value in dict_children:\n                # if the child is a match\n                if self._find_id(value, uid):\n                    # we're done\n                    return True\n\n            # if there are no values that are lists and there is an id key\n            if not list_children and not dict_children and 'id' in result:\n                # the value of the remote id field\n                result_id = result['id']\n                # we've found a match if the id field matches (cast to match type)\n                return result_id == type(result_id)(uid)\n\n        # we didn't find the result\n        return False", "response": "This method searches the result dictionary for the given uid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_before(self):\n        idx = self._container.structure.index(self)\n        return BlockBuilder(self._container, idx)", "response": "Returns a builder inserting a new block before the current block"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_after(self):\n        idx = self._container.structure.index(self)\n        return BlockBuilder(self._container, idx+1)", "response": "Returns a builder inserting a new block after the current block"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a comment block for the current object", "response": "def comment(self, text, comment_prefix='#'):\n        \"\"\"Creates a comment block\n\n        Args:\n            text (str): content of comment without #\n            comment_prefix (str): character indicating start of comment\n\n        Returns:\n            self for chaining\n        \"\"\"\n        comment = Comment(self._container)\n        if not text.startswith(comment_prefix):\n            text = \"{} {}\".format(comment_prefix, text)\n        if not text.endswith('\\n'):\n            text = \"{}{}\".format(text, '\\n')\n        comment.add_line(text)\n        self._container.structure.insert(self._idx, comment)\n        self._idx += 1\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef section(self, section):\n        if not isinstance(self._container, ConfigUpdater):\n            raise ValueError(\"Sections can only be added at section level!\")\n        if isinstance(section, str):\n            # create a new section\n            section = Section(section, container=self._container)\n        elif not isinstance(section, Section):\n            raise ValueError(\"Parameter must be a string or Section type!\")\n        if section.name in [block.name for block in self._container\n                            if isinstance(block, Section)]:\n            raise DuplicateSectionError(section.name)\n        self._container.structure.insert(self._idx, section)\n        self._idx += 1\n        return self", "response": "Creates a section block at the specified level."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a vertical space of newlines.", "response": "def space(self, newlines=1):\n        \"\"\"Creates a vertical space of newlines\n\n        Args:\n            newlines (int): number of empty lines\n\n        Returns:\n            self for chaining\n        \"\"\"\n        space = Space()\n        for line in range(newlines):\n            space.add_line('\\n')\n        self._container.structure.insert(self._idx, space)\n        self._idx += 1\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef option(self, key, value=None, **kwargs):\n        if not isinstance(self._container, Section):\n            raise ValueError(\"Options can only be added inside a section!\")\n        option = Option(key, value, container=self._container, **kwargs)\n        option.value = value\n        self._container.structure.insert(self._idx, option)\n        self._idx += 1\n        return self", "response": "Adds an option to the section with the specified key and value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a Comment object to the section Used during initial parsing mainly is a dict with the key = value and the value = value.", "response": "def add_comment(self, line):\n        \"\"\"Add a Comment object to the section\n\n        Used during initial parsing mainly\n\n        Args:\n            line (str): one line in the comment\n        \"\"\"\n        if not isinstance(self.last_item, Comment):\n            comment = Comment(self._structure)\n            self._structure.append(comment)\n        self.last_item.add_line(line)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_space(self, line):\n        if not isinstance(self.last_item, Space):\n            space = Space(self._structure)\n            self._structure.append(space)\n        self.last_item.add_line(line)\n        return self", "response": "Add a Space object to the section\n            Used during initial parsing mainly\n                   is a string that defines the space."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        return {key: self.__getitem__(key).value for key in self.options()}", "response": "Transform to dictionary\n\n        Returns:\n            dict: dictionary with same content"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set(self, option, value=None):\n        option = self._container.optionxform(option)\n        if option in self.options():\n            self.__getitem__(option).value = value\n        else:\n            self.__setitem__(option, value)\n        return self", "response": "Set an option for chaining."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_values(self, values, separator='\\n', indent=4*' '):\n        self._updated = True\n        self._multiline_value_joined = True\n        self._values = values\n        if separator == '\\n':\n            values.insert(0, '')\n            separator = separator + indent\n        self._value = separator.join(values)", "response": "Sets the value of the option to a given list of options e. g. multi - line values"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(self, filename, encoding=None):\n        with open(filename, encoding=encoding) as fp:\n            self._read(fp, filename)\n        self._filename = os.path.abspath(filename)", "response": "Read and parse a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_file(self):\n        if self._filename is None:\n            raise NoConfigFileReadError()\n        with open(self._filename, 'w') as fb:\n            self.write(fb)", "response": "Update the read - in configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_format(self, **kwargs):\n        args = dict(\n            dict_type=self._dict,\n            allow_no_value=self._allow_no_value,\n            inline_comment_prefixes=self._inline_comment_prefixes,\n            strict=self._strict,\n            empty_lines_in_values=self._empty_lines_in_values\n        )\n        args.update(kwargs)\n        parser = ConfigParser(**args)\n        updated_cfg = str(self)\n        parser.read_string(updated_cfg)", "response": "Call ConfigParser to validate config\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_section(self, section):\n        if section in self.sections():\n            raise DuplicateSectionError(section)\n        if isinstance(section, str):\n            # create a new section\n            section = Section(section, container=self)\n        elif not isinstance(section, Section):\n            raise ValueError(\"Parameter must be a string or Section type!\")\n        self._structure.append(section)", "response": "Add a section to the configuration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef options(self, section):\n        if not self.has_section(section):\n            raise NoSectionError(section) from None\n        return self.__getitem__(section).options()", "response": "Returns list of configuration options for the named section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting an option value for a given section.", "response": "def get(self, section, option):\n        \"\"\"Gets an option value for a given section.\n\n        Args:\n            section (str): section name\n            option (str): option name\n\n        Returns:\n            :class:`Option`: Option object holding key/value pair\n        \"\"\"\n        if not self.has_section(section):\n            raise NoSectionError(section) from None\n\n        section = self.__getitem__(section)\n        option = self.optionxform(option)\n        try:\n            value = section[option]\n        except KeyError:\n            raise NoOptionError(option, section)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of tuples for options or sections.", "response": "def items(self, section=_UNSET):\n        \"\"\"Return a list of (name, value) tuples for options or sections.\n\n        If section is given, return a list of tuples with (name, value) for\n        each option in the section. Otherwise, return a list of tuples with\n        (section_name, section_type) for each section.\n\n        Args:\n            section (str): optional section name, default UNSET\n\n        Returns:\n            list: list of :class:`Section` or :class:`Option` objects\n        \"\"\"\n        if section is _UNSET:\n            return [(sect.name, sect) for sect in self.sections_blocks()]\n\n        section = self.__getitem__(section)\n        return [(opt.key, opt) for opt in section.option_blocks()]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_option(self, section, option):\n        if section not in self.sections():\n            return False\n        else:\n            option = self.optionxform(option)\n            return option in self[section]", "response": "Checks if an option exists in a given section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting an option. value", "response": "def set(self, section, option, value=None):\n        \"\"\"Set an option.\n\n        Args:\n            section (str): section name\n            option (str): option name\n            value (str): value, default None\n        \"\"\"\n        try:\n            section = self.__getitem__(section)\n        except KeyError:\n            raise NoSectionError(section) from None\n        option = self.optionxform(option)\n        if option in section:\n            section[option].value = value\n        else:\n            section[option] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving an option from a section.", "response": "def remove_option(self, section, option):\n        \"\"\"Remove an option.\n\n        Args:\n            section (str): section name\n            option (str): option name\n\n        Returns:\n            bool: whether the option was actually removed\n        \"\"\"\n        try:\n            section = self.__getitem__(section)\n        except KeyError:\n            raise NoSectionError(section) from None\n        option = self.optionxform(option)\n        existed = option in section.options()\n        if existed:\n            del section[option]\n        return existed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_section(self, name):\n        existed = self.has_section(name)\n        if existed:\n            idx = self._get_section_idx(name)\n            del self._structure[idx]\n        return existed", "response": "Removes a section from the file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransform to dictionary Returns: dict: dictionary with same content", "response": "def to_dict(self):\n        \"\"\"Transform to dictionary\n\n        Returns:\n            dict: dictionary with same content\n        \"\"\"\n        return {sect: self.__getitem__(sect).to_dict()\n                for sect in self.sections()}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render_template(template, out_dir='.', context=None):\n    '''\n        This function renders the template desginated by the argument to the\n        designated directory using the given context.\n\n        Args:\n            template (string) : the source template to use (relative to ./templates)\n            out_dir (string) : the name of the output directory\n            context (dict) : the template rendering context\n    '''\n    # the directory containing templates\n    template_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                      '..',\n                                      'templates',\n                                      template\n                                     )\n\n    # the files and empty directories to copy\n    files = []\n    empty_dirs = []\n\n    for (dirpath, _, filenames) in os.walk(template_directory):\n        # if there are no files in the directory\n        if len(filenames) == 0:\n            # add the directory to the list\n            empty_dirs.append(os.path.relpath(dirpath, template_directory))\n        # otherwise there are files in this directory\n        else:\n            # add the files to the list\n            files.extend([os.path.join(dirpath, filepath) for filepath in filenames])\n\n    # for each template file\n    for source_file in files:\n        # open a new file that we are going to write to\n        with open(source_file, 'r') as file:\n            # create a template out of the source file contents\n            template = Template(file.read())\n            # render the template with the given contents\n            template_rendered = template.render(**(context or {}))\n\n            # the location of the source relative to the template directory\n            source_relpath = os.path.relpath(source_file, template_directory)\n\n            # the target filename\n            filename = os.path.join(out_dir, source_relpath)\n            # create a jinja template out of the file path\n            filename_rendered = Template(filename).render(**context)\n\n            # the directory of the target file\n            source_dir = os.path.dirname(filename_rendered)\n            # if the directory doesn't exist\n            if not os.path.exists(source_dir):\n                # create the directories\n                os.makedirs(source_dir)\n\n            # create the target file\n            with open(filename_rendered, 'w') as target_file:\n                # write the rendered template to the target file\n                target_file.write(template_rendered)\n\n    # for each empty directory\n    for dirpath in empty_dirs:\n        try:\n            # dirname\n            dirname = os.path.join(out_dir, dirpath)\n            # treat the dirname as a jinja template\n            dirname_rendered = Template(dirname).render(**context)\n\n            # if the directory doesn't exist\n            if not os.path.exists(dirname_rendered):\n                # create the directory in the target, replacing the name\n                os.makedirs(dirname_rendered)\n        except OSError as exc:\n            # if the directory already exists\n            if exc.errno == errno.EEXIST and os.path.isdir(dirpath):\n                # keep going (noop)\n                pass\n            # otherwise its an error we don't handle\n            else:\n                # pass it along\n                raise", "response": "This function renders the template with the given context and returns the contents of the rendered template."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef publish(type, payload):\n    async def _produce():\n        # fire an action with the given values\n        await producer.send(action_type=type, payload=payload)\n        # notify the user that we were successful\n        print(\"Successfully dispatched action with type {}.\".format(type))\n\n    # create a producer\n    producer = ActionHandler()\n    # start the producer\n    producer.start()\n\n    # get the current event loop\n    loop = asyncio.get_event_loop()\n\n    # run the production sequence\n    loop.run_until_complete(_produce())\n\n    # start the producer\n    producer.stop()", "response": "Publish a message with the specified action_type and payload over the event system. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_handler(Model, name=None, **kwds):\n    # necessary imports\n    from nautilus.database import db\n\n    async def action_handler(service, action_type, payload, props, notify=True, **kwds):\n        # if the payload represents a new instance of `model`\n        if action_type == get_crud_action('delete', name or Model):\n            try:\n                # the props of the message\n                message_props = {}\n                # if there was a correlation id in the request\n                if 'correlation_id' in props:\n                    # make sure it ends up in the reply\n                    message_props['correlation_id'] = props['correlation_id']\n                # the id in the payload representing the record to delete\n                record_id = payload['id'] if 'id' in payload else payload['pk']\n                # get the model matching the payload\n                try:\n                    model_query = Model.select().where(Model.primary_key() == record_id)\n                except KeyError:\n                    raise RuntimeError(\"Could not find appropriate id to remove service record.\")\n                # remove the model instance\n                model_query.get().delete_instance()\n                # if we need to tell someone about what happened\n                if notify:\n                    # publish the success event\n                    await service.event_broker.send(\n                        payload='{\"status\":\"ok\"}',\n                        action_type=change_action_status(action_type, success_status()),\n                        **message_props\n                    )\n\n            # if something goes wrong\n            except Exception as err:\n                # if we need to tell someone about what happened\n                if notify:\n                    # publish the error as an event\n                    await service.event_broker.send(\n                        payload=str(err),\n                        action_type=change_action_status(action_type, error_status()),\n                        **message_props\n                    )\n                # otherwise we aren't supposed to notify\n                else:\n                    # raise the exception normally\n                    raise err\n\n\n    # return the handler\n    return action_handler", "response": "This factory returns an action handler that deletes a new instance of the specified model from the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_handler(Model, name=None, **kwds):\n    async def action_handler(service, action_type, payload, props, **kwds):\n        # if the payload represents a new instance of `model`\n        if action_type == get_crud_action('read', name or Model):\n            # the props of the message\n            message_props = {}\n            # if there was a correlation id in the request\n            if 'correlation_id' in props:\n                # make sure it ends up in the reply\n                message_props['correlation_id'] = props['correlation_id']\n\n            try:\n                # resolve the query using the service schema\n                resolved = service.schema.execute(payload)\n                # create the string response\n                response = json.dumps({\n                    'data': {key:value for key,value in resolved.data.items()},\n                    'errors': resolved.errors\n                })\n\n                # publish the success event\n                await service.event_broker.send(\n                    payload=response,\n                    action_type=change_action_status(action_type, success_status()),\n                    **message_props\n                )\n\n            # if something goes wrong\n            except Exception as err:\n                # publish the error as an event\n                await service.event_broker.send(\n                    payload=str(err),\n                    action_type=change_action_status(action_type, error_status()),\n                    **message_props\n                )\n\n\n    # return the handler\n    return action_handler", "response": "This factory returns an action handler that responds to read requests by resolving the payload as graphql query against the internal schema and sending the response to the event broker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef crud_handler(Model, name=None, **kwds):\n\n    # import the necessary modules\n    from nautilus.network.events import combine_action_handlers\n    from . import update_handler, create_handler, delete_handler, read_handler\n\n    # combine them into one handler\n    return combine_action_handlers(\n        create_handler(Model, name=name),\n        read_handler(Model, name=name),\n        update_handler(Model, name=name),\n        delete_handler(Model, name=name),\n    )", "response": "This action handler factory reaturns an action handler that creates a new object that is created with the specified CRUD types and deletes the specified CRUD types."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ask(type, payload):\n    async def _produce():\n        # notify the user that we were successful\n        print(\"Dispatching action with type {}...\".format(type))\n        # fire an action with the given values\n        response = await producer.ask(action_type=type, payload=payload)\n        # show the user the reply\n        print(response)\n\n    # create a producer\n    producer = ActionHandler()\n    # start the producer\n    producer.start()\n\n    # get the current event loop\n    loop = asyncio.get_event_loop()\n\n    # run the production sequence\n    loop.run_until_complete(_produce())\n\n    # start the producer\n    producer.stop()", "response": "Publish a message with the specified action_type and payload over the event system. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def walk_query(obj, object_resolver, connection_resolver, errors, current_user=None, __naut_name=None, obey_auth=True, **filters):\n    # if the object has no selection set\n    if not hasattr(obj, 'selection_set'):\n        # yell loudly\n        raise ValueError(\"Can only resolve objects, not primitive types\")\n\n    # the name of the node\n    node_name = __naut_name or obj.name.value if obj.name else obj.operation\n\n    # the selected fields\n    selection_set = obj.selection_set.selections\n\n    def _build_arg_tree(arg):\n        \"\"\"\n            This function recursively builds the arguments for lists and single values\n        \"\"\"\n        # TODO: what about object arguments??\n\n        # if there is a single value\n        if hasattr(arg, 'value'):\n            # assign the value to the filter\n            return arg.value\n        # otherwise if there are multiple values for the argument\n        elif hasattr(arg, 'values'):\n            return [_build_arg_tree(node) for node in arg.values]\n\n    # for each argument on this node\n    for arg in obj.arguments:\n        # add it to the query filters\n        filters[arg.name.value] = _build_arg_tree(arg.value)\n\n    # the fields we have to ask for\n    fields = [field for field in selection_set if not field.selection_set]\n    # the links between objects\n    connections = [field for field in selection_set if field.selection_set]\n\n    try:\n        # resolve the model with the given fields\n        models = await object_resolver(node_name, [field.name.value for field in fields], current_user=current_user, obey_auth=obey_auth, **filters)\n    # if something went wrong resolving the object\n    except Exception as e:\n        # add the error as a string\n        errors.append(e.__str__())\n        # stop here\n        return None\n\n    # add connections to each matching model\n    for model in models:\n        # if is an id for the model\n        if 'pk' in model:\n            # for each connection\n            for connection in connections:\n                # the name of the connection\n                connection_name = connection.name.value\n                # the target of the connection\n                node = {\n                    'name': node_name,\n                    'pk': model['pk']\n                }\n\n                try:\n                    # go through the connection\n                    connected_ids, next_target = await connection_resolver(\n                        connection_name,\n                        node,\n                    )\n\n                    # if there are connections\n                    if connected_ids:\n                        # add the id filter to the list\n                        filters['pk_in'] = connected_ids\n\n                        # add the connection field\n                        value = await walk_query(\n                            connection,\n                            object_resolver,\n                            connection_resolver,\n                            errors,\n                            current_user=current_user,\n                            obey_auth=obey_auth,\n                            __naut_name=next_target,\n                            **filters\n                        )\n                    # there were no connections\n                    else:\n                        value = []\n                # if something went wrong\n                except Exception as e:\n                    # add the error as a string\n                    errors.append(e.__str__())\n                    # stop here\n                    value = None\n\n                # set the connection to the appropriate value\n                model[connection_name] = value\n\n    # return the list of matching models\n    return models", "response": "This function walks the object tree and returns the information in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef summarize_mutation_io(name, type, required=False):\n    return dict(\n        name=name,\n        type=type,\n        required=required\n    )", "response": "This function returns the standard summary for mutations inputs\n    and outputs\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crud_mutation_name(action, model):\n    model_string = get_model_string(model)\n    # make sure the mutation name is correctly camelcases\n    model_string = model_string[0].upper() + model_string[1:]\n\n    # return the mutation name\n    return \"{}{}\".format(action, model_string)", "response": "This function returns the name of a mutation that performs the specified crud action on the given model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_mutation_inputs(service):\n    # grab the default list of field summaries\n    inputs = _service_mutation_summaries(service)\n    # make sure the pk isn't in the list\n    inputs.remove([field for field in inputs if field['name'] == 'id'][0])\n\n    # return the final list\n    return inputs", "response": "Create the list of fields that are required for the mutation of a service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the list of fields that are required by the mutation for the given service.", "response": "def update_mutation_inputs(service):\n    \"\"\"\n        Args:\n            service : The service being updated by the mutation\n        Returns:\n            (list) : a list of all of the fields availible for the service. Pk\n                is a required field in order to filter the results\n    \"\"\"\n    # grab the default list of field summaries\n    inputs = _service_mutation_summaries(service)\n\n    # visit each field\n    for field in inputs:\n        # if we're looking at the id field\n        if field['name'] == 'id':\n            # make sure its required\n            field['required'] = True\n        # but no other field\n        else:\n            # is required\n            field['required'] = False\n\n    # return the final list\n    return inputs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of input for delete events.", "response": "def delete_mutation_inputs(service):\n    \"\"\"\n        Args:\n            service : The service being deleted by the mutation\n        Returns:\n            ([str]):  the only input for delete is the pk of the service.\n    \"\"\"\n    from nautilus.api.util import summarize_mutation_io\n\n    # the only input for delete events is the pk of the service record\n    return [summarize_mutation_io(name='pk', type='ID', required=True)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_handler(Model, name=None, **kwds):\n    async def action_handler(service, action_type, payload, props, notify=True, **kwds):\n        # if the payload represents a new instance of `Model`\n        if action_type == get_crud_action('update', name or Model):\n            try:\n                # the props of the message\n                message_props = {}\n                # if there was a correlation id in the request\n                if 'correlation_id' in props:\n                    # make sure it ends up in the reply\n                    message_props['correlation_id'] = props['correlation_id']\n\n\n                # grab the nam eof the primary key for the model\n                pk_field = Model.primary_key()\n\n                # make sure there is a primary key to id the model\n                if not pk_field.name in payload:\n                    # yell loudly\n                    raise ValueError(\"Must specify the pk of the model when updating\")\n\n                # grab the matching model\n                model = Model.select().where(pk_field == payload[pk_field.name]).get()\n\n                # remove the key from the payload\n                payload.pop(pk_field.name, None)\n\n                # for every key,value pair\n                for key, value in payload.items():\n                    # TODO: add protection for certain fields from being\n                    # changed by the api\n                    setattr(model, key, value)\n\n                # save the updates\n                model.save()\n\n                # if we need to tell someone about what happened\n                if notify:\n                    # publish the scucess event\n                    await service.event_broker.send(\n                        payload=ModelSerializer().serialize(model),\n                        action_type=change_action_status(action_type, success_status()),\n                        **message_props\n                    )\n\n            # if something goes wrong\n            except Exception as err:\n                # if we need to tell someone about what happened\n                if notify:\n                    # publish the error as an event\n                    await service.event_broker.send(\n                        payload=str(err),\n                        action_type=change_action_status(action_type, error_status()),\n                        **message_props\n                    )\n                # otherwise we aren't supposed to notify\n                else:\n                    # raise the exception normally\n                    raise err\n\n    # return the handler\n    return action_handler", "response": "This factory returns an action handler that updates a new instance of the specified model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef graphql_mutation_from_summary(summary):\n    # get the name of the mutation from the summary\n    mutation_name = summary['name']\n\n    # print(summary)\n\n    # the treat the \"type\" string as a gra\n    input_name = mutation_name + \"Input\"\n    input_fields = build_native_type_dictionary(summary['inputs'], name=input_name, respect_required=True)\n\n    # the inputs for the mutation are defined by a class record\n    inputs = type('Input', (object,), input_fields)\n\n    # the outputs for the mutation are attributes to the class record\n    output_name = mutation_name + \"Output\"\n    outputs = build_native_type_dictionary(summary['outputs'], name=output_name)\n\n    # a no-op in order to satisfy the introspection query\n    mutate = classmethod(lambda *_, **__ : 'hello')\n\n    # create the appropriate mutation class record\n    mutation = type(mutation_name, (graphene.Mutation,), {\n        'Input': inputs,\n        'mutate': mutate,\n        **outputs\n    })\n\n    # return the newly created mutation record\n    return mutation", "response": "This function returns a graphql mutation corresponding to the provided summary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef arg_string_from_dict(arg_dict, **kwds):\n    # the filters dictionary\n    filters = {\n        **arg_dict,\n        **kwds,\n    }\n    # return the correctly formed string\n    return \", \".join(\"{}: {}\".format(key, json.dumps(value)) for key,value in filters.items())", "response": "This function takes a series of ditionaries and creates an argument string for a graphql query\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connection_service_name(service, *args):\n    ''' the name of a service that manages the connection between services '''\n    # if the service is a string\n    if isinstance(service, str):\n        return service\n\n    return normalize_string(type(service).__name__)", "response": "the name of a service that manages the connection between services"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_session_token(secret_key, token):\n    return jwt.decode(token.encode('utf-8'), secret_key,\n        algorithms=[token_encryption_algorithm()]\n    )", "response": "This function verifies the token using the secret key and returns its\n        contents."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def announce(self):\n        # send a serialized event\n        await self.event_broker.send(\n            action_type=intialize_service_action(),\n            payload=json.dumps(self.summarize())\n        )", "response": "This method is used to announce the existence of the service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_http_endpoint(self, url, request_handler):\n        self.app.router.add_route('*', url, request_handler)", "response": "This method adds an http endpoint to the router."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef route(cls, route, config=None):\n        def decorator(wrapped_class, **kwds):\n\n            # add the endpoint at the given route\n            cls._routes.append(\n                dict(url=route, request_handler=wrapped_class)\n            )\n            # return the class undecorated\n            return wrapped_class\n\n        # return the decorator\n        return decorator", "response": "This method provides a decorator for adding endpoints to the specified route."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_session_token(secret_key, **payload):\n    return jwt.encode(payload, secret_key, algorithm=token_encryption_algorithm()).decode('utf-8')", "response": "This function generates a session token signed by the secret key which can be used to extract the user credentials in a verifiable way."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a PasswordHash from the given password.", "response": "def new(cls, password, rounds):\n        \"\"\"Creates a PasswordHash from the given password.\"\"\"\n        if isinstance(password, str):\n            password = password.encode('utf-8')\n        return cls(cls._new(password, rounds))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef coerce(cls, key, value):\n        if isinstance(value, PasswordHash):\n            return value\n        return super(PasswordHash, cls).coerce(key, value)", "response": "Ensure that loaded values are PasswordHashes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrecreate the internal hash.", "response": "def rehash(self, password):\n        \"\"\"Recreates the internal hash.\"\"\"\n        self.hash = self._new(password, self.desired_rounds)\n        self.rounds = self.desired_rounds"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def login_user(self, password, **kwds):\n        # find the matching user with the given email\n        user_data = (await self._get_matching_user(fields=list(kwds.keys()), **kwds))['data']\n        try:\n            # look for a matching entry in the local database\n            passwordEntry = self.model.select().where(\n                self.model.user == user_data[root_query()][0]['pk']\n            )[0]\n        # if we couldn't acess the id of the result\n        except (KeyError, IndexError) as e:\n            # yell loudly\n            raise RuntimeError('Could not find matching registered user')\n\n\n        # if the given password matches the stored hash\n        if passwordEntry and passwordEntry.password == password:\n            # the remote entry for the user\n            user = user_data[root_query()][0]\n            # then return a dictionary with the user and sessionToken\n            return {\n                'user': user,\n                'sessionToken': self._user_session_token(user)\n            }\n\n        # otherwise the passwords don't match\n        raise RuntimeError(\"Incorrect credentials\")", "response": "This function handles the registration of the given user credentials in the database and returns a dictionary with the user and sessionToken."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def register_user(self, password, **kwds):\n        # so make one\n        user = await self._create_remote_user(password=password, **kwds)\n        # if there is no pk field\n        if not 'pk' in user:\n            # make sure the user has a pk field\n            user['pk'] = user['id']\n\n        # the query to find a matching query\n        match_query = self.model.user == user['id']\n\n        # if the user has already been registered\n        if self.model.select().where(match_query).count() > 0:\n            # yell loudly\n            raise RuntimeError('The user is already registered.')\n\n        # create an entry in the user password table\n        password = self.model(user=user['id'], password=password)\n\n        # save it to the database\n        password.save()\n\n        # return a dictionary with the user we created and a session token for later use\n        return {\n            'user': user,\n            'sessionToken': self._user_session_token(user)\n        }", "response": "This function creates a user and stores it in the database and returns a dictionary with the user created and a sessionToken for later requests."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def object_resolver(self, object_name, fields, obey_auth=False, current_user=None, **filters):\n\n        try:\n            # check if an object with that name has been registered\n            registered = [model for model in self._external_service_data['models'] \\\n                                if model['name']==object_name][0]\n        # if there is no connection data yet\n        except AttributeError:\n            raise ValueError(\"No objects are registered with this schema yet.\")\n        # if we dont recognize the model that was requested\n        except IndexError:\n            raise ValueError(\"Cannot query for object {} on this service.\".format(object_name))\n\n        # the valid fields for this object\n        valid_fields = [field['name'] for field in registered['fields']]\n\n        # figure out if any invalid fields were requested\n        invalid_fields = [field for field in fields if field not in valid_fields]\n        try:\n            # make sure we never treat pk as invalid\n            invalid_fields.remove('pk')\n        # if they weren't asking for pk as a field\n        except ValueError:\n            pass\n\n        # if there were\n        if invalid_fields:\n            # yell loudly\n            raise ValueError(\"Cannot query for fields {!r} on {}\".format(\n                invalid_fields, registered['name']\n            ))\n\n        # make sure we include the id in the request\n        fields.append('pk')\n\n        # the query for model records\n        query = query_for_model(fields, **filters)\n\n        # the action type for the question\n        action_type = get_crud_action('read', object_name)\n\n        # query the appropriate stream for the information\n        response = await self.event_broker.ask(\n            action_type=action_type,\n            payload=query\n        )\n\n        # treat the reply like a json object\n        response_data = json.loads(response)\n\n        # if something went wrong\n        if 'errors' in response_data and response_data['errors']:\n            # return an empty response\n            raise ValueError(','.join(response_data['errors']))\n\n        # grab the valid list of matches\n        result = response_data['data'][root_query()]\n\n        # grab the auth handler for the object\n        auth_criteria = self.auth_criteria.get(object_name)\n\n        # if we care about auth requirements and there is one for this object\n        if obey_auth and auth_criteria:\n\n            # build a second list of authorized entries\n            authorized_results = []\n\n            # for each query result\n            for query_result in result:\n                # create a graph entity for the model\n                graph_entity = GraphEntity(self, model_type=object_name, id=query_result['pk'])\n                # if the auth handler passes\n                if await auth_criteria(model=graph_entity, user_id=current_user):\n                    # add the result to the final list\n                    authorized_results.append(query_result)\n\n            # overwrite the query result\n            result = authorized_results\n\n        # apply the auth handler to the result\n        return result", "response": "This function resolves a given object in the remote backend services."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def mutation_resolver(self, mutation_name, args, fields):\n\n        try:\n            # make sure we can identify the mutation\n            mutation_summary = [mutation for mutation in \\\n                                            self._external_service_data['mutations'] \\\n                                            if mutation['name'] == mutation_name][0]\n        # if we couldn't get the first entry in the list\n        except KeyError as e:\n            # make sure the error is reported\n            raise ValueError(\"Could not execute mutation named: \" + mutation_name)\n\n\n        # the function to use for running the mutation depends on its schronicity\n        # event_function = self.event_broker.ask \\\n        #                     if mutation_summary['isAsync'] else self.event_broker.send\n        event_function = self.event_broker.ask\n\n        # send the event and wait for a response\n        value =  await event_function(\n            action_type=mutation_summary['event'],\n            payload=args\n        )\n        try:\n            # return a dictionary with the values we asked for\n            return json.loads(value)\n\n        # if the result was not valid json\n        except json.decoder.JSONDecodeError:\n            # just throw the value\n            raise RuntimeError(value)", "response": "This method is used to resolve the event type of a specific mutation and return the fields contained in the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_wer(reference, hypothesis):\n    # initialisation\n    import numpy\n    d = numpy.zeros((len(reference)+1)*(len(hypothesis)+1), dtype=numpy.uint8)\n    d = d.reshape((len(reference)+1, len(hypothesis)+1))\n    for i in range(len(reference)+1):\n        for j in range(len(hypothesis)+1):\n            if i == 0:\n                d[0][j] = j\n            elif j == 0:\n                d[i][0] = i\n\n    # computation\n    for i in range(1, len(reference)+1):\n        for j in range(1, len(hypothesis)+1):\n            if reference[i-1] == hypothesis[j-1]:\n                d[i][j] = d[i-1][j-1]\n            else:\n                substitution = d[i-1][j-1] + 1\n                insertion    = d[i][j-1] + 1\n                deletion     = d[i-1][j] + 1\n                d[i][j] = min(substitution, insertion, deletion)\n\n    return d[len(reference)][len(hypothesis)]/float(len(reference))", "response": "Calculates the WER with Levenshtein distance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a parser object", "response": "def get_parser():\n    \"\"\"Get a parser object\"\"\"\n    from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter\n    parser = ArgumentParser(description=__doc__,\n                            formatter_class=ArgumentDefaultsHelpFormatter)\n    parser.add_argument(\"-s1\", dest=\"s1\", help=\"sequence 1\")\n    parser.add_argument(\"-s2\", dest=\"s2\", help=\"sequence 2\")\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a GET web request and return a bs4 parser", "response": "async def _async_request_soup(url):\n    '''\n    Perform a GET web request and return a bs4 parser\n    '''\n    from bs4 import BeautifulSoup\n    import aiohttp\n    _LOGGER.debug('GET %s', url)\n    async with aiohttp.ClientSession() as session:\n        resp = await session.get(url)\n        text = await resp.text()\n        return BeautifulSoup(text, 'html.parser')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetermines the current channel using fuzzywuzzy.", "response": "async def async_determine_channel(channel):\n    '''\n    Check whether the current channel is correct. If not try to determine it\n    using fuzzywuzzy\n    '''\n    from fuzzywuzzy import process\n    channel_data = await async_get_channels()\n    if not channel_data:\n        _LOGGER.error('No channel data. Cannot determine requested channel.')\n        return\n    channels = [c for c in channel_data.get('data', {}).keys()]\n    if channel in channels:\n        return channel\n    else:\n        res = process.extractOne(channel, channels)[0]\n        _LOGGER.debug('No direct match found for %s. Resort to guesswork.'\n                      'Guessed %s', channel, res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of channels and corresponding urls.", "response": "async def async_get_channels(no_cache=False, refresh_interval=4):\n    '''\n    Get channel list and corresponding urls\n    '''\n    # Check cache\n    now = datetime.datetime.now()\n    max_cache_age = datetime.timedelta(hours=refresh_interval)\n    if not no_cache and 'channels' in _CACHE:\n        cache = _CACHE.get('channels')\n        cache_age = cache.get('last_updated')\n        if now - cache_age < max_cache_age:\n            _LOGGER.debug('Found channel list in cache.')\n            return cache\n        else:\n            _LOGGER.debug('Found outdated channel list in cache. Update it.')\n            _CACHE.pop('channels')\n    soup = await _async_request_soup(BASE_URL + '/plan.html')\n    channels = {}\n    for li_item in soup.find_all('li'):\n        try:\n            child = li_item.findChild()\n            if not child or child.name != 'a':\n                continue\n            href = child.get('href')\n            if not href or not href.startswith('/programme/chaine'):\n                continue\n            channels[child.get('title')] = BASE_URL + href\n        except Exception as exc:\n            _LOGGER.error('Exception occured while fetching the channel '\n                          'list: %s', exc)\n    if channels:\n        _CACHE['channels'] = {'last_updated': now, 'data': channels}\n        return _CACHE['channels']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resize_program_image(img_url, img_size=300):\n    '''\n    Resize a program's thumbnail to the desired dimension\n    '''\n    match = re.match(r'.+/(\\d+)x(\\d+)/.+', img_url)\n    if not match:\n        _LOGGER.warning('Could not compute current image resolution of %s',\n                        img_url)\n        return img_url\n    res_x = int(match.group(1))\n    res_y = int(match.group(2))\n    # aspect_ratio = res_x / res_y\n    target_res_y = int(img_size * res_y / res_x)\n    return re.sub(\n        r'{}x{}'.format(res_x, res_y),\n        r'{}x{}'.format(img_size, target_res_y),\n        img_url)", "response": "Resize a program s thumbnail to the desired dimension."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_current_program_progress(program):\n    '''\n    Get the current progress of the program in %\n    '''\n    now = datetime.datetime.now()\n    program_duration = get_program_duration(program)\n    if not program_duration:\n        return\n    progress = now - program.get('start_time')\n    return progress.seconds * 100 / program_duration", "response": "Get the current progress of the program in %\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_program_duration(program):\n    '''\n    Get a program's duration in seconds\n    '''\n    program_start = program.get('start_time')\n    program_end = program.get('end_time')\n    if not program_start or not program_end:\n        _LOGGER.error('Could not determine program start and/or end times.')\n        _LOGGER.debug('Program data: %s', program)\n        return\n    program_duration = program_end - program_start\n    return program_duration.seconds", "response": "Get a program s duration in seconds."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_remaining_time(program):\n    '''\n    Get the remaining time in seconds of a program that is currently on.\n    '''\n    now = datetime.datetime.now()\n    program_start = program.get('start_time')\n    program_end = program.get('end_time')\n    if not program_start or not program_end:\n        _LOGGER.error('Could not determine program start and/or end times.')\n        _LOGGER.debug('Program data: %s', program)\n        return\n    if now > program_end:\n        _LOGGER.error('The provided program has already ended.')\n        _LOGGER.debug('Program data: %s', program)\n        return 0\n    progress = now - program_start\n    return progress.seconds", "response": "Get the remaining time in seconds of a program."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extract_program_summary(data):\n    '''\n    Extract the summary data from a program's detail page\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(data, 'html.parser')\n    try:\n        return soup.find(\n            'div', {'class': 'episode-synopsis'}\n        ).find_all('div')[-1].text.strip()\n    except Exception:\n        _LOGGER.info('No summary found for program: %s',\n                     soup.find('a', {'class': 'prog_name'}))\n        return \"No summary\"", "response": "Extract the summary data from a program s detail page"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a program s summary", "response": "async def async_set_summary(program):\n    '''\n    Set a program's summary\n    '''\n    import aiohttp\n    async with aiohttp.ClientSession() as session:\n        resp = await session.get(program.get('url'))\n        text = await resp.text()\n        summary = extract_program_summary(text)\n        program['summary'] = summary\n        return program"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the program data for a channel.", "response": "async def async_get_program_guide(channel, no_cache=False, refresh_interval=4):\n    '''\n    Get the program data for a channel\n    '''\n    chan = await async_determine_channel(channel)\n    now = datetime.datetime.now()\n    max_cache_age = datetime.timedelta(hours=refresh_interval)\n    if not no_cache and 'guide' in _CACHE and _CACHE.get('guide').get(chan):\n        cache = _CACHE.get('guide').get(chan)\n        cache_age = cache.get('last_updated')\n        if now - cache_age < max_cache_age:\n            _LOGGER.debug('Found program guide in cache.')\n            return cache.get('data')\n        else:\n            _LOGGER.debug('Found outdated program guide in cache. Update it.')\n            _CACHE['guide'].pop(chan)\n    chans = await async_get_channels()\n    url = chans.get('data', {}).get(chan)\n    if not url:\n        _LOGGER.error('Could not determine URL for %s', chan)\n        return\n    soup = await _async_request_soup(url)\n    programs = []\n    for prg_item in soup.find_all('div', {'class': 'program-infos'}):\n        try:\n            prog_info = prg_item.find('a', {'class': 'prog_name'})\n            prog_name = prog_info.text.strip()\n            prog_url = prog_info.get('href')\n            if not prog_url:\n                _LOGGER.warning('Failed to retrive the detail URL for program %s. '\n                                'The summary will be empty', prog_name)\n            prog_type = prg_item.find('span', {'class': 'prog_type'}).text.strip()\n            prog_times = prg_item.find('div', {'class': 'prog_progress'})\n            prog_start = datetime.datetime.fromtimestamp(\n                int(prog_times.get('data-start')))\n            prog_end = datetime.datetime.fromtimestamp(\n                int(prog_times.get('data-end')))\n            img = prg_item.find_previous_sibling().find(\n                'img', {'class': 'prime_broadcast_image'})\n            prog_img = img.get('data-src') if img else None\n            programs.append(\n                {'name': prog_name, 'type': prog_type, 'img': prog_img,\n                 'url': prog_url, 'summary': None, 'start_time': prog_start,\n                 'end_time': prog_end})\n        except Exception as exc:\n            _LOGGER.error('Exception occured while fetching the program '\n                          'guide for channel %s: %s', chan, exc)\n            import traceback\n            traceback.print_exc()\n    # Set the program summaries asynchronously\n    tasks = [async_set_summary(prog) for prog in programs]\n    programs = await asyncio.gather(*tasks)\n    if programs:\n        if 'guide' not in _CACHE:\n            _CACHE['guide'] = {}\n        _CACHE['guide'][chan] = {'last_updated': now, 'data': programs}\n    return programs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def async_get_current_program(channel, no_cache=False):\n    '''\n    Get the current program info\n    '''\n    chan = await async_determine_channel(channel)\n    guide = await async_get_program_guide(chan, no_cache)\n    if not guide:\n        _LOGGER.warning('Could not retrieve TV program for %s', channel)\n        return\n    now = datetime.datetime.now()\n    for prog in guide:\n        start = prog.get('start_time')\n        end = prog.get('end_time')\n        if now > start and now < end:\n            return prog", "response": "Get the current TV program info for a channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef publish(self, distribution, storage=\"\"):\n        try:\n            return self._publishes[distribution]\n        except KeyError:\n            self._publishes[distribution] = Publish(self.client, distribution, timestamp=self.timestamp, storage=(storage or self.storage))\n            return self._publishes[distribution]", "response": "Get or create publish\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new snapshot to the publish list", "response": "def add(self, snapshot, distributions, component='main', storage=\"\"):\n        \"\"\" Add mirror or repo to publish \"\"\"\n        for dist in distributions:\n            self.publish(dist, storage=storage).add(snapshot, component)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _publish_match(self, publish, names=False, name_only=False):\n        if names:\n            for name in names:\n                if not name_only and isinstance(name, re._pattern_type):\n                    if re.match(name, publish.name):\n                        return True\n                else:\n                    operand = name if name_only else [name, './%s' % name]\n                    if publish in operand:\n                        return True\n            return False\n        else:\n            return True", "response": "Check if publish name matches list of names or regex patterns"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_repo_information(config, client, fill_repo=False, components=[]):\n        repo_dict = {}\n        publish_dict = {}\n\n        for origin in ['repo', 'mirror']:\n            for name, repo in config.get(origin, {}).items():\n                if components and repo.get('component') not in components:\n                    continue\n                if fill_repo and origin == 'repo':\n                    packages = Publish._get_packages(\"repos\", name)\n                    repo_dict[name] = packages\n                for distribution in repo.get('distributions'):\n                    publish_name = str.join('/', distribution.split('/')[:-1])\n                    publish_dict[(publish_name, repo.get('component'))] = name\n\n        return (repo_dict, publish_dict)", "response": "Get the information about the repository and publish."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compare(self, other, components=[]):\n        lg.debug(\"Comparing publish %s (%s) and %s (%s)\" % (self.name, self.storage or \"local\", other.name, other.storage or \"local\"))\n\n        diff, equal = ({}, {})\n\n        for component, snapshots in self.components.items():\n            if component not in list(other.components.keys()):\n                # Component is missing in other\n                diff[component] = snapshots\n                continue\n\n            equal_snapshots = list(set(snapshots).intersection(other.components[component]))\n            if equal_snapshots:\n                lg.debug(\"Equal snapshots for %s: %s\" % (component, equal_snapshots))\n                equal[component] = equal_snapshots\n\n            diff_snapshots = list(set(snapshots).difference(other.components[component]))\n            if diff_snapshots:\n                lg.debug(\"Different snapshots for %s: %s\" % (component, diff_snapshots))\n                diff[component] = diff_snapshots\n\n        return (diff, equal)", "response": "Compare two publish sets and return a tuple of dictionaries containing the difference of the publish sets and the other publish sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds this publish on remote node", "response": "def _get_publish(self):\n        \"\"\"\n        Find this publish on remote\n        \"\"\"\n        publishes = self._get_publishes(self.client)\n        for publish in publishes:\n            if publish['Distribution'] == self.distribution and \\\n                    publish['Prefix'].replace(\"/\", \"_\") == (self.prefix or '.') and \\\n                    publish['Storage'] == self.storage:\n                return publish\n        raise NoSuchPublish(\"Publish %s (%s) does not exist\" % (self.name, self.storage or \"local\"))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nserializing publish in YAML", "response": "def save_publish(self, save_path):\n        \"\"\"\n        Serialize publish in YAML\n        \"\"\"\n        timestamp = time.strftime(\"%Y%m%d%H%M%S\")\n\n        yaml_dict = {}\n        yaml_dict[\"publish\"] = self.name\n        yaml_dict[\"name\"] = timestamp\n        yaml_dict[\"components\"] = []\n        yaml_dict[\"storage\"] = self.storage\n        for component, snapshots in self.components.items():\n            packages = self.get_packages(component)\n            package_dict = []\n            for package in packages:\n                (arch, name, version, ref) = self.parse_package_ref(package)\n                package_dict.append({'package': name, 'version': version, 'arch': arch, 'ref': ref})\n            snapshot = self._find_snapshot(snapshots[0])\n\n            yaml_dict[\"components\"].append({'component': component, 'snapshot': snapshot['Name'],\n                                            'description': snapshot['Description'], 'packages': package_dict})\n\n        name = self.name.replace('/', '-')\n        lg.info(\"Saving publish %s in %s\" % (name, save_path))\n        with open(save_path, 'w') as save_file:\n            yaml.dump(yaml_dict, save_file, default_flow_style=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef restore_publish(self, config, components, recreate=False):\n        if \"all\" in components:\n            components = []\n\n        try:\n            self.load()\n            publish = True\n        except NoSuchPublish:\n            publish = False\n\n        new_publish_snapshots = []\n        to_publish = []\n        created_snapshots = []\n\n        for saved_component in config.get('components', []):\n            component_name = saved_component.get('component')\n\n            if not component_name:\n                raise Exception(\"Corrupted file\")\n\n            if components and component_name not in components:\n                continue\n\n            saved_packages = []\n            if not saved_component.get('packages'):\n                raise Exception(\"Component %s is empty\" % component_name)\n\n            for package in saved_component.get('packages'):\n                package_ref = '{} {} {} {}'.format(package.get('arch'), package.get('package'), package.get('version'), package.get('ref'))\n                saved_packages.append(package_ref)\n\n            to_publish.append(component_name)\n\n            timestamp = time.strftime(\"%Y%m%d%H%M%S\")\n            snapshot_name = '{}-{}-{}'.format(\"restored\", timestamp, saved_component.get('snapshot'))\n            lg.debug(\"Creating snapshot %s for component %s of packages: %s\"\n                     % (snapshot_name, component_name, saved_packages))\n\n            try:\n                self.client.do_post(\n                    '/snapshots',\n                    data={\n                        'Name': snapshot_name,\n                        'SourceSnapshots': [],\n                        'Description': saved_component.get('description'),\n                        'PackageRefs': saved_packages,\n                    }\n                )\n                created_snapshots.append(snapshot_name)\n            except AptlyException as e:\n                if e.res.status_code == 404:\n                    # delete all the previously created\n                    # snapshots because the file is corrupted\n                    self._remove_snapshots(created_snapshots)\n                    raise Exception(\"Source snapshot or packages don't exist\")\n                else:\n                    raise\n\n            new_publish_snapshots.append({\n                'Component': component_name,\n                'Name': snapshot_name\n            })\n\n        if components:\n            self.publish_snapshots = [x for x in self.publish_snapshots if x['Component'] not in components and x['Component'] not in to_publish]\n            check_components = [x for x in new_publish_snapshots if x['Component'] in components]\n            if len(check_components) != len(components):\n                self._remove_snapshots(created_snapshots)\n                raise Exception(\"Not possible to find all the components required in the backup file\")\n\n        self.publish_snapshots += new_publish_snapshots\n        self.do_publish(recreate=recreate, merge_snapshots=False)", "response": "Restore publish from config file"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads publish info from remote", "response": "def load(self):\n        \"\"\"\n        Load publish info from remote\n        \"\"\"\n        publish = self._get_publish()\n        self.architectures = publish['Architectures']\n        for source in publish['Sources']:\n            component = source['Component']\n            snapshot = source['Name']\n            self.publish_snapshots.append({\n                'Component': component,\n                'Name': snapshot\n            })\n\n            snapshot_remote = self._find_snapshot(snapshot)\n            for source in self._get_source_snapshots(snapshot_remote, fallback_self=True):\n                self.add(source, component)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_packages(self, component=None, components=[], packages=None):\n        if component:\n            components = [component]\n\n        package_refs = []\n        for snapshot in self.publish_snapshots:\n            if component and snapshot['Component'] not in components:\n                # We don't want packages for this component\n                continue\n\n            component_refs = self._get_packages(self.client, \"snapshots\", snapshot['Name'])\n            if packages:\n                # Filter package names\n                for ref in component_refs:\n                    if self.parse_package_ref(ref)[1] in packages:\n                        package_refs.append(ref)\n            else:\n                package_refs.extend(component_refs)\n\n        return package_refs", "response": "Get packages for given components and packages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_package_ref(self, ref):\n        if not ref:\n            return None\n        parsed = re.match('(.*)\\ (.*)\\ (.*)\\ (.*)', ref)\n        return parsed.groups()", "response": "Parse a package reference string into a tuple of architecture package_name version and id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a snapshot of a component to publish", "response": "def add(self, snapshot, component='main'):\n        \"\"\"\n        Add snapshot of component to publish\n        \"\"\"\n        try:\n            self.components[component].append(snapshot)\n        except KeyError:\n            self.components[component] = [snapshot]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_snapshot(self, name):\n        remote_snapshots = self._get_snapshots(self.client)\n        for remote in reversed(remote_snapshots):\n            if remote[\"Name\"] == name or \\\n                    re.match(name, remote[\"Name\"]):\n                return remote\n        return None", "response": "Find a snapshot on remote by name or regular expression"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting list of source snapshot names of given snapshot", "response": "def _get_source_snapshots(self, snapshot, fallback_self=False):\n        \"\"\"\n        Get list of source snapshot names of given snapshot\n\n        TODO: we have to decide by description at the moment\n        \"\"\"\n        if not snapshot:\n            return []\n\n        source_snapshots = re.findall(r\"'([\\w\\d\\.-]+)'\", snapshot['Description'])\n        if not source_snapshots and fallback_self:\n            source_snapshots = [snapshot['Name']]\n\n        source_snapshots.sort()\n        return source_snapshots"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate component snapshots by merging other snapshots of same component", "response": "def merge_snapshots(self):\n        \"\"\"\n        Create component snapshots by merging other snapshots of same component\n        \"\"\"\n        self.publish_snapshots = []\n        for component, snapshots in self.components.items():\n            if len(snapshots) <= 1:\n                # Only one snapshot, no need to merge\n                lg.debug(\"Component %s has only one snapshot %s, not creating merge snapshot\" % (component, snapshots))\n                self.publish_snapshots.append({\n                    'Component': component,\n                    'Name': snapshots[0]\n                })\n                continue\n\n            # Look if merged snapshot doesn't already exist\n            remote_snapshot = self._find_snapshot(r'^%s%s-%s-\\d+' % (self.merge_prefix, self.name.replace('./', '').replace('/', '-'), component))\n            if remote_snapshot:\n                source_snapshots = self._get_source_snapshots(remote_snapshot)\n\n                # Check if latest merged snapshot has same source snapshots like us\n                snapshots_want = list(snapshots)\n                snapshots_want.sort()\n\n                lg.debug(\"Comparing snapshots: snapshot_name=%s, snapshot_sources=%s, wanted_sources=%s\" % (remote_snapshot['Name'], source_snapshots, snapshots_want))\n                if snapshots_want == source_snapshots:\n                    lg.info(\"Remote merge snapshot already exists: %s (%s)\" % (remote_snapshot['Name'], source_snapshots))\n                    self.publish_snapshots.append({\n                        'Component': component,\n                        'Name': remote_snapshot['Name']\n                    })\n                    continue\n\n            snapshot_name = '%s%s-%s-%s' % (self.merge_prefix, self.name.replace('./', '').replace('/', '-'), component, self.timestamp)\n            lg.info(\"Creating merge snapshot %s for component %s of snapshots %s\" % (snapshot_name, component, snapshots))\n            package_refs = []\n            for snapshot in snapshots:\n                # Get package refs from each snapshot\n                packages = self._get_packages(self.client, \"snapshots\", snapshot)\n                package_refs.extend(packages)\n\n            try:\n                self.client.do_post(\n                    '/snapshots',\n                    data={\n                        'Name': snapshot_name,\n                        'SourceSnapshots': snapshots,\n                        'Description': \"Merged from sources: %s\" % ', '.join(\"'%s'\" % snap for snap in snapshots),\n                        'PackageRefs': package_refs,\n                    }\n                )\n            except AptlyException as e:\n                if e.res.status_code == 400:\n                    lg.warning(\"Error creating snapshot %s, assuming it already exists\" % snapshot_name)\n                else:\n                    raise\n\n            self.publish_snapshots.append({\n                'Component': component,\n                'Name': snapshot_name\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timing_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"\n        Wrapper for printing execution time.\n\n        Parameters\n        ----------\n        print_time: bool, optional\n            whether or not to print time function takes.\n        \"\"\"\n        print_time = kwargs.pop('print_time', False)\n        if not print_time:\n            return func(*args, **kwargs)\n        else:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n            print(func.__name__ + ' took %.3f seconds' %\n                  (end_time - start_time))\n            return result\n    return wrapper", "response": "A decorator that prints the time func takes to execute."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave and/or loads func output (must be picklable).", "response": "def save_load_result(func):\n    \"\"\"Saves and/or loads func output (must be picklable).\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"\n        Default behavior is no saving and loading. Specify save_name to save\n        and load.\n\n        Parameters\n        ----------\n        save_name: str, optional\n            File name including directory and excluding extension.\n        save: bool, optional\n            Whether or not to save.\n        load: bool, optional\n            Whether or not to load.\n        overwrite existing: bool, optional\n            When the save path already contains file: if True, file will be\n            overwritten, if False the data will be saved with the system time\n            appended to the file name.\n        warn_if_error: bool, optional\n            Whether or not to issue UserWarning if load=True and save_name\n            is not None but there is an error loading.\n\n        Returns\n        -------\n        Result\n            func output.\n        \"\"\"\n        save_name = kwargs.pop('save_name', None)\n        save = kwargs.pop('save', save_name is not None)\n        load = kwargs.pop('load', save_name is not None)\n        overwrite_existing = kwargs.pop('overwrite_existing', True)\n        warn_if_error = kwargs.pop('warn_if_error', False)\n        if load:\n            if save_name is None:\n                warnings.warn(\n                    ('{} has load=True but cannot load because '\n                     'save_name=None'.format(func.__name__)),\n                    UserWarning)\n            else:\n                try:\n                    return pickle_load(save_name)\n                except (OSError, IOError) as err:\n                    if warn_if_error:\n                        msg = ('{} had {} loading file {}.'.format(\n                            func.__name__, type(err).__name__, save_name))\n                        msg = ' Continuing without loading.'\n                        warnings.warn(msg, UserWarning)\n        result = func(*args, **kwargs)\n        if save:\n            if save_name is None:\n                warnings.warn((func.__name__ + ' has save=True but cannot ' +\n                               'save because save_name=None'), UserWarning)\n            else:\n                pickle_save(result, save_name,\n                            overwrite_existing=overwrite_existing)\n        return result\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pickle_save(data, name, **kwargs):\n    extension = kwargs.pop('extension', '.pkl')\n    overwrite_existing = kwargs.pop('overwrite_existing', True)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    filename = name + extension\n    # Check if the target directory exists and if not make it\n    dirname = os.path.dirname(filename)\n    if not os.path.exists(dirname) and dirname != '':\n        os.makedirs(dirname)\n    if os.path.isfile(filename) and not overwrite_existing:\n        print(filename + ' already exists! Saving with time appended')\n        filename = name + '_' + time.asctime().replace(' ', '_')\n        filename += extension\n    # check if permission error is defined (was not before python 3.3)\n    # and otherwise use IOError\n    try:\n        PermissionError\n    except NameError:\n        PermissionError = IOError\n    try:\n        outfile = open(filename, 'wb')\n        pickle.dump(data, outfile)\n        outfile.close()\n    except (MemoryError, PermissionError) as err:\n        warnings.warn((type(err).__name__ + ' in pickle_save: continue without'\n                       ' saving.'), UserWarning)", "response": "Saves object with pickle."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pickle_load(name, extension='.pkl'):\n    filename = name + extension\n    infile = open(filename, 'rb')\n    data = pickle.load(infile)\n    infile.close()\n    return data", "response": "Load data with pickle."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbootstraps resamples threads of nested sampling run returning a new nested sampling run.", "response": "def bootstrap_resample_run(ns_run, threads=None, ninit_sep=False,\n                           random_seed=False):\n    \"\"\"Bootstrap resamples threads of nested sampling run, returning a new\n    (resampled) nested sampling run.\n\n    Get the individual threads for a nested sampling run.\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dictionary.\n    threads: None or list of numpy arrays, optional\n    ninit_sep: bool\n        For dynamic runs: resample initial threads and dynamically added\n        threads separately. Useful when there are only a few threads which\n        start by sampling the whole prior, as errors occur if none of these are\n        included in the bootstrap resample.\n    random_seed: None, bool or int, optional\n        Set numpy random seed. Default is to use None (so a random seed is\n        chosen from the computer's internal state) to ensure reliable results\n        when multiprocessing. Can set to an integer or to False to not edit the\n        seed.\n\n\n    Returns\n    -------\n    ns_run_temp: dict\n        Nested sampling run dictionary.\n    \"\"\"\n    if random_seed is not False:\n        # save the random state so we don't affect other bits of the code\n        state = np.random.get_state()\n        np.random.seed(random_seed)\n    if threads is None:\n        threads = nestcheck.ns_run_utils.get_run_threads(ns_run)\n    n_threads = len(threads)\n    if ninit_sep:\n        try:\n            ninit = ns_run['settings']['ninit']\n            assert np.all(ns_run['thread_min_max'][:ninit, 0] == -np.inf), (\n                'ninit_sep assumes the initial threads are labeled '\n                '(0,...,ninit-1), so these should start by sampling the whole '\n                'prior.')\n            inds = np.random.randint(0, ninit, ninit)\n            inds = np.append(inds, np.random.randint(ninit, n_threads,\n                                                     n_threads - ninit))\n        except KeyError:\n            warnings.warn((\n                'bootstrap_resample_run has kwarg ninit_sep=True but '\n                'ns_run[\"settings\"][\"ninit\"] does not exist. Doing bootstrap '\n                'with ninit_sep=False'), UserWarning)\n            ninit_sep = False\n    if not ninit_sep:\n        inds = np.random.randint(0, n_threads, n_threads)\n    threads_temp = [threads[i] for i in inds]\n    resampled_run = nestcheck.ns_run_utils.combine_threads(threads_temp)\n    try:\n        resampled_run['settings'] = ns_run['settings']\n    except KeyError:\n        pass\n    if random_seed is not False:\n        # if we have used a random seed then return to the original state\n        np.random.set_state(state)\n    return resampled_run"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_std_bootstrap(ns_run, estimator_list, **kwargs):\n    bs_values = run_bootstrap_values(ns_run, estimator_list, **kwargs)\n    stds = np.zeros(bs_values.shape[0])\n    for j, _ in enumerate(stds):\n        stds[j] = np.std(bs_values[j, :], ddof=1)\n    return stds", "response": "Uses bootstrap resampling to calculate an estimate of the the\n    standard deviation of the distribution of sampling errors on the calculation result for each estimator in estimator_list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse bootstrap resampling to calculate an estimate of the standard deviation of the distribution of sampling errors on the calculation result for each estimator in estimator_list.", "response": "def run_bootstrap_values(ns_run, estimator_list, **kwargs):\n    \"\"\"Uses bootstrap resampling to calculate an estimate of the\n    standard deviation of the distribution of sampling errors (the\n    uncertainty on the calculation) for a single nested sampling run.\n\n    For more details about bootstrap resampling for estimating sampling\n    errors see 'Sampling errors in nested sampling parameter estimation'\n    (Higson et al. 2018).\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dictionary.\n    estimator_list: list of functions for estimating quantities (such as the\n        Bayesian evidence or mean of parameters) from nested sampling runs.\n        Example functions can be found in estimators.py. Each should have\n        arguments: func(ns_run, logw=None)\n    n_simulate: int\n    ninit_sep: bool, optional\n        For dynamic runs: resample initial threads and dynamically added\n        threads separately. Useful when there are only a few threads which\n        start by sampling the whole prior, as errors occur if none of these are\n        included in the bootstrap resample.\n    flip_skew: bool, optional\n        Determine if distribution of bootstrap values should be flipped about\n        its mean to better represent our probability distribution on the true\n        value - see \"Bayesian astrostatistics: a backward look to the future\"\n        (Loredo, 2012 Figure 2) for an explanation.\n        If true, the samples :math:`X` are mapped to :math:`2 \\mu - X`, where\n        :math:`\\mu` is the mean sample value.\n        This leaves the mean and standard deviation unchanged.\n    random_seeds: list, optional\n        list of random_seed arguments for bootstrap_resample_run.\n        Defaults to range(n_simulate) in order to give reproducible results.\n\n    Returns\n    -------\n    output: 1d numpy array\n        Sampling error on calculation result for each estimator in\n        estimator_list.\n    \"\"\"\n    ninit_sep = kwargs.pop('ninit_sep', False)\n    flip_skew = kwargs.pop('flip_skew', True)\n    n_simulate = kwargs.pop('n_simulate')  # No default, must specify\n    random_seeds = kwargs.pop('random_seeds', range(n_simulate))\n    assert len(random_seeds) == n_simulate\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    threads = nestcheck.ns_run_utils.get_run_threads(ns_run)\n    bs_values = np.zeros((len(estimator_list), n_simulate))\n    for i, random_seed in enumerate(random_seeds):\n        ns_run_temp = bootstrap_resample_run(\n            ns_run, threads=threads, ninit_sep=ninit_sep,\n            random_seed=random_seed)\n        bs_values[:, i] = nestcheck.ns_run_utils.run_estimators(\n            ns_run_temp, estimator_list)\n        del ns_run_temp\n    if flip_skew:\n        estimator_means = np.mean(bs_values, axis=1)\n        for i, mu in enumerate(estimator_means):\n            bs_values[i, :] = (2 * mu) - bs_values[i, :]\n    return bs_values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse bootstrap resampling to calculate credible intervals on the sampling errors on the calculation result for each nested sampling run.", "response": "def run_ci_bootstrap(ns_run, estimator_list, **kwargs):\n    \"\"\"Uses bootstrap resampling to calculate credible intervals on the\n    distribution of sampling errors (the uncertainty on the calculation)\n    for a single nested sampling run.\n\n    For more details about bootstrap resampling for estimating sampling\n    errors see 'Sampling errors in nested sampling parameter estimation'\n    (Higson et al. 2018).\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dictionary.\n    estimator_list: list of functions for estimating quantities (such as the\n        Bayesian evidence or mean of parameters) from nested sampling runs.\n        Example functions can be found in estimators.py. Each should have\n        arguments: func(ns_run, logw=None)\n    cred_int: float\n    n_simulate: int\n    ninit_sep: bool, optional\n\n    Returns\n    -------\n    output: 1d numpy array\n        Credible interval on sampling error on calculation result for each\n        estimator in estimator_list.\n    \"\"\"\n    cred_int = kwargs.pop('cred_int')   # No default, must specify\n    bs_values = run_bootstrap_values(ns_run, estimator_list, **kwargs)\n    # estimate specific confidence intervals\n    # formulae for alpha CI on estimator T = 2 T(x) - G^{-1}(T(x*))\n    # where G is the CDF of the bootstrap resamples\n    expected_estimators = nestcheck.ns_run_utils.run_estimators(\n        ns_run, estimator_list)\n    cdf = ((np.asarray(range(bs_values.shape[1])) + 0.5) /\n           bs_values.shape[1])\n    ci_output = expected_estimators * 2\n    for i, _ in enumerate(ci_output):\n        ci_output[i] -= np.interp(\n            1. - cred_int, cdf, np.sort(bs_values[i, :]))\n    return ci_output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_std_simulate(ns_run, estimator_list, n_simulate=None):\n    assert n_simulate is not None, 'run_std_simulate: must specify n_simulate'\n    all_values = np.zeros((len(estimator_list), n_simulate))\n    for i in range(n_simulate):\n        all_values[:, i] = nestcheck.ns_run_utils.run_estimators(\n            ns_run, estimator_list, simulate=True)\n    stds = np.zeros(all_values.shape[0])\n    for i, _ in enumerate(stds):\n        stds[i] = np.std(all_values[i, :], ddof=1)\n    return stds", "response": "Uses the simulated weights method to calculate an estimate of the standard deviation of the distribution of sampling errors the\n    uncertainty on the calculation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply statistical_distances to each unique pair of distribution samples in dist_list.", "response": "def pairwise_distances(dist_list, earth_mover_dist=True, energy_dist=True):\n    \"\"\"Applies statistical_distances to each unique pair of distribution\n    samples in dist_list.\n\n    Parameters\n    ----------\n    dist_list: list of 1d arrays\n    earth_mover_dist: bool, optional\n        Passed to statistical_distances.\n    energy_dist: bool, optional\n        Passed to statistical_distances.\n\n    Returns\n    -------\n    ser: pandas Series object\n        Values are statistical distances. Index levels are:\n        calculation type: name of statistical distance.\n        run: tuple containing the index in dist_list of the pair of samples\n        arrays from which the statistical distance was computed.\n    \"\"\"\n    out = []\n    index = []\n    for i, samp_i in enumerate(dist_list):\n        for j, samp_j in enumerate(dist_list):\n            if j < i:\n                index.append(str((i, j)))\n                out.append(statistical_distances(\n                    samp_i, samp_j, earth_mover_dist=earth_mover_dist,\n                    energy_dist=energy_dist))\n    columns = ['ks pvalue', 'ks distance']\n    if earth_mover_dist:\n        columns.append('earth mover distance')\n    if energy_dist:\n        columns.append('energy distance')\n    ser = pd.DataFrame(out, index=index, columns=columns).unstack()\n    ser.index.names = ['calculation type', 'run']\n    return ser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the statistical distances between two samples.", "response": "def statistical_distances(samples1, samples2, earth_mover_dist=True,\n                          energy_dist=True):\n    \"\"\"Compute measures of the statistical distance between samples.\n\n    Parameters\n    ----------\n    samples1: 1d array\n    samples2: 1d array\n    earth_mover_dist: bool, optional\n        Whether or not to compute the Earth mover's distance between the\n        samples.\n    energy_dist: bool, optional\n        Whether or not to compute the energy distance between the samples.\n\n    Returns\n    -------\n    1d array\n    \"\"\"\n    out = []\n    temp = scipy.stats.ks_2samp(samples1, samples2)\n    out.append(temp.pvalue)\n    out.append(temp.statistic)\n    if earth_mover_dist:\n        out.append(scipy.stats.wasserstein_distance(samples1, samples2))\n    if energy_dist:\n        out.append(scipy.stats.energy_distance(samples1, samples2))\n    return np.asarray(out)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating dummy data for a single nested sampling thread.", "response": "def get_dummy_thread(nsamples, **kwargs):\n    \"\"\"Generate dummy data for a single nested sampling thread.\n\n    Log-likelihood values of points are generated from a uniform distribution\n    in (0, 1), sorted, scaled by logl_range and shifted by logl_start (if it is\n    not -np.inf). Theta values of each point are each generated from a uniform\n    distribution in (0, 1).\n\n    Parameters\n    ----------\n    nsamples: int\n        Number of samples in thread.\n    ndim: int, optional\n        Number of dimensions.\n    seed: int, optional\n        If not False, the seed is set with np.random.seed(seed).\n    logl_start: float, optional\n        logl at which thread starts.\n    logl_range: float, optional\n        Scale factor applied to logl values.\n    \"\"\"\n    seed = kwargs.pop('seed', False)\n    ndim = kwargs.pop('ndim', 2)\n    logl_start = kwargs.pop('logl_start', -np.inf)\n    logl_range = kwargs.pop('logl_range', 1)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    if seed is not False:\n        np.random.seed(seed)\n    thread = {'logl': np.sort(np.random.random(nsamples)) * logl_range,\n              'nlive_array': np.full(nsamples, 1.),\n              'theta': np.random.random((nsamples, ndim)),\n              'thread_labels': np.zeros(nsamples).astype(int)}\n    if logl_start != -np.inf:\n        thread['logl'] += logl_start\n    thread['thread_min_max'] = np.asarray([[logl_start, thread['logl'][-1]]])\n    return thread"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dummy_run(nthread, nsamples, **kwargs):\n    seed = kwargs.pop('seed', False)\n    ndim = kwargs.pop('ndim', 2)\n    logl_start = kwargs.pop('logl_start', -np.inf)\n    logl_range = kwargs.pop('logl_range', 1)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    threads = []\n    # set seed before generating any threads and do not reset for each thread\n    if seed is not False:\n        np.random.seed(seed)\n    threads = []\n    for _ in range(nthread):\n        threads.append(get_dummy_thread(\n            nsamples, ndim=ndim, seed=False, logl_start=logl_start,\n            logl_range=logl_range))\n    # Sort threads in order of starting logl so labels match labels that would\n    # have been given processing a dead points array. N.B. this only works when\n    # all threads have same start_logl\n    threads = sorted(threads, key=lambda th: th['logl'][0])\n    for i, _ in enumerate(threads):\n        threads[i]['thread_labels'] = np.full(nsamples, i)\n    # Use combine_ns_runs rather than combine threads as this relabels the\n    # threads according to their order\n    return nestcheck.ns_run_utils.combine_threads(threads)", "response": "Generate dummy data for a nested sampling run."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating dummy data for a dynamic nested sampling run.", "response": "def get_dummy_dynamic_run(nsamples, **kwargs):\n    \"\"\"Generate dummy data for a dynamic nested sampling run.\n\n    Loglikelihood values of points are generated from a uniform distribution\n    in (0, 1), sorted, scaled by logl_range and shifted by logl_start (if it is\n    not -np.inf). Theta values of each point are each generated from a uniform\n    distribution in (0, 1).\n\n    Parameters\n    ----------\n    nsamples: int\n        Number of samples in thread.\n    nthread_init: int\n        Number of threads in the inital run (starting at logl=-np.inf).\n    nthread_dyn: int\n        Number of threads in the inital run (starting at randomly chosen points\n        in the initial run).\n    ndim: int, optional\n        Number of dimensions.\n    seed: int, optional\n        If not False, the seed is set with np.random.seed(seed).\n    logl_start: float, optional\n        logl at which thread starts.\n    logl_range: float, optional\n        Scale factor applied to logl values.\n    \"\"\"\n    seed = kwargs.pop('seed', False)\n    ndim = kwargs.pop('ndim', 2)\n    nthread_init = kwargs.pop('nthread_init', 2)\n    nthread_dyn = kwargs.pop('nthread_dyn', 3)\n    logl_range = kwargs.pop('logl_range', 1)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    init = get_dummy_run(nthread_init, nsamples, ndim=ndim, seed=seed,\n                         logl_start=-np.inf, logl_range=logl_range)\n    dyn_starts = list(np.random.choice(\n        init['logl'], nthread_dyn, replace=True))\n    threads = nestcheck.ns_run_utils.get_run_threads(init)\n    # Seed must be False here so it is not set again for each thread\n    threads += [get_dummy_thread(\n        nsamples, ndim=ndim, seed=False, logl_start=start,\n        logl_range=logl_range) for start in dyn_starts]\n    # make sure the threads have unique labels and combine them\n    for i, _ in enumerate(threads):\n        threads[i]['thread_labels'] = np.full(nsamples, i)\n    run = nestcheck.ns_run_utils.combine_threads(threads)\n    # To make sure the thread labelling is same way it would when\n    # processing a dead points file, tranform into dead points\n    samples = nestcheck.write_polychord_output.run_dead_birth_array(run)\n    return nestcheck.data_processing.process_samples_array(samples)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_long_description():\n    pkg_dir = get_package_dir()\n    with open(os.path.join(pkg_dir, '.pypi_long_desc.rst')) as readme_file:\n        long_description = readme_file.read()\n    return long_description", "response": "Get PyPI long description from the. rst file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting single - source __version__.", "response": "def get_version():\n    \"\"\"Get single-source __version__.\"\"\"\n    pkg_dir = get_package_dir()\n    with open(os.path.join(pkg_dir, 'nestcheck/_version.py')) as ver_file:\n        string = ver_file.read()\n    return string.strip().replace('__version__ = ', '').replace('\\'', '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_run_nlive(method_names, run_dict, **kwargs):\n    logx_given_logl = kwargs.pop('logx_given_logl', None)\n    logl_given_logx = kwargs.pop('logl_given_logx', None)\n    logx_min = kwargs.pop('logx_min', None)\n    ymax = kwargs.pop('ymax', None)\n    npoints = kwargs.pop('npoints', 100)\n    figsize = kwargs.pop('figsize', (6.4, 2))\n    post_mass_norm = kwargs.pop('post_mass_norm', None)\n    cum_post_mass_norm = kwargs.pop('cum_post_mass_norm', None)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    assert set(method_names) == set(run_dict.keys()), (\n        'input method names=' + str(method_names) + ' do not match run_dict '\n        'keys=' + str(run_dict.keys()))\n    # Plotting\n    # --------\n    fig = plt.figure(figsize=figsize)\n    ax = plt.gca()\n    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n    # Reserve colors for certain common method_names so they are always the\n    # same regardless of method_name order for consistency in the paper.\n    linecolor_dict = {'standard': colors[2],\n                      'dynamic $G=0$': colors[8],\n                      'dynamic $G=1$': colors[9]}\n    ax.set_prop_cycle('color', [colors[i] for i in [4, 1, 6, 0, 3, 5, 7]])\n    integrals_dict = {}\n    logx_min_list = []\n    for method_name in method_names:\n        integrals = np.zeros(len(run_dict[method_name]))\n        for nr, run in enumerate(run_dict[method_name]):\n            if 'logx' in run:\n                logx = run['logx']\n            elif logx_given_logl is not None:\n                logx = logx_given_logl(run['logl'])\n            else:\n                logx = nestcheck.ns_run_utils.get_logx(\n                    run['nlive_array'], simulate=False)\n            logx_min_list.append(logx[-1])\n            logx[0] = 0  # to make lines extend all the way to the end\n            if nr == 0:\n                # Label the first line and store it so we can access its color\n                try:\n                    line, = ax.plot(logx, run['nlive_array'], linewidth=1,\n                                    label=method_name,\n                                    color=linecolor_dict[method_name])\n                except KeyError:\n                    line, = ax.plot(logx, run['nlive_array'], linewidth=1,\n                                    label=method_name)\n            else:\n                # Set other lines to same color and don't add labels\n                ax.plot(logx, run['nlive_array'], linewidth=1,\n                        color=line.get_color())\n            # for normalising analytic weight lines\n            integrals[nr] = -np.trapz(run['nlive_array'], x=logx)\n        integrals_dict[method_name] = integrals[np.isfinite(integrals)]\n    # if not specified, set logx min to the lowest logx reached by a run\n    if logx_min is None:\n        logx_min = np.asarray(logx_min_list).min()\n    if logl_given_logx is not None:\n        # Plot analytic posterior mass and cumulative posterior mass\n        logx_plot = np.linspace(logx_min, 0, npoints)\n        logl = logl_given_logx(logx_plot)\n        # Remove any NaNs\n        logx_plot = logx_plot[np.where(~np.isnan(logl))[0]]\n        logl = logl[np.where(~np.isnan(logl))[0]]\n        w_an = rel_posterior_mass(logx_plot, logl)\n        # Try normalising the analytic distribution of posterior mass to have\n        # the same area under the curve as the runs with dynamic_goal=1 (the\n        # ones which we want to compare to it). If they are not available just\n        # normalise it to the average area under all the runs (which should be\n        # about the same if they have the same number of samples).\n        w_an *= average_by_key(integrals_dict, post_mass_norm)\n        ax.plot(logx_plot, w_an,\n                linewidth=2, label='relative posterior mass',\n                linestyle=':', color='k')\n        # plot cumulative posterior mass\n        w_an_c = np.cumsum(w_an)\n        w_an_c /= np.trapz(w_an_c, x=logx_plot)\n        # Try normalising the cumulative distribution of posterior mass to have\n        # the same area under the curve as the runs with dynamic_goal=0 (the\n        # ones which we want to compare to it). If they are not available just\n        # normalise it to the average area under all the runs (which should be\n        # about the same if they have the same number of samples).\n        w_an_c *= average_by_key(integrals_dict, cum_post_mass_norm)\n        ax.plot(logx_plot, w_an_c, linewidth=2, linestyle='--', dashes=(2, 3),\n                label='posterior mass remaining', color='darkblue')\n    ax.set_ylabel('number of live points')\n    ax.set_xlabel(r'$\\log X $')\n    # set limits\n    if ymax is not None:\n        ax.set_ylim([0, ymax])\n    else:\n        ax.set_ylim(bottom=0)\n    ax.set_xlim([logx_min, 0])\n    ax.legend()\n    return fig", "response": "Plot the allocations of live points as a function of logX for the nested sampling sets of the given method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef kde_plot_df(df, xlims=None, **kwargs):\n    assert xlims is None or isinstance(xlims, dict)\n    figsize = kwargs.pop('figsize', (6.4, 1.5))\n    num_xticks = kwargs.pop('num_xticks', None)\n    nrows = kwargs.pop('nrows', 1)\n    ncols = kwargs.pop('ncols', int(np.ceil(len(df.columns) / nrows)))\n    normalize = kwargs.pop('normalize', True)\n    legend = kwargs.pop('legend', False)\n    legend_kwargs = kwargs.pop('legend_kwargs', {})\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)\n    for nax, col in enumerate(df):\n        if nrows == 1:\n            ax = axes[nax]\n        else:\n            ax = axes[nax // ncols, nax % ncols]\n        supmin = df[col].apply(np.min).min()\n        supmax = df[col].apply(np.max).max()\n        support = np.linspace(supmin - 0.1 * (supmax - supmin),\n                              supmax + 0.1 * (supmax - supmin), 200)\n        handles = []\n        labels = []\n        for name, samps in df[col].iteritems():\n            pdf = scipy.stats.gaussian_kde(samps)(support)\n            if not normalize:\n                pdf /= pdf.max()\n            handles.append(ax.plot(support, pdf, label=name)[0])\n            labels.append(name)\n        ax.set_ylim(bottom=0)\n        ax.set_yticks([])\n        if xlims is not None:\n            try:\n                ax.set_xlim(xlims[col])\n            except KeyError:\n                pass\n        ax.set_xlabel(col)\n        if num_xticks is not None:\n            ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(\n                nbins=num_xticks))\n    if legend:\n        fig.legend(handles, labels, **legend_kwargs)\n    return fig", "response": "Plots kde estimates of distributions of samples in each cell of the dataframe df."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bs_param_dists(run_list, **kwargs):\n    fthetas = kwargs.pop('fthetas', [lambda theta: theta[:, 0],\n                                     lambda theta: theta[:, 1]])\n    labels = kwargs.pop('labels', [r'$\\theta_' + str(i + 1) + '$' for i in\n                                   range(len(fthetas))])\n    ftheta_lims = kwargs.pop('ftheta_lims', [[-1, 1]] * len(fthetas))\n    n_simulate = kwargs.pop('n_simulate', 100)\n    random_seed = kwargs.pop('random_seed', 0)\n    figsize = kwargs.pop('figsize', (6.4, 2))\n    nx = kwargs.pop('nx', 100)\n    ny = kwargs.pop('ny', nx)\n    cache_in = kwargs.pop('cache', None)\n    parallel = kwargs.pop('parallel', True)\n    rasterize_contours = kwargs.pop('rasterize_contours', True)\n    tqdm_kwargs = kwargs.pop('tqdm_kwargs', {'disable': True})\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    # Use random seed to make samples consistent and allow caching.\n    # To avoid fixing seed use random_seed=None\n    state = np.random.get_state()  # save initial random state\n    np.random.seed(random_seed)\n    if not isinstance(run_list, list):\n        run_list = [run_list]\n    assert len(labels) == len(fthetas), (\n        'There should be the same number of axes and labels')\n    width_ratios = [40] * len(fthetas) + [1] * len(run_list)\n    fig, axes = plt.subplots(nrows=1, ncols=len(run_list) + len(fthetas),\n                             gridspec_kw={'wspace': 0.1,\n                                          'width_ratios': width_ratios},\n                             figsize=figsize)\n    colormaps = ['Reds_r', 'Blues_r', 'Greys_r', 'Greens_r', 'Oranges_r']\n    mean_colors = ['darkred', 'darkblue', 'darkgrey', 'darkgreen',\n                   'darkorange']\n    # plot in reverse order so reds are final plot and always on top\n    for nrun, run in reversed(list(enumerate(run_list))):\n        try:\n            cache = cache_in + '_' + str(nrun)\n        except TypeError:\n            cache = None\n        # add bs distribution plots\n        cbar = plot_bs_dists(run, fthetas, axes[:len(fthetas)],\n                             parallel=parallel,\n                             ftheta_lims=ftheta_lims, cache=cache,\n                             n_simulate=n_simulate, nx=nx, ny=ny,\n                             rasterize_contours=rasterize_contours,\n                             mean_color=mean_colors[nrun],\n                             colormap=colormaps[nrun],\n                             tqdm_kwargs=tqdm_kwargs)\n        # add colorbar\n        colorbar_plot = plt.colorbar(cbar, cax=axes[len(fthetas) + nrun],\n                                     ticks=[1, 2, 3])\n        colorbar_plot.solids.set_edgecolor('face')\n        colorbar_plot.ax.set_yticklabels([])\n        if nrun == len(run_list) - 1:\n            colorbar_plot.ax.set_yticklabels(\n                [r'$1\\sigma$', r'$2\\sigma$', r'$3\\sigma$'])\n    # Format axis ticks and labels\n    for nax, ax in enumerate(axes[:len(fthetas)]):\n        ax.set_yticks([])\n        ax.set_xlabel(labels[nax])\n        if ax.is_first_col():\n            ax.set_ylabel('probability')\n        # Prune final xtick label so it doesn't overlap with next plot\n        prune = 'upper' if nax != len(fthetas) - 1 else None\n        ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(\n            nbins=5, prune=prune))\n    np.random.set_state(state)  # return to original random state\n    return fig", "response": "Creates posterior distributions and their bootstrap error functions for nested sampling run lists and estimators."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef param_logx_diagram(run_list, **kwargs):\n    fthetas = kwargs.pop('fthetas', [lambda theta: theta[:, 0],\n                                     lambda theta: theta[:, 1]])\n    labels = kwargs.pop('labels', [r'$\\theta_' + str(i + 1) + '$' for i in\n                                   range(len(fthetas))])\n    ftheta_lims = kwargs.pop('ftheta_lims', [[-1, 1]] * len(fthetas))\n    threads_to_plot = kwargs.pop('threads_to_plot', [0])\n    plot_means = kwargs.pop('plot_means', True)\n    n_simulate = kwargs.pop('n_simulate', 100)\n    random_seed = kwargs.pop('random_seed', 0)\n    logx_min = kwargs.pop('logx_min', None)\n    figsize = kwargs.pop('figsize', (6.4, 2 * (1 + len(fthetas))))\n    colors = kwargs.pop('colors', ['red', 'blue', 'grey', 'green', 'orange'])\n    colormaps = kwargs.pop('colormaps', ['Reds_r', 'Blues_r', 'Greys_r',\n                                         'Greens_r', 'Oranges_r'])\n    # Options for fgivenx\n    cache_in = kwargs.pop('cache', None)\n    parallel = kwargs.pop('parallel', True)\n    rasterize_contours = kwargs.pop('rasterize_contours', True)\n    point_size = kwargs.pop('point_size', 0.2)\n    thin = kwargs.pop('thin', 1)\n    npoints = kwargs.pop('npoints', 100)\n    tqdm_kwargs = kwargs.pop('tqdm_kwargs', {'disable': True})\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    if not isinstance(run_list, list):\n        run_list = [run_list]\n    # Use random seed to make samples consistent and allow caching.\n    # To avoid fixing seed use random_seed=None\n    state = np.random.get_state()  # save initial random state\n    np.random.seed(random_seed)\n    if not plot_means:\n        mean_colors = [None] * len(colors)\n    else:\n        mean_colors = ['dark' + col for col in colors]\n    nlogx = npoints\n    ny_posterior = npoints\n    assert len(fthetas) == len(labels)\n    assert len(fthetas) == len(ftheta_lims)\n    thread_linestyles = ['-', '-.', ':']\n    # make figure\n    # -----------\n    fig, axes = plt.subplots(nrows=1 + len(fthetas), ncols=2, figsize=figsize,\n                             gridspec_kw={'wspace': 0,\n                                          'hspace': 0,\n                                          'width_ratios': [15, 40]})\n    # make colorbar axes in top left corner\n    axes[0, 0].set_visible(False)\n    divider = mpl_toolkits.axes_grid1.make_axes_locatable(axes[0, 0])\n    colorbar_ax_list = []\n    for i in range(len(run_list)):\n        colorbar_ax_list.append(divider.append_axes(\"left\", size=0.05,\n                                                    pad=0.05))\n    # Reverse color bar axis order so when an extra run is added the other\n    # colorbars stay in the same place\n    colorbar_ax_list = list(reversed(colorbar_ax_list))\n    # plot runs in reverse order to put the first run on top\n    for nrun, run in reversed(list(enumerate(run_list))):\n        # Weight Plot\n        # -----------\n        ax_weight = axes[0, 1]\n        ax_weight.set_ylabel('posterior\\nmass')\n        samples = np.zeros((n_simulate, run['nlive_array'].shape[0] * 2))\n        for i in range(n_simulate):\n            logx_temp = nestcheck.ns_run_utils.get_logx(\n                run['nlive_array'], simulate=True)[::-1]\n            logw_rel = logx_temp + run['logl'][::-1]\n            w_rel = np.exp(logw_rel - logw_rel.max())\n            w_rel /= np.trapz(w_rel, x=logx_temp)\n            samples[i, ::2] = logx_temp\n            samples[i, 1::2] = w_rel\n        if logx_min is None:\n            logx_min = samples[:, 0].min()\n        logx_sup = np.linspace(logx_min, 0, nlogx)\n        try:\n            cache = cache_in + '_' + str(nrun) + '_weights'\n        except TypeError:\n            cache = None\n        interp_alt = functools.partial(alternate_helper, func=np.interp)\n        y, pmf = fgivenx.drivers.compute_pmf(\n            interp_alt, logx_sup, samples, cache=cache, ny=npoints,\n            parallel=parallel, tqdm_kwargs=tqdm_kwargs)\n        cbar = fgivenx.plot.plot(\n            logx_sup, y, pmf, ax_weight, rasterize_contours=rasterize_contours,\n            colors=plt.get_cmap(colormaps[nrun]))\n        ax_weight.set_xlim([logx_min, 0])\n        ax_weight.set_ylim(bottom=0)\n        ax_weight.set_yticks([])\n        ax_weight.set_xticklabels([])\n        # color bar plot\n        # --------------\n        colorbar_plot = plt.colorbar(cbar, cax=colorbar_ax_list[nrun],\n                                     ticks=[1, 2, 3])\n        colorbar_ax_list[nrun].yaxis.set_ticks_position('left')\n        colorbar_plot.solids.set_edgecolor('face')\n        colorbar_plot.ax.set_yticklabels([])\n        if nrun == 0:\n            colorbar_plot.ax.set_yticklabels(\n                [r'$1\\sigma$', r'$2\\sigma$', r'$3\\sigma$'])\n        # samples plot\n        # ------------\n        logx = nestcheck.ns_run_utils.get_logx(run['nlive_array'],\n                                               simulate=False)\n        scatter_x = logx\n        scatter_theta = run['theta']\n        if thin != 1:\n            assert 0 < thin <= 1, (\n                'thin={} should be in the half-closed interval(0, 1]'\n                .format(thin))\n            state = np.random.get_state()  # save initial random state\n            np.random.seed(random_seed)\n            inds = np.where(np.random.random(logx.shape) <= thin)[0]\n            np.random.set_state(state)  # return to original random state\n            scatter_x = logx[inds]\n            scatter_theta = run['theta'][inds, :]\n        for nf, ftheta in enumerate(fthetas):\n            ax_samples = axes[1 + nf, 1]\n            ax_samples.scatter(scatter_x, ftheta(scatter_theta),\n                               s=point_size, color=colors[nrun])\n            if threads_to_plot is not None:\n                for i in threads_to_plot:\n                    thread_inds = np.where(run['thread_labels'] == i)[0]\n                    ax_samples.plot(logx[thread_inds],\n                                    ftheta(run['theta'][thread_inds]),\n                                    linestyle=thread_linestyles[nrun],\n                                    color='black', lw=1)\n            ax_samples.set_xlim([logx_min, 0])\n            ax_samples.set_ylim(ftheta_lims[nf])\n        # Plot posteriors\n        # ---------------\n        posterior_axes = [axes[i + 1, 0] for i in range(len(fthetas))]\n        _ = plot_bs_dists(run, fthetas, posterior_axes,\n                          ftheta_lims=ftheta_lims,\n                          flip_axes=True, n_simulate=n_simulate,\n                          rasterize_contours=rasterize_contours,\n                          cache=cache_in, nx=npoints, ny=ny_posterior,\n                          colormap=colormaps[nrun],\n                          mean_color=mean_colors[nrun],\n                          parallel=parallel, tqdm_kwargs=tqdm_kwargs)\n        # Plot means onto scatter plot\n        # ----------------------------\n        if plot_means:\n            w_rel = nestcheck.ns_run_utils.get_w_rel(run, simulate=False)\n            w_rel /= np.sum(w_rel)\n            means = [np.sum(w_rel * f(run['theta'])) for f in fthetas]\n            for nf, mean in enumerate(means):\n                axes[nf + 1, 1].axhline(y=mean, lw=1, linestyle='--',\n                                        color=mean_colors[nrun])\n    # Format axes\n    for nf, ax in enumerate(posterior_axes):\n        ax.set_ylim(ftheta_lims[nf])\n        ax.invert_xaxis()  # only invert each axis once, not for every run!\n    axes[-1, 1].set_xlabel(r'$\\log X$')\n    # Add labels\n    for i, label in enumerate(labels):\n        axes[i + 1, 0].set_ylabel(label)\n        # Prune final ytick label so it doesn't overlap with next plot\n        prune = 'upper' if i != 0 else None\n        axes[i + 1, 0].yaxis.set_major_locator(\n            matplotlib.ticker.MaxNLocator(nbins=3, prune=prune))\n    for _, ax in np.ndenumerate(axes):\n        if not ax.is_first_col():\n            ax.set_yticklabels([])\n        if not (ax.is_last_row() and ax.is_last_col()):\n            ax.set_xticks([])\n    np.random.set_state(state)  # return to original random state\n    return fig", "response": "Creates a diagram of nested sampling run s evolution towards higher likelihoods."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_bs_dists(run, fthetas, axes, **kwargs):\n    ftheta_lims = kwargs.pop('ftheta_lims', [[-1, 1]] * len(fthetas))\n    n_simulate = kwargs.pop('n_simulate', 100)\n    colormap = kwargs.pop('colormap', plt.get_cmap('Reds_r'))\n    mean_color = kwargs.pop('mean_color', None)\n    nx = kwargs.pop('nx', 100)\n    ny = kwargs.pop('ny', nx)\n    cache_in = kwargs.pop('cache', None)\n    parallel = kwargs.pop('parallel', True)\n    rasterize_contours = kwargs.pop('rasterize_contours', True)\n    smooth = kwargs.pop('smooth', False)\n    flip_axes = kwargs.pop('flip_axes', False)\n    tqdm_kwargs = kwargs.pop('tqdm_kwargs', {'leave': False})\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    assert len(fthetas) == len(axes), \\\n        'There should be the same number of axes and functions to plot'\n    assert len(fthetas) == len(ftheta_lims), \\\n        'There should be the same number of axes and functions to plot'\n    threads = nestcheck.ns_run_utils.get_run_threads(run)\n    # get a list of evenly weighted theta samples from bootstrap resampling\n    bs_samps = []\n    for i in range(n_simulate):\n        run_temp = nestcheck.error_analysis.bootstrap_resample_run(\n            run, threads=threads)\n        w_temp = nestcheck.ns_run_utils.get_w_rel(run_temp, simulate=False)\n        bs_samps.append((run_temp['theta'], w_temp))\n    for nf, ftheta in enumerate(fthetas):\n        # Make an array where each row contains one bootstrap replication's\n        # samples\n        max_samps = 2 * max([bs_samp[0].shape[0] for bs_samp in bs_samps])\n        samples_array = np.full((n_simulate, max_samps), np.nan)\n        for i, (theta, weights) in enumerate(bs_samps):\n            nsamp = 2 * theta.shape[0]\n            samples_array[i, :nsamp:2] = ftheta(theta)\n            samples_array[i, 1:nsamp:2] = weights\n        ftheta_vals = np.linspace(ftheta_lims[nf][0], ftheta_lims[nf][1], nx)\n        try:\n            cache = cache_in + '_' + str(nf)\n        except TypeError:\n            cache = None\n        samp_kde = functools.partial(alternate_helper,\n                                     func=weighted_1d_gaussian_kde)\n        y, pmf = fgivenx.drivers.compute_pmf(\n            samp_kde, ftheta_vals, samples_array, ny=ny, cache=cache,\n            parallel=parallel, tqdm_kwargs=tqdm_kwargs)\n        if flip_axes:\n            cbar = fgivenx.plot.plot(\n                y, ftheta_vals, np.swapaxes(pmf, 0, 1), axes[nf],\n                colors=colormap, rasterize_contours=rasterize_contours,\n                smooth=smooth)\n        else:\n            cbar = fgivenx.plot.plot(\n                ftheta_vals, y, pmf, axes[nf], colors=colormap,\n                rasterize_contours=rasterize_contours, smooth=smooth)\n    # Plot means\n    # ----------\n    if mean_color is not None:\n        w_rel = nestcheck.ns_run_utils.get_w_rel(run, simulate=False)\n        w_rel /= np.sum(w_rel)\n        means = [np.sum(w_rel * f(run['theta'])) for f in fthetas]\n        for nf, mean in enumerate(means):\n            if flip_axes:\n                axes[nf].axhline(y=mean, lw=1, linestyle='--',\n                                 color=mean_color)\n            else:\n                axes[nf].axvline(x=mean, lw=1, linestyle='--',\n                                 color=mean_color)\n    return cbar", "response": "Helper function for plotting bootstrap resamples and fgivenx distributions on posterior distributions\n    using bootstrap resamples and fgivenx module."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef alternate_helper(x, alt_samps, func=None):\n    alt_samps = alt_samps[~np.isnan(alt_samps)]\n    arg1 = alt_samps[::2]\n    arg2 = alt_samps[1::2]\n    return func(x, arg1, arg2)", "response": "Helper function for making fgivenx plots of functions with 2 array\n    arguments of variable lengths."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef weighted_1d_gaussian_kde(x, samples, weights):\n    assert x.ndim == 1\n    assert samples.ndim == 1\n    assert samples.shape == weights.shape\n    # normalise weights and find effective number of samples\n    weights /= np.sum(weights)\n    nz_weights = weights[np.nonzero(weights)]\n    nsamp_eff = np.exp(-1. * np.sum(nz_weights * np.log(nz_weights)))\n    # Calculate the weighted sample variance\n    mu = np.sum(weights * samples)\n    var = np.sum(weights * ((samples - mu) ** 2))\n    var *= nsamp_eff / (nsamp_eff - 1)  # correct for bias using nsamp_eff\n    # Calculate bandwidth\n    scott_factor = np.power(nsamp_eff, -1. / (5))  # 1d Scott factor\n    sig = np.sqrt(var) * scott_factor\n    # Calculate and weight residuals\n    xx, ss = np.meshgrid(x, samples)\n    chisquared = ((xx - ss) / sig) ** 2\n    energy = np.exp(-0.5 * chisquared) / np.sqrt(2 * np.pi * (sig ** 2))\n    result = np.sum(energy * weights[:, np.newaxis], axis=0)\n    return result", "response": "Gaussian kde with weighted samples"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rel_posterior_mass(logx, logl):\n    logw = logx + logl\n    w_rel = np.exp(logw - logw.max())\n    w_rel /= np.abs(np.trapz(w_rel, x=logx))\n    return w_rel", "response": "Calculate the relative posterior mass at each array of logx values at each logl value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing output from many nested sampling runs in parallel with optional error handling and caching.", "response": "def batch_process_data(file_roots, **kwargs):\n    \"\"\"Process output from many nested sampling runs in parallel with optional\n    error handling and caching.\n\n    The result can be cached using the 'save_name', 'save' and 'load' kwargs\n    (by default this is not done). See save_load_result docstring for more\n    details.\n\n    Remaining kwargs passed to parallel_utils.parallel_apply (see its\n    docstring for more details).\n\n    Parameters\n    ----------\n    file_roots: list of strs\n        file_roots for the runs to load.\n    base_dir: str, optional\n        path to directory containing files.\n    process_func: function, optional\n        function to use to process the data.\n    func_kwargs: dict, optional\n        additional keyword arguments for process_func.\n    errors_to_handle: error or tuple of errors, optional\n        which errors to catch when they occur in processing rather than\n        raising.\n    save_name: str or None, optional\n        See nestcheck.io_utils.save_load_result.\n    save: bool, optional\n        See nestcheck.io_utils.save_load_result.\n    load: bool, optional\n        See nestcheck.io_utils.save_load_result.\n    overwrite_existing: bool, optional\n        See nestcheck.io_utils.save_load_result.\n\n    Returns\n    -------\n    list of ns_run dicts\n        List of nested sampling runs in dict format (see the module\n        docstring for more details).\n    \"\"\"\n    base_dir = kwargs.pop('base_dir', 'chains')\n    process_func = kwargs.pop('process_func', process_polychord_run)\n    func_kwargs = kwargs.pop('func_kwargs', {})\n    func_kwargs['errors_to_handle'] = kwargs.pop('errors_to_handle', ())\n    data = nestcheck.parallel_utils.parallel_apply(\n        process_error_helper, file_roots, func_args=(base_dir, process_func),\n        func_kwargs=func_kwargs, **kwargs)\n    # Sort processed runs into the same order as file_roots (as parallel_apply\n    # does not preserve order)\n    data = sorted(data,\n                  key=lambda x: file_roots.index(x['output']['file_root']))\n    # Extract error information and print\n    errors = {}\n    for i, run in enumerate(data):\n        if 'error' in run:\n            try:\n                errors[run['error']].append(i)\n            except KeyError:\n                errors[run['error']] = [i]\n    for error_name, index_list in errors.items():\n        message = (error_name + ' processing ' + str(len(index_list)) + ' / '\n                   + str(len(file_roots)) + ' files')\n        if len(index_list) != len(file_roots):\n            message += ('. Roots with errors have (zero based) indexes: '\n                        + str(index_list))\n        print(message)\n    # Return runs which did not have errors\n    return [run for run in data if 'error' not in run]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_error_helper(root, base_dir, process_func, errors_to_handle=(),\n                         **func_kwargs):\n    \"\"\"Wrapper which applies process_func and handles some common errors so one\n    bad run does not spoil the whole batch.\n\n    Useful errors to handle include:\n\n    OSError: if you are not sure if all the files exist\n    AssertionError: if some of the many assertions fail for known reasons;\n    for example is there are occasional problems decomposing runs into threads\n    due to limited numerical precision in logls.\n\n    Parameters\n    ----------\n    root: str\n        File root.\n    base_dir: str\n        Directory containing file.\n    process_func: func\n        Function for processing file.\n    errors_to_handle: error type or tuple of error types\n        Errors to catch without throwing an exception.\n    func_kwargs: dict\n        Kwargs to pass to process_func.\n\n    Returns\n    -------\n    run: dict\n        Nested sampling run dict (see the module docstring for more\n        details) or, if an error occured, a dict containing its type\n        and the file root.\n    \"\"\"\n    try:\n        return process_func(root, base_dir, **func_kwargs)\n    except errors_to_handle as err:\n        run = {'error': type(err).__name__,\n               'output': {'file_root': root}}\n        return run", "response": "Wrapper which applies process_func and handles common errors and returns a nested sampling run dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_multinest_run(file_root, base_dir, **kwargs):\n    # Load dead and live points\n    dead = np.loadtxt(os.path.join(base_dir, file_root) + '-dead-birth.txt')\n    live = np.loadtxt(os.path.join(base_dir, file_root)\n                      + '-phys_live-birth.txt')\n    # Remove unnecessary final columns\n    dead = dead[:, :-2]\n    live = live[:, :-1]\n    assert dead[:, -2].max() < live[:, -2].min(), (\n        'final live points should have greater logls than any dead point!',\n        dead, live)\n    ns_run = process_samples_array(np.vstack((dead, live)), **kwargs)\n    assert np.all(ns_run['thread_min_max'][:, 0] == -np.inf), (\n        'As MultiNest does not currently perform dynamic nested sampling, all '\n        'threads should start by sampling the whole prior.')\n    ns_run['output'] = {}\n    ns_run['output']['file_root'] = file_root\n    ns_run['output']['base_dir'] = base_dir\n    return ns_run", "response": "Loads data from a MultiNest run into the nestcheck dictionary format for the nested sampling run."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms results from a dynesty run into a nestcheck dictionary.", "response": "def process_dynesty_run(results):\n    \"\"\"Transforms results from a dynesty run into the nestcheck dictionary\n    format for analysis. This function has been tested with dynesty v9.2.0.\n\n    Note that the nestcheck point weights and evidence will not be exactly\n    the same as the dynesty ones as nestcheck calculates logX volumes more\n    precisely (using the trapezium rule).\n\n    This function does not require the birth_inds_given_contours and\n    threads_given_birth_inds functions as dynesty results objects\n    already include thread labels via their samples_id property. If the\n    dynesty run is dynamic, the batch_bounds property is need to determine\n    the threads' starting birth contours.\n\n    Parameters\n    ----------\n    results: dynesty results object\n        N.B. the remaining live points at termination must be included in the\n        results (dynesty samplers' run_nested method does this if\n        add_live_points=True - its default value).\n\n    Returns\n    -------\n    ns_run: dict\n        Nested sampling run dict (see the module docstring for more details).\n    \"\"\"\n    samples = np.zeros((results.samples.shape[0],\n                        results.samples.shape[1] + 3))\n    samples[:, 0] = results.logl\n    samples[:, 1] = results.samples_id\n    samples[:, 3:] = results.samples\n    unique_th, first_inds = np.unique(results.samples_id, return_index=True)\n    assert np.array_equal(unique_th, np.asarray(range(unique_th.shape[0])))\n    thread_min_max = np.full((unique_th.shape[0], 2), np.nan)\n    try:\n        # Try processing standard nested sampling results\n        assert unique_th.shape[0] == results.nlive\n        assert np.array_equal(\n            np.unique(results.samples_id[-results.nlive:]),\n            np.asarray(range(results.nlive))), (\n                'perhaps the final live points are not included?')\n        thread_min_max[:, 0] = -np.inf\n    except AttributeError:\n        # If results has no nlive attribute, it must be dynamic nested sampling\n        assert unique_th.shape[0] == sum(results.batch_nlive)\n        for th_lab, ind in zip(unique_th, first_inds):\n            thread_min_max[th_lab, 0] = (\n                results.batch_bounds[results.samples_batch[ind], 0])\n    for th_lab in unique_th:\n        final_ind = np.where(results.samples_id == th_lab)[0][-1]\n        thread_min_max[th_lab, 1] = results.logl[final_ind]\n        samples[final_ind, 2] = -1\n    assert np.all(~np.isnan(thread_min_max))\n    run = nestcheck.ns_run_utils.dict_given_run_array(samples, thread_min_max)\n    nestcheck.ns_run_utils.check_ns_run(run)\n    return run"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_polychord_stats(file_root, base_dir):\n    filename = os.path.join(base_dir, file_root) + '.stats'\n    output = {'base_dir': base_dir,\n              'file_root': file_root}\n    with open(filename, 'r') as stats_file:\n        lines = stats_file.readlines()\n    output['logZ'] = float(lines[8].split()[2])\n    output['logZerr'] = float(lines[8].split()[4])\n    # Cluster logZs and errors\n    output['logZs'] = []\n    output['logZerrs'] = []\n    for line in lines[14:]:\n        if line[:5] != 'log(Z':\n            break\n        output['logZs'].append(float(\n            re.findall(r'=(.*)', line)[0].split()[0]))\n        output['logZerrs'].append(float(\n            re.findall(r'=(.*)', line)[0].split()[2]))\n    # Other output info\n    nclust = len(output['logZs'])\n    output['ncluster'] = nclust\n    output['nposterior'] = int(lines[20 + nclust].split()[1])\n    output['nequals'] = int(lines[21 + nclust].split()[1])\n    output['ndead'] = int(lines[22 + nclust].split()[1])\n    output['nlive'] = int(lines[23 + nclust].split()[1])\n    try:\n        output['nlike'] = int(lines[24 + nclust].split()[1])\n    except ValueError:\n        # if nlike has too many digits, PolyChord just writes ***** to .stats\n        # file. This causes a ValueError\n        output['nlike'] = np.nan\n    output['avnlike'] = float(lines[25 + nclust].split()[1])\n    output['avnlikeslice'] = float(lines[25 + nclust].split()[3])\n    # Means and stds of dimensions (not produced by PolyChord<=1.13)\n    if len(lines) > 29 + nclust:\n        output['param_means'] = []\n        output['param_mean_errs'] = []\n        for line in lines[29 + nclust:]:\n            output['param_means'].append(float(line.split()[1]))\n            output['param_mean_errs'].append(float(line.split()[3]))\n    return output", "response": "Reads a PolyChord <root. stats output file and returns the information\n    contained in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_samples_array(samples, **kwargs):\n    samples = samples[np.argsort(samples[:, -2])]\n    ns_run = {}\n    ns_run['logl'] = samples[:, -2]\n    ns_run['theta'] = samples[:, :-2]\n    birth_contours = samples[:, -1]\n    # birth_contours, ns_run['theta'] = check_logls_unique(\n    #     samples[:, -2], samples[:, -1], samples[:, :-2])\n    birth_inds = birth_inds_given_contours(\n        birth_contours, ns_run['logl'], **kwargs)\n    ns_run['thread_labels'] = threads_given_birth_inds(birth_inds)\n    unique_threads = np.unique(ns_run['thread_labels'])\n    assert np.array_equal(unique_threads,\n                          np.asarray(range(unique_threads.shape[0])))\n    # Work out nlive_array and thread_min_max logls from thread labels and\n    # birth contours\n    thread_min_max = np.zeros((unique_threads.shape[0], 2))\n    # NB delta_nlive indexes are offset from points' indexes by 1 as we need an\n    # element to represent the initial sampling of live points before any dead\n    # points are created.\n    # I.E. birth on step 1 corresponds to replacing dead point zero\n    delta_nlive = np.zeros(samples.shape[0] + 1)\n    for label in unique_threads:\n        thread_inds = np.where(ns_run['thread_labels'] == label)[0]\n        # Max is final logl in thread\n        thread_min_max[label, 1] = ns_run['logl'][thread_inds[-1]]\n        thread_start_birth_ind = birth_inds[thread_inds[0]]\n        # delta nlive indexes are +1 from logl indexes to allow for initial\n        # nlive (before first dead point)\n        delta_nlive[thread_inds[-1] + 1] -= 1\n        if thread_start_birth_ind == birth_inds[0]:\n            # thread minimum is -inf as it starts by sampling from whole prior\n            thread_min_max[label, 0] = -np.inf\n            delta_nlive[0] += 1\n        else:\n            assert thread_start_birth_ind >= 0\n            thread_min_max[label, 0] = ns_run['logl'][thread_start_birth_ind]\n            delta_nlive[thread_start_birth_ind + 1] += 1\n    ns_run['thread_min_max'] = thread_min_max\n    ns_run['nlive_array'] = np.cumsum(delta_nlive)[:-1]\n    return ns_run", "response": "Convert an array of nested sampling dead points and any remaining live points at termination into a nestcheck nested sampling run dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmapping iso - likelihood contours on which points were born to the index of the first occurrence of the dead point on the contour.", "response": "def birth_inds_given_contours(birth_logl_arr, logl_arr, **kwargs):\n    \"\"\"Maps the iso-likelihood contours on which points were born to the\n    index of the dead point on this contour.\n\n    MultiNest and PolyChord use different values to identify the inital live\n    points which were sampled from the whole prior (PolyChord uses -1e+30\n    and MultiNest -0.179769313486231571E+309). However in each case the first\n    dead point must have been sampled from the whole prior, so for either\n    package we can use\n\n    init_birth = birth_logl_arr[0]\n\n    If there are many points with the same logl_arr and dup_assert is False,\n    these points are randomly assigned an order (to ensure results are\n    consistent, random seeding is used).\n\n    Parameters\n    ----------\n    logl_arr: 1d numpy array\n        logl values of each point.\n    birth_logl_arr: 1d numpy array\n        Birth contours - i.e. logl values of the iso-likelihood contour from\n        within each point was sampled (on which it was born).\n    dup_assert: bool, optional\n        See ns_run_utils.check_ns_run_logls docstring.\n    dup_warn: bool, optional\n        See ns_run_utils.check_ns_run_logls docstring.\n\n    Returns\n    -------\n    birth_inds: 1d numpy array of ints\n        Step at which each element of logl_arr was sampled. Points sampled from\n        the whole prior are assigned value -1.\n    \"\"\"\n    dup_assert = kwargs.pop('dup_assert', False)\n    dup_warn = kwargs.pop('dup_warn', False)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    assert logl_arr.ndim == 1, logl_arr.ndim\n    assert birth_logl_arr.ndim == 1, birth_logl_arr.ndim\n    # Check for duplicate logl values (if specified by dup_assert or dup_warn)\n    nestcheck.ns_run_utils.check_ns_run_logls(\n        {'logl': logl_arr}, dup_assert=dup_assert, dup_warn=dup_warn)\n    # Random seed so results are consistent if there are duplicate logls\n    state = np.random.get_state()  # Save random state before seeding\n    np.random.seed(0)\n    # Calculate birth inds\n    init_birth = birth_logl_arr[0]\n    assert np.all(birth_logl_arr <= logl_arr), (\n        logl_arr[birth_logl_arr > logl_arr])\n    birth_inds = np.full(birth_logl_arr.shape, np.nan)\n    birth_inds[birth_logl_arr == init_birth] = -1\n    for i, birth_logl in enumerate(birth_logl_arr):\n        if not np.isnan(birth_inds[i]):\n            # birth ind has already been assigned\n            continue\n        dup_deaths = np.where(logl_arr == birth_logl)[0]\n        if dup_deaths.shape == (1,):\n            # death index is unique\n            birth_inds[i] = dup_deaths[0]\n            continue\n        # The remainder of this loop deals with the case that multiple points\n        # have the same logl value (=birth_logl). This can occur due to limited\n        # precision, or for likelihoods with contant regions. In this case we\n        # randomly assign the duplicates birth steps in a manner\n        # that provides a valid division into nested sampling runs\n        dup_births = np.where(birth_logl_arr == birth_logl)[0]\n        assert dup_deaths.shape[0] > 1, dup_deaths\n        if np.all(birth_logl_arr[dup_deaths] != birth_logl):\n            # If no points both are born and die on this contour, we can just\n            # randomly assign an order\n            np.random.shuffle(dup_deaths)\n            inds_to_use = dup_deaths\n        else:\n            # If some points are both born and die on the contour, we need to\n            # take care that the assigned birth inds do not result in some\n            # points dying before they are born\n            try:\n                inds_to_use = sample_less_than_condition(\n                    dup_deaths, dup_births)\n            except ValueError:\n                raise ValueError((\n                    'There is no way to allocate indexes dup_deaths={} such '\n                    'that each is less than dup_births={}.').format(\n                        dup_deaths, dup_births))\n        try:\n            # Add our selected inds_to_use values to the birth_inds array\n            # Note that dup_deaths (and hence inds to use) may have more\n            # members than dup_births, because one of the duplicates may be\n            # the final point in a thread. We therefore include only the first\n            # dup_births.shape[0] elements\n            birth_inds[dup_births] = inds_to_use[:dup_births.shape[0]]\n        except ValueError:\n            warnings.warn((\n                'for logl={}, the number of points born (indexes='\n                '{}) is bigger than the number of points dying '\n                '(indexes={}). This indicates a problem with your '\n                'nested sampling software - it may be caused by '\n                'a bug in PolyChord which was fixed in PolyChord '\n                'v1.14, so try upgrading. I will try to give an '\n                'approximate allocation of threads but this may '\n                'fail.').format(\n                    birth_logl, dup_births, inds_to_use), UserWarning)\n            extra_inds = np.random.choice(\n                inds_to_use, size=dup_births.shape[0] - inds_to_use.shape[0])\n            inds_to_use = np.concatenate((inds_to_use, extra_inds))\n            np.random.shuffle(inds_to_use)\n            birth_inds[dup_births] = inds_to_use[:dup_births.shape[0]]\n    assert np.all(~np.isnan(birth_inds)), np.isnan(birth_inds).sum()\n    np.random.set_state(state)  # Reset random state\n    return birth_inds.astype(int)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a random sample from choices without replacement subject to the condition that each element of the output is greater than the corresponding element of the condition array.", "response": "def sample_less_than_condition(choices_in, condition):\n    \"\"\"Creates a random sample from choices without replacement, subject to the\n    condition that each element of the output is greater than the corresponding\n    element of the condition array.\n\n    condition should be in ascending order.\n    \"\"\"\n    output = np.zeros(min(condition.shape[0], choices_in.shape[0]))\n    choices = copy.deepcopy(choices_in)\n    for i, _ in enumerate(output):\n        # randomly select one of the choices which meets condition\n        avail_inds = np.where(choices < condition[i])[0]\n        selected_ind = np.random.choice(avail_inds)\n        output[i] = choices[selected_ind]\n        # remove the chosen value\n        choices = np.delete(choices, selected_ind)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef threads_given_birth_inds(birth_inds):\n    unique, counts = np.unique(birth_inds, return_counts=True)\n    # First get a list of all the indexes on which threads start and their\n    # counts. This is every point initially sampled from the prior, plus any\n    # indexes where more than one point is sampled.\n    thread_start_inds = np.concatenate((\n        unique[:1], unique[1:][counts[1:] > 1]))\n    thread_start_counts = np.concatenate((\n        counts[:1], counts[1:][counts[1:] > 1] - 1))\n    thread_labels = np.full(birth_inds.shape, np.nan)\n    thread_num = 0\n    for nmulti, multi in enumerate(thread_start_inds):\n        for i, start_ind in enumerate(np.where(birth_inds == multi)[0]):\n            # unless nmulti=0 the first point born on the contour (i=0) is\n            # already assigned to a thread\n            if i != 0 or nmulti == 0:\n                # check point has not already been assigned\n                assert np.isnan(thread_labels[start_ind])\n                thread_labels[start_ind] = thread_num\n                # find the point which replaced it\n                next_ind = np.where(birth_inds == start_ind)[0]\n                while next_ind.shape != (0,):\n                    # check point has not already been assigned\n                    assert np.isnan(thread_labels[next_ind[0]])\n                    thread_labels[next_ind[0]] = thread_num\n                    # find the point which replaced it\n                    next_ind = np.where(birth_inds == next_ind[0])[0]\n                thread_num += 1\n    if not np.all(~np.isnan(thread_labels)):\n        warnings.warn((\n            '{} points (out of a total of {}) were not given a thread label! '\n            'This is likely due to small numerical errors in your nested '\n            'sampling software while running the calculation or writing the '\n            'input files. '\n            'I will try to give an approximate answer by randomly assigning '\n            'these points to threads.'\n            '\\nIndexes without labels are {}'\n            '\\nIndexes on which threads start are {} with {} threads '\n            'starting on each.').format(\n                (np.isnan(thread_labels)).sum(), birth_inds.shape[0],\n                np.where(np.isnan(thread_labels))[0],\n                thread_start_inds, thread_start_counts))\n        inds = np.where(np.isnan(thread_labels))[0]\n        state = np.random.get_state()  # Save random state before seeding\n        np.random.seed(0)  # make thread decomposition is reproducible\n        for ind in inds:\n            # Get the set of threads with members both before and after ind to\n            # ensure we don't change nlive_array by extending a thread\n            labels_to_choose = np.intersect1d(  # N.B. this removes nans too\n                thread_labels[:ind], thread_labels[ind + 1:])\n            if labels_to_choose.shape[0] == 0:\n                # In edge case that there is no intersection, just randomly\n                # select from non-nan thread labels\n                labels_to_choose = np.unique(\n                    thread_labels[~np.isnan(thread_labels)])\n            thread_labels[ind] = np.random.choice(labels_to_choose)\n        np.random.set_state(state)  # Reset random state\n    assert np.all(~np.isnan(thread_labels)), (\n        '{} points still do not have thread labels'.format(\n            (np.isnan(thread_labels)).sum()))\n    assert np.array_equal(thread_labels, thread_labels.astype(int)), (\n        'Thread labels should all be ints!')\n    thread_labels = thread_labels.astype(int)\n    # Check unique thread labels are a sequence from 0 to nthreads-1\n    assert np.array_equal(\n        np.unique(thread_labels),\n        np.asarray(range(sum(thread_start_counts)))), (\n            str(np.unique(thread_labels)) + ' is not equal to range('\n            + str(sum(thread_start_counts)) + ')')\n    return thread_labels", "response": "Divides a nested sampling run into threads given a list of birth indices."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parallel_map(func, *arg_iterable, **kwargs):\n    chunksize = kwargs.pop('chunksize', 1)\n    func_pre_args = kwargs.pop('func_pre_args', ())\n    func_kwargs = kwargs.pop('func_kwargs', {})\n    max_workers = kwargs.pop('max_workers', None)\n    parallel = kwargs.pop('parallel', True)\n    parallel_warning = kwargs.pop('parallel_warning', True)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    func_to_map = functools.partial(func, *func_pre_args, **func_kwargs)\n    if parallel:\n        pool = concurrent.futures.ProcessPoolExecutor(max_workers=max_workers)\n        return list(pool.map(func_to_map, *arg_iterable, chunksize=chunksize))\n    else:\n        if parallel_warning:\n            warnings.warn(('parallel_map has parallel=False - turn on '\n                           'parallelisation for faster processing'),\n                          UserWarning)\n        return list(map(func_to_map, *arg_iterable))", "response": "Apply function to iterable with parallel map and return list of function outputs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parallel_apply(func, arg_iterable, **kwargs):\n    max_workers = kwargs.pop('max_workers', None)\n    parallel = kwargs.pop('parallel', True)\n    parallel_warning = kwargs.pop('parallel_warning', True)\n    func_args = kwargs.pop('func_args', ())\n    func_pre_args = kwargs.pop('func_pre_args', ())\n    func_kwargs = kwargs.pop('func_kwargs', {})\n    tqdm_kwargs = kwargs.pop('tqdm_kwargs', {})\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    if 'leave' not in tqdm_kwargs:  # default to leave=False\n        tqdm_kwargs['leave'] = False\n    assert isinstance(func_args, tuple), (\n        str(func_args) + ' is type ' + str(type(func_args)))\n    assert isinstance(func_pre_args, tuple), (\n        str(func_pre_args) + ' is type ' + str(type(func_pre_args)))\n    progress = select_tqdm()\n    if not parallel:\n        if parallel_warning:\n            warnings.warn(('parallel_map has parallel=False - turn on '\n                           'parallelisation for faster processing'),\n                          UserWarning)\n        return [func(*(func_pre_args + (x,) + func_args), **func_kwargs) for\n                x in progress(arg_iterable, **tqdm_kwargs)]\n    else:\n        pool = concurrent.futures.ProcessPoolExecutor(max_workers=max_workers)\n        futures = []\n        for element in arg_iterable:\n            futures.append(pool.submit(\n                func, *(func_pre_args + (element,) + func_args),\n                **func_kwargs))\n        results = []\n        for fut in progress(concurrent.futures.as_completed(futures),\n                            total=len(arg_iterable), **tqdm_kwargs):\n            results.append(fut.result())\n        return results", "response": "Apply function to iterable with parallelisation and a tqdm progress bar."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a tqdm progress bar.", "response": "def select_tqdm():\n    \"\"\"If running in a jupyter notebook, then returns tqdm_notebook.\n    Otherwise returns a regular tqdm progress bar.\n\n    Returns\n    -------\n    progress: function\n    \"\"\"\n    try:\n        progress = tqdm.tqdm_notebook\n        assert get_ipython().has_trait('kernel')\n    except (NameError, AssertionError):\n        progress = tqdm.tqdm\n    return progress"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a panda data frame of the mean and std devs of an array of results, including the uncertainties on the values. This function converts the array to a DataFrame and calls summary_df on it. Parameters ---------- results_array: 2d numpy array names: list of str Names for the output df's columns. axis: int, optional Axis on which to calculate summary statistics. Returns ------- df: MultiIndex DataFrame See summary_df docstring for more details.", "response": "def summary_df_from_array(results_array, names, axis=0, **kwargs):\n    \"\"\"Make a panda data frame of the mean and std devs of an array of results,\n    including the uncertainties on the values.\n\n    This function converts the array to a DataFrame and calls summary_df on it.\n\n    Parameters\n    ----------\n    results_array: 2d numpy array\n    names: list of str\n        Names for the output df's columns.\n    axis: int, optional\n        Axis on which to calculate summary statistics.\n\n    Returns\n    -------\n    df: MultiIndex DataFrame\n        See summary_df docstring for more details.\n    \"\"\"\n    assert axis == 0 or axis == 1\n    df = pd.DataFrame(results_array)\n    if axis == 1:\n        df = df.T\n    df.columns = names\n    return summary_df(df, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summary_df_from_list(results_list, names, **kwargs):\n    for arr in results_list:\n        assert arr.shape == (len(names),)\n    df = pd.DataFrame(np.stack(results_list, axis=0))\n    df.columns = names\n    return summary_df(df, **kwargs)", "response": "This function converts a list of 1d numpy arrays to a DataFrame and calls summary_df on it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying summary_df to a multiindex while preserving some levels.", "response": "def summary_df_from_multi(multi_in, inds_to_keep=None, **kwargs):\n    \"\"\"Apply summary_df to a multiindex while preserving some levels.\n\n    Parameters\n    ----------\n    multi_in: multiindex pandas DataFrame\n    inds_to_keep: None or list of strs, optional\n        Index levels to preserve.\n    kwargs: dict, optional\n        Keyword arguments to pass to summary_df.\n\n    Returns\n    -------\n    df: MultiIndex DataFrame\n        See summary_df docstring for more details.\n    \"\"\"\n    # Need to pop include true values and add separately at the end as\n    # otherwise we get multiple true values added\n    include_true_values = kwargs.pop('include_true_values', False)\n    true_values = kwargs.get('true_values', None)\n    if inds_to_keep is None:\n        inds_to_keep = list(multi_in.index.names)[:-1]\n    if 'calculation type' not in inds_to_keep:\n        df = multi_in.groupby(inds_to_keep).apply(\n            summary_df, include_true_values=False, **kwargs)\n    else:\n        # If there is already a level called 'calculation type' in multi,\n        # summary_df will try making a second 'calculation type' index and (as\n        # of pandas v0.23.0) throw an error. Avoid this by renaming.\n        inds_to_keep = [lev if lev != 'calculation type' else\n                        'calculation type temp' for lev in inds_to_keep]\n        multi_temp = copy.deepcopy(multi_in)\n        multi_temp.index.set_names(\n            [lev if lev != 'calculation type' else 'calculation type temp' for\n             lev in list(multi_temp.index.names)], inplace=True)\n        df = multi_temp.groupby(inds_to_keep).apply(\n            summary_df, include_true_values=False, **kwargs)\n        # add the 'calculation type' values ('mean' and 'std') produced by\n        # summary_df to the input calculation type names (now in level\n        # 'calculation type temp')\n        ind = (df.index.get_level_values('calculation type temp') + ' ' +\n               df.index.get_level_values('calculation type'))\n        order = list(df.index.names)\n        order.remove('calculation type temp')\n        df.index = df.index.droplevel(\n            ['calculation type', 'calculation type temp'])\n        df['calculation type'] = list(ind)\n        df.set_index('calculation type', append=True, inplace=True)\n        df = df.reorder_levels(order)\n    if include_true_values:\n        assert true_values is not None\n        tv_ind = ['true values' if name == 'calculation type' else '' for\n                  name in df.index.names[:-1]] + ['value']\n        df.loc[tuple(tv_ind), :] = true_values\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef summary_df(df_in, **kwargs):\n    true_values = kwargs.pop('true_values', None)\n    include_true_values = kwargs.pop('include_true_values', False)\n    include_rmse = kwargs.pop('include_rmse', False)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    if true_values is not None:\n        assert true_values.shape[0] == df_in.shape[1], (\n            'There should be one true value for every column! '\n            'true_values.shape=' + str(true_values.shape) + ', '\n            'df_in.shape=' + str(df_in.shape))\n    # make the data frame\n    df = pd.DataFrame([df_in.mean(axis=0), df_in.std(axis=0, ddof=1)],\n                      index=['mean', 'std'])\n    if include_true_values:\n        assert true_values is not None\n        df.loc['true values'] = true_values\n    # Make index categorical to allow sorting\n    df.index = pd.CategoricalIndex(df.index.values, ordered=True,\n                                   categories=['true values', 'mean', 'std',\n                                               'rmse'],\n                                   name='calculation type')\n    # add uncertainties\n    num_cals = df_in.shape[0]\n    mean_unc = df.loc['std'] / np.sqrt(num_cals)\n    std_unc = df.loc['std'] * np.sqrt(1 / (2 * (num_cals - 1)))\n    df['result type'] = pd.Categorical(['value'] * df.shape[0], ordered=True,\n                                       categories=['value', 'uncertainty'])\n    df.set_index(['result type'], drop=True, append=True, inplace=True)\n    df.loc[('mean', 'uncertainty'), :] = mean_unc.values\n    df.loc[('std', 'uncertainty'), :] = std_unc.values\n    if include_rmse:\n        assert true_values is not None, \\\n            'Need to input true values for RMSE!'\n        rmse, rmse_unc = rmse_and_unc(df_in.values, true_values)\n        df.loc[('rmse', 'value'), :] = rmse\n        df.loc[('rmse', 'uncertainty'), :] = rmse_unc\n    # Ensure correct row order by sorting\n    df.sort_index(inplace=True)\n    # Cast calculation type index back from categorical to string to allow\n    # adding new calculation types\n    df.set_index(\n        [df.index.get_level_values('calculation type').astype(str),\n         df.index.get_level_values('result type')],\n        inplace=True)\n    return df", "response": "Make a multiindex DataFrame that contains the mean and standard deviations of each column."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef efficiency_gain_df(method_names, method_values, est_names, **kwargs):\n    true_values = kwargs.pop('true_values', None)\n    include_true_values = kwargs.pop('include_true_values', False)\n    include_rmse = kwargs.pop('include_rmse', False)\n    adjust_nsamp = kwargs.pop('adjust_nsamp', None)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    if adjust_nsamp is not None:\n        assert adjust_nsamp.shape == (len(method_names),)\n    assert len(method_names) == len(method_values)\n    df_dict = {}\n    for i, method_name in enumerate(method_names):\n        # Set include_true_values=False as we don't want them repeated for\n        # every method\n        df = summary_df_from_list(\n            method_values[i], est_names, true_values=true_values,\n            include_true_values=False, include_rmse=include_rmse)\n        if i != 0:\n            stats = ['std']\n            if include_rmse:\n                stats.append('rmse')\n            if adjust_nsamp is not None:\n                # Efficiency gain measures performance per number of\n                # samples (proportional to computational work). If the\n                # number of samples is not the same we can adjust this.\n                adjust = (adjust_nsamp[0] / adjust_nsamp[i])\n            else:\n                adjust = 1\n            for stat in stats:\n                # Calculate efficiency gain vs standard nested sampling\n                gain, gain_unc = get_eff_gain(\n                    df_dict[method_names[0]].loc[(stat, 'value')],\n                    df_dict[method_names[0]].loc[(stat, 'uncertainty')],\n                    df.loc[(stat, 'value')],\n                    df.loc[(stat, 'uncertainty')], adjust=adjust)\n                key = stat + ' efficiency gain'\n                df.loc[(key, 'value'), :] = gain\n                df.loc[(key, 'uncertainty'), :] = gain_unc\n        df_dict[method_name] = df\n    results = pd.concat(df_dict)\n    results.index.rename('dynamic settings', level=0, inplace=True)\n    new_ind = []\n    new_ind.append(pd.CategoricalIndex(\n        results.index.get_level_values('calculation type'), ordered=True,\n        categories=['true values', 'mean', 'std', 'rmse',\n                    'std efficiency gain', 'rmse efficiency gain']))\n    new_ind.append(pd.CategoricalIndex(\n        results.index.get_level_values('dynamic settings'),\n        ordered=True, categories=[''] + method_names))\n    new_ind.append(results.index.get_level_values('result type'))\n    results.set_index(new_ind, inplace=True)\n    if include_true_values:\n        with warnings.catch_warnings():\n            # Performance not an issue here so suppress annoying warning\n            warnings.filterwarnings('ignore', message=(\n                'indexing past lexsort depth may impact performance.'))\n            results.loc[('true values', '', 'value'), :] = true_values\n    results.sort_index(inplace=True)\n    return results", "response": "r Calculates the efficiency gain of a given set of methods."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef paper_format_efficiency_gain_df(eff_gain_df):\n    idxs = pd.IndexSlice[['std', 'std efficiency gain'], :, :]\n    paper_df = copy.deepcopy(eff_gain_df.loc[idxs, :])\n    # Show mean number of samples and likelihood calls instead of st dev\n    means = (eff_gain_df.xs('mean', level='calculation type')\n             .xs('value', level='result type'))\n    for col in ['samples', 'likelihood calls']:\n        try:\n            col_vals = []\n            for val in means[col].values:\n                col_vals += [int(np.rint(val)), np.nan]\n            col_vals += [np.nan] * (paper_df.shape[0] - len(col_vals))\n            paper_df[col] = col_vals\n        except KeyError:\n            pass\n    row_name_map = {'std efficiency gain': 'Efficiency gain',\n                    'St.Dev. efficiency gain': 'Efficiency gain',\n                    'dynamic ': '',\n                    'std': 'St.Dev.'}\n    row_names = (paper_df.index.get_level_values(0).astype(str) + ' ' +\n                 paper_df.index.get_level_values(1).astype(str))\n    for key, value in row_name_map.items():\n        row_names = row_names.str.replace(key, value)\n    paper_df.index = [row_names, paper_df.index.get_level_values(2)]\n    return paper_df", "response": "Transform the efficiency gain data frames output by nestcheck into the order they appear in the order they appear."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_eff_gain(base_std, base_std_unc, meth_std, meth_std_unc, adjust=1):\n    ratio = base_std / meth_std\n    ratio_unc = array_ratio_std(\n        base_std, base_std_unc, meth_std, meth_std_unc)\n    gain = ratio ** 2\n    gain_unc = 2 * ratio * ratio_unc\n    gain *= adjust\n    gain_unc *= adjust\n    return gain, gain_unc", "response": "r Calculates the effective gain for a new method compared to a base method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the values of list of quantities for each estimator in estimator_list.", "response": "def run_estimators(ns_run, estimator_list, simulate=False):\n    \"\"\"Calculates values of list of quantities (such as the Bayesian evidence\n    or mean of parameters) for a single nested sampling run.\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dict (see data_processing module docstring for more\n        details).\n    estimator_list: list of functions for estimating quantities from nested\n        sampling runs. Example functions can be found in estimators.py. Each\n        should have arguments: func(ns_run, logw=None).\n    simulate: bool, optional\n        See get_logw docstring.\n\n    Returns\n    -------\n    output: 1d numpy array\n        Calculation result for each estimator in estimator_list.\n    \"\"\"\n    logw = get_logw(ns_run, simulate=simulate)\n    output = np.zeros(len(estimator_list))\n    for i, est in enumerate(estimator_list):\n        output[i] = est(ns_run, logw=logw)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef array_given_run(ns_run):\n    samples = np.zeros((ns_run['logl'].shape[0], 3 + ns_run['theta'].shape[1]))\n    samples[:, 0] = ns_run['logl']\n    samples[:, 1] = ns_run['thread_labels']\n    # Calculate 'change in nlive' after each step\n    samples[:-1, 2] = np.diff(ns_run['nlive_array'])\n    samples[-1, 2] = -1  # nlive drops to zero after final point\n    samples[:, 3:] = ns_run['theta']\n    return samples", "response": "Converts information on samples in a nested sampling run dictionary into a numpy array representation. This allows fast addition of more samples and nlive recalculation of nlive at sample."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dict_given_run_array(samples, thread_min_max):\n    ns_run = {'logl': samples[:, 0],\n              'thread_labels': samples[:, 1],\n              'thread_min_max': thread_min_max,\n              'theta': samples[:, 3:]}\n    if np.all(~np.isnan(ns_run['thread_labels'])):\n        ns_run['thread_labels'] = ns_run['thread_labels'].astype(int)\n        assert np.array_equal(samples[:, 1], ns_run['thread_labels']), ((\n            'Casting thread labels from samples array to int has changed '\n            'their values!\\nsamples[:, 1]={}\\nthread_labels={}').format(\n                samples[:, 1], ns_run['thread_labels']))\n    nlive_0 = (thread_min_max[:, 0] <= ns_run['logl'].min()).sum()\n    assert nlive_0 > 0, 'nlive_0={}'.format(nlive_0)\n    nlive_array = np.zeros(samples.shape[0]) + nlive_0\n    nlive_array[1:] += np.cumsum(samples[:-1, 2])\n    # Check if there are multiple threads starting on the first logl point\n    dup_th_starts = (thread_min_max[:, 0] == ns_run['logl'].min()).sum()\n    if dup_th_starts > 1:\n        # In this case we approximate the true nlive (which we dont really\n        # know) by making sure the array's final point is 1 and setting all\n        # points with logl = logl.min() to have the same nlive\n        nlive_array += (1 - nlive_array[-1])\n        n_logl_min = (ns_run['logl'] == ns_run['logl'].min()).sum()\n        nlive_array[:n_logl_min] = nlive_0\n        warnings.warn((\n            'duplicate starting logls: {} threads start at logl.min()={}, '\n            'and {} points have logl=logl.min(). nlive_array may only be '\n            'approximately correct.').format(\n                dup_th_starts, ns_run['logl'].min(), n_logl_min), UserWarning)\n    assert nlive_array.min() > 0, ((\n        'nlive contains 0s or negative values. nlive_0={}'\n        '\\nnlive_array = {}\\nthread_min_max={}').format(\n            nlive_0, nlive_array, thread_min_max))\n    assert nlive_array[-1] == 1, (\n        'final point in nlive_array != 1.\\nnlive_array = ' + str(nlive_array))\n    ns_run['nlive_array'] = nlive_array\n    return ns_run", "response": "Converts an array of information about samples back into a nested sampling run dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the individual threads from a nested sampling run.", "response": "def get_run_threads(ns_run):\n    \"\"\"\n    Get the individual threads from a nested sampling run.\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dict (see data_processing module docstring for more\n        details).\n\n    Returns\n    -------\n    threads: list of numpy array\n        Each thread (list element) is a samples array containing columns\n        [logl, thread label, change in nlive at sample, (thetas)]\n        with each row representing a single sample.\n    \"\"\"\n    samples = array_given_run(ns_run)\n    unique_threads = np.unique(ns_run['thread_labels'])\n    assert ns_run['thread_min_max'].shape[0] == unique_threads.shape[0], (\n        'some threads have no points! {0} != {1}'.format(\n            unique_threads.shape[0], ns_run['thread_min_max'].shape[0]))\n    threads = []\n    for i, th_lab in enumerate(unique_threads):\n        thread_array = samples[np.where(samples[:, 1] == th_lab)]\n        # delete changes in nlive due to other threads in the run\n        thread_array[:, 2] = 0\n        thread_array[-1, 2] = -1\n        min_max = np.reshape(ns_run['thread_min_max'][i, :], (1, 2))\n        assert min_max[0, 1] == thread_array[-1, 0], (\n            'thread max logl should equal logl of its final point!')\n        threads.append(dict_given_run_array(thread_array, min_max))\n    return threads"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncombine a list of complete nested sampling run dictionaries into a single nested sampling run.", "response": "def combine_ns_runs(run_list_in, **kwargs):\n    \"\"\"\n    Combine a list of complete nested sampling run dictionaries into a single\n    ns run.\n\n    Input runs must contain any repeated threads.\n\n    Parameters\n    ----------\n    run_list_in: list of dicts\n        List of nested sampling runs in dict format (see data_processing module\n        docstring for more details).\n    kwargs: dict, optional\n        Options for check_ns_run.\n\n    Returns\n    -------\n    run: dict\n        Nested sampling run dict (see data_processing module docstring for more\n        details).\n    \"\"\"\n    run_list = copy.deepcopy(run_list_in)\n    if len(run_list) == 1:\n        run = run_list[0]\n    else:\n        nthread_tot = 0\n        for i, _ in enumerate(run_list):\n            check_ns_run(run_list[i], **kwargs)\n            run_list[i]['thread_labels'] += nthread_tot\n            nthread_tot += run_list[i]['thread_min_max'].shape[0]\n        thread_min_max = np.vstack([run['thread_min_max'] for run in run_list])\n        # construct samples array from the threads, including an updated nlive\n        samples_temp = np.vstack([array_given_run(run) for run in run_list])\n        samples_temp = samples_temp[np.argsort(samples_temp[:, 0])]\n        # Make combined run\n        run = dict_given_run_array(samples_temp, thread_min_max)\n        # Combine only the additive properties stored in run['output']\n        run['output'] = {}\n        for key in ['nlike', 'ndead']:\n            try:\n                run['output'][key] = sum([temp['output'][key] for temp in\n                                          run_list_in])\n            except KeyError:\n                pass\n    check_ns_run(run, **kwargs)\n    return run"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncombine a list of threads into a single ns run.", "response": "def combine_threads(threads, assert_birth_point=False):\n    \"\"\"\n    Combine list of threads into a single ns run.\n    This is different to combining runs as repeated threads are allowed, and as\n    some threads can start from log-likelihood contours on which no dead\n    point in the run is present.\n\n    Note that if all the thread labels are not unique and in ascending order,\n    the output will fail check_ns_run. However provided the thread labels are\n    not used it will work ok for calculations based on nlive, logl and theta.\n\n    Parameters\n    ----------\n    threads: list of dicts\n        List of nested sampling run dicts, each representing a single thread.\n    assert_birth_point: bool, optional\n        Whether or not to assert there is exactly one point present in the run\n        with the log-likelihood at which each point was born. This is not true\n        for bootstrap resamples of runs, where birth points may be repeated or\n        not present at all.\n\n    Returns\n    -------\n    run: dict\n        Nested sampling run dict (see data_processing module docstring for more\n        details).\n    \"\"\"\n    thread_min_max = np.vstack([td['thread_min_max'] for td in threads])\n    assert len(threads) == thread_min_max.shape[0]\n    # construct samples array from the threads, including an updated nlive\n    samples_temp = np.vstack([array_given_run(thread) for thread in threads])\n    samples_temp = samples_temp[np.argsort(samples_temp[:, 0])]\n    # update the changes in live points column for threads which start part way\n    # through the run. These are only present in dynamic nested sampling.\n    logl_starts = thread_min_max[:, 0]\n    state = np.random.get_state()  # save random state\n    np.random.seed(0)  # seed to make sure any random assignment is repoducable\n    for logl_start in logl_starts[logl_starts != -np.inf]:\n        ind = np.where(samples_temp[:, 0] == logl_start)[0]\n        if assert_birth_point:\n            assert ind.shape == (1,), \\\n                'No unique birth point! ' + str(ind.shape)\n        if ind.shape == (1,):\n            # If the point at which this thread started is present exactly\n            # once in this bootstrap replication:\n            samples_temp[ind[0], 2] += 1\n        elif ind.shape == (0,):\n            # If the point with the likelihood at which the thread started\n            # is not present in this particular bootstrap replication,\n            # approximate it with the point with the nearest likelihood.\n            ind_closest = np.argmin(np.abs(samples_temp[:, 0] - logl_start))\n            samples_temp[ind_closest, 2] += 1\n        else:\n            # If the point at which this thread started is present multiple\n            # times in this bootstrap replication, select one at random to\n            # increment nlive on. This avoids any systematic bias from e.g.\n            # always choosing the first point.\n            samples_temp[np.random.choice(ind), 2] += 1\n    np.random.set_state(state)\n    # make run\n    ns_run = dict_given_run_array(samples_temp, thread_min_max)\n    try:\n        check_ns_run_threads(ns_run)\n    except AssertionError:\n        # If the threads are not valid (e.g. for bootstrap resamples) then\n        # set them to None so they can't be accidentally used\n        ns_run['thread_labels'] = None\n        ns_run['thread_min_max'] = None\n    return ns_run"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_logw(ns_run, simulate=False):\n    try:\n        # find logX value for each point\n        logx = get_logx(ns_run['nlive_array'], simulate=simulate)\n        logw = np.zeros(ns_run['logl'].shape[0])\n        # Vectorized trapezium rule: w_i prop to (X_{i-1} - X_{i+1}) / 2\n        logw[1:-1] = log_subtract(logx[:-2], logx[2:]) - np.log(2)\n        # Assign all prior volume closest to first point X_first to that point:\n        # that is from logx=0 to logx=log((X_first + X_second) / 2)\n        logw[0] = log_subtract(0, scipy.special.logsumexp([logx[0], logx[1]]) -\n                               np.log(2))\n        # Assign all prior volume closest to final point X_last to that point:\n        # that is from logx=log((X_penultimate + X_last) / 2) to logx=-inf\n        logw[-1] = scipy.special.logsumexp([logx[-2], logx[-1]]) - np.log(2)\n        # multiply by likelihood (add in log space)\n        logw += ns_run['logl']\n        return logw\n    except IndexError:\n        if ns_run['logl'].shape[0] == 1:\n            # If there is only one point in the run then assign all prior\n            # volume X \\in (0, 1) to that point, so the weight is just\n            # 1 * logl_0 = logl_0\n            return copy.deepcopy(ns_run['logl'])\n        else:\n            raise", "response": "r Calculates the log posterior weights of the samples in the nested sampling run dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the relative posterior weights of the samples normalised so the maximum sample weight is 1. This is calculated from get_logw with the simulate parameter.", "response": "def get_w_rel(ns_run, simulate=False):\n    \"\"\"Get the relative posterior weights of the samples, normalised so\n    the maximum sample weight is 1. This is calculated from get_logw with\n    protection against numerical overflows.\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dict (see data_processing module docstring for more\n        details).\n    simulate: bool, optional\n        See the get_logw docstring for more details.\n\n    Returns\n    -------\n    w_rel: 1d numpy array\n        Relative posterior masses of points.\n    \"\"\"\n    logw = get_logw(ns_run, simulate=simulate)\n    return np.exp(logw - logw.max())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that nested sampling run dictionary has the expected properties.", "response": "def check_ns_run(run, dup_assert=False, dup_warn=False):\n    \"\"\"Checks a nestcheck format nested sampling run dictionary has the\n    expected properties (see the data_processing module docstring for more\n    details).\n\n    Parameters\n    ----------\n    run: dict\n        nested sampling run to check.\n    dup_assert: bool, optional\n        See check_ns_run_logls docstring.\n    dup_warn: bool, optional\n        See check_ns_run_logls docstring.\n\n\n    Raises\n    ------\n    AssertionError\n        if run does not have expected properties.\n    \"\"\"\n    assert isinstance(run, dict)\n    check_ns_run_members(run)\n    check_ns_run_logls(run, dup_assert=dup_assert, dup_warn=dup_warn)\n    check_ns_run_threads(run)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_ns_run_members(run):\n    run_keys = list(run.keys())\n    # Mandatory keys\n    for key in ['logl', 'nlive_array', 'theta', 'thread_labels',\n                'thread_min_max']:\n        assert key in run_keys\n        run_keys.remove(key)\n    # Optional keys\n    for key in ['output']:\n        try:\n            run_keys.remove(key)\n        except ValueError:\n            pass\n    # Check for unexpected keys\n    assert not run_keys, 'Unexpected keys in ns_run: ' + str(run_keys)\n    # Check type of mandatory members\n    for key in ['logl', 'nlive_array', 'theta', 'thread_labels',\n                'thread_min_max']:\n        assert isinstance(run[key], np.ndarray), (\n            key + ' is type ' + type(run[key]).__name__)\n    # check shapes of keys\n    assert run['logl'].ndim == 1\n    assert run['logl'].shape == run['nlive_array'].shape\n    assert run['logl'].shape == run['thread_labels'].shape\n    assert run['theta'].ndim == 2\n    assert run['logl'].shape[0] == run['theta'].shape[0]", "response": "Checks that nested sampling run member keys and values are consistent with the expected properties."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_ns_run_logls(run, dup_assert=False, dup_warn=False):\n    assert np.array_equal(run['logl'], run['logl'][np.argsort(run['logl'])])\n    if dup_assert or dup_warn:\n        unique_logls, counts = np.unique(run['logl'], return_counts=True)\n        repeat_logls = run['logl'].shape[0] - unique_logls.shape[0]\n        msg = ('{} duplicate logl values (out of a total of {}). This may be '\n               'caused by limited numerical precision in the output files.'\n               '\\nrepeated logls = {}\\ncounts = {}\\npositions in list of {}'\n               ' unique logls = {}').format(\n                   repeat_logls, run['logl'].shape[0],\n                   unique_logls[counts != 1], counts[counts != 1],\n                   unique_logls.shape[0], np.where(counts != 1)[0])\n        if dup_assert:\n            assert repeat_logls == 0, msg\n        elif dup_warn:\n            if repeat_logls != 0:\n                warnings.warn(msg, UserWarning)", "response": "Checks that the logls in the nested sampling run are unique and in the correct order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_ns_run_threads(run):\n    assert run['thread_labels'].dtype == int\n    uniq_th = np.unique(run['thread_labels'])\n    assert np.array_equal(\n        np.asarray(range(run['thread_min_max'].shape[0])), uniq_th), \\\n        str(uniq_th)\n    # Check thread_min_max\n    assert np.any(run['thread_min_max'][:, 0] == -np.inf), (\n        'Run should have at least one thread which starts by sampling the ' +\n        'whole prior')\n    for th_lab in uniq_th:\n        inds = np.where(run['thread_labels'] == th_lab)[0]\n        th_info = 'thread label={}, first_logl={}, thread_min_max={}'.format(\n            th_lab, run['logl'][inds[0]], run['thread_min_max'][th_lab, :])\n        assert run['thread_min_max'][th_lab, 0] <= run['logl'][inds[0]], (\n            'First point in thread has logl less than thread min logl! ' +\n            th_info + ', difference={}'.format(\n                run['logl'][inds[0]] - run['thread_min_max'][th_lab, 0]))\n        assert run['thread_min_max'][th_lab, 1] == run['logl'][inds[-1]], (\n            'Last point in thread logl != thread end logl! ' + th_info)", "response": "Checks that the nested sampling run has expected properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncount the number of samples in a nested sampling run.", "response": "def count_samples(ns_run, **kwargs):\n    r\"\"\"Number of samples in run.\n\n    Unlike most estimators this does not require log weights, but for\n    convenience will not throw an error if they are specified.\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dict (see the data_processing module\n        docstring for more details).\n\n    Returns\n    -------\n    int\n    \"\"\"\n    kwargs.pop('logw', None)\n    kwargs.pop('simulate', None)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    return ns_run['logl'].shape[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logz(ns_run, logw=None, simulate=False):\n    if logw is None:\n        logw = nestcheck.ns_run_utils.get_logw(ns_run, simulate=simulate)\n    return scipy.special.logsumexp(logw)", "response": "Natural log of Bayesian evidence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the mean of a single parameter for a nested sampling run.", "response": "def param_mean(ns_run, logw=None, simulate=False, param_ind=0,\n               handle_indexerror=False):\n    \"\"\"Mean of a single parameter (single component of theta).\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dict (see the data_processing module\n        docstring for more details).\n    logw: None or 1d numpy array, optional\n        Log weights of samples.\n    simulate: bool, optional\n        Passed to ns_run_utils.get_logw if logw needs to be\n        calculated.\n    param_ind: int, optional\n        Index of parameter for which the mean should be calculated. This\n        corresponds to the column of ns_run['theta'] which contains the\n        parameter.\n    handle_indexerror: bool, optional\n        Make the function function return nan rather than raising an\n        IndexError if param_ind >= ndim. This is useful when applying\n        the same list of estimators to data sets of different dimensions.\n\n    Returns\n    -------\n    float\n    \"\"\"\n    if logw is None:\n        logw = nestcheck.ns_run_utils.get_logw(ns_run, simulate=simulate)\n    w_relative = np.exp(logw - logw.max())\n    try:\n        return (np.sum(w_relative * ns_run['theta'][:, param_ind])\n                / np.sum(w_relative))\n    except IndexError:\n        if handle_indexerror:\n            return np.nan\n        else:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmeans of the square of single parameter of its posterior distribution.", "response": "def param_squared_mean(ns_run, logw=None, simulate=False, param_ind=0):\n    \"\"\"Mean of the square of single parameter (second moment of its\n    posterior distribution).\n\n    Parameters\n    ----------\n    ns_run: dict\n        Nested sampling run dict (see the data_processing module\n        docstring for more details).\n    logw: None or 1d numpy array, optional\n        Log weights of samples.\n    simulate: bool, optional\n        Passed to ns_run_utils.get_logw if logw needs to be\n        calculated.\n    param_ind: int, optional\n        Index of parameter for which the second moment should be\n        calculated. This corresponds to the column of ns_run['theta']\n        which contains the parameter.\n\n    Returns\n    -------\n    float\n    \"\"\"\n    if logw is None:\n        logw = nestcheck.ns_run_utils.get_logw(ns_run, simulate=simulate)\n    w_relative = np.exp(logw - logw.max())  # protect against overflow\n    w_relative /= np.sum(w_relative)\n    return np.sum(w_relative * (ns_run['theta'][:, param_ind] ** 2))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef r_mean(ns_run, logw=None, simulate=False):\n    if logw is None:\n        logw = nestcheck.ns_run_utils.get_logw(ns_run, simulate=simulate)\n    w_relative = np.exp(logw - logw.max())\n    r = np.sqrt(np.sum(ns_run['theta'] ** 2, axis=1))\n    return np.sum(w_relative * r) / np.sum(w_relative)", "response": "Mean of the radial coordinate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nproduce a latex formatted name for each function in the sequence.", "response": "def get_latex_name(func_in, **kwargs):\n    \"\"\"\n    Produce a latex formatted name for each function for use in labelling\n    results.\n\n    Parameters\n    ----------\n    func_in: function\n    kwargs: dict, optional\n        Kwargs for function.\n\n    Returns\n    -------\n    latex_name: str\n        Latex formatted name for the function.\n    \"\"\"\n    if isinstance(func_in, functools.partial):\n        func = func_in.func\n        assert not set(func_in.keywords) & set(kwargs), (\n            'kwargs={0} and func_in.keywords={1} contain repeated keys'\n            .format(kwargs, func_in.keywords))\n        kwargs.update(func_in.keywords)\n    else:\n        func = func_in\n    param_ind = kwargs.pop('param_ind', 0)\n    probability = kwargs.pop('probability', 0.5)\n    kwargs.pop('handle_indexerror', None)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    ind_str = r'{\\hat{' + str(param_ind + 1) + '}}'\n    latex_name_dict = {\n        'count_samples': r'samples',\n        'logz': r'$\\mathrm{log} \\mathcal{Z}$',\n        'evidence': r'$\\mathcal{Z}$',\n        'r_mean': r'$\\overline{|\\theta|}$',\n        'param_mean': r'$\\overline{\\theta_' + ind_str + '}$',\n        'param_squared_mean': r'$\\overline{\\theta^2_' + ind_str + '}$'}\n    # Add credible interval names\n    if probability == 0.5:\n        cred_str = r'$\\mathrm{median}('\n    else:\n        # format percent without trailing zeros\n        percent_str = ('%f' % (probability * 100)).rstrip('0').rstrip('.')\n        cred_str = r'$\\mathrm{C.I.}_{' + percent_str + r'\\%}('\n    latex_name_dict['param_cred'] = cred_str + r'\\theta_' + ind_str + ')$'\n    latex_name_dict['r_cred'] = cred_str + r'|\\theta|)$'\n    try:\n        return latex_name_dict[func.__name__]\n    except KeyError as err:\n        err.args = err.args + ('get_latex_name not yet set up for ' +\n                               func.__name__,)\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets quantile estimate for input probability given weighted samples using linear interpolation.", "response": "def weighted_quantile(probability, values, weights):\n    \"\"\"\n    Get quantile estimate for input probability given weighted samples using\n    linear interpolation.\n\n    Parameters\n    ----------\n    probability: float\n        Quantile to estimate - must be in open interval (0, 1).\n        For example, use 0.5 for the median and 0.84 for the upper\n        84% quantile.\n    values: 1d numpy array\n        Sample values.\n    weights: 1d numpy array\n        Corresponding sample weights (same shape as values).\n\n    Returns\n    -------\n    quantile: float\n    \"\"\"\n    assert 1 > probability > 0, (\n        'credible interval prob= ' + str(probability) + ' not in (0, 1)')\n    assert values.shape == weights.shape\n    assert values.ndim == 1\n    assert weights.ndim == 1\n    sorted_inds = np.argsort(values)\n    quantiles = np.cumsum(weights[sorted_inds]) - (0.5 * weights[sorted_inds])\n    quantiles /= np.sum(weights)\n    return np.interp(probability, quantiles, values[sorted_inds])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_run_output(run, **kwargs):\n    write_dead = kwargs.pop('write_dead', True)\n    write_stats = kwargs.pop('write_stats', True)\n    posteriors = kwargs.pop('posteriors', False)\n    equals = kwargs.pop('equals', False)\n    stats_means_errs = kwargs.pop('stats_means_errs', True)\n    fmt = kwargs.pop('fmt', '% .14E')\n    n_simulate = kwargs.pop('n_simulate', 100)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    mandatory_keys = ['file_root', 'base_dir']\n    for key in mandatory_keys:\n        assert key in run['output'], key + ' not in run[\"output\"]'\n    root = os.path.join(run['output']['base_dir'], run['output']['file_root'])\n    if write_dead:\n        samples = run_dead_birth_array(run)\n        np.savetxt(root + '_dead-birth.txt', samples, fmt=fmt)\n        np.savetxt(root + '_dead.txt', samples[:, :-1], fmt=fmt)\n    if equals or posteriors:\n        w_rel = nestcheck.ns_run_utils.get_w_rel(run)\n        post_arr = np.zeros((run['theta'].shape[0], run['theta'].shape[1] + 2))\n        post_arr[:, 0] = w_rel\n        post_arr[:, 1] = -2 * run['logl']\n        post_arr[:, 2:] = run['theta']\n    if posteriors:\n        np.savetxt(root + '.txt', post_arr, fmt=fmt)\n        run['output']['nposterior'] = post_arr.shape[0]\n    else:\n        run['output']['nposterior'] = 0\n    if equals:\n        inds = np.where(w_rel > np.random.random(w_rel.shape[0]))[0]\n        np.savetxt(root + '_equal_weights.txt', post_arr[inds, 1:],\n                   fmt=fmt)\n        run['output']['nequals'] = inds.shape[0]\n    else:\n        run['output']['nequals'] = 0\n    if write_stats:\n        run['output']['ndead'] = run['logl'].shape[0]\n        if stats_means_errs:\n            # Get logZ and param estimates and errors\n            estimators = [e.logz]\n            for i in range(run['theta'].shape[1]):\n                estimators.append(functools.partial(e.param_mean, param_ind=i))\n            values = nestcheck.ns_run_utils.run_estimators(run, estimators)\n            stds = nestcheck.error_analysis.run_std_bootstrap(\n                run, estimators, n_simulate=n_simulate)\n            run['output']['logZ'] = values[0]\n            run['output']['logZerr'] = stds[0]\n            run['output']['param_means'] = list(values[1:])\n            run['output']['param_mean_errs'] = list(stds[1:])\n        write_stats_file(run['output'])", "response": "Writes the output files corresponding to the input nested sampling\n    run."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_dead_birth_array(run, **kwargs):\n    nestcheck.ns_run_utils.check_ns_run(run, **kwargs)\n    threads = nestcheck.ns_run_utils.get_run_threads(run)\n    samp_arrays = []\n    ndim = run['theta'].shape[1]\n    for th in threads:\n        samp_arr = np.zeros((th['theta'].shape[0], ndim + 2))\n        samp_arr[:, :ndim] = th['theta']\n        samp_arr[:, ndim] = th['logl']\n        samp_arr[1:, ndim + 1] = th['logl'][:-1]\n        if th['thread_min_max'][0, 0] == -np.inf:\n            samp_arr[0, ndim + 1] = -1e30\n        else:\n            samp_arr[0, ndim + 1] = th['thread_min_max'][0, 0]\n        samp_arrays.append(samp_arr)\n    samples = np.vstack(samp_arrays)\n    samples = samples[np.argsort(samples[:, ndim]), :]\n    return samples", "response": "Converts input run into an array of the format of a PolyChord\n    <root >_dead - birth. txt file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_stats_file(run_output_dict):\n    mandatory_keys = ['file_root', 'base_dir']\n    for key in mandatory_keys:\n        assert key in run_output_dict, key + ' not in run_output_dict'\n    default_output = {'logZ': 0.0,\n                      'logZerr': 0.0,\n                      'logZs': [0.0],\n                      'logZerrs': [0.0],\n                      'ncluster': 1,\n                      'nposterior': 0,\n                      'nequals': 0,\n                      'ndead': 0,\n                      'nlike': 0,\n                      'nlive': 0,\n                      'avnlike': 0.0,\n                      'avnlikeslice': 0.0,\n                      'param_means': [0.0, 0.0, 0.0],\n                      'param_mean_errs': [0.0, 0.0, 0.0]}\n    allowed_keys = set(mandatory_keys) | set(default_output.keys())\n    assert set(run_output_dict.keys()).issubset(allowed_keys), (\n        'Input dict contains unexpected keys: {}'.format(\n            set(run_output_dict.keys()) - allowed_keys))\n    output = copy.deepcopy(run_output_dict)\n    for key, value in default_output.items():\n        if key not in output:\n            output[key] = value\n    # Make a PolyChord format .stats file corresponding to output\n    file_lines = [\n        'Evidence estimates:',\n        '===================',\n        ('  - The evidence Z is a log-normally distributed, with location and '\n         'scale parameters mu and sigma.'),\n        '  - We denote this as log(Z) = mu +/- sigma.',\n        '',\n        'Global evidence:',\n        '----------------',\n        '',\n        'log(Z)       =  {0} +/-   {1}'.format(\n            output['logZ'], output['logZerr']),\n        '',\n        '',\n        'Local evidences:',\n        '----------------',\n        '']\n    for i, (lz, lzerr) in enumerate(zip(output['logZs'], output['logZerrs'])):\n        file_lines.append('log(Z_ {0})  =  {1} +/-   {2}'.format(\n            str(i + 1).rjust(2), lz, lzerr))\n    file_lines += [\n        '',\n        '',\n        'Run-time information:',\n        '---------------------',\n        '',\n        ' ncluster:          0 /       1',\n        ' nposterior:        {0}'.format(output['nposterior']),\n        ' nequals:           {0}'.format(output['nequals']),\n        ' ndead:          {0}'.format(output['ndead']),\n        ' nlive:             {0}'.format(output['nlive']),\n        ' nlike:         {0}'.format(output['nlike']),\n        ' <nlike>:       {0}   (    {1} per slice )'.format(\n            output['avnlike'], output['avnlikeslice']),\n        '',\n        '',\n        'Dim No.       Mean        Sigma']\n    for i, (mean, meanerr) in enumerate(zip(output['param_means'],\n                                            output['param_mean_errs'])):\n        file_lines.append('{0}  {1} +/-   {2}'.format(\n            str(i + 1).ljust(3), mean, meanerr))\n    file_path = os.path.join(output['base_dir'],\n                             output['file_root'] + '.stats')\n    with open(file_path, 'w') as stats_file:\n        stats_file.writelines('{}\\n'.format(line) for line in file_lines)\n    return output", "response": "Writes a dummy PolyChord format. stats file for tests functions for\n    processing stats files. This is written to file_root base_dir. stats\n    Also returns the data in the file as a dict for comparison."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dataframe with calculation values and error diagnostics for each nested sampling run in the input run list.", "response": "def run_list_error_values(run_list, estimator_list, estimator_names,\n                          n_simulate=100, **kwargs):\n    \"\"\"Gets a data frame with calculation values and error diagnostics for each\n    run in the input run list.\n\n    NB when parallelised the results will not be produced in order (so results\n    from some run number will not nessesarily correspond to that number run in\n    run_list).\n\n    Parameters\n    ----------\n    run_list: list of dicts\n        List of nested sampling run dicts.\n    estimator_list: list of functions\n        Estimators to apply to runs.\n    estimator_names: list of strs\n        Name of each func in estimator_list.\n    n_simulate: int, optional\n        Number of bootstrap replications to use on each run.\n    thread_pvalue: bool, optional\n        Whether or not to compute KS test diaganostic for correlations between\n        threads within a run.\n    bs_stat_dist: bool, optional\n        Whether or not to compute statistical distance between bootstrap error\n        distributions diaganostic.\n    parallel: bool, optional\n        Whether or not to parallelise - see parallel_utils.parallel_apply.\n    save_name: str or None, optional\n        See nestcheck.io_utils.save_load_result.\n    save: bool, optional\n        See nestcheck.io_utils.save_load_result.\n    load: bool, optional\n        See nestcheck.io_utils.save_load_result.\n    overwrite_existing: bool, optional\n        See nestcheck.io_utils.save_load_result.\n\n    Returns\n    -------\n    df: pandas DataFrame\n        Results table showing calculation values and diagnostics. Rows\n        show different runs (or pairs of runs for pairwise comparisons).\n        Columns have titles given by estimator_names and show results for the\n        different functions in estimators_list.\n    \"\"\"\n    thread_pvalue = kwargs.pop('thread_pvalue', False)\n    bs_stat_dist = kwargs.pop('bs_stat_dist', False)\n    parallel = kwargs.pop('parallel', True)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    assert len(estimator_list) == len(estimator_names), (\n        'len(estimator_list) = {0} != len(estimator_names = {1}'\n        .format(len(estimator_list), len(estimator_names)))\n    # Calculation results\n    # -------------------\n    df = estimator_values_df(run_list, estimator_list, parallel=parallel,\n                             estimator_names=estimator_names)\n    df.index = df.index.map(str)\n    df['calculation type'] = 'values'\n    df.set_index('calculation type', drop=True, append=True, inplace=True)\n    df = df.reorder_levels(['calculation type', 'run'])\n    # Bootstrap stds\n    # --------------\n    # Create bs_vals_df then convert to stds so bs_vals_df does not need to be\n    # recomputed if bs_stat_dist is True\n    bs_vals_df = bs_values_df(run_list, estimator_list, estimator_names,\n                              n_simulate, parallel=parallel)\n    bs_std_df = bs_vals_df.applymap(lambda x: np.std(x, ddof=1))\n    bs_std_df.index.name = 'run'\n    bs_std_df['calculation type'] = 'bootstrap std'\n    bs_std_df.set_index('calculation type', drop=True, append=True,\n                        inplace=True)\n    bs_std_df = bs_std_df.reorder_levels(['calculation type', 'run'])\n    df = pd.concat([df, bs_std_df])\n    # Pairwise KS p-values on threads\n    # -------------------------------\n    if thread_pvalue:\n        t_vals_df = thread_values_df(\n            run_list, estimator_list, estimator_names, parallel=parallel)\n        t_d_df = pairwise_dists_on_cols(t_vals_df, earth_mover_dist=False,\n                                        energy_dist=False)\n        # Keep only the p value not the distance measures\n        t_d_df = t_d_df.xs('ks pvalue', level='calculation type',\n                           drop_level=False)\n        # Append 'thread ' to caclulcation type\n        t_d_df.index.set_levels(['thread ks pvalue'], level='calculation type',\n                                inplace=True)\n        df = pd.concat([df, t_d_df])\n    # Pairwise distances on BS distributions\n    # --------------------------------------\n    if bs_stat_dist:\n        b_d_df = pairwise_dists_on_cols(bs_vals_df)\n        # Select only statistical distances - not KS pvalue as this is not\n        # useful for the bootstrap resample distributions (see Higson et al.\n        # 2019 for more details).\n        dists = ['ks distance', 'earth mover distance', 'energy distance']\n        b_d_df = b_d_df.loc[pd.IndexSlice[dists, :], :]\n        # Append 'bootstrap ' to caclulcation type\n        new_ind = ['bootstrap ' +\n                   b_d_df.index.get_level_values('calculation type'),\n                   b_d_df.index.get_level_values('run')]\n        b_d_df.set_index(new_ind, inplace=True)\n        df = pd.concat([df, b_d_df])\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef estimator_values_df(run_list, estimator_list, **kwargs):\n    estimator_names = kwargs.pop(\n        'estimator_names',\n        ['est_' + str(i) for i in range(len(estimator_list))])\n    parallel = kwargs.pop('parallel', True)\n    if kwargs:\n        raise TypeError('Unexpected **kwargs: {0}'.format(kwargs))\n    values_list = pu.parallel_apply(\n        nestcheck.ns_run_utils.run_estimators, run_list,\n        func_args=(estimator_list,), parallel=parallel)\n    df = pd.DataFrame(np.stack(values_list, axis=0))\n    df.columns = estimator_names\n    df.index.name = 'run'\n    return df", "response": "Get a dataframe of estimator values for each run in run_list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef error_values_summary(error_values, **summary_df_kwargs):\n    df = pf.summary_df_from_multi(error_values, **summary_df_kwargs)\n    # get implementation stds\n    imp_std, imp_std_unc, imp_frac, imp_frac_unc = \\\n        nestcheck.error_analysis.implementation_std(\n            df.loc[('values std', 'value')],\n            df.loc[('values std', 'uncertainty')],\n            df.loc[('bootstrap std mean', 'value')],\n            df.loc[('bootstrap std mean', 'uncertainty')])\n    df.loc[('implementation std', 'value'), df.columns] = imp_std\n    df.loc[('implementation std', 'uncertainty'), df.columns] = imp_std_unc\n    df.loc[('implementation std frac', 'value'), :] = imp_frac\n    df.loc[('implementation std frac', 'uncertainty'), :] = imp_frac_unc\n    # Get implementation RMSEs (calculated using the values RMSE instead of\n    # values std)\n    if 'values rmse' in set(df.index.get_level_values('calculation type')):\n        imp_rmse, imp_rmse_unc, imp_frac, imp_frac_unc = \\\n            nestcheck.error_analysis.implementation_std(\n                df.loc[('values rmse', 'value')],\n                df.loc[('values rmse', 'uncertainty')],\n                df.loc[('bootstrap std mean', 'value')],\n                df.loc[('bootstrap std mean', 'uncertainty')])\n        df.loc[('implementation rmse', 'value'), df.columns] = imp_rmse\n        df.loc[('implementation rmse', 'uncertainty'), df.columns] = \\\n            imp_rmse_unc\n        df.loc[('implementation rmse frac', 'value'), :] = imp_frac\n        df.loc[('implementation rmse frac', 'uncertainty'), :] = imp_frac_unc\n    # Return only the calculation types we are interested in, in order\n    calcs_to_keep = ['true values', 'values mean', 'values std',\n                     'values rmse', 'bootstrap std mean',\n                     'implementation std', 'implementation std frac',\n                     'implementation rmse', 'implementation rmse frac',\n                     'thread ks pvalue mean', 'bootstrap ks distance mean',\n                     'bootstrap energy distance mean',\n                     'bootstrap earth mover distance mean']\n    df = pd.concat([df.xs(calc, level='calculation type', drop_level=False) for\n                    calc in calcs_to_keep if calc in\n                    df.index.get_level_values('calculation type')])\n    return df", "response": "Get summary statistics about calculation errors including estimated\nTaxonomy implementation errors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap which runs run_list_error_values then applies error_values_summary to the resulting dataframe", "response": "def run_list_error_summary(run_list, estimator_list, estimator_names,\n                           n_simulate, **kwargs):\n    \"\"\"Wrapper which runs run_list_error_values then applies error_values\n    summary to the resulting dataframe. See the docstrings for those two\n    funcions for more details and for descriptions of parameters and output.\n    \"\"\"\n    true_values = kwargs.pop('true_values', None)\n    include_true_values = kwargs.pop('include_true_values', False)\n    include_rmse = kwargs.pop('include_rmse', False)\n    error_values = run_list_error_values(run_list, estimator_list,\n                                         estimator_names, n_simulate, **kwargs)\n    return error_values_summary(error_values, true_values=true_values,\n                                include_true_values=include_true_values,\n                                include_rmse=include_rmse)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bs_values_df(run_list, estimator_list, estimator_names, n_simulate,\n                 **kwargs):\n    \"\"\"Computes a data frame of bootstrap resampled values.\n\n    Parameters\n    ----------\n    run_list: list of dicts\n        List of nested sampling run dicts.\n    estimator_list: list of functions\n        Estimators to apply to runs.\n    estimator_names: list of strs\n        Name of each func in estimator_list.\n    n_simulate: int\n        Number of bootstrap replications to use on each run.\n    kwargs:\n        Kwargs to pass to parallel_apply.\n\n    Returns\n    -------\n    bs_values_df: pandas data frame\n        Columns represent estimators and rows represent runs.\n        Each cell contains a 1d array of bootstrap resampled values for the run\n        and estimator.\n    \"\"\"\n    tqdm_kwargs = kwargs.pop('tqdm_kwargs', {'desc': 'bs values'})\n    assert len(estimator_list) == len(estimator_names), (\n        'len(estimator_list) = {0} != len(estimator_names = {1}'\n        .format(len(estimator_list), len(estimator_names)))\n    bs_values_list = pu.parallel_apply(\n        nestcheck.error_analysis.run_bootstrap_values, run_list,\n        func_args=(estimator_list,), func_kwargs={'n_simulate': n_simulate},\n        tqdm_kwargs=tqdm_kwargs, **kwargs)\n    df = pd.DataFrame()\n    for i, name in enumerate(estimator_names):\n        df[name] = [arr[i, :] for arr in bs_values_list]\n    # Check there are the correct number of bootstrap replications in each cell\n    for vals_shape in df.loc[0].apply(lambda x: x.shape).values:\n        assert vals_shape == (n_simulate,), (\n            'Should be n_simulate=' + str(n_simulate) + ' values in ' +\n            'each cell. The cell contains array with shape ' +\n            str(vals_shape))\n    return df", "response": "Computes a data frame of bootstrap resampled values for each run in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef thread_values_df(run_list, estimator_list, estimator_names, **kwargs):\n    tqdm_kwargs = kwargs.pop('tqdm_kwargs', {'desc': 'thread values'})\n    assert len(estimator_list) == len(estimator_names), (\n        'len(estimator_list) = {0} != len(estimator_names = {1}'\n        .format(len(estimator_list), len(estimator_names)))\n    # get thread results\n    thread_vals_arrays = pu.parallel_apply(\n        nestcheck.error_analysis.run_thread_values, run_list,\n        func_args=(estimator_list,), tqdm_kwargs=tqdm_kwargs, **kwargs)\n    df = pd.DataFrame()\n    for i, name in enumerate(estimator_names):\n        df[name] = [arr[i, :] for arr in thread_vals_arrays]\n    # Check there are the correct number of thread values in each cell\n    for vals_shape in df.loc[0].apply(lambda x: x.shape).values:\n        assert vals_shape == (run_list[0]['thread_min_max'].shape[0],), \\\n            ('Should be nlive=' + str(run_list[0]['thread_min_max'].shape[0]) +\n             ' values in each cell. The cell contains array with shape ' +\n             str(vals_shape))\n    return df", "response": "Calculates estimator values for the constituent threads of the input\n    runs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pairwise_dists_on_cols(df_in, earth_mover_dist=True, energy_dist=True):\n    df = pd.DataFrame()\n    for col in df_in.columns:\n        df[col] = nestcheck.error_analysis.pairwise_distances(\n            df_in[col].values, earth_mover_dist=earth_mover_dist,\n            energy_dist=energy_dist)\n    return df", "response": "Computes pairwise statistical distance measures on the columns of df_in."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _backtick_columns(cols):\n        def bt(s):\n            b = '' if s == '*' or not s else '`'\n            return [_ for _ in [b + (s or '') + b] if _]\n\n        formatted = []\n        for c in cols:\n            if c[0] == '#':\n                formatted.append(c[1:])\n            elif c.startswith('(') and c.endswith(')'):\n                # WHERE (column_a, column_b) IN ((1,10), (1,20))\n                formatted.append(c)\n            else:\n                # backtick the former part when it meets the first dot, and then all the rest\n                formatted.append('.'.join(bt(c.split('.')[0]) + bt('.'.join(c.split('.')[1:]))))\n\n        return ', '.join(formatted)", "response": "Return the column names that are used in the SQL query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _value_parser(self, value, columnname=False, placeholder='%s'):\n        if not isinstance(value, dict):\n            raise TypeError('Input value should be a dictionary')\n        q = []\n        a = []\n        for k, v in value.items():\n            if k[0] == '#':  # if is sql function\n                q.append(' = '.join([self._backtick(k[1:]), str(v)]) if columnname else v)\n            else:\n                q.append(' = '.join([self._backtick(k), placeholder]) if columnname else placeholder)\n                a.append(v)\n        return ', '.join(q), tuple(a)", "response": "Parse the value of the key - value pair into a SQL string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _by_columns(self, columns):\n        return columns if self.isstr(columns) else self._backtick_columns(columns)", "response": "Return a list of column names to be used in the select."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects all the entries in the specified table.", "response": "def select(self, table, columns=None, join=None, where=None, group=None, having=None, order=None, limit=None,\n               iterator=False, fetch=True):\n        \"\"\"\n        :type table: string\n        :type columns: list\n        :type join: dict\n        :param join: {'[>]table1(t1)': {'user.id': 't1.user_id'}} -> \"LEFT JOIN table AS t1 ON user.id = t1.user_id\"\n        :type where: dict\n        :type group: string|list\n        :type having: string\n        :type order: string|list\n        :type limit: int|list\n        # TODO: change to offset\n        :param limit: The max row number for this query.\n                      If it contains offset, limit must be a list like [offset, limit]\n        :param iterator: Whether to output the result in a generator. It always returns generator if the cursor is\n                         SSCursor or SSDictCursor, no matter iterator is True or False.\n        :type fetch: bool\n        \"\"\"\n        if not columns:\n            columns = ['*']\n        where_q, _args = self._where_parser(where)\n\n        # TODO: support multiple table\n\n        _sql = ''.join(['SELECT ', self._backtick_columns(columns),\n                        ' FROM ', self._tablename_parser(table)['formatted_tablename'],\n                        self._join_parser(join),\n                        where_q,\n                        (' GROUP BY ' + self._by_columns(group)) if group else '',\n                        (' HAVING ' + having) if having else '',\n                        (' ORDER BY ' + self._by_columns(order)) if order else '',\n                        self._limit_parser(limit), ';'])\n\n        if self.debug:\n            return self.cur.mogrify(_sql, _args)\n\n        execute_result = self.cur.execute(_sql, _args)\n\n        if not fetch:\n            return execute_result\n\n        if self.cursorclass in (pymysql.cursors.SSCursor, pymysql.cursors.SSDictCursor):\n            return self.cur\n\n        if iterator:\n            return self._yield_result()\n\n        return self.cur.fetchall()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a generator that yields the page of the available n - topic entries.", "response": "def select_page(self, limit, offset=0, **kwargs):\n        \"\"\"\n        :type limit: int\n        :param limit: The max row number for each page\n        :type offset: int\n        :param offset: The starting position of the page\n        :return:\n        \"\"\"\n        start = offset\n        while True:\n            result = self.select(limit=[start, limit], **kwargs)\n            start += limit\n            if result:\n                yield result\n            else:\n                break\n            if self.debug:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first result in one column only.", "response": "def get(self, table, column, join=None, where=None, insert=False, ifnone=None):\n        \"\"\"\n        A simplified method of select, for getting the first result in one column only. A common case of using this\n        method is getting id.\n        :type table: string\n        :type column: str\n        :type join: dict\n        :type where: dict\n        :type insert: bool\n        :param insert: If insert==True, insert the input condition if there's no result and return the id of new row.\n        :type ifnone: string\n        :param ifnone: When ifnone is a non-empty string, raise an error if query returns empty result. insert parameter\n                       would not work in this mode.\n        \"\"\"\n        select_result = self.select(table=table, columns=[column], join=join, where=where, limit=1)\n\n        if self.debug:\n            return select_result\n\n        result = select_result[0] if select_result else None\n\n        if result:\n            return result[0 if self.cursorclass is pymysql.cursors.Cursor else column]\n\n        if ifnone:\n            raise ValueError(ifnone)\n\n        if insert:\n            if any([isinstance(d, dict) for d in where.values()]):\n                raise ValueError(\"The where parameter in get() doesn't support nested condition with insert==True.\")\n            return self.insert(table=table, value=where)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert(self, table, value, ignore=False, commit=True):\n        value_q, _args = self._value_parser(value, columnname=False)\n        _sql = ''.join(['INSERT', ' IGNORE' if ignore else '', ' INTO ', self._backtick(table),\n                        ' (', self._backtick_columns(value), ') VALUES (', value_q, ');'])\n\n        if self.debug:\n            return self.cur.mogrify(_sql, _args)\n\n        self.cur.execute(_sql, _args)\n        if commit:\n            self.conn.commit()\n        return self.cur.lastrowid", "response": "Insert a dict into db."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts a record in the specified table with the given value.", "response": "def upsert(self, table, value, update_columns=None, commit=True):\n        \"\"\"\n        :type table: string\n        :type value: dict\n        :type update_columns: list\n        :param update_columns: specify the columns which will be updated if record exists\n        :type commit: bool\n        \"\"\"\n        if not isinstance(value, dict):\n            raise TypeError('Input value should be a dictionary')\n\n        if not update_columns:\n            update_columns = value.keys()\n\n        value_q, _args = self._value_parser(value, columnname=False)\n\n        _sql = ''.join(['INSERT INTO ', self._backtick(table), ' (', self._backtick_columns(value), ') VALUES ',\n                        '(', value_q, ') ',\n                        'ON DUPLICATE KEY UPDATE ',\n                        ', '.join(['='.join([k, 'VALUES('+k+')']) for k in update_columns]), ';'])\n\n        if self.debug:\n            return self.cur.mogrify(_sql, _args)\n\n        self.cur.execute(_sql, _args)\n        if commit:\n            self.conn.commit()\n        return self.cur.lastrowid"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts multiple records within one query.", "response": "def insertmany(self, table, columns, value, ignore=False, commit=True):\n        \"\"\"\n        Insert multiple records within one query.\n        :type table: string\n        :type columns: list\n        :type value: list|tuple\n        :param value: Doesn't support MySQL functions\n        :param value: Example: [(value1_column1, value1_column2,), ]\n        :type ignore: bool\n        :type commit: bool\n        :return: int. The row id of the LAST insert only.\n        \"\"\"\n        if not isinstance(value, (list, tuple)):\n            raise TypeError('Input value should be a list or tuple')\n\n        # Cannot add semicolon here, otherwise it will not pass the Cursor.executemany validation\n        _sql = ''.join(['INSERT', ' IGNORE' if ignore else '', ' INTO ', self._backtick(table),\n                        ' (', self._backtick_columns(columns), ') VALUES (', ', '.join(['%s'] * len(columns)), ')'])\n        _args = tuple(value)\n\n        # For insertmany, the base queries for executemany and printing are different\n        _sql_full = ''.join(['INSERT', ' IGNORE' if ignore else '', ' INTO ', self._backtick(table),\n                             ' (', self._backtick_columns(columns), ') VALUES ',\n                             ', '.join([''.join(['(', ', '.join(['%s'] * len(columns)), ')'])] * len(_args)),\n                             ';'])\n\n        _args_flattened = [item for sublist in _args for item in sublist]\n\n        if self.debug:\n            return self.cur.mogrify(_sql_full, _args_flattened)\n\n        self.cur.executemany(_sql, _args)\n        if commit:\n            self.conn.commit()\n        return self.cur.lastrowid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, table, value, where, join=None, commit=True):\n\n        value_q, _value_args = self._value_parser(value, columnname=True)\n\n        where_q, _where_args = self._where_parser(where)\n\n        _sql = ''.join(['UPDATE ', self._tablename_parser(table)['formatted_tablename'],\n                        self._join_parser(join),\n                        ' SET ', value_q, where_q, ';'])\n        _args = _value_args + _where_args\n\n        if self.debug:\n            return self.cur.mogrify(_sql, _args)\n\n        result = self.cur.execute(_sql, _args)\n        if commit:\n            self.commit()\n        return result", "response": "Update the entry in the specified table with the given value and where."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self, table, where=None, commit=True):\n        where_q, _args = self._where_parser(where)\n\n        alias = self._tablename_parser(table)['alias']\n\n        _sql = ''.join(['DELETE ',\n                        alias + ' ' if alias else '',\n                        'FROM ', self._tablename_parser(table)['formatted_tablename'], where_q, ';'])\n\n        if self.debug:\n            return self.cur.mogrify(_sql, _args)\n\n        result = self.cur.execute(_sql, _args)\n        if commit:\n            self.commit()\n        return result", "response": "Delete all the entries in the specified table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_whitespace(txt):\n\n    # if the entire parameter is whitespace\n    rall = re.search(r'^([\\s])+$', txt)\n    if rall:\n        tmp = txt.split('\\n', 1)\n        if len(tmp) == 2:\n            return (tmp[0], '\\n' + tmp[1])  # left, right\n        else:\n            return ('', tmp[0])  # left, right\n    left = ''\n    # find whitespace to the left of the parameter\n    rlm = re.search(r'^([\\s])+', txt)\n    if rlm:\n        left = rlm.group(0)\n    right = ''\n    # find whitespace to the right of the parameter\n    rrm = re.search(r'([\\s])+$', txt)\n    if rrm:\n        right = rrm.group(0)\n    return (left, right)", "response": "Returns a list containing the whitespace to the left and right of a string as its two elements\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to find a whitespace pattern in the existing parameters to be applied to a newly added parameter .", "response": "def find_whitespace_pattern(self):\n        \"\"\"\n        Try to find a whitespace pattern in the existing parameters\n        to be applied to a newly added parameter\n        \"\"\"\n        name_ws = []\n        value_ws = []\n        for entry in self._entries:\n            name_ws.append(get_whitespace(entry.name))\n            if entry.value != '':\n                value_ws.append(get_whitespace(entry._value))  # _value is unstripped\n        if len(value_ws) >= 1:\n            value_ws = most_common(value_ws)\n        else:\n            value_ws = ('', ' ')\n        if len(name_ws) >= 1:\n            name_ws = most_common(name_ws)\n        else:\n            name_ws = (' ', '')\n        return name_ws, value_ws"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the path on disk for a specific project and date.", "response": "def _path_for_file(self, project_name, date):\n        \"\"\"\n        Generate the path on disk for a specified project and date.\n\n        :param project_name: the PyPI project name for the data\n        :type project: str\n        :param date: the date for the data\n        :type date: datetime.datetime\n        :return: path for where to store this data on disk\n        :rtype: str\n        \"\"\"\n        return os.path.join(\n            self.cache_path,\n            '%s_%s.json' % (project_name, date.strftime('%Y%m%d'))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, project, date):\n        fpath = self._path_for_file(project, date)\n        logger.debug('Cache GET project=%s date=%s - path=%s',\n                     project, date.strftime('%Y-%m-%d'), fpath)\n        try:\n            with open(fpath, 'r') as fh:\n                data = json.loads(fh.read())\n        except:\n            logger.debug('Error getting from cache for project=%s date=%s',\n                         project, date.strftime('%Y-%m-%d'))\n            return None\n        data['cache_metadata']['date'] = datetime.strptime(\n            data['cache_metadata']['date'],\n            '%Y%m%d'\n        )\n        data['cache_metadata']['updated'] = datetime.fromtimestamp(\n            data['cache_metadata']['updated']\n        )\n        return data", "response": "Get the cache data for a specified project and date."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set(self, project, date, data, data_ts):\n        data['cache_metadata'] = {\n            'project': project,\n            'date': date.strftime('%Y%m%d'),\n            'updated': time.time(),\n            'version': VERSION,\n            'data_ts': data_ts\n        }\n        fpath = self._path_for_file(project, date)\n        logger.debug('Cache SET project=%s date=%s - path=%s',\n                     project, date.strftime('%Y-%m-%d'), fpath)\n        with open(fpath, 'w') as fh:\n            fh.write(json.dumps(data))", "response": "Set the cache data for a specified project for the specified date."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_dates_for_project(self, project):\n        file_re = re.compile(r'^%s_([0-9]{8})\\.json$' % project)\n        all_dates = []\n        for f in os.listdir(self.cache_path):\n            if not os.path.isfile(os.path.join(self.cache_path, f)):\n                continue\n            m = file_re.match(f)\n            if m is None:\n                continue\n            all_dates.append(datetime.strptime(m.group(1), '%Y%m%d'))\n        return sorted(all_dates)", "response": "Return a list of the dates we have in cache for the specified project sorted in ascending date order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_args(argv):\n    p = argparse.ArgumentParser(\n        description='pypi-download-stats - Calculate detailed download stats '\n                    'and generate HTML and badges for PyPI packages - '\n                    '<%s>' % PROJECT_URL,\n        prog='pypi-download-stats'\n    )\n    p.add_argument('-V', '--version', action='version',\n                   version='%(prog)s ' + VERSION)\n    p.add_argument('-v', '--verbose', dest='verbose', action='count',\n                   default=0,\n                   help='verbose output. specify twice for debug-level output.')\n    m = p.add_mutually_exclusive_group()\n    m.add_argument('-Q', '--no-query', dest='query', action='store_false',\n                   default=True, help='do not query; just generate output '\n                                      'from cached data')\n    m.add_argument('-G', '--no-generate', dest='generate', action='store_false',\n                   default=True, help='do not generate output; just query '\n                                      'data and cache results')\n    p.add_argument('-o', '--out-dir', dest='out_dir', action='store', type=str,\n                   default='./pypi-stats', help='output directory (default: '\n                                                './pypi-stats')\n    p.add_argument('-p', '--project-id', dest='project_id', action='store',\n                   type=str, default=None,\n                   help='ProjectID for your Google Cloud user, if not using '\n                        'service account credentials JSON file')\n    # @TODO this is tied to the DiskDataCache class\n    p.add_argument('-c', '--cache-dir', dest='cache_dir', action='store',\n                   type=str, default='./pypi-stats-cache',\n                   help='stats cache directory (default: ./pypi-stats-cache)')\n    p.add_argument('-B', '--backfill-num-days', dest='backfill_days', type=int,\n                   action='store', default=7,\n                   help='number of days of historical data to backfill, if '\n                        'missing (defaut: 7). Note this may incur BigQuery '\n                        'charges. Set to -1 to backfill all available history.')\n    g = p.add_mutually_exclusive_group()\n    g.add_argument('-P', '--project', dest='PROJECT', action='append', type=str,\n                   help='project name to query/generate stats for (can be '\n                        'specified more than once; '\n                        'this will reduce query cost for multiple projects)')\n    g.add_argument('-U', '--user', dest='user', action='store', type=str,\n                   help='Run for all PyPI projects owned by the specified'\n                        'user.')\n    args = p.parse_args(argv)\n    return args", "response": "Parse command - line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_log_level_format(level, format):\n    formatter = logging.Formatter(fmt=format)\n    logger.handlers[0].setFormatter(formatter)\n    logger.setLevel(level)", "response": "Set logger level and format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pypi_get_projects_for_user(username):\n    client = xmlrpclib.ServerProxy('https://pypi.python.org/pypi')\n    pkgs = client.user_packages(username)  # returns [role, package]\n    return [x[1] for x in pkgs]", "response": "Returns a list of all of the user s\n    projects from the XMLRPC interface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(args=None):\n    # parse args\n    if args is None:\n        args = parse_args(sys.argv[1:])\n\n    # set logging level\n    if args.verbose > 1:\n        set_log_debug()\n    elif args.verbose == 1:\n        set_log_info()\n\n    outpath = os.path.abspath(os.path.expanduser(args.out_dir))\n    cachepath = os.path.abspath(os.path.expanduser(args.cache_dir))\n    cache = DiskDataCache(cache_path=cachepath)\n\n    if args.user:\n        args.PROJECT = _pypi_get_projects_for_user(args.user)\n\n    if args.query:\n        DataQuery(args.project_id, args.PROJECT, cache).run_queries(\n            backfill_num_days=args.backfill_days)\n    else:\n        logger.warning('Query disabled by command-line flag; operating on '\n                       'cached data only.')\n    if not args.generate:\n        logger.warning('Output generation disabled by command-line flag; '\n                       'exiting now.')\n        raise SystemExit(0)\n    for proj in args.PROJECT:\n        logger.info('Generating output for: %s', proj)\n        stats = ProjectStats(proj, cache)\n        outdir = os.path.join(outpath, proj)\n        OutputGenerator(proj, stats, outdir).generate()", "response": "Entry point for pypi\n."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_graph(self):\n        logger.debug('Generating graph for %s', self._graph_id)\n        # tools to use\n        tools = [\n            PanTool(),\n            BoxZoomTool(),\n            WheelZoomTool(),\n            SaveTool(),\n            ResetTool(),\n            ResizeTool()\n        ]\n\n        # generate the stacked area graph\n        try:\n            g = Area(\n                self._data, x='Date', y=self._y_series_names,\n                title=self._title, stack=True, xlabel='Date',\n                ylabel='Downloads', tools=tools,\n                # note the width and height will be set by JavaScript\n                plot_height=400, plot_width=800,\n                toolbar_location='above', legend=False\n            )\n        except Exception as ex:\n            logger.error(\"Error generating %s graph\", self._graph_id)\n            logger.error(\"Data: %s\", self._data)\n            logger.error(\"y=%s\", self._y_series_names)\n            raise ex\n\n        lines = []\n        legend_parts = []\n        # add a line at the top of each Patch (stacked area) for hovertool\n        for renderer in g.select(GlyphRenderer):\n            if not isinstance(renderer.glyph, Patches):\n                continue\n            series_name = renderer.data_source.data['series'][0]\n            logger.debug('Adding line for Patches %s (series: %s)', renderer,\n                         series_name)\n            line = self._line_for_patches(self._data, g, renderer, series_name)\n            if line is not None:\n                lines.append(line)\n                legend_parts.append((series_name, [line]))\n\n        # add the Hovertool, specifying only our line glyphs\n        g.add_tools(\n            HoverTool(\n                tooltips=[\n                    (self._y_name, '@SeriesName'),\n                    ('Date', '@FmtDate'),\n                    ('Downloads', '@Downloads'),\n                ],\n                renderers=lines,\n                line_policy='nearest'\n            )\n        )\n\n        # legend outside chart area\n        legend = Legend(legends=legend_parts, location=(0, 0))\n        g.add_layout(legend, 'right')\n        return components(g)", "response": "Generate the graph for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a line along the top edge of a Patch in a stacked Area Chart; return the new Glyph for addition to HoverTool. :param data: original data for the graph :type data: dict :param chart: Chart to add the line to :type chart: bokeh.charts.Chart :param renderer: GlyphRenderer containing one Patches glyph, to draw the line for :type renderer: bokeh.models.renderers.GlyphRenderer :param series_name: the data series name this Patches represents :type series_name: str :return: GlyphRenderer for a Line at the top edge of this Patch :rtype: bokeh.models.renderers.GlyphRenderer", "response": "def _line_for_patches(self, data, chart, renderer, series_name):\n        \"\"\"\n        Add a line along the top edge of a Patch in a stacked Area Chart; return\n        the new Glyph for addition to HoverTool.\n\n        :param data: original data for the graph\n        :type data: dict\n        :param chart: Chart to add the line to\n        :type chart: bokeh.charts.Chart\n        :param renderer: GlyphRenderer containing one Patches glyph, to draw\n          the line for\n        :type renderer: bokeh.models.renderers.GlyphRenderer\n        :param series_name: the data series name this Patches represents\n        :type series_name: str\n        :return: GlyphRenderer for a Line at the top edge of this Patch\n        :rtype: bokeh.models.renderers.GlyphRenderer\n        \"\"\"\n        # @TODO this method needs a major refactor\n        # get the original x and y values, and color\n        xvals = deepcopy(renderer.data_source.data['x_values'][0])\n        yvals = deepcopy(renderer.data_source.data['y_values'][0])\n        line_color = renderer.glyph.fill_color\n\n        # save original values for logging if needed\n        orig_xvals = [x for x in xvals]\n        orig_yvals = [y for y in yvals]\n\n        # get a list of the values\n        new_xvals = [x for x in xvals]\n        new_yvals = [y for y in yvals]\n\n        # so when a Patch is made, the first point is (0,0); trash it\n        xvals = new_xvals[1:]\n        yvals = new_yvals[1:]\n\n        # then, we can tell the last point in the \"top\" line because it will be\n        # followed by a point with the same x value and a y value of 0.\n        last_idx = None\n        for idx, val in enumerate(xvals):\n            if yvals[idx+1] == 0 and xvals[idx+1] == xvals[idx]:\n                last_idx = idx\n                break\n\n        if last_idx is None:\n            logger.error('Unable to find top line of patch (x_values=%s '\n                         'y_values=%s', orig_xvals, orig_yvals)\n            return None\n\n        # truncate our values to just what makes up the top line\n        xvals = xvals[:last_idx+1]\n        yvals = yvals[:last_idx+1]\n\n        # Currently (bokeh 0.12.1) HoverTool won't show the tooltip for the last\n        # point in our line. As a hack for this, add a point with the same Y\n        # value and an X slightly before it.\n        lastx = xvals[-1]\n        xvals[-1] = lastx - 1000  # 1000 nanoseconds\n        xvals.append(lastx)\n        yvals.append(yvals[-1])\n        # get the actual download counts from the original data\n        download_counts = [\n            data[series_name][y] for y in range(0, len(yvals) - 1)\n        ]\n        download_counts.append(download_counts[-1])\n\n        # create a ColumnDataSource for the new overlay line\n        data2 = {\n            'x': xvals,  # Date/x values are numpy.datetime64\n            'y': yvals,\n            # the following are hacks for data that we want in the HoverTool\n            # tooltip\n            'SeriesName': [series_name for _ in yvals],\n            # formatted date\n            'FmtDate': [self.datetime64_to_formatted_date(x) for x in xvals],\n            # to show the exact value, not where the pointer is\n            'Downloads': download_counts\n        }\n        # set the formatted date for our hacked second-to-last point to the\n        # same value as the last point\n        data2['FmtDate'][-2] = data2['FmtDate'][-1]\n\n        # create the CloumnDataSource, then the line for it, then the Glyph\n        line_ds = ColumnDataSource(data2)\n        line = Line(x='x', y='y', line_color=line_color)\n        lineglyph = chart.add_glyph(line_ds, line)\n        return lineglyph"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_cache_dates(self):\n        all_dates = self.cache.get_dates_for_project(self.project_name)\n        dates = []\n        last_date = None\n        for val in sorted(all_dates):\n            if last_date is None:\n                last_date = val\n                continue\n            if val - last_date > timedelta(hours=48):\n                # reset dates to start from here\n                logger.warning(\"Last cache date was %s, current date is %s; \"\n                               \"delta is too large. Starting cache date series \"\n                               \"at current date.\", last_date, val)\n                dates = []\n            last_date = val\n            dates.append(val)\n        # find the first download record, and only look at dates after that\n        for idx, cache_date in enumerate(dates):\n            data = self._cache_get(cache_date)\n            if not self._is_empty_cache_record(data):\n                logger.debug(\"First cache date with data: %s\", cache_date)\n                return dates[idx:]\n        return dates", "response": "Get a list of dates that are present in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the specified cache record has no data False otherwise.", "response": "def _is_empty_cache_record(self, rec):\n        \"\"\"\n        Return True if the specified cache record has no data, False otherwise.\n\n        :param rec: cache record returned by :py:meth:`~._cache_get`\n        :type rec: dict\n        :return: True if record is empty, False otherwise\n        :rtype: bool\n        \"\"\"\n        # these are taken from DataQuery.query_one_table()\n        for k in [\n            'by_version',\n            'by_file_type',\n            'by_installer',\n            'by_implementation',\n            'by_system',\n            'by_distro',\n            'by_country'\n        ]:\n            if k in rec and len(rec[k]) > 0:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _cache_get(self, date):\n        if date in self.cache_data:\n            logger.debug('Using class-cached data for date %s',\n                         date.strftime('%Y-%m-%d'))\n            return self.cache_data[date]\n        logger.debug('Getting data from cache for date %s',\n                     date.strftime('%Y-%m-%d'))\n        data = self.cache.get(self.project_name, date)\n        self.cache_data[date] = data\n        return data", "response": "Get the cache data for the specified day."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _compound_column_value(k1, k2):\n        k1 = ProjectStats._column_value(k1)\n        k2 = ProjectStats._column_value(k2)\n        if k1 == 'unknown' and k2 == 'unknown':\n            return 'unknown'\n        return '%s %s' % (k1, k2)", "response": "Like _column_value but collapses two unknowns into one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshortening the version string to be a number of components.", "response": "def _shorten_version(ver, num_components=2):\n        \"\"\"\n        If ``ver`` is a dot-separated string with at least (num_components +1)\n        components, return only the first two. Else return the original string.\n\n        :param ver: version string\n        :type ver: str\n        :return: shortened (major, minor) version\n        :rtype: str\n        \"\"\"\n        parts = ver.split('.')\n        if len(parts) <= num_components:\n            return ver\n        return '.'.join(parts[:num_components])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef per_version_data(self):\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            if len(data['by_version']) == 0:\n                data['by_version'] = {'other': 0}\n            ret[cache_date] = data['by_version']\n        return ret", "response": "Return download data by version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning download data by file type.", "response": "def per_file_type_data(self):\n        \"\"\"\n        Return download data by file type.\n\n        :return: dict of cache data; keys are datetime objects, values are\n          dict of file type (str) to count (int)\n        :rtype: dict\n        \"\"\"\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            if len(data['by_file_type']) == 0:\n                data['by_file_type'] = {'other': 0}\n            ret[cache_date] = data['by_file_type']\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef per_installer_data(self):\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            ret[cache_date] = {}\n            for inst_name, inst_data in data['by_installer'].items():\n                for inst_ver, count in inst_data.items():\n                    k = self._compound_column_value(\n                        inst_name,\n                        self._shorten_version(inst_ver)\n                    )\n                    ret[cache_date][k] = count\n            if len(ret[cache_date]) == 0:\n                ret[cache_date]['unknown'] = 0\n        return ret", "response": "Return download data by installer name and version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning download data by python impelementation name and version.", "response": "def per_implementation_data(self):\n        \"\"\"\n        Return download data by python impelementation name and version.\n\n        :return: dict of cache data; keys are datetime objects, values are\n          dict of implementation name/version (str) to count (int).\n        :rtype: dict\n        \"\"\"\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            ret[cache_date] = {}\n            for impl_name, impl_data in data['by_implementation'].items():\n                for impl_ver, count in impl_data.items():\n                    k = self._compound_column_value(\n                        impl_name,\n                        self._shorten_version(impl_ver)\n                    )\n                    ret[cache_date][k] = count\n            if len(ret[cache_date]) == 0:\n                ret[cache_date]['unknown'] = 0\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn download data by system.", "response": "def per_system_data(self):\n        \"\"\"\n        Return download data by system.\n\n        :return: dict of cache data; keys are datetime objects, values are\n          dict of system (str) to count (int)\n        :rtype: dict\n        \"\"\"\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            ret[cache_date] = {\n                self._column_value(x): data['by_system'][x]\n                for x in data['by_system']\n            }\n            if len(ret[cache_date]) == 0:\n                ret[cache_date]['unknown'] = 0\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn download data by country.", "response": "def per_country_data(self):\n        \"\"\"\n        Return download data by country.\n\n        :return: dict of cache data; keys are datetime objects, values are\n          dict of country (str) to count (int)\n        :rtype: dict\n        \"\"\"\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            ret[cache_date] = {}\n            for cc, count in data['by_country'].items():\n                k = '%s (%s)' % (self._alpha2_to_country(cc), cc)\n                ret[cache_date][k] = count\n            if len(ret[cache_date]) == 0:\n                ret[cache_date]['unknown'] = 0\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns download data by distro name and version.", "response": "def per_distro_data(self):\n        \"\"\"\n        Return download data by distro name and version.\n\n        :return: dict of cache data; keys are datetime objects, values are\n          dict of distro name/version (str) to count (int).\n        :rtype: dict\n        \"\"\"\n        ret = {}\n        for cache_date in self.cache_dates:\n            data = self._cache_get(cache_date)\n            ret[cache_date] = {}\n            for distro_name, distro_data in data['by_distro'].items():\n                if distro_name.lower() == 'red hat enterprise linux server':\n                    distro_name = 'RHEL'\n                for distro_ver, count in distro_data.items():\n                    ver = self._shorten_version(distro_ver, num_components=1)\n                    if distro_name.lower() == 'os x':\n                        ver = self._shorten_version(distro_ver,\n                                                    num_components=2)\n                    k = self._compound_column_value(distro_name, ver)\n                    ret[cache_date][k] = count\n            if len(ret[cache_date]) == 0:\n                ret[cache_date]['unknown'] = 0\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef downloads_per_day(self):\n        count, num_days = self._downloads_for_num_days(7)\n        res = ceil(count / num_days)\n        logger.debug(\"Downloads per day = (%d / %d) = %d\", count, num_days, res)\n        return res", "response": "Return the number of downloads per day average over the past 7 days\n        of data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the number of downloads per week in the last 7 days of data.", "response": "def downloads_per_week(self):\n        \"\"\"\n        Return the number of downloads in the last 7 days.\n\n        :return: number of downloads in the last 7 days; if we have less than\n          7 days of data, returns None.\n        :rtype: int\n        \"\"\"\n        if len(self.cache_dates) < 7:\n            logger.error(\"Only have %d days of data; cannot calculate \"\n                         \"downloads per week\", len(self.cache_dates))\n            return None\n        count, _ = self._downloads_for_num_days(7)\n        logger.debug(\"Downloads per week = %d\", count)\n        return count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the total number of downloads for a given number of days of data.", "response": "def _downloads_for_num_days(self, num_days):\n        \"\"\"\n        Given a number of days of historical data to look at (starting with\n        today and working backwards), return the total number of downloads\n        for that time range, and the number of days of data we had (in cases\n        where we had less data than requested).\n\n        :param num_days: number of days of data to look at\n        :type num_days: int\n        :return: 2-tuple of (download total, number of days of data)\n        :rtype: tuple\n        \"\"\"\n        logger.debug(\"Getting download total for last %d days\", num_days)\n        dates = self.cache_dates\n        logger.debug(\"Cache has %d days of data\", len(dates))\n        if len(dates) > num_days:\n            dates = dates[(-1 * num_days):]\n        logger.debug(\"Looking at last %d days of data\", len(dates))\n        dl_sum = 0\n        for cache_date in dates:\n            data = self._cache_get(cache_date)\n            dl_sum += sum(data['by_version'].values())\n        logger.debug(\"Sum of download counts: %d\", dl_sum)\n        return dl_sum, len(dates)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_project_id(self):\n        fpath = os.environ.get('GOOGLE_APPLICATION_CREDENTIALS', None)\n        if fpath is None:\n            raise Exception('ERROR: No project ID specified, and '\n                            'GOOGLE_APPLICATION_CREDENTIALS env var is not set')\n        fpath = os.path.abspath(os.path.expanduser(fpath))\n        logger.debug('Reading credentials file at %s to get project_id', fpath)\n        with open(fpath, 'r') as fh:\n            cred_data = json.loads(fh.read())\n        return cred_data['project_id']", "response": "Get our projectId from the GOOGLE_APPLICATION_CREDENTIALS file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconnects to the BigQuery service.", "response": "def _get_bigquery_service(self):\n        \"\"\"\n        Connect to the BigQuery service.\n\n        Calling ``GoogleCredentials.get_application_default`` requires that\n        you either be running in the Google Cloud, or have the\n        ``GOOGLE_APPLICATION_CREDENTIALS`` environment variable set to the path\n        to a credentials JSON file.\n\n        :return: authenticated BigQuery service connection object\n        :rtype: `googleapiclient.discovery.Resource <http://google.github.io/\\\ngoogle-api-python-client/docs/epy/googleapiclient.discovery.\\\nResource-class.html>`_\n        \"\"\"\n        logger.debug('Getting Google Credentials')\n        credentials = GoogleCredentials.get_application_default()\n        logger.debug('Building BigQuery service instance')\n        bigquery_service = build('bigquery', 'v2', credentials=credentials)\n        return bigquery_service"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of PyPI downloads table IDs.", "response": "def _get_download_table_ids(self):\n        \"\"\"\n        Get a list of PyPI downloads table (sharded per day) IDs.\n\n        :return: list of table names (strings)\n        :rtype: ``list``\n        \"\"\"\n        all_table_names = []  # matching per-date table names\n        logger.info('Querying for all tables in dataset')\n        tables = self.service.tables()\n        request = tables.list(projectId=self._PROJECT_ID,\n                              datasetId=self._DATASET_ID)\n        while request is not None:\n            response = request.execute()\n            # if the number of results is evenly divisible by the page size,\n            # we may end up with a last response that has no 'tables' key,\n            # and is empty.\n            if 'tables' not in response:\n                response['tables'] = []\n            for table in response['tables']:\n                if table['type'] != 'TABLE':\n                    logger.debug('Skipping %s (type=%s)',\n                                 table['tableReference']['tableId'],\n                                 table['type'])\n                    continue\n                if not self._table_re.match(table['tableReference']['tableId']):\n                    logger.debug('Skipping table with non-matching name: %s',\n                                 table['tableReference']['tableId'])\n                    continue\n                all_table_names.append(table['tableReference']['tableId'])\n            request = tables.list_next(previous_request=request,\n                                       previous_response=response)\n        return sorted(all_table_names)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _datetime_for_table_name(self, table_name):\n        m = self._table_re.match(table_name)\n        dt = datetime.strptime(m.group(1), '%Y%m%d')\n        return dt", "response": "Return a datetime object for the date of the data in the specified table name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns one query against BigQuery and return the result.", "response": "def _run_query(self, query):\n        \"\"\"\n        Run one query against BigQuery and return the result.\n\n        :param query: the query to run\n        :type query: str\n        :return: list of per-row response dicts (key => value)\n        :rtype: ``list``\n        \"\"\"\n        query_request = self.service.jobs()\n        logger.debug('Running query: %s', query)\n        start = datetime.now()\n        resp = query_request.query(\n            projectId=self.project_id, body={'query': query}\n        ).execute()\n        duration = datetime.now() - start\n        logger.debug('Query response (in %s): %s', duration, resp)\n        if not resp['jobComplete']:\n            logger.error('Error: query reported job not complete!')\n        if int(resp['totalRows']) == 0:\n            return []\n        if int(resp['totalRows']) != len(resp['rows']):\n            logger.error('Error: query reported %s total rows, but only '\n                         'returned %d', resp['totalRows'], len(resp['rows']))\n        data = []\n        fields = [f['name'] for f in resp['schema']['fields']]\n        for row in resp['rows']:\n            d = {}\n            for idx, val in enumerate(row['f']):\n                d[fields[idx]] = val['v']\n            data.append(d)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery the database to get the newest timestamp in the given table.", "response": "def _get_newest_ts_in_table(self, table_name):\n        \"\"\"\n        Return the timestamp for the newest record in the given table.\n\n        :param table_name: name of the table to query\n        :type table_name: str\n        :return: timestamp of newest row in table\n        :rtype: int\n        \"\"\"\n        logger.debug(\n            'Querying for newest timestamp in table %s', table_name\n        )\n        q = \"SELECT TIMESTAMP_TO_SEC(MAX(timestamp)) AS max_ts %s;\" % (\n            self._from_for_table(table_name)\n        )\n        res = self._run_query(q)\n        ts = int(res[0]['max_ts'])\n        logger.debug('Newest timestamp in table %s: %s', table_name, ts)\n        return ts"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying for download data broken down by installer for one day.", "response": "def _query_by_installer(self, table_name):\n        \"\"\"\n        Query for download data broken down by installer, for one day.\n\n        :param table_name: table name to query against\n        :type table_name: str\n        :return: dict of download information by installer; keys are project\n          name, values are a dict of installer names to dicts of installer\n          version to download count.\n        :rtype: dict\n        \"\"\"\n        logger.info('Querying for downloads by installer in table %s',\n                    table_name)\n        q = \"SELECT file.project, details.installer.name, \" \\\n            \"details.installer.version, COUNT(*) as dl_count \" \\\n            \"%s \" \\\n            \"%s \" \\\n            \"GROUP BY file.project, details.installer.name, \" \\\n            \"details.installer.version;\" % (\n                self._from_for_table(table_name),\n                self._where_for_projects\n            )\n        res = self._run_query(q)\n        result = self._dict_for_projects()\n        # iterate through results\n        for row in res:\n            # pointer to the per-project result dict\n            proj = result[row['file_project']]\n            # grab the name and version; change None to 'unknown'\n            iname = row['details_installer_name']\n            iver = row['details_installer_version']\n            if iname not in proj:\n                proj[iname] = {}\n            if iver not in proj[iname]:\n                proj[iname][iver] = 0\n            proj[iname][iver] += int(row['dl_count'])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery for download data broken down by system for one day.", "response": "def _query_by_system(self, table_name):\n        \"\"\"\n        Query for download data broken down by system, for one day.\n\n        :param table_name: table name to query against\n        :type table_name: str\n        :return: dict of download information by system; keys are project name,\n          values are a dict of system names to download count.\n        :rtype: dict\n        \"\"\"\n        logger.info('Querying for downloads by system in table %s',\n                    table_name)\n        q = \"SELECT file.project, details.system.name, COUNT(*) as dl_count \" \\\n            \"%s \" \\\n            \"%s \" \\\n            \"GROUP BY file.project, details.system.name;\" % (\n                self._from_for_table(table_name),\n                self._where_for_projects\n            )\n        res = self._run_query(q)\n        result = self._dict_for_projects()\n        for row in res:\n            system = row['details_system_name']\n            result[row['file_project']][system] = int(\n                row['dl_count'])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nqueries for download data broken down by OS distribution for one day.", "response": "def _query_by_distro(self, table_name):\n        \"\"\"\n        Query for download data broken down by OS distribution, for one day.\n\n        :param table_name: table name to query against\n        :type table_name: str\n        :return: dict of download information by distro; keys are project name,\n          values are a dict of distro names to dicts of distro version to\n          download count.\n        :rtype: dict\n        \"\"\"\n        logger.info('Querying for downloads by distro in table %s', table_name)\n        q = \"SELECT file.project, details.distro.name, \" \\\n            \"details.distro.version, COUNT(*) as dl_count \" \\\n            \"%s \" \\\n            \"%s \" \\\n            \"GROUP BY file.project, details.distro.name, \" \\\n            \"details.distro.version;\" % (\n                self._from_for_table(table_name),\n                self._where_for_projects\n            )\n        res = self._run_query(q)\n        result = self._dict_for_projects()\n        # iterate through results\n        for row in res:\n            # pointer to the per-project result dict\n            proj = result[row['file_project']]\n            # grab the name and version; change None to 'unknown'\n            dname = row['details_distro_name']\n            dver = row['details_distro_version']\n            if dname not in proj:\n                proj[dname] = {}\n            if dver not in proj[dname]:\n                proj[dname][dver] = 0\n            proj[dname][dver] += int(row['dl_count'])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query_one_table(self, table_name):\n        table_date = self._datetime_for_table_name(table_name)\n        logger.info('Running all queries for date table: %s (%s)', table_name,\n                    table_date.strftime('%Y-%m-%d'))\n        final = self._dict_for_projects()\n        try:\n            data_timestamp = self._get_newest_ts_in_table(table_name)\n        except HttpError as exc:\n            try:\n                content = json.loads(exc.content.decode('utf-8'))\n                if content['error']['message'].startswith('Not found: Table'):\n                    logger.error(\"Table %s not found; no data for that day\",\n                                 table_name)\n                    return\n            except:\n                pass\n            raise exc\n        # data queries\n        # note - ProjectStats._is_empty_cache_record() needs to know keys\n        for name, func in {\n            'by_version': self._query_by_version,\n            'by_file_type': self._query_by_file_type,\n            'by_installer': self._query_by_installer,\n            'by_implementation': self._query_by_implementation,\n            'by_system': self._query_by_system,\n            'by_distro': self._query_by_distro,\n            'by_country': self._query_by_country_code\n        }.items():\n            tmp = func(table_name)\n            for proj_name in tmp:\n                final[proj_name][name] = tmp[proj_name]\n        # add to cache\n        for proj_name in final:\n            self.cache.set(proj_name, table_date, final[proj_name],\n                           data_timestamp)", "response": "Query all queries for a given table and update the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if we have cached data for the specified datetime. Return False otherwise.", "response": "def _have_cache_for_date(self, dt):\n        \"\"\"\n        Return True if we have cached data for all projects for the specified\n        datetime. Return False otherwise.\n\n        :param dt: datetime to find cache for\n        :type dt: datetime.datetime\n        :return: True if we have cache for all projects for this date, False\n          otherwise\n        :rtype: bool\n        \"\"\"\n        for p in self.projects:\n            if self.cache.get(p, dt) is None:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef backfill_history(self, num_days, available_table_names):\n        if num_days == -1:\n            # skip the first date, under the assumption that data may be\n            # incomplete\n            logger.info('Backfilling all available history')\n            start_table = available_table_names[1]\n        else:\n            logger.info('Backfilling %d days of history', num_days)\n            start_table = available_table_names[-1 * num_days]\n        start_date = self._datetime_for_table_name(start_table)\n        end_table = available_table_names[-3]\n        end_date = self._datetime_for_table_name(end_table)\n        logger.debug(\n            'Backfilling history from %s (%s) to %s (%s)', start_table,\n            start_date.strftime('%Y-%m-%d'), end_table,\n            end_date.strftime('%Y-%m-%d')\n        )\n        for days in range((end_date - start_date).days + 1):\n            backfill_dt = start_date + timedelta(days=days)\n            if self._have_cache_for_date(backfill_dt):\n                logger.info('Cache present for all projects for %s; skipping',\n                            backfill_dt.strftime('%Y-%m-%d'))\n                continue\n            backfill_table = self._table_name_for_datetime(backfill_dt)\n            logger.info('Backfilling %s (%s)', backfill_table,\n                        backfill_dt.strftime('%Y-%m-%d'))\n            self.query_one_table(backfill_table)", "response": "Backfill historical data for num_days days."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the data queries for the specified projects.", "response": "def run_queries(self, backfill_num_days=7):\n        \"\"\"\n        Run the data queries for the specified projects.\n\n        :param backfill_num_days: number of days of historical data to backfill,\n          if missing\n        :type backfill_num_days: int\n        \"\"\"\n        available_tables = self._get_download_table_ids()\n        logger.debug('Found %d available download tables: %s',\n                     len(available_tables), available_tables)\n        today_table = available_tables[-1]\n        yesterday_table = available_tables[-2]\n        self.query_one_table(today_table)\n        self.query_one_table(yesterday_table)\n        self.backfill_history(backfill_num_days, available_tables)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_data_columns(data):\n    keys = set()\n    for dt, d in data.items():\n        for k in d:\n            keys.add(k)\n    return sorted([x for x in keys])", "response": "Given a dict of data such as those in ProjectStats attributes return a list of distinct column keys in sorted order."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating the HTML for the specified graphs.", "response": "def _generate_html(self):\n        \"\"\"\n        Generate the HTML for the specified graphs.\n\n        :return:\n        :rtype:\n        \"\"\"\n        logger.debug('Generating templated HTML')\n        env = Environment(\n            loader=PackageLoader('pypi_download_stats', 'templates'),\n            extensions=['jinja2.ext.loopcontrols'])\n        env.filters['format_date_long'] = filter_format_date_long\n        env.filters['format_date_ymd'] = filter_format_date_ymd\n        env.filters['data_columns'] = filter_data_columns\n        template = env.get_template('base.html')\n\n        logger.debug('Rendering template')\n        html = template.render(\n            project=self.project_name,\n            cache_date=self._stats.as_of_datetime,\n            user=getuser(),\n            host=platform_node(),\n            version=VERSION,\n            proj_url=PROJECT_URL,\n            graphs=self._graphs,\n            graph_keys=self.GRAPH_KEYS,\n            resources=Resources(mode='inline').render(),\n            badges=self._badges\n        )\n        logger.debug('Template rendered')\n        return html"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _data_dict_to_bokeh_chart_data(self, data):\n        labels = []\n        # find all the data keys\n        keys = set()\n        for date in data:\n            for k in data[date]:\n                keys.add(k)\n        # final output dict\n        out_data = {}\n        for k in keys:\n            out_data[k] = []\n        # transform the data; deal with sparse data\n        for data_date, data_dict in sorted(data.items()):\n            labels.append(data_date)\n            for k in out_data:\n                if k in data_dict:\n                    out_data[k].append(data_dict[k])\n                else:\n                    out_data[k].append(0)\n        return out_data, labels", "response": "Take a dictionary of data and return a 2 - tuple of data dict and x labels list\n        usable by bokeh. charts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _limit_data(self, data):\n        if len(data.keys()) <= 10:\n            logger.debug(\"Data has less than 10 keys; not limiting\")\n            return data\n        # average last 7 days of each series\n        avgs = {}\n        for k in data:\n            if len(data[k]) <= 7:\n                vals = data[k]\n            else:\n                vals = data[k][-7:]\n            avgs[k] = sum(vals) / len(vals)\n        # hold state\n        final_data = {}  # final data dict\n        other = []  # values for dropped/'other' series\n        count = 0  # iteration counter\n        # iterate the sorted averages; either drop or keep\n        for k in sorted(avgs, key=avgs.get, reverse=True):\n            if count < 10:\n                final_data[k] = data[k]\n                logger.debug(\"Keeping data series %s (average over last 7 \"\n                             \"days of data: %d\", k, avgs[k])\n            else:\n                logger.debug(\"Adding data series %s to 'other' (average over \"\n                             \"last 7 days of data: %d\", k, avgs[k])\n                other.append(data[k])\n            count += 1\n        # sum up the other data and add to final\n        final_data['other'] = [sum(series) for series in zip(*other)]\n        return final_data", "response": "Limit the data to 10 series."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a downloads graph for the given name title and stats_data.", "response": "def _generate_graph(self, name, title, stats_data, y_name):\n        \"\"\"\n        Generate a downloads graph; append it to ``self._graphs``.\n\n        :param name: HTML name of the graph, also used in ``self.GRAPH_KEYS``\n        :type name: str\n        :param title: human-readable title for the graph\n        :type title: str\n        :param stats_data: data dict from ``self._stats``\n        :type stats_data: dict\n        :param y_name: Y axis metric name\n        :type y_name: str\n        \"\"\"\n        logger.debug('Generating chart data for %s graph', name)\n        orig_data, labels = self._data_dict_to_bokeh_chart_data(stats_data)\n        data = self._limit_data(orig_data)\n        logger.debug('Generating %s graph', name)\n        script, div = FancyAreaGraph(\n            name, '%s %s' % (self.project_name, title), data, labels,\n            y_name).generate_graph()\n        logger.debug('%s graph generated', name)\n        self._graphs[name] = {\n            'title': title,\n            'script': script,\n            'div': div,\n            'raw_data': stats_data\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating download badges. Append them to self. _badges.", "response": "def _generate_badges(self):\n        \"\"\"\n        Generate download badges. Append them to ``self._badges``.\n        \"\"\"\n        daycount = self._stats.downloads_per_day\n        day = self._generate_badge('Downloads', '%d/day' % daycount)\n        self._badges['per-day'] = day\n        weekcount = self._stats.downloads_per_week\n        if weekcount is None:\n            # we don't have enough data for week (or month)\n            return\n        week = self._generate_badge('Downloads', '%d/week' % weekcount)\n        self._badges['per-week'] = week\n        monthcount = self._stats.downloads_per_month\n        if monthcount is None:\n            # we don't have enough data for month\n            return\n        month = self._generate_badge('Downloads', '%d/month' % monthcount)\n        self._badges['per-month'] = month"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating one badge via shields. io.", "response": "def _generate_badge(self, subject, status):\n        \"\"\"\n        Generate SVG for one badge via shields.io.\n\n        :param subject: subject; left-hand side of badge\n        :type subject: str\n        :param status: status; right-hand side of badge\n        :type status: str\n        :return: badge SVG\n        :rtype: str\n        \"\"\"\n        url = 'https://img.shields.io/badge/%s-%s-brightgreen.svg' \\\n              '?style=flat&maxAge=3600' % (subject, status)\n        logger.debug(\"Getting badge for %s => %s (%s)\", subject, status, url)\n        res = requests.get(url)\n        if res.status_code != 200:\n            raise Exception(\"Error: got status %s for shields.io badge: %s\",\n                            res.status_code, res.text)\n        logger.debug('Got %d character response from shields.io', len(res.text))\n        return res.text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating all output types and write to disk.", "response": "def generate(self):\n        \"\"\"\n        Generate all output types and write to disk.\n        \"\"\"\n        logger.info('Generating graphs')\n        self._generate_graph(\n            'by-version',\n            'Downloads by Version',\n            self._stats.per_version_data,\n            'Version'\n        )\n        self._generate_graph(\n            'by-file-type',\n            'Downloads by File Type',\n            self._stats.per_file_type_data,\n            'File Type'\n        )\n        self._generate_graph(\n            'by-installer',\n            'Downloads by Installer',\n            self._stats.per_installer_data,\n            'Installer'\n        )\n        self._generate_graph(\n            'by-implementation',\n            'Downloads by Python Implementation/Version',\n            self._stats.per_implementation_data,\n            'Implementation/Version'\n        )\n        self._generate_graph(\n            'by-system',\n            'Downloads by System Type',\n            self._stats.per_system_data,\n            'System'\n        )\n        self._generate_graph(\n            'by-country',\n            'Downloads by Country',\n            self._stats.per_country_data,\n            'Country'\n        )\n        self._generate_graph(\n            'by-distro',\n            'Downloads by Distro',\n            self._stats.per_distro_data,\n            'Distro'\n        )\n        self._generate_badges()\n        logger.info('Generating HTML')\n        html = self._generate_html()\n        html_path = os.path.join(self.output_dir, 'index.html')\n        with open(html_path, 'wb') as fh:\n            fh.write(html.encode('utf-8'))\n        logger.info('HTML report written to %s', html_path)\n        logger.info('Writing SVG badges')\n        for name, svg in self._badges.items():\n            path = os.path.join(self.output_dir, '%s.svg' % name)\n            with open(path, 'w') as fh:\n                fh.write(svg)\n            logger.info('%s badge written to: %s', name, path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a formatted version of the given datetime instance.", "response": "def datetime_format(desired_format, datetime_instance=None,  *args, **kwargs):\n    \"\"\"\n    Replaces format style phrases (listed in the dt_exps dictionary)\n    with this datetime instance's information.\n\n    .. code :: python\n\n        reusables.datetime_format(\"Hey, it's {month-full} already!\")\n        \"Hey, it's March already!\"\n\n    :param desired_format: string to add datetime details too\n    :param datetime_instance: datetime.datetime instance, defaults to 'now'\n    :param args: additional args to pass to str.format\n    :param kwargs: additional kwargs to pass to str format\n    :return: formatted string\n    \"\"\"\n    for strf, exp in datetime_regex.datetime.format.items():\n        desired_format = exp.sub(strf, desired_format)\n    if not datetime_instance:\n        datetime_instance = now()\n    return datetime_instance.strftime(desired_format.format(*args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef datetime_from_iso(iso_string):\n    try:\n        assert datetime_regex.datetime.datetime.match(iso_string).groups()[0]\n    except (ValueError, AssertionError, IndexError, AttributeError):\n        raise TypeError(\"String is not in ISO format\")\n    try:\n        return datetime.datetime.strptime(iso_string, \"%Y-%m-%dT%H:%M:%S.%f\")\n    except ValueError:\n        return datetime.datetime.strptime(iso_string, \"%Y-%m-%dT%H:%M:%S\")", "response": "Create a DateTime object from an ISO string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a current DateTime object. By default is local.", "response": "def now(utc=False, tz=None):\n    \"\"\"\n    Get a current DateTime object. By default is local.\n\n    .. code:: python\n\n        reusables.now()\n        # DateTime(2016, 12, 8, 22, 5, 2, 517000)\n\n        reusables.now().format(\"It's {24-hour}:{min}\")\n        # \"It's 22:05\"\n\n    :param utc: bool, default False, UTC time not local\n    :param tz: TimeZone as specified by the datetime module\n    :return: reusables.DateTime\n    \"\"\"\n    return datetime.datetime.utcnow() if utc else datetime.datetime.now(tz=tz)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a command and return a new process object.", "response": "def run(command, input=None, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n        timeout=None, copy_local_env=False, **kwargs):\n    \"\"\"\n    Cross platform compatible subprocess with CompletedProcess return.\n\n    No formatting or encoding is performed on the output of subprocess, so it's\n    output will appear the same on each version / interpreter as before.\n\n    .. code:: python\n\n        reusables.run('echo \"hello world!', shell=True)\n        # CPython 3.6\n        # CompletedProcess(args='echo \"hello world!', returncode=0,\n        #                  stdout=b'\"hello world!\\\\r\\\\n', stderr=b'')\n        #\n        # PyPy 5.4 (Python 2.7.10)\n        # CompletedProcess(args='echo \"hello world!', returncode=0L,\n        # stdout='\"hello world!\\\\r\\\\n')\n\n    Timeout is only usable in Python 3.X, as it was not implemented before then,\n    a NotImplementedError will be raised if specified on 2.x version of Python.\n\n    :param command: command to run, str if shell=True otherwise must be list\n    :param input: send something `communicate`\n    :param stdout: PIPE or None\n    :param stderr: PIPE or None\n    :param timeout: max time to wait for command to complete\n    :param copy_local_env: Use all current ENV vars in the subprocess as well\n    :param kwargs: additional arguments to pass to Popen\n    :return: CompletedProcess class\n    \"\"\"\n    if copy_local_env:\n        # Copy local env first and overwrite with anything manually specified\n        env = os.environ.copy()\n        env.update(kwargs.get('env', {}))\n    else:\n        env = kwargs.get('env')\n\n    if sys.version_info >= (3, 5):\n        return subprocess.run(command, input=input, stdout=stdout,\n                              stderr=stderr, timeout=timeout, env=env,\n                              **kwargs)\n\n    # Created here instead of root level as it should never need to be\n    # manually created or referenced\n    class CompletedProcess(object):\n        \"\"\"A backwards compatible near clone of subprocess.CompletedProcess\"\"\"\n\n        def __init__(self, args, returncode, stdout=None, stderr=None):\n            self.args = args\n            self.returncode = returncode\n            self.stdout = stdout\n            self.stderr = stderr\n\n        def __repr__(self):\n            args = ['args={0!r}'.format(self.args),\n                    'returncode={0!r}'.format(self.returncode),\n                    'stdout={0!r}'.format(self.stdout) if self.stdout else '',\n                    'stderr={0!r}'.format(self.stderr) if self.stderr else '']\n            return \"{0}({1})\".format(type(self).__name__,\n                                     ', '.join(filter(None, args)))\n\n        def check_returncode(self):\n            if self.returncode:\n                if python_version < (2, 7):\n                    raise subprocess.CalledProcessError(self.returncode,\n                                                        self.args)\n                raise subprocess.CalledProcessError(self.returncode,\n                                                    self.args,\n                                                    self.stdout)\n\n    proc = subprocess.Popen(command, stdout=stdout, stderr=stderr,\n                            env=env, **kwargs)\n    if PY3:\n        out, err = proc.communicate(input=input, timeout=timeout)\n    else:\n        if timeout:\n            raise NotImplementedError(\"Timeout is only available on Python 3\")\n        out, err = proc.communicate(input=input)\n    return CompletedProcess(command, proc.returncode, out, err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_in_pool(target, iterable, threaded=True, processes=4,\n                asynchronous=False, target_kwargs=None):\n    \"\"\" Run a set of iterables to a function in a Threaded or MP Pool.\n\n    .. code: python\n\n        def func(a):\n            return a + a\n\n        reusables.run_in_pool(func, [1,2,3,4,5])\n        # [1, 4, 9, 16, 25]\n\n\n    :param target: function to run\n    :param iterable: positional arg to pass to function\n    :param threaded: Threaded if True multiprocessed if False\n    :param processes: Number of workers\n    :param asynchronous: will do map_async if True\n    :param target_kwargs: Keyword arguments to set on the function as a partial\n    :return: pool results\n    \"\"\"\n    my_pool = pool.ThreadPool if threaded else pool.Pool\n\n    if target_kwargs:\n        target = partial(target, **target_kwargs if target_kwargs else None)\n\n    p = my_pool(processes)\n    try:\n        results = (p.map_async(target, iterable) if asynchronous\n                   else p.map(target, iterable))\n    finally:\n        p.close()\n        p.join()\n    return results", "response": "Run a set of iterables to a function in a Threaded or MP Pool."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tree_view(dictionary, level=0, sep=\"|  \"):\n    return \"\".join([\"{0}{1}\\n{2}\".format(sep * level, k,\n                   tree_view(v, level + 1, sep=sep) if isinstance(v, dict)\n                   else \"\") for k, v in dictionary.items()])", "response": "View a dictionary as a tree."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nturn the Namespace and sub Namespaces back into a native python dictionary.", "response": "def to_dict(self, in_dict=None):\n        \"\"\"\n        Turn the Namespace and sub Namespaces back into a native\n        python dictionary.\n\n        :param in_dict: Do not use, for self recursion\n        :return: python dictionary of this Namespace\n        \"\"\"\n        in_dict = in_dict if in_dict else self\n        out_dict = dict()\n        for k, v in in_dict.items():\n            if isinstance(v, Namespace):\n                v = v.to_dict()\n            out_dict[k] = v\n        return out_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning value of key as a list", "response": "def list(self, item, default=None, spliter=\",\", strip=True, mod=None):\n        \"\"\" Return value of key as a list\n\n        :param item: key of value to transform\n        :param mod: function to map against list\n        :param default: value to return if item does not exist\n        :param spliter: character to split str on\n        :param strip: clean the list with the `strip`\n        :return: list of items\n        \"\"\"\n        try:\n            item = self.__getattr__(item)\n        except AttributeError as err:\n            if default is not None:\n                return default\n            raise err\n        if strip:\n            item = item.lstrip(\"[\").rstrip(\"]\")\n        out = [x.strip() if strip else x for x in item.split(spliter)]\n        if mod:\n            return list(map(mod, out))\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading a given URL to either file or memory.", "response": "def download(url, save_to_file=True, save_dir=\".\", filename=None,\n             block_size=64000, overwrite=False, quiet=False):\n    \"\"\"\n    Download a given URL to either file or memory\n\n    :param url: Full url (with protocol) of path to download\n    :param save_to_file: boolean if it should be saved to file or not\n    :param save_dir: location of saved file, default is current working dir\n    :param filename: filename to save as\n    :param block_size: download chunk size\n    :param overwrite: overwrite file if it already exists\n    :param quiet: boolean to turn off logging for function\n    :return: save location (or content if not saved to file)\n    \"\"\"\n\n    if save_to_file:\n        if not filename:\n            filename = safe_filename(url.split('/')[-1])\n            if not filename:\n                filename = \"downloaded_at_{}.file\".format(time.time())\n        save_location = os.path.abspath(os.path.join(save_dir, filename))\n        if os.path.exists(save_location) and not overwrite:\n            logger.error(\"File {0} already exists\".format(save_location))\n            return False\n    else:\n        save_location = \"memory\"\n\n    try:\n        request = urlopen(url)\n    except ValueError as err:\n        if not quiet and \"unknown url type\" in str(err):\n            logger.error(\"Please make sure URL is formatted correctly and\"\n                         \" starts with http:// or other protocol\")\n        raise err\n    except Exception as err:\n        if not quiet:\n            logger.error(\"Could not download {0} - {1}\".format(url, err))\n        raise err\n\n    try:\n        kb_size = int(request.headers[\"Content-Length\"]) / 1024\n    except Exception as err:\n        if not quiet:\n            logger.debug(\"Could not determine file size - {0}\".format(err))\n        file_size = \"(unknown size)\"\n    else:\n        file_size = \"({0:.1f} {1})\".format(*(kb_size, \"KB\") if kb_size < 9999\n                                           else (kb_size / 1024, \"MB\"))\n\n    if not quiet:\n        logger.info(\"Downloading {0} {1} to {2}\".format(url, file_size,\n                                                         save_location))\n\n    if save_to_file:\n        with open(save_location, \"wb\") as f:\n            while True:\n                buffer = request.read(block_size)\n                if not buffer:\n                    break\n                f.write(buffer)\n        return save_location\n    else:\n        return request.read()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of IP addresses for a given URL.", "response": "def url_to_ips(url, port=None, ipv6=False, connect_type=socket.SOCK_STREAM,\n               proto=socket.IPPROTO_TCP, flags=0):\n    \"\"\"\n    Provide a list of IP addresses, uses `socket.getaddrinfo`\n\n    .. code:: python\n\n        reusables.url_to_ips(\"example.com\", ipv6=True)\n        # ['2606:2800:220:1:248:1893:25c8:1946']\n\n    :param url: hostname to resolve to IP addresses\n    :param port: port to send to getaddrinfo\n    :param ipv6: Return IPv6 address if True, otherwise IPv4\n    :param connect_type: defaults to STREAM connection, can be 0 for all\n    :param proto: defaults to TCP, can be 0 for all\n    :param flags: additional flags to pass\n    :return: list of resolved IPs\n    \"\"\"\n    try:\n        results = socket.getaddrinfo(url, port,\n                                     (socket.AF_INET if not ipv6\n                                      else socket.AF_INET6),\n                                     connect_type,\n                                     proto,\n                                     flags)\n    except socket.gaierror:\n        logger.exception(\"Could not resolve hostname\")\n        return []\n\n    return list(set([result[-1][0] for result in results]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves a hostname based off an IP address.", "response": "def ip_to_url(ip_addr):\n    \"\"\"\n    Resolve a hostname based off an IP address.\n\n    This is very limited and will\n    probably not return any results if it is a shared IP address or an\n    address with improperly setup DNS records.\n\n    .. code:: python\n\n        reusables.ip_to_url('93.184.216.34') # example.com\n        # None\n\n        reusables.ip_to_url('8.8.8.8')\n        # 'google-public-dns-a.google.com'\n\n\n    :param ip_addr: IP address to resolve to hostname\n    :return: string of hostname or None\n    \"\"\"\n    try:\n        return socket.gethostbyaddr(ip_addr)[0]\n    except (socket.gaierror, socket.herror):\n        logger.exception(\"Could not resolve hostname\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a background thread for httpd and serve forever", "response": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stream_handler(stream=sys.stderr, level=logging.INFO,\n                       log_format=log_formats.easy_read):\n    \"\"\"\n    Returns a set up stream handler to add to a logger.\n\n    :param stream: which stream to use, defaults to sys.stderr\n    :param level: logging level to set handler at\n    :param log_format: formatter to use\n    :return: stream handler\n    \"\"\"\n    sh = logging.StreamHandler(stream)\n    sh.setLevel(level)\n    sh.setFormatter(logging.Formatter(log_format))\n    return sh", "response": "Returns a set up stream handler to add to a logger."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_file_handler(file_path=\"out.log\", level=logging.INFO,\n                     log_format=log_formats.easy_read,\n                     handler=logging.FileHandler,\n                     **handler_kwargs):\n    \"\"\"\n    Set up a file handler to add to a logger.\n\n    :param file_path: file to write the log to, defaults to out.log\n    :param level: logging level to set handler at\n    :param log_format: formatter to use\n    :param handler: logging handler to use, defaults to FileHandler\n    :param handler_kwargs: options to pass to the handler\n    :return: handler\n    \"\"\"\n    fh = handler(file_path, **handler_kwargs)\n    fh.setLevel(level)\n    fh.setFormatter(logging.Formatter(log_format))\n    return fh", "response": "Create a file handler for the next available log file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset up a logger for the specified module.", "response": "def setup_logger(module_name=None, level=logging.INFO, stream=sys.stderr,\n                 file_path=None, log_format=log_formats.easy_read,\n                 suppress_warning=True):\n    \"\"\"\n    Grabs the specified logger and adds wanted handlers to it. Will\n    default to adding a stream handler.\n\n    :param module_name: logger name to use\n    :param level: logging level to set logger at\n    :param stream: stream to log to, or None\n    :param file_path: file path to log to, or None\n    :param log_format: format to set the handlers to use\n    :param suppress_warning: add a NullHandler if no other handler is specified\n    :return: configured logger\n    \"\"\"\n    new_logger = logging.getLogger(module_name)\n\n    if stream:\n        new_logger.addHandler(get_stream_handler(stream, level, log_format))\n    elif not file_path and suppress_warning and not new_logger.handlers:\n            new_logger.addHandler(logging.NullHandler())\n\n    if file_path:\n        new_logger.addHandler(get_file_handler(file_path, level, log_format))\n    if level > 0:\n        new_logger.setLevel(level)\n    return new_logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new stream handler to the specified logger", "response": "def add_stream_handler(logger=None, stream=sys.stderr, level=logging.INFO,\n                       log_format=log_formats.easy_read):\n    \"\"\"\n    Addes a newly created stream handler to the specified logger\n\n    :param logger: logging name or object to modify, defaults to root logger\n    :param stream: which stream to use, defaults to sys.stderr\n    :param level: logging level to set handler at\n    :param log_format: formatter to use\n    \"\"\"\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    logger.addHandler(get_stream_handler(stream, level, log_format))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new file handler to the specified logger", "response": "def add_file_handler(logger=None, file_path=\"out.log\", level=logging.INFO,\n                     log_format=log_formats.easy_read):\n    \"\"\"\n    Addes a newly created file handler to the specified logger\n\n    :param logger: logging name or object to modify, defaults to root logger\n    :param file_path: path to file to log to\n    :param level: logging level to set handler at\n    :param log_format: formatter to use\n    \"\"\"\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    logger.addHandler(get_file_handler(file_path, level, log_format))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_rotating_file_handler(logger=None, file_path=\"out.log\",\n                              level=logging.INFO,\n                              log_format=log_formats.easy_read,\n                              max_bytes=10*sizes.mb, backup_count=5,\n                              **handler_kwargs):\n    \"\"\" Adds a rotating file handler to the specified logger.\n\n    :param logger: logging name or object to modify, defaults to root logger\n    :param file_path: path to file to log to\n    :param level: logging level to set handler at\n    :param log_format: log formatter\n    :param max_bytes: Max file size in bytes before rotating\n    :param backup_count: Number of backup files\n    :param handler_kwargs: options to pass to the handler\n    \"\"\"\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    logger.addHandler(get_file_handler(file_path, level, log_format,\n                                       handler=RotatingFileHandler,\n                                       maxBytes=max_bytes,\n                                       backupCount=backup_count,\n                                       **handler_kwargs))", "response": "Adds a rotating file handler to the specified logger."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a timed rotating file handler to the specified logger.", "response": "def add_timed_rotating_file_handler(logger=None, file_path=\"out.log\",\n                                    level=logging.INFO,\n                                    log_format=log_formats.easy_read,\n                                    when='w0', interval=1, backup_count=5,\n                                    **handler_kwargs):\n    \"\"\" Adds a timed rotating file handler to the specified logger.\n    Defaults to weekly rotation, with 5 backups.\n\n    :param logger: logging name or object to modify, defaults to root logger\n    :param file_path: path to file to log to\n    :param level: logging level to set handler at\n    :param log_format: log formatter\n    :param when:\n    :param interval:\n    :param backup_count: Number of backup files\n    :param handler_kwargs: options to pass to the handler\n    \"\"\"\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    logger.addHandler(get_file_handler(file_path, level, log_format,\n                                       handler=TimedRotatingFileHandler,\n                                       when=when,\n                                       interval=interval,\n                                       backupCount=backup_count,\n                                       **handler_kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves only stream handlers from the specified logger", "response": "def remove_stream_handlers(logger=None):\n    \"\"\"\n    Remove only stream handlers from the specified logger\n\n    :param logger: logging name or object to modify, defaults to root logger\n    \"\"\"\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    new_handlers = []\n    for handler in logger.handlers:\n        # FileHandler is a subclass of StreamHandler so\n        # 'if not a StreamHandler' does not work\n        if (isinstance(handler, logging.FileHandler) or\n            isinstance(handler, logging.NullHandler) or\n            (isinstance(handler, logging.Handler) and not\n                isinstance(handler, logging.StreamHandler))):\n            new_handlers.append(handler)\n    logger.handlers = new_handlers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_file_handlers(logger=None):\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    new_handlers = []\n    for handler in logger.handlers:\n        if isinstance(handler, logging.FileHandler):\n            handler.close()\n        else:\n            new_handlers.append(handler)\n    logger.handlers = new_handlers", "response": "Removes only file handlers from the specified logger."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_all_handlers(logger=None):\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    remove_file_handlers(logger)\n    logger.handlers = []", "response": "Safely remove all handlers from the logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchanges the levels of the logger and all handlers to the specified level.", "response": "def change_logger_levels(logger=None, level=logging.DEBUG):\n    \"\"\"\n    Go through the logger and handlers and update their levels to the\n    one specified.\n\n    :param logger: logging name or object to modify, defaults to root logger\n    :param level: logging level to set at (10=Debug, 20=Info, 30=Warn, 40=Error)\n    \"\"\"\n    if not isinstance(logger, logging.Logger):\n        logger = logging.getLogger(logger)\n\n    logger.setLevel(level)\n    for handler in logger.handlers:\n        handler.level = level"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the names of all loggers currently registered in the hierarchy.", "response": "def get_registered_loggers(hide_children=False, hide_reusables=False):\n    \"\"\"\n    Find the names of all loggers currently registered\n\n    :param hide_children: only return top level logger names\n    :param hide_reusables: hide the reusables loggers\n    :return: list of logger names\n    \"\"\"\n\n    return [logger for logger in logging.Logger.manager.loggerDict.keys()\n            if not (hide_reusables and \"reusables\" in logger)\n            and not (hide_children and \".\" in logger)]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping to make sure a function is only run once at a time.", "response": "def lock_it(lock=g_lock):\n    \"\"\"\n    Wrapper. Simple wrapper to make sure a function is only run once at a time.\n\n    .. code: python\n\n        import reusables\n        import time\n\n        def func_one(_):\n            time.sleep(5)\n\n        @reusables.lock_it()\n        def func_two(_):\n            time.sleep(5)\n\n        @reusables.time_it(message=\"test_1 took {0:.2f} seconds\")\n        def test_1():\n            reusables.run_in_pool(func_one, (1, 2, 3), threaded=True)\n\n        @reusables.time_it(message=\"test_2 took {0:.2f} seconds\")\n        def test_2():\n            reusables.run_in_pool(func_two, (1, 2, 3), threaded=True)\n\n        test_1()\n        test_2()\n\n        # test_1 took 5.04 seconds\n        # test_2 took 15.07 seconds\n\n\n    :param lock: Which lock to use, uses unique default\n    \"\"\"\n    def func_wrapper(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            with lock:\n                return func(*args, **kwargs)\n        return wrapper\n    return func_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef time_it(log=None, message=None, append=None):\n    def func_wrapper(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            # Can't use nonlocal in 2.x\n            msg = (message if message else\n                   \"Function '{func}' took a total of {seconds} seconds\")\n            if not message:\n                msg = _add_args(msg, *args, **kwargs)\n\n            time_func = (time.perf_counter if python_version >= (3, 3)\n                         else time.time)\n            start_time = time_func()\n            try:\n                return func(*args, **kwargs)\n            finally:\n                total_time = time_func() - start_time\n\n                time_string = msg.format(func=func.__name__,\n                                         seconds=total_time,\n                                         args=args, kwargs=kwargs)\n                if log:\n                    my_logger = logging.getLogger(log) if isinstance(log, str)\\\n                                else logger\n                    my_logger.info(time_string)\n                else:\n                    print(time_string)\n                if isinstance(append, list):\n                    append.append(total_time)\n        return wrapper\n    return func_wrapper", "response": "Time the amount of time it takes the execution of the function\n ArcGIS and print it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping for reusables. queue_it.", "response": "def queue_it(queue=g_queue, **put_args):\n    \"\"\"\n    Wrapper. Instead of returning the result of the function, add it to a queue.\n\n    .. code: python\n\n        import reusables\n        import queue\n\n        my_queue = queue.Queue()\n\n        @reusables.queue_it(my_queue)\n        def func(a):\n            return a\n\n        func(10)\n\n        print(my_queue.get())\n        # 10\n\n\n    :param queue: Queue to add result into\n    \"\"\"\n    def func_wrapper(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            queue.put(func(*args, **kwargs), **put_args)\n        return wrapper\n    return func_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncatches exceptions and returns the specified default or sent to a handler function instead.", "response": "def catch_it(exceptions=(Exception, ), default=None, handler=None):\n    \"\"\"\n    If the function encounters an exception, catch it, and\n    return the specified default or sent to a handler function instead.\n\n    .. code :: python\n\n        def handle_error(exception, func, *args, **kwargs):\n            print(f\"{func.__name__} raised {exception} when called with {args}\")\n\n        @reusables.catch_it(handler=err_func)\n        def will_raise(message=\"Hello\")\n            raise Exception(message)\n\n\n    :param exceptions: tuple of exceptions to catch\n    :param default: what to return if the exception is caught\n    :param handler: function to send exception, func, *args and **kwargs\n    \"\"\"\n    def func_wrapper(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exceptions as err:\n                if handler:\n                    return handler(err, func, *args, **kwargs)\n                return default\n        return wrapper\n    return func_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrying a function if an exception is raised or if output_check returns False.", "response": "def retry_it(exceptions=(Exception, ), tries=10, wait=0, handler=None,\n             raised_exception=ReusablesError, raised_message=None):\n    \"\"\"\n    Retry a function if an exception is raised, or if output_check returns\n    False.\n\n    Message format options: {func} {args} {kwargs}\n\n    :param exceptions: tuple of exceptions to catch\n    :param tries: number of tries to retry the function\n    :param wait: time to wait between executions in seconds\n    :param handler: function to check if output is valid, must return bool \n    :param raised_exception: default is ReusablesError\n    :param raised_message: message to pass to raised exception\n    \"\"\"\n    def func_wrapper(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            msg = (raised_message if raised_message\n                   else \"Max retries exceeded for function '{func}'\")\n            if not raised_message:\n                msg = _add_args(msg, *args, **kwargs)\n            try:\n                result = func(*args, **kwargs)\n            except exceptions:\n                if tries:\n                    if wait:\n                        time.sleep(wait)\n                    return retry_it(exceptions=exceptions, tries=tries-1,\n                                    handler=handler,\n                                    wait=wait)(func)(*args, **kwargs)\n                if raised_exception:\n                    exc = raised_exception(msg.format(func=func.__name__,\n                                           args=args, kwargs=kwargs))\n                    exc.__cause__ = None\n                    raise exc\n            else:\n                if handler:\n                    if not handler(result):\n                        return retry_it(exceptions=exceptions, tries=tries - 1,\n                                        handler=handler,\n                                        wait=wait)(func)(*args, **kwargs)\n                return result\n        return wrapper\n    return func_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract(archive_file, path=\".\", delete_on_success=False,\n            enable_rar=False):\n    \"\"\"\n    Automatically detect archive type and extract all files to specified path.\n\n    .. code:: python\n\n        import os\n\n        os.listdir(\".\")\n        # ['test_structure.zip']\n\n        reusables.extract(\"test_structure.zip\")\n\n        os.listdir(\".\")\n        # [ 'test_structure', 'test_structure.zip']\n\n\n    :param archive_file: path to file to extract\n    :param path: location to extract to\n    :param delete_on_success: Will delete the original archive if set to True\n    :param enable_rar: include the rarfile import and extract\n    :return: path to extracted files\n    \"\"\"\n\n    if not os.path.exists(archive_file) or not os.path.getsize(archive_file):\n        logger.error(\"File {0} unextractable\".format(archive_file))\n        raise OSError(\"File does not exist or has zero size\")\n\n    arch = None\n    if zipfile.is_zipfile(archive_file):\n        logger.debug(\"File {0} detected as a zip file\".format(archive_file))\n        arch = zipfile.ZipFile(archive_file)\n    elif tarfile.is_tarfile(archive_file):\n        logger.debug(\"File {0} detected as a tar file\".format(archive_file))\n        arch = tarfile.open(archive_file)\n    elif enable_rar:\n        import rarfile\n        if rarfile.is_rarfile(archive_file):\n            logger.debug(\"File {0} detected as \"\n                         \"a rar file\".format(archive_file))\n            arch = rarfile.RarFile(archive_file)\n\n    if not arch:\n        raise TypeError(\"File is not a known archive\")\n\n    logger.debug(\"Extracting files to {0}\".format(path))\n\n    try:\n        arch.extractall(path=path)\n    finally:\n        arch.close()\n\n    if delete_on_success:\n        logger.debug(\"Archive {0} will now be deleted\".format(archive_file))\n        os.unlink(archive_file)\n\n    return os.path.abspath(path)", "response": "Extract the contents of the archive file to specified path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\narchiving a list of files or folders in a single archive.", "response": "def archive(files_to_archive, name=\"archive.zip\", archive_type=None,\n            overwrite=False, store=False, depth=None, err_non_exist=True,\n            allow_zip_64=True, **tarfile_kwargs):\n    \"\"\" Archive a list of files (or files inside a folder), can chose between\n\n        - zip\n        - tar\n        - gz (tar.gz, tgz)\n        - bz2 (tar.bz2)\n\n    .. code:: python\n\n        reusables.archive(['reusables', '.travis.yml'],\n                              name=\"my_archive.bz2\")\n        # 'C:\\\\Users\\\\Me\\\\Reusables\\\\my_archive.bz2'\n\n    :param files_to_archive: list of files and folders to archive\n    :param name: path and name of archive file\n    :param archive_type: auto-detects unless specified\n    :param overwrite: overwrite if archive exists\n    :param store: zipfile only, True will not compress files\n    :param depth: specify max depth for folders\n    :param err_non_exist: raise error if provided file does not exist\n    :param allow_zip_64: must be enabled for zip files larger than 2GB\n    :param tarfile_kwargs: extra args to pass to tarfile.open\n    :return: path to created archive\n    \"\"\"\n    if not isinstance(files_to_archive, (list, tuple)):\n        files_to_archive = [files_to_archive]\n\n    if not archive_type:\n        if name.lower().endswith(\"zip\"):\n            archive_type = \"zip\"\n        elif name.lower().endswith(\"gz\"):\n            archive_type = \"gz\"\n        elif name.lower().endswith(\"z2\"):\n            archive_type = \"bz2\"\n        elif name.lower().endswith(\"tar\"):\n            archive_type = \"tar\"\n        else:\n            err_msg = (\"Could not determine archive \"\n                       \"type based off {0}\".format(name))\n            logger.error(err_msg)\n            raise ValueError(err_msg)\n        logger.debug(\"{0} file detected for {1}\".format(archive_type, name))\n    elif archive_type not in (\"tar\", \"gz\", \"bz2\", \"zip\"):\n        err_msg = (\"archive_type must be zip, gz, bz2,\"\n                   \" or gz, was {0}\".format(archive_type))\n        logger.error(err_msg)\n        raise ValueError(err_msg)\n\n    if not overwrite and os.path.exists(name):\n        err_msg = \"File {0} exists and overwrite not specified\".format(name)\n        logger.error(err_msg)\n        raise OSError(err_msg)\n\n    if archive_type == \"zip\":\n        arch = zipfile.ZipFile(name, 'w',\n                               zipfile.ZIP_STORED if store else\n                               zipfile.ZIP_DEFLATED,\n                               allowZip64=allow_zip_64)\n        write = arch.write\n    elif archive_type in (\"tar\", \"gz\", \"bz2\"):\n        mode = archive_type if archive_type != \"tar\" else \"\"\n        arch = tarfile.open(name, 'w:{0}'.format(mode), **tarfile_kwargs)\n        write = arch.add\n    else:\n        raise ValueError(\"archive_type must be zip, gz, bz2, or gz\")\n\n    try:\n        for file_path in files_to_archive:\n            if os.path.isfile(file_path):\n                if err_non_exist and not os.path.exists(file_path):\n                    raise OSError(\"File {0} does not exist\".format(file_path))\n                write(file_path)\n            elif os.path.isdir(file_path):\n                for nf in find_files(file_path, abspath=False, depth=depth):\n                    write(nf)\n    except (Exception, KeyboardInterrupt) as err:\n        logger.exception(\"Could not archive {0}\".format(files_to_archive))\n        try:\n            arch.close()\n        finally:\n            os.unlink(name)\n        raise err\n    else:\n        arch.close()\n\n    return os.path.abspath(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_to_csv(my_list, csv_file):\n    if PY3:\n        csv_handler = open(csv_file, 'w', newline='')\n    else:\n        csv_handler = open(csv_file, 'wb')\n\n    try:\n        writer = csv.writer(csv_handler, delimiter=',', quoting=csv.QUOTE_ALL)\n        writer.writerows(my_list)\n    finally:\n        csv_handler.close()", "response": "Save a list of lists to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening and transform a CSV file into a list of lists.", "response": "def csv_to_list(csv_file):\n    \"\"\"\n    Open and transform a CSV file into a matrix (list of lists).\n\n    .. code:: python\n\n        reusables.csv_to_list(\"example.csv\")\n        # [['Name', 'Location'],\n        #  ['Chris', 'South Pole'],\n        #  ['Harry', 'Depth of Winter'],\n        #  ['Bob', 'Skull']]\n\n    :param csv_file: Path to CSV file as str\n    :return: list\n    \"\"\"\n    with open(csv_file, 'r' if PY3 else 'rb') as f:\n        return list(csv.reader(f))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_json(json_file, **kwargs):\n    with open(json_file) as f:\n        return json.load(f, **kwargs)", "response": "Open and load data from a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave a dictionary to a JSON file.", "response": "def save_json(data, json_file, indent=4, **kwargs):\n    \"\"\"\n    Takes a dictionary and saves it to a file as JSON\n\n    .. code:: python\n\n        my_dict = {\"key_1\": \"val_1\",\n                   \"key_for_dict\": {\"sub_dict_key\": 8}}\n\n        reusables.save_json(my_dict,\"example.json\")\n\n    example.json\n\n    .. code::\n\n        {\n            \"key_1\": \"val_1\",\n            \"key_for_dict\": {\n                \"sub_dict_key\": 8\n            }\n        }\n\n    :param data: dictionary to save as JSON\n    :param json_file: Path to save file location as str\n    :param indent: Format the JSON file with so many numbers of spaces\n    :param kwargs: Additional arguments for the json.dump command\n    \"\"\"\n    with open(json_file, \"w\") as f:\n        json.dump(data, f, indent=indent, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef config_dict(config_file=None, auto_find=False, verify=True, **cfg_options):\n    if not config_file:\n        config_file = []\n\n    cfg_parser = ConfigParser.ConfigParser(**cfg_options)\n    cfg_files = []\n\n    if config_file:\n        if not isinstance(config_file, (list, tuple)):\n            if isinstance(config_file, str):\n                cfg_files.append(config_file)\n            else:\n                raise TypeError(\"config_files must be a list or a string\")\n        else:\n            cfg_files.extend(config_file)\n\n    if auto_find:\n        cfg_files.extend(find_files_list(\n            current_root if isinstance(auto_find, bool) else auto_find,\n            ext=(\".cfg\", \".config\", \".ini\")))\n\n    logger.info(\"config files to be used: {0}\".format(cfg_files))\n\n    if verify:\n        cfg_parser.read([cfg for cfg in cfg_files if os.path.exists(cfg)])\n    else:\n        cfg_parser.read(cfg_files)\n\n    return dict((section, dict(cfg_parser.items(section)))\n                for section in cfg_parser.sections())", "response": "Return configuration options as dictionary. Accepts either a single config file or a list of files."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the configuration options as a Namespace.", "response": "def config_namespace(config_file=None, auto_find=False,\n                     verify=True, **cfg_options):\n    \"\"\"\n    Return configuration options as a Namespace.\n\n    .. code:: python\n\n        reusables.config_namespace(os.path.join(\"test\", \"data\",\n                                                \"test_config.ini\"))\n        # <Namespace: {'General': {'example': 'A regul...>\n\n\n    :param config_file: path or paths to the files location\n    :param auto_find: look for a config type file at this location or below\n    :param verify: make sure the file exists before trying to read\n    :param cfg_options: options to pass to the parser\n    :return: Namespace of the config files\n    \"\"\"\n    return ConfigNamespace(**config_dict(config_file, auto_find,\n                                         verify, **cfg_options))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _walk(directory, enable_scandir=False, **kwargs):\n    walk = os.walk\n    if python_version < (3, 5) and enable_scandir:\n        import scandir\n        walk = scandir.walk\n    return walk(directory, **kwargs)", "response": "Internal function to return a walk generator from os. walk\n    on Python < 3. 5"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef os_tree(directory, enable_scandir=False):\n    if not os.path.exists(directory):\n        raise OSError(\"Directory does not exist\")\n    if not os.path.isdir(directory):\n        raise OSError(\"Path is not a directory\")\n\n    full_list = []\n    for root, dirs, files in _walk(directory, enable_scandir=enable_scandir):\n        full_list.extend([os.path.join(root, d).lstrip(directory) + os.sep\n                          for d in dirs])\n    tree = {os.path.basename(directory): {}}\n    for item in full_list:\n        separated = item.split(os.sep)\n        is_dir = separated[-1:] == ['']\n        if is_dir:\n            separated = separated[:-1]\n        parent = tree[os.path.basename(directory)]\n        for index, path in enumerate(separated):\n            if path in parent:\n                parent = parent[path]\n                continue\n            else:\n                parent[path] = dict()\n            parent = parent[path]\n    return tree", "response": "Returns a dictionary of the contents of a directory as a dictionary hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhash a given file with md5 or any other and return the hex digest.", "response": "def file_hash(path, hash_type=\"md5\", block_size=65536, hex_digest=True):\n    \"\"\"\n    Hash a given file with md5, or any other and return the hex digest. You\n    can run `hashlib.algorithms_available` to see which are available on your\n    system unless you have an archaic python version, you poor soul).\n\n    This function is designed to be non memory intensive.\n\n    .. code:: python\n\n        reusables.file_hash(test_structure.zip\")\n        # '61e387de305201a2c915a4f4277d6663'\n\n    :param path: location of the file to hash\n    :param hash_type: string name of the hash to use\n    :param block_size: amount of bytes to add to hasher at a time\n    :param hex_digest: returned as hexdigest, false will return digest\n    :return: file's hash\n    \"\"\"\n    hashed = hashlib.new(hash_type)\n    with open(path, \"rb\") as infile:\n        buf = infile.read(block_size)\n        while len(buf) > 0:\n            hashed.update(buf)\n            buf = infile.read(block_size)\n    return hashed.hexdigest() if hex_digest else hashed.digest()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds all files in a directory and return an iterator of all files that match the requirements.", "response": "def find_files(directory=\".\", ext=None, name=None,\n               match_case=False, disable_glob=False, depth=None,\n               abspath=False, enable_scandir=False):\n    \"\"\"\n    Walk through a file directory and return an iterator of files\n    that match requirements. Will autodetect if name has glob as magic\n    characters.\n\n    Note: For the example below, you can use find_files_list to return as a\n    list, this is simply an easy way to show the output.\n\n    .. code:: python\n\n        list(reusables.find_files(name=\"ex\", match_case=True))\n        # ['C:\\\\example.pdf',\n        #  'C:\\\\My_exam_score.txt']\n\n        list(reusables.find_files(name=\"*free*\"))\n        # ['C:\\\\my_stuff\\\\Freedom_fight.pdf']\n\n        list(reusables.find_files(ext=\".pdf\"))\n        # ['C:\\\\Example.pdf',\n        #  'C:\\\\how_to_program.pdf',\n        #  'C:\\\\Hunks_and_Chicks.pdf']\n\n        list(reusables.find_files(name=\"*chris*\"))\n        # ['C:\\\\Christmas_card.docx',\n        #  'C:\\\\chris_stuff.zip']\n\n    :param directory: Top location to recursively search for matching files\n    :param ext: Extensions of the file you are looking for\n    :param name: Part of the file name\n    :param match_case: If name or ext has to be a direct match or not\n    :param disable_glob: Do not look for globable names or use glob magic check\n    :param depth: How many directories down to search\n    :param abspath: Return files with their absolute paths\n    :param enable_scandir: on python < 3.5 enable external scandir package\n    :return: generator of all files in the specified directory\n    \"\"\"\n    if ext or not name:\n        disable_glob = True\n    if not disable_glob:\n        disable_glob = not glob.has_magic(name)\n\n    if ext and isinstance(ext, str):\n        ext = [ext]\n    elif ext and not isinstance(ext, (list, tuple)):\n        raise TypeError(\"extension must be either one extension or a list\")\n    if abspath:\n        directory = os.path.abspath(directory)\n    starting_depth = directory.count(os.sep)\n\n    for root, dirs, files in _walk(directory, enable_scandir=enable_scandir):\n        if depth and root.count(os.sep) - starting_depth >= depth:\n            continue\n\n        if not disable_glob:\n            if match_case:\n                raise ValueError(\"Cannot use glob and match case, please \"\n                                 \"either disable glob or not set match_case\")\n            glob_generator = glob.iglob(os.path.join(root, name))\n            for item in glob_generator:\n                yield item\n            continue\n\n        for file_name in files:\n            if ext:\n                for end in ext:\n                    if file_name.lower().endswith(end.lower() if not\n                    match_case else end):\n                        break\n                else:\n                    continue\n            if name:\n                if match_case and name not in file_name:\n                    continue\n                elif name.lower() not in file_name.lower():\n                    continue\n            yield os.path.join(root, file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves all empty directories from a path.", "response": "def remove_empty_directories(root_directory, dry_run=False, ignore_errors=True,\n                             enable_scandir=False):\n    \"\"\"\n    Remove all empty folders from a path. Returns list of empty directories.\n\n    :param root_directory: base directory to start at\n    :param dry_run: just return a list of what would be removed\n    :param ignore_errors: Permissions are a pain, just ignore if you blocked\n    :param enable_scandir: on python < 3.5 enable external scandir package\n    :return: list of removed directories\n    \"\"\"\n    listdir = os.listdir\n    if python_version < (3, 5) and enable_scandir:\n        import scandir as _scandir\n\n        def listdir(directory):\n            return list(_scandir.scandir(directory))\n\n    directory_list = []\n    for root, directories, files in _walk(root_directory,\n                                          enable_scandir=enable_scandir,\n                                          topdown=False):\n        if (not directories and not files and os.path.exists(root) and\n                    root != root_directory and os.path.isdir(root)):\n            directory_list.append(root)\n            if not dry_run:\n                try:\n                    os.rmdir(root)\n                except OSError as err:\n                    if ignore_errors:\n                        logger.info(\"{0} could not be deleted\".format(root))\n                    else:\n                        raise err\n        elif directories and not files:\n            for directory in directories:\n                directory = join_paths(root, directory, strict=True)\n                if (os.path.exists(directory) and os.path.isdir(directory) and\n                        not listdir(directory)):\n                    directory_list.append(directory)\n                    if not dry_run:\n                        try:\n                            os.rmdir(directory)\n                        except OSError as err:\n                            if ignore_errors:\n                                logger.info(\"{0} could not be deleted\".format(\n                                    directory))\n                            else:\n                                raise err\n    return directory_list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving all empty files from a directory.", "response": "def remove_empty_files(root_directory, dry_run=False, ignore_errors=True,\n                       enable_scandir=False):\n    \"\"\"\n    Remove all empty files from a path. Returns list of the empty files removed.\n\n    :param root_directory: base directory to start at\n    :param dry_run: just return a list of what would be removed\n    :param ignore_errors: Permissions are a pain, just ignore if you blocked\n    :param enable_scandir: on python < 3.5 enable external scandir package\n    :return: list of removed files\n    \"\"\"\n    file_list = []\n    for root, directories, files in _walk(root_directory,\n                                          enable_scandir=enable_scandir):\n        for file_name in files:\n            file_path = join_paths(root, file_name, strict=True)\n            if os.path.isfile(file_path) and not os.path.getsize(file_path):\n                if file_hash(file_path) == variables.hashes.empty_file.md5:\n                    file_list.append(file_path)\n\n    file_list = sorted(set(file_list))\n\n    if not dry_run:\n        for afile in file_list:\n            try:\n                os.unlink(afile)\n            except OSError as err:\n                if ignore_errors:\n                    logger.info(\"File {0} could not be deleted\".format(afile))\n                else:\n                    raise err\n\n    return file_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dup_finder(file_path, directory=\".\", enable_scandir=False):\n    size = os.path.getsize(file_path)\n    if size == 0:\n        for empty_file in remove_empty_files(directory, dry_run=True):\n            yield empty_file\n    else:\n        with open(file_path, 'rb') as f:\n            first_twenty = f.read(20)\n        file_sha256 = file_hash(file_path, \"sha256\")\n\n        for root, directories, files in _walk(directory,\n                                              enable_scandir=enable_scandir):\n            for each_file in files:\n                test_file = os.path.join(root, each_file)\n                if os.path.getsize(test_file) == size:\n                    try:\n                        with open(test_file, 'rb') as f:\n                            test_first_twenty = f.read(20)\n                    except OSError:\n                        logger.warning(\"Could not open file to compare - \"\n                                       \"{0}\".format(test_file))\n                    else:\n                        if first_twenty == test_first_twenty:\n                            if file_hash(test_file, \"sha256\") == file_sha256:\n                                yield os.path.abspath(test_file)", "response": "A generator that returns the duplicate files of a file in a directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding all duplicates in a directory. Will return a list of duplicates in that list.", "response": "def directory_duplicates(directory, hash_type='md5', **kwargs):\n    \"\"\"\n    Find all duplicates in a directory. Will return a list, in that list\n    are lists of duplicate files.\n\n    .. code: python\n\n        dups = reusables.directory_duplicates('C:\\\\Users\\\\Me\\\\Pictures')\n\n        print(len(dups))\n        # 56\n        print(dups)\n        # [['C:\\\\Users\\\\Me\\\\Pictures\\\\IMG_20161127.jpg',\n        # 'C:\\\\Users\\\\Me\\\\Pictures\\\\Phone\\\\IMG_20161127.jpg'], ...\n\n\n    :param directory: Directory to search\n    :param hash_type: Type of hash to perform\n    :param kwargs: Arguments to pass to find_files to narrow file types\n    :return: list of lists of dups\"\"\"\n    size_map, hash_map = defaultdict(list), defaultdict(list)\n\n    for item in find_files(directory, **kwargs):\n        file_size = os.path.getsize(item)\n        size_map[file_size].append(item)\n\n    for possible_dups in (v for v in size_map.values() if len(v) > 1):\n        for each_item in possible_dups:\n            item_hash = file_hash(each_item, hash_type=hash_type)\n            hash_map[item_hash].append(each_item)\n\n    return [v for v in hash_map.values() if len(v) > 1]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef join_paths(*paths, **kwargs):\n    path = os.path.abspath(paths[0])\n\n    for next_path in paths[1:]:\n        path = os.path.join(path, next_path.lstrip(\"\\\\\").lstrip(\"/\").strip())\n    path.rstrip(os.sep)\n    return path if not kwargs.get('safe') else safe_path(path)", "response": "Join multiple paths together and return the absolute path of them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef join_here(*paths, **kwargs):\n    path = os.path.abspath(\".\")\n    for next_path in paths:\n        next_path = next_path.lstrip(\"\\\\\").lstrip(\"/\").strip() if not \\\n            kwargs.get('strict') else next_path\n        path = os.path.abspath(os.path.join(path, next_path))\n    return path if not kwargs.get('safe') else safe_path(path)", "response": "Join any path or paths as a sub directory of the current file s directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the filename is safe to use or not.", "response": "def check_filename(filename):\n    \"\"\"\n    Returns a boolean stating if the filename is safe to use or not. Note that\n    this does not test for \"legal\" names accepted, but a more restricted set of:\n    Letters, numbers, spaces, hyphens, underscores and periods.\n\n    :param filename: name of a file as a string\n    :return: boolean if it is a safe file name\n    \"\"\"\n    if not isinstance(filename, str):\n        raise TypeError(\"filename must be a string\")\n    if regex.path.linux.filename.search(filename):\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef safe_filename(filename, replacement=\"_\"):\n    if not isinstance(filename, str):\n        raise TypeError(\"filename must be a string\")\n    if regex.path.linux.filename.search(filename):\n        return filename\n    safe_name = \"\"\n    for char in filename:\n        safe_name += char if regex.path.linux.filename.search(char) \\\n            else replacement\n    return safe_name", "response": "Returns a string that is safe for a given filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a path that can be used as a safe version of the file.", "response": "def safe_path(path, replacement=\"_\"):\n    \"\"\"\n    Replace unsafe path characters with underscores. Do NOT use this\n    with existing paths that cannot be modified, this to to help generate\n    new, clean paths.\n\n    Supports windows and *nix systems.\n\n    :param path: path as a string\n    :param replacement: character to use in place of bad characters\n    :return: a safer path\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(\"path must be a string\")\n    if os.sep not in path:\n        return safe_filename(path, replacement=replacement)\n    filename = safe_filename(os.path.basename(path))\n    dirname = os.path.dirname(path)\n    safe_dirname = \"\"\n    regexp = regex.path.windows.safe if win_based else regex.path.linux.safe\n    if win_based and dirname.find(\":\\\\\") == 1 and dirname[0].isalpha():\n        safe_dirname = dirname[0:3]\n        dirname = dirname[3:]\n    if regexp.search(dirname) and check_filename(filename):\n        return path\n    else:\n        for char in dirname:\n            safe_dirname += char if regexp.search(char) else replacement\n    sanitized_path = os.path.normpath(\"{path}{sep}{filename}\".format(\n        path=safe_dirname,\n        sep=os.sep if not safe_dirname.endswith(os.sep) else \"\",\n        filename=filename))\n    if (not filename and\n            path.endswith(os.sep) and\n            not sanitized_path.endswith(os.sep)):\n        sanitized_path += os.sep\n    return sanitized_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef change_task_size(self, size):\n        self._pause.value = True\n        self.log.debug(\"About to change task size to {0}\".format(size))\n        try:\n            size = int(size)\n        except ValueError:\n            self.log.error(\"Cannot change task size, non integer size provided\")\n            return False\n        if size < 0:\n            self.log.error(\"Cannot change task size, less than 0 size provided\")\n            return False\n        self.max_tasks = size\n        if size < self.max_tasks:\n            diff = self.max_tasks - size\n            self.log.debug(\"Reducing size offset by {0}\".format(diff))\n            while True:\n                self._update_tasks()\n                if len(self.free_tasks) >= diff:\n                    for i in range(diff):\n                        task_id = self.free_tasks.pop(0)\n                        del self.current_tasks[task_id]\n                    break\n                time.sleep(0.5)\n            if not size:\n                self._reset_and_pause()\n                return True\n        elif size > self.max_tasks:\n            diff = size - self.max_tasks\n            for i in range(diff):\n                task_id = str(uuid.uuid4())\n                self.current_tasks[task_id] = {}\n                self.free_tasks.append(task_id)\n        self._pause.value = False\n        self.log.debug(\"Task size changed to {0}\".format(size))\n        return True", "response": "Blocking request to change the number of running tasks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop(self):\n        self._end.value = True\n        if self.background_process:\n            try:\n                self.background_process.terminate()\n            except Exception:\n                pass\n        for task_id, values in self.current_tasks.items():\n            try:\n                values['proc'].terminate()\n            except Exception:\n                pass", "response": "Hard stop the server and sub process"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_state(self):\n        return {\"started\": (True if self.background_process and\n                            self.background_process.is_alive() else False),\n                \"paused\": self._pause.value,\n                \"stopped\": self._end.value,\n                \"tasks\": len(self.current_tasks),\n                \"busy_tasks\": len(self.busy_tasks),\n                \"free_tasks\": len(self.free_tasks)}", "response": "Get the state of the class"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nblocks function that can be run directly and can be used to run a single process.", "response": "def main_loop(self, stop_at_empty=False):\n        \"\"\"Blocking function that can be run directly, if so would probably\n        want to specify 'stop_at_empty' to true, or have a separate process\n        adding items to the queue. \"\"\"\n        try:\n            while True:\n                self.hook_pre_command()\n                self._check_command_queue()\n                if self.run_until and self.run_until < datetime.datetime.now():\n                    self.log.info(\"Time limit reached\")\n                    break\n                if self._end.value:\n                    break\n                if self._pause.value:\n                    time.sleep(.5)\n                    continue\n                self.hook_post_command()\n                self._update_tasks()\n                task_id = self._free_task()\n                if task_id:\n                    try:\n                        task = self.task_queue.get(timeout=.1)\n                    except queue.Empty:\n                        if stop_at_empty:\n                            break\n                        self._return_task(task_id)\n                    else:\n                        self.hook_pre_task()\n                        self.log.debug(\"Starting task on {0}\".format(task_id))\n                        try:\n                            self._start_task(task_id, task)\n                        except Exception as err:\n                            self.log.exception(\"Could not start task {0} -\"\n                                               \" {1}\".format(task_id, err))\n                        else:\n                            self.hook_post_task()\n        finally:\n            self.log.info(\"Ending main loop\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the main loop as a background process.", "response": "def run(self):\n        \"\"\"Start the main loop as a background process. *nix only\"\"\"\n        if win_based:\n            raise NotImplementedError(\"Please run main_loop, \"\n                                      \"backgrounding not supported on Windows\")\n        self.background_process = mp.Process(target=self.main_loop)\n        self.background_process.start()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a shell command and have it automatically decoded and printed", "response": "def cmd(command, ignore_stderr=False, raise_on_return=False, timeout=None,\n        encoding=\"utf-8\"):\n    \"\"\" Run a shell command and have it automatically decoded and printed\n\n    :param command: Command to run as str\n    :param ignore_stderr: To not print stderr\n    :param raise_on_return: Run CompletedProcess.check_returncode()\n    :param timeout: timeout to pass to communicate if python 3\n    :param encoding: How the output should be decoded\n    \"\"\"\n    result = run(command, timeout=timeout, shell=True)\n    if raise_on_return:\n        result.check_returncode()\n    print(result.stdout.decode(encoding))\n    if not ignore_stderr and result.stderr:\n        print(result.stderr.decode(encoding))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pushd(directory):\n    directory = os.path.expanduser(directory)\n    _saved_paths.insert(0, os.path.abspath(os.getcwd()))\n    os.chdir(directory)\n    return [directory] + _saved_paths", "response": "Change working directories in style and stay organized!"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef popd():\n    try:\n        directory = _saved_paths.pop(0)\n    except IndexError:\n        return [os.getcwd()]\n    os.chdir(directory)\n    return [directory] + _saved_paths", "response": "Go back to where you once were."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ls(params=\"\", directory=\".\", printed=True):\n    command = \"{0} {1} {2}\".format(\"ls\" if not win_based else \"dir\",\n                                   params, directory)\n    response = run(command, shell=True)  # Shell required for windows\n    response.check_returncode()\n    if printed:\n        print(response.stdout.decode(\"utf-8\"))\n    else:\n        return response.stdout", "response": "This function is just a python implementation of ls. It s just to subprocess ls."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find(name=None, ext=None, directory=\".\", match_case=False,\n         disable_glob=False, depth=None):\n    \"\"\" Designed for the interactive interpreter by making default order\n    of find_files faster.\n\n    :param name: Part of the file name\n    :param ext: Extensions of the file you are looking for\n    :param directory: Top location to recursively search for matching files\n    :param match_case: If name has to be a direct match or not\n    :param disable_glob: Do not look for globable names or use glob magic check\n    :param depth: How many directories down to search\n    :return: list of all files in the specified directory\n    \"\"\"\n    return find_files_list(directory=directory, ext=ext, name=name,\n                           match_case=match_case, disable_glob=disable_glob,\n                           depth=depth)", "response": "This function is used to find all files in a directory or not in a file system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the first N lines of a file", "response": "def head(file_path, lines=10, encoding=\"utf-8\", printed=True,\n         errors='strict'):\n    \"\"\"\n    Read the first N lines of a file, defaults to 10\n\n    :param file_path: Path to file to read\n    :param lines: Number of lines to read in\n    :param encoding: defaults to utf-8 to decode as, will fail on binary\n    :param printed: Automatically print the lines instead of returning it\n    :param errors: Decoding errors: 'strict', 'ignore' or 'replace'\n    :return: if printed is false, the lines are returned as a list\n    \"\"\"\n    data = []\n    with open(file_path, \"rb\") as f:\n        for _ in range(lines):\n            try:\n                if python_version >= (2, 7):\n                    data.append(next(f).decode(encoding, errors=errors))\n                else:\n                    data.append(next(f).decode(encoding))\n            except StopIteration:\n                break\n    if printed:\n        print(\"\".join(data))\n    else:\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tail(file_path, lines=10, encoding=\"utf-8\",\n         printed=True, errors='strict'):\n    \"\"\"\n    A really silly way to get the last N lines, defaults to 10.\n\n\n    :param file_path: Path to file to read\n    :param lines: Number of lines to read in\n    :param encoding: defaults to utf-8 to decode as, will fail on binary\n    :param printed: Automatically print the lines instead of returning it\n    :param errors: Decoding errors: 'strict', 'ignore' or 'replace'\n    :return: if printed is false, the lines are returned as a list\n    \"\"\"\n    data = deque()\n\n    with open(file_path, \"rb\") as f:\n        for line in f:\n            if python_version >= (2, 7):\n                data.append(line.decode(encoding, errors=errors))\n            else:\n                data.append(line.decode(encoding))\n            if len(data) > lines:\n                data.popleft()\n    if printed:\n        print(\"\".join(data))\n    else:\n        return data", "response": "Returns the last N lines of a node in a node list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cp(src, dst, overwrite=False):\n\n    if not isinstance(src, list):\n        src = [src]\n\n    dst = os.path.expanduser(dst)\n    dst_folder = os.path.isdir(dst)\n\n    if len(src) > 1 and not dst_folder:\n        raise OSError(\"Cannot copy multiple item to same file\")\n\n    for item in src:\n        source = os.path.expanduser(item)\n        destination = (dst if not dst_folder else\n                       os.path.join(dst, os.path.basename(source)))\n        if not overwrite and os.path.exists(destination):\n            _logger.warning(\"Not replacing {0} with {1}, overwrite not enabled\"\n                            \"\".format(destination, source))\n            continue\n\n        shutil.copy(source, destination)", "response": "Copy files from one folder to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cut(string, characters=2, trailing=\"normal\"):\n    split_str = [string[i:i + characters] for\n                 i in range(0, len(string), characters)]\n\n    if trailing != \"normal\" and len(split_str[-1]) != characters:\n        if trailing.lower() == \"remove\":\n            return split_str[:-1]\n        if trailing.lower() == \"combine\" and len(split_str) >= 2:\n            return split_str[:-2] + [split_str[-2] + split_str[-1]]\n        if trailing.lower() == \"error\":\n            raise IndexError(\"String of length {0} not divisible by {1} to\"\n                             \" cut\".format(len(string), characters))\n    return split_str", "response": "Returns a list of N characters from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting an integer into a roman string.", "response": "def int_to_roman(integer):\n    \"\"\"\n    Convert an integer into a string of roman numbers.\n\n    .. code: python\n\n        reusables.int_to_roman(445)\n        # 'CDXLV'\n\n\n    :param integer:\n    :return: roman string\n    \"\"\"\n    if not isinstance(integer, int):\n        raise ValueError(\"Input integer must be of type int\")\n    output = []\n    while integer > 0:\n        for r, i in sorted(_roman_dict.items(),\n                           key=lambda x: x[1], reverse=True):\n            while integer >= i:\n                output.append(r)\n                integer -= i\n    return \"\".join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef roman_to_int(roman_string):\n    roman_string = roman_string.upper().strip()\n    if \"IIII\" in roman_string:\n        raise ValueError(\"Malformed roman string\")\n    value = 0\n    skip_one = False\n    last_number = None\n    for i, letter in enumerate(roman_string):\n        if letter not in _roman_dict:\n            raise ValueError(\"Malformed roman string\")\n        if skip_one:\n            skip_one = False\n            continue\n        if i < (len(roman_string) - 1):\n            double_check = letter + roman_string[i + 1]\n            if double_check in _roman_dict:\n                if last_number and _roman_dict[double_check] > last_number:\n                    raise ValueError(\"Malformed roman string\")\n                last_number = _roman_dict[double_check]\n                value += _roman_dict[double_check]\n                skip_one = True\n                continue\n        if last_number and _roman_dict[letter] > last_number:\n            raise ValueError(\"Malformed roman string\")\n        last_number = _roman_dict[letter]\n        value += _roman_dict[letter]\n    return value", "response": "Convert a string of roman numbers into an integer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef int_to_words(number, european=False):\n    def ones(n):\n        return \"\" if n == 0 else _numbers[n]\n\n    def tens(n):\n        teen = int(\"{0}{1}\".format(n[0], n[1]))\n\n        if n[0] == 0:\n            return ones(n[1])\n        if teen in _numbers:\n            return _numbers[teen]\n        else:\n            ten = _numbers[int(\"{0}0\".format(n[0]))]\n            one = _numbers[n[1]]\n            return \"{0}-{1}\".format(ten, one)\n\n    def hundreds(n):\n        if n[0] == 0:\n            return tens(n[1:])\n        else:\n            t = tens(n[1:])\n            return \"{0} hundred {1}\".format(_numbers[n[0]], \"\" if not t else t)\n\n    def comma_separated(list_of_strings):\n        if len(list_of_strings) > 1:\n            return \"{0} \".format(\"\" if len(list_of_strings) == 2\n                                 else \",\").join(list_of_strings)\n        else:\n            return list_of_strings[0]\n\n    def while_loop(list_of_numbers, final_list):\n        index = 0\n        group_set = int(len(list_of_numbers) / 3)\n        while group_set != 0:\n            value = hundreds(list_of_numbers[index:index + 3])\n            if value:\n                final_list.append(\"{0} {1}\".format(value, _places[group_set])\n                                  if _places[group_set] else value)\n            group_set -= 1\n            index += 3\n\n    number_list = []\n    decimal_list = []\n\n    decimal = ''\n    number = str(number)\n    group_delimiter, point_delimiter = (\",\", \".\") \\\n        if not european else (\".\", \",\")\n\n    if point_delimiter in number:\n        decimal = number.split(point_delimiter)[1]\n        number = number.split(point_delimiter)[0].replace(\n            group_delimiter, \"\")\n    elif group_delimiter in number:\n        number = number.replace(group_delimiter, \"\")\n\n    if not number.isdigit():\n        raise ValueError(\"Number is not numeric\")\n\n    if decimal and not decimal.isdigit():\n        raise ValueError(\"Decimal is not numeric\")\n\n    if int(number) == 0:\n        number_list.append(\"zero\")\n\n    r = len(number) % 3\n    d_r = len(decimal) % 3\n    number = number.zfill(len(number) + 3 - r if r else 0)\n    f_decimal = decimal.zfill(len(decimal) + 3 - d_r if d_r else 0)\n\n    d = [int(x) for x in f_decimal]\n    n = [int(x) for x in number]\n\n    while_loop(n, number_list)\n\n    if decimal and int(decimal) != 0:\n        while_loop(d, decimal_list)\n\n        if decimal_list:\n            name = ''\n            if len(decimal) % 3 == 1:\n                name = 'ten'\n            elif len(decimal) % 3 == 2:\n                name = 'hundred'\n\n            place = int((str(len(decimal) / 3).split(\".\")[0]))\n            number_list.append(\"and {0} {1}{2}{3}ths\".format(\n                comma_separated(decimal_list), name,\n                \"-\" if name and _places[place+1] else \"\", _places[place+1]))\n\n    return comma_separated(number_list)", "response": "Converts an integer or float to words."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_osm_file():\r\n\r\n    print_info('Filtering OSM file...')\r\n    start_time = time.time()\r\n\r\n    if check_osmfilter():\r\n        # params = '--keep=\"highway=motorway =motorway_link =trunk =trunk_link =primary =primary_link =secondary' \\\r\n        # \t\t ' =secondary_link =tertiary =tertiary_link =unclassified =unclassified_link =residential =residential_link' \\\r\n        # \t\t ' =living_street\" --drop=\"access=no\"'\r\n        params = config.osm_filter_params\r\n\r\n        command = './osmfilter' if platform.system() == 'Linux' else 'osmfilter.exe'\r\n\r\n        if platform.system() == 'Linux':\r\n            filter_command = '%s \"%s\" %s | pv > \"%s\"' % (command, config.osm_map_filename, params,\r\n                                                         config.filtered_osm_filename)\r\n        else:\r\n            filter_command = '%s \"%s\" %s > \"%s\"' % (\r\n            command, config.osm_map_filename, params, config.filtered_osm_filename)\r\n        os.system(filter_command)\r\n    else:\r\n        print_info('Osmfilter not available. Exiting.')\r\n        exit(1)\r\n\r\n    print_info('Filtering finished. (%.2f secs)' % (time.time() - start_time))", "response": "Download and compiles the OSM file and filter out the road elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef task_list():\n    try:\n        jobs_module = settings.RQ_JOBS_MODULE\n    except AttributeError:\n        raise ImproperlyConfigured(_(\"You have to define RQ_JOBS_MODULE in settings.py\"))\n\n    if isinstance(jobs_module, string_types):\n        jobs_modules = (jobs_module,)\n    elif isinstance(jobs_module, (tuple, list)):\n        jobs_modules = jobs_module\n    else:\n        raise ImproperlyConfigured(_(\"RQ_JOBS_MODULE must be a string or a tuple\"))\n\n    choices = []\n\n    for module in jobs_modules:\n        try:\n            tasks = importlib.import_module(module)\n        except ImportError:\n            raise ImproperlyConfigured(_(\"Can not find module {}\").format(module))\n\n        module_choices = [('%s.%s' % (module, x), underscore_to_camelcase(x)) for x, y in list(tasks.__dict__.items())\n                          if type(y) == FunctionType and hasattr(y, 'delay')]\n\n        choices.extend(module_choices)\n\n    choices.sort(key=lambda tup: tup[1])\n\n    return choices", "response": "Returns a list of all tasks that are available in the RQ_JOBS_MODULES"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rq_link(self):\n        if self.rq_job:\n            url = reverse('rq_job_detail',\n                          kwargs={'job_id': self.rq_id, 'queue_index': queue_index_by_name(self.rq_origin)})\n            return '<a href=\"{}\">{}</a>'.format(url, self.rq_id)", "response": "Link to Django - RQ status page for this job"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rq_task(self):\n        task_path = self.task.split('.')\n        module_name = '.'.join(task_path[:-1])\n        task_name = task_path[-1]\n\n        module = importlib.import_module(module_name)\n        return getattr(module, task_name)", "response": "Returns the class that is responsible for retrieving the current task s information."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes for tasks without a module. Provides backwards compatibility with < 0. 1. 5", "response": "def fix_module(job):\n    \"\"\"\n    Fix for tasks without a module. Provides backwards compatibility with < 0.1.5\n    \"\"\"\n    modules = settings.RQ_JOBS_MODULE\n    if not type(modules) == tuple:\n        modules = [modules]\n    for module in modules:\n        try:\n            module_match = importlib.import_module(module)\n            if hasattr(module_match, job.task):\n                job.task = '{}.{}'.format(module, job.task)\n                break\n        except ImportError:\n            continue\n    return job"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndrop tables for all given models.", "response": "async def drop_model_tables(models, **drop_table_kwargs):\n    \"\"\"Drop tables for all given models (in the right order).\"\"\"\n    for m in reversed(sort_models_topologically(models)):\n        await m.drop_table(**drop_table_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def model_to_dict(model, recurse=True, backrefs=False, only=None,\n                        exclude=None, seen=None, extra_attrs=None,\n                        fields_from_query=None, max_depth=None):\n    \"\"\"\n    Convert a model instance (and any related objects) to a dictionary.\n    :param bool recurse: Whether foreign-keys should be recursed.\n    :param bool backrefs: Whether lists of related objects should be recursed.\n    :param only: A list (or set) of field instances indicating which fields\n        should be included.\n    :param exclude: A list (or set) of field instances that should be\n        excluded from the dictionary.\n    :param list extra_attrs: Names of model instance attributes or methods\n        that should be included.\n    :param SelectQuery fields_from_query: Query that was source of model. Take\n        fields explicitly selected by the query and serialize them.\n    :param int max_depth: Maximum depth to recurse, value <= 0 means no max.\n    \"\"\"\n    max_depth = -1 if max_depth is None else max_depth\n    if max_depth == 0:\n        recurse = False\n\n    only = _clone_set(only)\n    extra_attrs = _clone_set(extra_attrs)\n\n    if fields_from_query is not None:\n        for item in fields_from_query._select:\n            if isinstance(item, Field):\n                only.add(item)\n            elif isinstance(item, Node) and item._alias:\n                extra_attrs.add(item._alias)\n\n    data = {}\n    exclude = _clone_set(exclude)\n    seen = _clone_set(seen)\n    exclude |= seen\n    model_class = type(model)\n\n    for field in model._meta.declared_fields:\n        if field in exclude or (only and (field not in only)):\n            continue\n\n        field_data = model._data.get(field.name)\n        if isinstance(field, ForeignKeyField) and recurse:\n            if field_data:\n                seen.add(field)\n                rel_obj = getattr(model, field.name)\n                if iscoroutine(rel_obj):\n                    rel_obj = await rel_obj\n                field_data = await model_to_dict(\n                    rel_obj,\n                    recurse=recurse,\n                    backrefs=backrefs,\n                    only=only,\n                    exclude=exclude,\n                    seen=seen,\n                    max_depth=max_depth - 1)\n            else:\n                field_data = None\n\n        data[field.name] = field_data\n\n    if extra_attrs:\n        for attr_name in extra_attrs:\n            attr = getattr(model, attr_name)\n            if callable(attr):\n                data[attr_name] = attr()\n            else:\n                data[attr_name] = attr\n\n    if backrefs and recurse:\n        for related_name, foreign_key in model._meta.reverse_rel.items():\n            descriptor = getattr(model_class, related_name)\n            if descriptor in exclude or foreign_key in exclude:\n                continue\n            if only and (descriptor not in only) and (foreign_key not in only):\n                continue\n\n            accum = []\n            exclude.add(foreign_key)\n            related_query = getattr(\n                model,\n                related_name + '_prefetch',\n                getattr(model, related_name))\n\n            async for rel_obj in related_query:\n                accum.append(await model_to_dict(\n                    rel_obj,\n                    recurse=recurse,\n                    backrefs=backrefs,\n                    only=only,\n                    exclude=exclude,\n                    max_depth=max_depth - 1))\n\n            data[related_name] = accum\n\n    return data", "response": "Convert a model instance to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract the rows from the CSV file and analyze their data - types.", "response": "async def extract_rows(self, file_or_name, **reader_kwargs):\n        \"\"\"\n        Extract `self.sample_size` rows from the CSV file and analyze their\n        data-types.\n        :param str file_or_name: A string filename or a file handle.\n        :param reader_kwargs: Arbitrary parameters to pass to the CSV reader.\n        :returns: A 2-tuple containing a list of headers and list of rows\n                  read from the CSV file.\n        \"\"\"\n        rows = []\n        rows_to_read = self.sample_size\n        async with self.get_reader(file_or_name, **reader_kwargs) as reader:\n            if self.has_header:\n                rows_to_read += 1\n            for i in range(self.sample_size):\n                try:\n                    row = await reader.__anext__()\n                except AttributeError as te:\n                    row = next(reader)\n                except:\n                    raise\n                rows.append(row)\n\n        if self.has_header:\n            header, rows = rows[0], rows[1:]\n        else:\n            header = ['field_%d' % i for i in range(len(rows[0]))]\n        return header, rows"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of functions to use when testing values.", "response": "def get_checks(self):\n        \"\"\"Return a list of functions to use when testing values.\"\"\"\n        return [\n            self.is_date,\n            self.is_datetime,\n            self.is_integer,\n            self.is_float,\n            self.default]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nanalyze the given rows and try to determine the type of value stored in the table.", "response": "def analyze(self, rows):\n        \"\"\"\n        Analyze the given rows and try to determine the type of value stored.\n        :param list rows: A list-of-lists containing one or more rows from a\n                          csv file.\n        :returns: A list of peewee Field objects for each column in the CSV.\n        \"\"\"\n        transposed = zip(*rows)\n        checks = self.get_checks()\n        column_types = []\n        for i, column in enumerate(transposed):\n            # Remove any empty values.\n            col_vals = [val for val in column if val != '']\n            for check in checks:\n                results = set(check(val) for val in col_vals)\n                if all(results):\n                    column_types.append(check.field())\n                    break\n\n        return column_types"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean_text(self, text):\n        '''Clean text using bleach.'''\n        if text is None:\n            return ''\n        text = re.sub(ILLEGAL_CHARACTERS_RE, '', text)\n        if '<' in text or '&lt' in text:\n            text = clean(text, tags=self.tags, strip=self.strip)\n\n        return unescape(text)", "response": "Clean text using bleach."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs the path to the image and feature of the unique key.", "response": "def path(self, category = None, image = None, feature = None):\n        \"\"\"\n\t\tConstructs the path to categories, images and features.\n\n        This path function assumes that the following storage scheme is used on\n        the hard disk to access categories, images and features:\n            - categories: /impath/category\n            - images:     /impath/category/category_image.png\n            - features:   /ftrpath/category/feature/category_image.mat\n\n        The path function is called to query the location of categories, images\n        and features before they are loaded. Thus, if your features are organized\n        in a different way, you can simply replace this method such that it returns\n        appropriate paths' and the LoadFromDisk loader will use your naming\n        scheme.\n\t\t\"\"\"\n        filename = None\n        if not category is None:\n            filename = join(self.impath, str(category))\n        if not image is None:\n            assert not category is None, \"The category has to be given if the image is given\"\n            filename = join(filename,\n                '%s_%s.png' % (str(category), str(image)))\n        if not feature is None:\n            assert category != None and image != None, \"If a feature name is given the category and image also have to be given.\"\n            filename = join(self.ftrpath, str(category), feature,\n                '%s_%s.mat' % (str(category), str(image)))\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_image(self, cat, img):\n        filename = self.path(cat, img)\n        data = []\n        if filename.endswith('mat'):\n            data = loadmat(filename)['output']\n        else:\n            data = imread(filename)\n        if self.size is not None:\n            return imresize(data, self.size)\n        else:\n            return data", "response": "Loads an image from disk."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_feature(self, cat, img, feature):\n        filename = self.path(cat, img, feature)\n        data = loadmat(filename)\n        name = [k for k in list(data.keys()) if not k.startswith('__')]\n        if self.size is not None:\n            return imresize(data[name.pop()], self.size)\n        return data[name.pop()]", "response": "Load a feature from disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_image(self, cat, img, data):\n        filename = self.path(cat, img)\n        mkdir(filename)\n        if type(data) == np.ndarray:\n            data = Image.fromarray(data).convert('RGB')\n        data.save(filename)", "response": "Saves a new image."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_feature(self, cat, img, feature, data):\n        filename = self.path(cat, img, feature)\n        mkdir(filename)\n        savemat(filename, {'output':data})", "response": "Saves a new feature."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws nr_samples random samples from vec.", "response": "def randsample(vec, nr_samples, with_replacement = False):\n    \"\"\"\n    Draws nr_samples random samples from vec.\n    \"\"\"\n    if not with_replacement:\n        return np.random.permutation(vec)[0:nr_samples]\n    else:\n        return np.asarray(vec)[np.random.randint(0, len(vec), nr_samples)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates how much prediction. shape and image_size differ.", "response": "def calc_resize_factor(prediction, image_size):\n    \"\"\"\n    Calculates how much prediction.shape and image_size differ.\n    \"\"\"\n    resize_factor_x = prediction.shape[1] / float(image_size[1])\n    resize_factor_y = prediction.shape[0] / float(image_size[0])\n    if abs(resize_factor_x - resize_factor_y) > 1.0/image_size[1] :\n        raise RuntimeError(\"\"\"The aspect ratio of the fixations does not\n                              match with the prediction: %f vs. %f\"\"\"\n                              %(resize_factor_y, resize_factor_x))\n    return (resize_factor_y, resize_factor_x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a dictionary to a NumPy matrix.", "response": "def dict_2_mat(data, fill = True):\n    \"\"\"\n    Creates a NumPy array from a dictionary with only integers as keys and\n    NumPy arrays as values. Dimension 0 of the resulting array is formed from\n    data.keys(). Missing values in keys can be filled up with np.nan (default)\n    or ignored.\n\n    Parameters\n    ----------\n    data : dict\n        a dictionary with integers as keys and array-likes of the same shape\n        as values\n    fill : boolean\n        flag specifying if the resulting matrix will keep a correspondence\n        between dictionary keys and matrix indices by filling up missing keys\n        with matrices of NaNs. Defaults to True\n\n    Returns\n    -------\n    numpy array with one more dimension than the values of the input dict\n    \"\"\"\n    if any([type(k) != int for k in list(data.keys())]):\n        raise RuntimeError(\"Dictionary cannot be converted to matrix, \" +\n                            \"not all keys are ints\")\n    base_shape = np.array(list(data.values())[0]).shape\n    result_shape = list(base_shape)\n    if fill:\n        result_shape.insert(0, max(data.keys()) + 1)\n    else:\n        result_shape.insert(0, len(list(data.keys())))\n    result = np.empty(result_shape) + np.nan\n        \n    for (i, (k, v)) in enumerate(data.items()):\n        v = np.array(v)\n        if v.shape != base_shape:\n            raise RuntimeError(\"Dictionary cannot be converted to matrix, \" +\n                                        \"not all values have same dimensions\")\n        result[fill and [k][0] or [i][0]] = v\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dict_fun(data, function):\n    return dict((k, function(v)) for k, v in list(data.items()))", "response": "Apply a function to all values in a dictionary return a dictionary with the keys as data and the values as function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmiddles string of length max_len", "response": "def snip_string_middle(string, max_len=20, snip_string='...'):\n    \"\"\"\n    >>> snip_string_middle('this is long', 8)\n    'th...ong'\n    >>> snip_string_middle('this is long', 12)\n    'this is long'\n    >>> snip_string_middle('this is long', 8, '~')\n    'thi~long'\n    \n\n    \"\"\"\n    #warn('use snip_string() instead', DeprecationWarning)\n    if len(string) <= max_len:\n        new_string = string\n    else:\n        visible_len = (max_len - len(snip_string))\n        start_len = visible_len//2\n        end_len = visible_len-start_len\n        \n        new_string = string[0:start_len]+ snip_string + string[-end_len:]\n    \n    return new_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snip_string(string, max_len=20, snip_string='...', snip_point=0.5):\n    if len(string) <= max_len:\n        new_string = string\n    else:\n        visible_len = (max_len - len(snip_string))\n        start_len = int(visible_len*snip_point)\n        end_len = visible_len-start_len\n        \n        new_string = string[0:start_len]+ snip_string\n        if end_len > 0:\n            new_string += string[-end_len:]\n    \n    return new_string", "response": "Snips a string so that it is no longer than max_len replacing deleted characters with the snip_string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a list of strings finds the longest string that is common to all strings in the list.", "response": "def find_common_beginning(string_list, boundary_char = None):\n    \"\"\"Given a list of strings, finds finds the longest string that is common\n    to the *beginning* of all strings in the list.\n    \n    boundary_char defines a boundary that must be preserved, so that the\n    common string removed must end with this char.\n    \"\"\"\n    \n    common=''\n    \n    # by definition there is nothing common to 1 item...\n    if len(string_list) > 1:\n        shortestLen = min([len(el) for el in string_list])\n        \n        for idx in range(shortestLen):\n            chars = [s[idx] for s in string_list]\n            if chars.count(chars[0]) != len(chars): # test if any chars differ\n                break\n            common+=chars[0]\n    \n        \n    if boundary_char is not None:\n        try:\n            end_idx = common.rindex(boundary_char)\n            common = common[0:end_idx+1]\n        except ValueError:\n            common = ''\n    \n    return common"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of strings finds the longest string that is common to all strings in the list and returns a new list of strings.", "response": "def factorise_strings (string_list, boundary_char=None):\n    \"\"\"Given a list of strings, finds the longest string that is common\n    to the *beginning* of all strings in the list and\n    returns a new list whose elements lack this common beginning.\n    \n    boundary_char defines a boundary that must be preserved, so that the\n    common string removed must end with this char.\n    \n    >>> cmn='something/to/begin with?'\n    >>> blah=[cmn+'yes',cmn+'no',cmn+'?maybe']\n    >>> (blee, bleecmn) = factorise_strings(blah)\n    >>> blee\n    ['yes', 'no', '?maybe']\n    >>> bleecmn == cmn\n    True\n    \n    >>> blah = ['de.uos.nbp.senhance', 'de.uos.nbp.heartFelt']\n    >>> (blee, bleecmn) = factorise_strings(blah, '.')\n    >>> blee\n    ['senhance', 'heartFelt']\n    >>> bleecmn\n    'de.uos.nbp.'\n    \n    >>> blah = ['/some/deep/dir/subdir', '/some/deep/other/dir', '/some/deep/other/dir2']\n    >>> (blee, bleecmn) = factorise_strings(blah, '/')\n    >>> blee\n    ['dir/subdir', 'other/dir', 'other/dir2']\n    >>> bleecmn\n    '/some/deep/'\n    \n    >>> blah = ['/net/store/nbp/heartFelt/data/ecg/emotive_interoception/p20/2012-01-27T09.01.14-ecg.csv', '/net/store/nbp/heartFelt/data/ecg/emotive_interoception/p21/2012-01-27T11.03.08-ecg.csv', '/net/store/nbp/heartFelt/data/ecg/emotive_interoception/p23/2012-01-31T12.02.55-ecg.csv']\n    >>> (blee, bleecmn) = factorise_strings(blah, '/')\n    >>> bleecmn\n    '/net/store/nbp/heartFelt/data/ecg/emotive_interoception/'\n    \n    rmuil 2012/02/01\n    \"\"\"\n    \n    cmn = find_common_beginning(string_list, boundary_char)\n    \n    new_list = [el[len(cmn):] for el in string_list]\n\n    return (new_list, cmn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a datamat from a file.", "response": "def load(path, variable='Datamat'):\n    \"\"\"\n    Load datamat at path.\n\n    Parameters:\n        path : string\n            Absolute path of the file to load from.\n    \"\"\"\n    f = h5py.File(path,'r')\n    try:\n        dm = fromhdf5(f[variable])\n    finally:\n        f.close()\n    return dm"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef VectorFactory(fields, parameters, categories = None):\n    '''\n    Creates a datamat from a dictionary that contains lists/arrays as values.\n\n    Input:\n        fields: Dictionary\n            The values will be used as fields of the datamat and the keys\n            as field names.\n        parameters: Dictionary\n            A dictionary whose values are added as parameters. Keys are used\n            for parameter names.\n    '''\n    fm = Datamat(categories = categories)\n    fm._fields = list(fields.keys())\n    for (field, value) in list(fields.items()):\n        try:\n            fm.__dict__[field] = np.asarray(value)\n        except ValueError:\n            fm.__dict__[field] = np.asarray(value, dtype=np.object)\n\n    fm._parameters = parameters\n    for (field, value) in list(parameters.items()):\n       fm.__dict__[field] = value\n    fm._num_fix = len(fm.__dict__[list(fields.keys())[0]])\n    return fm", "response": "Returns a datamat from a dictionary that contains lists or arrays as values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter(self, index): #@ReservedAssignment\n        return Datamat(categories=self._categories, datamat=self, index=index)", "response": "This function filters a datamat by different aspects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self):\n        return self.filter(np.ones(self._num_fix).astype(bool))", "response": "Returns a copy of the datamat."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, path):\n        f = h5py.File(path, 'w')\n        try:\n            fm_group = f.create_group('Datamat')\n            for field in self.fieldnames():\n                try:\n                    fm_group.create_dataset(field, data = self.__dict__[field])\n                except (TypeError,) as e:\n                    # Assuming field is an object array that contains dicts which\n                    # contain numpy arrays as values\n                    sub_group = fm_group.create_group(field)\n                    for i, d in enumerate(self.__dict__[field]):\n                        index_group = sub_group.create_group(str(i))\n                        print((field, d))\n                        for key, value in list(d.items()):\n                            index_group.create_dataset(key, data=value)\n\n            for param in self.parameters():\n                fm_group.attrs[param]=self.__dict__[param]\n        finally:\n            f.close()", "response": "Saves the object to a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the value of a parameter.", "response": "def set_param(self, key, value):\n        \"\"\"\n        Set the value of a parameter.\n        \"\"\"\n        self.__dict__[key] = value\n        self._parameters[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef by_field(self, field):\n        for value in np.unique(self.__dict__[field]):\n            yield self.filter(self.__dict__[field] == value)", "response": "Returns an iterator that iterates over unique values of field"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef by_cat(self):\n        for value in np.unique(self.category):\n            cat_fm = self.filter(self.category == value)\n            if self._categories:\n                yield (cat_fm, self._categories[value])\n            else:\n                yield (cat_fm, None)", "response": "Iterate over datamat and categories and returns a filtered datamat."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating over datamat and returns a filtered datamat and associated categories objects.", "response": "def by_filenumber(self):\n        \"\"\"\n        Iterates over categories and returns a filtered datamat.\n\n        If a categories object is attached, the images object for the given\n        category is returned as well (else None is returned).\n\n        Returns:\n            (datamat, categories) : A tuple that contains first the filtered\n                datamat (has only one category) and second the associated\n                categories object (if it is available, None otherwise)\n        \"\"\"\n        for value in np.unique(self.filenumber):\n            file_fm = self.filter(self.filenumber == value)\n            if self._categories:\n                yield (file_fm, self._categories[self.category[0]][value])\n            else:\n                yield (file_fm, None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_field(self, name, data):\n        if name in self._fields:\n            raise ValueError\n        if not len(data) == self._num_fix:\n            raise ValueError\n        self._fields.append(name)\n        self.__dict__[name] = data", "response": "Add a new field to the datamat."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_field_like(self, name, like_array):\n        new_shape = list(like_array.shape)\n        new_shape[0] = len(self)\n        new_data = ma.empty(new_shape, like_array.dtype)\n        new_data.mask = True\n        self.add_field(name, new_data)", "response": "Add a new field to the Datamat with the dtype of the like_array and the shape of the like_array except for the first\n        dimension."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new field (data_field) to the Datamat with data from the corresponding field of another Datamat (src_dm). This is accomplished through the use of a key_field, which is used to determine how the data is copied. This operation corresponds loosely to an SQL join operation. The two Datamats are essentially aligned by the unique values of key_field so that each block element of the new field of the target Datamat will consist of those elements of src_dm's data_field where the corresponding element in key_field matches. If 'take_first' is not true, and there is not only a single corresponding element (typical usage case) then the target element value will be a sequence (array) of all the matching elements. The target Datamat (self) must not have a field name data_field already, and both Datamats must have key_field. The new field in the target Datamat will be a masked array to handle non-existent data. TODO: Make example more generic, remove interoceptive reference TODO: Make standalone test Examples: >>> dm_intero = load_interoception_files ('test-ecg.csv', silent=True) >>> dm_emotiv = load_emotivestimuli_files ('test-bpm.csv', silent=True) >>> length(dm_intero) 4 >>> unique(dm_intero.subject_id) ['p05', 'p06'] >>> length(dm_emotiv) 3 >>> unique(dm_emotiv.subject_id) ['p04', 'p05', 'p06'] >>> 'interospective_awareness' in dm_intero.fieldnames() True >>> unique(dm_intero.interospective_awareness) == [0.5555, 0.6666] True >>> 'interospective_awareness' in dm_emotiv.fieldnames() False >>> dm_emotiv.copy_field(dm_intero, 'interospective_awareness', 'subject_id') >>> 'interospective_awareness' in dm_emotiv.fieldnames() True >>> unique(dm_emotiv.interospective_awareness) == [NaN, 0.5555, 0.6666] False", "response": "def annotate (self, src_dm, data_field, key_field, take_first=True):\n        \"\"\"\n        Adds a new field (data_field) to the Datamat with data from the\n        corresponding field of another Datamat (src_dm).\n\n\t\t\t\tThis is accomplished through the use of a key_field, which is\n        used to determine how the data is copied.\n\n\t\t\t\tThis operation corresponds loosely to an SQL join operation.\n\n        The two Datamats are essentially aligned by the unique values\n        of key_field so that each block element of the new field of the target\n        Datamat will consist of those elements of src_dm's data_field\n        where the corresponding element in key_field matches.\n\n        If 'take_first' is not true, and there is not\n        only a single corresponding element (typical usage case) then the\n        target element value will be\n        a sequence (array) of all the matching elements.\n\n        The target Datamat (self) must not have a field name data_field\n        already, and both Datamats must have key_field.\n\n        The new field in the target Datamat will be a masked array to handle\n        non-existent data.\n\n\t\t\t\tTODO: Make example more generic, remove interoceptive reference\n\t\t\t\tTODO: Make standalone test\n        Examples:\n\n        >>> dm_intero = load_interoception_files ('test-ecg.csv', silent=True)\n        >>> dm_emotiv = load_emotivestimuli_files ('test-bpm.csv', silent=True)\n        >>> length(dm_intero)\n        4\n        >>> unique(dm_intero.subject_id)\n        ['p05', 'p06']\n        >>> length(dm_emotiv)\n        3\n        >>> unique(dm_emotiv.subject_id)\n        ['p04', 'p05', 'p06']\n        >>> 'interospective_awareness' in dm_intero.fieldnames()\n        True\n        >>> unique(dm_intero.interospective_awareness) == [0.5555, 0.6666]\n        True\n        >>> 'interospective_awareness' in dm_emotiv.fieldnames()\n        False\n        >>> dm_emotiv.copy_field(dm_intero, 'interospective_awareness', 'subject_id')\n        >>> 'interospective_awareness' in dm_emotiv.fieldnames()\n        True\n        >>> unique(dm_emotiv.interospective_awareness) == [NaN, 0.5555, 0.6666]\n        False\n        \"\"\"\n        if key_field not in self._fields or key_field not in src_dm._fields:\n            raise AttributeError('key field (%s) must exist in both Datamats'%(key_field))\n        if data_field not in src_dm._fields:\n            raise AttributeError('data field (%s) must exist in source Datamat' % (data_field))\n        if data_field in self._fields:\n            raise AttributeError('data field (%s) already exists in target Datamat' % (data_field))\n\n        #Create a mapping of key_field value to data value.\n        data_to_copy = dict([(x.field(key_field)[0], x.field(data_field)) for x in src_dm.by_field(key_field)])\n\n        data_element = list(data_to_copy.values())[0]\n\n        #Create the new data array of correct size.\n        # We use a masked array because it is possible that for some elements\n        # of the target Datamat, there exist simply no data in the source\n        # Datamat. NaNs are fine as indication of this for floats, but if the\n        # field happens to hold booleans or integers or something else, NaN\n        # does not work.\n        new_shape = [len(self)] + list(data_element.shape)\n        new_data = ma.empty(new_shape, data_element.dtype)\n        new_data.mask=True\n        if np.issubdtype(new_data.dtype, np.float):\n            new_data.fill(np.NaN) #For backwards compatibility, if mask not used\n\n        #Now we copy the data. If the data to copy contains only a single value,\n        # it is added to the target as a scalar (single value).\n        # Otherwise, it is copied as is, i.e. as a sequence.\n        for (key, val) in list(data_to_copy.items()):\n            if take_first:\n                new_data[self.field(key_field) == key] = val[0]\n            else:\n                new_data[self.field(key_field) == key] = val\n\n        self.add_field(data_field, new_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rm_field(self, name):\n        if not name in self._fields:\n            raise ValueError\n        self._fields.remove(name)\n        del self.__dict__[name]", "response": "Removes a field from the datamat."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_parameter(self, name, value):\n        if name in self._parameters:\n            raise ValueError(\"'%s' is already a parameter\" % (name))\n        elif name in self.__dict__:\n            raise ValueError(\"'%s' conflicts with the Datamat name-space\" % (name))\n\n        self.__dict__[name] = value\n        self._parameters[name] = self.__dict__[name]", "response": "Adds a parameter to the existing Datamat."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rm_parameter(self, name):\n        if name not in self._parameters:\n            raise ValueError(\"no '%s' parameter found\" % (name))\n\n        del self._parameters[name]\n        del self.__dict__[name]", "response": "Removes a parameter from the existing Datamat."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npromote a parameter to a field by creating a new array of same size as the other existing fields and filling it with the current value of the parameter.", "response": "def parameter_to_field(self, name):\n        \"\"\"\n        Promotes a parameter to a field by creating a new array of same\n        size as the other existing fields, filling it with the current\n        value of the parameter, and then removing that parameter.\n        \"\"\"\n        if name not in self._parameters:\n            raise ValueError(\"no '%s' parameter found\" % (name))\n        if self._fields.count(name) > 0:\n            raise ValueError(\"field with name '%s' already exists\" % (name))\n\n        data = np.array([self._parameters[name]]*self._num_fix)\n\n        self.rm_parameter(name)\n        self.add_field(name, data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\njoin the current instance of Datamat with the new instance of Datamat.", "response": "def join(self, fm_new, minimal_subset=True):\n        \"\"\"\n        Adds content of a new Datamat to this Datamat.\n\n        If a parameter of the Datamats is not equal or does not exist\n        in one, it is promoted to a field.\n\n        If the two Datamats have different fields then the elements for the\n        Datamats that did not have the field will be NaN, unless\n        'minimal_subset' is true, in which case the mismatching fields will\n        simply be deleted.\n\n        Parameters\n        fm_new : instance of Datamat\n            This Datamat is added to the current one.\n        minimal_subset : if true, remove fields which don't exist in both,\n        \tinstead of using NaNs for missing elements (defaults to False)\n\n        Capacity to use superset of fields added by rmuil 2012/01/30\n\n        \"\"\"\n        # Check if parameters are equal. If not, promote them to fields.\n        '''\n        for (nm, val) in fm_new._parameters.items():\n            if self._parameters.has_key(nm):\n                if (val != self._parameters[nm]):\n                    self.parameter_to_field(nm)\n                    fm_new.parameter_to_field(nm)\n            else:\n                fm_new.parameter_to_field(nm)\n        '''\n        # Deal with mismatch in the fields\n        # First those in self that do not exist in new...\n        orig_fields = self._fields[:]\n        for field in orig_fields:\n            if not field in fm_new._fields:\n                if minimal_subset:\n                    self.rm_field(field)\n                else:\n                    warnings.warn(\"This option is deprecated. Clean and Filter your data before it is joined.\", DeprecationWarning)\n                    fm_new.add_field_like(field, self.field(field))\n        # ... then those in the new that do not exist in self.\n        orig_fields = fm_new._fields[:]\n        for field in orig_fields:\n            if not field in self._fields:\n                if minimal_subset:\n                    fm_new.rm_field(field)\n                else:\n                    warnings.warn(\"This option is deprecated. Clean and Filter your data before it is joined.\", DeprecationWarning)\n                    self.add_field_like(field, fm_new.field(field))\n\n        if 'SUBJECTINDEX' in self._fields[:]:\n            if fm_new.SUBJECTINDEX[0] in self.SUBJECTINDEX:\n                fm_new.SUBJECTINDEX[:] = self.SUBJECTINDEX.max()+1\n        # Concatenate fields\n        for field in self._fields:\n            self.__dict__[field] = ma.hstack((self.__dict__[field],\n                fm_new.__dict__[field]))\n\n        # Update _num_fix\n        self._num_fix += fm_new._num_fix"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a histogram of the given data along the x - axis and length differences.", "response": "def makeAngLenHist(ad, ld, fm = None, collapse=True, fit=spline_base.fit2d):\n    \"\"\"\n    Histograms and performs a spline fit on the given data, \n    usually angle and length differences.\n    \n    Parameters:\n        ad : array\n            The data to be histogrammed along the x-axis. \n            May range from -180 to 180.\n        ld : array\n            The data to be histogrammed along the y-axis.\n            May range from -36 to 36.\n        collapse : boolean\n            If true, the histogrammed data will include \n            negative values on the x-axis. Else, the histogram\n            will be collapsed along x = 0, and thus contain only \n            positive angle differences\n        fit : function or None, optional\n            The function to use in order to fit the data. \n            If no fit should be applied, set to None\n        fm  : fixmat or None, optional\n            If given, the angle and length differences are calculated\n            from the fixmat and the previous parameters are overwritten.\n    \"\"\"\n    \n    if fm:\n        ad,ld = anglendiff(fm, roll=2)\n        ad, ld = ad[0], ld[0]\n        \n    ld = ld[~np.isnan(ld)]\n    ad = reshift(ad[~np.isnan(ad)])\n\n    if collapse:\n        e_y = np.linspace(-36.5, 36.5, 74)\n        e_x = np.linspace(0, 180, 181)\n        H = makeHist(abs(ad), ld, fit=fit, bins=[e_y, e_x])\n\n        H = H/H.sum()\n        \n        return H\n    else:\n        e_x = np.linspace(-180, 180, 361)\n        e_y = np.linspace(-36.5, 36.5, 74)\n        return makeHist(ad, ld, fit=fit, bins=[e_y, e_x])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct a 2D histogram of the given data.", "response": "def makeHist(x_val, y_val, fit=spline_base.fit2d, \n            bins=[np.linspace(-36.5,36.5,74),np.linspace(-180,180,361)]):\n    \"\"\"\n    Constructs a (fitted) histogram of the given data.\n    \n    Parameters:\n        x_val : array\n            The data to be histogrammed along the x-axis. \n        y_val : array\n            The data to be histogrammed along the y-axis.\n        fit : function or None, optional\n            The function to use in order to fit the data. \n            If no fit should be applied, set to None\n        bins : touple of arrays, giving the bin edges to be \n            used in the histogram. (First value: y-axis, Second value: x-axis)\n    \"\"\"\n    \n    y_val = y_val[~np.isnan(y_val)]\n    x_val = x_val[~np.isnan(x_val)]\n    \n    samples = list(zip(y_val, x_val))\n    K, xedges, yedges = np.histogram2d(y_val, x_val, bins=bins)\n\n    if (fit is None):\n        return K/ K.sum()\n   \n    # Check if given attr is a function\n    elif hasattr(fit, '__call__'):\n        H = fit(np.array(samples), bins[0], bins[1], p_est=K)[0]\n        return H/H.sum()\n    else:\n        raise TypeError(\"Not a valid argument, insert spline function or None\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef firstSacDist(fm):\n    ang, leng, ad, ld = anglendiff(fm, return_abs=True)\n    y_arg = leng[0][np.roll(fm.fix == min(fm.fix), 1)]/fm.pixels_per_degree\n    x_arg = reshift(ang[0][np.roll(fm.fix == min(fm.fix), 1)])\n    bins = [list(range(int(ceil(np.nanmax(y_arg)))+1)), np.linspace(-180, 180, 361)]\n    return makeHist(x_arg, y_arg, fit=None, bins = bins)", "response": "Computes the distribution of angle and length of the first saccades\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the distribution of trajectory lengths i. e. the number of saccades that were made as part of one trajectory ArcGIS record.", "response": "def trajLenDist(fm):\n    \"\"\"\n        Computes the distribution of trajectory lengths, i.e.\n        the number of saccades that were made as a part of one trajectory\n        \n        Parameters:\n            fm : ocupy.fixmat \n                The fixation data to be analysed\n    \n    \"\"\"  \n    trajLen = np.roll(fm.fix, 1)[fm.fix == min(fm.fix)]\n    val, borders = np.histogram(trajLen, \n                    bins=np.linspace(-0.5, max(trajLen)+0.5, max(trajLen)+2))\n    cumsum = np.cumsum(val.astype(float) / val.sum())\n    return cumsum, borders"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransform the given number element into a range of [-180, 180], which covers all possible angle differences. This method reshifts larger or smaller numbers that might be the output of other angular calculations into that range by adding or subtracting 360, respectively. To make sure that angular data ranges between -180 and 180 in order to be properly histogrammed, apply this method first. Parameters: I : array or list or int or float Number or numbers that shall be reshifted. Farell, Ludwig, Ellis, and Gilchrist Returns: numpy.ndarray : Reshifted number or numbers as array", "response": "def reshift(I):\n    \"\"\"\n    Transforms the given number element into a range of [-180, 180],\n    which covers all possible angle differences. This method reshifts larger or \n    smaller numbers that might be the output of other angular calculations\n    into that range by adding or subtracting 360, respectively. \n    To make sure that angular data ranges between -180 and 180 in order to be\n    properly histogrammed, apply this method first.\n    \n    \n    Parameters: \n        I : array or list or int or float\n            Number or numbers that shall be reshifted.\n    Farell, Ludwig, Ellis, and Gilchrist\n    Returns:\n        numpy.ndarray : Reshifted number or numbers as array\n    \"\"\"\n    # Output -180 to +180\n    if type(I)==list:\n        I = np.array(I)\n    \n    return ((I-180)%360)-180"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initializeData(self, fit = None, full_H1=None, max_length = 40,\n            in_deg = True):\n        \"\"\"\n        Prepares the data to be replicated. Calculates the second-order length \n        and angle dependencies between saccades and stores them in a fitted \n        histogram.\n        \n        Parameters:\n            fit : function, optional\n                The method to use for fitting the histogram\n            full_H1 : twodimensional numpy.ndarray, optional\n                Where applicable, the distribution of angle and length\n                differences to replicate with dimensions [73,361]\n        \"\"\"\n        a, l, ad, ld = anglendiff(self.fm, roll=1, return_abs = True)\n        if in_deg:\n            self.fm.pixels_per_degree = 1\n            \n        samples = np.zeros([3, len(l[0])])\n        samples[0] = l[0]/self.fm.pixels_per_degree\n        samples[1] = np.roll(l[0]/self.fm.pixels_per_degree,-1)\n        samples[2] = np.roll(reshift(ad[0]),-1)\n        z = np.any(np.isnan(samples), axis=0)\n        samples = samples[:,~np.isnan(samples).any(0)]\n           \n        if full_H1 is None:   \n            self.full_H1 = []\n            for i in range(1, int(ceil(max_length+1))):\n                idx = np.logical_and(samples[0]<=i, samples[0]>i-1)\n                if idx.any():\n                    self.full_H1.append(makeHist(samples[2][idx], samples[1][idx], fit=fit, \n                                                bins=[np.linspace(0,max_length-1,max_length),np.linspace(-180,180,361)]))\n                    # Sometimes if there's only one sample present there seems to occur a problem\n                    # with histogram calculation and the hist is filled with nans. In this case, dismiss\n                    # the hist.\n                    if np.isnan(self.full_H1[-1]).any():\n                        self.full_H1[-1] = np.array([])\n                    self.nosamples.append(len(samples[2][idx]))\n                else:\n                    self.full_H1.append(np.array([]))\n                    self.nosamples.append(0)\n        else:\n            self.full_H1 = full_H1\n                \n        self.firstLenAng_cumsum, self.firstLenAng_shape = (\n                                        compute_cumsum(firstSacDist(self.fm)))\n        self.probability_cumsum = []\n       \n        for i in range(len(self.full_H1)):\n            if self.full_H1[i] == []:\n                self.probability_cumsum.append(np.array([]))\n            else:\n                self.probability_cumsum.append(np.cumsum(self.full_H1[i].flat))\n               \n        self.trajLen_cumsum, self.trajLen_borders = trajLenDist(self.fm)\n        \n        min_distance = 1/np.array([min((np.unique(self.probability_cumsum[i]) \\\n                        -np.roll(np.unique(self.probability_cumsum[i]),1))[1:]) \\\n                        for i in range(len(self.probability_cumsum))])\n        # Set a minimal resolution\n        min_distance[min_distance<10] = 10\n\n        self.linind = {}\n        for i in range(len(self.probability_cumsum)):\n            self.linind['self.probability_cumsum '+repr(i)] = np.linspace(0,1,min_distance[i])[0:-1]\n        \n        for elem in [self.firstLenAng_cumsum, self.trajLen_cumsum]:\n            self.linind[elem] = np.linspace(0, 1, 1/min((np.unique((elem))-np.roll(np.unique((elem)),1))[1:]))[0:-1]", "response": "Initializes the data for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _calc_xy(self, xxx_todo_changeme, angle, length):\n        (x, y) = xxx_todo_changeme\n        return (x+(cos(radians(angle))*length),\n                y+(sin(radians(angle))*length))", "response": "Calculates the coordinates after a specific saccade was made."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _draw(self, prev_angle = None, prev_length = None):\n        \n        if (prev_angle is None) or (prev_length is None):\n            (length, angle)= np.unravel_index(self.drawFrom('self.firstLenAng_cumsum', self.getrand('self.firstLenAng_cumsum')),\n                                                self.firstLenAng_shape)\n            angle = angle-((self.firstLenAng_shape[1]-1)/2) \n            angle += 0.5\n            length += 0.5\n            length *= self.fm.pixels_per_degree\n        else:\n            ind = int(floor(prev_length/self.fm.pixels_per_degree))\n            while ind >= len(self.probability_cumsum):\n                ind -= 1\n\n            while not(self.probability_cumsum[ind]).any():\n                ind -= 1\n                \n            J, I = np.unravel_index(self.drawFrom('self.probability_cumsum '+repr(ind),self.getrand('self.probability_cumsum '+repr(ind))), \n                                    self.full_H1[ind].shape)\n            angle = reshift((I-self.full_H1[ind].shape[1]/2) + prev_angle)\n            angle += 0.5\n            length = J+0.5\n            length *= self.fm.pixels_per_degree\n        return angle, length", "response": "Draw a new length - and angle - difference pair and calculates the last saccade drawn."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sample_many(self, num_samples = 2000):\n        x = []\n        y = []\n        fix = []\n        sample = []\n        \n        # XXX: Delete ProgressBar\n        pbar = ProgressBar(widgets=[Percentage(),Bar()], maxval=num_samples).start()\n        \n        for s in range(0, num_samples):\n            for i, (xs, ys) in enumerate(self.sample()):\n                x.append(xs)\n                y.append(ys)\n                fix.append(i+1)\n                sample.append(s)\n            pbar.update(s+1)\n            \n        fields = {'fix':np.array(fix), 'y':np.array(y), 'x':np.array(x)}\n        param = {'pixels_per_degree':self.fm.pixels_per_degree}\n        out =  fixmat.VectorFixmatFactory(fields, param)\n        return out", "response": "Generates a given number of trajectories using the method sample."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sample(self):\n        lenghts = []\n        angles = []\n        coordinates = []\n        fix = []\n        sample_size = int(round(self.trajLen_borders[self.drawFrom('self.trajLen_cumsum', self.getrand('self.trajLen_cumsum'))]))\n\n        coordinates.append([0, 0])\n        fix.append(1)\n        \n        while len(coordinates) < sample_size:\n            if len(lenghts) == 0 and len(angles) == 0:          \n                angle, length = self._draw(self)\n            else:\n                angle, length = self._draw(prev_angle = angles[-1], \n                                            prev_length = lenghts[-1])  \n                        \n            x, y = self._calc_xy(coordinates[-1], angle, length) \n            \n            coordinates.append([x, y])\n            lenghts.append(length) \n            angles.append(angle)\n            fix.append(fix[-1]+1)\n        return coordinates", "response": "Draw a trajectory length first coordinates lengths angles and length - angle - difference pairs according to the empirical distribution. Each call creates one complete trajectory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws a value from a cumulative sum.", "response": "def drawFrom(self, cumsum, r):\n        \"\"\"\n        Draws a value from a cumulative sum.\n        \n        Parameters: \n            cumsum : array\n                Cumulative sum from which shall be drawn.\n\n        Returns:\n            int : Index of the cumulative sum element drawn.\n        \"\"\"\n        a = cumsum.rsplit()\n        if len(a)>1:\n            b = eval(a[0])[int(a[1])]\n        else:\n            b = eval(a[0])\n            \n        return np.nonzero(b>=r)[0][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a fixmat from a file.", "response": "def load(path):\n    \"\"\"\n    Load fixmat at path.\n    \n    Parameters:\n        path : string\n            Absolute path of the file to load from.\n    \"\"\"\n    f = h5py.File(path,'r')\n    if 'Fixmat' in f:\n      fm_group = f['Fixmat']\n    else:\n      fm_group = f['Datamat']\n    fields = {}\n    params = {}\n    for field, value in list(fm_group.items()):\n        fields[field] = np.array(value)\n    for param, value in list(fm_group.attrs.items()):\n        params[param] = value\n    f.close()\n    return VectorFixmatFactory(fields, params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the fixation density map for the calling fixmat.", "response": "def compute_fdm(fixmat, fwhm=2, scale_factor=1):\n    \"\"\"\n    Computes a fixation density map for the calling fixmat. \n    \n    Creates a map the size of the image fixations were recorded on.  \n    Every pixel contains the frequency of fixations\n    for this image. The fixation map is smoothed by convolution with a\n    Gaussian kernel to approximate the area with highest processing\n    (usually 2 deg. visual angle).\n\n    Note: The function does not check whether the fixmat contains\n    fixations from different images as it might be desirable to compute\n    fdms over fixations from more than one image.\n\n    Parameters:\n        fwhm :  float \n            the full width at half maximum of the Gaussian kernel used\n            for convolution of the fixation frequency map.\n\n        scale_factor : float\n            scale factor for the resulting fdm. Default is 1. Scale_factor\n            must be a float specifying the fraction of the current size.\n        \n    Returns:\n        fdm  : numpy.array \n            a numpy.array of size fixmat.image_size containing\n            the fixation probability for every location on the image.\n    \"\"\"\n    # image category must exist (>-1) and image_size must be non-empty\n    assert (len(fixmat.image_size) == 2 and (fixmat.image_size[0] > 0) and\n        (fixmat.image_size[1] > 0)), 'The image_size is either 0, or not 2D'\n    # check whether fixmat contains fixations\n    if fixmat._num_fix == 0 or len(fixmat.x) == 0 or len(fixmat.y) == 0 :\n        raise RuntimeError('There are no fixations in the fixmat.')\n    assert not scale_factor <= 0, \"scale_factor has to be > 0\"\n    # this specifies left edges of the histogram bins, i.e. fixations between\n    # ]0 binedge[0]] are included. --> fixations are ceiled\n    e_y = np.arange(0, np.round(scale_factor*fixmat.image_size[0]+1))\n    e_x = np.arange(0, np.round(scale_factor*fixmat.image_size[1]+1))\n    samples = np.array(list(zip((scale_factor*fixmat.y), (scale_factor*fixmat.x))))\n    (hist, _) = np.histogramdd(samples, (e_y, e_x))\n    kernel_sigma = fwhm * fixmat.pixels_per_degree * scale_factor\n    kernel_sigma = kernel_sigma / (2 * (2 * np.log(2)) ** .5)\n    fdm = gaussian_filter(hist, kernel_sigma, order=0, mode='constant')\n    return fdm / fdm.sum()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef relative_bias(fm,  scale_factor = 1, estimator = None):\n    assert 'fix' in fm.fieldnames(), \"Can not work without fixation  numbers\"\n    excl = fm.fix - np.roll(fm.fix, 1) != 1\n\n    # Now calculate the direction where the NEXT fixation goes to\n    diff_x = (np.roll(fm.x, 1) - fm.x)[~excl]\n    diff_y = (np.roll(fm.y, 1) - fm.y)[~excl]\n       \n\n    # Make a histogram of diff values\n    # this specifies left edges of the histogram bins, i.e. fixations between\n    # ]0 binedge[0]] are included. --> fixations are ceiled\n    ylim =  np.round(scale_factor * fm.image_size[0])\n    xlim =  np.round(scale_factor * fm.image_size[1])\n    x_steps = np.ceil(2*xlim) +1\n    if x_steps % 2 != 0: x_steps+=1\n    y_steps = np.ceil(2*ylim)+1\n    if y_steps % 2 != 0: y_steps+=1\n    e_x = np.linspace(-xlim,xlim,x_steps)\n    e_y = np.linspace(-ylim,ylim,y_steps)\n\n    #e_y = np.arange(-ylim, ylim+1)\n    #e_x = np.arange(-xlim, xlim+1)\n    samples = np.array(list(zip((scale_factor * diff_y),\n                             (scale_factor* diff_x))))\n    if estimator == None:\n        (hist, _) = np.histogramdd(samples, (e_y, e_x))\n    else:\n        hist = estimator(samples, e_y, e_x)\n    return hist", "response": "Computes the relative bias of a single class hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef DirectoryFixmatFactory(directory, categories = None, glob_str = '*.mat', var_name = 'fixmat'):\n    files = glob(join(directory,glob_str))\n    if len(files) == 0:\n        raise ValueError(\"Could not find any fixmats in \" + \n            join(directory, glob_str))\n    f_all = FixmatFactory(files.pop(), categories, var_name)\n    for fname in files:\n        f_current = FixmatFactory(fname, categories, var_name)\n        f_all.join(f_current)\n    return f_all", "response": "Returns a new fixmat object that contains all fixmats in a directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef FixmatFactory(fixmatfile, categories = None, var_name = 'fixmat', field_name='x'):\n    try:\n        data = loadmat(fixmatfile, struct_as_record = False)\n        keys = list(data.keys())\n        data = data[var_name][0][0]\n    except KeyError:\n        raise RuntimeError('%s is not a field of the matlab structure. Possible'+\n                'Keys are %s'%str(keys))\n    \n    num_fix = data.__getattribute__(field_name).size\n\n    # Get a list with fieldnames and a list with parameters\n    fields = {}\n    parameters = {}\n    for field in data._fieldnames:\n        if data.__getattribute__(field).size == num_fix:\n            fields[field] = data.__getattribute__(field)\n        else:            \n            parameters[field] = data.__getattribute__(field)[0].tolist()\n            if len(parameters[field]) == 1:\n                parameters[field] = parameters[field][0]\n    \n    # Generate FixMat\n    fixmat = FixMat(categories = categories)\n    fixmat._fields = list(fields.keys())\n    for (field, value) in list(fields.items()):\n        fixmat.__dict__[field] = value.reshape(-1,) \n\n    fixmat._parameters = parameters\n    fixmat._subjects = None\n    for (field, value) in list(parameters.items()):\n        fixmat.__dict__[field] = value\n    fixmat._num_fix = num_fix\n    return fixmat", "response": "This function creates a new fixmat object from a matlab fixmat file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_feature_values(self, features):\n        if not 'x' in self.fieldnames():\n            raise RuntimeError(\"\"\"add_feature_values expects to find\n        (x,y) locations in self.x and self.y. But self.x does not exist\"\"\")\n \n        if not self._categories:\n            raise RuntimeError(\n            '''\"%s\" does not exist as a fieldname and the\n            fixmat does not have a Categories object (no features \n            available. The fixmat has these fields: %s''' \\\n            %(features, str(self._fields))) \n        for feature in features:\n            # initialize new field with NaNs\n            feat_vals = np.zeros([len(self.x)]) * np.nan \n            for (cat_mat, imgs) in self.by_cat():\n                for img in np.unique(cat_mat.filenumber).astype(int):\n                    fmap = imgs[img][feature]\n                    on_image = (self.x >= 0) & (self.x <= self.image_size[1])\n                    on_image = on_image & (self.y >= 0) & (self.y <= self.image_size[0])\n                    idx = (self.category == imgs.category) & \\\n                          (self.filenumber == img) & \\\n                          (on_image.astype('bool'))\n                    feat_vals[idx] = fmap[self.y[idx].astype('int'), \n                        self.x[idx].astype('int')]\n            # setattr(self, feature, feat_vals)\n            self.add_field(feature, feat_vals)", "response": "This function adds feature values of feature to all fixations in \n ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating two M x N matrices with M feature values at fixations for N features. Controls are a random sample out of all non-fixated regions of an image or fixations of the same subject group on a randomly chosen image. Fixations are pooled over all subjects in the calling fixmat. Parameters : all_controls : bool if True, all non-fixated points on a feature map are takes as control values. If False, controls are fixations from the same subjects but on one other randomly chosen image of the same category feature_list : list of strings contains names of all features that are used to generate the feature value matrix (--> number of dimensions in the model). ...note: this list has to be sorted ! Returns : N x M matrix of N control feature values per feature (M). Rows = Feature number /type Columns = Feature values", "response": "def make_reg_data(self, feature_list=None, all_controls=False):    \n        \"\"\" \n        Generates two M x N matrices with M feature values at fixations for \n        N features. Controls are a random sample out of all non-fixated regions \n        of an image or fixations of the same subject group on a randomly chosen \n        image. Fixations are pooled over all subjects in the calling fixmat.\n       \n        Parameters : \n            all_controls : bool\n                if True, all non-fixated points on a feature map are takes as\n                control values. If False, controls are fixations from the same\n                subjects but on one other randomly chosen image of the same\n                category\n            feature_list : list of strings\n                contains names of all features that are used to generate\n                the feature value matrix (--> number of dimensions in the \n                model). \n                ...note: this list has to be sorted !\n\n        Returns : \n            N x M matrix of N control feature values per feature (M).\n            Rows = Feature number /type\n            Columns = Feature values\n        \"\"\"\n        if not 'x' in self.fieldnames():\n            raise RuntimeError(\"\"\"make_reg_data expects to find\n        (x,y) locations in self.x and self.y. But self.x does not exist\"\"\")\n\n        on_image = (self.x >= 0) & (self.x <= self.image_size[1])\n        on_image = on_image & (self.y >= 0) & (self.y <= self.image_size[0])\n        assert on_image.all(), \"All Fixations need to be on the image\"\n        assert len(np.unique(self.filenumber) > 1), \"Fixmat has to have more than one filenumber\"\n        self.x = self.x.astype(int)\n        self.y = self.y.astype(int)\n        \n        if feature_list == None:\n            feature_list = np.sort(self._categories._features)\n        all_act = np.zeros((len(feature_list), 1)) * np.nan\n        all_ctrls = all_act.copy()\n                            \n        for (cfm, imgs) in self.by_cat():\n            # make a list of all filenumbers in this category and then \n            # choose one random filenumber without replacement\n            imfiles = np.array(imgs.images()) # array makes a copy of the list\n            ctrl_imgs = imfiles.copy()\n            np.random.shuffle(ctrl_imgs)\n            while (imfiles == ctrl_imgs).any():\n                np.random.shuffle(ctrl_imgs)\n            for (imidx, img) in enumerate(imfiles):\n                xact = cfm.x[cfm.filenumber == img]\n                yact = cfm.y[cfm.filenumber == img]\n                if all_controls:\n                # take a sample the same length as the actuals out of every \n                # non-fixated point in the feature map\n                    idx = np.ones(self.image_size)\n                    idx[cfm.y[cfm.filenumber == img], \n                        cfm.x[cfm.filenumber == img]] = 0\n                    yctrl, xctrl = idx.nonzero()\n                    idx = np.random.randint(0, len(yctrl), len(xact))\n                    yctrl = yctrl[idx]\n                    xctrl = xctrl[idx]\n                    del idx\n                else:\n                    xctrl = cfm.x[cfm.filenumber == ctrl_imgs[imidx]]\n                    yctrl = cfm.y[cfm.filenumber == ctrl_imgs[imidx]]\n                # initialize arrays for this filenumber\n                actuals = np.zeros((1, len(xact))) * np.nan\n                controls = np.zeros((1, len(xctrl))) * np.nan                \n                \n                for feature in feature_list:\n                    # get the feature map\n                    fmap = imgs[img][feature]\n                    actuals = np.vstack((actuals, fmap[yact, xact]))\n                    controls = np.vstack((controls, fmap[yctrl, xctrl]))\n                all_act = np.hstack((all_act, actuals[1:, :]))\n                all_ctrls = np.hstack((all_ctrls, controls[1:, :]))\n        return (all_act[:, 1:], all_ctrls[:, 1:])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute velocity of eye - movements.", "response": "def get_velocity(samplemat, Hz, blinks=None):\n    '''\n    Compute velocity of eye-movements.\n\n    Samplemat must contain fields 'x' and 'y', specifying the x,y coordinates\n    of gaze location. The function assumes that the values in x,y are sampled\n    continously at a rate specified by 'Hz'.\n    '''\n    Hz = float(Hz)\n    distance = ((np.diff(samplemat.x) ** 2) +\n                (np.diff(samplemat.y) ** 2)) ** .5\n    distance = np.hstack(([distance[0]], distance))\n    if blinks is not None:\n        distance[blinks[1:]] = np.nan\n    win = np.ones((velocity_window_size)) / float(velocity_window_size)\n    velocity = np.convolve(distance, win, mode='same')\n    velocity = velocity / (velocity_window_size / Hz)\n    acceleration = np.diff(velocity) / (1. / Hz)\n    acceleration = abs(np.hstack(([acceleration[0]], acceleration)))\n    return velocity, acceleration"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetects saccades in a stream of gaze location samples.", "response": "def saccade_detection(samplemat, Hz=200, threshold=30,\n                      acc_thresh=2000, min_duration=21, min_movement=.35,\n                      ignore_blinks=False):\n    '''\n    Detect saccades in a stream of gaze location samples.\n\n    Coordinates in samplemat are assumed to be in degrees.\n\n    Saccades are detect by a velocity/acceleration threshold approach.\n    A saccade starts when a) the velocity is above threshold, b) the\n    acceleration is above acc_thresh at least once during the interval\n    defined by the velocity threshold, c) the saccade lasts at least min_duration\n    ms and d) the distance between saccade start and enpoint is at least\n    min_movement degrees.\n    '''\n    if ignore_blinks:\n        velocity, acceleration = get_velocity(samplemat, float(Hz), blinks=samplemat.blinks)\n    else:\n        velocity, acceleration = get_velocity(samplemat, float(Hz))\n\n    saccades = (velocity > threshold)\n    #print velocity[samplemat.blinks[1:]]\n    #print saccades[samplemat.blinks[1:]]\n\n    borders = np.where(np.diff(saccades.astype(int)))[0] + 1\n    if velocity[1] > threshold:\n        borders = np.hstack(([0], borders))\n    saccade = 0 * np.ones(samplemat.x.shape)\n\n    # Only count saccades when acceleration also surpasses threshold\n    for i, (start, end) in enumerate(zip(borders[0::2], borders[1::2])):\n        if sum(acceleration[start:end] > acc_thresh) >= 1:\n            saccade[start:end] = 1\n\n    borders = np.where(np.diff(saccade.astype(int)))[0] + 1\n    if saccade[0] == 0:\n        borders = np.hstack(([0], borders))\n    for i, (start, end) in enumerate(zip(borders[0::2], borders[1::2])):\n        if (1000*(end - start) / float(Hz)) < (min_duration):\n            saccade[start:end] = 1\n\n    # Delete saccade between fixations that are too close together.\n    dists_ok = False\n    while not dists_ok:\n        dists_ok = True\n        num_merges = 0\n        for i, (lfixstart, lfixend, start, end, nfixstart, nfixend) in enumerate(zip(\n                borders[0::2], borders[1::2],\n                borders[1::2], borders[2::2],\n                borders[2::2], borders[3::2])):\n            lastx = samplemat.x[lfixstart:lfixend].mean()\n            lasty = samplemat.y[lfixstart:lfixend].mean()\n            nextx = samplemat.x[nfixstart:nfixend].mean()\n            nexty = samplemat.y[nfixstart:nfixend].mean()\n            if (1000*(lfixend - lfixstart) / float(Hz)) < (min_duration):\n                saccade[lfixstart:lfixend] = 1\n                continue\n            distance = ((nextx - lastx) ** 2 + (nexty - lasty) ** 2) ** .5\n            if distance < min_movement:\n                num_merges += 1\n                dists_ok = False\n                saccade[start:end] = 0\n        borders = np.where(np.diff(saccade.astype(int)))[0] + 1\n        if saccade[0] == 0:\n            borders = np.hstack(([0], borders))\n    return saccade.astype(bool)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndetect fixation from saccades.", "response": "def fixation_detection(samplemat, saccades, Hz=200, samples2fix=None,\n                       respect_trial_borders=False, sample_times=None):\n    '''\n    Detect Fixation from saccades.\n\n    Fixations are defined as intervals between saccades. This function\n    also calcuates start and end times (in ms) for each fixation.\n    Input:\n        samplemat: datamat\n            Contains the recorded samples and associated metadata.\n        saccades: ndarray\n            Logical vector that is True for samples that belong to a saccade.\n        Hz: Float\n            Number of samples per second.\n        samples2fix: Dict\n            There is usually metadata associated with the samples (e.g. the\n            trial number). This dictionary can be used to specify how the\n            metadata should be collapsed for one fixation. It contains\n            field names from samplemat as keys and functions as values that\n            return one value when they are called with all samples for one\n            fixation. In addition the function can raise an 'InvalidFixation'\n            exception to signal that the fixation should be discarded.\n    '''\n    if samples2fix is None:\n        samples2fix = {}\n    fixations = ~saccades\n    acc = AccumulatorFactory()\n    if not respect_trial_borders:\n        borders = np.where(np.diff(fixations.astype(int)))[0] + 1\n    else:\n        borders = np.where(\n            ~(np.diff(fixations.astype(int)) == 0) |\n            ~(np.diff(samplemat.trial.astype(int)) == 0))[0] + 1\n\n    fixations = 0 * saccades.copy()\n    if not saccades[0]:\n        borders = np.hstack(([0], borders))\n    #lasts,laste = borders[0], borders[1]\n    for i, (start, end) in enumerate(zip(borders[0::2], borders[1::2])):\n\n        current = {}\n        for k in samplemat.fieldnames():\n            if k in list(samples2fix.keys()):\n                current[k] = samples2fix[k](samplemat, k, start, end)\n            else:\n                current[k] = np.mean(samplemat.field(k)[start:end])\n        current['start_sample'] = start\n        current['end_sample'] = end\n        fixations[start:end] = 1\n        # Calculate start and end time in ms\n        if sample_times is None:\n            current['start'] = 1000 * start / Hz\n            current['end'] = 1000 * end / Hz\n        else:\n            current['start'] = sample_times[start]\n            current['end'] = sample_times[end]\n\n        #lasts, laste = start,end\n        acc.update(current)\n\n    return acc.get_dm(params=samplemat.parameters()), fixations.astype(bool)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(parse_obj, agent=None, etag=None, modified=None, inject=False):\n\n    guarantees = common.SuperDict({\n        'bozo': 0,\n        'feeds': [],\n        'lists': [],\n        'opportunities': [],\n        'meta': common.SuperDict(),\n        'version': '',\n    })\n    fileobj, info = _mkfile(parse_obj, (agent or USER_AGENT), etag, modified)\n    guarantees.update(info)\n    if not fileobj:\n        return guarantees\n\n    handler = Handler()\n    handler.harvest.update(guarantees)\n    parser = xml.sax.make_parser()\n    parser.setFeature(xml.sax.handler.feature_namespaces, True)\n    parser.setContentHandler(handler)\n    parser.setErrorHandler(handler)\n    if inject:\n        fileobj = Injector(fileobj)\n    try:\n        parser.parse(fileobj)\n    except (SAXParseException, MalformedByteSequenceException):  # noqa: E501  # pragma: no cover\n        # Jython propagates exceptions past the ErrorHandler.\n        err = sys.exc_info()[1]\n        handler.harvest.bozo = 1\n        handler.harvest.bozo_exception = err\n    finally:\n        fileobj.close()\n\n    # Test if a DOCTYPE injection is needed\n    if hasattr(handler.harvest, 'bozo_exception'):\n        if 'entity' in handler.harvest.bozo_exception.__str__():\n            if not inject:\n                return parse(parse_obj, agent, etag, modified, True)\n    # Make it clear that the XML file is broken\n    # (if no other exception has been assigned)\n    if inject and not handler.harvest.bozo:\n        handler.harvest.bozo = 1\n        handler.harvest.bozo_exception = ListError('undefined entity found')\n    return handler.harvest", "response": "Parse a subscription list and return a dict containing the results."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef FixmatStimuliFactory(fm, loader):\n    # Find all feature names\n    features = [] \n    if loader.ftrpath:\n        assert os.access(loader.ftrpath, os.R_OK)   \n        features = os.listdir(os.path.join(loader.ftrpath, str(fm.category[0])))\n    # Find all images in all categories   \n    img_per_cat = {}\n    for cat in np.unique(fm.category):\n        if not loader.test_for_category(cat):\n            raise ValueError('Category %s is specified in fixmat but '%(\n                                str(cat) + 'can not be located by loader'))\n        img_per_cat[cat] = []\n        for img in np.unique(fm[(fm.category == cat)].filenumber):\n            if not loader.test_for_image(cat, img):\n                raise ValueError('Image %s in category %s is '%(str(cat), \n                    str(img)) + \n                    'specified in fixmat but can be located by loader')\n            img_per_cat[cat].append(img)\n            if loader.ftrpath:\n                for feature in features:\n                    if not loader.test_for_feature(cat, img, feature):\n                        raise RuntimeError(\n                            'Feature %s for image %s' %(str(feature),str(img)) +\n                            ' in category %s ' %str(cat) +\n                            'can not be located by loader') \n    return Categories(loader, img_per_cat = img_per_cat,\n         features = features, fixations = fm)", "response": "Returns a new object for all image and category combinations in a fixmat."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef DirectoryStimuliFactory(loader):\n    impath = loader.impath\n    ftrpath = loader.ftrpath\n    # checks whether user has reading permission for the path\n    assert os.access(impath, os.R_OK)\n    assert os.access(ftrpath, os.R_OK)    \n\n    # EXTRACTING IMAGE NAMES\n    img_per_cat = {}\n    # extract only directories in the given folder\n    subfolders = [name for name in os.listdir(impath) if os.path.isdir(\n        os.path.join(impath, name))]\n    # if there are no subfolders, walk through files. Take 1 as key for the \n    # categories object\n    if not subfolders:\n        [_, _, files] = next(os.walk(os.path.join(impath)))\n        # this only takes entries that end with '.png'\n        entries = {1: \n            [int(cur_file[cur_file.find('_')+1:-4]) for cur_file\n            in files if cur_file.endswith('.png')]}\n        img_per_cat.update(entries)\n        subfolders = ['']\n    # if there are subfolders, walk through them\n    else:\n        for directory in subfolders:\n            [_, _, files] = next(os.walk(os.path.join(impath, directory)))\n            # this only takes entries that end with '.png'. Strips ending and\n            # considers everything after the first '_' as the imagenumber\n            imagenumbers = [int(cur_file[cur_file.find('_')+1:-4]) \n                    for cur_file in files\n                        if (cur_file.endswith('.png') & (len(cur_file) > 4))]\n            entries = {int(directory): imagenumbers}\n            img_per_cat.update(entries)\n            del directory\n    del imagenumbers\n\n    # in case subfolders do not exist, '' is appended here.\n    _, features, files = next(os.walk(os.path.join(ftrpath, \n                                            subfolders[0])))\n    return Categories(loader, img_per_cat = img_per_cat, features = features)", "response": "This function creates a directory - independent structure for the given folder - and image - files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fixations(self):\n        ''' Filter the fixmat such that it only contains fixations on images\n        in categories that are also in the categories object'''\n        if not self._fixations:\n            raise RuntimeError('This Images object does not have'\n                +' an associated fixmat')\n        if len(list(self._categories.keys())) == 0:\n            return None\n        else:\n            idx = np.zeros(self._fixations.x.shape, dtype='bool')\n            for (cat, _) in list(self._categories.items()):\n                idx = idx | ((self._fixations.category == cat))\n            return self._fixations[idx]", "response": "Filter the fixmat such that it only contains fixations on images\n        in categories that are also in the categories object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data(self, value):\n        self.loader.save_image(self.category, self.image, value)", "response": "Saves a new image to disk"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of fixations that are associated with this image.", "response": "def fixations(self):\n        \"\"\"\n        Returns all fixations that are on this image.\n        A precondition for this to work is that a fixmat \n        is associated with this Image object.\n        \"\"\"\n        if not self._fixations:\n            raise RuntimeError('This Images object does not have'\n                +' an associated fixmat')\n        return self._fixations[(self._fixations.category == self.category) &\n                               (self._fixations.filenumber == self.image)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npreparing data for a single set of fixmat objects.", "response": "def prepare_data(fm, max_back, dur_cap=700):\n    '''\n    Computes angle and length differences up to given order and deletes\n    suspiciously long fixations.\n\n    Input\n        fm: Fixmat\n            Fixmat for which to comput angle and length differences\n        max_back: Int\n            Computes delta angle and amplitude up to order max_back.\n        dur_cap: Int\n            Longest allowed fixation duration\n\n    Output\n        fm: Fixmat\n            Filtered fixmat that aligns to the other outputs.\n        durations: ndarray\n            Duration for each fixation in fm\n        forward_angle:\n            Angle between previous and next saccade.\n\n    '''\n    durations = np.roll(fm.end - fm.start, 1).astype(float)\n    angles, lengths, ads, lds = anglendiff(fm, roll=max_back, return_abs=True)\n    # durations and ads are aligned in a way that an entry in ads\n    # encodes the angle of the saccade away from a fixation in\n    # durations\n    forward_angle = abs(reshift(ads[0])).astype(float)\n    ads = [abs(reshift(a)) for a in ads]\n    # Now filter out weird fixation durations\n    id_in = durations > dur_cap\n    durations[id_in] = np.nan\n    forward_angle[id_in] = np.nan\n    return fm, durations, forward_angle, ads, lds"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the mean fixation duration at forward angles.", "response": "def saccadic_momentum_effect(durations, forward_angle,\n                             summary_stat=nanmean):\n    \"\"\"\n    Computes the mean fixation duration at forward angles.\n    \"\"\"\n    durations_per_da = np.nan * np.ones((len(e_angle) - 1,))\n    for i, (bo, b1) in enumerate(zip(e_angle[:-1], e_angle[1:])):\n        idx = (\n            bo <= forward_angle) & (\n            forward_angle < b1) & (\n            ~np.isnan(durations))\n        durations_per_da[i] = summary_stat(durations[idx])\n    return durations_per_da"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes a measure of fixation durations at delta angle and delta length combinations.", "response": "def ior_effect(durations, angle_diffs, length_diffs,\n               summary_stat=np.mean, parallel=True, min_samples=20):\n    \"\"\"\n    Computes a measure of fixation durations at delta angle and delta\n    length combinations.\n    \"\"\"\n    raster = np.empty((len(e_dist) - 1, len(e_angle) - 1), dtype=object)\n    for a, (a_low, a_upp) in enumerate(zip(e_angle[:-1], e_angle[1:])):\n        for d, (d_low, d_upp) in enumerate(zip(e_dist[:-1], e_dist[1:])):\n            idx = ((d_low <= length_diffs) & (length_diffs < d_upp) &\n                   (a_low <= angle_diffs) & (angle_diffs < a_upp))\n            if sum(idx) < min_samples:\n                raster[d, a] = np.array([np.nan])\n            else:\n                raster[d, a] = durations[idx]\n    if parallel:\n        p = pool.Pool(3)\n        result = p.map(summary_stat, list(raster.flatten()))\n        p.terminate()\n    else:\n        result = list(map(summary_stat, list(raster.flatten())))\n    for idx, value in enumerate(result):\n        i, j = np.unravel_index(idx, raster.shape)\n        raster[i, j] = value\n    return raster"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef predict_fixation_duration(\n        durations, angles, length_diffs, dataset=None, params=None):\n    \"\"\"\n    Fits a non-linear piecewise regression to fixtaion durations for a fixmat.\n\n    Returns corrected fixation durations.\n    \"\"\"\n    if dataset is None:\n        dataset = np.ones(durations.shape)\n    corrected_durations = np.nan * np.ones(durations.shape)\n    for i, ds in enumerate(np.unique(dataset)):\n        e = lambda v, x, y, z: (leastsq_dual_model(x, z, *v) - y)\n        v0 = [120, 220.0, -.1, 0.5, .1, .1]\n        id_ds = dataset == ds\n        idnan = (\n            ~np.isnan(angles)) & (\n            ~np.isnan(durations)) & (\n            ~np.isnan(length_diffs))\n        v, s = leastsq(\n            e, v0, args=(\n                angles[\n                    idnan & id_ds], durations[\n                    idnan & id_ds], length_diffs[\n                    idnan & id_ds]), maxfev=10000)\n        corrected_durations[id_ds] = (durations[id_ds] -\n                                      (leastsq_dual_model(angles[id_ds], length_diffs[id_ds], *v)))\n        if params is not None:\n            params['v' + str(i)] = v\n            params['s' + str(i)] = s\n    return corrected_durations", "response": "Predicts fixtaion durations for a fixmat."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the saccadic momentum effect for individual subjects.", "response": "def subject_predictions(fm, field='SUBJECTINDEX',\n                        method=predict_fixation_duration, data=None):\n    '''\n    Calculates the saccadic momentum effect for individual subjects.\n\n    Removes any effect of amplitude differences.\n\n    The parameters are fitted on unbinned data. The effects are\n    computed on binned data. See e_dist and e_angle for the binning\n    parameter.\n    '''\n    if data is None:\n        fma, dura, faa, adsa, ldsa = prepare_data(fm, dur_cap=700, max_back=5)\n        adsa = adsa[0]\n        ldsa = ldsa[0]\n    else:\n        fma, dura, faa, adsa, ldsa = data\n    fma = fma.copy()  # [ones(fm.x.shape)]\n    sub_effects = []\n    sub_predictions = []\n    parameters = []\n    for i, fmsub in enumerate(np.unique(fma.field(field))):\n        id = fma.field(field) == fmsub\n        #_, dur, fa, ads, lds = prepare_data(fmsub, dur_cap = 700, max_back=5)\n        dur, fa, ads, lds = dura[id], faa[id], adsa[id], ldsa[id]\n        params = {}\n        _ = method(dur, fa, lds, params=params)\n        ps = params['v0']\n        ld_corrected = leastsq_only_dist(lds, ps[4], ps[5])\n        prediction = leastsq_only_angle(fa, ps[0], ps[1], ps[2], ps[3])\n        sub_predictions += [saccadic_momentum_effect(prediction, fa)]\n        sub_effects += [saccadic_momentum_effect(dur - ld_corrected, fa)]\n        parameters += [ps]\n    return np.array(sub_effects), np.array(sub_predictions), parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef intersubject_scores(fm, category, predicting_filenumbers,\n                        predicting_subjects, predicted_filenumbers,\n                        predicted_subjects, controls = True, scale_factor = 1):\n    \"\"\"\n    Calculates how well the fixations from a set of subjects on a set of\n    images can be predicted with the fixations from another set of subjects\n    on another set of images.\n\n    The prediction is carried out by computing a fixation density map from\n    fixations of predicting_subjects subjects on predicting_images images.\n    Prediction accuracy is assessed by measures.prediction_scores.\n\n    Parameters\n        fm : fixmat instance\n        category : int\n            Category from which the fixations are taken.\n        predicting_filenumbers : list\n            List of filenumbers used for prediction, i.e. images where fixations\n            for the prediction are taken from.\n        predicting_subjects : list\n            List of subjects whose fixations on images in predicting_filenumbers\n            are used for the prediction.\n        predicted_filenumnbers : list\n            List of images from which the to be predicted fixations are taken.\n        predicted_subjects : list\n            List of subjects used for evaluation, i.e subjects whose fixations\n            on images in predicted_filenumbers are taken for evaluation.\n        controls : bool, optional\n            If True (default), n_predict subjects are chosen from the fixmat.\n            If False, 1000 fixations are randomly generated and used for\n            testing.\n        scale_factor : int, optional\n            specifies the scaling of the fdm. Default is 1.\n\n    Returns\n        auc : area under the roc curve for sets of actuals and controls\n        true_pos_rate : ndarray\n            Rate of true positives for every given threshold value.\n            All values appearing in actuals are taken as thresholds. Uses lower\n            sum interpolation.\n        false_pos_rate : ndarray\n            See true_pos_rate but for false positives.\n\n    \"\"\"\n    predicting_fm = fm[\n        (ismember(fm.SUBJECTINDEX, predicting_subjects)) &\n        (ismember(fm.filenumber, predicting_filenumbers)) &\n        (fm.category == category)]\n    predicted_fm = fm[\n        (ismember(fm.SUBJECTINDEX,predicted_subjects)) &\n        (ismember(fm.filenumber,predicted_filenumbers))&\n        (fm.category == category)]\n    try:\n        predicting_fdm = compute_fdm(predicting_fm, scale_factor = scale_factor)\n    except RuntimeError:\n        predicting_fdm = None\n\n    if controls == True:\n        fm_controls = fm[\n            (ismember(fm.SUBJECTINDEX, predicted_subjects)) &\n            ((ismember(fm.filenumber, predicted_filenumbers)) != True) &\n            (fm.category == category)]\n        return measures.prediction_scores(predicting_fdm, predicted_fm,\n            controls = (fm_controls.y, fm_controls.x))\n    return measures.prediction_scores(predicting_fdm, predicted_fm, controls = None)", "response": "This function calculates the fixation density map from a set of subjects on a set of images and predicting the set of subjects on a set of images."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning that uses intersubject_auc to compute the scores of random subjects on one image can be predicted with the fixations of m other random subjects.", "response": "def intersubject_scores_random_subjects(fm, category, filenumber, n_train,\n                                        n_predict, controls=True,\n                                        scale_factor = 1):\n    \"\"\"\n    Calculates how well the fixations of n random subjects on one image can\n    be predicted with the fixations of m other random subjects.\n\n    Notes\n        Function that uses intersubject_auc for computing auc.\n\n    Parameters\n        fm : fixmat instance\n        category : int\n            Category from which the fixations are taken.\n        filnumber : int\n            Image from which fixations are taken.\n        n_train : int\n            The number of subjects which are used for prediction.\n        n_predict : int\n            The number of subjects to predict\n        controls : bool, optional\n            If True (default), n_predict subjects are chosen from the fixmat.\n            If False, 1000 fixations are randomly generated and used for\n            testing.\n        scale_factor : int, optional\n            specifies the scaling of the fdm. Default is 1.\n\n    Returns\n        tuple : prediction scores\n    \"\"\"\n    subjects = np.unique(fm.SUBJECTINDEX)\n    if len(subjects) < n_train + n_predict:\n        raise ValueError(\"\"\"Not enough subjects in fixmat\"\"\")\n    # draw a random sample of subjects for testing and evaluation, according\n    # to the specified set sizes (n_train, n_predict)\n    np.random.shuffle(subjects)\n    predicted_subjects  = subjects[0 : n_predict]\n    predicting_subjects = subjects[n_predict : n_predict + n_train]\n    assert len(predicting_subjects) == n_train\n    assert len(predicted_subjects) == n_predict\n    assert [x not in predicting_subjects for x in predicted_subjects]\n    return intersubject_scores(fm, category, [filenumber], predicting_subjects,\n        [filenumber], predicted_subjects,\n        controls, scale_factor)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the inter - subject consistency upper bound for a fixmat instance.", "response": "def upper_bound(fm, nr_subs = None, scale_factor = 1):\n    \"\"\"\n    compute the inter-subject consistency upper bound for a fixmat.\n\n    Input:\n        fm : a fixmat instance\n        nr_subs : the number of subjects used for the prediction. Defaults\n                  to the total number of subjects in the fixmat minus 1\n        scale_factor : the scale factor of the FDMs. Default is 1.\n    Returns:\n        A list of scores; the list contains one dictionary for each measure.\n        Each dictionary contains one key for each category and corresponding\n        values is an array with scores for each subject.\n    \"\"\"\n    nr_subs_total = len(np.unique(fm.SUBJECTINDEX))\n    if not nr_subs:\n        nr_subs = nr_subs_total - 1\n    assert (nr_subs < nr_subs_total)\n    # initialize output structure; every measure gets one dict with\n    # category numbers as keys and numpy-arrays as values\n    intersub_scores = []\n    for measure in range(len(measures.scores)):\n        res_dict = {}\n        result_vectors = [np.empty(nr_subs_total) + np.nan\n                            for _ in np.unique(fm.category)]\n        res_dict.update(list(zip(np.unique(fm.category), result_vectors)))\n        intersub_scores.append(res_dict)\n    #compute inter-subject scores for every stimulus, with leave-one-out\n    #over subjects\n    for fm_cat in fm.by_field('category'):\n        cat = fm_cat.category[0]\n        for (sub_counter, sub) in enumerate(np.unique(fm_cat.SUBJECTINDEX)):\n            image_scores = []\n            for fm_single in fm_cat.by_field('filenumber'):\n                predicting_subs = (np.setdiff1d(np.unique(\n                    fm_single.SUBJECTINDEX),[sub]))\n                np.random.shuffle(predicting_subs)\n                predicting_subs = predicting_subs[0:nr_subs]\n                predicting_fm = fm_single[\n                    (ismember(fm_single.SUBJECTINDEX, predicting_subs))]\n                predicted_fm = fm_single[fm_single.SUBJECTINDEX == sub]\n                try:\n                    predicting_fdm = compute_fdm(predicting_fm,\n                        scale_factor = scale_factor)\n                except RuntimeError:\n                    predicting_fdm = None\n                image_scores.append(measures.prediction_scores(\n                                        predicting_fdm, predicted_fm))\n            for (measure, score) in enumerate(nanmean(image_scores, 0)):\n                intersub_scores[measure][cat][sub_counter] = score\n    return intersub_scores"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the spatial bias lower bound for a fixmat instance.", "response": "def lower_bound(fm, nr_subs = None, nr_imgs = None, scale_factor = 1):\n    \"\"\"\n    Compute the spatial bias lower bound for a fixmat.\n\n    Input:\n        fm : a fixmat instance\n        nr_subs : the number of subjects used for the prediction. Defaults\n                  to the total number of subjects in the fixmat minus 1\n        nr_imgs : the number of images used for prediction. If given, the\n                  same number will be used for every category. If not given,\n                  leave-one-out will be used in all categories.\n        scale_factor : the scale factor of the FDMs. Default is 1.\n    Returns:\n        A list of spatial bias scores; the list contains one dictionary for each\n         measure. Each dictionary contains one key for each category and\n        corresponding values is an array with scores for each subject.\n    \"\"\"\n    nr_subs_total = len(np.unique(fm.SUBJECTINDEX))\n    if nr_subs is None:\n        nr_subs = nr_subs_total - 1\n    assert (nr_subs < nr_subs_total)\n    # initialize output structure; every measure gets one dict with\n    # category numbers as keys and numpy-arrays as values\n    sb_scores = []\n    for measure in range(len(measures.scores)):\n        res_dict = {}\n        result_vectors = [np.empty(nr_subs_total) + np.nan\n                            for _ in np.unique(fm.category)]\n        res_dict.update(list(zip(np.unique(fm.category),result_vectors)))\n        sb_scores.append(res_dict)\n    # compute mean spatial bias predictive power for all subjects in all\n    # categories\n    for fm_cat in fm.by_field('category'):\n        cat = fm_cat.category[0]\n        nr_imgs_cat = len(np.unique(fm_cat.filenumber))\n        if not nr_imgs:\n            nr_imgs_current = nr_imgs_cat - 1\n        else:\n            nr_imgs_current = nr_imgs\n        assert(nr_imgs_current < nr_imgs_cat)\n        for (sub_counter, sub) in enumerate(np.unique(fm.SUBJECTINDEX)):\n            image_scores = []\n            for fm_single in fm_cat.by_field('filenumber'):\n                # Iterating by field filenumber makes filenumbers\n                # in fm_single unique: Just take the first one to get the\n                # filenumber for this fixmat\n                fn = fm_single.filenumber[0]\n                predicting_subs = (np.setdiff1d(np.unique(\n                    fm_cat.SUBJECTINDEX), [sub]))\n                np.random.shuffle(predicting_subs)\n                predicting_subs = predicting_subs[0:nr_subs]\n                predicting_fns = (np.setdiff1d(np.unique(\n                    fm_cat.filenumber), [fn]))\n                np.random.shuffle(predicting_fns)\n                predicting_fns = predicting_fns[0:nr_imgs_current]\n                predicting_fm = fm_cat[\n                    (ismember(fm_cat.SUBJECTINDEX, predicting_subs)) &\n                    (ismember(fm_cat.filenumber, predicting_fns))]\n                predicted_fm = fm_single[fm_single.SUBJECTINDEX == sub]\n                try:\n                    predicting_fdm = compute_fdm(predicting_fm,\n                        scale_factor = scale_factor)\n                except RuntimeError:\n                    predicting_fdm = None\n                image_scores.append(measures.prediction_scores(predicting_fdm,\n                     predicted_fm))\n            for (measure, score) in enumerate(nanmean(image_scores, 0)):\n                sb_scores[measure][cat][sub_counter] = score\n    return sb_scores"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ind2sub(ind, dimensions):\n    # check that the index is within range\n    if ind >= np.prod(dimensions):\n        raise RuntimeError(\"ind2sub: index exceeds array size\")\n    cum_dims = list(dimensions)\n    cum_dims.reverse()\n    m = 1\n    mult = []\n    for d in cum_dims:\n        m = m*d\n        mult.append(m)\n    mult.pop()\n    mult.reverse()\n    mult.append(1)\n    indices = []\n    for d in mult:\n        indices.append((ind/d)+1)\n        ind = ind - (ind/d)*d\n    return indices", "response": "Calculates subscripts for indices into regularly spaced matrixes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sub2ind(indices, dimensions):\n    # check that none of the indices exceeds the size of the array\n    if any([i > j for i, j in zip(indices, dimensions)]):\n        raise RuntimeError(\"sub2ind:an index exceeds its dimension's size\")\n    dims = list(dimensions)\n    dims.append(1)\n    dims.remove(dims[0])\n    dims.reverse()\n    ind  = list(indices)\n    ind.reverse()\n    idx = 0\n    mult = 1\n    for (cnt, dim) in zip(ind, dims):\n        mult = dim*mult\n        idx = idx + (cnt-1)*mult    \n    return idx", "response": "A sub2ind implementation to create randomization \n    scripts. This function calculates indices from subscripts into regularly spaced\n    matrixes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef RestoreTaskStoreFactory(store_class, chunk_size, restore_file, save_file):\n    intm_results = np.load(restore_file)\n    intm = intm_results[intm_results.files[0]]\n    idx = np.isnan(intm).flatten().nonzero()[0]\n    partitions = math.ceil(len(idx) / float(chunk_size))\n    task_store = store_class(partitions, idx.tolist(), save_file)\n    task_store.num_tasks = len(idx)\n    # Also set up matrices for saving results\n    for f in intm_results.files:\n        task_store.__dict__[f] = intm_results[f]\n    return task_store", "response": "Restores a task store from file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xmlrpc_reschedule(self):\n        if not len(self.scheduled_tasks) == 0:\n            self.reschedule = list(self.scheduled_tasks.items())\n            self.scheduled_tasks = {}\n        return True", "response": "Reschedule all running tasks."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new task description", "response": "def xmlrpc_get_task(self):\n        \"\"\"\n        Return a new task description: ID and necessary parameters, \n        all are given in a dictionary\n        \"\"\"\n        try:\n            if len(self.reschedule) == 0:\n                (task_id, cur_task) = next(self.task_iterator)\n            else:\n                (task_id, cur_task) = self.reschedule.pop()\n            self.scheduled_tasks.update({task_id: cur_task})\n            return (task_id, cur_task.to_dict())\n        except StopIteration:\n            print('StopIteration: No more tasks')\n            return False\n        except Exception as err:\n            print('Some other error')\n            print(err)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls when the task is done.", "response": "def xmlrpc_task_done(self, result):\n        \"\"\"\n        Take the results of a computation and put it into the results list.\n        \"\"\"\n        (task_id, task_results) = result\n        del self.scheduled_tasks[task_id]\n        self.task_store.update_results(task_id, task_results)\n        self.results += 1\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef xmlrpc_status(self):\n        return (\"\"\"\n        %i Jobs are still wating for execution\n        %i Jobs are being processed\n        %i Jobs are done\n        \"\"\" %(self.task_store.partitions - \n                self.results - \n                len(self.scheduled_tasks),\n              len(self.scheduled_tasks),\n              self.results))", "response": "Return a status message for the current process"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef xmlrpc_save2file(self, filename):\n        savefile = open(filename,'wb')\n        try:\n            pickle.dump({'scheduled':self.scheduled_tasks,\n                          'reschedule':self.reschedule},savefile)\n        except pickle.PicklingError:\n            return -1\n        savefile.close()\n        return 1", "response": "Save results and own state into file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        (task_id, tasks) = self.server.get_task()\n        self.task_store.from_dict(tasks)\n        for (index, task) in self.task_store:\n            result = self.compute(index, task)\n            self.results.append(result)\n        self.server.task_done((task_id, self.results))", "response": "This function is called to start the computation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dict(self, description):\n        assert(self.ident == description['ident'])\n        self.partitions = description['partitions']\n        self.indices    = description['indices']", "response": "Configures the task store to be the task_store described \n            in description"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfitting a 3D distribution with splines.", "response": "def fit3d(samples, e_x, e_y, e_z, remove_zeros = False, **kw):\n    \"\"\"Fits a 3D distribution with splines.\n\n    Input:\n        samples: Array\n            Array of samples from a probability distribution\n        e_x: Array\n            Edges that define the events in the probability \n            distribution along the x direction. For example, \n            e_x[0] < samples[0] <= e_x[1] picks out all \n            samples that are associated with the first event.\n        e_y: Array\n            See e_x, but for the y direction.\n        remove_zeros: Bool\n            If True, events that are not observed will not \n            be part of the fitting process. If False, those \n            events will be modelled as finfo('float').eps \n        **kw: Arguments that are passed on to spline_bse1d.\n\n    Returns:\n        distribution: Array\n            An array that gives an estimate of probability for \n            events defined by e.\n        knots: Tuple of arrays\n            Sequence of knots that were used for the spline basis (x,y) \n    \"\"\"\n    height, width, depth = len(e_y)-1, len(e_x)-1, len(e_z)-1 \n    \n    (p_est, _) = np.histogramdd(samples, (e_x, e_y, e_z))\n    p_est = p_est/sum(p_est.flat)\n    p_est = p_est.flatten()\n    if remove_zeros:\n        non_zero = ~(p_est == 0)\n    else:\n        non_zero = (p_est >= 0)\n    basis = spline_base3d(width,height, depth, **kw)\n    model = linear_model.BayesianRidge()\n    model.fit(basis[:, non_zero].T, p_est[:,np.newaxis][non_zero,:])\n    return (model.predict(basis.T).reshape((width, height, depth)), \n                p_est.reshape((width, height, depth)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit2d(samples,e_x, e_y, remove_zeros = False, p_est = None,  **kw):\n    if p_est is None:\n        height = len(e_y)-1\n        width = len(e_x)-1   \n        (p_est, _) = np.histogramdd(samples, (e_x, e_y))\n    else:\n        p_est = p_est.T\n        width, height = p_est.shape\n    # p_est contains x in dim 1 and y in dim 0\n    shape = p_est.shape\n    p_est = (p_est/sum(p_est.flat)).reshape(shape)\n    mx =  p_est.sum(1)\n    my = p_est.sum(0)\n    # Transpose hist to have x in dim 0\n    p_est = p_est.T.flatten()\n    basis, knots = spline_base2d(width, height, marginal_x = mx, marginal_y = my, **kw)\n    model = linear_model.BayesianRidge()\n    if remove_zeros:\n        non_zero = ~(p_est == 0)\n        model.fit(basis[:, non_zero].T, p_est[non_zero])\n    else:\n        non_zero = (p_est >= 0)\n        p_est[~non_zero,:] = np.finfo(float).eps\n        model.fit(basis.T, p_est)\n    return (model.predict(basis.T).reshape((height, width)), \n            p_est.reshape((height, width)), knots)", "response": "Fits a 2D distribution with splines."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfits a 1D distribution with splines.", "response": "def fit1d(samples, e, remove_zeros = False, **kw):\n    \"\"\"Fits a 1D distribution with splines.\n\n    Input:\n        samples: Array\n            Array of samples from a probability distribution\n        e: Array\n            Edges that define the events in the probability \n            distribution. For example, e[0] < x <= e[1] is\n            the range of values that are associated with the\n            first event.\n        **kw: Arguments that are passed on to spline_bse1d.\n\n    Returns:\n        distribution: Array\n            An array that gives an estimate of probability for \n            events defined by e.\n        knots: Array\n            Sequence of knots that were used for the spline basis\n    \"\"\"\n    samples = samples[~np.isnan(samples)]\n    length = len(e)-1\n    hist,_ = np.histogramdd(samples, (e,))\n    hist = hist/sum(hist)\n    basis, knots = spline_base1d(length, marginal = hist, **kw)\n    non_zero = hist>0\n    model = linear_model.BayesianRidge()\n    if remove_zeros:\n        model.fit(basis[non_zero, :], hist[:,np.newaxis][non_zero,:])\n    else:\n        hist[~non_zero] = np.finfo(float).eps\n        model.fit(basis, hist[:,np.newaxis])\n    return model.predict(basis), hist, knots"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef knots_from_marginal(marginal, nr_knots, spline_order):\n    cumsum = np.cumsum(marginal)\n    cumsum = cumsum/cumsum.max()\n    borders = np.linspace(0,1,nr_knots)\n    knot_placement = [0] + np.unique([np.where(cumsum>=b)[0][0] for b in borders[1:-1]]).tolist() +[len(marginal)-1]\n    knots = augknt(knot_placement, spline_order)\n    return knots", "response": "This function calculates the knot placement based on a marginal distribution."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes a 1D spline base for each entry in the list of knots.", "response": "def spline_base1d(length, nr_knots = 20, spline_order = 5, marginal = None):\n    \"\"\"Computes a 1D spline basis\n    \n    Input:\n        length: int\n            length  of each basis\n        nr_knots: int\n            Number of knots, i.e. number of basis functions.\n        spline_order: int\n            Order of the splines.\n        marginal: array, optional\n            Estimate of the marginal distribution of the input to be fitted. \n            If given, it is used to determine the positioning of knots, each \n            knot will cover the same amount of probability mass. If not given,\n            knots are equally spaced.\n    \"\"\"\n    if marginal is None:\n        knots = augknt(np.linspace(0,length+1, nr_knots), spline_order)\n    else:\n        knots = knots_from_marginal(marginal, nr_knots, spline_order)\n        \n    x_eval = np.arange(1,length+1).astype(float)\n    Bsplines    = spcol(x_eval,knots,spline_order)\n    return Bsplines, knots"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef spline_base2d(width, height, nr_knots_x = 20.0, nr_knots_y = 20.0, \n        spline_order = 5, marginal_x = None, marginal_y = None):\n    \"\"\"Computes a set of 2D spline basis functions. \n    \n    The basis functions cover the entire space in height*width and can \n    for example be used to create fixation density maps. \n\n    Input:\n        width: int\n            width  of each basis\n        height: int \n            height of each basis\n        nr_knots_x: int\n            of knots in x (width) direction.\n        nr_knots_y: int\n            of knots in y (height) direction.\n        spline_order: int\n            Order of the spline.\n        marginal_x: array, optional\n            Estimate of marginal distribution of the input to be fitted\n            along the x-direction (width). If given, it is used to determine \n            the positioning of knots, each knot will cover the same amount \n            of probability mass. If not given, knots are equally spaced.\n        marginal_y: array, optional\n            Marginal distribution along the y-direction (height). If\n            given, it is used to determine the positioning of knots.\n            Each knot will cover the same amount of probability mass.\n    Output:\n        basis: Matrix \n            Matrix of size n*(width*height) that contains in each row\n            one vectorized basis. \n        knots: Tuple \n            (x,y) are knot arrays that show the placement of knots.\n    \"\"\"\n    if not (nr_knots_x<width and nr_knots_y<height):\n        raise RuntimeError(\"Too many knots for size of the base\")\n    if marginal_x is None:\n        knots_x         = augknt(np.linspace(0,width+1,nr_knots_x), spline_order)\n    else:\n        knots_x = knots_from_marginal(marginal_x, nr_knots_x, spline_order) \n    if marginal_y is None:\n        knots_y         = augknt(np.linspace(0,height+1, nr_knots_y), spline_order)\n    else:\n        knots_y = knots_from_marginal(marginal_y, nr_knots_y, spline_order)\n    x_eval = np.arange(1,width+1).astype(float)\n    y_eval = np.arange(1,height+1).astype(float)    \n    spline_setx = spcol(x_eval, knots_x, spline_order)\n    spline_sety = spcol(y_eval, knots_y, spline_order)\n    nr_coeff = [spline_sety.shape[1], spline_setx.shape[1]]\n    dim_bspline = [nr_coeff[0]*nr_coeff[1], len(x_eval)*len(y_eval)]\n    # construct 2D B-splines \n    nr_basis = 0\n    bspline = np.zeros(dim_bspline)\n    for IDX1 in range(0,nr_coeff[0]):\n        for IDX2 in range(0, nr_coeff[1]):\n            rand_coeff  = np.zeros((nr_coeff[0] , nr_coeff[1]))\n            rand_coeff[IDX1,IDX2] = 1\n            tmp = np.dot(spline_sety,rand_coeff)\n            bspline[nr_basis,:] = np.dot(tmp,spline_setx.T).reshape((1,-1))\n            nr_basis = nr_basis+1\n    return bspline, (knots_x, knots_y)", "response": "Computes a set of 2D spline functions that cover the entire space in width and height."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spline_base3d( width, height, depth, nr_knots_x = 10.0, nr_knots_y = 10.0,\n        nr_knots_z=10, spline_order = 3, marginal_x = None, marginal_y = None, \n        marginal_z = None):\n    \"\"\"Computes a set of 3D spline basis functions. \n    \n    For a description of the parameters see spline_base2d.\n    \"\"\"  \n    if not nr_knots_z < depth:\n        raise RuntimeError(\"Too many knots for size of the base\")\n    basis2d, (knots_x, knots_y) = spline_base2d(height, width, nr_knots_x, \n            nr_knots_y, spline_order, marginal_x, marginal_y)\n    if marginal_z is not None:\n        knots_z = knots_from_marginal(marginal_z, nr_knots_z, spline_order)\n    else:\n        knots_z = augknt(np.linspace(0,depth+1, nr_knots_z), spline_order)\n    z_eval = np.arange(1,depth+1).astype(float)\n    spline_setz = spcol(z_eval, knots_z, spline_order)\n    bspline = np.zeros((basis2d.shape[0]*len(z_eval), height*width*depth))\n    basis_nr = 0\n    for spline_a in spline_setz.T:\n        for spline_b in basis2d:\n            spline_b = spline_b.reshape((height, width))\n            bspline[basis_nr, :] = (spline_b[:,:,np.newaxis] * spline_a[:]).flat\n            basis_nr +=1\n    return bspline, (knots_x, knots_y, knots_z)", "response": "Computes a set of 3D spline functions."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nevaluate the ith spline basis given by knots on points in x", "response": "def spline(x,knots,p,i=0.0):\n    \"\"\"Evaluates the ith spline basis given by knots on points in x\"\"\"\n    assert(p+1<len(knots))\n    return np.array([N(float(u),float(i),float(p),knots) for u in x])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef spcol(x,knots,spline_order):\n    colmat = np.nan*np.ones((len(x),len(knots) - spline_order-1))\n    for i in range(0,len(knots) - spline_order -1):\n        colmat[:,i] = spline(x,knots,spline_order,i)\n    return colmat", "response": "Computes the spline colocation matrix for knots in x."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef augknt(knots,order):\n    a = []\n    [a.append(knots[0]) for t in range(0,order)]\n    [a.append(k) for k in knots]\n    [a.append(knots[-1]) for t in range(0,order)]\n    return np.array(a)", "response": "Augment knot sequence such that some boundary conditions \n    are met."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the spline basis of order p at knot i and point u.", "response": "def N(u,i,p,knots):\n    \"\"\"Compute Spline Basis\n    \n    Evaluates the spline basis of order p defined by knots \n    at knot i and point u.\n    \"\"\"\n    if p == 0:\n        if knots[i] < u and u <=knots[i+1]:\n            return 1.0\n        else:\n            return 0.0\n    else:\n        try:\n            k = (( float((u-knots[i]))/float((knots[i+p] - knots[i]) )) \n                    * N(u,i,p-1,knots))\n        except ZeroDivisionError:\n            k = 0.0\n        try:\n            q = (( float((knots[i+p+1] - u))/float((knots[i+p+1] - knots[i+1])))\n                    * N(u,i+1,p-1,knots))\n        except ZeroDivisionError:\n            q  = 0.0 \n        return float(k + q)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prediction_scores(prediction, fm, **kw):\n    if prediction == None:\n        return [np.NaN for measure in scores]\n    results = []\n    for measure in scores:\n        (args, _, _, _) = inspect.getargspec(measure)\n        if len(args)>2:\n            # Filter dictionary, such that only the keys that are\n            # expected by the measure are in it\n            mdict = {}\n            [mdict.update({key:value}) for (key, value) in list(kw.items())\n                if key in args]\n            score = measure(prediction, fm, **mdict)\n        else:\n            score = measure(prediction, fm)\n        results.append(score)\n    return results", "response": "Evaluates a prediction against a fixmat with different measures."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating the kldiv function for model evaluation", "response": "def kldiv_model(prediction, fm):\n    \"\"\"\n    wraps kldiv functionality for model evaluation\n\n    input:\n        prediction: 2D matrix\n            the model salience map\n        fm : fixmat\n            Should be filtered for the image corresponding to the prediction\n    \"\"\"\n    (_, r_x) = calc_resize_factor(prediction, fm.image_size)\n    q = np.array(prediction, copy=True)\n    q -= np.min(q.flatten())\n    q /= np.sum(q.flatten())\n    return kldiv(None, q, distp = fm, scale_factor = r_x)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kldiv(p, q, distp = None, distq = None, scale_factor = 1):\n    assert q != None or distq != None, \"Either q or distq have to be given\"\n    assert p != None or distp != None, \"Either p or distp have to be given\"\n\n    try:\n        if p == None:\n            p = compute_fdm(distp, scale_factor = scale_factor)\n        if q == None:\n            q = compute_fdm(distq, scale_factor = scale_factor)\n    except RuntimeError:\n        return np.NaN\n\n    q += np.finfo(q.dtype).eps\n    p += np.finfo(p.dtype).eps\n    kl = np.sum( p * (np.log2(p / q)))\n    return kl", "response": "Computes the Kullback - Leibler divergence between two distributions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes Chao - Shen corrected KL - divergence between prediction and fdm made from fixations in fm.", "response": "def kldiv_cs_model(prediction, fm):\n    \"\"\"\n    Computes Chao-Shen corrected KL-divergence between prediction\n    and fdm made from fixations in fm.\n\n    Parameters :\n        prediction : np.ndarray\n            a fixation density map\n        fm : FixMat object\n    \"\"\"\n    # compute histogram of fixations needed for ChaoShen corrected kl-div\n    # image category must exist (>-1) and image_size must be non-empty\n    assert(len(fm.image_size) == 2 and (fm.image_size[0] > 0) and\n        (fm.image_size[1] > 0))\n    assert(-1 not in fm.category)\n    # check whether fixmat contains fixations\n    if len(fm.x) ==  0:\n        return np.NaN\n    (scale_factor, _) = calc_resize_factor(prediction, fm.image_size)\n    # this specifies left edges of the histogram bins, i.e. fixations between\n    # ]0 binedge[0]] are included. --> fixations are ceiled\n    e_y = np.arange(0, np.round(scale_factor*fm.image_size[0]+1))\n    e_x = np.arange(0, np.round(scale_factor*fm.image_size[1]+1))\n    samples = np.array(list(zip((scale_factor*fm.y), (scale_factor*fm.x))))\n    (fdm, _) = np.histogramdd(samples, (e_y, e_x))\n\n    # compute ChaoShen corrected kl-div\n    q = np.array(prediction, copy = True)\n    q[q == 0] = np.finfo(q.dtype).eps\n    q /= np.sum(q)\n    (H, pa, la) = chao_shen(fdm)\n    q = q[fdm > 0]\n    cross_entropy = -np.sum((pa * np.log2(q)) / la)\n    return (cross_entropy - H)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef chao_shen(q):\n    yx = q[q > 0] # remove bins with zero counts\n    n = np.sum(yx)\n    p = yx.astype(float)/n\n    f1 = np.sum(yx == 1) # number of singletons in the sample\n    if f1 == n: # avoid C == 0\n        f1 -= 1\n    C = 1 - (f1/n) # estimated coverage of the sample\n    pa = C * p  # coverage adjusted empirical frequencies\n    la = (1 - (1 - pa) ** n)  # probability to see a bin (species) in the sample\n    H = -np.sum((pa * np.log2(pa)) / la)\n    return (H, pa, la)", "response": "Computes some terms needed for Chao - Shen KL correction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef correlation_model(prediction, fm):\n    (_, r_x) = calc_resize_factor(prediction, fm.image_size)\n    fdm = compute_fdm(fm, scale_factor = r_x)\n    return np.corrcoef(fdm.flatten(), prediction.flatten())[0,1]", "response": "computes the FDM and correlation model for a 2D Matrix\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps nss functionality for model evaluation input : 2D matrix the model salience map the model salience map the model salience map the fixmat", "response": "def nss_model(prediction, fm):\n    \"\"\"\n    wraps nss functionality for model evaluation\n\n    input:\n        prediction: 2D matrix\n            the model salience map\n        fm : fixmat\n            Fixations that define the actuals\n    \"\"\"\n    (r_y, r_x) = calc_resize_factor(prediction, fm.image_size)\n    fix = ((np.array(fm.y-1)*r_y).astype(int),\n                            (np.array(fm.x-1)*r_x).astype(int))\n    return nss(prediction, fix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the normalized scanpath salience input : list of y - values", "response": "def nss(prediction, fix):\n    \"\"\"\n    Compute the normalized scanpath salience\n\n    input:\n        fix : list, l[0] contains y, l[1] contains x\n    \"\"\"\n\n    prediction = prediction - np.mean(prediction)\n    prediction = prediction / np.std(prediction)\n    return np.mean(prediction[fix[0], fix[1]])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap roc functionality for model evaluation Parameters: prediction: 2D array the model salience map fm : fixmat Fixations that define locations of the actuals ctr_loc : tuple of (y.x) coordinates, optional Allows to specify control points for spatial bias correction ctr_size : two element tuple, optional Specifies the assumed image size of the control locations, defaults to fm.image_size", "response": "def roc_model(prediction, fm, ctr_loc = None, ctr_size = None):\n    \"\"\"\n    wraps roc functionality for model evaluation\n\n    Parameters:\n        prediction: 2D array\n            the model salience map\n        fm : fixmat\n            Fixations that define locations of the actuals\n        ctr_loc : tuple of (y.x) coordinates, optional\n            Allows to specify control points for spatial\n            bias correction\n        ctr_size : two element tuple, optional\n            Specifies the assumed image size of the control locations,\n            defaults to fm.image_size\n     \"\"\"\n\n    # check if prediction is a valid numpy array\n    assert type(prediction) == np.ndarray\n    # check whether scaling preserved aspect ratio\n    (r_y, r_x) = calc_resize_factor(prediction, fm.image_size)\n    # read out values in the fdm at actual fixation locations\n    # .astype(int) floors numbers in np.array\n    y_index = (r_y * np.array(fm.y-1)).astype(int)\n    x_index = (r_x * np.array(fm.x-1)).astype(int)\n    actuals = prediction[y_index, x_index]\n    if not ctr_loc:\n        xc = np.random.randint(0, prediction.shape[1], 1000)\n        yc = np.random.randint(0, prediction.shape[0], 1000)\n        ctr_loc = (yc.astype(int), xc.astype(int))\n    else:\n        if not ctr_size:\n            ctr_size = fm.image_size\n        else:\n            (r_y, r_x) = calc_resize_factor(prediction, ctr_size)\n        ctr_loc = ((r_y * np.array(ctr_loc[0])).astype(int),\n                   (r_x * np.array(ctr_loc[1])).astype(int))\n    controls = prediction[ctr_loc[0], ctr_loc[1]]\n    return fast_roc(actuals, controls)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the area under the roc curve for a set of actuals and controls.", "response": "def fast_roc(actuals, controls):\n    \"\"\"\n    approximates the area under the roc curve for sets of actuals and controls.\n    Uses all values appearing in actuals as thresholds and lower sum\n    interpolation. Also returns arrays of the true positive rate and the false\n    positive rate that can be used for plotting the roc curve.\n\n    Parameters:\n        actuals : list\n            A list of numeric values for positive observations.\n        controls : list\n            A list of numeric values for negative observations.\n    \"\"\"\n    assert(type(actuals) is np.ndarray)\n    assert(type(controls) is np.ndarray)\n\n    actuals = np.ravel(actuals)\n    controls = np.ravel(controls)\n    if np.isnan(actuals).any():\n        raise RuntimeError('NaN found in actuals')\n    if np.isnan(controls).any():\n        raise RuntimeError('NaN found in controls')\n\n    thresholds = np.hstack([-np.inf, np.unique(actuals), np.inf])[::-1]\n    true_pos_rate = np.empty(thresholds.size)\n    false_pos_rate = np.empty(thresholds.size)\n    num_act = float(len(actuals))\n    num_ctr = float(len(controls))\n\n    for i, value in enumerate(thresholds):\n        true_pos_rate[i] = (actuals >= value).sum() / num_act\n        false_pos_rate[i] = (controls >= value).sum() / num_ctr\n    auc = np.dot(np.diff(false_pos_rate), true_pos_rate[0:-1])\n    # treat cases where TPR of one is not reached before FPR of one\n    # by using trapezoidal integration for the last segment\n    # (add the missing triangle)\n    if false_pos_rate[-2] == 1:\n        auc += ((1-true_pos_rate[-3])*.5*(1-false_pos_rate[-3]))\n    return (auc, true_pos_rate, false_pos_rate)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef faster_roc(actuals, controls):\n    assert(type(actuals) is np.ndarray)\n    assert(type(controls) is np.ndarray)\n\n    if len(actuals)<500:\n        raise RuntimeError('This method might be incorrect when '+\n                'not enough actuals are present. Needs to be checked before '+\n                'proceeding. Stopping here for you to do so.')\n\n    actuals = np.ravel(actuals)\n    controls = np.ravel(controls)\n    if np.isnan(actuals).any():\n        raise RuntimeError('NaN found in actuals')\n    if np.isnan(controls).any():\n        raise RuntimeError('NaN found in controls')\n\n    thresholds = np.hstack([-np.inf, np.unique(actuals), np.inf])+np.finfo(float).eps\n    true_pos_rate = np.nan*np.empty(thresholds.size-1)\n    false_pos_rate = np.nan*np.empty(thresholds.size-1)\n    num_act = float(len(actuals))\n    num_ctr = float(len(controls))\n\n    actuals = 1-(np.cumsum(np.histogram(actuals, thresholds)[0])/num_act)\n    controls = 1-(np.cumsum(np.histogram(controls, thresholds)[0])/num_ctr)\n    true_pos_rate = actuals\n    false_pos_rate = controls\n    #true_pos_rate = np.concatenate(([0], true_pos_rate, [1]))\n    false_pos_rate = false_pos_rate\n    auc = -1*np.dot(np.diff(false_pos_rate), true_pos_rate[0:-1])\n    # treat cases where TPR of one is not reached before FPR of one\n    # by using trapezoidal integration for the last segment\n    # (add the missing triangle)\n    if false_pos_rate[-2] == 1:\n        auc += ((1-true_pos_rate[-3])*.5*(1-false_pos_rate[-3]))\n    return (auc, true_pos_rate, false_pos_rate)", "response": "This method is used to compute the AUC unde ROC curve."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an emd model for the given model salience map", "response": "def emd_model(prediction, fm):\n    \"\"\"\n    wraps emd functionality for model evaluation\n\n    requires:\n        OpenCV python bindings\n\n    input:\n        prediction: the model salience map\n        fm : fixmat filtered for the image corresponding to the prediction\n    \"\"\"\n    (_, r_x) = calc_resize_factor(prediction, fm.image_size)\n    gt = fixmat.compute_fdm(fm, scale_factor = r_x)\n    return emd(prediction, gt)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the Eart Movers Distance between prediction and model.", "response": "def emd(prediction, ground_truth):\n    \"\"\"\n    Compute the Eart Movers Distance between prediction and model.\n\n    This implementation uses opencv for doing the actual work.\n    Unfortunately, at the time of implementation only the SWIG\n    bindings werer available and the numpy arrays have to\n    converted by hand. This changes with opencv 2.1.  \"\"\"\n    import opencv\n\n    if not (prediction.shape == ground_truth.shape):\n        raise RuntimeError('Shapes of prediction and ground truth have' +\n                           ' to be equal. They are: %s, %s'\n                            %(str(prediction.shape), str(ground_truth.shape)))\n    (x, y) = np.meshgrid(list(range(0, prediction.shape[1])),\n                        list(range(0, prediction.shape[0])))\n    s1 = np.array([x.flatten(), y.flatten(), prediction.flatten()]).T\n    s2 = np.array([x.flatten(), y.flatten(), ground_truth.flatten()]).T\n    s1m = opencv.cvCreateMat(s1.shape[0], s2.shape[1], opencv.CV_32FC1)\n    s2m = opencv.cvCreateMat(s1.shape[0], s2.shape[1], opencv.CV_32FC1)\n    for r in range(0, s1.shape[0]):\n        for c in range(0, s1.shape[1]):\n            s1m[r, c] = float(s1[r, c])\n            s2m[r, c] = float(s2[r, c])\n    d = opencv.cvCalcEMD2(s1m, s2m, opencv.CV_DIST_L2)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _rfc822(date):\n    daynames = set(['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'])\n    months = {\n        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,\n        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12,\n    }\n    timezonenames = {\n        'ut': 0, 'gmt': 0, 'z': 0,\n        'adt': -3, 'ast': -4, 'at': -4,\n        'edt': -4, 'est': -5, 'et': -5,\n        'cdt': -5, 'cst': -6, 'ct': -6,\n        'mdt': -6, 'mst': -7, 'mt': -7,\n        'pdt': -7, 'pst': -8, 'pt': -8,\n        'a': -1, 'n': 1,\n        'm': -12, 'y': 12,\n    }\n\n    parts = date.lower().split()\n    if len(parts) < 5:\n        # Assume that the time and timezone are missing\n        parts.extend(('00:00:00', '0000'))\n    # Remove the day name\n    if parts[0][:3] in daynames:\n        parts = parts[1:]\n    if len(parts) < 5:\n        # If there are still fewer than five parts, there's not enough\n        # information to interpret this\n        return None\n    try:\n        day = int(parts[0])\n    except ValueError:\n        # Check if the day and month are swapped\n        if months.get(parts[0][:3]):\n            try:\n                day = int(parts[1])\n            except ValueError:\n                return None\n            else:\n                parts[1] = parts[0]\n        else:\n            return None\n    month = months.get(parts[1][:3])\n    if not month:\n        return None\n    try:\n        year = int(parts[2])\n    except ValueError:\n        return None\n    # Normalize two-digit years:\n    # Anything in the 90's is interpreted as 1990 and on\n    # Anything 89 or less is interpreted as 2089 or before\n    if len(parts[2]) <= 2:\n        year += (1900, 2000)[year < 90]\n    timeparts = parts[3].split(':')\n    timeparts = timeparts + ([0] * (3 - len(timeparts)))\n    try:\n        (hour, minute, second) = map(int, timeparts)\n    except ValueError:\n        return None\n    tzhour = 0\n    tzmin = 0\n    # Strip 'Etc/' from the timezone\n    if parts[4].startswith('etc/'):\n        parts[4] = parts[4][4:]\n    # Normalize timezones that start with 'gmt':\n    # GMT-05:00 => -0500\n    # GMT => GMT\n    if parts[4].startswith('gmt'):\n        parts[4] = ''.join(parts[4][3:].split(':')) or 'gmt'\n    # Handle timezones like '-0500', '+0500', and 'EST'\n    if parts[4] and parts[4][0] in ('-', '+'):\n        try:\n            tzhour = int(parts[4][1:3])\n            tzmin = int(parts[4][3:])\n        except ValueError:\n            return None\n        if parts[4].startswith('-'):\n            tzhour = tzhour * -1\n            tzmin = tzmin * -1\n    else:\n        tzhour = timezonenames.get(parts[4], 0)\n    # Create the datetime object and timezone delta objects\n    try:\n        stamp = datetime.datetime(year, month, day, hour, minute, second)\n    except ValueError:\n        return None\n    delta = datetime.timedelta(0, 0, 0, 0, tzmin, tzhour)\n    # Return the date and timestamp in a UTC 9-tuple\n    try:\n        return stamp - delta\n    except OverflowError:\n        return None", "response": "Parse a date string into a sequence of time and timezone names."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _to_rfc822(date):\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    fmt = '{day}, {d:02} {month} {y:04} {h:02}:{m:02}:{s:02} GMT'\n    return fmt.format(\n        day=days[date.weekday()],\n        d=date.day,\n        month=months[date.month - 1],\n        y=date.year,\n        h=date.hour,\n        m=date.minute,\n        s=date.second,\n    )", "response": "_to_rfc822 - Convert a datetime. datetime object to a RFC822 - formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the SQL query to use named parameters instead of ordinal parameters.", "response": "def format(self, sql, params):\n\t\t\"\"\"\n\t\tFormats the SQL query to use ordinal parameters instead of named\n\t\tparameters.\n\n\t\t*sql* (|string|) is the SQL query.\n\n\t\t*params* (|dict|) maps each named parameter (|string|) to value\n\t\t(|object|). If |self.named| is \"numeric\", then *params* can be\n\t\tsimply a |sequence| of values mapped by index.\n\n\t\tReturns a 2-|tuple| containing: the formatted SQL query (|string|),\n\t\tand the ordinal parameters (|list|).\n\t\t\"\"\"\n\t\tif isinstance(sql, unicode):\n\t\t\tstring_type = unicode\n\t\telif isinstance(sql, bytes):\n\t\t\tstring_type = bytes\n\t\t\tsql = sql.decode(_BYTES_ENCODING)\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\tif self.named == 'numeric':\n\t\t\tif isinstance(params, collections.Mapping):\n\t\t\t\tparams = {string_type(idx): val for idx, val in iteritems(params)}\n\t\t\telif isinstance(params, collections.Sequence) and not isinstance(params, (unicode, bytes)):\n\t\t\t\tparams = {string_type(idx): val for idx, val in enumerate(params, 1)}\n\n\t\tif not isinstance(params, collections.Mapping):\n\t\t\traise TypeError(\"params:{!r} is not a dict.\".format(params))\n\n\t\t# Find named parameters.\n\t\tnames = self.match.findall(sql)\n\n\t\t# Map named parameters to ordinals.\n\t\tord_params = []\n\t\tname_to_ords = {}\n\t\tfor name in names:\n\t\t\tvalue = params[name]\n\t\t\tif isinstance(value, tuple):\n\t\t\t\tord_params.extend(value)\n\t\t\t\tif name not in name_to_ords:\n\t\t\t\t\tname_to_ords[name] = '(' + ','.join((self.replace,) * len(value)) + ')'\n\t\t\telse:\n\t\t\t\tord_params.append(value)\n\t\t\t\tif name not in name_to_ords:\n\t\t\t\t\tname_to_ords[name] = self.replace\n\n\t\t# Replace named parameters with ordinals.\n\t\tsql = self.match.sub(lambda m: name_to_ords[m.group(1)], sql)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tsql = sql.encode(_BYTES_ENCODING)\n\n\t\t# Return formatted SQL and new ordinal parameters.\n\t\treturn sql, ord_params"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef formatmany(self, sql, many_params):\n\t\tif isinstance(sql, unicode):\n\t\t\tstring_type = unicode\n\t\telif isinstance(sql, bytes):\n\t\t\tstring_type = bytes\n\t\t\tsql = sql.decode(_BYTES_ENCODING)\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\tif not isinstance(many_params, collections.Iterable) or isinstance(many_params, (unicode, bytes)):\n\t\t\traise TypeError(\"many_params:{!r} is not iterable.\".format(many_params))\n\n\t\t# Find named parameters.\n\t\tnames = self.match.findall(sql)\n\t\tname_set = set(names)\n\n\t\t# Map named parameters to ordinals.\n\t\tmany_ord_params = []\n\t\tname_to_ords = {}\n\t\tname_to_len = {}\n\t\trepl_str = self.replace\n\t\trepl_tuple = (repl_str,)\n\t\tfor i, params in enumerate(many_params):\n\t\t\tif self.named == 'numeric':\n\t\t\t\tif isinstance(params, collections.Mapping):\n\t\t\t\t\tparams = {string_type(idx): val for idx, val in iteritems(params)}\n\t\t\t\telif isinstance(params, collections.Sequence) and not isinstance(params, (unicode, bytes)):\n\t\t\t\t\tparams = {string_type(idx): val for idx, val in enumerate(params, 1)}\n\n\t\t\tif not isinstance(params, collections.Mapping):\n\t\t\t\traise TypeError(\"many_params[{}]:{!r} is not a dict.\".format(i, params))\n\n\t\t\tif not i: # first\n\t\t\t\t# Map names to ordinals, and determine what names are tuples and\n\t\t\t\t# what their lengths are.\n\t\t\t\tfor name in name_set:\n\t\t\t\t\tvalue = params[name]\n\t\t\t\t\tif isinstance(value, tuple):\n\t\t\t\t\t\ttuple_len = len(value)\n\t\t\t\t\t\tname_to_ords[name] = '(' + ','.join(repl_tuple * tuple_len) + ')'\n\t\t\t\t\t\tname_to_len[name] = tuple_len\n\t\t\t\t\telse:\n\t\t\t\t\t\tname_to_ords[name] = repl_str\n\t\t\t\t\t\tname_to_len[name] = None\n\n\t\t\t# Make sure tuples match up and collapse tuples into ordinals.\n\t\t\tord_params = []\n\t\t\tfor name in names:\n\t\t\t\tvalue = params[name]\n\t\t\t\ttuple_len = name_to_len[name]\n\t\t\t\tif tuple_len is not None:\n\t\t\t\t\tif not isinstance(value, tuple):\n\t\t\t\t\t\traise TypeError(\"many_params[{}][{!r}]:{!r} was expected to be a tuple.\".format(i, name, value))\n\t\t\t\t\telif len(value) != tuple_len:\n\t\t\t\t\t\traise ValueError(\"many_params[{}][{!r}]:{!r} length was expected to be {}.\".format(i, name, value, tuple_len))\n\t\t\t\t\tord_params.extend(value)\n\t\t\t\telse:\n\t\t\t\t\tord_params.append(value)\n\t\t\tmany_ord_params.append(ord_params)\n\n\t\t# Replace named parameters with ordinals.\n\t\tsql = self.match.sub(lambda m: name_to_ords[m.group(1)], sql)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tsql = sql.encode(_BYTES_ENCODING)\n\n\t\t# Return formatted SQL and new ordinal parameters.\n\t\treturn sql, many_ord_params", "response": "Formats the given SQL query with the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the parser for the command f creates a new one if it does not exist", "response": "def _get_parser(f):\n    \"\"\"\n    Gets the parser for the command f, if it not exists it creates a new one\n    \"\"\"\n    _COMMAND_GROUPS[f.__module__].load()\n\n    if f.__name__ not in _COMMAND_GROUPS[f.__module__].parsers:\n        parser = _COMMAND_GROUPS[f.__module__].parser_generator.add_parser(f.__name__, help=f.__doc__,\n                                                                           description=f.__doc__)\n        parser.set_defaults(func=f)\n\n        _COMMAND_GROUPS[f.__module__].parsers[f.__name__] = parser\n\n    return _COMMAND_GROUPS[f.__module__].parsers[f.__name__]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all mentions in a given HTML page.", "response": "def findMentions(sourceURL, targetURL=None, exclude_domains=[], content=None, test_urls=True, headers={}, timeout=None):\n    \"\"\"Find all <a /> elements in the given html for a post. Only scan html element matching all criteria in look_in.\n\n    optionally the content to be scanned can be given as an argument.\n\n    If any have an href attribute that is not from the\n    one of the items in exclude_domains, append it to our lists.\n\n    :param sourceURL: the URL for the post we are scanning\n    :param exclude_domains: a list of domains to exclude from the search\n    :type exclude_domains: list\n    :param content: the content to be scanned for mentions\n    :param look_in: dictionary with name, id and class_. only element matching all of these will be scanned\n    :param test_urls: optional flag to test URLs for validation\n    :param headers: optional headers to send with any web requests\n    :type headers: dict\n    :param timeout: optional timeout for web requests\n    :type timeout float\n    :rtype: dictionary of Mentions\n    \"\"\"\n\n    __doc__ = None\n\n    if test_urls:\n        URLValidator(message='invalid source URL')(sourceURL)\n\n    if content:\n        result = {'status':   requests.codes.ok,\n                  'headers':  None,\n                  }\n    else:\n        r = requests.get(sourceURL, verify=True, headers=headers, timeout=timeout)\n        result = {'status':   r.status_code,\n                  'headers':  r.headers\n                  }\n        # Check for character encodings and use 'correct' data\n        if 'charset' in r.headers.get('content-type', ''):\n            content = r.text\n        else:\n            content = r.content\n\n    result.update({'refs': set(), 'post-url': sourceURL})\n\n    if result['status'] == requests.codes.ok:\n        # Allow passing BS doc as content\n        if isinstance(content, BeautifulSoup):\n            __doc__ = content\n            # result.update({'content': unicode(__doc__)})\n            result.update({'content': str(__doc__)})\n        else:\n            __doc__ = BeautifulSoup(content, _html_parser)\n            result.update({'content': content})\n\n        # try to find first h-entry else use full document\n        entry = __doc__.find(class_=\"h-entry\") or __doc__\n\n        # Allow finding particular URL\n        if targetURL:\n            # find only targetURL\n            all_links = entry.find_all('a', href=targetURL)\n        else:\n            # find all links with a href\n            all_links = entry.find_all('a', href=True)\n        for link in all_links:\n            href = link.get('href', None)\n            if href:\n                url = urlparse(href)\n\n                if url.scheme in ('http', 'https'):\n                    if url.hostname and url.hostname not in exclude_domains:\n                        result['refs'].add(href)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches the given html content for all links and return any discovered WebMention URL.", "response": "def findEndpoint(html):\n    \"\"\"Search the given html content for all <link /> elements\n    and return any discovered WebMention URL.\n\n    :param html: html content\n    :rtype: WebMention URL\n    \"\"\"\n    poss_rels = ['webmention', 'http://webmention.org', 'http://webmention.org/', 'https://webmention.org', 'https://webmention.org/']\n\n    # find elements with correct rels and a href value\n    all_links = BeautifulSoup(html, _html_parser).find_all(rel=poss_rels, href=True)\n    for link in all_links:\n        s = link.get('href', None)\n        if s is not None:\n            return s\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndiscover any endpoint for a given URL.", "response": "def discoverEndpoint(url, test_urls=True, headers={}, timeout=None, request=None, debug=False):\n    \"\"\"Discover any WebMention endpoint for a given URL.\n\n    :param link: URL to discover WebMention endpoint\n    :param test_urls: optional flag to test URLs for validation\n    :param headers: optional headers to send with any web requests\n    :type headers dict\n    :param timeout: optional timeout for web requests\n    :type timeout float\n    :param request: optional Requests request object to avoid another GET\n    :rtype: tuple (status_code, URL, [debug])\n    \"\"\"\n    if test_urls:\n        URLValidator(message='invalid URL')(url)\n\n    # status, webmention\n    endpointURL = None\n    debugOutput = []\n    try:\n        if request is not None:\n            targetRequest = request\n        else:\n            targetRequest = requests.get(url, verify=False, headers=headers, timeout=timeout)\n        returnCode = targetRequest.status_code\n        debugOutput.append('%s %s' % (returnCode, url))\n        if returnCode == requests.codes.ok:\n            try:\n                linkHeader  = parse_link_header(targetRequest.headers['link'])\n                endpointURL = linkHeader.get('webmention', '') or \\\n                              linkHeader.get('http://webmention.org', '') or \\\n                              linkHeader.get('http://webmention.org/', '') or \\\n                              linkHeader.get('https://webmention.org', '') or \\\n                              linkHeader.get('https://webmention.org/', '')\n                # force searching in the HTML if not found\n                if not endpointURL:\n                    raise AttributeError\n                debugOutput.append('found in link headers')\n            except (KeyError, AttributeError):\n                endpointURL = findEndpoint(targetRequest.text)\n                debugOutput.append('found in body')\n            if endpointURL is not None:\n                endpointURL = urljoin(url, endpointURL)\n    except (requests.exceptions.RequestException, requests.exceptions.ConnectionError,\n            requests.exceptions.HTTPError, requests.exceptions.URLRequired,\n            requests.exceptions.TooManyRedirects, requests.exceptions.Timeout):\n        debugOutput.append('exception during GET request')\n        returnCode = 500\n    debugOutput.append('endpointURL: %s %s' % (returnCode, endpointURL))\n    if debug:\n        return (returnCode, endpointURL, debugOutput)\n    else:\n        return (returnCode, endpointURL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sendWebmention(sourceURL, targetURL, webmention=None, test_urls=True, vouchDomain=None,\n                   headers={}, timeout=None, debug=False):\n    \"\"\"Send to the :targetURL: a WebMention for the :sourceURL:\n\n    The WebMention will be discovered if not given in the :webmention:\n    parameter.\n\n    :param sourceURL: URL that is referencing :targetURL:\n    :param targetURL: URL of mentioned post\n    :param webmention: optional WebMention endpoint\n    :param test_urls: optional flag to test URLs for validation\n    :param headers: optional headers to send with any web requests\n    :type headers dict\n    :param timeout: optional timeout for web requests\n    :type timeout float\n\n    :rtype: HTTPrequest object if WebMention endpoint was valid\n    \"\"\"\n    if test_urls:\n        v = URLValidator()\n        v(sourceURL)\n        v(targetURL)\n\n    debugOutput = []\n    originalURL = targetURL\n    try:\n        targetRequest = requests.get(targetURL)\n\n        if targetRequest.status_code == requests.codes.ok:\n            if len(targetRequest.history) > 0:\n                redirect = targetRequest.history[-1]\n                if (redirect.status_code == 301 or redirect.status_code == 302) and 'Location' in redirect.headers:\n                    targetURL = urljoin(targetURL, redirect.headers['Location'])\n                    debugOutput.append('targetURL redirected: %s' % targetURL)\n        if webmention is None:\n            wStatus, wUrl = discoverEndpoint(targetURL, headers=headers, timeout=timeout, request=targetRequest)\n        else:\n            wStatus = 200\n            wUrl = webmention\n        debugOutput.append('endpointURL: %s %s' % (wStatus, wUrl))\n        if wStatus == requests.codes.ok and wUrl is not None:\n            if test_urls:\n                v(wUrl)\n            payload = {'source': sourceURL,\n                       'target': originalURL}\n            if vouchDomain is not None:\n                payload['vouch'] = vouchDomain\n            try:\n                result = requests.post(wUrl, data=payload, headers=headers, timeout=timeout)\n                debugOutput.append('POST %s -- %s' % (wUrl, result.status_code))\n                if result.status_code == 405 and len(result.history) > 0:\n                    redirect = result.history[-1]\n                    if redirect.status_code == 301 and 'Location' in redirect.headers:\n                        result = requests.post(redirect.headers['Location'], data=payload, headers=headers, timeout=timeout)\n                        debugOutput.append('redirected POST %s -- %s' % (redirect.headers['Location'], result.status_code))\n            except Exception as e:\n                result = None\n    except (requests.exceptions.RequestException, requests.exceptions.ConnectionError,\n            requests.exceptions.HTTPError, requests.exceptions.URLRequired,\n            requests.exceptions.TooManyRedirects, requests.exceptions.Timeout):\n        debugOutput.append('exception during GET request')\n        result = None\n    return result", "response": "Send a WebMention to the targetURL."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking the link header as a string and returns a dictionary with rel names as keys and urls as values", "response": "def parse_link_header(link):\n    \"\"\"takes the link header as a string and returns a dictionary with rel values as keys and urls as values\n    :param link: link header as a string\n    :rtype: dictionary {rel_name: rel_value}\n    \"\"\"\n    rel_dict = {}\n    for rels in link.split(','):\n        rel_break = quoted_split(rels, ';')\n        try:\n            rel_url = re.search('<(.+?)>', rel_break[0]).group(1)\n            rel_names = quoted_split(rel_break[1], '=')[-1]\n            if rel_names.startswith('\"') and rel_names.endswith('\"'):\n                    rel_names = rel_names[1:-1]\n            for name in rel_names.split():\n                rel_dict[name] = rel_url\n        except (AttributeError, IndexError):\n            pass\n\n    return rel_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds all links that are rel = me and include them in the result.", "response": "def findRelMe(sourceURL):\n    \"\"\"Find all <a /> elements in the given html for a post.\n\n    If any have an href attribute that is rel=\"me\" then include\n    it in the result.\n\n    :param sourceURL: the URL for the post we are scanning\n    :rtype: dictionary of RelMe references\n    \"\"\"\n    r = requests.get(sourceURL)\n    result = {'status':  r.status_code,\n              'headers': r.headers,\n              'history': r.history,\n              'content': r.text,\n              'relme':   [],\n              'url':     sourceURL\n              }\n    if r.status_code == requests.codes.ok:\n        dom = BeautifulSoup(r.text, _html_parser)\n        for link in dom.find_all('a', rel='me'):\n            rel  = link.get('rel')\n            href = link.get('href')\n            if rel is not None and href is not None:\n                url = urlparse(href)\n                if url is not None and url.scheme in ('http', 'https'):\n                    result['relme'].append(cleanURL(href))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a given resource URL is authoritative for the given profile URL.", "response": "def confirmRelMe(profileURL, resourceURL, profileRelMes=None, resourceRelMes=None):\n    \"\"\"Determine if a given :resourceURL: is authoritative for the :profileURL:\n\n    TODO add https/http filtering for those who wish to limit/restrict urls to match fully\n    TODO add code to ensure that each item in the redirect chain is authoritative\n\n    :param profileURL: URL of the user\n    :param resourceURL: URL of the resource to validate\n    :param profileRelMes: optional list of rel=\"me\" links within the profile URL\n    :param resourceRelMes: optional list of rel=\"me\" links found within resource URL\n    :rtype: True if confirmed\n    \"\"\"\n    result  = False\n    profile = normalizeURL(profileURL)\n\n    if profileRelMes is None:\n        profileRelMe = findRelMe(profileURL)\n        profileRelMes = profileRelMe['relme']\n    if resourceRelMes is None:\n        resourceRelMe = findRelMe(resourceURL)\n        resourceRelMes = resourceRelMe['relme']\n\n    for url in resourceRelMes:\n        if profile in (url, normalizeURL(url)):\n            result = True\n            break\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef indent_text(string, indent_level=2):\n    indented_lines = []\n\n    indent_spaces = ' ' * indent_level\n\n    for line in string.split('\\n'):\n        indented_lines.append(indent_spaces + line)\n\n    return '\\n'.join(indented_lines)", "response": "Indent every line of text in a newline - delimited string"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads a file using requests.", "response": "def download(url, target, headers=None, trackers=()):\n    \"\"\"Download a file using requests.\n\n    This is like urllib.request.urlretrieve, but:\n\n    - requests validates SSL certificates by default\n    - you can pass tracker objects to e.g. display a progress bar or calculate\n      a file hash.\n    \"\"\"\n    if headers is None:\n        headers = {}\n    headers.setdefault('user-agent', 'requests_download/'+__version__)\n    r = requests.get(url, headers=headers, stream=True)\n    r.raise_for_status()\n    for t in trackers:\n        t.on_start(r)\n\n\n    with open(target, 'wb') as f:\n        for chunk in r.iter_content(chunk_size=8192):\n            if chunk:\n                f.write(chunk)\n                for t in trackers:\n                    t.on_chunk(chunk)\n\n    for t in trackers:\n        t.on_finish()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites an object created by parse to either a file or a bytearray.", "response": "def write(parsed_obj, spec=None, filename=None):\n    \"\"\"Writes an object created by `parse` to either a file or a bytearray.\n\n    If the object doesn't end on a byte boundary, zeroes are appended to it\n    until it does.\n    \"\"\"\n    if not isinstance(parsed_obj, BreadStruct):\n        raise ValueError(\n            'Object to write must be a structure created '\n            'by bread.parse')\n\n    if filename is not None:\n        with open(filename, 'wb') as fp:\n            parsed_obj._data_bits[:parsed_obj._length].tofile(fp)\n    else:\n        return bytearray(parsed_obj._data_bits[:parsed_obj._length].tobytes())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deploy_file(file_path, bucket):\n\n    # Paths look like:\n    #  index.html\n    #  css/bootstrap.min.css\n\n    logger.info(\"Deploying {0}\".format(file_path))\n\n    # Upload the actual file to file_path\n    k = Key(bucket)\n    k.key = file_path\n    try:\n        k.set_contents_from_filename(file_path)\n        k.set_acl('public-read')\n    except socket.error:\n        logger.warning(\"Caught socket.error while trying to upload {0}\".format(\n            file_path))\n        msg = \"Please file an issue with alotofeffort if you see this,\"\n        logger.warning(msg)\n        logger.warning(\"providing as much info as you can.\")", "response": "Uploads a file to an S3 bucket as a public file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deploy(www_dir, bucket_name):\n\n    # Set up the connection to an S3 bucket.\n    conn = boto.connect_s3()\n    bucket = conn.get_bucket(bucket_name)\n\n    # Deploy each changed file in www_dir\n    os.chdir(www_dir)\n    for root, dirs, files in os.walk('.'):\n        for f in files:\n            # Use full relative path. Normalize to remove dot.\n            file_path = os.path.normpath(os.path.join(root, f))\n\n            if has_changed_since_last_deploy(file_path, bucket):\n                deploy_file(file_path, bucket)\n            else:\n                logger.info(\"Skipping {0}\".format(file_path))\n\n    # Make the whole bucket public\n    bucket.set_acl('public-read')\n\n    # Configure it to be a website\n    bucket.configure_website('index.html', 'error.html')\n\n    # Print the endpoint, so you know the URL\n    msg = \"Your website is now live at {0}\".format(\n        bucket.get_website_endpoint())\n    logger.info(msg)\n    logger.info(\"If you haven't done so yet, point your domain name there!\")", "response": "Deploy all files in www_dir to the configured S3 bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_changed_since_last_deploy(file_path, bucket):\n\n    msg = \"Checking if {0} has changed since last deploy.\".format(file_path)\n    logger.debug(msg)\n    with open(file_path) as f:\n        data = f.read()\n        file_md5 = hashlib.md5(data.encode('utf-8')).hexdigest()\n        logger.debug(\"file_md5 is {0}\".format(file_md5))\n\n    key = bucket.get_key(file_path)\n\n    # HACK: Boto's md5 property does not work when the file hasn't been\n    # downloaded. The etag works but will break for multi-part uploaded files.\n    # http://stackoverflow.com/questions/16872679/how-to-programmatically-\n    #     get-the-md5-checksum-of-amazon-s3-file-using-boto/17607096#17607096\n    # Also the double quotes around it must be stripped. Sketchy...boto's fault\n    if key:\n        key_md5 = key.etag.replace('\"', '').strip()\n        logger.debug(\"key_md5 is {0}\".format(key_md5))\n    else:\n        logger.debug(\"File does not exist in bucket\")\n        return True\n\n    if file_md5 == key_md5:\n        logger.debug(\"File has not changed.\")\n        return False\n    logger.debug(\"File has changed.\")\n    return True", "response": "Checks if a file has changed since the last time it was deployed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n\n    # Log info and above to console\n    logging.basicConfig(\n        format='%(levelname)s: %(message)s', level=logging.INFO)\n\n    # Get command line input/output arguments\n    msg = 'Instantly deploy static HTML sites to S3 at the command line.'\n    parser = argparse.ArgumentParser(description=msg)\n    parser.add_argument(\n        'www_dir',\n        help='Directory containing the HTML files for your website.'\n    )\n    parser.add_argument(\n        'bucket_name',\n        help='Name of S3 bucket to deploy to, e.g. mybucket.'\n    )\n    args = parser.parse_args()\n\n    # Deploy the site to S3!\n    deploy(args.www_dir, args.bucket_name)", "response": "Entry point for the package."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart sikuli java process.", "response": "def start_sikuli_process(self, port=None):\n        \"\"\"\n        This keyword is used to start sikuli java process.\n        If library is inited with mode \"OLD\", sikuli java process is started automatically.\n        If library is inited with mode \"NEW\", this keyword should be used.\n\n        :param port: port of sikuli java process, if value is None or 0, a random free port will be used\n        :return: None\n        \"\"\"\n        if port is None or int(port) == 0:\n            port = self._get_free_tcp_port()\n        self.port = port\n        start_retries = 0\n        started = False\n        while start_retries < 5:\n            try:\n                self._start_sikuli_java_process()\n            except RuntimeError as err:\n                print('error........%s' % err)\n                if self.process:\n                    self.process.terminate_process()\n                self.port = self._get_free_tcp_port()\n                start_retries += 1\n                continue\n            started = True\n            break\n        if not started:\n            raise RuntimeError('Start sikuli java process failed!')\n        self.remote = self._connect_remote_library()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrespond to POSTed username / password with token.", "response": "def post(self, request):\n        \"\"\"Respond to POSTed username/password with token.\"\"\"\n        serializer = AuthTokenSerializer(data=request.data)\n\n        if serializer.is_valid():\n            token, _ = ExpiringToken.objects.get_or_create(\n                user=serializer.validated_data['user']\n            )\n\n            if token.expired():\n                # If the token is expired, generate a new one.\n                token.delete()\n                token = ExpiringToken.objects.create(\n                    user=serializer.validated_data['user']\n                )\n\n            data = {'token': token.key}\n            return Response(data)\n\n        return Response(serializer.errors, status=HTTP_400_BAD_REQUEST)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef EXPIRING_TOKEN_LIFESPAN(self):\n        try:\n            val = settings.EXPIRING_TOKEN_LIFESPAN\n        except AttributeError:\n            val = timedelta(days=30)\n\n        return val", "response": "Return the allowed lifespan of a token as a TimeDelta object. Defaults to 30 days."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expired(self):\n        now = timezone.now()\n        if self.created < now - token_settings.EXPIRING_TOKEN_LIFESPAN:\n            return True\n        return False", "response": "Return boolean indicating token expiration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unicode_is_punctuation(text):\n    for char in str_func(text):\n        category = unicodedata.category(char)[0]\n        if category not in 'PSZMC':\n            return False\n    return True", "response": "Test if a string is entirely of punctuation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process(self):\n        if hasattr(self, '_process'):\n            return self._process\n        else:\n            self._process = self._get_process()\n            return self._process", "response": "Returns the actual process of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a process by running the specified command.", "response": "def _get_process(self):\n        \"\"\"\n        Create the process by running the specified command.\n        \"\"\"\n        command = self._get_command()\n        return subprocess.Popen(command, bufsize=-1, close_fds=True,\n                                stdout=subprocess.PIPE,\n                                stdin=subprocess.PIPE)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsplits a text into separate words.", "response": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndetermine whether a single word is a stopword.", "response": "def is_stopword(self, text):\n        \"\"\"\n        Determine whether a single word is a stopword, or whether a short\n        phrase is made entirely of stopwords, disregarding context.\n\n        Use of this function should be avoided; it's better to give the text\n        in context and let the process determine which words are the stopwords.\n        \"\"\"\n        found_content_word = False\n        for record in self.analyze(text):\n            if not self.is_stopword_record(record):\n                found_content_word = True\n                break\n        return not found_content_word"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef normalize_list(self, text, cache=None):\n        words = []\n        analysis = self.analyze(text)\n        for record in analysis:\n            if not self.is_stopword_record(record):\n                words.append(self.get_record_root(record))\n        if not words:\n            # Don't discard stopwords if that's all you've got\n            words = [self.get_record_token(record) for record in analysis]\n        return words", "response": "Get a canonical list representation of text with words\n        separated and reduced to their base forms."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving some text return a sequence of stem pos and text.", "response": "def tag_and_stem(self, text, cache=None):\n        \"\"\"\n        Given some text, return a sequence of (stem, pos, text) triples as\n        appropriate for the reader. `pos` can be as general or specific as\n        necessary (for example, it might label all parts of speech, or it might\n        only distinguish function words from others).\n\n        Twitter-style hashtags and at-mentions have the stem and pos they would\n        have without the leading # or @. For instance, if the reader's triple\n        for \"thing\" is ('thing', 'NN', 'things'), then \"#things\" would come out\n        as ('thing', 'NN', '#things').\n        \"\"\"\n        analysis = self.analyze(text)\n        triples = []\n\n        for record in analysis:\n            root = self.get_record_root(record)\n            token = self.get_record_token(record)\n\n            if token:\n                if unicode_is_punctuation(token):\n                    triples.append((token, '.', token))\n                else:\n                    pos = self.get_record_pos(record)\n                    triples.append((root, pos, token))\n        return triples"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_phrases(self, text):\n        analysis = self.analyze(text)\n        for pos1 in range(len(analysis)):\n            rec1 = analysis[pos1]\n            if not self.is_stopword_record(rec1):\n                yield self.get_record_root(rec1), rec1[0]\n                for pos2 in range(pos1 + 1, len(analysis)):\n                    rec2 = analysis[pos2]\n                    if not self.is_stopword_record(rec2):\n                        roots = [self.get_record_root(rec1),\n                                 self.get_record_root(rec2)]\n                        pieces = [analysis[i][0] for i in range(pos1, pos2+1)]\n                        term = ' '.join(roots)\n                        phrase = ''.join(pieces)\n                        yield term, phrase\n                        break", "response": "Given some text extract phrases of up to 2 content words and phrase."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a text into a katakana string.", "response": "def to_kana(text):\n    \"\"\"\n    Use MeCab to turn any text into its phonetic spelling, as katakana\n    separated by spaces.\n    \"\"\"\n    records = MECAB.analyze(text)\n    kana = []\n    for record in records:\n        if record.pronunciation:\n            kana.append(record.pronunciation)\n        elif record.reading:\n            kana.append(record.reading)\n        else:\n            kana.append(record.surface)\n    return ' '.join(k for k in kana if k)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns two things about each character in the kana base.", "response": "def get_kana_info(char):\n    \"\"\"\n    Return two things about each character:\n\n    - Its transliterated value (in Roman characters, if it's a kana)\n    - A class of characters indicating how it affects the romanization\n    \"\"\"\n    try:\n        name = unicodedata.name(char)\n    except ValueError:\n        return char, NOT_KANA\n\n    # The names we're dealing with will probably look like\n    # \"KATAKANA CHARACTER ZI\".\n    if (name.startswith('HIRAGANA LETTER') or\n        name.startswith('KATAKANA LETTER') or\n        name.startswith('KATAKANA-HIRAGANA')):\n        names = name.split()\n        syllable = str_func(names[-1].lower())\n\n        if name.endswith('SMALL TU'):\n            # The small tsu (\u3063) doubles the following consonant.\n            # It'll show up as 't' on its own.\n            return 't', SMALL_TSU\n        elif names[-1] == 'N':\n            return 'n', NN\n        elif names[1] == 'PROLONGED':\n            # The prolongation marker doubles the previous vowel.\n            # It'll show up as '_' on its own.\n            return '_', PROLONG\n        elif names[-2] == 'SMALL':\n            # Small characters tend to modify the sound of the previous\n            # kana. If they can't modify anything, they're appended to\n            # the letter 'x' instead.\n            if syllable.startswith('y'):\n                return 'x' + syllable, SMALL_Y\n            else:\n                return 'x' + syllable, SMALL\n\n        return syllable, KANA\n    else:\n        if char in ROMAN_PUNCTUATION_TABLE:\n            char = ROMAN_PUNCTUATION_TABLE[char]\n        return char, NOT_KANA"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef analyze(self, text):\n        try:\n            self.process  # make sure things are loaded\n            text = render_safe(text).replace('\\n', ' ').lower()\n            results = []\n            for chunk in string_pieces(text):\n                self.send_input((chunk + '\\n').encode('utf-8'))\n                while True:\n                    out_line = self.receive_output_line().decode('utf-8')\n                    if out_line == 'EOS\\n':\n                        break\n\n                    word, info = out_line.strip('\\n').split('\\t')\n                    record_parts = [word] + info.split(',')\n\n                    # Pad the record out to have 10 parts if it doesn't\n                    record_parts += [None] * (10 - len(record_parts))\n                    record = MeCabRecord(*record_parts)\n\n                    # special case for detecting nai -> n\n                    if (record.surface == '\u3093' and\n                        record.conjugation == '\u4e0d\u5909\u5316\u578b'):\n                        # rebuild the record so that record.root is 'nai'\n                        record_parts[MeCabRecord._fields.index('root')] = '\u306a\u3044'\n                        record = MeCabRecord(*record_parts)\n\n                    results.append(record)\n            return results\n        except ProcessError:\n            self.restart_process()\n            return self.analyze(text)", "response": "Runs a line of text through MeCab and returns the results as a list of lists of MeCabRecord objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines whether a MeCab record represents a stopword.", "response": "def is_stopword_record(self, record):\n        \"\"\"\n        Determine whether a single MeCab record represents a stopword.\n\n        This mostly determines words to strip based on their parts of speech.\n        If common_words is set to True (default), it will also strip common\n        verbs and nouns such as \u304f\u308b and \u3088\u3046. If more_stopwords is True, it\n        will look at the sub-part of speech to remove more categories.\n        \"\"\"\n        # preserve negations\n        if record.root == '\u306a\u3044':\n            return False\n        return (\n            record.pos in STOPWORD_CATEGORIES or\n            record.subclass1 in STOPWORD_CATEGORIES or\n            record.root in STOPWORD_ROOTS\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_record_pos(self, record):\n        if self.is_stopword_record(record):\n            return '~' + record.pos\n        else:\n            return record.pos", "response": "Given a record return the word s part of speech."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef analyze(self, text):\n        try:\n            text = render_safe(text).strip()\n            if not text:\n                return []\n            chunks = text.split('\\n')\n            results = []\n            for chunk_text in chunks:\n                if chunk_text.strip():\n                    textbytes = (chunk_text + '\\n').encode('utf-8')\n                    self.send_input(textbytes)\n                    out_line = ''\n                    while True:\n                        out_line = self.receive_output_line()\n                        out_line = out_line.decode('utf-8')\n\n                        if out_line == '\\n':\n                            break\n\n                        record = out_line.strip('\\n').split(' ')\n                        results.append(record)\n            return results\n        except ProcessError:\n            self.restart_process()\n            return self.analyze(text)", "response": "Run the external process and get a list of lists\n            s that contain the analysis of each word."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef untokenize(words):\n    text = ' '.join(words)\n    step1 = text.replace(\"`` \", '\"').replace(\" ''\", '\"').replace('. . .', '...')\n    step2 = step1.replace(\" ( \", \" (\").replace(\" ) \", \") \")\n    step3 = re.sub(r' ([.,:;?!%]+)([ \\'\"`])', r\"\\1\\2\", step2)\n    step4 = re.sub(r' ([.,:;?!%]+)$', r\"\\1\", step3)\n    step5 = step4.replace(\" '\", \"'\").replace(\" n't\", \"n't\").replace(\n        \"can not\", \"cannot\")\n    step6 = step5.replace(\" ` \", \" '\")\n    return step6.strip()", "response": "Untokenizes a text into a single tokenised list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef string_pieces(s, maxlen=1024):\n    if not s:\n        return\n    i = 0\n    while True:\n        j = i + maxlen\n        if j >= len(s):\n            yield s[i:]\n            return\n        # Using \"j - 1\" keeps boundary characters with the left chunk\n        while unicodedata.category(s[j - 1]) not in BOUNDARY_CATEGORIES:\n            j -= 1\n            if j == i:\n                # No boundary available; oh well.\n                j = i + maxlen\n                break\n        yield s[i:j]\n        i = j", "response": "Takes a unicode string and yields pieces of it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nassign a heuristic to possible outputs from Morphy. Minimizing this heuristic avoids incorrect stems.", "response": "def _word_badness(word):\n    \"\"\"\n    Assign a heuristic to possible outputs from Morphy. Minimizing this\n    heuristic avoids incorrect stems.\n    \"\"\"\n    if word.endswith('e'):\n        return len(word) - 2\n    elif word.endswith('ess'):\n        return len(word) - 10\n    elif word.endswith('ss'):\n        return len(word) - 4\n    else:\n        return len(word)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the most likely stem for a word using Morphy.", "response": "def _morphy_best(word, pos=None):\n    \"\"\"\n    Get the most likely stem for a word using Morphy, once the input has been\n    pre-processed by morphy_stem().\n    \"\"\"\n    results = []\n    if pos is None:\n        pos = 'nvar'\n    for pos_item in pos:\n        results.extend(morphy(word, pos_item))\n    if not results:\n        return None\n    results.sort(key=lambda x: _word_badness(x))\n    return results[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the most likely stem for a word.", "response": "def morphy_stem(word, pos=None):\n    \"\"\"\n    Get the most likely stem for a word. If a part of speech is supplied,\n    the stem will be more accurate.\n\n    Valid parts of speech are:\n\n    - 'n' or 'NN' for nouns\n    - 'v' or 'VB' for verbs\n    - 'a' or 'JJ' for adjectives\n    - 'r' or 'RB' for adverbs\n\n    Any other part of speech will be treated as unknown.\n    \"\"\"\n    word = word.lower()\n    if pos is not None:\n        if pos.startswith('NN'):\n            pos = 'n'\n        elif pos.startswith('VB'):\n            pos = 'v'\n        elif pos.startswith('JJ'):\n            pos = 'a'\n        elif pos.startswith('RB'):\n            pos = 'r'\n    if pos is None and word.endswith('ing') or word.endswith('ed'):\n        pos = 'v'\n    if pos is not None and pos not in 'nvar':\n        pos = None\n    if word in EXCEPTIONS:\n        return EXCEPTIONS[word]\n    if pos is None:\n        if word in AMBIGUOUS_EXCEPTIONS:\n            return AMBIGUOUS_EXCEPTIONS[word]\n    return _morphy_best(word, pos) or word"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntag a text into words and return a list of triples that are tagged with the stem and the token.", "response": "def tag_and_stem(text):\n    \"\"\"\n    Returns a list of (stem, tag, token) triples:\n\n    - stem: the word's uninflected form\n    - tag: the word's part of speech\n    - token: the original word, so we can reconstruct it later\n    \"\"\"\n    tokens = tokenize(text)\n    tagged = nltk.pos_tag(tokens)\n    out = []\n    for token, tag in tagged:\n        stem = morphy_stem(token, tag)\n        out.append((stem, tag, token))\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_list(text):\n    pieces = [morphy_stem(word) for word in tokenize(text)]\n    pieces = [piece for piece in pieces if good_lemma(piece)]\n    if not pieces:\n        return [text]\n    if pieces[0] == 'to':\n        pieces = pieces[1:]\n    return pieces", "response": "Return a list of word stems that appear in the text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_topic(topic):\n    # find titles of the form Foo (bar)\n    topic = topic.replace('_', ' ')\n    match = re.match(r'([^(]+) \\(([^)]+)\\)', topic)\n    if not match:\n        return normalize(topic), None\n    else:\n        return normalize(match.group(1)), 'n/' + match.group(2).strip(' _')", "response": "Normalizes a Wikipedia topic."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting key to elements", "response": "def key2elements(key):\n    \"\"\"split key to elements\"\"\"\n    # words = key.split('.')\n    # if len(words) == 4:\n    #     return words\n    # # there is a dot in object name\n    # fieldword = words.pop(-1)\n    # nameword = '.'.join(words[-2:])\n    # if nameword[-1] in ('\"', \"'\"):\n    #     # The object name is in quotes\n    #     nameword = nameword[1:-1]\n    # elements = words[:-2] + [nameword, fieldword, ]\n    # return elements\n    words = key.split('.')\n    first2words = words[:2]\n    lastword = words[-1]\n    namewords = words[2:-1]\n    namephrase = '.'.join(namewords)\n    if namephrase.startswith(\"'\") and namephrase.endswith(\"'\"):\n        namephrase = namephrase[1:-1]\n    return first2words + [namephrase] + [lastword]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef updateidf(idf, dct):\n    for key in list(dct.keys()):\n        if key.startswith('idf.'):\n            idftag, objkey, objname, field = key2elements(key)\n            if objname == '':\n                try:\n                    idfobj = idf.idfobjects[objkey.upper()][0]\n                except IndexError as e:\n                    idfobj = idf.newidfobject(objkey.upper())\n            else:\n                idfobj = idf.getobject(objkey.upper(), objname)\n                if idfobj == None:\n                    idfobj = idf.newidfobject(objkey.upper(), Name=objname)\n            idfobj[field] = dct[key]", "response": "update idf using dct"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates fan power in bhp given the fan efficiency Pressure rise and flow", "response": "def fan_bhp(fan_tot_eff, pascal, m3s):\n    \"\"\"return the fan power in bhp given fan efficiency, Pressure rise (Pa) and flow (m3/s)\"\"\"\n    # from discussion in\n    # http://energy-models.com/forum/baseline-fan-power-calculation\n    inh2o = pascal2inh2o(pascal)\n    cfm = m3s2cfm(m3s)\n    return (cfm * inh2o * 1.0) / (6356.0 * fan_tot_eff)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn inputs for E + in pascal and m3s", "response": "def bhp2pascal(bhp, cfm, fan_tot_eff):\n    \"\"\"return inputs for E+ in pascal and m3/s\"\"\"\n    inh2o = bhp * 6356.0 * fan_tot_eff / cfm\n    pascal = inh2o2pascal(inh2o)        \n    m3s = cfm2m3s(cfm)\n    return pascal, m3s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fan_watts(fan_tot_eff, pascal, m3s):\n    # got this from a google search\n    bhp = fan_bhp(fan_tot_eff, pascal, m3s)\n    return bhp2watts(bhp)", "response": "return the fan power in watts given the fan efficiency Pressure rise and flow"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert and return inputs for E + in pascal and m3 / s", "response": "def watts2pascal(watts, cfm, fan_tot_eff):\n    \"\"\"convert and return inputs for E+ in pascal and m3/s\"\"\"\n    bhp = watts2bhp(watts)\n    return bhp2pascal(bhp, cfm, fan_tot_eff)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fanpower_bhp(ddtt):\n    from eppy.bunch_subclass import BadEPFieldError # here to prevent circular dependency\n    try:\n        fan_tot_eff = ddtt.Fan_Total_Efficiency # from V+ V8.7.0 onwards\n    except BadEPFieldError as e:\n        fan_tot_eff = ddtt.Fan_Efficiency \n    pascal = float(ddtt.Pressure_Rise)\n    if str(ddtt.Maximum_Flow_Rate).lower() == 'autosize': \n    # str can fail with unicode chars :-(\n        return 'autosize'\n    else:\n        m3s = float(ddtt.Maximum_Flow_Rate)\n    return fan_bhp(fan_tot_eff, pascal, m3s)", "response": "return fan power in bhp given the fan IDF object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the fan power in bhp given the fan IDF object", "response": "def fanpower_watts(ddtt):\n    \"\"\"return fan power in bhp given the fan IDF object\"\"\"\n    from eppy.bunch_subclass import BadEPFieldError # here to prevent circular dependency\n    try:\n        fan_tot_eff = ddtt.Fan_Total_Efficiency # from V+ V8.7.0 onwards\n    except BadEPFieldError as e:\n        fan_tot_eff = ddtt.Fan_Efficiency \n    pascal = float(ddtt.Pressure_Rise)\n    if str(ddtt.Maximum_Flow_Rate).lower() == 'autosize':\n    # str can fail with unicode chars :-(\n        return 'autosize'\n    else:\n        m3s = float(ddtt.Maximum_Flow_Rate)\n    return fan_watts(fan_tot_eff, pascal, m3s)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fan_maxcfm(ddtt):\n    if str(ddtt.Maximum_Flow_Rate).lower() == 'autosize':\n    # str can fail with unicode chars :-(\n        return 'autosize'\n    else:\n        m3s = float(ddtt.Maximum_Flow_Rate)\n        return m3s2cfm(m3s)", "response": "return the fan max cfm"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the install paths for EnergyPlus executable and weather files.", "response": "def install_paths(version=None, iddname=None):\n    \"\"\"Get the install paths for EnergyPlus executable and weather files.\n\n    We prefer to get the install path from the IDD name but fall back to\n    getting it from the version number for backwards compatibility and to\n    simplify tests.\n\n    Parameters\n    ----------\n    version : str, optional\n        EnergyPlus version in the format \"X-X-X\", e.g. \"8-7-0\".\n    iddname : str, optional\n        File path to the IDD.\n\n    Returns\n    -------\n    eplus_exe : str\n        Full path to the EnergyPlus executable.\n    eplus_weather : str\n        Full path to the EnergyPlus weather directory.\n\n    \"\"\"\n    try:\n        eplus_exe, eplus_home = paths_from_iddname(iddname)\n    except (AttributeError, TypeError, ValueError):\n        eplus_exe, eplus_home = paths_from_version(version)\n    eplus_weather = os.path.join(eplus_home, 'WeatherData')\n\n    return eplus_exe, eplus_weather"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the EnergyPlus install directory and executable path from an IDD.", "response": "def paths_from_iddname(iddname):\n    \"\"\"Get the EnergyPlus install directory and executable path.\n\n    Parameters\n    ----------\n    iddname : str, optional\n        File path to the IDD.\n\n    Returns\n    -------\n    eplus_exe : str\n        Full path to the EnergyPlus executable.\n    eplus_home : str\n        Full path to the EnergyPlus install directory.\n\n    Raises\n    ------\n    AttributeError (TypeError on Windows)\n        If iddname does not have a directory component (e.g. if None).\n    ValueError\n        If eplus_exe is not a file.\n\n    \"\"\"\n    eplus_home = os.path.abspath(os.path.dirname(iddname))\n    if platform.system() == 'Windows':\n        eplus_exe = os.path.join(eplus_home, 'energyplus.exe')\n    elif platform.system() == \"Linux\":\n        eplus_exe = os.path.join(eplus_home, 'energyplus')\n    else:\n        eplus_exe = os.path.join(eplus_home, 'energyplus')\n    if not os.path.isfile(eplus_exe):\n        raise ValueError\n    return eplus_exe, eplus_home"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the EnergyPlus install directory and executable path.", "response": "def paths_from_version(version):\n    \"\"\"Get the EnergyPlus install directory and executable path.\n\n    Parameters\n    ----------\n    version : str, optional\n        EnergyPlus version in the format \"X-X-X\", e.g. \"8-7-0\".\n\n    Returns\n    -------\n    eplus_exe : str\n        Full path to the EnergyPlus executable.\n    eplus_home : str\n        Full path to the EnergyPlus install directory.\n\n    \"\"\"\n    if platform.system() == 'Windows':\n        eplus_home = \"C:/EnergyPlusV{version}\".format(version=version)\n        eplus_exe = os.path.join(eplus_home, 'energyplus.exe')\n    elif platform.system() == \"Linux\":\n        eplus_home = \"/usr/local/EnergyPlus-{version}\".format(version=version)\n        eplus_exe = os.path.join(eplus_home, 'energyplus')\n    else:\n        eplus_home = \"/Applications/EnergyPlus-{version}\".format(version=version)\n        eplus_exe = os.path.join(eplus_home, 'energyplus')\n    return eplus_exe, eplus_home"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runIDFs(jobs, processors=1):\n    if processors <= 0:\n        processors = max(1, mp.cpu_count() - processors)\n\n    shutil.rmtree(\"multi_runs\", ignore_errors=True)\n    os.mkdir(\"multi_runs\")\n\n    prepared_runs = (prepare_run(run_id, run_data) for run_id, run_data in enumerate(jobs))\n    try:\n        pool = mp.Pool(processors)\n        pool.map(multirunner, prepared_runs)\n        pool.close()\n    except NameError:\n        # multiprocessing not present so pass the jobs one at a time\n        for job in prepared_runs:\n            multirunner([job])\n    shutil.rmtree(\"multi_runs\", ignore_errors=True)", "response": "Wrapper for run() to be used when running IDF5 runs in parallel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare_run(run_id, run_data):\n    idf, kwargs = run_data\n    epw = idf.epw\n    idf_dir = os.path.join('multi_runs', 'idf_%i' % run_id)\n    os.mkdir(idf_dir)\n    idf_path = os.path.join(idf_dir, 'in.idf')\n    idf.saveas(idf_path)\n    return (idf_path, epw), kwargs", "response": "Prepare run inputs for one of multiple EnergyPlus runs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(idf=None, weather=None, output_directory='', annual=False,\n        design_day=False, idd=None, epmacro=False, expandobjects=False,\n        readvars=False, output_prefix=None, output_suffix=None, version=False,\n        verbose='v', ep_version=None):\n    \"\"\"\n    Wrapper around the EnergyPlus command line interface.\n\n    Parameters\n    ----------\n    idf : str\n        Full or relative path to the IDF file to be run, or an IDF object.\n\n    weather : str\n        Full or relative path to the weather file.\n\n    output_directory : str, optional\n        Full or relative path to an output directory (default: 'run_outputs)\n\n    annual : bool, optional\n        If True then force annual simulation (default: False)\n\n    design_day : bool, optional\n        Force design-day-only simulation (default: False)\n\n    idd : str, optional\n        Input data dictionary (default: Energy+.idd in EnergyPlus directory)\n\n    epmacro : str, optional\n        Run EPMacro prior to simulation (default: False).\n\n    expandobjects : bool, optional\n        Run ExpandObjects prior to simulation (default: False)\n\n    readvars : bool, optional\n        Run ReadVarsESO after simulation (default: False)\n\n    output_prefix : str, optional\n        Prefix for output file names (default: eplus)\n\n    output_suffix : str, optional\n        Suffix style for output file names (default: L)\n            L: Legacy (e.g., eplustbl.csv)\n            C: Capital (e.g., eplusTable.csv)\n            D: Dash (e.g., eplus-table.csv)\n\n    version : bool, optional\n        Display version information (default: False)\n\n    verbose: str\n        Set verbosity of runtime messages (default: v)\n            v: verbose\n            q: quiet\n\n    ep_version: str\n        EnergyPlus version, used to find install directory. Required if run() is\n        called with an IDF file path rather than an IDF object.\n\n    Returns\n    -------\n    str : status\n\n    Raises\n    ------\n    CalledProcessError\n\n    AttributeError\n        If no ep_version parameter is passed when calling with an IDF file path\n        rather than an IDF object.\n\n\n    \"\"\"\n    args = locals().copy()\n    # get unneeded params out of args ready to pass the rest to energyplus.exe\n    verbose = args.pop('verbose')\n    idf = args.pop('idf')\n    iddname = args.get('idd')\n    if not isinstance(iddname, str):\n        args.pop('idd')\n    try:\n        idf_path = os.path.abspath(idf.idfname)\n    except AttributeError:\n        idf_path = os.path.abspath(idf)\n    ep_version = args.pop('ep_version')\n    # get version from IDF object or by parsing the IDF file for it\n    if not ep_version:\n        try:\n            ep_version = '-'.join(str(x) for x in idf.idd_version[:3])\n        except AttributeError:\n            raise AttributeError(\n                \"The ep_version must be set when passing an IDF path. \\\n                Alternatively, use IDF.run()\")\n\n    eplus_exe_path, eplus_weather_path = install_paths(ep_version, iddname)\n    if version:\n        # just get EnergyPlus version number and return\n        cmd = [eplus_exe_path, '--version']\n        check_call(cmd)\n        return\n\n    # convert paths to absolute paths if required\n    if os.path.isfile(args['weather']):\n        args['weather'] = os.path.abspath(args['weather'])\n    else:\n        args['weather'] = os.path.join(eplus_weather_path, args['weather'])\n    output_dir = os.path.abspath(args['output_directory'])\n    args['output_directory'] = output_dir\n\n    # store the directory we start in\n    cwd = os.getcwd()\n    run_dir = os.path.abspath(tempfile.mkdtemp())\n    os.chdir(run_dir)\n\n    # build a list of command line arguments\n    cmd = [eplus_exe_path]\n    for arg in args:\n        if args[arg]:\n            if isinstance(args[arg], bool):\n                args[arg] = ''\n            cmd.extend(['--{}'.format(arg.replace('_', '-'))])\n            if args[arg] != \"\":\n                cmd.extend([args[arg]])\n    cmd.extend([idf_path])\n\n    try:\n        if verbose == 'v':\n            print(\"\\r\\n\" + \" \".join(cmd) + \"\\r\\n\")\n            check_call(cmd)\n        elif verbose == 'q':\n            check_call(cmd, stdout=open(os.devnull, 'w'))\n    except CalledProcessError:\n        message = parse_error(output_dir)\n        raise EnergyPlusRunError(message)\n    finally:\n        os.chdir(cwd)\n    return 'OK'", "response": "Wrapper around the EnergyPlus command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_error(output_dir):\n    sys.stderr.seek(0)\n    std_err = sys.stderr.read().decode('utf-8')\n    err_file = os.path.join(output_dir, \"eplusout.err\")\n    if os.path.isfile(err_file):\n        with open(err_file, \"r\") as f:\n            ep_err = f.read()\n    else:\n        ep_err = \"<File not found>\"\n    message = \"\\r\\n{std_err}\\r\\nContents of EnergyPlus error file at {err_file}\\r\\n{ep_err}\".format(**locals())\n    return message", "response": "Parse the error file and put it in the exception message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the rvalue of a single object in IDF", "response": "def rvalue(ddtt):\n    \"\"\"\n    R value (W/K) of a construction or material.\n    thickness (m) / conductivity (W/m-K)\n    \"\"\"\n    object_type = ddtt.obj[0]\n    if object_type == 'Construction':\n        rvalue = INSIDE_FILM_R + OUTSIDE_FILM_R\n        layers = ddtt.obj[2:]\n        field_idd = ddtt.getfieldidd('Outside_Layer')\n        validobjects = field_idd['validobjects']\n        for layer in layers:\n            found = False\n            for key in validobjects:\n                try:\n                    rvalue += ddtt.theidf.getobject(key, layer).rvalue\n                    found = True\n                except AttributeError:\n                    pass\n            if not found:\n                raise AttributeError(\"%s material not found in IDF\" % layer)\n    elif object_type == 'Material':\n        thickness = ddtt.obj[ddtt.objls.index('Thickness')]\n        conductivity = ddtt.obj[ddtt.objls.index('Conductivity')]\n        rvalue = thickness / conductivity\n    elif object_type == 'Material:AirGap':\n        rvalue = ddtt.obj[ddtt.objls.index('Thermal_Resistance')] \n    elif object_type == 'Material:InfraredTransparent':\n        rvalue = 0\n    elif object_type == 'Material:NoMass':\n        rvalue = ddtt.obj[ddtt.objls.index('Thermal_Resistance')] \n    elif object_type == 'Material:RoofVegetation':\n        warnings.warn(\n            \"Material:RoofVegetation thermal properties are based on dry soil\",\n            UserWarning)\n        thickness = ddtt.obj[ddtt.objls.index('Thickness')]\n        conductivity = ddtt.obj[ddtt.objls.index('Conductivity_of_Dry_Soil')]\n        rvalue = thickness / conductivity\n    else:\n        raise AttributeError(\"%s rvalue property not implemented\" % object_type)\n    return rvalue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the heat capacity of a single object in IDF", "response": "def heatcapacity(ddtt):\n    \"\"\"\n    Heat capacity (kJ/m2-K) of a construction or material.\n    thickness (m) * density (kg/m3) * specific heat (J/kg-K) * 0.001\n    \"\"\"\n    object_type = ddtt.obj[0]\n    if object_type == 'Construction':\n        heatcapacity = 0\n        layers = ddtt.obj[2:]\n        field_idd = ddtt.getfieldidd('Outside_Layer')\n        validobjects = field_idd['validobjects']\n        for layer in layers:\n            found = False\n            for key in validobjects:\n                try:\n                    heatcapacity += ddtt.theidf.getobject(key, layer).heatcapacity\n                    found = True\n                except AttributeError:\n                    pass\n            if not found:\n                raise AttributeError(\"%s material not found in IDF\" % layer)\n    elif object_type == 'Material':\n        thickness = ddtt.obj[ddtt.objls.index('Thickness')]\n        density = ddtt.obj[ddtt.objls.index('Density')]\n        specificheat = ddtt.obj[ddtt.objls.index('Specific_Heat')]\n        heatcapacity = thickness * density * specificheat * 0.001\n    elif object_type == 'Material:AirGap':\n        heatcapacity = 0\n    elif object_type == 'Material:InfraredTransparent':\n        heatcapacity = 0\n    elif object_type == 'Material:NoMass':\n        warnings.warn(\n            \"Material:NoMass materials included in heat capacity calculation\",\n            UserWarning)\n        heatcapacity = 0\n    elif object_type == 'Material:RoofVegetation':\n        warnings.warn(\n            \"Material:RoofVegetation thermal properties are based on dry soil\",\n            UserWarning)\n        thickness = ddtt.obj[ddtt.objls.index('Thickness')]\n        density = ddtt.obj[ddtt.objls.index('Density_of_Dry_Soil')]\n        specificheat = ddtt.obj[ddtt.objls.index('Specific_Heat_of_Dry_Soil')]\n        heatcapacity = thickness * density * specificheat * 0.001\n    else:\n        raise AttributeError(\"%s has no heatcapacity property\" % object_type)\n    return heatcapacity"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if two values are equal to a given number of places.", "response": "def almostequal(first, second, places=7, printit=True):\n    \"\"\"\n    Test if two values are equal to a given number of places.\n    This is based on python's unittest so may be covered by Python's\n    license.\n\n    \"\"\"\n    if first == second:\n        return True\n\n    if round(abs(second - first), places) != 0:\n        if printit:\n            print(round(abs(second - first), places))\n            print(\"notalmost: %s != %s to %i places\" % (first, second, places))\n        return False\n    else:\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a new object for the given key.", "response": "def newrawobject(data, commdct, key, block=None, defaultvalues=True):\n    \"\"\"Make a new object for the given key.\n\n    Parameters\n    ----------\n    data : Eplusdata object\n        Data dictionary and list of objects for the entire model.\n    commdct : list of dicts\n        Comments from the IDD file describing each item type in `data`.\n    key : str\n        Object type of the object to add (in ALL_CAPS).\n\n    Returns\n    -------\n    list\n        A list of field values for the new object.\n\n    \"\"\"\n    dtls = data.dtls\n    key = key.upper()\n\n    key_i = dtls.index(key)\n    key_comm = commdct[key_i]\n    # set default values\n    if defaultvalues:\n        obj = [comm.get('default', [''])[0] for comm in key_comm]\n    else:\n        obj = ['' for comm in key_comm]\n    if not block:\n        inblock = ['does not start with N'] * len(obj)\n    else:\n        inblock = block[key_i]\n    for i, (f_comm, f_val, f_iddname) in enumerate(zip(key_comm, obj, inblock)):\n        if i == 0:\n            obj[i] = key\n        else:\n            obj[i] = convertafield(f_comm, f_val, f_iddname)\n    obj = poptrailing(obj)  # remove the blank items in a repeating field.\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addthisbunch(bunchdt, data, commdct, thisbunch, theidf):\n    key = thisbunch.key.upper()\n    obj = copy.copy(thisbunch.obj)\n    abunch = obj2bunch(data, commdct, obj)\n    bunchdt[key].append(abunch)\n    return abunch", "response": "add a bunch to the bunchdt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking a bunch object using the data object", "response": "def obj2bunch(data, commdct, obj):\n    \"\"\"make a new bunch object using the data object\"\"\"\n    dtls = data.dtls\n    key = obj[0].upper()\n    key_i = dtls.index(key)\n    abunch = makeabunch(commdct, obj, key_i)\n    return abunch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an object to the bunchdt", "response": "def addobject(bunchdt, data, commdct, key, theidf, aname=None, **kwargs):\n    \"\"\"add an object to the eplus model\"\"\"\n    obj = newrawobject(data, commdct, key)\n    abunch = obj2bunch(data, commdct, obj)\n    if aname:\n        namebunch(abunch, aname)\n    data.dt[key].append(obj)\n    bunchdt[key].append(abunch)\n    for key, value in list(kwargs.items()):\n        abunch[key] = value\n    return abunch"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getnamedargs(*args, **kwargs):\n    adict = {}\n    for arg in args:\n        if isinstance(arg, dict):\n            adict.update(arg)\n    adict.update(kwargs)\n    return adict", "response": "allows you to pass a dict and named args\nTaxonomy so you can pass a dict and named kwargs\nTaxonomy so you can pass a dict and named args\nTaxonomy so you can pass a dict and get\n    dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addobject1(bunchdt, data, commdct, key, **kwargs):\n    obj = newrawobject(data, commdct, key)\n    abunch = obj2bunch(data, commdct, obj)\n    data.dt[key].append(obj)\n    bunchdt[key].append(abunch)\n    # adict = getnamedargs(*args, **kwargs)\n    for kkey, value in iteritems(kwargs):\n        abunch[kkey] = value\n    return abunch", "response": "add an object to the eplus model"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getobject(bunchdt, key, name):\n    # TODO : throw exception if more than one object, or return more objects\n    idfobjects = bunchdt[key]\n    if idfobjects:\n        # second item in list is a unique ID\n        unique_id = idfobjects[0].objls[1]\n    theobjs = [idfobj for idfobj in idfobjects if\n               idfobj[unique_id].upper() == name.upper()]\n    try:\n        return theobjs[0]\n    except IndexError:\n        return None", "response": "get the object if you have the key and the name\n    returns a list of objects"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if the idf object has the fields in kwargs", "response": "def __objecthasfields(bunchdt, data, commdct, idfobject, places=7, **kwargs):\n    \"\"\"test if the idf object has the field values in kwargs\"\"\"\n    for key, value in list(kwargs.items()):\n        if not isfieldvalue(\n                bunchdt, data, commdct,\n                idfobject, key, value, places=places):\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getobjects(bunchdt, data, commdct, key, places=7, **kwargs):\n    idfobjects = bunchdt[key]\n    allobjs = []\n    for obj in idfobjects:\n        if __objecthasfields(\n                bunchdt, data, commdct,\n                obj, places=places, **kwargs):\n            allobjs.append(obj)\n    return allobjs", "response": "get all the objects of the given key that match the fields in kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the index of the first extensible item", "response": "def getextensibleindex(bunchdt, data, commdct, key, objname):\n    \"\"\"get the index of the first extensible item\"\"\"\n    theobject = getobject(bunchdt, key, objname)\n    if theobject == None:\n        return None\n    theidd = iddofobject(data, commdct, key)\n    extensible_i = [\n        i for i in range(len(theidd)) if 'begin-extensible' in theidd[i]]\n    try:\n        extensible_i = extensible_i[0]\n    except IndexError:\n        return theobject"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the extensible items in the object", "response": "def removeextensibles(bunchdt, data, commdct, key, objname):\n    \"\"\"remove the extensible items in the object\"\"\"\n    theobject = getobject(bunchdt, key, objname)\n    if theobject == None:\n        return theobject\n    theidd = iddofobject(data, commdct, key)\n    extensible_i = [\n        i for i in range(len(theidd)) if 'begin-extensible' in theidd[i]]\n    try:\n        extensible_i = extensible_i[0]\n    except IndexError:\n        return theobject\n    while True:\n        try:\n            popped = theobject.obj.pop(extensible_i)\n        except IndexError:\n            break\n    return theobject"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the idd comment for the field", "response": "def getfieldcomm(bunchdt, data, commdct, idfobject, fieldname):\n    \"\"\"get the idd comment for the field\"\"\"\n    key = idfobject.obj[0].upper()\n    keyi = data.dtls.index(key)\n    fieldi = idfobject.objls.index(fieldname)\n    thiscommdct = commdct[keyi][fieldi]\n    return thiscommdct"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if case has to be retained for that field", "response": "def is_retaincase(bunchdt, data, commdct, idfobject, fieldname):\n    \"\"\"test if case has to be retained for that field\"\"\"\n    thiscommdct = getfieldcomm(bunchdt, data, commdct, idfobject, fieldname)\n    return 'retaincase' in thiscommdct"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isfieldvalue(bunchdt, data, commdct, idfobj, fieldname, value, places=7):\n    # do a quick type check\n    # if type(idfobj[fieldname]) != type(value):\n    # return False # takes care of autocalculate and real\n    # check float\n    thiscommdct = getfieldcomm(bunchdt, data, commdct, idfobj, fieldname)\n    if 'type' in thiscommdct:\n        if thiscommdct['type'][0] in ('real', 'integer'):\n            # test for autocalculate\n            try:\n                if idfobj[fieldname].upper() == 'AUTOCALCULATE':\n                    if value.upper() == 'AUTOCALCULATE':\n                        return True\n            except AttributeError:\n                pass\n            return almostequal(float(idfobj[fieldname]), float(value), places, False)\n    # check retaincase\n    if is_retaincase(bunchdt, data, commdct, idfobj, fieldname):\n        return idfobj[fieldname] == value\n    else:\n        return idfobj[fieldname].upper() == value.upper()", "response": "test if idfobj. field == value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef equalfield(bunchdt, data, commdct, idfobj1, idfobj2, fieldname, places=7):\n    # TODO test if both objects are of same type\n    key1 = idfobj1.obj[0].upper()\n    key2 = idfobj2.obj[0].upper()\n    if key1 != key2:\n        raise NotSameObjectError\n    vee2 = idfobj2[fieldname]\n    return isfieldvalue(\n        bunchdt, data, commdct,\n        idfobj1, fieldname, vee2, places=places)", "response": "returns true if the two fields are equal"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the reference names for this object", "response": "def getrefnames(idf, objname):\n    \"\"\"get the reference names for this object\"\"\"\n    iddinfo = idf.idd_info\n    dtls = idf.model.dtls\n    index = dtls.index(objname)\n    fieldidds = iddinfo[index]\n    for fieldidd in fieldidds:\n        if 'field' in fieldidd:\n            if fieldidd['field'][0].endswith('Name'):\n                if 'reference' in fieldidd:\n                    return fieldidd['reference']\n                else:\n                    return []"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rename(idf, objkey, objname, newname):\n    refnames = getrefnames(idf, objkey)\n    for refname in refnames:\n        objlists = getallobjlists(idf, refname)\n        # [('OBJKEY', refname, fieldindexlist), ...]\n        for refname in refnames:\n        # TODO : there seems to be a duplication in this loop. Check.\n        # refname appears in both loops\n            for robjkey, refname, fieldindexlist in objlists:\n                idfobjects = idf.idfobjects[robjkey]\n                for idfobject in idfobjects:\n                    for findex in fieldindexlist:  # for each field\n                        if idfobject[idfobject.objls[findex]] == objname:\n                            idfobject[idfobject.objls[findex]] = newname\n    theobject = idf.getobject(objkey, objname)\n    fieldname = [item for item in theobject.objls if item.endswith('Name')][0]\n    theobject[fieldname] = newname\n    return theobject", "response": "rename all the refrences to this objname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zone_height_min2max(idf, zonename, debug=False):\n    zone = idf.getobject('ZONE', zonename)\n    surfs = idf.idfobjects['BuildingSurface:Detailed'.upper()]\n    zone_surfs = [s for s in surfs if s.Zone_Name == zone.Name]\n    surf_xyzs = [eppy.function_helpers.getcoords(s) for s in zone_surfs]\n    surf_xyzs = list(itertools.chain(*surf_xyzs))\n    surf_zs = [z for x, y, z in surf_xyzs]\n    topz = max(surf_zs)\n    botz = min(surf_zs)\n    height = topz - botz\n    return height", "response": "zone height min - max"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the height of a zone", "response": "def zoneheight(idf, zonename, debug=False):\n    \"\"\"zone height\"\"\"\n    zone = idf.getobject('ZONE', zonename)\n    surfs = idf.idfobjects['BuildingSurface:Detailed'.upper()]\n    zone_surfs = [s for s in surfs if s.Zone_Name == zone.Name]\n    floors = [s for s in zone_surfs if s.Surface_Type.upper() == 'FLOOR']\n    roofs = [s for s in zone_surfs if s.Surface_Type.upper() == 'ROOF']\n    if floors == [] or roofs == []:\n        height = zone_height_min2max(idf, zonename)\n    else:\n        height = zone_floor2roofheight(idf, zonename)\n    return height"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nzones floor to roof height", "response": "def zone_floor2roofheight(idf, zonename, debug=False):\n    \"\"\"zone floor to roof height\"\"\"\n    zone = idf.getobject('ZONE', zonename)\n    surfs = idf.idfobjects['BuildingSurface:Detailed'.upper()]\n    zone_surfs = [s for s in surfs if s.Zone_Name == zone.Name]\n    floors = [s for s in zone_surfs if s.Surface_Type.upper() == 'FLOOR']\n    roofs = [s for s in zone_surfs if s.Surface_Type.upper() == 'ROOF']\n    ceilings = [s for s in zone_surfs if s.Surface_Type.upper() == 'CEILING']\n    topsurfaces = roofs + ceilings\n\n    topz = []\n    for topsurface in topsurfaces:\n        for coord in topsurface.coords:\n            topz.append(coord[-1])\n    topz = max(topz)\n\n    botz = []\n    for floor in floors:\n        for coord in floor.coords:\n            botz.append(coord[-1])\n    botz = min(botz)\n    height = topz - botz\n\n    return height"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setiddname(cls, iddname, testing=False):\n        if cls.iddname == None:\n            cls.iddname = iddname\n            cls.idd_info = None\n            cls.block = None\n        elif cls.iddname == iddname:\n            pass\n        else:\n            if testing == False:\n                errortxt = \"IDD file is set to: %s\" % (cls.iddname,)\n                raise IDDAlreadySetError(errortxt)", "response": "Set the path to the EnergyPlus IDD file which is used by eppy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the IDD to be used by eppy.", "response": "def setidd(cls, iddinfo, iddindex, block, idd_version):\n        \"\"\"Set the IDD to be used by eppy.\n\n        Parameters\n        ----------\n        iddinfo : list\n            Comments and metadata about fields in the IDD.\n        block : list\n            Field names in the IDD.\n\n        \"\"\"\n        cls.idd_info = iddinfo\n        cls.block = block\n        cls.idd_index = iddindex\n        cls.idd_version = idd_version"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initread(self, idfname):\n        with open(idfname, 'r') as _:\n            # raise nonexistent file error early if idfname doesn't exist\n            pass\n        iddfhandle = StringIO(iddcurrent.iddtxt)\n        if self.getiddname() == None:\n            self.setiddname(iddfhandle)\n        self.idfname = idfname\n        self.read()", "response": "Initialize the IDD with the contents of the IDF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef initreadtxt(self, idftxt):\n        iddfhandle = StringIO(iddcurrent.iddtxt)\n        if self.getiddname() == None:\n            self.setiddname(iddfhandle)\n        idfhandle = StringIO(idftxt)\n        self.idfname = idfhandle\n        self.read()", "response": "Initialize the IDD and read an IDF from text data."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the IDF file and the IDD file.", "response": "def read(self):\n        \"\"\"\n        Read the IDF file and the IDD file. If the IDD file had already been\n        read, it will not be read again.\n\n        Read populates the following data structures:\n\n        - idfobjects : list\n        - model : list\n        - idd_info : list\n        - idd_index : dict\n\n        \"\"\"\n        if self.getiddname() == None:\n            errortxt = (\"IDD file needed to read the idf file. \"\n                        \"Set it using IDF.setiddname(iddfile)\")\n            raise IDDNotSetError(errortxt)\n        readout = idfreader1(\n            self.idfname, self.iddname, self,\n            commdct=self.idd_info, block=self.block)\n        (self.idfobjects, block, self.model,\n            idd_info, idd_index, idd_version) = readout\n        self.__class__.setidd(idd_info, idd_index, block, idd_version)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef initnew(self, fname):\n        iddfhandle = StringIO(iddcurrent.iddtxt)\n        if self.getiddname() == None:\n            self.setiddname(iddfhandle)\n        idfhandle = StringIO('')\n        self.idfname = idfhandle\n        self.read()\n        if fname:\n            self.idfname = fname", "response": "Initialize the current IDD and create a new empty IDF."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new IDF object to the model.", "response": "def newidfobject(self, key, aname='', defaultvalues=True, **kwargs):\n        \"\"\"\n        Add a new idfobject to the model. If you don't specify a value for a\n        field, the default value will be set.\n\n        For example ::\n\n            newidfobject(\"CONSTRUCTION\")\n            newidfobject(\"CONSTRUCTION\",\n                Name='Interior Ceiling_class',\n                Outside_Layer='LW Concrete',\n                Layer_2='soundmat')\n\n        Parameters\n        ----------\n        key : str\n            The type of IDF object. This must be in ALL_CAPS.\n        aname : str, deprecated\n            This parameter is not used. It is left there for backward\n            compatibility.\n        defaultvalues: boolean\n            default is True. If True default values WILL be set. \n            If False, default values WILL NOT be set\n        **kwargs\n            Keyword arguments in the format `field=value` used to set the value\n            of fields in the IDF object when it is created.\n\n        Returns\n        -------\n        EpBunch object\n\n        \"\"\"\n        \n        obj = newrawobject(self.model, self.idd_info, \n                    key, block=self.block, defaultvalues=defaultvalues)\n        abunch = obj2bunch(self.model, self.idd_info, obj)\n        if aname:\n            warnings.warn(\"The aname parameter should no longer be used.\", UserWarning)\n            namebunch(abunch, aname)\n        self.idfobjects[key].append(abunch)\n        for k, v in list(kwargs.items()):\n            abunch[k] = v\n        return abunch"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef removeidfobject(self, idfobject):\n        key = idfobject.key.upper()\n        self.idfobjects[key].remove(idfobject)", "response": "Removes an IDF object from the IDF."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copyidfobject(self, idfobject):\n        return addthisbunch(self.idfobjects,\n                     self.model,\n                     self.idd_info,\n                     idfobject, self)", "response": "Add an IDF object to the IDF."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the index of the first extensible item in the list of items in the IDF table.", "response": "def getextensibleindex(self, key, name):\n        \"\"\"\n        Get the index of the first extensible item.\n\n        Only for internal use. # TODO : hide this\n\n        Parameters\n        ----------\n        key : str\n            The type of IDF object. This must be in ALL_CAPS.\n        name : str\n            The name of the object to fetch.\n\n        Returns\n        -------\n        int\n\n        \"\"\"\n        return getextensibleindex(\n            self.idfobjects, self.model, self.idd_info,\n            key, name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef removeextensibles(self, key, name):\n        return removeextensibles(\n            self.idfobjects, self.model, self.idd_info,\n            key, name)", "response": "Remove extensible items in the object of key and name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the string representation of the IDF.", "response": "def idfstr(self):\n        \"\"\"String representation of the IDF.\n\n        Returns\n        -------\n        str\n\n        \"\"\"\n        if self.outputtype == 'standard':\n            astr = ''\n        else:\n            astr = self.model.__repr__()\n\n        if self.outputtype == 'standard':\n            astr = ''\n            dtls = self.model.dtls\n            for objname in dtls:\n                for obj in self.idfobjects[objname]:\n                    astr = astr + obj.__repr__()\n        elif self.outputtype == 'nocomment':\n            return astr\n        elif self.outputtype == 'nocomment1':\n            slist = astr.split('\\n')\n            slist = [item.strip() for item in slist]\n            astr = '\\n'.join(slist)\n        elif self.outputtype == 'nocomment2':\n            slist = astr.split('\\n')\n            slist = [item.strip() for item in slist]\n            slist = [item for item in slist if item != '']\n            astr = '\\n'.join(slist)\n        elif self.outputtype == 'compressed':\n            slist = astr.split('\\n')\n            slist = [item.strip() for item in slist]\n            astr = ' '.join(slist)\n        else:\n            raise ValueError(\"%s is not a valid outputtype\" % self.outputtype)\n        return astr"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the IDF as a text file with the optional filename passed or with the current idfname of the IDF.", "response": "def save(self, filename=None, lineendings='default', encoding='latin-1'):\n        \"\"\"\n        Save the IDF as a text file with the optional filename passed, or with\n        the current idfname of the IDF.\n\n        Parameters\n        ----------\n        filename : str, optional\n            Filepath to save the file. If None then use the IDF.idfname\n            parameter. Also accepts a file handle.\n\n        lineendings : str, optional\n            Line endings to use in the saved file. Options are 'default',\n            'windows' and 'unix' the default is 'default' which uses the line\n            endings for the current system.\n\n        encoding : str, optional\n            Encoding to use for the saved file. The default is 'latin-1' which\n            is compatible with the EnergyPlus IDFEditor.\n\n        \"\"\"\n        if filename is None:\n            filename = self.idfname\n        s = self.idfstr()\n        if lineendings == 'default':\n            system = platform.system()\n            s = '!- {} Line endings \\n'.format(system) + s\n            slines = s.splitlines()\n            s = os.linesep.join(slines)\n        elif lineendings == 'windows':\n            s = '!- Windows Line endings \\n' + s\n            slines = s.splitlines()\n            s = '\\r\\n'.join(slines)\n        elif lineendings == 'unix':\n            s = '!- Unix Line endings \\n' + s\n            slines = s.splitlines()\n            s = '\\n'.join(slines)\n\n        s = s.encode(encoding)\n        try:\n            with open(filename, 'wb') as idf_out:\n                idf_out.write(s)\n        except TypeError:  # in the case that filename is a file handle\n            try:\n                filename.write(s)\n            except TypeError:\n                filename.write(s.decode(encoding))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef saveas(self, filename, lineendings='default', encoding='latin-1'):\n        self.idfname = filename\n        self.save(filename, lineendings, encoding)", "response": "Save the IDF as a text file with the filename passed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave a copy of the file with the filename passed.", "response": "def savecopy(self, filename, lineendings='default', encoding='latin-1'):\n        \"\"\"Save a copy of the file with the filename passed.\n\n        Parameters\n        ----------\n        filename : str\n            Filepath to save the file.\n\n        lineendings : str, optional\n            Line endings to use in the saved file. Options are 'default',\n            'windows' and 'unix' the default is 'default' which uses the line\n            endings for the current system.\n\n        encoding : str, optional\n            Encoding to use for the saved file. The default is 'latin-1' which\n            is compatible with the EnergyPlus IDFEditor.\n\n        \"\"\"\n        self.save(filename, lineendings, encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, **kwargs):\n        # write the IDF to the current directory\n        self.saveas('in.idf')\n        # if `idd` is not passed explicitly, use the IDF.iddname\n        idd = kwargs.pop('idd', self.iddname)\n        epw = kwargs.pop('weather', self.epw)\n        try:\n            run(self, weather=epw, idd=idd, **kwargs)\n        finally:\n            os.remove('in.idf')", "response": "This is the main entry point for the EnergyPlus command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef printdict(adict):\n    dlist = list(adict.keys())\n    dlist.sort()\n    for i in range(0, len(dlist)):\n        print(dlist[i], adict[dlist[i]])", "response": "printdict - prints the dictionary adict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a tabstr to a list of unique ids", "response": "def tabstr2list(data):\n    \"\"\"tabstr2list\"\"\"\n    alist = data.split(os.linesep)\n    blist = alist[1].split('\\t')\n\n    clist = []\n    for num in range(0, len(alist)):\n        ilist = alist[num].split('\\t')\n        clist = clist+[ilist]\n    cclist = clist[:-1]\n      #the last element is turning out to be empty\n      #this is because the string ends with a os.linesep\n    return cclist"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list2doe(alist):\n    theequal = ''\n    astr = ''\n    lenj = len(alist)\n    leni = len(alist[0])\n    for i in range(0, leni-1):\n        for j in range(0, lenj):\n            if j == 0:\n                astr = astr + alist[j][i + 1] + theequal + alist[j][0] + RET\n            else:\n                astr = astr + alist[j][0] + theequal + alist[j][i + 1] + RET\n        astr = astr + RET\n    return astr", "response": "converts a list of tables to a single table of tables"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tabfile2doefile(tabfile, doefile):\n    alist = tabfile2list(tabfile)\n    astr = list2doe(alist)\n    mylib1.write_str2file(doefile, astr)", "response": "convert tabfile to doefile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef makedoetree(ddict, bdict):\n    dlist = list(ddict.keys())\n    blist = list(bdict.keys())\n    dlist.sort()\n    blist.sort()\n    #make space dict\n    doesnot = 'DOES NOT'\n    lst = []\n    for num in range(0, len(blist)):\n        if bdict[blist[num]] == doesnot:#belong\n            lst = lst + [blist[num]]\n\n    doedict = {}\n    for num in range(0, len(lst)):\n        #print lst[num]\n        doedict[lst[num]] = {}\n    lv1list = list(doedict.keys())\n    lv1list.sort()\n\n    #make wall dict\n    #for each space\n    for i in range(0, len(lv1list)):\n        walllist = []\n        adict = doedict[lv1list[i]]\n        #loop thru the entire blist dictonary and list the ones that belong into walllist\n        for num in range(0, len(blist)):\n            if bdict[blist[num]] == lv1list[i]:\n                walllist = walllist + [blist[num]]\n        #put walllist into dict\n        for j in range(0, len(walllist)):\n            adict[walllist[j]] = {}\n\n    #make window dict\n    #for each space\n    for i in range(0, len(lv1list)):\n        adict1 = doedict[lv1list[i]]\n        #for each wall\n        walllist = list(adict1.keys())\n        walllist.sort()\n        for j in range(0, len(walllist)):\n            windlist = []\n            adict2 = adict1[walllist[j]]\n           #loop thru the entire blist dictonary and list the ones that belong into windlist\n            for num in range(0, len(blist)):\n                if bdict[blist[num]] == walllist[j]:\n                    windlist = windlist + [blist[num]]\n            #put walllist into dict\n            for k in range(0, len(windlist)):\n                adict2[windlist[k]] = {}\n    return doedict", "response": "make a new dict that contains all of the keys in ddict and bdict that are not in bdict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tree2doe(str1):\n    retstuff = makedoedict(str1)\n    ddict = makedoetree(retstuff[0], retstuff[1])\n    ddict = retstuff[0]\n    retstuff[1] = {}# don't need it anymore\n\n    str1 = ''#just re-using it\n    l1list = list(ddict.keys())\n    l1list.sort()\n    for i in range(0, len(l1list)):\n        str1 = str1 + ddict[l1list[i]]\n        l2list = list(ddict[l1list[i]].keys())\n        l2list.sort()\n        for j in range(0, len(l2list)):\n            str1 = str1 + ddict[l2list[j]]\n            l3list = list(ddict[l1list[i]][l2list[j]].keys())\n            l3list.sort()\n            for k in range(0, len(l3list)):\n                str1 = str1 + ddict[l3list[k]]\n    return str1", "response": "tree2doe - converts a string into a single DOE"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mtabstr2doestr(st1):\n    seperator = '$ =============='\n    alist = st1.split(seperator)\n\n    #this removes all the tabs that excel\n    #puts after the seperator and before the next line\n    for num in range(0, len(alist)):\n        alist[num] = alist[num].lstrip()\n    st2 = ''\n    for num in range(0, len(alist)):\n        alist = tabstr2list(alist[num])\n        st2 = st2 + list2doe(alist)\n\n    lss = st2.split('..')\n    mylib1.write_str2file('forfinal.txt', st2)#for debugging\n    print(len(lss))\n\n\n    st3 = tree2doe(st2)\n    lsss = st3.split('..')\n    print(len(lsss))\n    return st3", "response": "mtabstr2doestr - convert a string to a tree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the block bounded by start and end doesn t work for multiple blocks", "response": "def getoneblock(astr, start, end):\n    \"\"\"get the block bounded by start and end\n    doesn't work for multiple blocks\"\"\"\n    alist = astr.split(start)\n    astr = alist[-1]\n    alist = astr.split(end)\n    astr = alist[0]\n    return astr"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef doestr2tabstr(astr, kword):\n    alist = astr.split('..')\n    del astr\n    #strip junk put .. back\n    for num in range(0, len(alist)):\n        alist[num] = alist[num].strip()\n        alist[num] = alist[num] + os.linesep + '..' + os.linesep\n    alist.pop()\n\n    lblock = []\n    for num in range(0, len(alist)):\n        linels = alist[num].split(os.linesep)\n        firstline = linels[0]\n        assignls = firstline.split('=')\n        keyword = assignls[-1].strip()\n        if keyword == kword:\n            lblock = lblock + [alist[num]]\n            #print firstline\n\n    #get all val\n    lval = []\n    for num in range(0, len(lblock)):\n        block = lblock[num]\n        linel = block.split(os.linesep)\n        lvalin = []\n        for k in range(0, len(linel)):\n            line = linel[k]\n            assignl = line.split('=')\n            if k == 0:\n                lvalin = lvalin + [assignl[0]]\n            else:\n                if assignl[-1] == '..':\n                    assignl[-1] = '.'\n                lvalin = lvalin + [assignl[-1]]\n        lvalin.pop()\n        lval = lval + [lvalin]\n\n    #get keywords\n    kwordl = []\n    block = lblock[0]\n    linel = block.split(os.linesep)\n    for k in range(0, len(linel)):\n        line = linel[k]\n        assignl = line.split('=')\n        if k == 0:\n            kword = ' =  ' + assignl[1].strip()\n        else:\n            if assignl[0] == '..':\n                assignl[0] = '.'\n            else:\n                assignl[0] = assignl[0] + '='\n            kword = assignl[0].strip()\n        kwordl = kwordl + [kword]\n    kwordl.pop()\n\n    astr = ''\n    for num in range(0, len(kwordl)):\n        linest = ''\n        linest = linest + kwordl[num]\n        for k in range(0, len(lval)):\n            linest = linest + '\\t' + lval[k][num]\n        astr = astr + linest + os.linesep\n\n    return astr", "response": "converts a DOS string to a TAB string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef myreplace(astr, thefind, thereplace):\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "response": "in string astr replace all occurences of thefind with thereplace"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the slice after at sub in string astr", "response": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pickledump(theobject, fname):\n    fhandle = open(fname, 'wb')\n    pickle.dump(theobject, fhandle)", "response": "same as pickle. dump"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_str2file(pathname, astr):\n    fname = pathname\n    fhandle = open(fname, 'wb')\n    fhandle.write(astr)\n    fhandle.close()", "response": "writes a string to file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vol_tehrahedron(poly):\n    a_pnt = np.array(poly[0])\n    b_pnt = np.array(poly[1])\n    c_pnt = np.array(poly[2])\n    d_pnt = np.array(poly[3])\n    return abs(np.dot(\n        (a_pnt-d_pnt), np.cross((b_pnt-d_pnt), (c_pnt-d_pnt))) / 6)", "response": "volume of a irregular tetrahedron"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vol_zone(poly1, poly2):\n    c_point = central_p(poly1, poly2)\n    c_point = (c_point[0], c_point[1], c_point[2])\n    vol_therah = 0\n    num = len(poly1)\n    for i in range(num-2):\n        # the upper part\n        tehrahedron = [c_point, poly1[0], poly1[i+1], poly1[i+2]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n        # the bottom part\n        tehrahedron = [c_point, poly2[0], poly2[i+1], poly2[i+2]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n    # the middle part\n    for i in range(num-1):\n        tehrahedron = [c_point, poly1[i], poly2[i], poly2[i+1]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n        tehrahedron = [c_point, poly1[i], poly1[i+1], poly2[i]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n    tehrahedron = [c_point, poly1[num-1], poly2[num-1], poly2[0]]\n    vol_therah += vol_tehrahedron(tehrahedron)\n    tehrahedron = [c_point, poly1[num-1], poly1[0], poly2[0]]\n    vol_therah += vol_tehrahedron(tehrahedron)\n    return vol_therah", "response": "volume of a zone defined by two polygon bases"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef newidf(version=None):\n    if not version:\n        version = \"8.9\"\n    import eppy.easyopen as easyopen\n    idfstring = \"  Version,{};\".format(str(version))\n    fhandle = StringIO(idfstring)\n    return easyopen.easyopen(fhandle)", "response": "open a new idf file for particular version"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef openidf(fname, idd=None, epw=None):\n    import eppy.easyopen as easyopen\n    return easyopen.easyopen(fname, idd=idd, epw=epw)", "response": "automatically set idd and open idf file. Uses version from idf to set correct idd\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an interaone wall if the bsd object is an interaone wall", "response": "def wallinterzone(idf, bsdobject, deletebsd=True, setto000=False):\n    \"\"\"return an wall:interzone object if the bsd (buildingsurface:detailed) \n    is an interaone wall\"\"\"\n    # ('WALL:INTERZONE', Wall, Surface OR Zone OR OtherSideCoefficients)\n    # test if it is an exterior wall\n    if bsdobject.Surface_Type.upper() == 'WALL': # Surface_Type == wall\n        if bsdobject.Outside_Boundary_Condition.upper() in ('SURFACE', 'ZONE', 'OtherSideCoefficients'.upper()): \n            simpleobject = idf.newidfobject('WALL:INTERZONE')\n            simpleobject.Name = bsdobject.Name\n            simpleobject.Construction_Name = bsdobject.Construction_Name\n            simpleobject.Zone_Name = bsdobject.Zone_Name\n            obco = 'Outside_Boundary_Condition_Object'\n            simpleobject[obco] = bsdobject[obco]\n            simpleobject.Azimuth_Angle = bsdobject.azimuth\n            simpleobject.Tilt_Angle = bsdobject.tilt\n            surforigin = bsdorigin(bsdobject, setto000=setto000)\n            simpleobject.Starting_X_Coordinate = surforigin[0]\n            simpleobject.Starting_Y_Coordinate = surforigin[1]\n            simpleobject.Starting_Z_Coordinate = surforigin[2]\n            simpleobject.Length = bsdobject.width\n            simpleobject.Height = bsdobject.height\n            if deletebsd:\n                idf.removeidfobject(bsdobject)\n            return simpleobject\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef door(idf, fsdobject, deletebsd=True, setto000=False):\n    # ('DOOR', Door, None)\n    # test if it is aroof\n    if fsdobject.Surface_Type.upper() == 'DOOR': # Surface_Type == w\n        simpleobject = idf.newidfobject('DOOR')\n        simpleobject.Name = fsdobject.Name\n        simpleobject.Construction_Name = fsdobject.Construction_Name\n        simpleobject.Building_Surface_Name = fsdobject.Building_Surface_Name\n        simpleobject.Multiplier = fsdobject.Multiplier\n        surforigin = fsdorigin(fsdobject, setto000=setto000)\n        simpleobject.Starting_X_Coordinate = surforigin[0]\n        simpleobject.Starting_Z_Coordinate = surforigin[1]\n        simpleobject.Length = fsdobject.width\n        simpleobject.Height = fsdobject.height\n        if deletebsd:\n            idf.removeidfobject(fsdobject)\n        return simpleobject\n    return None", "response": "return an door object if the fsd ( fenestrationsurface : detailed ) is \n    a door object if the fsd ( fenestrationsurface : detailed ) is \n    a door object if the fsd ( fenestrationsurface : detailed ) is \n    a door object if the fsd ( fenestrationsurface : detailed ) is \n    a door object if the fsd ( f"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef simplesurface(idf, bsd, deletebsd=True, setto000=False):\n    funcs = (wallexterior,\n        walladiabatic,\n        wallunderground,\n        wallinterzone,\n        roof,\n        ceilingadiabatic,\n        ceilinginterzone,\n        floorgroundcontact,\n        flooradiabatic,\n        floorinterzone,)\n    for func in funcs:\n        surface = func(idf, bsd, deletebsd=deletebsd, setto000=setto000)\n        if surface:\n            return surface\n    return None", "response": "convert a bsd into a simple surface"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a bsd ( fenestrationsurface : detailed into a simple", "response": "def simplefenestration(idf, fsd, deletebsd=True, setto000=False):\n    \"\"\"convert a bsd (fenestrationsurface:detailed) into a simple \n    fenestrations\"\"\"\n    funcs = (window,\n        door,\n        glazeddoor,)\n    for func in funcs:\n        fenestration = func(idf, fsd, deletebsd=deletebsd, setto000=setto000)\n        if fenestration:\n            return fenestration\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tdbr2EOL(td):\n    for br in td.find_all(\"br\"):\n        br.replace_with(\"\\n\")\n    txt = six.text_type(td) # make it back into test \n                            # would be unicode(id) in python2\n    soup = BeautifulSoup(txt, 'lxml') # read it as a BeautifulSoup\n    ntxt = soup.find('td') # BeautifulSoup has lot of other html junk.\n                           # this line will extract just the <td> block \n    return ntxt", "response": "convert the br in td into line ending"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if the table has only strings in the cells", "response": "def is_simpletable(table):\n    \"\"\"test if the table has only strings in the cells\"\"\"\n    tds = table('td')\n    for td in tds:\n        if td.contents != []:\n            td = tdbr2EOL(td)\n            if len(td.contents) == 1:\n                thecontents = td.contents[0]\n                if not isinstance(thecontents, NavigableString):\n                    return False\n            else:\n                return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a table to a list of lists - a 2D matrix", "response": "def table2matrix(table):\n    \"\"\"convert a table to a list of lists - a 2D matrix\"\"\"\n\n    if not is_simpletable(table):\n        raise NotSimpleTable(\"Not able read a cell in the table as a string\")\n    rows = []\n    for tr in table('tr'):\n        row = []\n        for td in tr('td'):\n            td = tdbr2EOL(td) # convert any '<br>' in the td to line ending\n            try:\n                row.append(td.contents[0])\n            except IndexError:\n                row.append('')\n        rows.append(row)\n    return rows"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a table to a list of lists - a 2D matrix", "response": "def table2val_matrix(table):\n    \"\"\"convert a table to a list of lists - a 2D matrix\n    Converts numbers to float\"\"\"\n    if not is_simpletable(table):\n        raise NotSimpleTable(\"Not able read a cell in the table as a string\")\n    rows = []\n    for tr in table('tr'):\n        row = []\n        for td in tr('td'):\n            td = tdbr2EOL(td)\n            try:\n                val = td.contents[0]\n            except IndexError:\n                row.append('')\n            else:\n                try:\n                    val = float(val)\n                    row.append(val)\n                except ValueError:\n                    row.append(val)\n        rows.append(row)\n    return rows"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef titletable(html_doc, tofloat=True):\n    soup = BeautifulSoup(html_doc, \"html.parser\")\n    btables = soup.find_all(['b', 'table']) # find all the <b> and <table>\n    titletables = []\n    for i, item in enumerate(btables):\n        if item.name == 'table':\n            for j in range(i + 1):\n                if btables[i-j].name == 'b':# step back to find a <b>\n                    break\n            titletables.append((btables[i - j], item))\n    if tofloat:\n        t2m = table2val_matrix\n    else:\n        t2m = table2matrix\n    titlerows = [(tl.contents[0], t2m(tb)) for tl, tb in titletables]\n    return titlerows", "response": "return a list of tuples of title table..."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _has_name(soup_obj):\n    try:\n        name = soup_obj.name\n        if name == None:\n            return False\n        return True\n    except AttributeError:\n        return False", "response": "checks if soup_obj is really a soup object or just a string\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of lines between this table and the previous table", "response": "def lines_table(html_doc, tofloat=True):\n    \"\"\"return a list of [(lines, table), .....]\n\n    lines = all the significant lines before the table.\n        These are lines between this table and\n        the previous table or 'hr' tag\n    table = rows -> [[cell1, cell2, ..], [cell1, cell2, ..], ..]\n\n    The lines act as a description for what is in the table\n    \"\"\"\n    soup = BeautifulSoup(html_doc, \"html.parser\")\n    linestables = []\n    elements = soup.p.next_elements # start after the first para\n    for element in elements:\n        tabletup = []\n        if not _has_name(element):\n            continue\n        if element.name == 'table': # hit the first table\n            beforetable = []\n            prev_elements = element.previous_elements # walk back and get the lines\n            for prev_element in prev_elements:\n                if not _has_name(prev_element):\n                    continue\n                if prev_element.name not in ('br', None): # no lines here\n                    if prev_element.name in ('table', 'hr', 'tr', 'td'):\n                        # just hit the previous table. You got all the lines\n                        break\n                    if prev_element.parent.name == \"p\":\n                        # if the parent is \"p\", you will get it's text anyways from the parent\n                        pass\n                    else:\n                        if prev_element.get_text(): # skip blank lines\n                            beforetable.append(prev_element.get_text())\n            beforetable.reverse()\n            tabletup.append(beforetable)\n            function_selector = {True:table2val_matrix, False:table2matrix}\n            function = function_selector[tofloat]\n            tabletup.append(function(element))\n        if tabletup:\n            linestables.append(tabletup)\n    return linestables"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a named tuple grid", "response": "def _make_ntgrid(grid):\n    \"\"\"make a named tuple grid\n\n    [[\"\",  \"a b\", \"b c\", \"c d\"],\n     [\"x y\", 1,     2,     3 ],\n     [\"y z\", 4,     5,     6 ],\n     [\"z z\", 7,     8,     9 ],]\n    will return\n    ntcol(x_y=ntrow(a_b=1, b_c=2, c_d=3),\n          y_z=ntrow(a_b=4, b_c=5, c_d=6),\n          z_z=ntrow(a_b=7, b_c=8, c_d=9))\"\"\"\n    hnames = [_nospace(n) for n in grid[0][1:]]\n    vnames = [_nospace(row[0]) for row in grid[1:]]\n    vnames_s = \" \".join(vnames)\n    hnames_s = \" \".join(hnames)\n    ntcol = collections.namedtuple('ntcol', vnames_s)\n    ntrow = collections.namedtuple('ntrow', hnames_s)\n    rdict = [dict(list(zip(hnames, row[1:]))) for row in grid[1:]]\n    ntrows = [ntrow(**rdict[i]) for i, name in enumerate(vnames)]\n    ntcols = ntcol(**dict(list(zip(vnames, ntrows))))\n    return ntcols"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef onlylegalchar(name):\n    legalchar = ascii_letters + digits + ' '\n    return ''.join([s for s in name[:] if s in legalchar])", "response": "return only legal chars"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef matchfieldnames(field_a, field_b):\n    normalised_a = field_a.replace(' ', '_').lower()\n    normalised_b = field_b.replace(' ', '_').lower()\n    \n    return normalised_a == normalised_b", "response": "Check if two strings are equal ignoring case and spaces / underscore."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef intinlist(lst):\n    for item in lst:\n        try:\n            item = int(item)\n            return True\n        except ValueError:\n            pass\n    return False", "response": "test if int in list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replaceint(fname, replacewith='%s'):\n    words = fname.split()\n    for i, word in enumerate(words):\n        try:\n            word = int(word)\n            words[i] = replacewith\n        except ValueError:\n            pass\n    return ' '.join(words)", "response": "replace int in lst"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleaniddfield(acomm):\n    for key in list(acomm.keys()):\n        val = acomm[key]\n        acomm[key.lower()] = val\n    for key in list(acomm.keys()):\n        val = acomm[key]\n        if key != key.lower():\n            acomm.pop(key)\n    return acomm", "response": "make all the keys lower case"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef makecsvdiffs(thediffs, dtls, n1, n2):\n    def ishere(val):\n        if val == None:\n            return \"not here\"\n        else:\n            return \"is here\"\n    rows = []\n    rows.append(['file1 = %s' % (n1, )])\n    rows.append(['file2 = %s' % (n2, )])\n    rows.append('')\n    rows.append(theheader(n1, n2))\n    keys = list(thediffs.keys()) # ensures sorting by Name\n    keys.sort()\n    # sort the keys in the same order as in the idd\n    dtlssorter = DtlsSorter(dtls)\n    keys = sorted(keys, key=dtlssorter.getkey)\n    for key in keys:\n        if len(key) == 2:\n            rw2 = [''] + [ishere(i) for i in thediffs[key]]\n        else:\n            rw2 = list(thediffs[key])\n        rw1 = list(key)\n        rows.append(rw1 + rw2)\n    return rows", "response": "return the csv to be displayed"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the diffs between two idfs", "response": "def idfdiffs(idf1, idf2):\n    \"\"\"return the diffs between the two idfs\"\"\"\n    # for any object type, it is sorted by name\n    thediffs = {}\n    keys = idf1.model.dtls # undocumented variable\n\n    for akey in keys:\n        idfobjs1 = idf1.idfobjects[akey]\n        idfobjs2 = idf2.idfobjects[akey]\n        names = set([getobjname(i) for i in idfobjs1] +\n                    [getobjname(i) for i in idfobjs2])\n        names = sorted(names)\n        idfobjs1 = sorted(idfobjs1, key=lambda idfobj: idfobj['obj'])\n        idfobjs2 = sorted(idfobjs2, key=lambda idfobj: idfobj['obj'])\n        for name in names:\n            n_idfobjs1 = [item for item in idfobjs1\n                          if getobjname(item) == name]\n            n_idfobjs2 = [item for item in idfobjs2\n                          if getobjname(item) == name]\n            for idfobj1, idfobj2 in zip_longest(n_idfobjs1,\n                                                           n_idfobjs2):\n                if idfobj1 == None:\n                    thediffs[(idfobj2.key.upper(), \n                                getobjname(idfobj2))] = (None, idf2.idfname) #(idf1.idfname, None) -> old\n                    break\n                if idfobj2 == None:\n                    thediffs[(idfobj1.key.upper(), \n                                getobjname(idfobj1))] = (idf1.idfname, None) # (None, idf2.idfname) -> old\n                    break\n                for i, (f1, f2) in enumerate(zip(idfobj1.obj, idfobj2.obj)):\n                    if i == 0:\n                        f1, f2 = f1.upper(), f2.upper()\n                    if f1 != f2:\n                        thediffs[(\n                            akey,\n                            getobjname(idfobj1),\n                            idfobj1.objidd[i]['field'][0])] = (f1, f2)\n    return thediffs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef heading2table(soup, table, row):\n    tr = Tag(soup, name=\"tr\")\n    table.append(tr)\n    for attr in row:\n        th = Tag(soup, name=\"th\")\n        tr.append(th)\n        th.append(attr)", "response": "add heading row to table"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef row2table(soup, table, row):\n    tr = Tag(soup, name=\"tr\")\n    table.append(tr)\n    for attr in row:\n        td = Tag(soup, name=\"td\")\n        tr.append(td)\n        td.append(attr)", "response": "ad a row to the table"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extendlist(lst, i, value=''):\n    if i < len(lst):\n        pass\n    else:\n        lst.extend([value, ] * (i - len(lst) + 1))", "response": "extend the list so that you have i - th value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd functions to the epbunch", "response": "def addfunctions(abunch):\n    \"\"\"add functions to epbunch\"\"\"\n\n    key = abunch.obj[0].upper()\n\n    #-----------------\n    # TODO : alternate strategy to avoid listing the objkeys in snames\n    # check if epbunch has field \"Zone_Name\" or \"Building_Surface_Name\"\n    # and is in group u'Thermal Zones and Surfaces'\n    # then it is likely to be a surface.\n    # of course we need to recode for surfaces that do not have coordinates :-(\n    # or we can filter those out since they do not have\n    # the field \"Number_of_Vertices\"\n    snames = [\n        \"BuildingSurface:Detailed\",\n        \"Wall:Detailed\",\n        \"RoofCeiling:Detailed\",\n        \"Floor:Detailed\",\n        \"FenestrationSurface:Detailed\",\n        \"Shading:Site:Detailed\",\n        \"Shading:Building:Detailed\",\n        \"Shading:Zone:Detailed\", ]\n    snames = [sname.upper() for sname in snames]\n    if key in snames:\n        func_dict = {\n            'area': fh.area,\n            'height': fh.height,  # not working correctly\n            'width': fh.width,  # not working correctly\n            'azimuth': fh.azimuth,\n            'tilt': fh.tilt,\n            'coords': fh.getcoords,  # needed for debugging\n        }\n        abunch.__functions.update(func_dict)\n\n    #-----------------\n    # print(abunch.getfieldidd )\n    names = [\n        \"CONSTRUCTION\",\n        \"MATERIAL\",\n        \"MATERIAL:AIRGAP\",\n        \"MATERIAL:INFRAREDTRANSPARENT\",\n        \"MATERIAL:NOMASS\",\n        \"MATERIAL:ROOFVEGETATION\",\n        \"WINDOWMATERIAL:BLIND\",\n        \"WINDOWMATERIAL:GLAZING\",\n        \"WINDOWMATERIAL:GLAZING:REFRACTIONEXTINCTIONMETHOD\",\n        \"WINDOWMATERIAL:GAP\",\n        \"WINDOWMATERIAL:GAS\",\n        \"WINDOWMATERIAL:GASMIXTURE\",\n        \"WINDOWMATERIAL:GLAZINGGROUP:THERMOCHROMIC\",\n        \"WINDOWMATERIAL:SCREEN\",\n        \"WINDOWMATERIAL:SHADE\",\n        \"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\",\n              ]\n    if key in names:\n        func_dict = {\n            'rvalue': fh.rvalue,\n            'ufactor': fh.ufactor,\n            'rvalue_ip': fh.rvalue_ip,  # quick fix for Santosh. Needs to thought thru\n            'ufactor_ip': fh.ufactor_ip,  # quick fix for Santosh. Needs to thought thru\n            'heatcapacity': fh.heatcapacity,\n        }\n        abunch.__functions.update(func_dict)\n\n    names = [\n        'FAN:CONSTANTVOLUME',\n        'FAN:VARIABLEVOLUME',\n        'FAN:ONOFF',\n        'FAN:ZONEEXHAUST',\n        'FANPERFORMANCE:NIGHTVENTILATION',\n              ]\n    if key in names:\n        func_dict = {\n            'f_fanpower_bhp': fh.fanpower_bhp,\n            'f_fanpower_watts': fh.fanpower_watts,\n            'f_fan_maxcfm': fh.fan_maxcfm,\n        }\n        abunch.__functions.update(func_dict)\n    # =====\n    # code for references\n    #-----------------\n    # add function zonesurfaces\n    if key == 'ZONE':\n        func_dict = {'zonesurfaces':fh.zonesurfaces}\n        abunch.__functions.update(func_dict)\n\n    #-----------------\n    # add function subsurfaces\n    # going to cheat here a bit\n    # check if epbunch has field \"Zone_Name\"\n    # and is in group u'Thermal Zones and Surfaces'\n    # then it is likely to be a surface attached to a zone\n    fields = abunch.fieldnames\n    try:\n        group = abunch.getfieldidd('key')['group']\n    except KeyError as e:  # some pytests don't have group\n        group = None\n    if group == u'Thermal Zones and Surfaces':\n        if \"Zone_Name\" in fields:\n            func_dict = {'subsurfaces':fh.subsurfaces}\n            abunch.__functions.update(func_dict)\n\n    return abunch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the ranges for this field", "response": "def getrange(bch, fieldname):\n    \"\"\"get the ranges for this field\"\"\"\n    keys = ['maximum', 'minimum', 'maximum<', 'minimum>', 'type']\n    index = bch.objls.index(fieldname)\n    fielddct_orig = bch.objidd[index]\n    fielddct = copy.deepcopy(fielddct_orig)\n    therange = {}\n    for key in keys:\n        therange[key] = fielddct.setdefault(key, None)\n    if therange['type']:\n        therange['type'] = therange['type'][0]\n    if therange['type'] == 'real':\n        for key in keys[:-1]:\n            if therange[key]:\n                therange[key] = float(therange[key][0])\n    if therange['type'] == 'integer':\n        for key in keys[:-1]:\n            if therange[key]:\n                therange[key] = int(therange[key][0])\n    return therange"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if the value of the fieldname is in the range of the idd dict", "response": "def checkrange(bch, fieldname):\n    \"\"\"throw exception if the out of range\"\"\"\n    fieldvalue = bch[fieldname]\n    therange = bch.getrange(fieldname)\n    if therange['maximum'] != None:\n        if fieldvalue > therange['maximum']:\n            astr = \"Value %s is not less or equal to the 'maximum' of %s\"\n            astr = astr % (fieldvalue, therange['maximum'])\n            raise RangeError(astr)\n    if therange['minimum'] != None:\n        if fieldvalue < therange['minimum']:\n            astr = \"Value %s is not greater or equal to the 'minimum' of %s\"\n            astr = astr % (fieldvalue, therange['minimum'])\n            raise RangeError(astr)\n    if therange['maximum<'] != None:\n        if fieldvalue >= therange['maximum<']:\n            astr = \"Value %s is not less than the 'maximum<' of %s\"\n            astr = astr % (fieldvalue, therange['maximum<'])\n            raise RangeError(astr)\n    if  therange['minimum>'] != None:\n        if fieldvalue <= therange['minimum>']:\n            astr = \"Value %s is not greater than the 'minimum>' of %s\"\n            astr = astr % (fieldvalue, therange['minimum>'])\n            raise RangeError(astr)\n    return fieldvalue\n    \"\"\"get the idd dict for this field\n    Will return {} if the fieldname does not exist\"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getfieldidd(bch, fieldname):\n    # print(bch)\n    try:\n        fieldindex = bch.objls.index(fieldname)\n    except ValueError as e:\n        return {}  # the fieldname does not exist\n                    # so there is no idd\n    fieldidd = bch.objidd[fieldindex]\n    return fieldidd", "response": "get the idd dict for this fieldname Will return {} if the fieldname does not exist"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an item from the fieldidd given the iddkey", "response": "def getfieldidd_item(bch, fieldname, iddkey):\n    \"\"\"return an item from the fieldidd, given the iddkey\n    will return and empty list if it does not have the iddkey\n    or if the fieldname does not exist\"\"\"\n    fieldidd = getfieldidd(bch, fieldname)\n    try:\n        return fieldidd[iddkey]\n    except KeyError as e:\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isequal(bch, fieldname, value, places=7):\n    def equalalphanumeric(bch, fieldname, value):\n        if bch.get_retaincase(fieldname):\n            return bch[fieldname] == value\n        else:\n            return bch[fieldname].upper() == value.upper()\n\n    fieldidd = bch.getfieldidd(fieldname)\n    try:\n        ftype = fieldidd['type'][0]\n        if ftype in ['real', 'integer']:\n            return almostequal(bch[fieldname], float(value), places=places)\n        else:\n            return equalalphanumeric(bch, fieldname, value)\n    except KeyError as e:\n        return equalalphanumeric(bch, fieldname, value)", "response": "return True if the field is equal to value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of objects that refer to this object", "response": "def getreferingobjs(referedobj, iddgroups=None, fields=None):\n    \"\"\"Get a list of objects that refer to this object\"\"\"\n    # pseudocode for code below\n    # referringobjs = []\n    # referedobj has: -> Name\n    #                 -> reference\n    # for each obj in idf:\n    # [optional filter -> objects in iddgroup]\n    #     each field of obj:\n    #     [optional filter -> field in fields]\n    #         has object-list [refname]:\n    #             if refname in reference:\n    #                 if Name = field value:\n    #                     referringobjs.append()\n    referringobjs = []\n    idf = referedobj.theidf\n    referedidd = referedobj.getfieldidd(\"Name\")\n    try:\n        references = referedidd['reference']\n    except KeyError as e:\n        return referringobjs\n    idfobjs = idf.idfobjects.values()\n    idfobjs = list(itertools.chain.from_iterable(idfobjs))  # flatten list\n    if iddgroups:  # optional filter\n        idfobjs = [anobj for anobj in idfobjs\n            if anobj.getfieldidd('key')['group'] in iddgroups]\n    for anobj in idfobjs:\n        if not fields:\n            thefields = anobj.objls\n        else:\n            thefields = fields\n        for field in thefields:\n            try:\n                itsidd = anobj.getfieldidd(field)\n            except ValueError as e:\n                continue\n            if 'object-list' in itsidd:\n                refname = itsidd['object-list'][0]\n                if refname in references:\n                    if referedobj.isequal('Name', anobj[field]):\n                        referringobjs.append(anobj)\n    return referringobjs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_referenced_object(referring_object, fieldname):\n    idf = referring_object.theidf\n    object_list = referring_object.getfieldidd_item(fieldname, u'object-list')\n    for obj_type in idf.idfobjects:\n        for obj in idf.idfobjects[obj_type]:\n            valid_object_lists = obj.getfieldidd_item(\"Name\", u'reference')\n            if set(object_list).intersection(set(valid_object_lists)):\n                referenced_obj_name = referring_object[fieldname]\n                if obj.Name == referenced_obj_name:\n                    return obj", "response": "Get an object that is referenced by a field in another object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the field == value", "response": "def isequal(self, fieldname, value, places=7):\n        \"\"\"return True if the field == value\n        Will retain case if get_retaincase == True\n        for real value will compare to decimal 'places'\n        \"\"\"\n        return isequal(self, fieldname, value, places=places)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getreferingobjs(self, iddgroups=None, fields=None):\n        return getreferingobjs(self, iddgroups=iddgroups, fields=fields)", "response": "Get a list of objects that refer to this object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvoluming of a irregular tetrahedron", "response": "def vol_tehrahedron(poly):\n    \"\"\"volume of a irregular tetrahedron\"\"\"\n    p_a = np.array(poly[0])\n    p_b = np.array(poly[1])\n    p_c = np.array(poly[2])\n    p_d = np.array(poly[3])\n    return abs(np.dot(\n        np.subtract(p_a, p_d),\n        np.cross(\n            np.subtract(p_b, p_d),\n            np.subtract(p_c, p_d))) / 6)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vol(poly1, poly2):\n    c_point = central_p(poly1, poly2)\n    c_point = (c_point[0], c_point[1], c_point[2])\n    vol_therah = 0\n    num = len(poly1)\n    poly1.append(poly1[0])\n    poly2.append(poly2[0])\n    for i in range(num - 2):\n        # the upper part\n        tehrahedron = [c_point, poly1[0], poly1[i+1], poly1[i+2]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n        # the bottom part\n        tehrahedron = [c_point, poly2[0], poly2[i+1], poly2[i+2]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n    # the middle part\n    for i in range(num):\n        tehrahedron = [c_point, poly1[i], poly2[i], poly2[i+1]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n        tehrahedron = [c_point, poly1[i], poly1[i+1], poly2[i]]\n        vol_therah += vol_tehrahedron(tehrahedron)\n    return vol_therah", "response": "volume of a zone defined by two polygon bases"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef makename2refdct(commdct):\n    refdct = {}\n    for comm in commdct: # commdct is a list of dict\n        try:\n            idfobj = comm[0]['idfobj'].upper()\n            field1 = comm[1]\n            if 'Name' in field1['field']:\n                references = field1['reference']\n                refdct[idfobj] = references\n        except (KeyError, IndexError) as e:\n            continue # not the expected pattern for reference\n    return refdct", "response": "make the name2refs dict in the idd_index"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking the ref2namesdct in the idd_index", "response": "def makeref2namesdct(name2refdct):\n    \"\"\"make the ref2namesdct in the idd_index\"\"\"\n    ref2namesdct = {}\n    for key, values in name2refdct.items():\n        for value in values:\n            ref2namesdct.setdefault(value, set()).add(key)\n    return ref2namesdct"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ref2names2commdct(ref2names, commdct):\n    for comm in commdct:\n        for cdct in comm:\n            try:\n                refs = cdct['object-list'][0]\n                validobjects = ref2names[refs]\n                cdct.update({'validobjects':validobjects})\n            except KeyError as e:\n                continue\n    return commdct", "response": "embed ref2names into commdct"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prevnode(edges, component):\n    e = edges\n    c = component\n    n2c = [(a, b) for a, b in e if type(a) == tuple]\n    c2n = [(a, b) for a, b in e if type(b) == tuple]\n    node2cs = [(a, b) for a, b in e if b == c]\n    c2nodes = []\n    for node2c in node2cs:\n        c2node = [(a, b) for a, b in c2n if b == node2c[0]]\n        if len(c2node) == 0:\n            # return []\n            c2nodes = []\n            break\n        c2nodes.append(c2node[0])\n    cs = [a for a, b in c2nodes]\n    # test for connections that have no nodes\n    # filter for no nodes\n    nonodes = [(a, b) for a, b in e if type(a) != tuple and type(b) != tuple]\n    for a, b in nonodes:\n        if b == component:\n            cs.append(a)\n    return cs", "response": "get the pervious component in the loop"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninserts an idfobject to list1 and list2.", "response": "def insert(self, i, v):\n        \"\"\"Insert an idfobject (bunch) to list1 and its object to list2.\"\"\"\n        self.list1.insert(i, v)\n        self.list2.insert(i, v.obj)\n        if isinstance(v, EpBunch):\n            v.theidf = self.theidf"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncollecting data into fixed - length chunks or blocks", "response": "def grouper(num, iterable, fillvalue=None):\n    \"Collect data into fixed-length chunks or blocks\"\n    # grouper(3, 'ABCDEFG', 'x') --> ABC DEF Gxx\n    args = [iter(iterable)] * num\n    return zip_longest(fillvalue=fillvalue, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the coordinates of the surface", "response": "def getcoords(ddtt):\n    \"\"\"return the coordinates of the surface\"\"\"\n    n_vertices_index = ddtt.objls.index('Number_of_Vertices')\n    first_x = n_vertices_index + 1 # X of first coordinate\n    pts = ddtt.obj[first_x:]\n    return list(grouper(3, pts))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cleanupversion(ver):\n    lst = ver.split(\".\")\n    if len(lst) == 1:\n        lst.extend(['0', '0'])\n    elif len(lst) == 2:\n        lst.extend(['0'])\n    elif len(lst) > 2:\n        lst = lst[:3]\n    lst[2] = '0' # ensure the 3rd number is 0    \n    cleanver = '.'.join(lst)\n    return cleanver", "response": "massage the version number so it matches the format of install folder"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getiddfile(versionid):\n    vlist = versionid.split('.')\n    if len(vlist) == 1:\n        vlist = vlist + ['0', '0']\n    elif len(vlist) == 2:\n        vlist = vlist + ['0']\n    ver_str =  '-'.join(vlist)\n    eplus_exe, _  = eppy.runner.run_functions.install_paths(ver_str)\n    eplusfolder = os.path.dirname(eplus_exe)\n    iddfile = '{}/Energy+.idd'.format(eplusfolder, )\n    return iddfile", "response": "find the IDD file of the E + installation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removecomment(astr, cphrase):\n    # linesep = mylib3.getlinesep(astr)\n    alist = astr.splitlines()\n    for i in range(len(alist)):\n        alist1 = alist[i].split(cphrase)\n        alist[i] = alist1[0]\n\n    # return string.join(alist, linesep)\n    return '\\n'.join(alist)", "response": "removecomment is similar to the comment in python."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initdict(self, fname):\n        if isinstance(fname, Idd):\n            self.dt, self.dtls = fname.dt, fname.dtls\n            return self.dt, self.dtls\n\n        astr = mylib2.readfile(fname)\n        nocom = removecomment(astr, '!')\n        idfst = nocom\n        alist = idfst.split(';')\n        lss = []\n        for element in alist:\n            lst = element.split(',')\n            lss.append(lst)\n\n        for i in range(0, len(lss)):\n            for j in range(0, len(lss[i])):\n                lss[i][j] = lss[i][j].strip()\n\n        dt = {}\n        dtls = []\n        for element in lss:\n            if element[0] == '':\n                continue\n            dt[element[0].upper()] = []\n            dtls.append(element[0].upper())\n\n        self.dt, self.dtls = dt, dtls\n        return dt, dtls", "response": "create a blank dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef makedict(self, dictfile, fnamefobject):\n        #fname = './exapmlefiles/5ZoneDD.idf'\n        #fname = './1ZoneUncontrolled.idf'\n        if isinstance(dictfile, Idd):\n            localidd = copy.deepcopy(dictfile)\n            dt, dtls = localidd.dt, localidd.dtls\n        else:\n            dt, dtls = self.initdict(dictfile)\n        # astr = mylib2.readfile(fname)\n        astr = fnamefobject.read()\n        try:\n            astr = astr.decode('ISO-8859-2')\n        except AttributeError:\n            pass\n        fnamefobject.close()\n        nocom = removecomment(astr, '!')\n        idfst = nocom\n        # alist = string.split(idfst, ';')\n        alist = idfst.split(';')\n        lss = []\n        for element in alist:\n            # lst = string.split(element, ',')\n            lst = element.split(',')\n            lss.append(lst)\n\n        for i in range(0, len(lss)):\n            for j in range(0, len(lss[i])):\n                lss[i][j] = lss[i][j].strip()\n\n        for element in lss:\n            node = element[0].upper()\n            if node in dt:\n                # stuff data in this key\n                dt[node.upper()].append(element)\n            else:\n                # scream\n                if node == '':\n                    continue\n                print('this node -%s-is not present in base dictionary' %\n                      (node))\n\n        self.dt, self.dtls = dt, dtls\n        return dt, dtls", "response": "stuff file data into the blank dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replacenode(self, othereplus, node):\n        node = node.upper()\n        self.dt[node.upper()] = othereplus.dt[node.upper()]", "response": "replace the node here with the node from othereplus"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add2node(self, othereplus, node):\n        node = node.upper()\n        self.dt[node.upper()] = self.dt[node.upper()] + \\\n            othereplus.dt[node.upper()]", "response": "add the node here with the node from othereplus"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an item to the node.", "response": "def addinnode(self, otherplus, node, objectname):\n        \"\"\"add an item to the node.\n        example: add a new zone to the element 'ZONE' \"\"\"\n        # do a test for unique object here\n        newelement = otherplus.dt[node.upper()]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getrefs(self, reflist):\n        alist = []\n        for element in reflist:\n            if element[0].upper() in self.dt:\n                for elm in self.dt[element[0].upper()]:\n                    alist.append(elm[element[1]])\n        return alist", "response": "getrefs returns a list of all the fields refered by reflist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing a graph without the nodes", "response": "def dropnodes(edges):\n    \"\"\"draw a graph without the nodes\"\"\"\n    newedges = []\n    added = False\n    for edge in edges:\n        if bothnodes(edge):\n            newtup = (edge[0][0], edge[1][0])\n            newedges.append(newtup)\n            added = True\n        elif firstisnode(edge):\n            for edge1 in edges:\n                if edge[0] == edge1[1]:\n                    newtup = (edge1[0], edge[1])\n                    try:\n                        newedges.index(newtup)\n                    except ValueError as e:\n                        newedges.append(newtup)\n                    added = True\n        elif secondisnode(edge):\n            for edge1 in edges:\n                if edge[1] == edge1[0]:\n                    newtup = (edge[0], edge1[1])\n                    try:\n                        newedges.index(newtup)\n                    except ValueError as e:\n                        newedges.append(newtup)\n                    added = True\n        # gets the hanging nodes - nodes with no connection\n        if not added:\n            if firstisnode(edge):\n                newedges.append((edge[0][0], edge[1]))\n            if secondisnode(edge):\n                newedges.append((edge[0], edge[1][0]))\n        added = False\n    return newedges"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngathers the nodes from the edges", "response": "def edges2nodes(edges):\n    \"\"\"gather the nodes from the edges\"\"\"\n    nodes = []\n    for e1, e2 in edges:\n        nodes.append(e1)\n        nodes.append(e2)\n    nodedict = dict([(n, None) for n in nodes])\n    justnodes = list(nodedict.keys())\n    # justnodes.sort()\n    justnodes = sorted(justnodes, key=lambda x: str(x[0]))\n    return justnodes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef makediagram(edges):\n    graph = pydot.Dot(graph_type='digraph')\n    nodes = edges2nodes(edges)\n    epnodes = [(node, \n        makeanode(node[0])) for node in nodes if nodetype(node)==\"epnode\"]\n    endnodes = [(node, \n        makeendnode(node[0])) for node in nodes if nodetype(node)==\"EndNode\"]\n    epbr = [(node, makeabranch(node)) for node in nodes if not istuple(node)]\n    nodedict = dict(epnodes + epbr + endnodes)\n    for value in list(nodedict.values()):\n        graph.add_node(value)\n    for e1, e2 in edges:\n        graph.add_edge(pydot.Edge(nodedict[e1], nodedict[e2]))\n    return graph", "response": "make the diagram with the edges"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the edges jointing the components of a branch", "response": "def makebranchcomponents(data, commdct, anode=\"epnode\"):\n    \"\"\"return the edges jointing the components of a branch\"\"\"\n    alledges = []\n\n    objkey = 'BRANCH'\n    cnamefield = \"Component %s Name\"\n    inletfield = \"Component %s Inlet Node Name\"\n    outletfield = \"Component %s Outlet Node Name\"\n\n    numobjects = len(data.dt[objkey])\n    cnamefields = loops.repeatingfields(data, commdct, objkey, cnamefield)\n    inletfields = loops.repeatingfields(data, commdct, objkey, inletfield)\n    outletfields = loops.repeatingfields(data, commdct, objkey, outletfield)\n\n    inlts = loops.extractfields(data, commdct, \n        objkey, [inletfields] * numobjects)\n    cmps = loops.extractfields(data, commdct, \n        objkey, [cnamefields] * numobjects)\n    otlts = loops.extractfields(data, commdct, \n        objkey, [outletfields] * numobjects)\n\n    zipped = list(zip(inlts, cmps, otlts))\n    tzipped = [transpose2d(item) for item in zipped]\n    for i in range(len(data.dt[objkey])):\n        tt = tzipped[i]\n        # branchname = data.dt[objkey][i][1]\n        edges = []\n        for t0 in tt:\n            edges = edges + [((t0[0], anode), t0[1]), (t0[1], (t0[2], anode))]\n        alledges = alledges + edges\n    return alledges"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef makeairplantloop(data, commdct):\n    anode = \"epnode\"\n    endnode = \"EndNode\"\n\n    # in plantloop get:\n    #     demand inlet, outlet, branchlist\n    #     supply inlet, outlet, branchlist\n    plantloops = loops.plantloopfields(data, commdct)\n    # splitters\n    #     inlet\n    #     outlet1\n    #     outlet2\n    splitters = loops.splitterfields(data, commdct)\n    #     \n    # mixer\n    #     outlet\n    #     inlet1\n    #     inlet2\n\n    mixers = loops.mixerfields(data, commdct)\n    #     \n    # supply barnchlist\n    #     branch1 -> inlet, outlet\n    #     branch2 -> inlet, outlet\n    #     branch3 -> inlet, outlet\n    #         \n    # CONNET INLET OUTLETS\n    edges = []\n\n    # get all branches\n    branchkey = \"branch\".upper()\n    branches = data.dt[branchkey]\n    branch_i_o = {}\n    for br in branches:\n        br_name = br[1]\n        in_out = loops.branch_inlet_outlet(data, commdct, br_name)\n        branch_i_o[br_name] = dict(list(zip([\"inlet\", \"outlet\"], in_out)))\n    # for br_name, in_out in branch_i_o.items():\n    #     edges.append(((in_out[\"inlet\"], anode), br_name))\n    #     edges.append((br_name, (in_out[\"outlet\"], anode)))\n\n    # instead of doing the branch\n    # do the content of the branch\n    edges = makebranchcomponents(data, commdct)\n\n\n    # connect splitter to nodes\n    for splitter in splitters:\n        # splitter_inlet = inletbranch.node\n        splittername = splitter[0]\n        inletbranchname = splitter[1] \n        splitter_inlet = branch_i_o[inletbranchname][\"outlet\"]\n        # edges = splitter_inlet -> splittername\n        edges.append(((splitter_inlet, anode), splittername))\n        # splitter_outlets = ouletbranches.nodes\n        outletbranchnames = [br for br in splitter[2:]]\n        splitter_outlets = [branch_i_o[br][\"inlet\"] for br in outletbranchnames]\n        # edges = [splittername -> outlet for outlet in splitter_outlets]\n        moreedges = [(splittername, \n                            (outlet, anode)) for outlet in splitter_outlets]\n        edges = edges + moreedges\n\n    for mixer in mixers:\n        # mixer_outlet = outletbranch.node\n        mixername = mixer[0]\n        outletbranchname = mixer[1] \n        mixer_outlet = branch_i_o[outletbranchname][\"inlet\"]\n        # edges = mixername -> mixer_outlet\n        edges.append((mixername, (mixer_outlet, anode)))\n        # mixer_inlets = inletbranches.nodes\n        inletbranchnames = [br for br in mixer[2:]]\n        mixer_inlets = [branch_i_o[br][\"outlet\"] for br in inletbranchnames]\n        # edges = [mixername -> inlet for inlet in mixer_inlets]\n        moreedges = [((inlet, anode), mixername) for inlet in mixer_inlets]\n        edges = edges + moreedges\n\n    # connect demand and supply side\n    # for plantloop in plantloops:\n    #     supplyinlet = plantloop[1]\n    #     supplyoutlet = plantloop[2]\n    #     demandinlet = plantloop[4]\n    #     demandoutlet = plantloop[5]\n    #     # edges = [supplyoutlet -> demandinlet, demandoutlet -> supplyinlet]\n    #     moreedges = [((supplyoutlet, endnode), (demandinlet, endnode)), \n    #         ((demandoutlet, endnode), (supplyinlet, endnode))]\n    #     edges = edges + moreedges\n    #     \n    # -----------air loop stuff----------------------\n    # from s_airloop2.py\n    # Get the demand and supply nodes from 'airloophvac'\n    # in airloophvac get:\n    #   get branch, supplyinlet, supplyoutlet, demandinlet, demandoutlet\n    objkey = \"airloophvac\".upper()\n    fieldlists = [[\"Branch List Name\",\n        \"Supply Side Inlet Node Name\",\n        \"Demand Side Outlet Node Name\",\n        \"Demand Side Inlet Node Names\",\n        \"Supply Side Outlet Node Names\"]] * loops.objectcount(data, objkey)\n    airloophvacs = loops.extractfields(data, commdct, objkey, fieldlists)\n    # airloophvac = airloophvacs[0]\n\n    # in AirLoopHVAC:ZoneSplitter:\n    #   get Name, inlet, all outlets\n    objkey = \"AirLoopHVAC:ZoneSplitter\".upper()\n    singlefields = [\"Name\", \"Inlet Node Name\"]\n    fld = \"Outlet %s Node Name\"\n    repeatfields = loops.repeatingfields(data, commdct, objkey, fld)\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    zonesplitters = loops.extractfields(data, commdct, objkey, fieldlists)\n\n    # in AirLoopHVAC:SupplyPlenum:\n    #   get Name, Zone Name, Zone Node Name, inlet, all outlets\n    objkey = \"AirLoopHVAC:SupplyPlenum\".upper()\n    singlefields = [\"Name\", \"Zone Name\", \"Zone Node Name\", \"Inlet Node Name\"]\n    fld = \"Outlet %s Node Name\"\n    repeatfields = loops.repeatingfields(data, commdct, objkey, fld)\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    supplyplenums = loops.extractfields(data, commdct, objkey, fieldlists)\n\n    # in AirLoopHVAC:ZoneMixer:\n    #   get Name, outlet, all inlets\n    objkey = \"AirLoopHVAC:ZoneMixer\".upper()\n    singlefields = [\"Name\", \"Outlet Node Name\"]\n    fld = \"Inlet %s Node Name\"\n    repeatfields = loops.repeatingfields(data, commdct, objkey, fld)\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    zonemixers = loops.extractfields(data, commdct, objkey, fieldlists)\n\n    # in AirLoopHVAC:ReturnPlenum:\n    #   get Name, Zone Name, Zone Node Name, outlet, all inlets\n    objkey = \"AirLoopHVAC:ReturnPlenum\".upper()\n    singlefields = [\"Name\", \"Zone Name\", \"Zone Node Name\", \"Outlet Node Name\"]\n    fld = \"Inlet %s Node Name\"\n    repeatfields = loops.repeatingfields(data, commdct, objkey, fld)\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    returnplenums = loops.extractfields(data, commdct, objkey, fieldlists)\n\n\n    # connect room to each equip in equiplist\n    # in ZoneHVAC:EquipmentConnections:\n    #   get Name, equiplist, zoneairnode, returnnode\n    objkey = \"ZoneHVAC:EquipmentConnections\".upper()\n    singlefields = [\"Zone Name\", \"Zone Conditioning Equipment List Name\", \n        \"Zone Air Node Name\", \"Zone Return Air Node Name\"]\n    repeatfields = []\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    equipconnections = loops.extractfields(data, commdct, objkey, fieldlists)\n    # in ZoneHVAC:EquipmentList:\n    #   get Name, all equiptype, all equipnames\n    objkey = \"ZoneHVAC:EquipmentList\".upper()\n    singlefields = [\"Name\", ]\n    fieldlist = singlefields\n    flds = [\"Zone Equipment %s Object Type\", \"Zone Equipment %s Name\"]\n    repeatfields = loops.repeatingfields(data, commdct, objkey, flds)\n    fieldlist = fieldlist + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    equiplists = loops.extractfields(data, commdct, objkey, fieldlists)\n    equiplistdct = dict([(ep[0], ep[1:])  for ep in equiplists])\n    for key, equips in list(equiplistdct.items()):\n        enames = [equips[i] for i in range(1, len(equips), 2)]\n        equiplistdct[key] = enames\n    # adistuunit -> room    \n    # adistuunit <- VAVreheat \n    # airinlet -> VAVreheat\n    # in ZoneHVAC:AirDistributionUnit:\n    #   get Name, equiplist, zoneairnode, returnnode\n    objkey = \"ZoneHVAC:AirDistributionUnit\".upper()\n    singlefields = [\"Name\", \"Air Terminal Object Type\", \"Air Terminal Name\"]\n    repeatfields = []\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    adistuunits = loops.extractfields(data, commdct, objkey, fieldlists)\n    # code only for AirTerminal:SingleDuct:VAV:Reheat\n    # get airinletnodes for vavreheats\n    # in AirTerminal:SingleDuct:VAV:Reheat:\n    #   get Name, airinletnode\n    adistuinlets = loops.makeadistu_inlets(data, commdct)\n    alladistu_comps = []\n    for key in list(adistuinlets.keys()):\n        objkey = key.upper()\n        singlefields = [\"Name\"] + adistuinlets[key]\n        repeatfields = []\n        fieldlist = singlefields + repeatfields\n        fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n        adistu_components = loops.extractfields(data, commdct, objkey, fieldlists)\n        alladistu_comps.append(adistu_components)\n\n    # in AirTerminal:SingleDuct:Uncontrolled:\n    #   get Name, airinletnode\n    objkey = \"AirTerminal:SingleDuct:Uncontrolled\".upper()\n    singlefields = [\"Name\", \"Zone Supply Air Node Name\"]\n    repeatfields = []\n    fieldlist = singlefields + repeatfields\n    fieldlists = [fieldlist] * loops.objectcount(data, objkey)\n    uncontrolleds = loops.extractfields(data, commdct, objkey, fieldlists)\n\n    anode = \"epnode\"\n    endnode = \"EndNode\"\n\n    # edges = []\n\n    # connect demand and supply side\n    # for airloophvac in airloophvacs:\n    #     supplyinlet = airloophvac[1]\n    #     supplyoutlet = airloophvac[4]\n    #     demandinlet = airloophvac[3]\n    #     demandoutlet = airloophvac[2]\n    #     # edges = [supplyoutlet -> demandinlet, demandoutlet -> supplyinlet]\n    #     moreedges = [((supplyoutlet, endnode), (demandinlet, endnode)),\n    #         ((demandoutlet, endnode), (supplyinlet, endnode))]\n    #     edges = edges + moreedges\n\n    # connect zonesplitter to nodes\n    for zonesplitter in zonesplitters:\n        name = zonesplitter[0]\n        inlet = zonesplitter[1]\n        outlets = zonesplitter[2:]\n        edges.append(((inlet, anode), name))\n        for outlet in outlets:\n            edges.append((name, (outlet, anode)))\n\n    # connect supplyplenum to nodes\n    for supplyplenum in supplyplenums:\n        name = supplyplenum[0]\n        inlet = supplyplenum[3]\n        outlets = supplyplenum[4:]\n        edges.append(((inlet, anode), name))\n        for outlet in outlets:\n            edges.append((name, (outlet, anode)))\n\n    # connect zonemixer to nodes\n    for zonemixer in zonemixers:\n        name = zonemixer[0]\n        outlet = zonemixer[1]\n        inlets = zonemixer[2:]\n        edges.append((name, (outlet, anode)))\n        for inlet in inlets:\n            edges.append(((inlet, anode), name))\n\n    # connect returnplenums to nodes\n    for returnplenum in returnplenums:\n        name = returnplenum[0]\n        outlet = returnplenum[3]\n        inlets = returnplenum[4:]\n        edges.append((name, (outlet, anode)))\n        for inlet in inlets:\n            edges.append(((inlet, anode), name))\n\n    # connect room to return node\n    for equipconnection in equipconnections:\n        zonename = equipconnection[0]\n        returnnode = equipconnection[-1]\n        edges.append((zonename, (returnnode, anode)))\n    \n    # connect equips to room\n    for equipconnection in equipconnections:\n        zonename = equipconnection[0]\n        zequiplistname = equipconnection[1]\n        for zequip in equiplistdct[zequiplistname]:\n            edges.append((zequip, zonename))\n\n    # adistuunit <- adistu_component \n    for adistuunit in adistuunits:\n        unitname = adistuunit[0]\n        compname = adistuunit[2]\n        edges.append((compname, unitname))\n\n    # airinlet -> adistu_component\n    for adistu_comps in alladistu_comps:\n        for adistu_comp in adistu_comps:\n            name = adistu_comp[0]\n            for airnode in adistu_comp[1:]:\n                edges.append(((airnode, anode), name))\n\n    # supplyairnode -> uncontrolled\n    for uncontrolled in uncontrolleds:\n        name = uncontrolled[0]\n        airnode = uncontrolled[1]            \n        edges.append(((airnode, anode), name))\n                \n\n    # edges = edges + moreedges    \n    return edges", "response": "make the edges for the airloop and the plantloop"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getedges(fname, iddfile):\n    data, commdct, _idd_index = readidf.readdatacommdct(fname, iddfile=iddfile)\n    edges = makeairplantloop(data, commdct)\n    return edges", "response": "return the edges of the idf file fname"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of the input string st1 st2 and lss which are the nested list of all the variables in the Energy +. idd file", "response": "def get_nocom_vars(astr):\n    \"\"\"\n    input 'astr' which is the Energy+.idd file as a string\n    returns (st1, st2, lss)\n    st1 = with all the ! comments striped\n    st2 = strips all comments - both the '!' and '\\\\'\n    lss = nested list of all the variables in Energy+.idd file\n    \"\"\"\n    nocom = nocomment(astr, '!')# remove '!' comments\n    st1 = nocom\n    nocom1 = nocomment(st1, '\\\\')# remove '\\' comments\n    st1 = nocom\n    st2 = nocom1\n    # alist = string.split(st2, ';')\n    alist = st2.split(';')\n    lss = []\n\n    # break the .idd file into a nested list\n    #=======================================\n    for element in alist:\n        # item = string.split(element, ',')\n        item = element.split(',')\n        lss.append(item)\n    for i in range(0, len(lss)):\n        for j in range(0, len(lss[i])):\n            lss[i][j] = lss[i][j].strip()\n    if len(lss) > 1:\n        lss.pop(-1)\n    #=======================================\n\n    #st1 has the '\\' comments --- looks like I don't use this\n    #lss is the .idd file as a nested list\n    return (st1, st2, lss)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef removeblanklines(astr):\n    lines = astr.splitlines()\n    lines = [line for line in lines if line.strip() != \"\"]\n    return \"\\n\".join(lines)", "response": "remove the blank lines in astr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncopying from extractidddata below. It deals with all the types of files", "response": "def _readfname(fname):\n    \"\"\"copied from extractidddata below. \n    It deals with all the types of fnames\"\"\"\n    try:\n        if isinstance(fname, (file, StringIO)):\n            astr = fname.read()\n        else:\n            astr = open(fname, 'rb').read()\n    except NameError:\n        if isinstance(fname, (FileIO, StringIO)):\n            astr = fname.read()\n        else:\n            astr = mylib2.readfile(fname)\n    return astr"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts group info into extracted idd", "response": "def embedgroupdata(extract_func, fname, debug):\n    \"\"\"insert group info into extracted idd\"\"\"\n    \n    astr = _readfname(fname)\n    \n    # fname is exhausted by the above read\n    # reconstitute fname as a StringIO\n    fname = StringIO(astr)\n\n    try:\n        astr = astr.decode('ISO-8859-2')\n    except Exception as e:\n        pass # for python 3\n    glist = iddgroups.iddtxt2grouplist(astr)\n    \n    \n    blocklst, commlst, commdct = extract_func(fname)\n    # add group information to commlst and commdct\n    # glist = getglist(fname)\n    commlst = iddgroups.group2commlst(commlst, glist)\n    commdct = iddgroups.group2commdct(commdct, glist)\n    return blocklst, commlst, commdct"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extractidddata(fname, debug=False):\n    try:\n        if isinstance(fname, (file, StringIO)):\n            astr = fname.read()\n            try:\n                astr = astr.decode('ISO-8859-2')\n            except AttributeError:\n                pass \n        else:\n            astr = mylib2.readfile(fname)\n            # astr = astr.decode('ISO-8859-2') -> mylib1 does a decode\n    except NameError:\n        if isinstance(fname, (FileIO, StringIO)):\n            astr = fname.read()\n            try:\n                astr = astr.decode('ISO-8859-2')\n            except AttributeError:\n                pass\n        else:\n            astr = mylib2.readfile(fname)\n            # astr = astr.decode('ISO-8859-2') -> mylib2.readfile has decoded\n    (nocom, nocom1, blocklst) = get_nocom_vars(astr)\n\n\n    astr = nocom\n    st1 = removeblanklines(astr)\n    if debug:\n        mylib1.write_str2file('nocom2.txt', st1.encode('latin-1'))\n\n\n    #find the groups and the start object of the group\n    #find all the group strings\n    groupls = []\n    alist = st1.splitlines()\n    for element in alist:\n        lss = element.split()\n        if lss[0].upper() == '\\\\group'.upper():\n            groupls.append(element)\n\n\n    #find the var just after each item in groupls\n    groupstart = []\n    for i in range(len(groupls)):\n        iindex = alist.index(groupls[i])\n        groupstart.append([alist[iindex], alist[iindex+1]])\n\n    #remove the group commentline\n    for element in groupls:\n        alist.remove(element)\n\n    if debug:\n        st1 = '\\n'.join(alist)\n        mylib1.write_str2file('nocom3.txt', st1.encode('latin-1'))\n\n    #strip each line\n    for i in range(len(alist)):\n        alist[i] = alist[i].strip()\n\n    if debug:\n        st1 = '\\n'.join(alist)\n        mylib1.write_str2file('nocom4.txt', st1.encode('latin-1'))\n\n    #ensure that each line is a comment or variable\n    #find lines that don't start with a comment\n    #if this line has a comment in it\n    #   then move the comment to a new line below\n    lss = []\n    for i in range(len(alist)):\n        #find lines that don't start with a comment\n        if alist[i][0] != '\\\\':\n            #if this line has a comment in it\n            pnt = alist[i].find('\\\\')\n            if pnt != -1:\n                #then move the comment to a new line below\n                lss.append(alist[i][:pnt].strip())\n                lss.append(alist[i][pnt:].strip())\n            else:\n                lss.append(alist[i])\n        else:\n            lss.append(alist[i])\n\n\n    alist = lss[:]\n    if debug:\n        st1 = '\\n'.join(alist)\n        mylib1.write_str2file('nocom5.txt', st1.encode('latin-1'))\n\n    #need to make sure that each line has only one variable - as in WindowGlassSpectralData,\n    lss = []\n    for element in alist:\n        # if the line is not a comment\n        if element[0] != '\\\\':\n            #test for more than one var\n            llist = element.split(',')\n            if llist[-1] == '':\n                tmp = llist.pop()\n            for elm in llist:\n                if elm[-1] == ';':\n                    lss.append(elm.strip())\n                else:\n                    lss.append((elm+',').strip())\n        else:\n            lss.append(element)\n\n    ls_debug = alist[:] # needed for the next debug - 'nocom7.txt'\n    alist = lss[:]\n    if debug:\n        st1 = '\\n'.join(alist)\n        mylib1.write_str2file('nocom6.txt', st1.encode('latin-1'))\n\n    if debug:\n        #need to make sure that each line has only one variable - as in WindowGlassSpectralData,\n        #this is same as above.\n        # but the variables are put in without the ';' and ','\n        #so we can do a diff between 'nocom7.txt' and 'nocom8.txt'. Should be identical\n        lss_debug = []\n        for element in ls_debug:\n            # if the line is not a comment\n            if element[0] != '\\\\':\n                #test for more than one var\n                llist = element.split(',')\n                if llist[-1] == '':\n                    tmp = llist.pop()\n                for elm in llist:\n                    if elm[-1] == ';':\n                        lss_debug.append(elm[:-1].strip())\n                    else:\n                        lss_debug.append((elm).strip())\n            else:\n                lss_debug.append(element)\n\n        ls_debug = lss_debug[:]\n        st1 = '\\n'.join(ls_debug)\n        mylib1.write_str2file('nocom7.txt', st1.encode('latin-1'))\n\n\n    #replace each var with '=====var======'\n    #join into a string,\n    #split using '=====var====='\n    for i in range(len(lss)):\n        #if the line is not a comment\n        if lss[i][0] != '\\\\':\n            lss[i] = '=====var====='\n\n    st2 = '\\n'.join(lss)\n    lss = st2.split('=====var=====\\n')\n    lss.pop(0) # the above split generates an extra item at start\n\n    if debug:\n        fname = 'nocom8.txt'\n        fhandle = open(fname, 'wb')\n        k = 0\n        for i in range(len(blocklst)):\n            for j in range(len(blocklst[i])):\n                atxt = blocklst[i][j]+'\\n'\n                fhandle.write(atxt)\n                atxt = lss[k]\n                fhandle.write(atxt.encode('latin-1'))\n                k = k+1\n\n        fhandle.close()\n\n    #map the structure of the comments -(this is 'lss' now) to\n    #the structure of blocklst - blocklst is a nested list\n    #make lss a similar nested list\n    k = 0\n    lst = []\n    for i in range(len(blocklst)):\n        lst.append([])\n        for j in range(len(blocklst[i])):\n            lst[i].append(lss[k])\n            k = k+1\n\n\n    if debug:\n        fname = 'nocom9.txt'\n        fhandle = open(fname, 'wb')\n        k = 0\n        for i in range(len(blocklst)):\n            for j in range(len(blocklst[i])):\n                atxt = blocklst[i][j]+'\\n'\n                fhandle.write(atxt)\n                fhandle.write(lst[i][j].encode('latin-1'))\n                k = k+1\n\n        fhandle.close()\n\n\n\n    #break up multiple line comment so that it is a list\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            lst[i][j] = lst[i][j].splitlines()\n            # remove the '\\'\n            for k in range(len(lst[i][j])):\n                lst[i][j][k] = lst[i][j][k][1:]\n    commlst = lst\n\n\n    #copied with minor modifications from readidd2_2.py -- which has been erased ha !\n    clist = lst\n    lss = []\n    for i in range(0, len(clist)):\n        alist = []\n        for j in range(0, len(clist[i])):\n            itt = clist[i][j]\n            ddtt = {}\n            for element in itt:\n                if len(element.split()) == 0:\n                    break\n                ddtt[element.split()[0].lower()] = []\n\n            for element in itt:\n                if len(element.split()) == 0:\n                    break\n                # ddtt[element.split()[0].lower()].append(string.join(element.split()[1:]))\n                ddtt[element.split()[0].lower()].append(' '.join(element.split()[1:]))\n\n\n            alist.append(ddtt)\n\n        lss.append(alist)\n    commdct = lss\n    \n    # add group information to commlst and commdct\n    # glist = iddgroups.idd2grouplist(fname)\n    # commlst = group2commlst(commlst, glist)\n    # commdct = group2commdct(commdct, glist)\n    \n    return blocklst, commlst, commdct", "response": "This function extracts all the needed information out of the idd file fname and returns a series of strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getobjectref(blocklst, commdct):\n    objlst_dct = {}\n    for eli in commdct:\n        for elj in eli:\n            if 'object-list' in elj:\n                objlist = elj['object-list'][0]\n                objlst_dct[objlist] = []\n\n    for objlist in list(objlst_dct.keys()):\n        for i in range(len(commdct)):\n            for j in range(len(commdct[i])):\n                if 'reference' in commdct[i][j]:\n                    for ref in commdct[i][j]['reference']:\n                        if ref == objlist:\n                            objlst_dct[objlist].append((blocklst[i][0], j))\n    return objlst_dct", "response": "returns a dictionary of object - lists that points to a list of tuples"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the idf file", "response": "def readdatacommlst(idfname):\n    \"\"\"read the idf file\"\"\"\n    # iddfile = sys.path[0] + '/EplusCode/Energy+.idd'\n    iddfile = 'Energy+.idd'\n    # iddfile = './EPlusInterfaceFunctions/E1.idd' # TODO : can the path name be not hard coded\n    iddtxt = open(iddfile, 'r').read()\n    block, commlst, commdct = parse_idd.extractidddata(iddfile)\n\n    theidd = eplusdata.Idd(block, 2)\n    data = eplusdata.Eplusdata(theidd, idfname)\n    return data, commlst"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the idf file", "response": "def readdatacommdct(idfname, iddfile='Energy+.idd', commdct=None):\n    \"\"\"read the idf file\"\"\"\n    if not commdct:\n        block, commlst, commdct, idd_index = parse_idd.extractidddata(iddfile)\n        theidd = eplusdata.Idd(block, 2)\n    else:\n        theidd = iddfile\n    data = eplusdata.Eplusdata(theidd, idfname)\n    return data, commdct, idd_index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extractfields(data, commdct, objkey, fieldlists):\n    # TODO : this assumes that the field list identical for\n    # each instance of the object. This is not true.\n    # So we should have a field list for each instance of the object\n    # and map them with a zip\n    objindex = data.dtls.index(objkey)\n    objcomm = commdct[objindex]\n    objfields = []\n    # get the field names of that object\n    for dct in objcomm[0:]:\n        try:\n            thefieldcomms = dct['field']\n            objfields.append(thefieldcomms[0])\n        except KeyError as err:\n            objfields.append(None)\n    fieldindexes = []\n    for fieldlist in fieldlists:\n        fieldindex = []\n        for item in fieldlist:\n            if isinstance(item, int):\n                fieldindex.append(item)\n            else:\n                fieldindex.append(objfields.index(item) + 0)\n                # the index starts at 1, not at 0\n        fieldindexes.append(fieldindex)\n    theobjects = data.dt[objkey]\n    fieldcontents = []\n    for theobject, fieldindex in zip(theobjects, fieldindexes):\n        innerlst = []\n        for item in fieldindex:\n            try:\n                innerlst.append(theobject[item])\n            except IndexError as err:\n                break\n        fieldcontents.append(innerlst)\n        # fieldcontents.append([theobject[item] for item in fieldindex])\n    return fieldcontents", "response": "extracts all the fields of a single object in the object list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plantloopfieldlists(data):\n    objkey = 'plantloop'.upper()\n    numobjects = len(data.dt[objkey])\n    return [[\n        'Name',\n        'Plant Side Inlet Node Name',\n        'Plant Side Outlet Node Name',\n        'Plant Side Branch List Name',\n        'Demand Side Inlet Node Name',\n        'Demand Side Outlet Node Name',\n        'Demand Side Branch List Name']] * numobjects", "response": "return the plantloopfield list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting plantloop fields to diagram it", "response": "def plantloopfields(data, commdct):\n    \"\"\"get plantloop fields to diagram it\"\"\"\n    fieldlists = plantloopfieldlists(data)\n    objkey = 'plantloop'.upper()\n    return extractfields(data, commdct, objkey, fieldlists)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting branches from the branchlist", "response": "def branchlist2branches(data, commdct, branchlist):\n    \"\"\"get branches from the branchlist\"\"\"\n    objkey = 'BranchList'.upper()\n    theobjects = data.dt[objkey]\n    fieldlists = []\n    objnames = [obj[1] for obj in theobjects]\n    for theobject in theobjects:\n        fieldlists.append(list(range(2, len(theobject))))\n    blists = extractfields(data, commdct, objkey, fieldlists)\n    thebranches = [branches for name, branches in zip(objnames, blists)\n                   if name == branchlist]\n    return thebranches[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the inlet and outlet of a branch", "response": "def branch_inlet_outlet(data, commdct, branchname):\n    \"\"\"return the inlet and outlet of a branch\"\"\"\n    objkey = 'Branch'.upper()\n    theobjects = data.dt[objkey]\n    theobject = [obj for obj in theobjects if obj[1] == branchname]\n    theobject = theobject[0]\n    inletindex = 6\n    outletindex = len(theobject) - 2\n    return [theobject[inletindex], theobject[outletindex]]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets splitter fields to diagram it", "response": "def splitterfields(data, commdct):\n    \"\"\"get splitter fields to diagram it\"\"\"\n    objkey = \"Connector:Splitter\".upper()\n    fieldlists = splittermixerfieldlists(data, commdct, objkey)\n    return extractfields(data, commdct, objkey, fieldlists)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget mixer fields to diagram it", "response": "def mixerfields(data, commdct):\n    \"\"\"get mixer fields to diagram it\"\"\"\n    objkey = \"Connector:Mixer\".upper()\n    fieldlists = splittermixerfieldlists(data, commdct, objkey)\n    return extractfields(data, commdct, objkey, fieldlists)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of repeating fields", "response": "def repeatingfields(theidd, commdct, objkey, flds):\n    \"\"\"return a list of repeating fields\n    fld is in format 'Component %s Name'\n    so flds = [fld % (i, ) for i in range(n)]\n    does not work for 'fields as indicated' \"\"\"\n    # TODO : make it work for 'fields as indicated'\n    if type(flds) != list:\n        flds = [flds] # for backward compatability\n    objindex = theidd.dtls.index(objkey)\n    objcomm = commdct[objindex]\n    allfields = []\n    for fld in flds:\n        thefields = []\n        indx = 1\n        for i in range(len(objcomm)):\n            try:\n                thefield = fld % (indx, )\n                if objcomm[i]['field'][0] == thefield:\n                    thefields.append(thefield)\n                    indx = indx + 1\n            except KeyError as err:\n                pass\n        allfields.append(thefields)\n    allfields = list(zip(*allfields))\n    return [item for sublist in allfields for item in sublist]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef objectcount(data, key):\n    objkey = key.upper()\n    return len(data.dt[objkey])", "response": "return the count of objects of key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getfieldindex(data, commdct, objkey, fname):\n    objindex = data.dtls.index(objkey)\n    objcomm = commdct[objindex]\n    for i_index, item in enumerate(objcomm):\n        try:\n            if item['field'] == [fname]:\n                break\n        except KeyError as err:\n            pass\n    return i_index", "response": "given objkey and fieldname return its index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake the dict adistu_inlets", "response": "def makeadistu_inlets(data, commdct):\n    \"\"\"make the dict adistu_inlets\"\"\"\n    adistus = getadistus(data, commdct)\n    # assume that the inlet node has the words \"Air Inlet Node Name\"\n    airinletnode = \"Air Inlet Node Name\"\n    adistu_inlets = {}\n    for adistu in adistus:\n        objkey = adistu.upper()\n        objindex = data.dtls.index(objkey)\n        objcomm = commdct[objindex]\n        airinlets = []\n        for i, comm in enumerate(objcomm):\n            try:\n                if comm['field'][0].find(airinletnode) != -1:\n                    airinlets.append(comm['field'][0])\n            except KeyError as err:\n                pass\n        adistu_inlets[adistu] = airinlets\n    return adistu_inlets"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the version number from the E + install folder", "response": "def folder2ver(folder):\n    \"\"\"get the version number from the E+ install folder\"\"\"\n    ver = folder.split('EnergyPlus')[-1]\n    ver = ver[1:]\n    splitapp = ver.split('-')\n    ver = '.'.join(splitapp)\n    return ver"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting the idf text to a simple text", "response": "def idf2txt(txt):\n    \"\"\"convert the idf text to a simple text\"\"\"\n    astr = nocomment(txt)\n    objs = astr.split(';')\n    objs = [obj.split(',') for obj in objs]\n    objs = [[line.strip() for line in obj] for obj in objs]\n    objs = [[_tofloat(line) for line in obj] for obj in objs]\n    objs = [tuple(obj) for obj in objs]\n    objs.sort()\n\n    lst = []\n    for obj in objs:\n        for field in obj[:-1]:\n            lst.append('%s,' % (field, ))\n        lst.append('%s;\\n' % (obj[-1], ))\n\n    return '\\n'.join(lst)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iddversiontuple(afile):\n    def versiontuple(vers):\n        \"\"\"version tuple\"\"\"\n        return tuple([int(num) for num in vers.split(\".\")])\n    try:\n        fhandle = open(afile, 'rb')\n    except TypeError:\n        fhandle = afile\n    line1 = fhandle.readline()\n    try:\n        line1 = line1.decode('ISO-8859-2')\n    except AttributeError:\n        pass\n    line = line1.strip()\n    if line1 == '':\n        return (0,)\n    vers = line.split()[-1]\n    return versiontuple(vers)", "response": "given the idd file or filehandle return the version tuple"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef makeabunch(commdct, obj, obj_i):\n    objidd = commdct[obj_i]\n    objfields = [comm.get('field') for comm in commdct[obj_i]]\n    objfields[0] = ['key']\n    objfields = [field[0] for field in objfields]\n    obj_fields = [bunchhelpers.makefieldname(field) for field in objfields]\n    bobj = EpBunch(obj, obj_fields, objidd)\n    return bobj", "response": "make a bunch from the object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake bunches with data", "response": "def makebunches(data, commdct):\n    \"\"\"make bunches with data\"\"\"\n    bunchdt = {}\n    ddtt, dtls = data.dt, data.dtls\n    for obj_i, key in enumerate(dtls):\n        key = key.upper()\n        bunchdt[key] = []\n        objs = ddtt[key]\n        for obj in objs:\n            bobj = makeabunch(commdct, obj, obj_i)\n            bunchdt[key].append(bobj)\n    return bunchdt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake bunches with data", "response": "def makebunches_alter(data, commdct, theidf):\n    \"\"\"make bunches with data\"\"\"\n    bunchdt = {}\n    dt, dtls = data.dt, data.dtls\n    for obj_i, key in enumerate(dtls):\n        key = key.upper()\n        objs = dt[key]\n        list1 = []\n        for obj in objs:\n            bobj = makeabunch(commdct, obj, obj_i)\n            list1.append(bobj)\n        bunchdt[key] = Idf_MSequence(list1, objs, theidf)\n    return bunchdt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting the float and interger fields", "response": "def convertfields_old(key_comm, obj, inblock=None):\n    \"\"\"convert the float and interger fields\"\"\"\n    convinidd = ConvInIDD()\n    typefunc = dict(integer=convinidd.integer, real=convinidd.real)\n    types = []\n    for comm in key_comm:\n        types.append(comm.get('type', [None])[0])\n    convs = [typefunc.get(typ, convinidd.no_type) for typ in types]\n    try:\n        inblock = list(inblock)\n    except TypeError as e:\n        inblock = ['does not start with N'] * len(obj)\n    for i, (val, conv, avar) in enumerate(zip(obj, convs, inblock)):\n        if i == 0:\n            # inblock[0] is the key\n            pass\n        else:\n            val = conv(val, inblock[i])\n        obj[i] = val\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convertafield(field_comm, field_val, field_iddname):\n    convinidd = ConvInIDD()\n    field_typ = field_comm.get('type', [None])[0]    \n    conv = convinidd.conv_dict().get(field_typ, convinidd.no_type)\n    return conv(field_val, field_iddname)", "response": "convert field based on field info in IDD"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convertfields(key_comm, obj, inblock=None):\n    # f_ stands for field_\n    convinidd = ConvInIDD()\n    if not inblock:\n        inblock = ['does not start with N'] * len(obj)\n    for i, (f_comm, f_val, f_iddname) in enumerate(zip(key_comm, obj, inblock)):\n        if i == 0:\n            # inblock[0] is the iddobject key. No conversion here\n            pass\n        else:\n            obj[i] = convertafield(f_comm, f_val, f_iddname)\n    return obj", "response": "convert based on float integer and A1 and N1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addfunctions(dtls, bunchdt):\n    snames = [\n        \"BuildingSurface:Detailed\",\n        \"Wall:Detailed\",\n        \"RoofCeiling:Detailed\",\n        \"Floor:Detailed\",\n        \"FenestrationSurface:Detailed\",\n        \"Shading:Site:Detailed\",\n        \"Shading:Building:Detailed\",\n        \"Shading:Zone:Detailed\", ]\n    for sname in snames:\n        if sname.upper() in bunchdt:\n            surfaces = bunchdt[sname.upper()]\n            for surface in surfaces:\n                func_dict = {\n                    'area': fh.area,\n                    'height': fh.height,  # not working correctly\n                    'width': fh.width,  # not working correctly\n                    'azimuth': fh.azimuth,\n                    'tilt': fh.tilt,\n                    'coords': fh.getcoords,  # needed for debugging\n                }\n                try:\n                    surface.__functions.update(func_dict)\n                except KeyError as e:\n                    surface.__functions = func_dict", "response": "add functions to the objects in the objects in the bunchdt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd functions to a new bunch object", "response": "def addfunctions2new(abunch, key):\n    \"\"\"add functions to a new bunch/munch object\"\"\"\n    snames = [\n        \"BuildingSurface:Detailed\",\n        \"Wall:Detailed\",\n        \"RoofCeiling:Detailed\",\n        \"Floor:Detailed\",\n        \"FenestrationSurface:Detailed\",\n        \"Shading:Site:Detailed\",\n        \"Shading:Building:Detailed\",\n        \"Shading:Zone:Detailed\", ]\n    snames = [sname.upper() for sname in snames]\n    if key in snames:\n        func_dict = {\n            'area': fh.area,\n            'height': fh.height,  # not working correctly\n            'width': fh.width,  # not working correctly\n            'azimuth': fh.azimuth,\n            'tilt': fh.tilt,\n            'coords': fh.getcoords,  # needed for debugging\n        }\n        try:\n            abunch.__functions.update(func_dict)\n        except KeyError as e:\n            abunch.__functions = func_dict\n    return abunch"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads idf file and return bunches", "response": "def idfreader(fname, iddfile, conv=True):\n    \"\"\"read idf file and return bunches\"\"\"\n    data, commdct, idd_index = readidf.readdatacommdct(fname, iddfile=iddfile)\n    if conv:\n        convertallfields(data, commdct)\n    # fill gaps in idd\n    ddtt, dtls = data.dt, data.dtls\n    # skiplist = [\"TABLE:MULTIVARIABLELOOKUP\"]\n    nofirstfields = iddgaps.missingkeys_standard(\n        commdct, dtls,\n        skiplist=[\"TABLE:MULTIVARIABLELOOKUP\"])\n    iddgaps.missingkeys_nonstandard(None, commdct, dtls, nofirstfields)\n    bunchdt = makebunches(data, commdct)\n    return bunchdt, data, commdct, idd_index"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads idf file and return bunches", "response": "def idfreader1(fname, iddfile, theidf, conv=True, commdct=None, block=None):\n    \"\"\"read idf file and return bunches\"\"\"\n    versiontuple = iddversiontuple(iddfile)\n    # import pdb; pdb.set_trace()\n    block, data, commdct, idd_index = readidf.readdatacommdct1(\n        fname,\n        iddfile=iddfile,\n        commdct=commdct,\n        block=block)\n    if conv:\n        convertallfields(data, commdct, block)\n    # fill gaps in idd\n    ddtt, dtls = data.dt, data.dtls\n    if versiontuple < (8,):\n        skiplist = [\"TABLE:MULTIVARIABLELOOKUP\"]\n    else:\n        skiplist = None\n    nofirstfields = iddgaps.missingkeys_standard(\n        commdct, dtls,\n        skiplist=skiplist)\n    iddgaps.missingkeys_nonstandard(block, commdct, dtls, nofirstfields)\n    # bunchdt = makebunches(data, commdct)\n    bunchdt = makebunches_alter(data, commdct, theidf)\n    return bunchdt, block, data, commdct, idd_index, versiontuple"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getanymentions(idf, anidfobject):\n    name = anidfobject.obj[1]\n    foundobjs = []\n    keys = idfobjectkeys(idf)\n    idfkeyobjects = [idf.idfobjects[key.upper()] for key in keys]\n    for idfobjects in idfkeyobjects:\n        for idfobject in idfobjects:\n            if name.upper() in [item.upper() \n                                    for item in idfobject.obj \n                                        if isinstance(item, basestring)]:\n                foundobjs.append(idfobject)\n    return foundobjs", "response": "Find out if idjobject is mentioned an any object anywhere"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the object that has the given fieldname.", "response": "def getobject_use_prevfield(idf, idfobject, fieldname):\n    \"\"\"field=object_name, prev_field=object_type. Return the object\"\"\"\n    if not fieldname.endswith(\"Name\"):\n        return None\n    # test if prevfieldname ends with \"Object_Type\"\n    fdnames = idfobject.fieldnames\n    ifieldname = fdnames.index(fieldname)\n    prevfdname = fdnames[ifieldname - 1]\n    if not prevfdname.endswith(\"Object_Type\"):\n        return None\n    objkey = idfobject[prevfdname].upper()\n    objname = idfobject[fieldname]\n    try:\n        foundobj = idf.getobject(objkey, objname)\n    except KeyError as e:\n        return None\n    return foundobj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getidfkeyswithnodes():\n    idf = IDF(StringIO(\"\"))\n    keys = idfobjectkeys(idf)\n    keysfieldnames = ((key, idf.newidfobject(key.upper()).fieldnames) \n                for key in keys)\n    keysnodefdnames = ((key,  (name for name in fdnames \n                                if (name.endswith('Node_Name')))) \n                            for key, fdnames in keysfieldnames)\n    nodekeys = [key for key, fdnames in keysnodefdnames if list(fdnames)]\n    return nodekeys", "response": "return a list of keys of idfobjects that have None Name fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getobjectswithnode(idf, nodekeys, nodename):\n    keys = nodekeys\n    # TODO getidfkeyswithnodes needs to be done only once. take out of here\n    listofidfobjects = (idf.idfobjects[key.upper()] \n                for key in keys if idf.idfobjects[key.upper()])\n    idfobjects = [idfobj \n                    for idfobjs in listofidfobjects \n                        for idfobj in idfobjs]\n    objwithnodes = []\n    for obj in idfobjects:\n        values = obj.fieldvalues\n        fdnames = obj.fieldnames\n        for value, fdname in zip(values, fdnames):\n            if fdname.endswith('Node_Name'):\n                if value == nodename:\n                    objwithnodes.append(obj)\n                    break\n    return objwithnodes", "response": "return all objects that mention this node name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the object if the Name or some other field is known.", "response": "def name2idfobject(idf, groupnamess=None, objkeys=None, **kwargs):\n    \"\"\"return the object, if the Name or some other field is known.\n    send filed in **kwargs as Name='a name', Roughness='smooth'\n    Returns the first find (field search is unordered)\n    objkeys -> if objkeys=['ZONE', 'Material'], search only those\n    groupnames -> not yet coded\"\"\"\n    # TODO : this is a very slow search. revist to speed it up.\n    if not objkeys:\n        objkeys = idfobjectkeys(idf)\n    for objkey in objkeys:\n        idfobjs = idf.idfobjects[objkey.upper()]\n        for idfobj in idfobjs:\n            for key, val in kwargs.items():\n                try:\n                    if idfobj[key] == val:\n                        return idfobj\n                except BadEPFieldError as e:\n                    continue"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all idfobjects in idf", "response": "def getidfobjectlist(idf):\n    \"\"\"return a list of all idfobjects in idf\"\"\"\n    idfobjects = idf.idfobjects  \n    # idfobjlst = [idfobjects[key] for key in idfobjects if idfobjects[key]]\n    idfobjlst = [idfobjects[key] for key in idf.model.dtls if idfobjects[key]]\n        # `for key in idf.model.dtls` maintains the order\n        # `for key in idfobjects` does not have order\n    idfobjlst = itertools.chain.from_iterable(idfobjlst)\n    idfobjlst = list(idfobjlst)\n    return idfobjlst"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies fromidf completely into toidf", "response": "def copyidfintoidf(toidf, fromidf):\n    \"\"\"copy fromidf completely into toidf\"\"\"\n    idfobjlst = getidfobjectlist(fromidf)\n    for idfobj in idfobjlst:\n        toidf.copyidfobject(idfobj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef idfdiffs(idf1, idf2):\n    thediffs = {}\n    keys = idf1.model.dtls # undocumented variable\n\n    for akey in keys:\n        idfobjs1 = idf1.idfobjects[akey]\n        idfobjs2 = idf2.idfobjects[akey]\n        names = set([getobjname(i) for i in idfobjs1] + \n                    [getobjname(i) for i in idfobjs2])\n        names = sorted(names)\n        idfobjs1 = sorted(idfobjs1, key=lambda idfobj: idfobj['obj'])\n        idfobjs2 = sorted(idfobjs2, key=lambda idfobj: idfobj['obj'])\n        for name in names:\n            n_idfobjs1 = [item for item in idfobjs1 \n                            if getobjname(item) == name]\n            n_idfobjs2 = [item for item in idfobjs2 \n                            if getobjname(item) == name]\n            for idfobj1, idfobj2 in itertools.zip_longest(n_idfobjs1, \n                                                          n_idfobjs2):\n                if idfobj1 == None:\n                    thediffs[(idfobj2.key.upper(), \n                                getobjname(idfobj2))] = (None, idf1.idfname) #(idf1.idfname, None)\n                    break\n                if idfobj2 == None:\n                    thediffs[(idfobj1.key.upper(), \n                                getobjname(idfobj1))] = (idf2.idfname, None) # (None, idf2.idfname)\n                    break\n                # for i, (f1, f2) in enumerate(zip(idfobj1.obj, idfobj2.obj)):\n                #     if i == 0:\n                #         f1, f2 = f1.upper(), f2.upper()\n                #     if f1 != f2:\n                #         thediffs[(akey,\n                #                 getobjname(idfobj1),\n                #                 idfobj1.objidd[i]['field'][0])] = (f1, f2)\n    return thediffs", "response": "return the diffs between two idfs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn autsizeable field names in idfobject", "response": "def autosize_fieldname(idfobject):\n    \"\"\"return autsizeable field names in idfobject\"\"\"\n    # undocumented stuff in this code\n    return [fname for (fname, dct) in zip(idfobject.objls,\n                                          idfobject['objidd'])\n            if 'autosizable' in dct]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iddtxt2groups(txt):\n    try:\n        txt = txt.decode('ISO-8859-2')\n    except AttributeError as e:\n        pass # for python 3\n    txt = nocomment(txt, '!')\n    txt = txt.replace(\"\\\\group\", \"!-group\") # retains group in next line\n    txt = nocomment(txt, '\\\\') # remove all other idd info\n    lines = txt.splitlines()\n    lines = [line.strip() for line in lines] # cleanup\n    lines = [line for line in lines if line != ''] # cleanup\n    txt = '\\n'.join(lines)\n    gsplits = txt.split('!') # split into groups, since we have !-group\n    gsplits = [gsplit.splitlines() for gsplit in gsplits] # split group\n\n    gsplits[0].insert(0, None)\n        # Put None for the first group that does nothave a group name\n    gdict = {}\n    for gsplit in gsplits:\n        gdict.update({gsplit[0]:gsplit[1:]})\n        # makes dict {groupname:[k1, k2], groupname2:[k3, k4]}\n\n    gdict = {k:'\\n'.join(v) for k, v in gdict.items()}# joins lines back\n    gdict = {k:v.split(';') for k, v in gdict.items()} # splits into idfobjects\n    gdict = {k:[i.strip() for i in v] for k, v in gdict.items()} # cleanup\n    gdict = {k:[i.splitlines() for i in v] for k, v in gdict.items()}\n        # splits idfobjects into lines\n    gdict = {k:[i for i in v if len(i) > 0] for k, v in gdict.items()}\n        # cleanup - removes blank lines\n    gdict = {k:[i[0] for i in v] for k, v in gdict.items()} # use first line\n    gdict = {k:[i.split(',')[0] for i in v] for k, v in gdict.items()}\n        # remove ','\n    nvalue = gdict.pop(None) # remove group with no name\n    gdict = {k[len('-group '):]:v for k, v in gdict.items()} # get group name\n    gdict.update({None:nvalue}) # put back group with no name\n    return gdict", "response": "extract the groups from the idd file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of group names the list in the same order as the idf objects in idd file", "response": "def iddtxt2grouplist(txt):\n    \"\"\"return a list of group names\n    the list in the same order as the idf objects in idd file\n    \"\"\"\n    def makenone(astr):\n        if astr == 'None':\n            return None\n        else:\n            return astr\n\n    txt = nocomment(txt, '!')\n    txt = txt.replace(\"\\\\group\", \"!-group\") # retains group in next line\n    txt = nocomment(txt, '\\\\') # remove all other idd info\n    lines = txt.splitlines()\n    lines = [line.strip() for line in lines] # cleanup\n    lines = [line for line in lines if line != ''] # cleanup\n    txt = '\\n'.join(lines)\n    gsplits = txt.split('!') # split into groups, since we have !-group\n    gsplits = [gsplit.splitlines() for gsplit in gsplits] # split group\n\n    gsplits[0].insert(0, u'-group None')\n        # Put None for the first group that does nothave a group name\n    \n    glist = []\n    for gsplit in gsplits:\n        glist.append((gsplit[0], gsplit[1:]))\n        # makes dict {groupname:[k1, k2], groupname2:[k3, k4]}\n\n    glist = [(k, '\\n'.join(v)) for k, v in glist]# joins lines back\n    glist = [(k, v.split(';')) for k, v in glist] # splits into idfobjects\n    glist = [(k, [i.strip() for i in v]) for k, v in glist] # cleanup\n    glist = [(k, [i.splitlines() for i in v]) for k, v in glist]\n        # splits idfobjects into lines\n    glist = [(k, [i for i in v if len(i) > 0]) for k, v in glist]\n        # cleanup - removes blank lines\n    glist = [(k, [i[0] for i in v]) for k, v in glist] # use first line\n    fglist = []\n    for gnamelist in glist:\n        gname = gnamelist[0]\n        thelist = gnamelist[-1]\n        for item in thelist:\n            fglist.append((gname, item))\n    glist = [(gname[len(\"-group \"):], obj) for gname, obj in fglist] # remove \"-group \"\n    glist = [(makenone(gname), obj) for gname, obj in glist] # make str None into None\n    glist = [(gname, obj.split(',')[0]) for gname, obj in glist] # remove comma\n    return glist"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd group info to commlst", "response": "def group2commlst(commlst, glist):\n    \"\"\"add group info to commlst\"\"\"\n    for (gname, objname), commitem in zip(glist, commlst):\n        newitem1 = \"group %s\" % (gname, )\n        newitem2 = \"idfobj %s\" % (objname, )\n        commitem[0].insert(0, newitem1)\n        commitem[0].insert(1, newitem2)\n    return commlst"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef group2commdct(commdct, glist):\n    for (gname, objname), commitem in zip(glist, commdct):\n        commitem[0]['group'] = gname\n        commitem[0]['idfobj'] = objname\n    return commdct", "response": "add group info to commct"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract embedded group data from commdct. return gdict - > list of objects", "response": "def commdct2grouplist(gcommdct):\n    \"\"\"extract embedded group data from commdct.\n    return gdict -> {g1:[obj1, obj2, obj3], g2:[obj4, ..]}\"\"\"\n    gdict = {}\n    for objidd in gcommdct:\n        group = objidd[0]['group']\n        objname = objidd[0]['idfobj']\n        if group in gdict:\n            gdict[group].append(objname)\n        else:\n            gdict[group] = [objname, ]\n    return gdict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flattencopy(lst):\n    # modified from\n    # http://stackoverflow.com/questions/2158395/flatten-an-irregular-list-of-lists-in-python\n    thelist = copy.deepcopy(lst)\n    list_is_nested = True\n    while list_is_nested:  # outer loop\n        keepchecking = False\n        atemp = []\n        for element in thelist:  # inner loop\n            if isinstance(element, list):\n                atemp.extend(element)\n                keepchecking = True\n            else:\n                atemp.append(element)\n        list_is_nested = keepchecking  # determine if outer loop exits\n        thelist = atemp[:]\n    return thelist", "response": "flatten and return a copy of the list\n    indefficient on large lists"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a pipe component generate inlet outlet names", "response": "def makepipecomponent(idf, pname):\n    \"\"\"make a pipe component\n    generate inlet outlet names\"\"\"\n    apipe = idf.newidfobject(\"Pipe:Adiabatic\".upper(), Name=pname)\n    apipe.Inlet_Node_Name = \"%s_inlet\" % (pname,)\n    apipe.Outlet_Node_Name = \"%s_outlet\" % (pname,)\n    return apipe"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a duct component generate inlet outlet names", "response": "def makeductcomponent(idf, dname):\n    \"\"\"make a duct component\n    generate inlet outlet names\"\"\"\n    aduct = idf.newidfobject(\"duct\".upper(), Name=dname)\n    aduct.Inlet_Node_Name = \"%s_inlet\" % (dname,)\n    aduct.Outlet_Node_Name = \"%s_outlet\" % (dname,)\n    return aduct"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a branch with a pipe", "response": "def makepipebranch(idf, bname):\n    \"\"\"make a branch with a pipe\n    use standard inlet outlet names\"\"\"\n    # make the pipe component first\n    pname = \"%s_pipe\" % (bname,)\n    apipe = makepipecomponent(idf, pname)\n    # now make the branch with the pipe in it\n    abranch = idf.newidfobject(\"BRANCH\", Name=bname)\n    abranch.Component_1_Object_Type = 'Pipe:Adiabatic'\n    abranch.Component_1_Name = pname\n    abranch.Component_1_Inlet_Node_Name = apipe.Inlet_Node_Name\n    abranch.Component_1_Outlet_Node_Name = apipe.Outlet_Node_Name\n    abranch.Component_1_Branch_Control_Type = \"Bypass\"\n    return abranch"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a branch with a duct use standard inlet outlet names", "response": "def makeductbranch(idf, bname):\n    \"\"\"make a branch with a duct\n    use standard inlet outlet names\"\"\"\n    # make the duct component first\n    pname = \"%s_duct\" % (bname,)\n    aduct = makeductcomponent(idf, pname)\n    # now make the branch with the duct in it\n    abranch = idf.newidfobject(\"BRANCH\", Name=bname)\n    abranch.Component_1_Object_Type = 'duct'\n    abranch.Component_1_Name = pname\n    abranch.Component_1_Inlet_Node_Name = aduct.Inlet_Node_Name\n    abranch.Component_1_Outlet_Node_Name = aduct.Outlet_Node_Name\n    abranch.Component_1_Branch_Control_Type = \"Bypass\"\n    return abranch"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the components of the branch", "response": "def getbranchcomponents(idf, branch, utest=False):\n    \"\"\"get the components of the branch\"\"\"\n    fobjtype = 'Component_%s_Object_Type'\n    fobjname = 'Component_%s_Name'\n    complist = []\n    for i in range(1, 100000):\n        try:\n            objtype = branch[fobjtype % (i,)]\n            if objtype.strip() == '':\n                break\n            objname = branch[fobjname % (i,)]\n            complist.append((objtype, objname))\n        except bunch_subclass.BadEPFieldError:\n            break\n    if utest:\n        return complist\n    else:\n        return [idf.getobject(ot, on) for ot, on in complist]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrename all the changed nodes", "response": "def renamenodes(idf, fieldtype):\n    \"\"\"rename all the changed nodes\"\"\"\n    renameds = []\n    for key in idf.model.dtls:\n        for idfobject in idf.idfobjects[key]:\n            for fieldvalue in idfobject.obj:\n                if type(fieldvalue) is list:\n                    if fieldvalue not in renameds:\n                        cpvalue = copy.copy(fieldvalue)\n                        renameds.append(cpvalue)\n\n    # do the renaming\n    for key in idf.model.dtls:\n        for idfobject in idf.idfobjects[key]:\n            for i, fieldvalue in enumerate(idfobject.obj):\n                itsidd = idfobject.objidd[i]\n                if 'type' in itsidd:\n                    if itsidd['type'][0] == fieldtype:\n                        tempdct = dict(renameds)\n                        if type(fieldvalue) is list:\n                            fieldvalue = fieldvalue[-1]\n                            idfobject.obj[i] = fieldvalue\n                        else:\n                            if fieldvalue in tempdct:\n                                fieldvalue = tempdct[fieldvalue]\n                                idfobject.obj[i] = fieldvalue"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getfieldnamesendswith(idfobject, endswith):\n    objls = idfobject.objls\n    tmp = [name for name in objls if name.endswith(endswith)]\n    if tmp == []:\n        pass\n    return [name for name in objls if name.endswith(endswith)]", "response": "get the filednames for the idfobject based on endswith"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the field name of the node fluid is only needed if there are air and water nodes", "response": "def getnodefieldname(idfobject, endswith, fluid=None, startswith=None):\n    \"\"\"return the field name of the node\n    fluid is only needed if there are air and water nodes\n    fluid is Air or Water or ''.\n    if the fluid is Steam, use Water\"\"\"\n    if startswith is None:\n        startswith = ''\n    if fluid is None:\n        fluid = ''\n    nodenames = getfieldnamesendswith(idfobject, endswith)\n    nodenames = [name for name in nodenames if name.startswith(startswith)]\n    fnodenames = [nd for nd in nodenames if nd.find(fluid) != -1]\n    fnodenames = [name for name in fnodenames if name.startswith(startswith)]\n    if len(fnodenames) == 0:\n        nodename = nodenames[0]\n    else:\n        nodename = fnodenames[0]\n    return nodename"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenames nodes so that the components get connected fluid is only needed if there are air and water nodes fluid is Steam or Air", "response": "def connectcomponents(idf, components, fluid=None):\n    \"\"\"rename nodes so that the components get connected\n    fluid is only needed if there are air and water nodes\n    fluid is Air or Water or ''.\n    if the fluid is Steam, use Water\"\"\"\n    if fluid is None:\n        fluid = ''\n    if len(components) == 1:\n        thiscomp, thiscompnode = components[0]\n        initinletoutlet(idf, thiscomp, thiscompnode, force=False)\n        outletnodename = getnodefieldname(thiscomp, \"Outlet_Node_Name\",\n                                          fluid=fluid, startswith=thiscompnode)\n        thiscomp[outletnodename] = [thiscomp[outletnodename],\n                                    thiscomp[outletnodename]]\n        # inletnodename = getnodefieldname(nextcomp, \"Inlet_Node_Name\", fluid)\n        # nextcomp[inletnodename] = [nextcomp[inletnodename], betweennodename]\n        return components\n    for i in range(len(components) - 1):\n        thiscomp, thiscompnode = components[i]\n        nextcomp, nextcompnode = components[i + 1]\n        initinletoutlet(idf, thiscomp, thiscompnode, force=False)\n        initinletoutlet(idf, nextcomp, nextcompnode, force=False)\n        betweennodename = \"%s_%s_node\" % (thiscomp.Name, nextcomp.Name)\n        outletnodename = getnodefieldname(thiscomp, \"Outlet_Node_Name\",\n                                          fluid=fluid, startswith=thiscompnode)\n        thiscomp[outletnodename] = [thiscomp[outletnodename], betweennodename]\n        inletnodename = getnodefieldname(nextcomp, \"Inlet_Node_Name\", fluid)\n        nextcomp[inletnodename] = [nextcomp[inletnodename], betweennodename]\n    return components"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initinletoutlet(idf, idfobject, thisnode, force=False):\n    def blankfield(fieldvalue):\n        \"\"\"test for blank field\"\"\"\n        try:\n            if fieldvalue.strip() == '':\n                return True\n            else:\n                return False\n        except AttributeError:  # field may be a list\n            return False\n    def trimfields(fields, thisnode):\n        if len(fields) > 1:\n            if thisnode is not None:\n                fields = [field for field in fields\n                          if field.startswith(thisnode)]\n                return fields\n            else:\n                print(\"Where should this loop connect ?\")\n                print(\"%s - %s\" % (idfobject.key, idfobject.Name))\n                print([field.split(\"Inlet_Node_Name\")[0]\n                       for field in inletfields])\n                raise WhichLoopError\n        else:\n            return fields\n\n    inletfields = getfieldnamesendswith(idfobject, \"Inlet_Node_Name\")\n    inletfields = trimfields(inletfields, thisnode)  # or warn with exception\n    for inletfield in inletfields:\n        if blankfield(idfobject[inletfield]) == True or force == True:\n            idfobject[inletfield] = \"%s_%s\" % (idfobject.Name, inletfield)\n    outletfields = getfieldnamesendswith(idfobject, \"Outlet_Node_Name\")\n    outletfields = trimfields(outletfields, thisnode)  # or warn with exception\n    for outletfield in outletfields:\n        if blankfield(idfobject[outletfield]) == True or force == True:\n            idfobject[outletfield] = \"%s_%s\" % (idfobject.Name, outletfield)\n    return idfobject", "response": "initialze values for all the inlet and outlet nodes for the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef componentsintobranch(idf, branch, listofcomponents, fluid=None):\n    if fluid is None:\n        fluid = ''\n    componentlist = [item[0] for item in listofcomponents]\n    # assumes that the nodes of the component connect to each other\n    # empty branch if it has existing components\n    thebranchname = branch.Name\n    thebranch = idf.removeextensibles('BRANCH', thebranchname)  # empty the branch\n    # fill in the new components with the node names into this branch\n        # find the first extensible field and fill in the data in obj.\n    e_index = idf.getextensibleindex('BRANCH', thebranchname)\n    theobj = thebranch.obj\n    modeleditor.extendlist(theobj, e_index)  # just being careful here\n    for comp, compnode in listofcomponents:\n        theobj.append(comp.key)\n        theobj.append(comp.Name)\n        inletnodename = getnodefieldname(comp, \"Inlet_Node_Name\", fluid=fluid,\n                                         startswith=compnode)\n        theobj.append(comp[inletnodename])\n        outletnodename = getnodefieldname(comp, \"Outlet_Node_Name\",\n                                          fluid=fluid, startswith=compnode)\n        theobj.append(comp[outletnodename])\n        theobj.append('')\n\n    return thebranch", "response": "insert a list of components into a branch"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes plant loop with pip components", "response": "def makeplantloop(idf, loopname, sloop, dloop, testing=None):\n    \"\"\"make plant loop with pip components\"\"\"\n    # -------- <testing ---------\n    testn = 0\n    # -------- testing> ---------\n    newplantloop = idf.newidfobject(\"PLANTLOOP\", Name=loopname)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    fields = SomeFields.p_fields\n\n    # for use in bunch\n    flnames = [field.replace(' ', '_') for field in fields]\n\n    # simplify naming\n    fields1 = [field.replace('Plant Side', 'Supply') for field in fields]\n    fields1 = [field.replace('Demand Side', 'Demand') for field in fields1]\n    fields1 = [field[:field.find('Name') - 1] for field in fields1]\n    fields1 = [field.replace(' Node', '') for field in fields1]\n    fields1 = [field.replace(' List', 's') for field in fields1]\n\n    # TODO : pop connectors if no parallel branches\n    # make fieldnames in the plant loop\n    fieldnames = ['%s %s' % (loopname, field) for field in fields1]\n    for fieldname, thefield in zip(fieldnames, flnames):\n        newplantloop[thefield] = fieldname\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # make the branch lists for this plant loop\n    sbranchlist = idf.newidfobject(\n        \"BRANCHLIST\",\n        Name=newplantloop.Plant_Side_Branch_List_Name)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    dbranchlist = idf.newidfobject(\n        \"BRANCHLIST\",\n        Name=newplantloop.Demand_Side_Branch_List_Name)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # add branch names to the branchlist\n    sbranchnames = flattencopy(sloop)\n    # sbranchnames = sloop[1]\n    for branchname in sbranchnames:\n        sbranchlist.obj.append(branchname)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    dbranchnames = flattencopy(dloop)\n    # dbranchnames = dloop[1]\n    for branchname in dbranchnames:\n        dbranchlist.obj.append(branchname)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # make a pipe branch for all branches in the loop\n\n    # supply side\n    sbranchs = []\n    for bname in sbranchnames:\n        branch = makepipebranch(idf, bname)\n        sbranchs.append(branch)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop\n    anode = \"Component_1_Inlet_Node_Name\"\n    sameinnode = \"Plant_Side_Inlet_Node_Name\"\n    sbranchs[0][anode] = newplantloop[sameinnode]\n    anode = \"Component_1_Outlet_Node_Name\"\n    sameoutnode = \"Plant_Side_Outlet_Node_Name\"\n    sbranchs[-1][anode] = newplantloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop - rename in pipe\n    pname = sbranchs[0]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Inlet_Node_Name = newplantloop[sameinnode]\n    pname = sbranchs[-1]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Outlet_Node_Name = newplantloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # demand side\n    dbranchs = []\n    for bname in dbranchnames:\n        branch = makepipebranch(idf, bname)\n        dbranchs.append(branch)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop - rename in branch\n    anode = \"Component_1_Inlet_Node_Name\"\n    sameinnode = \"Demand_Side_Inlet_Node_Name\"\n    dbranchs[0][anode] = newplantloop[sameinnode]\n    anode = \"Component_1_Outlet_Node_Name\"\n    sameoutnode = \"Demand_Side_Outlet_Node_Name\"\n    dbranchs[-1][anode] = newplantloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop - rename in pipe\n    pname = dbranchs[0]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Inlet_Node_Name = newplantloop[sameinnode]\n    pname = dbranchs[-1]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Outlet_Node_Name = newplantloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n\n    # TODO : test if there are parallel branches\n    # make the connectorlist an fill fields\n    sconnlist = idf.newidfobject(\n        \"CONNECTORLIST\",\n        Name=newplantloop.Plant_Side_Connector_List_Name)\n    sconnlist.Connector_1_Object_Type = \"Connector:Splitter\"\n    sconnlist.Connector_1_Name = \"%s_supply_splitter\" % (loopname,)\n    sconnlist.Connector_2_Object_Type = \"Connector:Mixer\"\n    sconnlist.Connector_2_Name = \"%s_supply_mixer\" % (loopname,)\n    dconnlist = idf.newidfobject(\n        \"CONNECTORLIST\",\n        Name=newplantloop.Demand_Side_Connector_List_Name)\n    dconnlist.Connector_1_Object_Type = \"Connector:Splitter\"\n    dconnlist.Connector_1_Name = \"%s_demand_splitter\" % (loopname,)\n    dconnlist.Connector_2_Object_Type = \"Connector:Mixer\"\n    dconnlist.Connector_2_Name = \"%s_demand_mixer\" % (loopname,)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # make splitters and mixers\n    s_splitter = idf.newidfobject(\n        \"CONNECTOR:SPLITTER\",\n        Name=sconnlist.Connector_1_Name)\n    s_splitter.obj.extend([sloop[0]] + sloop[1])\n    s_mixer = idf.newidfobject(\n        \"CONNECTOR:MIXER\",\n        Name=sconnlist.Connector_2_Name)\n    s_mixer.obj.extend([sloop[-1]] + sloop[1])\n    # -\n    d_splitter = idf.newidfobject(\n        \"CONNECTOR:SPLITTER\",\n        Name=dconnlist.Connector_1_Name)\n    d_splitter.obj.extend([dloop[0]] + dloop[1])\n    d_mixer = idf.newidfobject(\n        \"CONNECTOR:MIXER\",\n        Name=dconnlist.Connector_2_Name)\n    d_mixer.obj.extend([dloop[-1]] + dloop[1])\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newplantloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    return newplantloop"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake condenser loop with pipe components", "response": "def makecondenserloop(idf, loopname, sloop, dloop, testing=None):\n    \"\"\"make condenser loop with pipe components\"\"\"\n    # -------- <testing ---------\n    testn = 0\n    # -------- testing> ---------\n    newcondenserloop = idf.newidfobject(\"CondenserLoop\".upper(), Name=loopname)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    fields = SomeFields.c_fields\n\n    # for use in bunch\n    flnames = [field.replace(' ', '_') for field in fields]\n\n    # simplify naming\n    fields1 = [field.replace(\n        'Condenser Side',\n        'Cond_Supply') for field in fields]\n    fields1 = [field.replace('Demand Side', 'Demand') for field in fields1]\n    fields1 = [field[:field.find('Name') - 1] for field in fields1]\n    fields1 = [field.replace(' Node', '') for field in fields1]\n    fields1 = [field.replace(' List', 's') for field in fields1]\n\n    # old TODO : pop connectors if no parallel branches\n    # make fieldnames in the condenser loop\n    fieldnames = ['%s %s' % (loopname, field) for field in fields1]\n    for fieldname, thefield in zip(fieldnames, flnames):\n        newcondenserloop[thefield] = fieldname\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # make the branch lists for this condenser loop\n    sbranchlist = idf.newidfobject(\n        \"BRANCHLIST\",\n        Name=newcondenserloop.Condenser_Side_Branch_List_Name)\n    dbranchlist = idf.newidfobject(\n        \"BRANCHLIST\",\n        Name=newcondenserloop.Condenser_Demand_Side_Branch_List_Name)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # add branch names to the branchlist\n    sbranchnames = flattencopy(sloop)\n    # sbranchnames = sloop[1]\n    for branchname in sbranchnames:\n        sbranchlist.obj.append(branchname)\n    dbranchnames = flattencopy(dloop)\n    # dbranchnames = dloop[1]\n    for branchname in dbranchnames:\n        dbranchlist.obj.append(branchname)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # make a pipe branch for all branches in the loop\n\n    # supply side\n    sbranchs = []\n    for bname in sbranchnames:\n        branch = makepipebranch(idf, bname)\n        sbranchs.append(branch)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop\n    anode = \"Component_1_Inlet_Node_Name\"\n    sameinnode = \"Condenser_Side_Inlet_Node_Name\"  # TODO : change ?\n    sbranchs[0][anode] = newcondenserloop[sameinnode]\n    anode = \"Component_1_Outlet_Node_Name\"\n    sameoutnode = \"Condenser_Side_Outlet_Node_Name\"  # TODO : change ?\n    sbranchs[-1][anode] = newcondenserloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop - rename in pipe\n    pname = sbranchs[0]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Inlet_Node_Name = newcondenserloop[sameinnode]\n    pname = sbranchs[-1]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Outlet_Node_Name = newcondenserloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # demand side\n    dbranchs = []\n    for bname in dbranchnames:\n        branch = makepipebranch(idf, bname)\n        dbranchs.append(branch)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop - rename in branch\n    anode = \"Component_1_Inlet_Node_Name\"\n    sameinnode = \"Demand_Side_Inlet_Node_Name\"  # TODO : change ?\n    dbranchs[0][anode] = newcondenserloop[sameinnode]\n    anode = \"Component_1_Outlet_Node_Name\"\n    sameoutnode = \"Demand_Side_Outlet_Node_Name\"  # TODO : change ?\n    dbranchs[-1][anode] = newcondenserloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # rename inlet outlet of endpoints of loop - rename in pipe\n    pname = dbranchs[0]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Inlet_Node_Name = newcondenserloop[sameinnode]\n    pname = dbranchs[-1]['Component_1_Name']  # get the pipe name\n    apipe = idf.getobject('Pipe:Adiabatic'.upper(), pname)  # get pipe\n    apipe.Outlet_Node_Name = newcondenserloop[sameoutnode]\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n\n    # TODO : test if there are parallel branches\n    # make the connectorlist an fill fields\n    sconnlist = idf.newidfobject(\n        \"CONNECTORLIST\",\n        Name=newcondenserloop.Condenser_Side_Connector_List_Name)\n    sconnlist.Connector_1_Object_Type = \"Connector:Splitter\"\n    sconnlist.Connector_1_Name = \"%s_supply_splitter\" % (loopname,)\n    sconnlist.Connector_2_Object_Type = \"Connector:Mixer\"\n    sconnlist.Connector_2_Name = \"%s_supply_mixer\" % (loopname,)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    dconnlist = idf.newidfobject(\n        \"CONNECTORLIST\",\n        Name=newcondenserloop.Condenser_Demand_Side_Connector_List_Name)\n    dconnlist.Connector_1_Object_Type = \"Connector:Splitter\"\n    dconnlist.Connector_1_Name = \"%s_demand_splitter\" % (loopname,)\n    dconnlist.Connector_2_Object_Type = \"Connector:Mixer\"\n    dconnlist.Connector_2_Name = \"%s_demand_mixer\" % (loopname,)\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n\n    # make splitters and mixers\n    s_splitter = idf.newidfobject(\n        \"CONNECTOR:SPLITTER\",\n        Name=sconnlist.Connector_1_Name)\n    s_splitter.obj.extend([sloop[0]] + sloop[1])\n    s_mixer = idf.newidfobject(\n        \"CONNECTOR:MIXER\",\n        Name=sconnlist.Connector_2_Name)\n    s_mixer.obj.extend([sloop[-1]] + sloop[1])\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    # -\n    d_splitter = idf.newidfobject(\n        \"CONNECTOR:SPLITTER\",\n        Name=dconnlist.Connector_1_Name)\n    d_splitter.obj.extend([dloop[0]] + dloop[1])\n    d_mixer = idf.newidfobject(\n        \"CONNECTOR:MIXER\",\n        Name=dconnlist.Connector_2_Name)\n    d_mixer.obj.extend([dloop[-1]] + dloop[1])\n    # -------- <testing ---------\n    testn = doingtesting(testing, testn, newcondenserloop)\n    if testn == None:\n        returnnone()\n    # -------- testing> ---------\n    return newcondenserloop"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nforces it to be a list of tuples", "response": "def _clean_listofcomponents(listofcomponents):\n    \"\"\"force it to be a list of tuples\"\"\"\n    def totuple(item):\n        \"\"\"return a tuple\"\"\"\n        if isinstance(item, (tuple, list)):\n            return item\n        else:\n            return (item, None)\n    return [totuple(item) for item in listofcomponents]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncleaning up list of 3 - tuples", "response": "def _clean_listofcomponents_tuples(listofcomponents_tuples):\n    \"\"\"force 3 items in the tuple\"\"\"\n    def to3tuple(item):\n        \"\"\"return a 3 item tuple\"\"\"\n        if len(item) == 3:\n            return item\n        else:\n            return (item[0], item[1], None)\n    return [to3tuple(item) for item in listofcomponents_tuples]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getmakeidfobject(idf, key, name):\n    idfobject = idf.getobject(key, name)\n    if not idfobject:\n        return idf.newidfobject(key, Name=name)\n    else:\n        return idfobject", "response": "get idfobject or make it if it does not exist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replacebranch1(idf, loop, branchname, listofcomponents_tuples, fluid=None,\n                   debugsave=False):\n    \"\"\"do I even use this ? .... yup! I do\"\"\"\n    if fluid is None:\n        fluid = ''\n    listofcomponents_tuples = _clean_listofcomponents_tuples(listofcomponents_tuples)\n    branch = idf.getobject('BRANCH', branchname)  # args are (key, name)\n    listofcomponents = []\n    for comp_type, comp_name, compnode in listofcomponents_tuples:\n        comp = getmakeidfobject(idf, comp_type.upper(), comp_name)\n        listofcomponents.append((comp, compnode))\n    newbr = replacebranch(idf, loop, branch, listofcomponents,\n                          debugsave=debugsave, fluid=fluid)\n    return newbr", "response": "replace branch1 with new branch1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replacebranch(idf, loop, branch,\n                  listofcomponents, fluid=None,\n                  debugsave=False,\n                  testing=None):\n    \"\"\"It will replace the components in the branch with components in\n    listofcomponents\"\"\"\n    if fluid is None:\n        fluid = ''\n    # -------- testing ---------\n    testn = 0\n    # -------- testing ---------\n\n    # join them into a branch\n    # -----------------------\n    # np1_inlet -> np1 -> np1_np2_node -> np2 -> np2_outlet\n        # change the node names in the component\n        # empty the old branch\n        # fill in the new components with the node names into this branch\n    listofcomponents = _clean_listofcomponents(listofcomponents)\n\n    components = [item[0] for item in listofcomponents]\n    connectcomponents(idf, listofcomponents, fluid=fluid)\n    if debugsave:\n        idf.savecopy(\"hhh3.idf\")\n    # -------- testing ---------\n    testn = doingtesting(testing, testn)\n    if testn == None:\n        returnnone()\n    # -------- testing ---------\n    fields = SomeFields.a_fields\n\n    thebranch = branch\n    componentsintobranch(idf, thebranch, listofcomponents, fluid=fluid)\n    if debugsave:\n        idf.savecopy(\"hhh4.idf\")\n    # -------- testing ---------\n    testn = doingtesting(testing, testn)\n    if testn == None:\n        returnnone()\n    # -------- testing ---------\n\n    # # gather all renamed nodes\n    # # do the renaming\n    renamenodes(idf, 'node')\n    if debugsave:\n        idf.savecopy(\"hhh7.idf\")\n    # -------- testing ---------\n    testn = doingtesting(testing, testn)\n    if testn == None:\n        returnnone()\n    # -------- testing ---------\n\n    # check for the end nodes of the loop\n    if loop.key == 'AIRLOOPHVAC':\n        fields = SomeFields.a_fields\n    if loop.key == 'PLANTLOOP':\n        fields = SomeFields.p_fields\n    if loop.key == 'CONDENSERLOOP':\n        fields = SomeFields.c_fields\n    # for use in bunch\n    flnames = [field.replace(' ', '_') for field in fields]\n\n    if fluid.upper() == 'WATER':\n        supplyconlistname = loop[flnames[3]]\n        # Plant_Side_Connector_List_Name or Condenser_Side_Connector_List_Name\n    elif fluid.upper() == 'AIR':\n        supplyconlistname = loop[flnames[1]]  # Connector_List_Name'\n    supplyconlist = idf.getobject('CONNECTORLIST', supplyconlistname)\n    for i in range(1, 100000):  # large range to hit end\n        try:\n            fieldname = 'Connector_%s_Object_Type' % (i,)\n            ctype = supplyconlist[fieldname]\n        except bunch_subclass.BadEPFieldError:\n            break\n        if ctype.strip() == '':\n            break\n        fieldname = 'Connector_%s_Name' % (i,)\n        cname = supplyconlist[fieldname]\n        connector = idf.getobject(ctype.upper(), cname)\n        if connector.key == 'CONNECTOR:SPLITTER':\n            firstbranchname = connector.Inlet_Branch_Name\n            cbranchname = firstbranchname\n            isfirst = True\n        if connector.key == 'CONNECTOR:MIXER':\n            lastbranchname = connector.Outlet_Branch_Name\n            cbranchname = lastbranchname\n            isfirst = False\n        if cbranchname == thebranch.Name:\n            # rename end nodes\n            comps = getbranchcomponents(idf, thebranch)\n            if isfirst:\n                comp = comps[0]\n                inletnodename = getnodefieldname(\n                    comp,\n                    \"Inlet_Node_Name\", fluid)\n                comp[inletnodename] = [\n                    comp[inletnodename],\n                    loop[flnames[0]]]  # Plant_Side_Inlet_Node_Name\n            else:\n                comp = comps[-1]\n                outletnodename = getnodefieldname(\n                    comp,\n                    \"Outlet_Node_Name\", fluid)\n                comp[outletnodename] = [\n                    comp[outletnodename],\n                    loop[flnames[1]]]  # .Plant_Side_Outlet_Node_Name\n    # -------- testing ---------\n    testn = doingtesting(testing, testn)\n    if testn == None:\n        returnnone()\n    # -------- testing ---------\n\n    if fluid.upper() == 'WATER':\n        demandconlistname = loop[flnames[7]]  # .Demand_Side_Connector_List_Name\n        demandconlist = idf.getobject('CONNECTORLIST', demandconlistname)\n        for i in range(1, 100000):  # large range to hit end\n            try:\n                fieldname = 'Connector_%s_Object_Type' % (i,)\n                ctype = demandconlist[fieldname]\n            except bunch_subclass.BadEPFieldError:\n                break\n            if ctype.strip() == '':\n                break\n            fieldname = 'Connector_%s_Name' % (i,)\n            cname = demandconlist[fieldname]\n            connector = idf.getobject(ctype.upper(), cname)\n            if connector.key == 'CONNECTOR:SPLITTER':\n                firstbranchname = connector.Inlet_Branch_Name\n                cbranchname = firstbranchname\n                isfirst = True\n            if connector.key == 'CONNECTOR:MIXER':\n                lastbranchname = connector.Outlet_Branch_Name\n                cbranchname = lastbranchname\n                isfirst = False\n            if cbranchname == thebranch.Name:\n                # rename end nodes\n                comps = getbranchcomponents(idf, thebranch)\n                if isfirst:\n                    comp = comps[0]\n                    inletnodename = getnodefieldname(\n                        comp,\n                        \"Inlet_Node_Name\", fluid)\n                    comp[inletnodename] = [\n                        comp[inletnodename],\n                        loop[flnames[4]]]  # .Demand_Side_Inlet_Node_Name\n                if not isfirst:\n                    comp = comps[-1]\n                    outletnodename = getnodefieldname(\n                        comp,\n                        \"Outlet_Node_Name\", fluid)\n                    comp[outletnodename] = [\n                        comp[outletnodename],\n                        loop[flnames[5]]]  # .Demand_Side_Outlet_Node_Name\n\n    # -------- testing ---------\n    testn = doingtesting(testing, testn)\n    if testn == None:\n        returnnone()\n    # -------- testing ---------\n\n    if debugsave:\n        idf.savecopy(\"hhh8.idf\")\n\n    # # gather all renamed nodes\n    # # do the renaming\n    renamenodes(idf, 'node')\n    # -------- testing ---------\n    testn = doingtesting(testing, testn)\n    if testn == None:\n        returnnone()\n    # -------- testing ---------\n    if debugsave:\n        idf.savecopy(\"hhh9.idf\")\n    return thebranch", "response": "This function will replace the components in the branch with the components in listofcomponents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef area(poly):\n    if len(poly) < 3: # not a plane - no area\n        return 0\n    total = [0, 0, 0]\n    num = len(poly)\n    for i in range(num):\n        vi1 = poly[i]\n        vi2 = poly[(i+1) % num]\n        prod = np.cross(vi1, vi2)\n        total[0] += prod[0]\n        total[1] += prod[1]\n        total[2] += prod[2]\n    if total == [0, 0, 0]:  # points are in a straight line - no area\n        return 0\n    result = np.dot(total, unit_normal(poly[0], poly[1], poly[2]))\n    return abs(result/2)", "response": "Area of a polygon poly"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unit_normal(pt_a, pt_b, pt_c):\n    x_val = np.linalg.det([[1, pt_a[1], pt_a[2]], [1, pt_b[1], pt_b[2]], [1, pt_c[1], pt_c[2]]])\n    y_val = np.linalg.det([[pt_a[0], 1, pt_a[2]], [pt_b[0], 1, pt_b[2]], [pt_c[0], 1, pt_c[2]]])\n    z_val = np.linalg.det([[pt_a[0], pt_a[1], 1], [pt_b[0], pt_b[1], 1], [pt_c[0], pt_c[1], 1]])\n    magnitude = (x_val**2 + y_val**2 + z_val**2)**.5\n    mag = (x_val/magnitude, y_val/magnitude, z_val/magnitude)\n    if magnitude < 0.00000001:\n        mag = (0, 0, 0)\n    return mag", "response": "unit normal vector of plane defined by points pt_a pt_b and pt_c"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef width(poly):\n    num = len(poly) - 1\n    if abs(poly[num][2] - poly[0][2]) < abs(poly[1][2] - poly[0][2]):\n        return dist(poly[num], poly[0])\n    elif abs(poly[num][2] - poly[0][2]) > abs(poly[1][2] - poly[0][2]):\n        return dist(poly[1], poly[0])\n    else: return max(dist(poly[num], poly[0]), dist(poly[1], poly[0]))", "response": "Width of a polygon poly"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef angle2vecs(vec1, vec2):\n    # vector a * vector b = |a|*|b|* cos(angle between vector a and vector b)\n    dot = np.dot(vec1, vec2)\n    vec1_modulus = np.sqrt(np.multiply(vec1, vec1).sum())\n    vec2_modulus = np.sqrt(np.multiply(vec2, vec2).sum())\n    if (vec1_modulus * vec2_modulus) == 0:\n        cos_angle = 1\n    else: cos_angle = dot / (vec1_modulus * vec2_modulus)\n    return math.degrees(acos(cos_angle))", "response": "angle between two vectors"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntilting of a polygon poly", "response": "def tilt(poly):\n    \"\"\"Tilt of a polygon poly\"\"\"\n    num = len(poly) - 1\n    vec = unit_normal(poly[0], poly[1], poly[num])\n    vec_alt = np.array([vec[0], vec[1], vec[2]])\n    vec_z = np.array([0, 0, 1])\n    # return (90 - angle2vecs(vec_alt, vec_z)) # update by Santosh\n    return angle2vecs(vec_alt, vec_z)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all the fields that have the key field", "response": "def getfields(comm):\n    \"\"\"get all the fields that have the key 'field' \"\"\"\n    fields = []\n    for field in comm:\n        if 'field' in field:\n            fields.append(field)\n    return fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef repeatingfieldsnames(fields):\n    fnames = [field['field'][0] for field in fields]\n    fnames = [bunchhelpers.onlylegalchar(fname) for fname in fnames]\n    fnames = [fname for fname in fnames if bunchhelpers.intinlist(fname.split())]\n    fnames = [(bunchhelpers.replaceint(fname), None) for fname in fnames]\n    dct = dict(fnames)\n    repnames = fnames[:len(list(dct.keys()))]\n    return repnames", "response": "get the names of the repeating fields"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef missingkeys_standard(commdct, dtls, skiplist=None):\n    if skiplist == None:\n        skiplist = []\n    # find objects where all the fields are not named\n    gkeys = [dtls[i] for i in range(len(dtls)) if commdct[i].count({}) > 2]\n    nofirstfields = []\n    # operatie on those fields\n    for key_txt in gkeys:\n        if key_txt in skiplist:\n            continue\n        # print key_txt\n        # for a function, pass comm as a variable\n        key_i = dtls.index(key_txt.upper())\n        comm = commdct[key_i]\n\n\n\n        # get all fields\n        fields = getfields(comm)\n\n        # get repeating field names\n        repnames = repeatingfieldsnames(fields)\n\n        try:\n            first = repnames[0][0] % (1, )\n        except IndexError:\n            nofirstfields.append(key_txt)\n            continue\n        # print first\n\n        # get all comments of the first repeating field names\n        firstnames = [repname[0] % (1, ) for repname in repnames]\n        fcomments = [field for field in fields\n                     if bunchhelpers.onlylegalchar(field['field'][0])\n                     in firstnames]\n        fcomments = [dict(fcomment) for fcomment in fcomments]\n        for cmt in fcomments:\n            fld = cmt['field'][0]\n            fld = bunchhelpers.onlylegalchar(fld)\n            fld = bunchhelpers.replaceint(fld)\n            cmt['field'] = [fld]\n\n        for i, cmt in enumerate(comm[1:]):\n            thefield = cmt['field'][0]\n            thefield = bunchhelpers.onlylegalchar(thefield)\n            if thefield == first:\n                break\n        first_i = i + 1\n\n        newfields = []\n        for i in range(1, len(comm[first_i:]) // len(repnames) + 1):\n            for fcomment in fcomments:\n                nfcomment = dict(fcomment)\n                fld = nfcomment['field'][0]\n                fld = fld % (i, )\n                nfcomment['field'] = [fld]\n                newfields.append(nfcomment)\n\n        for i, cmt in enumerate(comm):\n            if i < first_i:\n                continue\n            else:\n                afield = newfields.pop(0)\n                comm[i] = afield\n        commdct[key_i] = comm\n    return nofirstfields", "response": "put missing keys in commdct for standard objects\n    return a list of keys where it is unable to do so\n    commdct is not updated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef missingkeys_nonstandard(block, commdct, dtls, objectlist, afield='afiled %s'):\n    afield = 'afield %s'\n    for key_txt in objectlist:\n        key_i = dtls.index(key_txt.upper())\n        comm = commdct[key_i]\n        if block:\n            blk = block[key_i]\n        for i, cmt in enumerate(comm):\n            if cmt == {}:\n                first_i = i\n                break\n        for i, cmt in enumerate(comm):\n            if i >= first_i:\n                if block:\n                    comm[i]['field'] = ['%s' % (blk[i])]\n                else:\n                    comm[i]['field'] = [afield % (i - first_i + 1,),]", "response": "This function is used to set the field names of the objectlist that are not in the objectlist."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_event_loop():\n  ev = _state.event_loop\n  if not os.getenv(_EVENT_LOOP_KEY) and ev is not None:\n    ev.clear()\n    _state.event_loop = None\n    ev = None\n  if ev is None:\n    ev = EventLoop()\n    _state.event_loop = ev\n    os.environ[_EVENT_LOOP_KEY] = '1'\n  return ev", "response": "Return an EventLoop instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear(self):\n    while self.current or self.idlers or self.queue or self.rpcs:\n      current = self.current\n      idlers = self.idlers\n      queue = self.queue\n      rpcs = self.rpcs\n      _logging_debug('Clearing stale EventLoop instance...')\n      if current:\n        _logging_debug('  current = %s', current)\n      if idlers:\n        _logging_debug('  idlers = %s', idlers)\n      if queue:\n        _logging_debug('  queue = %s', queue)\n      if rpcs:\n        _logging_debug('  rpcs = %s', rpcs)\n      self.__init__()\n      current.clear()\n      idlers.clear()\n      queue[:] = []\n      rpcs.clear()\n      _logging_debug('Cleared')", "response": "Remove all pending events without running any."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting event into queue and keep it sorted assuming queue is sorted.", "response": "def insort_event_right(self, event, lo=0, hi=None):\n    \"\"\"Insert event in queue, and keep it sorted assuming queue is sorted.\n\n    If event is already in queue, insert it to the right of the rightmost\n    event (to keep FIFO order).\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n\n    Args:\n      event: a (time in sec since unix epoch, callback, args, kwds) tuple.\n    \"\"\"\n\n    if lo < 0:\n      raise ValueError('lo must be non-negative')\n    if hi is None:\n      hi = len(self.queue)\n    while lo < hi:\n      mid = (lo + hi) // 2\n      if event[0] < self.queue[mid][0]:\n        hi = mid\n      else:\n        lo = mid + 1\n    self.queue.insert(lo, event)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nschedule a function call at a specific time in the future.", "response": "def queue_call(self, delay, callback, *args, **kwds):\n    \"\"\"Schedule a function call at a specific time in the future.\"\"\"\n    if delay is None:\n      self.current.append((callback, args, kwds))\n      return\n    if delay < 1e9:\n      when = delay + self.clock.now()\n    else:\n      # Times over a billion seconds are assumed to be absolute.\n      when = delay\n    self.insort_event_right((when, callback, args, kwds))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscheduling an RPC to be executed on the service.", "response": "def queue_rpc(self, rpc, callback=None, *args, **kwds):\n    \"\"\"Schedule an RPC with an optional callback.\n\n    The caller must have previously sent the call to the service.\n    The optional callback is called with the remaining arguments.\n\n    NOTE: If the rpc is a MultiRpc, the callback will be called once\n    for each sub-RPC.  TODO: Is this a good idea?\n    \"\"\"\n    if rpc is None:\n      return\n    if rpc.state not in (_RUNNING, _FINISHING):\n      raise RuntimeError('rpc must be sent to service before queueing')\n    if isinstance(rpc, datastore_rpc.MultiRpc):\n      rpcs = rpc.rpcs\n      if len(rpcs) > 1:\n        # Don't call the callback until all sub-rpcs have completed.\n        rpc.__done = False\n\n        def help_multi_rpc_along(r=rpc, c=callback, a=args, k=kwds):\n          if r.state == _FINISHING and not r.__done:\n            r.__done = True\n            c(*a, **k)\n            # TODO: And again, what about exceptions?\n        callback = help_multi_rpc_along\n        args = ()\n        kwds = {}\n    else:\n      rpcs = [rpc]\n    for rpc in rpcs:\n      self.rpcs[rpc] = (callback, args, kwds)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an idle callback.", "response": "def add_idle(self, callback, *args, **kwds):\n    \"\"\"Add an idle callback.\n\n    An idle callback can return True, False or None.  These mean:\n\n    - None: remove the callback (don't reschedule)\n    - False: the callback did no work; reschedule later\n    - True: the callback did some work; reschedule soon\n\n    If the callback raises an exception, the traceback is logged and\n    the callback is removed.\n    \"\"\"\n    self.idlers.append((callback, args, kwds))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_idle(self):\n    if not self.idlers or self.inactive >= len(self.idlers):\n      return False\n    idler = self.idlers.popleft()\n    callback, args, kwds = idler\n    _logging_debug('idler: %s', callback.__name__)\n    res = callback(*args, **kwds)\n    # See add_idle() for the meaning of the callback return value.\n    if res is not None:\n      if res:\n        self.inactive = 0\n      else:\n        self.inactive += 1\n      self.idlers.append(idler)\n    else:\n      _logging_debug('idler %s removed', callback.__name__)\n    return True", "response": "Run one of the idle callbacks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run0(self):\n    if self.current:\n      self.inactive = 0\n      callback, args, kwds = self.current.popleft()\n      _logging_debug('nowevent: %s', callback.__name__)\n      callback(*args, **kwds)\n      return 0\n    if self.run_idle():\n      return 0\n    delay = None\n    if self.queue:\n      delay = self.queue[0][0] - self.clock.now()\n      if delay <= 0:\n        self.inactive = 0\n        _, callback, args, kwds = self.queue.pop(0)\n        _logging_debug('event: %s', callback.__name__)\n        callback(*args, **kwds)\n        # TODO: What if it raises an exception?\n        return 0\n    if self.rpcs:\n      self.inactive = 0\n      rpc = datastore_rpc.MultiRpc.wait_any(self.rpcs)\n      if rpc is not None:\n        _logging_debug('rpc: %s.%s', rpc.service, rpc.method)\n        # Yes, wait_any() may return None even for a non-empty argument.\n        # But no, it won't ever return an RPC not in its argument.\n        if rpc not in self.rpcs:\n          raise RuntimeError('rpc %r was not given to wait_any as a choice %r' %\n                             (rpc, self.rpcs))\n        callback, args, kwds = self.rpcs[rpc]\n        del self.rpcs[rpc]\n        if callback is not None:\n          callback(*args, **kwds)\n          # TODO: Again, what about exceptions?\n      return 0\n    return delay", "response": "Run one item in a tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run1(self):\n    delay = self.run0()\n    if delay is None:\n      return False\n    if delay > 0:\n      self.clock.sleep(delay)\n    return True", "response": "Run one item in the queue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_prop_from_modelclass(modelclass, name):\n  if name == '__key__':\n    return modelclass._key\n\n  parts = name.split('.')\n  part, more = parts[0], parts[1:]\n  prop = modelclass._properties.get(part)\n  if prop is None:\n    if issubclass(modelclass, model.Expando):\n      prop = model.GenericProperty(part)\n    else:\n      raise TypeError('Model %s has no property named %r' %\n                      (modelclass._get_kind(), part))\n\n  while more:\n    part = more.pop(0)\n    if not isinstance(prop, model.StructuredProperty):\n      raise TypeError('Model %s has no property named %r' %\n                      (modelclass._get_kind(), part))\n    maybe = getattr(prop, part, None)\n    if isinstance(maybe, model.Property) and maybe._name == part:\n      prop = maybe\n    else:\n      maybe = prop._modelclass._properties.get(part)\n      if maybe is not None:\n        # Must get it this way to get the copy with the long name.\n        # (See StructuredProperty.__getattr__() for details.)\n        prop = getattr(prop, maybe._code_name)\n      else:\n        if issubclass(prop._modelclass, model.Expando) and not more:\n          prop = model.GenericProperty()\n          prop._name = name  # Bypass the restriction on dots.\n        else:\n          raise KeyError('Model %s has no property named %r' %\n                         (prop._modelclass._get_kind(), part))\n\n  return prop", "response": "Helper function for parsing a property name into a property object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a GQL query string.", "response": "def gql(query_string, *args, **kwds):\n  \"\"\"Parse a GQL query string.\n\n  Args:\n    query_string: Full GQL query, e.g. 'SELECT * FROM Kind WHERE prop = 1'.\n    *args, **kwds: If present, used to call bind().\n\n  Returns:\n    An instance of query_class.\n  \"\"\"\n  qry = _gql(query_string)\n  if args or kwds:\n    qry = qry._bind(args, kwds)\n  return qry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a GQL query string and return an instance of query_class.", "response": "def _gql(query_string, query_class=Query):\n  \"\"\"Parse a GQL query string (internal version).\n\n  Args:\n    query_string: Full GQL query, e.g. 'SELECT * FROM Kind WHERE prop = 1'.\n    query_class: Optional class to use, default Query.\n\n  Returns:\n    An instance of query_class.\n  \"\"\"\n  from .google_imports import gql  # Late import, to avoid name conflict.\n  gql_qry = gql.GQL(query_string)\n  kind = gql_qry.kind()\n  if kind is None:\n    # The query must be lacking a \"FROM <kind>\" class.  Let Expando\n    # stand in for the model class (it won't actually be used to\n    # construct the results).\n    modelclass = model.Expando\n  else:\n    modelclass = model.Model._lookup_model(\n        kind,\n        tasklets.get_context()._conn.adapter.default_model)\n    # Adjust kind to the kind of the model class.\n    kind = modelclass._get_kind()\n  ancestor = None\n  flt = gql_qry.filters()\n  filters = list(modelclass._default_filters())\n  for name_op in sorted(flt):\n    name, op = name_op\n    values = flt[name_op]\n    op = op.lower()\n    if op == 'is' and name == gql.GQL._GQL__ANCESTOR:\n      if len(values) != 1:\n        raise ValueError('\"is\" requires exactly one value')\n      [(func, args)] = values\n      ancestor = _args_to_val(func, args)\n      continue\n    if op not in _OPS:\n      raise NotImplementedError('Operation %r is not supported.' % op)\n    for (func, args) in values:\n      val = _args_to_val(func, args)\n      prop = _get_prop_from_modelclass(modelclass, name)\n      if prop._name != name:\n        raise RuntimeError('Whoa! _get_prop_from_modelclass(%s, %r) '\n                           'returned a property whose name is %r?!' %\n                           (modelclass.__name__, name, prop._name))\n      if isinstance(val, ParameterizedThing):\n        node = ParameterNode(prop, op, val)\n      elif op == 'in':\n        node = prop._IN(val)\n      else:\n        node = prop._comparison(op, val)\n      filters.append(node)\n  if filters:\n    filters = ConjunctionNode(*filters)\n  else:\n    filters = None\n  orders = _orderings_to_orders(gql_qry.orderings(), modelclass)\n  offset = gql_qry.offset()\n  limit = gql_qry.limit()\n  if limit < 0:\n    limit = None\n  keys_only = gql_qry._keys_only\n  if not keys_only:\n    keys_only = None\n  options = QueryOptions(offset=offset, limit=limit, keys_only=keys_only)\n  projection = gql_qry.projection()\n  if gql_qry.is_distinct():\n    group_by = projection\n  else:\n    group_by = None\n  qry = query_class(kind=kind,\n                    ancestor=ancestor,\n                    filters=filters,\n                    orders=orders,\n                    default_options=options,\n                    projection=projection,\n                    group_by=group_by)\n  return qry"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _apply(self, key_value_map):\n    columns = []\n    for key in self.match_keys:\n      column = key_value_map.get(key)\n      if not column:  # None, or an empty list.\n        return False  # If any column is empty there can be no match.\n      columns.append(column)\n    # Use izip to transpose the columns into rows.\n    return self.match_values in itertools.izip(*columns)", "response": "Apply the filter to the values extracted from an entity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun this query and put entities into the given queue.", "response": "def run_to_queue(self, queue, conn, options=None, dsquery=None):\n    \"\"\"Run this query, putting entities into the given queue.\"\"\"\n    try:\n      multiquery = self._maybe_multi_query()\n      if multiquery is not None:\n        yield multiquery.run_to_queue(queue, conn, options=options)\n        return\n\n      if dsquery is None:\n        dsquery = self._get_query(conn)\n      rpc = dsquery.run_async(conn, options)\n      while rpc is not None:\n        batch = yield rpc\n        if (batch.skipped_results and\n            datastore_query.FetchOptions.offset(options)):\n          offset = options.offset - batch.skipped_results\n          options = datastore_query.FetchOptions(offset=offset, config=options)\n        rpc = batch.next_batch_async(options)\n        for i, result in enumerate(batch.results):\n          queue.putq((batch, i, result))\n      queue.complete()\n\n    except GeneratorExit:\n      raise\n    except Exception:\n      if not queue.done():\n        _, e, tb = sys.exc_info()\n        queue.set_exception(e, tb)\n      raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_distinct(self):\n    return bool(self.__group_by and\n                set(self._to_property_names(self.__group_by)) <=\n                set(self._to_property_names(self.__projection)))", "response": "True if results are guaranteed to contain a unique set of property\n    values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new Query with additional filter ( s ) applied.", "response": "def filter(self, *args):\n    \"\"\"Return a new Query with additional filter(s) applied.\"\"\"\n    if not args:\n      return self\n    preds = []\n    f = self.filters\n    if f:\n      preds.append(f)\n    for arg in args:\n      if not isinstance(arg, Node):\n        raise TypeError('Cannot filter a non-Node argument; received %r' % arg)\n      preds.append(arg)\n    if not preds:\n      pred = None\n    elif len(preds) == 1:\n      pred = preds[0]\n    else:\n      pred = ConjunctionNode(*preds)\n    return self.__class__(kind=self.kind, ancestor=self.ancestor,\n                          filters=pred, orders=self.orders,\n                          app=self.app, namespace=self.namespace,\n                          default_options=self.default_options,\n                          projection=self.projection, group_by=self.group_by)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef order(self, *args):\n    # q.order(Employee.name, -Employee.age)\n    if not args:\n      return self\n    orders = []\n    o = self.orders\n    if o:\n      orders.append(o)\n    for arg in args:\n      if isinstance(arg, model.Property):\n        orders.append(datastore_query.PropertyOrder(arg._name, _ASC))\n      elif isinstance(arg, datastore_query.Order):\n        orders.append(arg)\n      else:\n        raise TypeError('order() expects a Property or query Order; '\n                        'received %r' % arg)\n    if not orders:\n      orders = None\n    elif len(orders) == 1:\n      orders = orders[0]\n    else:\n      orders = datastore_query.CompositeOrder(orders)\n    return self.__class__(kind=self.kind, ancestor=self.ancestor,\n                          filters=self.filters, orders=orders,\n                          app=self.app, namespace=self.namespace,\n                          default_options=self.default_options,\n                          projection=self.projection, group_by=self.group_by)", "response": "Return a new Query with additional sort order ( s ) applied."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef map(self, callback, pass_batch_into_callback=None,\n          merge_future=None, **q_options):\n    \"\"\"Map a callback function or tasklet over the query results.\n\n    Args:\n      callback: A function or tasklet to be applied to each result; see below.\n      merge_future: Optional Future subclass; see below.\n      **q_options: All query options keyword arguments are supported.\n\n    Callback signature: The callback is normally called with an entity\n    as argument.  However if keys_only=True is given, it is called\n    with a Key.  Also, when pass_batch_into_callback is True, it is\n    called with three arguments: the current batch, the index within\n    the batch, and the entity or Key at that index.  The callback can\n    return whatever it wants.  If the callback is None, a trivial\n    callback is assumed that just returns the entity or key passed in\n    (ignoring produce_cursors).\n\n    Optional merge future: The merge_future is an advanced argument\n    that can be used to override how the callback results are combined\n    into the overall map() return value.  By default a list of\n    callback return values is produced.  By substituting one of a\n    small number of specialized alternatives you can arrange\n    otherwise.  See tasklets.MultiFuture for the default\n    implementation and a description of the protocol the merge_future\n    object must implement the default.  Alternatives from the same\n    module include QueueFuture, SerialQueueFuture and ReducingFuture.\n\n    Returns:\n      When the query has run to completion and all callbacks have\n      returned, map() returns a list of the results of all callbacks.\n      (But see 'optional merge future' above.)\n    \"\"\"\n    return self.map_async(callback,\n                          pass_batch_into_callback=pass_batch_into_callback,\n                          merge_future=merge_future,\n                          **q_options).get_result()", "response": "Map a callback function or tasklet over the query results."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmapping a callback function or tasklet over the query results.", "response": "def map_async(self, callback, pass_batch_into_callback=None,\n                merge_future=None, **q_options):\n    \"\"\"Map a callback function or tasklet over the query results.\n\n    This is the asynchronous version of Query.map().\n    \"\"\"\n    qry = self._fix_namespace()\n    return tasklets.get_context().map_query(\n        qry,\n        callback,\n        pass_batch_into_callback=pass_batch_into_callback,\n        options=self._make_options(q_options),\n        merge_future=merge_future)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_async(self, limit=None, **q_options):\n    if limit is None:\n      default_options = self._make_options(q_options)\n      if default_options is not None and default_options.limit is not None:\n        limit = default_options.limit\n      else:\n        limit = _MAX_LIMIT\n    q_options['limit'] = limit\n    q_options.setdefault('batch_size', limit)\n    if self._needs_multi_query():\n      return self.map_async(None, **q_options)\n    # Optimization using direct batches.\n    options = self._make_options(q_options)\n    qry = self._fix_namespace()\n    return qry._run_to_list([], options=options)", "response": "Fetch a list of query results up to a limit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_async(self, **q_options):\n    res = yield self.fetch_async(1, **q_options)\n    if not res:\n      raise tasklets.Return(None)\n    raise tasklets.Return(res[0])", "response": "Internal version of get_async."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncounting the number of query results up to a limit.", "response": "def count_async(self, limit=None, **q_options):\n    \"\"\"Count the number of query results, up to a limit.\n\n    This is the asynchronous version of Query.count().\n    \"\"\"\n    qry = self._fix_namespace()\n    return qry._count_async(limit=limit, **q_options)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a page of results. This is the asynchronous version of Query. fetch_page.", "response": "def fetch_page_async(self, page_size, **q_options):\n    \"\"\"Fetch a page of results.\n\n    This is the asynchronous version of Query.fetch_page().\n    \"\"\"\n    qry = self._fix_namespace()\n    return qry._fetch_page_async(page_size, **q_options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _fetch_page_async(self, page_size, **q_options):\n    q_options.setdefault('batch_size', page_size)\n    q_options.setdefault('produce_cursors', True)\n    it = self.iter(limit=page_size + 1, **q_options)\n    results = []\n    while (yield it.has_next_async()):\n      results.append(it.next())\n      if len(results) >= page_size:\n        break\n    try:\n      cursor = it.cursor_after()\n    except datastore_errors.BadArgumentError:\n      cursor = None\n    raise tasklets.Return(results, cursor, it.probably_has_next())", "response": "Internal version of fetch_page_async."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef analyze(self):\n    class MockBindings(dict):\n\n      def __contains__(self, key):\n        self[key] = None\n        return True\n    bindings = MockBindings()\n    used = {}\n    ancestor = self.ancestor\n    if isinstance(ancestor, ParameterizedThing):\n      ancestor = ancestor.resolve(bindings, used)\n    filters = self.filters\n    if filters is not None:\n      filters = filters.resolve(bindings, used)\n    return sorted(used)", "response": "Return a list giving the parameters required by a query."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbinds parameter values. Returns a new Query object.", "response": "def _bind(self, args, kwds):\n    \"\"\"Bind parameter values.  Returns a new Query object.\"\"\"\n    bindings = dict(kwds)\n    for i, arg in enumerate(args):\n      bindings[i + 1] = arg\n    used = {}\n    ancestor = self.ancestor\n    if isinstance(ancestor, ParameterizedThing):\n      ancestor = ancestor.resolve(bindings, used)\n    filters = self.filters\n    if filters is not None:\n      filters = filters.resolve(bindings, used)\n    unused = []\n    for i in xrange(1, 1 + len(args)):\n      if i not in used:\n        unused.append(i)\n    if unused:\n      raise datastore_errors.BadArgumentError(\n          'Positional arguments %s were given but not used.' %\n          ', '.join(str(i) for i in unused))\n    return self.__class__(kind=self.kind, ancestor=ancestor,\n                          filters=filters, orders=self.orders,\n                          app=self.app, namespace=self.namespace,\n                          default_options=self.default_options,\n                          projection=self.projection, group_by=self.group_by)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the cursor before the current item.", "response": "def cursor_before(self):\n    \"\"\"Return the cursor before the current item.\n\n    You must pass a QueryOptions object with produce_cursors=True\n    for this to work.\n\n    If there is no cursor or no current item, raise BadArgumentError.\n    Before next() has returned there is no cursor.  Once the loop is\n    exhausted, this returns the cursor after the last item.\n    \"\"\"\n    if self._exhausted:\n      return self.cursor_after()\n    if isinstance(self._cursor_before, BaseException):\n      raise self._cursor_before\n    return self._cursor_before"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the cursor after the current item.", "response": "def cursor_after(self):\n    \"\"\"Return the cursor after the current item.\n\n    You must pass a QueryOptions object with produce_cursors=True\n    for this to work.\n\n    If there is no cursor or no current item, raise BadArgumentError.\n    Before next() has returned there is no cursor.    Once the loop is\n    exhausted, this returns the cursor after the last item.\n    \"\"\"\n    if isinstance(self._cursor_after, BaseException):\n      raise self._cursor_after\n    return self._cursor_after"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_next_async(self):\n    if self._fut is None:\n      self._fut = self._iter.getq()\n    flag = True\n    try:\n      yield self._fut\n    except EOFError:\n      flag = False\n    raise tasklets.Return(flag)", "response": "Return a Future whose result will say whether a next item is available."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef next(self):\n    if self._fut is None:\n      self._fut = self._iter.getq()\n    try:\n      try:\n        # The future result is set by this class's _extended_callback\n        # method.\n        # pylint: disable=unpacking-non-sequence\n        (ent,\n         self._cursor_before,\n         self._cursor_after,\n         self._more_results) = self._fut.get_result()\n        return ent\n      except EOFError:\n        self._exhausted = True\n        raise StopIteration\n    finally:\n      self._fut = None", "response": "Iterator protocol for get next item or raise StopIteration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun this query and put entities into the given queue.", "response": "def run_to_queue(self, queue, conn, options=None):\n    \"\"\"Run this query, putting entities into the given queue.\"\"\"\n    if options is None:\n      # Default options.\n      offset = None\n      limit = None\n      keys_only = None\n    else:\n      # Capture options we need to simulate.\n      offset = options.offset\n      limit = options.limit\n      keys_only = options.keys_only\n\n      # Cursors are supported for certain orders only.\n      if (options.start_cursor or options.end_cursor or\n          options.produce_cursors):\n        names = set()\n        if self.__orders is not None:\n          names = self.__orders._get_prop_names()\n        if '__key__' not in names:\n          raise datastore_errors.BadArgumentError(\n              '_MultiQuery with cursors requires __key__ order')\n\n    # Decide if we need to modify the options passed to subqueries.\n    # NOTE: It would seem we can sometimes let Cloud Datastore handle\n    # the offset natively, but this would thwart the duplicate key\n    # detection, so we always have to emulate the offset here.\n    # We can set the limit we pass along to offset + limit though,\n    # since that is the maximum number of results from a single\n    # subquery we will ever have to consider.\n    modifiers = {}\n    if offset:\n      modifiers['offset'] = None\n      if limit is not None:\n        modifiers['limit'] = min(_MAX_LIMIT, offset + limit)\n    if keys_only and self.__orders is not None:\n      modifiers['keys_only'] = None\n    if modifiers:\n      options = QueryOptions(config=options, **modifiers)\n\n    if offset is None:\n      offset = 0\n\n    if limit is None:\n      limit = _MAX_LIMIT\n\n    if self.__orders is None:\n      # Run the subqueries sequentially; there is no order to keep.\n      keys_seen = set()\n      for subq in self.__subqueries:\n        if limit <= 0:\n          break\n        subit = tasklets.SerialQueueFuture('_MultiQuery.run_to_queue[ser]')\n        subq.run_to_queue(subit, conn, options=options)\n        while limit > 0:\n          try:\n            batch, index, result = yield subit.getq()\n          except EOFError:\n            break\n          if keys_only:\n            key = result\n          else:\n            key = result._key\n          if key not in keys_seen:\n            keys_seen.add(key)\n            if offset > 0:\n              offset -= 1\n            else:\n              limit -= 1\n              queue.putq((None, None, result))\n      queue.complete()\n      return\n\n    # This with-statement causes the adapter to set _orig_pb on all\n    # entities it converts from protobuf.\n    # TODO: Does this interact properly with the cache?\n    with conn.adapter:\n      # Start running all the sub-queries.\n      todo = []  # List of (subit, dsquery) tuples.\n      for subq in self.__subqueries:\n        dsquery = subq._get_query(conn)\n        subit = tasklets.SerialQueueFuture('_MultiQuery.run_to_queue[par]')\n        subq.run_to_queue(subit, conn, options=options, dsquery=dsquery)\n        todo.append((subit, dsquery))\n\n      # Create a list of (first-entity, subquery-iterator) tuples.\n      state = []  # List of _SubQueryIteratorState instances.\n      for subit, dsquery in todo:\n        try:\n          thing = yield subit.getq()\n        except EOFError:\n          continue\n        else:\n          state.append(_SubQueryIteratorState(thing, subit, dsquery,\n                                              self.__orders))\n\n      # Now turn it into a sorted heap.  The heapq module claims that\n      # calling heapify() is more efficient than calling heappush() for\n      # each item.\n      heapq.heapify(state)\n\n      # Repeatedly yield the lowest entity from the state vector,\n      # filtering duplicates.  This is essentially a multi-way merge\n      # sort.  One would think it should be possible to filter\n      # duplicates simply by dropping other entities already in the\n      # state vector that are equal to the lowest entity, but because of\n      # the weird sorting of repeated properties, we have to explicitly\n      # keep a set of all keys, so we can remove later occurrences.\n      # Note that entities will still be sorted correctly, within the\n      # constraints given by the sort order.\n      keys_seen = set()\n      while state and limit > 0:\n        item = heapq.heappop(state)\n        batch = item.batch\n        index = item.index\n        entity = item.entity\n        key = entity._key\n        if key not in keys_seen:\n          keys_seen.add(key)\n          if offset > 0:\n            offset -= 1\n          else:\n            limit -= 1\n            if keys_only:\n              queue.putq((batch, index, key))\n            else:\n              queue.putq((batch, index, entity))\n        subit = item.iterator\n        try:\n          batch, index, entity = yield subit.getq()\n        except EOFError:\n          pass\n        else:\n          item.batch = batch\n          item.index = index\n          item.entity = entity\n          heapq.heappush(state, item)\n      queue.complete()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap for memcache. get.", "response": "def memcache_get(self, key, for_cas=False, namespace=None, use_cache=False,\n                   deadline=None):\n    \"\"\"An auto-batching wrapper for memcache.get() or .get_multi().\n\n    Args:\n      key: Key to set.  This must be a string; no prefix is applied.\n      for_cas: If True, request and store CAS ids on the Context.\n      namespace: Optional namespace.\n      deadline: Optional deadline for the RPC.\n\n    Returns:\n      A Future (!) whose return value is the value retrieved from\n      memcache, or None.\n    \"\"\"\n    if not isinstance(key, basestring):\n      raise TypeError('key must be a string; received %r' % key)\n    if not isinstance(for_cas, bool):\n      raise TypeError('for_cas must be a bool; received %r' % for_cas)\n    if namespace is None:\n      namespace = namespace_manager.get_namespace()\n    options = (for_cas, namespace, deadline)\n    batcher = self.memcache_get_batcher\n    if use_cache:\n      return batcher.add_once(key, options)\n    else:\n      return batcher.add(key, options)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef positional(max_pos_args):\n  __ndb_debug__ = 'SKIP'\n\n  def positional_decorator(wrapped):\n    if not DEBUG:\n      return wrapped\n    __ndb_debug__ = 'SKIP'\n\n    @wrapping(wrapped)\n    def positional_wrapper(*args, **kwds):\n      __ndb_debug__ = 'SKIP'\n      if len(args) > max_pos_args:\n        plural_s = ''\n        if max_pos_args != 1:\n          plural_s = 's'\n        raise TypeError(\n            '%s() takes at most %d positional argument%s (%d given)' %\n            (wrapped.__name__, max_pos_args, plural_s, len(args)))\n      return wrapped(*args, **kwds)\n    return positional_wrapper\n  return positional_decorator", "response": "A decorator to declare that only the first N arguments may be positional."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decorator(wrapped_decorator):\n  def helper(_func=None, **options):\n    def outer_wrapper(func):\n      @wrapping(func)\n      def inner_wrapper(*args, **kwds):\n        return wrapped_decorator(func, args, kwds, **options)\n      return inner_wrapper\n\n    if _func is None:\n      # Form (2), with options.\n      return outer_wrapper\n\n    # Form (1), vanilla.\n    if options:\n      # Don't allow @decorator(foo, op1=5).\n      raise TypeError('positional arguments not supported')\n    return outer_wrapper(_func)\n  helper.wrapped_decorator = wrapped_decorator\n  return helper", "response": "A decorator that returns a function that accepts keyword arguments in its declaration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fibonacci(n):\n  if n <= 1:\n    raise ndb.Return(n)\n  a, b = yield fibonacci(n - 1), fibonacci(n - 2)\n  raise ndb.Return(a + b)", "response": "A recursive Fibonacci to exercise task switching."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef memoizing_fibonacci(n):\n  if n <= 1:\n    raise ndb.Return(n)\n  key = ndb.Key(FibonacciMemo, str(n))\n  memo = yield key.get_async(ndb_should_cache=False)\n  if memo is not None:\n    assert memo.arg == n\n    logging.info('memo hit: %d -> %d', n, memo.value)\n    raise ndb.Return(memo.value)\n  logging.info('memo fail: %d', n)\n  a = yield memoizing_fibonacci(n - 1)\n  b = yield memoizing_fibonacci(n - 2)\n  ans = a + b\n  memo = FibonacciMemo(key=key, arg=n, value=ans)\n  logging.info('memo write: %d -> %d', n, memo.value)\n  yield memo.put_async(ndb_should_cache=False)\n  raise ndb.Return(ans)", "response": "A memoizing recursive Fibonacci to exercise RPCs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_queue(self, options, todo):\n    utils.logging_debug('AutoBatcher(%s): %d items',\n                        self._todo_tasklet.__name__, len(todo))\n    batch_fut = self._todo_tasklet(todo, options)\n    self._running.append(batch_fut)\n    # Add a callback when we're done.\n    batch_fut.add_callback(self._finished_callback, batch_fut, todo)", "response": "Actually run the _todo_tasklet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an arg and returns a future.", "response": "def add(self, arg, options=None):\n    \"\"\"Adds an arg and gets back a future.\n\n    Args:\n      arg: one argument for _todo_tasklet.\n      options: rpc options.\n\n    Return:\n      An instance of future, representing the result of running\n        _todo_tasklet without batching.\n    \"\"\"\n    fut = tasklets.Future('%s.add(%s, %s)' % (self, arg, options))\n    todo = self._queues.get(options)\n    if todo is None:\n      utils.logging_debug('AutoBatcher(%s): creating new queue for %r',\n                          self._todo_tasklet.__name__, options)\n      if not self._queues:\n        eventloop.add_idle(self._on_idle)\n      todo = self._queues[options] = []\n    todo.append((fut, arg))\n    if len(todo) >= self._limit:\n      del self._queues[options]\n      self.run_queue(options, todo)\n    return fut"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _finished_callback(self, batch_fut, todo):\n    self._running.remove(batch_fut)\n    err = batch_fut.get_exception()\n    if err is not None:\n      tb = batch_fut.get_traceback()\n      for (fut, _) in todo:\n        if not fut.done():\n          fut.set_exception(err, tb)", "response": "Called by the tasklet when the batch future has finished."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_namespaces(start=None, end=None):\n  q = Namespace.query()\n  if start is not None:\n    q = q.filter(Namespace.key >= Namespace.key_for_namespace(start))\n  if end is not None:\n    q = q.filter(Namespace.key < Namespace.key_for_namespace(end))\n  return [x.namespace_name for x in q]", "response": "Return all namespaces in the specified range."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all kinds in the specified range for the current namespace.", "response": "def get_kinds(start=None, end=None):\n  \"\"\"Return all kinds in the specified range, for the current namespace.\n\n  Args:\n    start: only return kinds >= start if start is not None.\n    end: only return kinds < end if end is not None.\n\n  Returns:\n    A list of kind names between the (optional) start and end values.\n  \"\"\"\n  q = Kind.query()\n  if start is not None and start != '':\n    q = q.filter(Kind.key >= Kind.key_for_kind(start))\n  if end is not None:\n    if end == '':\n      return []\n    q = q.filter(Kind.key < Kind.key_for_kind(end))\n\n  return [x.kind_name for x in q]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_properties_of_kind(kind, start=None, end=None):\n  q = Property.query(ancestor=Property.key_for_kind(kind))\n  if start is not None and start != '':\n    q = q.filter(Property.key >= Property.key_for_property(kind, start))\n  if end is not None:\n    if end == '':\n      return []\n    q = q.filter(Property.key < Property.key_for_property(kind, end))\n\n  return [Property.key_to_property(k) for k in q.iter(keys_only=True)]", "response": "Return all properties of the specified kind in the specified range."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all representations of properties of the specified kind in the specified range.", "response": "def get_representations_of_kind(kind, start=None, end=None):\n  \"\"\"Return all representations of properties of kind in the specified range.\n\n  NOTE: This function does not return unindexed properties.\n\n  Args:\n    kind: name of kind whose properties you want.\n    start: only return properties >= start if start is not None.\n    end: only return properties < end if end is not None.\n\n  Returns:\n    A dictionary mapping property names to its list of representations.\n  \"\"\"\n  q = Property.query(ancestor=Property.key_for_kind(kind))\n  if start is not None and start != '':\n    q = q.filter(Property.key >= Property.key_for_property(kind, start))\n  if end is not None:\n    if end == '':\n      return {}\n    q = q.filter(Property.key < Property.key_for_property(kind, end))\n\n  result = {}\n  for property in q:\n    result[property.property_name] = property.property_representation\n\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the version of the entity group containing key.", "response": "def get_entity_group_version(key):\n  \"\"\"Return the version of the entity group containing key.\n\n  Args:\n    key: a key for an entity group whose __entity_group__ key you want.\n\n  Returns:\n    The version of the entity group containing key. This version is\n    guaranteed to increase on every change to the entity group. The version\n    may increase even in the absence of user-visible changes to the entity\n    group. May return None if the entity group was never written to.\n\n    On non-HR datatores, this function returns None.\n  \"\"\"\n\n  eg = EntityGroup.key_for_entity_group(key).get()\n  if eg:\n    return eg.version\n  else:\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Key for a namespace.", "response": "def key_for_namespace(cls, namespace):\n    \"\"\"Return the Key for a namespace.\n\n    Args:\n      namespace: A string giving the namespace whose key is requested.\n\n    Returns:\n      The Key for the namespace.\n    \"\"\"\n    if namespace:\n      return model.Key(cls.KIND_NAME, namespace)\n    else:\n      return model.Key(cls.KIND_NAME, cls.EMPTY_NAMESPACE_ID)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the key for the given property of the given kind.", "response": "def key_for_property(cls, kind, property):\n    \"\"\"Return the __property__ key for property of kind.\n\n    Args:\n      kind: kind whose key is requested.\n      property: property whose key is requested.\n\n    Returns:\n      The key for property of kind.\n    \"\"\"\n    return model.Key(Kind.KIND_NAME, kind, Property.KIND_NAME, property)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the kind name of a given key.", "response": "def key_to_kind(cls, key):\n    \"\"\"Return the kind specified by a given __property__ key.\n\n    Args:\n      key: key whose kind name is requested.\n\n    Returns:\n      The kind specified by key.\n    \"\"\"\n    if key.kind() == Kind.KIND_NAME:\n      return key.id()\n    else:\n      return key.parent().id()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef key_for_entity_group(cls, key):\n    return model.Key(cls.KIND_NAME, cls.ID, parent=key.root())", "response": "Return the key for the entity group containing key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_request(self, unused_request):\n    # Compare to the first half of toplevel() in context.py.\n    tasklets._state.clear_all_pending()\n    # Create and install a new context.\n    ctx = tasklets.make_default_context()\n    tasklets.set_context(ctx)", "response": "Called by Django before deciding which view to execute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_ctx_options(ctx_options, config_cls=ContextOptions):\n  if not ctx_options:\n    return None\n  for key in list(ctx_options):\n    translation = _OPTION_TRANSLATIONS.get(key)\n    if translation:\n      if translation in ctx_options:\n        raise ValueError('Cannot specify %s and %s at the same time' %\n                         (key, translation))\n      ctx_options[translation] = ctx_options.pop(key)\n  return config_cls(**ctx_options)", "response": "Helper function to construct a ContextOptions object from keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_cache_policy(self, func):\n    if func is None:\n      func = self.default_cache_policy\n    elif isinstance(func, bool):\n      func = lambda unused_key, flag=func: flag\n    self._cache_policy = func", "response": "Sets the context cache policy function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _use_cache(self, key, options=None):\n    flag = ContextOptions.use_cache(options)\n    if flag is None:\n      flag = self._cache_policy(key)\n    if flag is None:\n      flag = ContextOptions.use_cache(self._conn.config)\n    if flag is None:\n      flag = True\n    return flag", "response": "Return whether to use the context cache for this key."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the memcache policy function.", "response": "def set_memcache_policy(self, func):\n    \"\"\"Set the memcache policy function.\n\n    Args:\n      func: A function that accepts a Key instance as argument and returns\n        a bool indicating if it should be cached.  May be None.\n    \"\"\"\n    if func is None:\n      func = self.default_memcache_policy\n    elif isinstance(func, bool):\n      func = lambda unused_key, flag=func: flag\n    self._memcache_policy = func"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _use_memcache(self, key, options=None):\n    flag = ContextOptions.use_memcache(options)\n    if flag is None:\n      flag = self._memcache_policy(key)\n    if flag is None:\n      flag = ContextOptions.use_memcache(self._conn.config)\n    if flag is None:\n      flag = True\n    return flag", "response": "Return whether to use memcache for this key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef default_datastore_policy(key):\n    flag = None\n    if key is not None:\n      modelclass = model.Model._kind_map.get(key.kind())\n      if modelclass is not None:\n        policy = getattr(modelclass, '_use_datastore', None)\n        if policy is not None:\n          if isinstance(policy, bool):\n            flag = policy\n          else:\n            flag = policy(key)\n    return flag", "response": "Default datastore policy.\n\n    This defers to _use_datastore on the Model class.\n\n    Args:\n      key: Key instance.\n\n    Returns:\n      A bool or None."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_datastore_policy(self, func):\n    if func is None:\n      func = self.default_datastore_policy\n    elif isinstance(func, bool):\n      func = lambda unused_key, flag=func: flag\n    self._datastore_policy = func", "response": "Set the context datastore policy function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning whether to use the datastore for this key.", "response": "def _use_datastore(self, key, options=None):\n    \"\"\"Return whether to use the datastore for this key.\n\n    Args:\n      key: Key instance.\n      options: ContextOptions instance, or None.\n\n    Returns:\n      True if the datastore should be used, False otherwise.\n    \"\"\"\n    flag = ContextOptions.use_datastore(options)\n    if flag is None:\n      flag = self._datastore_policy(key)\n    if flag is None:\n      flag = ContextOptions.use_datastore(self._conn.config)\n    if flag is None:\n      flag = True\n    return flag"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef default_memcache_timeout_policy(key):\n    timeout = None\n    if key is not None and isinstance(key, model.Key):\n      modelclass = model.Model._kind_map.get(key.kind())\n      if modelclass is not None:\n        policy = getattr(modelclass, '_memcache_timeout', None)\n        if policy is not None:\n          if isinstance(policy, (int, long)):\n            timeout = policy\n          else:\n            timeout = policy(key)\n    return timeout", "response": "Default memcache timeout policy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the policy function for memcache timeout expiration.", "response": "def set_memcache_timeout_policy(self, func):\n    \"\"\"Set the policy function for memcache timeout (expiration).\n\n    Args:\n      func: A function that accepts a key instance as argument and returns\n        an integer indicating the desired memcache timeout.  May be None.\n\n    If the function returns 0 it implies the default timeout.\n    \"\"\"\n    if func is None:\n      func = self.default_memcache_timeout_policy\n    elif isinstance(func, (int, long)):\n      func = lambda unused_key, flag=func: flag\n    self._memcache_timeout_policy = func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the memcache timeout for this key.", "response": "def _get_memcache_timeout(self, key, options=None):\n    \"\"\"Return the memcache timeout (expiration) for this key.\"\"\"\n    timeout = ContextOptions.memcache_timeout(options)\n    if timeout is None:\n      timeout = self._memcache_timeout_policy(key)\n    if timeout is None:\n      timeout = ContextOptions.memcache_timeout(self._conn.config)\n    if timeout is None:\n      timeout = 0\n    return timeout"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a cached Model instance given the entity key if available.", "response": "def _load_from_cache_if_available(self, key):\n    \"\"\"Returns a cached Model instance given the entity key if available.\n\n    Args:\n      key: Key instance.\n\n    Returns:\n      A Model instance if the key exists in the cache.\n    \"\"\"\n    if key in self._cache:\n      entity = self._cache[key]  # May be None, meaning \"doesn't exist\".\n      if entity is None or entity._key == key:\n        # If entity's key didn't change later, it is ok.\n        # See issue 13.  http://goo.gl/jxjOP\n        raise tasklets.Return(entity)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a Model instance given the entity key.", "response": "def get(self, key, **ctx_options):\n    \"\"\"Return a Model instance given the entity key.\n\n    It will use the context cache if the cache policy for the given\n    key is enabled.\n\n    Args:\n      key: Key instance.\n      **ctx_options: Context options.\n\n    Returns:\n      A Model instance if the key exists in the datastore; None otherwise.\n    \"\"\"\n    options = _make_ctx_options(ctx_options)\n    use_cache = self._use_cache(key, options)\n    if use_cache:\n      self._load_from_cache_if_available(key)\n\n    use_datastore = self._use_datastore(key, options)\n    if (use_datastore and\n        isinstance(self._conn, datastore_rpc.TransactionalConnection)):\n      use_memcache = False\n    else:\n      use_memcache = self._use_memcache(key, options)\n    ns = key.namespace()\n    memcache_deadline = None  # Avoid worries about uninitialized variable.\n\n    if use_memcache:\n      mkey = self._memcache_prefix + key.urlsafe()\n      memcache_deadline = self._get_memcache_deadline(options)\n      mvalue = yield self.memcache_get(mkey, for_cas=use_datastore,\n                                       namespace=ns, use_cache=True,\n                                       deadline=memcache_deadline)\n      # A value may have appeared while yielding.\n      if use_cache:\n        self._load_from_cache_if_available(key)\n      if mvalue not in (_LOCKED, None):\n        cls = model.Model._lookup_model(key.kind(),\n                                        self._conn.adapter.default_model)\n        pb = entity_pb.EntityProto()\n\n        try:\n          pb.MergePartialFromString(mvalue)\n        except ProtocolBuffer.ProtocolBufferDecodeError:\n          logging.warning('Corrupt memcache entry found '\n                          'with key %s and namespace %s' % (mkey, ns))\n          mvalue = None\n        else:\n          entity = cls._from_pb(pb)\n          # Store the key on the entity since it wasn't written to memcache.\n          entity._key = key\n          if use_cache:\n            # Update in-memory cache.\n            self._cache[key] = entity\n          raise tasklets.Return(entity)\n\n      if mvalue is None and use_datastore:\n        yield self.memcache_set(mkey, _LOCKED, time=_LOCK_TIME, namespace=ns,\n                                use_cache=True, deadline=memcache_deadline)\n        yield self.memcache_gets(mkey, namespace=ns, use_cache=True,\n                                 deadline=memcache_deadline)\n\n    if not use_datastore:\n      # NOTE: Do not cache this miss.  In some scenarios this would\n      # prevent an app from working properly.\n      raise tasklets.Return(None)\n\n    if use_cache:\n      entity = yield self._get_batcher.add_once(key, options)\n    else:\n      entity = yield self._get_batcher.add(key, options)\n\n    if entity is not None:\n      if use_memcache and mvalue != _LOCKED:\n        # Don't serialize the key since it's already the memcache key.\n        pbs = entity._to_pb(set_key=False).SerializePartialToString()\n        # Don't attempt to write to memcache if too big.  Note that we\n        # use LBYL (\"look before you leap\") because a multi-value\n        # memcache operation would fail for all entities rather than\n        # for just the one that's too big.  (Also, the AutoBatcher\n        # class doesn't pass back exceptions very well.)\n        if len(pbs) <= memcache.MAX_VALUE_SIZE:\n          timeout = self._get_memcache_timeout(key, options)\n          # Don't use fire-and-forget -- for users who forget\n          # @ndb.toplevel, it's too painful to diagnose why their simple\n          # code using a single synchronous call doesn't seem to use\n          # memcache.  See issue 105.  http://goo.gl/JQZxp\n          yield self.memcache_cas(mkey, pbs, time=timeout, namespace=ns,\n                                  deadline=memcache_deadline)\n\n    if use_cache:\n      # Cache hit or miss.  NOTE: In this case it is okay to cache a\n      # miss; the datastore is the ultimate authority.\n      self._cache[key] = entity\n\n    raise tasklets.Return(entity)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef call_on_commit(self, callback):\n    if not self.in_transaction():\n      callback()\n    else:\n      self._on_commit_queue.append(callback)", "response": "Call a callback upon successful commit of a transaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Future for a nickname from an account.", "response": "def get_nickname(userid):\n  \"\"\"Return a Future for a nickname from an account.\"\"\"\n  account = yield get_account(userid)\n  if not account:\n    nickname = 'Unregistered'\n  else:\n    nickname = account.nickname or account.email\n  raise ndb.Return(nickname)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmark a task as done.", "response": "def mark_done(task_id):\n  \"\"\"Marks a task as done.\n\n  Args:\n    task_id: The integer id of the task to update.\n\n  Raises:\n    ValueError: if the requested task doesn't exist.\n  \"\"\"\n  task = Task.get_by_id(task_id)\n  if task is None:\n    raise ValueError('Task with id %d does not exist' % task_id)\n  task.done = True\n  task.put()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_tasks(tasks):\n  return ['%d : %s (%s)' % (task.key.id(),\n                            task.description,\n                            ('done' if task.done\n                             else 'created %s' % task.created))\n          for task in tasks]", "response": "Converts a list of tasks to a list of string representations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccepting a string command and performs an action.", "response": "def handle_command(command):\n  \"\"\"Accepts a string command and performs an action.\n\n  Args:\n    command: the command to run as a string.\n  \"\"\"\n  try:\n    cmds = command.split(None, 1)\n    cmd = cmds[0]\n    if cmd == 'new':\n      add_task(get_arg(cmds))\n    elif cmd == 'done':\n      mark_done(int(get_arg(cmds)))\n    elif cmd == 'list':\n      for task in format_tasks(list_tasks()):\n        print task\n    elif cmd == 'delete':\n      delete_task(int(get_arg(cmds)))\n    else:\n      print_usage()\n  except Exception, e:  # pylint: disable=broad-except\n    print e\n    print_usage()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_async(blob_key, **options):\n  if not isinstance(blob_key, (basestring, BlobKey)):\n    raise TypeError('Expected blob key, got %r' % (blob_key,))\n  rpc = blobstore.create_rpc(**options)\n  yield blobstore.delete_async(blob_key, rpc=rpc)", "response": "Async version of delete."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate upload URL for POST form.", "response": "def create_upload_url(success_path,\n                      max_bytes_per_blob=None,\n                      max_bytes_total=None,\n                      **options):\n  \"\"\"Create upload URL for POST form.\n\n  Args:\n    success_path: Path within application to call when POST is successful\n      and upload is complete.\n    max_bytes_per_blob: The maximum size in bytes that any one blob in the\n      upload can be or None for no maximum size.\n    max_bytes_total: The maximum size in bytes that the aggregate sizes of all\n      of the blobs in the upload can be or None for no maximum size.\n    **options: Options for create_rpc().\n\n  Returns:\n    The upload URL.\n\n  Raises:\n    TypeError: If max_bytes_per_blob or max_bytes_total are not integral types.\n    ValueError: If max_bytes_per_blob or max_bytes_total are not\n      positive values.\n  \"\"\"\n  fut = create_upload_url_async(success_path,\n                                max_bytes_per_blob=max_bytes_per_blob,\n                                max_bytes_total=max_bytes_total,\n                                **options)\n  return fut.get_result()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_blob_info(field_storage):\n  if field_storage is None:\n    return None\n\n  field_name = field_storage.name\n\n  def get_value(dct, name):\n    value = dct.get(name, None)\n    if value is None:\n      raise BlobInfoParseError(\n          'Field %s has no %s.' % (field_name, name))\n    return value\n\n  filename = get_value(field_storage.disposition_options, 'filename')\n  blob_key_str = get_value(field_storage.type_options, 'blob-key')\n  blob_key = BlobKey(blob_key_str)\n\n  upload_content = email.message_from_file(field_storage.file)\n  content_type = get_value(upload_content, 'content-type')\n  size = get_value(upload_content, 'content-length')\n  creation_string = get_value(upload_content, UPLOAD_INFO_CREATION_HEADER)\n  md5_hash_encoded = get_value(upload_content, 'content-md5')\n  md5_hash = base64.urlsafe_b64decode(md5_hash_encoded)\n\n  try:\n    size = int(size)\n  except (TypeError, ValueError):\n    raise BlobInfoParseError(\n        '%s is not a valid value for %s size.' % (size, field_name))\n\n  try:\n    creation = blobstore._parse_creation(creation_string, field_name)\n  except blobstore._CreationFormatError, err:\n    raise BlobInfoParseError(str(err))\n\n  return BlobInfo(id=blob_key_str,\n                  content_type=content_type,\n                  creation=creation,\n                  filename=filename,\n                  size=size,\n                  md5_hash=md5_hash,\n                 )", "response": "Parse a BlobInfo record from a file upload field_storage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching data for a blob.", "response": "def fetch_data(blob, start_index, end_index, **options):\n  \"\"\"Fetch data for blob.\n\n  Fetches a fragment of a blob up to MAX_BLOB_FETCH_SIZE in length.  Attempting\n  to fetch a fragment that extends beyond the boundaries of the blob will return\n  the amount of data from start_index until the end of the blob, which will be\n  a smaller size than requested.  Requesting a fragment which is entirely\n  outside the boundaries of the blob will return empty string.  Attempting\n  to fetch a negative index will raise an exception.\n\n  Args:\n    blob: BlobInfo, BlobKey, str or unicode representation of BlobKey of\n      blob to fetch data from.\n    start_index: Start index of blob data to fetch.  May not be negative.\n    end_index: End index (inclusive) of blob data to fetch.  Must be\n      >= start_index.\n    **options: Options for create_rpc().\n\n  Returns:\n    str containing partial data of blob.  If the indexes are legal but outside\n    the boundaries of the blob, will return empty string.\n\n  Raises:\n    TypeError if start_index or end_index are not indexes.  Also when blob\n      is not a string, BlobKey or BlobInfo.\n    DataIndexOutOfRangeError when start_index < 0 or end_index < start_index.\n    BlobFetchSizeTooLargeError when request blob fragment is larger than\n      MAX_BLOB_FETCH_SIZE.\n    BlobNotFoundError when blob does not exist.\n  \"\"\"\n  fut = fetch_data_async(blob, start_index, end_index, **options)\n  return fut.get_result()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a BlobInfo entity by blob key.", "response": "def get(cls, blob_key, **ctx_options):\n    \"\"\"Retrieve a BlobInfo by key.\n\n    Args:\n      blob_key: A blob key.  This may be a str, unicode or BlobKey instance.\n      **ctx_options: Context options for Model().get_by_id().\n\n    Returns:\n      A BlobInfo entity associated with the provided key,  If there was\n      no such entity, returns None.\n    \"\"\"\n    fut = cls.get_async(blob_key, **ctx_options)\n    return fut.get_result()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_async(cls, blob_key, **ctx_options):\n    if not isinstance(blob_key, (BlobKey, basestring)):\n      raise TypeError('Expected blob key, got %r' % (blob_key,))\n    if 'parent' in ctx_options:\n      raise TypeError('Parent is not supported')\n    return cls.get_by_id_async(str(blob_key), **ctx_options)", "response": "Async version of get ()."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_multi_async(cls, blob_keys, **ctx_options):\n    for blob_key in blob_keys:\n      if not isinstance(blob_key, (BlobKey, basestring)):\n        raise TypeError('Expected blob key, got %r' % (blob_key,))\n    if 'parent' in ctx_options:\n      raise TypeError('Parent is not supported')\n    blob_key_strs = map(str, blob_keys)\n    keys = [model.Key(BLOB_INFO_KIND, id) for id in blob_key_strs]\n    return model.get_multi_async(keys, **ctx_options)", "response": "Async version of get_multi."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self, **options):\n    fut = delete_async(self.key(), **options)\n    fut.get_result()", "response": "Permanently delete this blob from Blobstore."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfill the internal buffer with the given size.", "response": "def __fill_buffer(self, size=0):\n    \"\"\"Fills the internal buffer.\n\n    Args:\n      size: Number of bytes to read. Will be clamped to\n        [self.__buffer_size, MAX_BLOB_FETCH_SIZE].\n    \"\"\"\n    read_size = min(max(size, self.__buffer_size), MAX_BLOB_FETCH_SIZE)\n\n    self.__buffer = fetch_data(self.__blob_key, self.__position,\n                               self.__position + read_size - 1)\n    self.__buffer_position = 0\n    self.__eof = len(self.__buffer) < read_size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the BlobInfo for this file.", "response": "def blob_info(self):\n    \"\"\"Returns the BlobInfo for this file.\"\"\"\n    if not self.__blob_info:\n      self.__blob_info = BlobInfo.get(self.__blob_key)\n    return self.__blob_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new Connection object with the right adapter.", "response": "def make_connection(config=None, default_model=None,\n                    _api_version=datastore_rpc._DATASTORE_V3,\n                    _id_resolver=None):\n  \"\"\"Create a new Connection object with the right adapter.\n\n  Optionally you can pass in a datastore_rpc.Configuration object.\n  \"\"\"\n  return datastore_rpc.Connection(\n      adapter=ModelAdapter(default_model, id_resolver=_id_resolver),\n      config=config,\n      _api_version=_api_version)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _unpack_user(v):\n  uv = v.uservalue()\n  email = unicode(uv.email().decode('utf-8'))\n  auth_domain = unicode(uv.auth_domain().decode('utf-8'))\n  obfuscated_gaiaid = uv.obfuscated_gaiaid().decode('utf-8')\n  obfuscated_gaiaid = unicode(obfuscated_gaiaid)\n\n  federated_identity = None\n  if uv.has_federated_identity():\n    federated_identity = unicode(\n        uv.federated_identity().decode('utf-8'))\n\n  value = users.User(email=email,\n                     _auth_domain=auth_domain,\n                     _user_id=obfuscated_gaiaid,\n                     federated_identity=federated_identity)\n  return value", "response": "Internal helper to unpack a User value from a protocol buffer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _date_to_datetime(value):\n  if not isinstance(value, datetime.date):\n    raise TypeError('Cannot convert to datetime expected date value; '\n                    'received %s' % value)\n  return datetime.datetime(value.year, value.month, value.day)", "response": "Convert a date object to a datetime object for Cloud Datastore storage."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _time_to_datetime(value):\n  if not isinstance(value, datetime.time):\n    raise TypeError('Cannot convert to datetime expected time value; '\n                    'received %s' % value)\n  return datetime.datetime(1970, 1, 1,\n                           value.hour, value.minute, value.second,\n                           value.microsecond)", "response": "Convert a time to a datetime for Cloud Datastore storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transactional_tasklet(func, args, kwds, **options):\n  from . import tasklets\n  func = tasklets.tasklet(func)\n  return transactional_async.wrapped_decorator(func, args, kwds, **options)", "response": "A decorator that will be used to wrap a function in a tasklet."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates all descendants to a specified value.", "response": "def _set(self, value):\n    \"\"\"Updates all descendants to a specified value.\"\"\"\n    if self.__is_parent_node():\n      for child in self.__sub_counters.itervalues():\n        child._set(value)\n    else:\n      self.__counter = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _comparison(self, op, value):\n    # NOTE: This is also used by query.gql().\n    if not self._indexed:\n      raise datastore_errors.BadFilterError(\n          'Cannot query for unindexed property %s' % self._name)\n    from .query import FilterNode  # Import late to avoid circular imports.\n    if value is not None:\n      value = self._do_validate(value)\n      value = self._call_to_base_type(value)\n      value = self._datastore_type(value)\n    return FilterNode(self._name, op, value)", "response": "Internal helper for comparison operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls all validations on the value.", "response": "def _do_validate(self, value):\n    \"\"\"Call all validations on the value.\n\n    This calls the most derived _validate() method(s), then the custom\n    validator function, and then checks the choices.  It returns the\n    value, possibly modified in an idempotent way, or raises an\n    exception.\n\n    Note that this does not call all composable _validate() methods.\n    It only calls _validate() methods up to but not including the\n    first _to_base_type() method, when the MRO is traversed looking\n    for _validate() and _to_base_type() methods.  (IOW if a class\n    defines both _validate() and _to_base_type(), its _validate()\n    is called and then the search is aborted.)\n\n    Note that for a repeated Property this function should be called\n    for each item in the list, not for the list as a whole.\n    \"\"\"\n    if isinstance(value, _BaseValue):\n      return value\n    value = self._call_shallow_validation(value)\n    if self._validator is not None:\n      newvalue = self._validator(self, value)\n      if newvalue is not None:\n        value = newvalue\n    if self._choices is not None:\n      if value not in self._choices:\n        raise datastore_errors.BadValueError(\n            'Value %r for property %s is not an allowed choice' %\n            (value, self._name))\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fix_up(self, cls, code_name):\n    self._code_name = code_name\n    if self._name is None:\n      self._name = code_name", "response": "Internal helper to tell the property its name and set the code_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_value(self, entity, value):\n    if entity._projection:\n      raise ReadonlyPropertyError(\n          'You cannot set property values of a projection entity')\n    if self._repeated:\n      if not isinstance(value, (list, tuple, set, frozenset)):\n        raise datastore_errors.BadValueError('Expected list or tuple, got %r' %\n                                             (value,))\n      value = [self._do_validate(v) for v in value]\n    else:\n      if value is not None:\n        value = self._do_validate(value)\n    self._store_value(entity, value)", "response": "Internal helper to set a value in an entity for a Property."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nliking _get_base_value but always returns a list.", "response": "def _get_base_value_unwrapped_as_list(self, entity):\n    \"\"\"Like _get_base_value(), but always returns a list.\n\n    Returns:\n      A new list of unwrapped base values.  For an unrepeated\n      property, if the value is missing or None, returns [None]; for a\n      repeated property, if the original value is missing or None or\n      empty, returns [].\n    \"\"\"\n    wrapped = self._get_base_value(entity)\n    if self._repeated:\n      if wrapped is None:\n        return []\n      assert isinstance(wrapped, list)\n      return [w.b_val for w in wrapped]\n    else:\n      if wrapped is None:\n        return [None]\n      assert isinstance(wrapped, _BaseValue)\n      return [wrapped.b_val]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls _from_base_type() if necessary.", "response": "def _opt_call_from_base_type(self, value):\n    \"\"\"Call _from_base_type() if necessary.\n\n    If the value is a _BaseValue instance, unwrap it and call all\n    _from_base_type() methods.  Otherwise, return the value\n    unchanged.\n    \"\"\"\n    if isinstance(value, _BaseValue):\n      value = self._call_from_base_type(value.b_val)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _opt_call_to_base_type(self, value):\n    if not isinstance(value, _BaseValue):\n      value = _BaseValue(self._call_to_base_type(value))\n    return value", "response": "Optimize the value to be a _BaseValue instance if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _call_from_base_type(self, value):\n    methods = self._find_methods('_from_base_type', reverse=True)\n    call = self._apply_list(methods)\n    return call(value)", "response": "Call all _from_base_type() methods on the value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _call_to_base_type(self, value):\n    methods = self._find_methods('_validate', '_to_base_type')\n    call = self._apply_list(methods)\n    return call(value)", "response": "Call all _validate and _to_base_type methods on the value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling the _validate methods that can be called with the given value.", "response": "def _call_shallow_validation(self, value):\n    \"\"\"Call the initial set of _validate() methods.\n\n    This is similar to _call_to_base_type() except it only calls\n    those _validate() methods that can be called without needing to\n    call _to_base_type().\n\n    An example: suppose the class hierarchy is A -> B -> C ->\n    Property, and suppose A defines _validate() only, but B and C\n    define _validate() and _to_base_type().  The full list of\n    methods called by _call_to_base_type() is::\n\n      A._validate()\n      B._validate()\n      B._to_base_type()\n      C._validate()\n      C._to_base_type()\n\n    This method will call A._validate() and B._validate() but not the\n    others.\n    \"\"\"\n    methods = []\n    for method in self._find_methods('_validate', '_to_base_type'):\n      if method.__name__ != '_validate':\n        break\n      methods.append(method)\n    call = self._apply_list(methods)\n    return call(value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _find_methods(cls, *names, **kwds):\n    reverse = kwds.pop('reverse', False)\n    assert not kwds, repr(kwds)\n    cache = cls.__dict__.get('_find_methods_cache')\n    if cache:\n      hit = cache.get(names)\n      if hit is not None:\n        return hit\n    else:\n      cls._find_methods_cache = cache = {}\n    methods = []\n    for c in cls.__mro__:\n      for name in names:\n        method = c.__dict__.get(name)\n        if method is not None:\n          methods.append(method)\n    if reverse:\n      methods.reverse()\n    cache[names] = methods\n    return methods", "response": "Compute a list of composable methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _apply_list(self, methods):\n    def call(value):\n      for method in methods:\n        newvalue = method(self, value)\n        if newvalue is not None:\n          value = newvalue\n      return value\n    return call", "response": "Returns a single callable that applies a list of methods to a value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _apply_to_values(self, entity, function):\n    value = self._retrieve_value(entity, self._default)\n    if self._repeated:\n      if value is None:\n        value = []\n        self._store_value(entity, value)\n      else:\n        value[:] = map(function, value)\n    else:\n      if value is not None:\n        newvalue = function(value)\n        if newvalue is not None and newvalue is not value:\n          self._store_value(entity, newvalue)\n          value = newvalue\n    return value", "response": "Applies a function to the property value and returns the value or list of values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_value(self, entity):\n    if entity._projection:\n      if self._name not in entity._projection:\n        raise UnprojectedPropertyError(\n            'Property %s is not in the projection' % (self._name,))\n    return self._get_user_value(entity)", "response": "Internal helper to get the value for this Property from an entity."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _serialize(self, entity, pb, prefix='', parent_repeated=False,\n                 projection=None):\n    \"\"\"Internal helper to serialize this property to a protocol buffer.\n\n    Subclasses may override this method.\n\n    Args:\n      entity: The entity, a Model (subclass) instance.\n      pb: The protocol buffer, an EntityProto instance.\n      prefix: Optional name prefix used for StructuredProperty\n        (if present, must end in '.').\n      parent_repeated: True if the parent (or an earlier ancestor)\n        is a repeated Property.\n      projection: A list or tuple of strings representing the projection for\n        the model instance, or None if the instance is not a projection.\n    \"\"\"\n    values = self._get_base_value_unwrapped_as_list(entity)\n    name = prefix + self._name\n    if projection and name not in projection:\n      return\n\n    if self._indexed:\n      create_prop = lambda: pb.add_property()\n    else:\n      create_prop = lambda: pb.add_raw_property()\n\n    if self._repeated and not values and self._write_empty_list:\n      # We want to write the empty list\n      p = create_prop()\n      p.set_name(name)\n      p.set_multiple(False)\n      p.set_meaning(entity_pb.Property.EMPTY_LIST)\n      p.mutable_value()\n    else:\n      # We write a list, or a single property\n      for val in values:\n        p = create_prop()\n        p.set_name(name)\n        p.set_multiple(self._repeated or parent_repeated)\n        v = p.mutable_value()\n        if val is not None:\n          self._db_set_value(v, p, val)\n          if projection:\n            # Projected properties have the INDEX_VALUE meaning and only contain\n            # the original property's name and value.\n            new_p = entity_pb.Property()\n            new_p.set_name(p.name())\n            new_p.set_meaning(entity_pb.Property.INDEX_VALUE)\n            new_p.set_multiple(False)\n            new_p.mutable_value().CopyFrom(v)\n            p.CopyFrom(new_p)", "response": "Internal helper to serialize this property to a protocol buffer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _deserialize(self, entity, p, unused_depth=1):\n    if p.meaning() == entity_pb.Property.EMPTY_LIST:\n      self._store_value(entity, [])\n      return\n\n    val = self._db_get_value(p.value(), p)\n    if val is not None:\n      val = _BaseValue(val)\n\n    # TODO: replace the remainder of the function with the following commented\n    # out code once its feasible to make breaking changes such as not calling\n    # _store_value().\n\n    # if self._repeated:\n    #   entity._values.setdefault(self._name, []).append(val)\n    # else:\n    #   entity._values[self._name] = val\n\n    if self._repeated:\n      if self._has_value(entity):\n        value = self._retrieve_value(entity)\n        assert isinstance(value, list), repr(value)\n        value.append(val)\n      else:\n        # We promote single values to lists if we are a list property\n        value = [val]\n    else:\n      value = val\n    self._store_value(entity, value)", "response": "Internal helper to deserialize this property from a protocol buffer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_property(self, rest=None, require_indexed=True):\n    if require_indexed and not self._indexed:\n      raise InvalidPropertyError('Property is unindexed %s' % self._name)\n    if rest:\n      raise InvalidPropertyError('Referencing subproperty %s.%s '\n                                 'but %s is not a structured property' %\n                                 (self._name, rest, self._name))", "response": "Internal helper to check this property for specific requirements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _set_value(self, entity, value):\n    if value is not None:\n      value = _validate_key(value, entity=entity)\n      value = entity._validate_key(value)\n    entity._entity_key = value", "response": "Setter for key attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noverride _get_value to not raise UnprojectedPropertyError.", "response": "def _get_value(self, entity):\n    \"\"\"Override _get_value() to *not* raise UnprojectedPropertyError.\"\"\"\n    value = self._get_user_value(entity)\n    if value is None and entity._projection:\n      # Invoke super _get_value() to raise the proper exception.\n      return super(StructuredProperty, self)._get_value(entity)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check_property(self, rest=None, require_indexed=True):\n    if not rest:\n      raise InvalidPropertyError(\n          'Structured property %s requires a subproperty' % self._name)\n    self._modelclass._check_properties([rest], require_indexed=require_indexed)", "response": "Override for Property. _check_property."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_initialized(self):\n    baddies = self._find_uninitialized()\n    if baddies:\n      raise datastore_errors.BadValueError(\n          'Entity has uninitialized properties: %s' % ', '.join(baddies))", "response": "Internal helper to check for uninitialized properties. Raises a BadValueError if it finds any."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _reset_kind_map(cls):\n    # Preserve \"system\" kinds, like __namespace__\n    keep = {}\n    for name, value in cls._kind_map.iteritems():\n      if name.startswith('__') and name.endswith('__'):\n        keep[name] = value\n    cls._kind_map.clear()\n    cls._kind_map.update(keep)", "response": "Clear the kind map. Useful for testing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _lookup_model(cls, kind, default_model=None):\n    modelclass = cls._kind_map.get(kind, default_model)\n    if modelclass is None:\n      raise KindError(\n          \"No model class found for kind '%s'. Did you forget to import it?\" %\n          kind)\n    return modelclass", "response": "Lookup the model class for the given kind."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompare two entities of the same class excluding keys.", "response": "def _equivalent(self, other):\n    \"\"\"Compare two entities of the same class, excluding keys.\"\"\"\n    if other.__class__ is not self.__class__:  # TODO: What about subclasses?\n      raise NotImplementedError('Cannot compare different model classes. '\n                                '%s is not %s' % (self.__class__.__name__,\n                                                  other.__class_.__name__))\n    if set(self._projection) != set(other._projection):\n      return False\n    # It's all about determining inequality early.\n    if len(self._properties) != len(other._properties):\n      return False  # Can only happen for Expandos.\n    my_prop_names = set(self._properties.iterkeys())\n    their_prop_names = set(other._properties.iterkeys())\n    if my_prop_names != their_prop_names:\n      return False  # Again, only possible for Expandos.\n    if self._projection:\n      my_prop_names = set(self._projection)\n    for name in my_prop_names:\n      if '.' in name:\n        name, _ = name.split('.', 1)\n      my_value = self._properties[name]._get_value(self)\n      their_value = other._properties[name]._get_value(other)\n      if my_value != their_value:\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _to_pb(self, pb=None, allow_partial=False, set_key=True):\n    if not allow_partial:\n      self._check_initialized()\n    if pb is None:\n      pb = entity_pb.EntityProto()\n\n    if set_key:\n      # TODO: Move the key stuff into ModelAdapter.entity_to_pb()?\n      self._key_to_pb(pb)\n\n    for unused_name, prop in sorted(self._properties.iteritems()):\n      prop._serialize(self, pb, projection=self._projection)\n\n    return pb", "response": "Internal helper to turn an entity into an EntityProto protobuf."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _from_pb(cls, pb, set_key=True, ent=None, key=None):\n    if not isinstance(pb, entity_pb.EntityProto):\n      raise TypeError('pb must be a EntityProto; received %r' % pb)\n    if ent is None:\n      ent = cls()\n\n    # A key passed in overrides a key in the pb.\n    if key is None and pb.key().path().element_size():\n      key = Key(reference=pb.key())\n    # If set_key is not set, skip a trivial incomplete key.\n    if key is not None and (set_key or key.id() or key.parent()):\n      ent._key = key\n\n    # NOTE(darke): Keep a map from (indexed, property name) to the property.\n    # This allows us to skip the (relatively) expensive call to\n    # _get_property_for for repeated fields.\n    _property_map = {}\n    projection = []\n    for indexed, plist in ((True, pb.property_list()),\n                           (False, pb.raw_property_list())):\n      for p in plist:\n        if p.meaning() == entity_pb.Property.INDEX_VALUE:\n          projection.append(p.name())\n        property_map_key = (p.name(), indexed)\n        if property_map_key not in _property_map:\n          _property_map[property_map_key] = ent._get_property_for(p, indexed)\n        _property_map[property_map_key]._deserialize(ent, p)\n\n    ent._set_projection(projection)\n    return ent", "response": "Internal helper to create an entity from an EntityProto protobuf."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_property_for(self, p, indexed=True, depth=0):\n    parts = p.name().split('.')\n    if len(parts) <= depth:\n      # Apparently there's an unstructured value here.\n      # Assume it is a None written for a missing value.\n      # (It could also be that a schema change turned an unstructured\n      # value into a structured one.  In that case, too, it seems\n      # better to return None than to return an unstructured value,\n      # since the latter doesn't match the current schema.)\n      return None\n    next = parts[depth]\n    prop = self._properties.get(next)\n    if prop is None:\n      prop = self._fake_property(p, next, indexed)\n    return prop", "response": "Internal helper to get the Property for a protobuf - level property."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _clone_properties(self):\n    cls = self.__class__\n    if self._properties is cls._properties:\n      self._properties = dict(cls._properties)", "response": "Internal helper to clone self. _properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _fake_property(self, p, next, indexed=True):\n    self._clone_properties()\n    if p.name() != next and not p.name().endswith('.' + next):\n      prop = StructuredProperty(Expando, next)\n      prop._store_value(self, _BaseValue(Expando()))\n    else:\n      compressed = p.meaning_uri() == _MEANING_URI_COMPRESSED\n      prop = GenericProperty(next,\n                             repeated=p.multiple(),\n                             indexed=indexed,\n                             compressed=compressed)\n    prop._code_name = next\n    self._properties[prop._name] = prop\n    return prop", "response": "Internal helper to create a fake Property."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dict containing the entity s property values.", "response": "def _to_dict(self, include=None, exclude=None):\n    \"\"\"Return a dict containing the entity's property values.\n\n    Args:\n      include: Optional set of property names to include, default all.\n      exclude: Optional set of property names to skip, default none.\n        A name contained in both include and exclude is excluded.\n    \"\"\"\n    if (include is not None and\n        not isinstance(include, (list, tuple, set, frozenset))):\n      raise TypeError('include should be a list, tuple or set')\n    if (exclude is not None and\n        not isinstance(exclude, (list, tuple, set, frozenset))):\n      raise TypeError('exclude should be a list, tuple or set')\n    values = {}\n    for prop in self._properties.itervalues():\n      name = prop._code_name\n      if include is not None and name not in include:\n        continue\n      if exclude is not None and name in exclude:\n        continue\n      try:\n        values[name] = prop._get_for_dict(self)\n      except UnprojectedPropertyError:\n        pass  # Ignore unprojected properties rather than failing.\n    return values"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfixing up the properties of a given class by calling their _fix_up method.", "response": "def _fix_up_properties(cls):\n    \"\"\"Fix up the properties by calling their _fix_up() method.\n\n    Note: This is called by MetaModel, but may also be called manually\n    after dynamically updating a model class.\n    \"\"\"\n    # Verify that _get_kind() returns an 8-bit string.\n    kind = cls._get_kind()\n    if not isinstance(kind, basestring):\n      raise KindError('Class %s defines a _get_kind() method that returns '\n                      'a non-string (%r)' % (cls.__name__, kind))\n    if not isinstance(kind, str):\n      try:\n        kind = kind.encode('ascii')  # ASCII contents is okay.\n      except UnicodeEncodeError:\n        raise KindError('Class %s defines a _get_kind() method that returns '\n                        'a Unicode string (%r); please encode using utf-8' %\n                        (cls.__name__, kind))\n    cls._properties = {}  # Map of {name: Property}\n    if cls.__module__ == __name__:  # Skip the classes in *this* file.\n      return\n    for name in set(dir(cls)):\n      attr = getattr(cls, name, None)\n      if isinstance(attr, ModelAttribute) and not isinstance(attr, ModelKey):\n        if name.startswith('_'):\n          raise TypeError('ModelAttribute %s cannot begin with an underscore '\n                          'character. _ prefixed attributes are reserved for '\n                          'temporary Model instance values.' % name)\n        attr._fix_up(cls, name)\n        if isinstance(attr, Property):\n          if (attr._repeated or\n              (isinstance(attr, StructuredProperty) and\n               attr._modelclass._has_repeated)):\n            cls._has_repeated = True\n          cls._properties[attr._name] = attr\n    cls._update_kind_map()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a Query object for this class.", "response": "def _query(cls, *args, **kwds):\n    \"\"\"Create a Query object for this class.\n\n    Args:\n      distinct: Optional bool, short hand for group_by = projection.\n      *args: Used to apply an initial filter\n      **kwds: are passed to the Query() constructor.\n\n    Returns:\n      A Query object.\n    \"\"\"\n    # Validating distinct.\n    if 'distinct' in kwds:\n      if 'group_by' in kwds:\n        raise TypeError(\n            'cannot use distinct= and group_by= at the same time')\n      projection = kwds.get('projection')\n      if not projection:\n        raise TypeError(\n            'cannot use distinct= without projection=')\n      if kwds.pop('distinct'):\n        kwds['group_by'] = projection\n\n    # TODO: Disallow non-empty args and filter=.\n    from .query import Query  # Import late to avoid circular imports.\n    qry = Query(kind=cls._get_kind(), **kwds)\n    qry = qry.filter(*cls._default_filters())\n    qry = qry.filter(*args)\n    return qry"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a GQL query.", "response": "def _gql(cls, query_string, *args, **kwds):\n    \"\"\"Run a GQL query.\"\"\"\n    from .query import gql  # Import late to avoid circular imports.\n    return gql('SELECT * FROM %s %s' % (cls._class_name(), query_string),\n               *args, **kwds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites this entity to Cloud Datastore.", "response": "def _put_async(self, **ctx_options):\n    \"\"\"Write this entity to Cloud Datastore.\n\n    This is the asynchronous version of Model._put().\n    \"\"\"\n    if self._projection:\n      raise datastore_errors.BadRequestError('Cannot put a partial entity')\n    from . import tasklets\n    ctx = tasklets.get_context()\n    self._prepare_for_put()\n    if self._key is None:\n      self._key = Key(self._get_kind(), None)\n    self._pre_put_hook()\n    fut = ctx.put(self, **ctx_options)\n    post_hook = self._post_put_hook\n    if not self._is_default_hook(Model._default_post_put_hook, post_hook):\n      fut.add_immediate_callback(post_hook, fut)\n    return fut"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _allocate_ids(cls, size=None, max=None, parent=None, **ctx_options):\n    return cls._allocate_ids_async(size=size, max=max, parent=parent,\n                                   **ctx_options).get_result()", "response": "Allocates a range of key IDs for this model class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nallocating a range of key IDs for this model class.", "response": "def _allocate_ids_async(cls, size=None, max=None, parent=None,\n                          **ctx_options):\n    \"\"\"Allocates a range of key IDs for this model class.\n\n    This is the asynchronous version of Model._allocate_ids().\n    \"\"\"\n    from . import tasklets\n    ctx = tasklets.get_context()\n    cls._pre_allocate_ids_hook(size, max, parent)\n    key = Key(cls._get_kind(), None, parent=parent)\n    fut = ctx.allocate_ids(key, size=size, max=max, **ctx_options)\n    post_hook = cls._post_allocate_ids_hook\n    if not cls._is_default_hook(Model._default_post_allocate_ids_hook,\n                                post_hook):\n      fut.add_immediate_callback(post_hook, size, max, parent, fut)\n    return fut"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_by_id(cls, id, parent=None, **ctx_options):\n    return cls._get_by_id_async(id, parent=parent, **ctx_options).get_result()", "response": "Returns an instance of Model class by ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an instance of Model class by ID.", "response": "def _get_by_id_async(cls, id, parent=None, app=None, namespace=None,\n                       **ctx_options):\n    \"\"\"Returns an instance of Model class by ID (and app, namespace).\n\n    This is the asynchronous version of Model._get_by_id().\n    \"\"\"\n    key = Key(cls._get_kind(), id, parent=parent, app=app, namespace=namespace)\n    return key.get_async(**ctx_options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_default_hook(default_hook, hook):\n    if not hasattr(default_hook, '__call__'):\n      raise TypeError('Default hooks for ndb.model.Model must be callable')\n    if not hasattr(hook, '__call__'):\n      raise TypeError('Hooks must be callable')\n    return default_hook.im_func is hook.im_func", "response": "Checks whether a specific hook is in its default state."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing a Reference from a list of pairs.", "response": "def _ConstructReference(cls, pairs=None, flat=None,\n                        reference=None, serialized=None, urlsafe=None,\n                        app=None, namespace=None, parent=None):\n  \"\"\"Construct a Reference; the signature is the same as for Key.\"\"\"\n  if cls is not Key:\n    raise TypeError('Cannot construct Key reference on non-Key class; '\n                    'received %r' % cls)\n  if (bool(pairs) + bool(flat) + bool(reference) + bool(serialized) +\n      bool(urlsafe)) != 1:\n    raise TypeError('Cannot construct Key reference from incompatible keyword '\n                    'arguments.')\n  if flat or pairs:\n    if flat:\n      if len(flat) % 2:\n        raise TypeError('_ConstructReference() must have an even number of '\n                        'positional arguments.')\n      pairs = [(flat[i], flat[i + 1]) for i in xrange(0, len(flat), 2)]\n    elif parent is not None:\n      pairs = list(pairs)\n    if not pairs:\n      raise TypeError('Key references must consist of at least one pair.')\n    if parent is not None:\n      if not isinstance(parent, Key):\n        raise datastore_errors.BadValueError(\n            'Expected Key instance, got %r' % parent)\n      pairs[:0] = parent.pairs()\n      if app:\n        if app != parent.app():\n          raise ValueError('Cannot specify a different app %r '\n                           'than the parent app %r' %\n                           (app, parent.app()))\n      else:\n        app = parent.app()\n      if namespace is not None:\n        if namespace != parent.namespace():\n          raise ValueError('Cannot specify a different namespace %r '\n                           'than the parent namespace %r' %\n                           (namespace, parent.namespace()))\n      else:\n        namespace = parent.namespace()\n    reference = _ReferenceFromPairs(pairs, app=app, namespace=namespace)\n  else:\n    if parent is not None:\n      raise TypeError('Key reference cannot be constructed when the parent '\n                      'argument is combined with either reference, serialized '\n                      'or urlsafe arguments.')\n    if urlsafe:\n      serialized = _DecodeUrlSafe(urlsafe)\n    if serialized:\n      reference = _ReferenceFromSerialized(serialized)\n    if not reference.path().element_size():\n      raise RuntimeError('Key reference has no path or elements (%r, %r, %r).'\n                         % (urlsafe, serialized, str(reference)))\n    # TODO: ensure that each element has a type and either an id or a name\n    if not serialized:\n      reference = _ReferenceFromReference(reference)\n    # You needn't specify app= or namespace= together with reference=,\n    # serialized= or urlsafe=, but if you do, their values must match\n    # what is already in the reference.\n    if app is not None:\n      ref_app = reference.app()\n      if app != ref_app:\n        raise RuntimeError('Key reference constructed uses a different app %r '\n                           'than the one specified %r' %\n                           (ref_app, app))\n    if namespace is not None:\n      ref_namespace = reference.name_space()\n      if namespace != ref_namespace:\n        raise RuntimeError('Key reference constructed uses a different '\n                           'namespace %r than the one specified %r' %\n                           (ref_namespace, namespace))\n  return reference"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ReferenceFromPairs(pairs, reference=None, app=None, namespace=None):\n  if reference is None:\n    reference = entity_pb.Reference()\n  path = reference.mutable_path()\n  last = False\n  for kind, idorname in pairs:\n    if last:\n      raise datastore_errors.BadArgumentError(\n          'Incomplete Key entry must be last')\n    t = type(kind)\n    if t is str:\n      pass\n    elif t is unicode:\n      kind = kind.encode('utf8')\n    else:\n      if issubclass(t, type):\n        # Late import to avoid cycles.\n        from .model import Model\n        modelclass = kind\n        if not issubclass(modelclass, Model):\n          raise TypeError('Key kind must be either a string or subclass of '\n                          'Model; received %r' % modelclass)\n        kind = modelclass._get_kind()\n        t = type(kind)\n      if t is str:\n        pass\n      elif t is unicode:\n        kind = kind.encode('utf8')\n      elif issubclass(t, str):\n        pass\n      elif issubclass(t, unicode):\n        kind = kind.encode('utf8')\n      else:\n        raise TypeError('Key kind must be either a string or subclass of Model;'\n                        ' received %r' % kind)\n    # pylint: disable=superfluous-parens\n    if not (1 <= len(kind) <= _MAX_KEYPART_BYTES):\n      raise ValueError('Key kind string must be a non-empty string up to %i'\n                       'bytes; received %s' %\n                       (_MAX_KEYPART_BYTES, kind))\n    elem = path.add_element()\n    elem.set_type(kind)\n    t = type(idorname)\n    if t is int or t is long:\n      # pylint: disable=superfluous-parens\n      if not (1 <= idorname < _MAX_LONG):\n        raise ValueError('Key id number is too long; received %i' % idorname)\n      elem.set_id(idorname)\n    elif t is str:\n      # pylint: disable=superfluous-parens\n      if not (1 <= len(idorname) <= _MAX_KEYPART_BYTES):\n        raise ValueError('Key name strings must be non-empty strings up to %i '\n                         'bytes; received %s' %\n                         (_MAX_KEYPART_BYTES, idorname))\n      elem.set_name(idorname)\n    elif t is unicode:\n      idorname = idorname.encode('utf8')\n      # pylint: disable=superfluous-parens\n      if not (1 <= len(idorname) <= _MAX_KEYPART_BYTES):\n        raise ValueError('Key name unicode strings must be non-empty strings up'\n                         ' to %i bytes; received %s' %\n                         (_MAX_KEYPART_BYTES, idorname))\n      elem.set_name(idorname)\n    elif idorname is None:\n      last = True\n    elif issubclass(t, (int, long)):\n      # pylint: disable=superfluous-parens\n      if not (1 <= idorname < _MAX_LONG):\n        raise ValueError('Key id number is too long; received %i' % idorname)\n      elem.set_id(idorname)\n    elif issubclass(t, basestring):\n      if issubclass(t, unicode):\n        idorname = idorname.encode('utf8')\n      # pylint: disable=superfluous-parens\n      if not (1 <= len(idorname) <= _MAX_KEYPART_BYTES):\n        raise ValueError('Key name strings must be non-empty strings up to %i '\n                         'bytes; received %s' % (_MAX_KEYPART_BYTES, idorname))\n      elem.set_name(idorname)\n    else:\n      raise TypeError('id must be either a numeric id or a string name; '\n                      'received %r' % idorname)\n  # An empty app id means to use the default app id.\n  if not app:\n    app = _DefaultAppId()\n  # Always set the app id, since it is mandatory.\n  reference.set_app(app)\n  # An empty namespace overrides the default namespace.\n  if namespace is None:\n    namespace = _DefaultNamespace()\n  # Only set the namespace if it is not empty.\n  if namespace:\n    reference.set_name_space(namespace)\n  return reference", "response": "Construct a Reference from a list of pairs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ReferenceFromSerialized(serialized):\n  if not isinstance(serialized, basestring):\n    raise TypeError('serialized must be a string; received %r' % serialized)\n  elif isinstance(serialized, unicode):\n    serialized = serialized.encode('utf8')\n  return entity_pb.Reference(serialized)", "response": "Construct a Reference from a serialized Reference."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding a url - safe base64 - encoded string.", "response": "def _DecodeUrlSafe(urlsafe):\n  \"\"\"Decode a url-safe base64-encoded string.\n\n  This returns the decoded string.\n  \"\"\"\n  if not isinstance(urlsafe, basestring):\n    raise TypeError('urlsafe must be a string; received %r' % urlsafe)\n  if isinstance(urlsafe, unicode):\n    urlsafe = urlsafe.encode('utf8')\n  mod = len(urlsafe) % 4\n  if mod:\n    urlsafe += '=' * (4 - mod)\n  # This is 3-4x faster than urlsafe_b64decode()\n  return base64.b64decode(urlsafe.replace('-', '+').replace('_', '/'))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_from_ref(cls, pairs=None, flat=None,\n                      reference=None, serialized=None, urlsafe=None,\n                      app=None, namespace=None, parent=None):\n    \"\"\"Construct a Reference; the signature is the same as for Key.\"\"\"\n    if cls is not Key:\n      raise TypeError('Cannot construct Key reference on non-Key class; '\n                      'received %r' % cls)\n    if (bool(pairs) + bool(flat) + bool(reference) + bool(serialized) +\n        bool(urlsafe) + bool(parent)) != 1:\n      raise TypeError('Cannot construct Key reference from incompatible '\n                      'keyword arguments.')\n    if urlsafe:\n      serialized = _DecodeUrlSafe(urlsafe)\n    if serialized:\n      reference = _ReferenceFromSerialized(serialized)\n    if reference:\n      reference = _ReferenceFromReference(reference)\n    pairs = []\n    elem = None\n    path = reference.path()\n    for elem in path.element_list():\n      kind = elem.type()\n      if elem.has_id():\n        id_or_name = elem.id()\n      else:\n        id_or_name = elem.name()\n      if not id_or_name:\n        id_or_name = None\n      tup = (kind, id_or_name)\n      pairs.append(tup)\n    if elem is None:\n      raise RuntimeError('Key reference has no path or elements (%r, %r, %r).'\n                         % (urlsafe, serialized, str(reference)))\n    # TODO: ensure that each element has a type and either an id or a name\n    # You needn't specify app= or namespace= together with reference=,\n    # serialized= or urlsafe=, but if you do, their values must match\n    # what is already in the reference.\n    ref_app = reference.app()\n    if app is not None:\n      if app != ref_app:\n        raise RuntimeError('Key reference constructed uses a different app %r '\n                           'than the one specified %r' %\n                           (ref_app, app))\n    ref_namespace = reference.name_space()\n    if namespace is not None:\n      if namespace != ref_namespace:\n        raise RuntimeError('Key reference constructed uses a different '\n                           'namespace %r than the one specified %r' %\n                           (ref_namespace, namespace))\n    return (reference, tuple(pairs), ref_app, ref_namespace)", "response": "Construct a Key reference from a reference."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parent(self):\n    pairs = self.__pairs\n    if len(pairs) <= 1:\n      return None\n    return Key(pairs=pairs[:-1], app=self.__app, namespace=self.__namespace)", "response": "Return a Key constructed from all but the last pair."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef string_id(self):\n    id = self.id()\n    if not isinstance(id, basestring):\n      id = None\n    return id", "response": "Return the string id in the last pair of kind and id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef integer_id(self):\n    id = self.id()\n    if not isinstance(id, (int, long)):\n      id = None\n    return id", "response": "Return the integer id in the last kind id pair."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a tuple of alternating kind and id values.", "response": "def flat(self):\n    \"\"\"Return a tuple of alternating kind and id values.\"\"\"\n    flat = []\n    for kind, id in self.__pairs:\n      flat.append(kind)\n      flat.append(id)\n    return tuple(flat)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reference(self):\n    if self.__reference is None:\n      self.__reference = _ConstructReference(self.__class__,\n                                             pairs=self.__pairs,\n                                             app=self.__app,\n                                             namespace=self.__namespace)\n    return self.__reference", "response": "Return the Reference object for this Key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef urlsafe(self):\n    # This is 3-4x faster than urlsafe_b64decode()\n    urlsafe = base64.b64encode(self.reference().Encode())\n    return urlsafe.rstrip('=').replace('+', '-').replace('/', '_')", "response": "Return a url - safe string encoding this Key s Reference."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a Future whose result is the entity for this Key.", "response": "def get_async(self, **ctx_options):\n    \"\"\"Return a Future whose result is the entity for this Key.\n\n    If no such entity exists, a Future is still returned, and the\n    Future's eventual return result be None.\n    \"\"\"\n    from . import model, tasklets\n    ctx = tasklets.get_context()\n    cls = model.Model._kind_map.get(self.kind())\n    if cls:\n      cls._pre_get_hook(self)\n    fut = ctx.get(self, **ctx_options)\n    if cls:\n      post_hook = cls._post_get_hook\n      if not cls._is_default_hook(model.Model._default_post_get_hook,\n                                  post_hook):\n        fut.add_immediate_callback(post_hook, self, fut)\n    return fut"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nschedule deletion of the entity for this Key.", "response": "def delete_async(self, **ctx_options):\n    \"\"\"Schedule deletion of the entity for this Key.\n\n    This returns a Future, whose result becomes available once the\n    deletion is complete.  If no such entity exists, a Future is still\n    returned.  In all cases the Future's result is None (i.e. there is\n    no way to tell whether the entity existed or not).\n    \"\"\"\n    from . import tasklets, model\n    ctx = tasklets.get_context()\n    cls = model.Model._kind_map.get(self.kind())\n    if cls:\n      cls._pre_delete_hook(self)\n    fut = ctx.delete(self, **ctx_options)\n    if cls:\n      post_hook = cls._post_delete_hook\n      if not cls._is_default_hook(model.Model._default_post_delete_hook,\n                                  post_hook):\n        fut.add_immediate_callback(post_hook, self, fut)\n    return fut"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_flow_exception(exc):\n  global _flow_exceptions\n  if not isinstance(exc, type) or not issubclass(exc, Exception):\n    raise TypeError('Expected an Exception subclass, got %r' % (exc,))\n  as_set = set(_flow_exceptions)\n  as_set.add(exc)\n  _flow_exceptions = tuple(as_set)", "response": "Add an exception that should not be logged."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _init_flow_exceptions():\n  global _flow_exceptions\n  _flow_exceptions = ()\n  add_flow_exception(datastore_errors.Rollback)\n  try:\n    from webob import exc\n  except ImportError:\n    pass\n  else:\n    add_flow_exception(exc.HTTPException)", "response": "Internal helper to initialize _flow_exceptions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef synctasklet(func):\n  taskletfunc = tasklet(func)  # wrap at declaration time.\n\n  @utils.wrapping(func)\n  def synctasklet_wrapper(*args, **kwds):\n    # pylint: disable=invalid-name\n    __ndb_debug__ = utils.func_info(func)\n    return taskletfunc(*args, **kwds).get_result()\n  return synctasklet_wrapper", "response": "Decorator to run a function as a tasklet when called."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new context that can connect to a Remote Cloud Datastore instance.", "response": "def _make_cloud_datastore_context(app_id, external_app_ids=()):\n  \"\"\"Creates a new context to connect to a remote Cloud Datastore instance.\n\n  This should only be used outside of Google App Engine.\n\n  Args:\n    app_id: The application id to connect to. This differs from the project\n      id as it may have an additional prefix, e.g. \"s~\" or \"e~\".\n    external_app_ids: A list of apps that may be referenced by data in your\n      application. For example, if you are connected to s~my-app and store keys\n      for s~my-other-app, you should include s~my-other-app in the external_apps\n      list.\n  Returns:\n    An ndb.Context that can connect to a Remote Cloud Datastore. You can use\n    this context by passing it to ndb.set_context.\n  \"\"\"\n  from . import model  # Late import to deal with circular imports.\n  # Late import since it might not exist.\n  if not datastore_pbs._CLOUD_DATASTORE_ENABLED:\n    raise datastore_errors.BadArgumentError(\n        datastore_pbs.MISSING_CLOUD_DATASTORE_MESSAGE)\n  import googledatastore\n  try:\n    from google.appengine.datastore import cloud_datastore_v1_remote_stub\n  except ImportError:\n    from google3.apphosting.datastore import cloud_datastore_v1_remote_stub\n\n  current_app_id = os.environ.get('APPLICATION_ID', None)\n  if current_app_id and current_app_id != app_id:\n    # TODO(pcostello): We should support this so users can connect to different\n    # applications.\n    raise ValueError('Cannot create a Cloud Datastore context that connects '\n                     'to an application (%s) that differs from the application '\n                     'already connected to (%s).' % (app_id, current_app_id))\n  os.environ['APPLICATION_ID'] = app_id\n\n  id_resolver = datastore_pbs.IdResolver((app_id,) + tuple(external_app_ids))\n  project_id = id_resolver.resolve_project_id(app_id)\n  endpoint = googledatastore.helper.get_project_endpoint_from_env(project_id)\n  datastore = googledatastore.Datastore(\n      project_endpoint=endpoint,\n      credentials=googledatastore.helper.get_credentials_from_env())\n\n  conn = model.make_connection(_api_version=datastore_rpc._CLOUD_DATASTORE_V1,\n                               _id_resolver=id_resolver)\n\n  # If necessary, install the stubs\n  try:\n    stub = cloud_datastore_v1_remote_stub.CloudDatastoreV1RemoteStub(datastore)\n    apiproxy_stub_map.apiproxy.RegisterStub(datastore_rpc._CLOUD_DATASTORE_V1,\n                                            stub)\n  except:\n    pass  # The stub is already installed.\n  # TODO(pcostello): Ensure the current stub is connected to the right project.\n\n  # Install a memcache and taskqueue stub which throws on everything.\n  try:\n    apiproxy_stub_map.apiproxy.RegisterStub('memcache', _ThrowingStub())\n  except:\n    pass  # The stub is already installed.\n  try:\n    apiproxy_stub_map.apiproxy.RegisterStub('taskqueue', _ThrowingStub())\n  except:\n    pass  # The stub is already installed.\n\n\n  return make_context(conn=conn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _analyze_indexed_fields(indexed_fields):\n  result = {}\n  for field_name in indexed_fields:\n    if not isinstance(field_name, basestring):\n      raise TypeError('Field names must be strings; got %r' % (field_name,))\n    if '.' not in field_name:\n      if field_name in result:\n        raise ValueError('Duplicate field name %s' % field_name)\n      result[field_name] = None\n    else:\n      head, tail = field_name.split('.', 1)\n      if head not in result:\n        result[head] = [tail]\n      elif result[head] is None:\n        raise ValueError('Field name %s conflicts with ancestor %s' %\n                         (field_name, head))\n      else:\n        result[head].append(tail)\n  return result", "response": "Internal helper to check a list of indexed fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _make_model_class(message_type, indexed_fields, **props):\n  analyzed = _analyze_indexed_fields(indexed_fields)\n  for field_name, sub_fields in analyzed.iteritems():\n    if field_name in props:\n      raise ValueError('field name %s is reserved' % field_name)\n    try:\n      field = message_type.field_by_name(field_name)\n    except KeyError:\n      raise ValueError('Message type %s has no field named %s' %\n                       (message_type.__name__, field_name))\n    if isinstance(field, messages.MessageField):\n      if not sub_fields:\n        raise ValueError(\n            'MessageField %s cannot be indexed, only sub-fields' % field_name)\n      sub_model_class = _make_model_class(field.type, sub_fields)\n      prop = model.StructuredProperty(sub_model_class, field_name,\n                                      repeated=field.repeated)\n    else:\n      if sub_fields is not None:\n        raise ValueError(\n            'Unstructured field %s cannot have indexed sub-fields' % field_name)\n      if isinstance(field, messages.EnumField):\n        prop = EnumProperty(field.type, field_name, repeated=field.repeated)\n      elif isinstance(field, messages.BytesField):\n        prop = model.BlobProperty(field_name,\n                                  repeated=field.repeated, indexed=True)\n      else:\n        # IntegerField, FloatField, BooleanField, StringField.\n        prop = model.GenericProperty(field_name, repeated=field.repeated)\n    props[field_name] = prop\n  return model.MetaModel('_%s__Model' % message_type.__name__,\n                         (model.Model,), props)", "response": "Construct a Model subclass corresponding to a Message subclass."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _projected_entity_to_message(ent, message_type):\n  msg = message_type()\n  analyzed = _analyze_indexed_fields(ent._projection)\n  for name, sublist in analyzed.iteritems():\n    prop = ent._properties[name]\n    val = prop._get_value(ent)\n    assert isinstance(prop, model.StructuredProperty) == bool(sublist)\n    if sublist:\n      field = message_type.field_by_name(name)\n      assert isinstance(field, messages.MessageField)\n      assert prop._repeated == field.repeated\n      if prop._repeated:\n        assert isinstance(val, list)\n        val = [_projected_entity_to_message(v, field.type) for v in val]\n      else:\n        assert isinstance(val, prop._modelclass)\n        val = _projected_entity_to_message(val, field.type)\n    setattr(msg, name, val)\n  return msg", "response": "Recursive helper for _from_base_type() to convert an entity to a message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate(self, value):\n    if not isinstance(value, self._enum_type):\n      raise TypeError('Expected a %s instance, got %r instead' %\n                      (self._enum_type.__name__, value))", "response": "Validate an Enum value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating an Enum value.", "response": "def _validate(self, msg):\n    \"\"\"Validate an Enum value.\n\n    Raises:\n      TypeError if the value is not an instance of self._message_type.\n    \"\"\"\n    if not isinstance(msg, self._message_type):\n      raise TypeError('Expected a %s instance for %s property',\n                      self._message_type.__name__,\n                      self._code_name or self._name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _to_base_type(self, msg):\n    ent = _message_to_entity(msg, self._modelclass)\n    ent.blob_ = self._protocol_impl.encode_message(msg)\n    return ent", "response": "Convert a Message value to a Model instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a Model instance to a Message value.", "response": "def _from_base_type(self, ent):\n    \"\"\"Convert a Model instance (entity) to a Message value.\"\"\"\n    if ent._projection:\n      # Projection query result.  Reconstitute the message from the fields.\n      return _projected_entity_to_message(ent, self._message_type)\n\n    blob = ent.blob_\n    if blob is not None:\n      protocol = self._protocol_impl\n    else:\n      # Perhaps it was written using a different protocol.\n      protocol = None\n      for name in _protocols_registry.names:\n        key = '__%s__' % name\n        if key in ent._values:\n          blob = ent._values[key]\n          if isinstance(blob, model._BaseValue):\n            blob = blob.b_val\n          protocol = _protocols_registry.lookup_by_name(name)\n          break\n    if blob is None or protocol is None:\n      return None  # This will reveal the underlying dummy model.\n    msg = protocol.decode_message(self._message_type, blob)\n    return msg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_value(self, entity):\n    value = super(_ClassKeyProperty, self)._get_value(entity)\n    if not value:\n      value = entity._class_key()\n      self._store_value(entity, value)\n    return value", "response": "Compute and store a default value if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\noverrides ; called by Model. _fix_up_properties.", "response": "def _update_kind_map(cls):\n    \"\"\"Override; called by Model._fix_up_properties().\n\n    Update the kind map as well as the class map, except for PolyModel\n    itself (its class key is empty).  Note that the kind map will\n    contain entries for all classes in a PolyModel hierarchy; they all\n    have the same kind, but different class names.  PolyModel class\n    names, like regular Model class names, must be globally unique.\n    \"\"\"\n    cls._kind_map[cls._class_name()] = cls\n    class_key = cls._class_key()\n    if class_key:\n      cls._class_map[tuple(class_key)] = cls"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _from_pb(cls, pb, set_key=True, ent=None, key=None):\n    prop_name = cls.class_._name\n    class_name = []\n    for plist in [pb.property_list(), pb.raw_property_list()]:\n      for p in plist:\n        if p.name() == prop_name:\n          class_name.append(p.value().stringvalue())\n    cls = cls._class_map.get(tuple(class_name), cls)\n    return super(PolyModel, cls)._from_pb(pb, set_key, ent, key)", "response": "Override. _from_pb Use the class map to give the correct subclass of cls."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverride Make sure that the kind returned is the root class of the the polymorphic hierarchy.", "response": "def _get_kind(cls):\n    \"\"\"Override.\n\n    Make sure that the kind returned is the root class of the\n    polymorphic hierarchy.\n    \"\"\"\n    bases = cls._get_hierarchy()\n    if not bases:\n      # We have to jump through some hoops to call the superclass'\n      # _get_kind() method.  First, this is called by the metaclass\n      # before the PolyModel name is defined, so it can't use\n      # super(PolyModel, cls)._get_kind().  Second, we can't just call\n      # Model._get_kind() because that always returns 'Model'.  Hence\n      # the 'im_func' hack.\n      return model.Model._get_kind.im_func(cls)\n    else:\n      return bases[0]._class_name()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all potential kernels in a base_dirs", "response": "def find_env_paths_in_basedirs(base_dirs):\n    \"\"\"Returns all potential envs in a basedir\"\"\"\n    # get potential env path in the base_dirs\n    env_path = []\n    for base_dir in base_dirs:\n        env_path.extend(glob.glob(os.path.join(\n            os.path.expanduser(base_dir), '*', '')))\n    # self.log.info(\"Found the following kernels from config: %s\", \", \".join(venvs))\n\n    return env_path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a list of paths to environments to env_data.", "response": "def convert_to_env_data(mgr, env_paths, validator_func, activate_func,\n                        name_template, display_name_template, name_prefix):\n    \"\"\"Converts a list of paths to environments to env_data.\n\n    env_data is a structure {name -> (ressourcedir, kernel spec)}\n    \"\"\"\n    env_data = {}\n    for venv_dir in env_paths:\n        venv_name = os.path.split(os.path.abspath(venv_dir))[1]\n        kernel_name = name_template.format(name_prefix + venv_name)\n        kernel_name = kernel_name.lower()\n        if kernel_name in env_data:\n            mgr.log.debug(\n                \"Found duplicate env kernel: %s, which would again point to %s. Using the first!\",\n                kernel_name, venv_dir)\n            continue\n        argv, language, resource_dir = validator_func(venv_dir)\n        if not argv:\n            # probably does not contain the kernel type (e.g. not R or python or does not contain\n            # the kernel code itself)\n            continue\n        display_name = display_name_template.format(kernel_name)\n        kspec_dict = {\"argv\": argv, \"language\": language,\n                      \"display_name\": display_name,\n                      \"resource_dir\": resource_dir\n                      }\n\n        # the default vars are needed to save the vars in the function context\n        def loader(env_dir=venv_dir, activate_func=activate_func, mgr=mgr):\n            mgr.log.debug(\"Loading env data for %s\" % env_dir)\n            res = activate_func(mgr, env_dir)\n            # mgr.log.info(\"PATH: %s\" % res['PATH'])\n            return res\n\n        kspec = EnvironmentLoadingKernelSpec(loader, **kspec_dict)\n        env_data.update({kernel_name: (resource_dir, kspec)})\n    return env_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating that this env contains an IPython kernel and returns info to start it", "response": "def validate_IPykernel(venv_dir):\n    \"\"\"Validates that this env contains an IPython kernel and returns info to start it\n\n\n    Returns: tuple\n        (ARGV, language, resource_dir)\n    \"\"\"\n    python_exe_name = find_exe(venv_dir, \"python\")\n    if python_exe_name is None:\n        python_exe_name = find_exe(venv_dir, \"python2\")\n    if python_exe_name is None:\n        python_exe_name = find_exe(venv_dir, \"python3\")\n    if python_exe_name is None:\n        return [], None, None\n\n    # Make some checks for ipython first, because calling the import is expensive\n    if find_exe(venv_dir, \"ipython\") is None:\n        if find_exe(venv_dir, \"ipython2\") is None:\n            if find_exe(venv_dir, \"ipython3\") is None:\n                return [], None, None\n\n    # check if this is really an ipython **kernel**\n    import subprocess\n    try:\n        subprocess.check_call([python_exe_name, '-c', '\"import ipykernel\"'])\n    except:\n        # not installed? -> not useable in any case...\n        return [], None, None\n    argv = [python_exe_name, \"-m\", \"ipykernel\", \"-f\", \"{connection_file}\"]\n    resources_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"logos\", \"python\")\n    return argv, \"python\", resources_dir"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_IRkernel(venv_dir):\n    r_exe_name = find_exe(venv_dir, \"R\")\n    if r_exe_name is None:\n        return [], None, None\n\n    # check if this is really an IRkernel **kernel**\n    import subprocess\n    ressources_dir = None\n    try:\n        print_resources = 'cat(as.character(system.file(\"kernelspec\", package = \"IRkernel\")))'\n        resources_dir_bytes = subprocess.check_output([r_exe_name, '--slave', '-e', print_resources])\n        resources_dir = resources_dir_bytes.decode(errors='ignore')\n    except:\n        # not installed? -> not useable in any case...\n        return [], None, None\n    argv = [r_exe_name, \"--slave\", \"-e\", \"IRkernel::main()\", \"--args\", \"{connection_file}\"]\n    if not os.path.exists(resources_dir.strip()):\n        # Fallback to our own log, but don't get the nice js goodies...\n        resources_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"logos\", \"r\")\n    return argv, \"r\", resources_dir", "response": "Validates that this env contains an IRkernel kernel and returns info to start it"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_exe(env_dir, name):\n\n    if platform.system() == \"Windows\":\n        name = name + \".exe\"\n\n    # find the binary\n    exe_name = os.path.join(env_dir, name)\n    if not os.path.exists(exe_name):\n        exe_name = os.path.join(env_dir, \"bin\", name)\n        if not os.path.exists(exe_name):\n            exe_name = os.path.join(env_dir, \"Scripts\", name)\n            if not os.path.exists(exe_name):\n                return None\n    return exe_name", "response": "Find an executable with that name in the environment path"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_virtualenv_env_data(mgr):\n\n    if not mgr.find_virtualenv_envs:\n        return {}\n\n    mgr.log.debug(\"Looking for virtualenv environments in %s...\", mgr.virtualenv_env_dirs)\n\n    # find all potential env paths\n    env_paths = find_env_paths_in_basedirs(mgr.virtualenv_env_dirs)\n\n    mgr.log.debug(\"Scanning virtualenv environments for python kernels...\")\n    env_data = convert_to_env_data(mgr=mgr,\n                                   env_paths=env_paths,\n                                   validator_func=validate_IPykernel,\n                                   activate_func=_get_env_vars_for_virtualenv_env,\n                                   name_template=mgr.virtualenv_prefix_template,\n                                   display_name_template=mgr.display_name_template,\n                                   # virtualenv has only python, so no need for a prefix\n                                   name_prefix=\"\")\n    return env_data", "response": "Finds kernel specs from virtualenv environments\n    returns env_data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef source_bash(args, stdin=None):\n    args = list(args)\n    new_args = ['bash', '--sourcer=source']\n    new_args.extend(args)\n    return source_foreign(new_args, stdin=stdin)", "response": "Simply bash - specific wrapper around source - foreign"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef argvquote(arg, force=False):\n    if not force and len(arg) != 0 and not any([c in arg for c in ' \\t\\n\\v\"']):\n        return arg\n    else:\n        n_backslashes = 0\n        cmdline = '\"'\n        for c in arg:\n            if c == \"\\\\\":\n                # first count the number of current backslashes\n                n_backslashes += 1\n                continue\n            if c == '\"':\n                # Escape all backslashes and the following double quotation mark\n                cmdline += (n_backslashes * 2 + 1) * '\\\\'\n            else:\n                # backslashes are not special here\n                cmdline += n_backslashes * '\\\\'\n            n_backslashes = 0\n            cmdline += c\n        # Escape all backslashes, but let the terminating\n        # double quotation mark we add below be interpreted\n        # as a metacharacter\n        cmdline += + n_backslashes * 2 * '\\\\' + '\"'\n        return cmdline", "response": "Returns an argument quoted in such a way that CommandLineToArgvW\n on Windows will return the argument unchanged."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nescape the Windows command string.", "response": "def escape_windows_cmd_string(s):\n    \"\"\"Returns a string that is usable by the Windows cmd.exe.\n    The escaping is based on details here and emperical testing:\n    http://www.robvanderwoude.com/escapechars.php\n    \"\"\"\n    for c in '()%!^<>&|\"':\n        s = s.replace(c, '^' + c)\n    s = s.replace('/?', '/.')\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef source_foreign(args, stdin=None):\n    parser = _ensure_source_foreign_parser()\n    ns = parser.parse_args(args)\n    if ns.prevcmd is not None:\n        pass  # don't change prevcmd if given explicitly\n    elif os.path.isfile(ns.files_or_code[0]):\n        # we have filename to source\n        ns.prevcmd = '{} \"{}\"'.format(ns.sourcer, '\" \"'.join(ns.files_or_code))\n    elif ns.prevcmd is None:\n        ns.prevcmd = ' '.join(ns.files_or_code)  # code to run, no files\n    fsenv = foreign_shell_data(shell=ns.shell, login=ns.login,\n                                          interactive=ns.interactive,\n                                          envcmd=ns.envcmd,\n                                          aliascmd=ns.aliascmd,\n                                          extra_args=ns.extra_args,\n                                          safe=ns.safe, prevcmd=ns.prevcmd,\n                                          postcmd=ns.postcmd,\n                                          funcscmd=ns.funcscmd,\n                                          sourcer=ns.sourcer,\n                                          use_tmpfile=ns.use_tmpfile,\n                                          seterrprevcmd=ns.seterrprevcmd,\n                                          seterrpostcmd=ns.seterrpostcmd)\n    if fsenv is None:\n        raise RuntimeError(\"Source failed: {}\\n\".format(ns.prevcmd), 1)\n    # apply results\n    env = os.environ.copy()\n    for k, v in fsenv.items():\n        if k in env and v == env[k]:\n            continue  # no change from original\n        env[k] = v\n    # Remove any env-vars that were unset by the script.\n    for k in os.environ: # use os.environ again to prevent errors about changed size\n        if k not in fsenv:\n            env.pop(k, None)\n    return env", "response": "Sources a file written in a foreign shell language."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking that path is an executable regular file or a symlink towards one.", "response": "def _is_executable_file(path):\n    \"\"\"Checks that path is an executable regular file, or a symlink towards one.\n    This is roughly ``os.path isfile(path) and os.access(path, os.X_OK)``.\n\n    This function was forked from pexpect originally:\n\n    Copyright (c) 2013-2014, Pexpect development team\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n    \"\"\"\n    # follow symlinks,\n    fpath = os.path.realpath(path)\n\n    if not os.path.isfile(fpath):\n        # non-files (directories, fifo, etc.)\n        return False\n\n    return os.access(fpath, os.X_OK)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef foreign_shell_data(shell, interactive=True, login=False, envcmd=None,\n                       aliascmd=None, extra_args=(), currenv=None,\n                       safe=False, prevcmd='', postcmd='', funcscmd=None,\n                       sourcer=None, use_tmpfile=False, tmpfile_ext=None,\n                       runcmd=None, seterrprevcmd=None, seterrpostcmd=None):\n    \"\"\"Extracts data from a foreign (non-xonsh) shells. Currently this gets\n    the environment, aliases, and functions but may be extended in the future.\n\n    Parameters\n    ----------\n    shell : str\n        The name of the shell, such as 'bash' or '/bin/sh'.\n    interactive : bool, optional\n        Whether the shell should be run in interactive mode.\n    login : bool, optional\n        Whether the shell should be a login shell.\n    envcmd : str or None, optional\n        The command to generate environment output with.\n    aliascmd : str or None, optional\n        The command to generate alias output with.\n    extra_args : tuple of str, optional\n        Addtional command line options to pass into the shell.\n    currenv : tuple of items or None, optional\n        Manual override for the current environment.\n    safe : bool, optional\n        Flag for whether or not to safely handle exceptions and other errors.\n    prevcmd : str, optional\n        A command to run in the shell before anything else, useful for\n        sourcing and other commands that may require environment recovery.\n    postcmd : str, optional\n        A command to run after everything else, useful for cleaning up any\n        damage that the prevcmd may have caused.\n    funcscmd : str or None, optional\n        This is a command or script that can be used to determine the names\n        and locations of any functions that are native to the foreign shell.\n        This command should print *only* a JSON object that maps\n        function names to the filenames where the functions are defined.\n        If this is None, then a default script will attempted to be looked\n        up based on the shell name. Callable wrappers for these functions\n        will be returned in the aliases dictionary.\n    sourcer : str or None, optional\n        How to source a foreign shell file for purposes of calling functions\n        in that shell. If this is None, a default value will attempt to be\n        looked up based on the shell name.\n    use_tmpfile : bool, optional\n        This specifies if the commands are written to a tmp file or just\n        parsed directly to the shell\n    tmpfile_ext : str or None, optional\n        If tmpfile is True this sets specifies the extension used.\n    runcmd : str or None, optional\n        Command line switches to use when running the script, such as\n        -c for Bash and /C for cmd.exe.\n    seterrprevcmd : str or None, optional\n        Command that enables exit-on-error for the shell that is run at the\n        start of the script. For example, this is \"set -e\" in Bash. To disable\n        exit-on-error behavior, simply pass in an empty string.\n    seterrpostcmd : str or None, optional\n        Command that enables exit-on-error for the shell that is run at the end\n        of the script. For example, this is \"if errorlevel 1 exit 1\" in\n        cmd.exe. To disable exit-on-error behavior, simply pass in an\n        empty string.\n\n    Returns\n    -------\n    env : dict\n        Dictionary of shell's environment\n    aliases : dict\n        Dictionary of shell's alaiases, this includes foreign function\n        wrappers.\n    \"\"\"\n    cmd = [shell]\n    cmd.extend(extra_args)  # needs to come here for GNU long options\n    if interactive:\n        cmd.append('-i')\n    if login:\n        cmd.append('-l')\n    shkey = CANON_SHELL_NAMES[shell]\n    envcmd = DEFAULT_ENVCMDS.get(shkey, 'env') if envcmd is None else envcmd\n    tmpfile_ext = DEFAULT_TMPFILE_EXT.get(shkey, 'sh') if tmpfile_ext is None else tmpfile_ext\n    runcmd = DEFAULT_RUNCMD.get(shkey, '-c') if runcmd is None else runcmd\n    seterrprevcmd = DEFAULT_SETERRPREVCMD.get(shkey, '') \\\n                        if seterrprevcmd is None else seterrprevcmd\n    seterrpostcmd = DEFAULT_SETERRPOSTCMD.get(shkey, '') \\\n                        if seterrpostcmd is None else seterrpostcmd\n    command = COMMAND.format(envcmd=envcmd, prevcmd=prevcmd,\n                             postcmd=postcmd,\n                             seterrprevcmd=seterrprevcmd,\n                             seterrpostcmd=seterrpostcmd).strip()\n\n    cmd.append(runcmd)\n\n    if not use_tmpfile:\n        cmd.append(command)\n    else:\n        tmpfile = NamedTemporaryFile(suffix=tmpfile_ext, delete=False)\n        tmpfile.write(command.encode('utf8'))\n        tmpfile.close()\n        cmd.append(tmpfile.name)\n\n    if currenv is not None:\n        currenv = os.environ\n    try:\n        s = subprocess.check_output(cmd, stderr=subprocess.PIPE, env=currenv,\n                                    # start new session to avoid hangs\n                                    start_new_session=True,\n                                    universal_newlines=True)\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        if not safe:\n            raise\n        return None, None\n    finally:\n        if use_tmpfile:\n            pass\n            os.remove(tmpfile.name)\n    env = parse_env(s)\n    return env", "response": "Extracts data from a foreign shell."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert to a boolean in a semantically meaningful way.", "response": "def to_bool(x):\n    \"\"\"\"Converts to a boolean in a semantically meaningful way.\"\"\"\n    if isinstance(x, bool):\n        return x\n    elif isinstance(x, str):\n        return False if x.lower() in _FALSES else True\n    else:\n        return bool(x)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the environment portion of string into a dict.", "response": "def parse_env(s):\n    \"\"\"Parses the environment portion of string into a dict.\"\"\"\n    m = ENV_RE.search(s)\n    if m is None:\n        return {}\n    g1 = m.group(1)\n    env = dict(ENV_SPLIT_RE.findall(g1))\n    return env"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_conda_env_data(mgr):\n    if not mgr.find_conda_envs:\n        return {}\n\n    mgr.log.debug(\"Looking for conda environments in %s...\", mgr.conda_env_dirs)\n\n    # find all potential env paths\n    env_paths = find_env_paths_in_basedirs(mgr.conda_env_dirs)\n    env_paths.extend(_find_conda_env_paths_from_conda(mgr))\n    env_paths = list(set(env_paths)) # remove duplicates\n\n    mgr.log.debug(\"Scanning conda environments for python kernels...\")\n    env_data = convert_to_env_data(mgr=mgr,\n                                   env_paths=env_paths,\n                                   validator_func=validate_IPykernel,\n                                   activate_func=_get_env_vars_for_conda_env,\n                                   name_template=mgr.conda_prefix_template,\n                                   display_name_template=mgr.display_name_template,\n                                   name_prefix=\"\")  # lets keep the py kernels without a prefix...\n    if mgr.find_r_envs:\n        mgr.log.debug(\"Scanning conda environments for R kernels...\")\n        env_data.update(convert_to_env_data(mgr=mgr,\n                                            env_paths=env_paths,\n                                            validator_func=validate_IRkernel,\n                                            activate_func=_get_env_vars_for_conda_env,\n                                            name_template=mgr.conda_prefix_template,\n                                            display_name_template=mgr.display_name_template,\n                                            name_prefix=\"r_\"))\n    return env_data", "response": "Finds kernel specs from conda environments\n    is a structure where name is the name of the kernel and kernel spec is the kernel spec."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of paths as given by conda env list - json.", "response": "def _find_conda_env_paths_from_conda(mgr):\n    \"\"\"Returns a list of path as given by `conda env list --json`.\n\n    Returns empty list, if conda couldn't be called.\n    \"\"\"\n    # this is expensive, so make it configureable...\n    if not mgr.use_conda_directly:\n        return []\n    mgr.log.debug(\"Looking for conda environments by calling conda directly...\")\n    import subprocess\n    import json\n    try:\n        p = subprocess.Popen(\n            ['conda', 'env', 'list', '--json'],\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE)\n        comm = p.communicate()\n        output = comm[0].decode()\n        if p.returncode != 0 or len(output) == 0:\n            mgr.log.error(\n                \"Couldn't call 'conda' to get the environments. \"\n                \"Output:\\n%s\", str(comm))\n            return []\n    except FileNotFoundError:\n        mgr.log.error(\"'conda' not found in path.\")\n        return []\n    output = json.loads(output)\n    envs = output[\"envs\"]\n    # self.log.info(\"Found the following kernels from conda: %s\", \", \".join(envs))\n    return envs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the name of the environment against the blacklist and the whitelist.", "response": "def validate_env(self, envname):\n        \"\"\"\n        Check the name of the environment against the black list and the\n        whitelist. If a whitelist is specified only it is checked.\n        \"\"\"\n        if self.whitelist_envs and envname in self.whitelist_envs:\n            return True\n        elif self.whitelist_envs:\n            return False\n\n        if self.blacklist_envs and envname not in self.blacklist_envs:\n            return True\n        elif self.blacklist_envs:\n            # If there is just a True, all envs are blacklisted\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the data about the available environments.", "response": "def _get_env_data(self, reload=False):\n        \"\"\"Get the data about the available environments.\n\n        env_data is a structure {name -> (resourcedir, kernel spec)}\n        \"\"\"\n\n        # This is called much too often and finding-process is really expensive :-(\n        if not reload and getattr(self, \"_env_data_cache\", {}):\n            return getattr(self, \"_env_data_cache\")\n\n        env_data = {}\n        for supplyer in ENV_SUPPLYER:\n            env_data.update(supplyer(self))\n\n        env_data = {name: env_data[name] for name in env_data if self.validate_env(name)}\n        new_kernels = [env for env in list(env_data.keys()) if env not in list(self._env_data_cache.keys())]\n        if new_kernels:\n            self.log.info(\"Found new kernels in environments: %s\", \", \".join(new_kernels))\n\n        self._env_data_cache = env_data\n        return env_data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict mapping kernel names to resource directories.", "response": "def find_kernel_specs_for_envs(self):\n        \"\"\"Returns a dict mapping kernel names to resource directories.\"\"\"\n        data = self._get_env_data()\n        return {name: data[name][0] for name in data}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_kernel_specs_for_envs(self):\n\n        data = self._get_env_data()\n        return {name: data[name][1] for name in data}", "response": "Returns the dict of name - > kernel_spec for all environments"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dict mapping kernel names to resource directories.", "response": "def find_kernel_specs(self):\n        \"\"\"Returns a dict mapping kernel names to resource directories.\"\"\"\n        # let real installed kernels overwrite envs with the same name:\n        # this is the same order as the get_kernel_spec way, which also prefers\n        # kernels from the jupyter dir over env kernels.\n        specs = self.find_kernel_specs_for_envs()\n        specs.update(super(EnvironmentKernelSpecManager,\n                           self).find_kernel_specs())\n        return specs"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dict mapping kernel names and resource directories to kernel names.", "response": "def get_all_specs(self):\n        \"\"\"Returns a dict mapping kernel names and resource directories.\n        \"\"\"\n        # This is new in 4.1 -> https://github.com/jupyter/jupyter_client/pull/93\n        specs = self.get_all_kernel_specs_for_envs()\n        specs.update(super(EnvironmentKernelSpecManager, self).get_all_specs())\n        return specs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a : class:`KernelSpec` instance for the given kernel name.", "response": "def get_kernel_spec(self, kernel_name):\n        \"\"\"Returns a :class:`KernelSpec` instance for the given kernel_name.\n\n        Raises :exc:`NoSuchKernel` if the given kernel name is not found.\n        \"\"\"\n        try:\n            return super(EnvironmentKernelSpecManager,\n                         self).get_kernel_spec(kernel_name)\n        except (NoSuchKernel, FileNotFoundError):\n            venv_kernel_name = kernel_name.lower()\n            specs = self.get_all_kernel_specs_for_envs()\n            if venv_kernel_name in specs:\n                return specs[venv_kernel_name]\n            else:\n                raise NoSuchKernel(kernel_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_latin(string_to_transliterate, lang_code='sr'):\n    ''' Transliterate serbian cyrillic string of characters to latin string of characters.\n    :param string_to_transliterate: The cyrillic string to transliterate into latin characters.\n    :param lang_code: Indicates the cyrillic language code we are translating from. Defaults to Serbian (sr).\n    :return: A string of latin characters transliterated from the given cyrillic string.\n    '''\n\n    # First check if we support the cyrillic alphabet we want to transliterate to latin.\n    if lang_code.lower() not in TRANSLIT_DICT:\n        # If we don't support it, then just return the original string.\n        return string_to_transliterate\n\n    # If we do support it, check if the implementation is not missing before proceeding.\n    elif not TRANSLIT_DICT[lang_code.lower()]['tolatin']:\n        return string_to_transliterate\n\n    # Everything checks out, proceed with transliteration.\n    else:\n\n        # Get the character per character transliteration dictionary\n        transliteration_dict = TRANSLIT_DICT[lang_code.lower()]['tolatin']\n\n        # Initialize the output latin string variable\n        latinized_str = ''\n\n        # Transliterate by traversing the input string character by character.\n        string_to_transliterate = __decode_utf8(string_to_transliterate)\n\n\n        for c in string_to_transliterate:\n\n            # If character is in dictionary, it means it's a cyrillic so let's transliterate that character.\n            if c in transliteration_dict:\n                # Transliterate current character.\n                latinized_str += transliteration_dict[c]\n\n            # If character is not in character transliteration dictionary,\n            # it is most likely a number or a special character so just keep it.\n            else:\n                latinized_str += c\n\n        # Return the transliterated string.\n        return __encode_utf8(latinized_str)", "response": "Transliterate a string of characters into a latin string of characters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntransliterating a string of characters into a cyrillic string of characters.", "response": "def to_cyrillic(string_to_transliterate, lang_code='sr'):\n    ''' Transliterate serbian latin string of characters to cyrillic string of characters.\n    :param string_to_transliterate: The latin string to transliterate into cyrillic characters.\n    :param lang_code: Indicates the cyrillic language code we are translating to. Defaults to Serbian (sr).\n    :return: A string of cyrillic characters transliterated from the given latin string.\n    '''\n\n    # First check if we support the cyrillic alphabet we want to transliterate to latin.\n    if lang_code.lower() not in TRANSLIT_DICT:\n        # If we don't support it, then just return the original string.\n        return string_to_transliterate\n\n    # If we do support it, check if the implementation is not missing before proceeding.\n    elif not TRANSLIT_DICT[lang_code.lower()]['tocyrillic']:\n        return string_to_transliterate\n\n    else:\n        # Get the character per character transliteration dictionary\n        transliteration_dict = TRANSLIT_DICT[lang_code.lower()]['tocyrillic']\n\n        # Initialize the output cyrillic string variable\n        cyrillic_str = ''\n\n        string_to_transliterate = __decode_utf8(string_to_transliterate)\n\n        # Transliterate by traversing the inputted string character by character.\n        length_of_string_to_transliterate = len(string_to_transliterate)\n        index = 0\n\n        while index < length_of_string_to_transliterate:\n            # Grab a character from the string at the current index\n            c = string_to_transliterate[index]\n\n            # Watch out for Lj and lj. Don't want to interpret Lj/lj as L/l and j.\n            # Watch out for Nj and nj. Don't want to interpret Nj/nj as N/n and j.\n            # Watch out for D\u017e and and d\u017e. Don't want to interpret D\u017e/d\u017e as D/d and j.\n            c_plus_1 = u''\n            if index != length_of_string_to_transliterate - 1:\n                c_plus_1 = string_to_transliterate[index + 1]\n\n            if ((c == u'L' or c == u'l') and c_plus_1 == u'j') or \\\n               ((c == u'N' or c == u'n') and c_plus_1 == u'j') or \\\n               ((c == u'D' or c == u'd') and c_plus_1 == u'\u017e') or \\\n               (lang_code == 'mk' and (c == u'D' or c == u'd') and c_plus_1 == u'z') or \\\n               (lang_code == 'ru' and (\n                    (c in u'Cc' and c_plus_1 in u'Hh')   or  # c, ch\n                    (c in u'Ee' and c_plus_1 in u'Hh')   or  # eh\n                    (c == u'i'  and c_plus_1 == u'y' and\n                     string_to_transliterate[index + 2:index + 3] not in u'aou') or  # iy[^AaOoUu]\n                    (c in u'Jj' and c_plus_1 in u'UuAaEe') or  # j, ju, ja, je\n                    (c in u'Ss' and c_plus_1 in u'HhZz') or  # s, sh, sz\n                    (c in u'Yy' and c_plus_1 in u'AaOoUu') or  # y, ya, yo, yu\n                    (c in u'Zz' and c_plus_1 in u'Hh')       # z, zh\n               )):\n\n                index += 1\n                c += c_plus_1\n\n            # If character is in dictionary, it means it's a cyrillic so let's transliterate that character.\n            if c in transliteration_dict:\n                # ay, ey, iy, oy, uy\n                if lang_code == 'ru' and c in u'Yy' and \\\n                        cyrillic_str and cyrillic_str[-1].lower() in u\"\u0430\u0435\u0438\u043e\u0443\u044d\u044f\":\n                    cyrillic_str += u\"\u0439\" if c == u'y' else u\"\u0419\"\n                else:\n                    # Transliterate current character.\n                    cyrillic_str += transliteration_dict[c]\n\n            # If character is not in character transliteration dictionary,\n            # it is most likely a number or a special character so just keep it.\n            else:\n                cyrillic_str += c\n\n            index += 1\n\n        return __encode_utf8(cyrillic_str)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the incoming bytestream as XML and returns the resulting data.", "response": "def parse(self, stream, media_type=None, parser_context=None):\n        \"\"\"\n        Parses the incoming bytestream as XML and returns the resulting data.\n        \"\"\"\n        assert etree, 'XMLParser requires defusedxml to be installed'\n\n        parser_context = parser_context or {}\n        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)\n        parser = etree.DefusedXMLParser(encoding=encoding)\n        try:\n            tree = etree.parse(stream, parser=parser, forbid_dtd=True)\n        except (etree.ParseError, ValueError) as exc:\n            raise ParseError('XML parse error - %s' % six.text_type(exc))\n        data = self._xml_convert(tree.getroot())\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the xml element into the corresponding python object", "response": "def _xml_convert(self, element):\n        \"\"\"\n        convert the xml `element` into the corresponding python object\n        \"\"\"\n\n        children = list(element)\n\n        if len(children) == 0:\n            return self._type_convert(element.text)\n        else:\n            # if the fist child tag is list-item means all children are list-item\n            if children[0].tag == \"list-item\":\n                data = []\n                for child in children:\n                    data.append(self._xml_convert(child))\n            else:\n                data = {}\n                for child in children:\n                    data[child.tag] = self._xml_convert(child)\n\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _type_convert(self, value):\n        if value is None:\n            return value\n\n        try:\n            return datetime.datetime.strptime(value, '%Y-%m-%d %H:%M:%S')\n        except ValueError:\n            pass\n\n        try:\n            return int(value)\n        except ValueError:\n            pass\n\n        try:\n            return decimal.Decimal(value)\n        except decimal.InvalidOperation:\n            pass\n\n        return value", "response": "Converts the value returned by the XMl parse into the equivalent\n        Python type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering data into serialized XML.", "response": "def render(self, data, accepted_media_type=None, renderer_context=None):\n        \"\"\"\n        Renders `data` into serialized XML.\n        \"\"\"\n        if data is None:\n            return ''\n\n        stream = StringIO()\n\n        xml = SimplerXMLGenerator(stream, self.charset)\n        xml.startDocument()\n        xml.startElement(self.root_tag_name, {})\n\n        self._to_xml(xml, data)\n\n        xml.endElement(self.root_tag_name)\n        xml.endDocument()\n        return stream.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open(self):\n        device_type = 'cisco_ios'\n        if self.transport == 'telnet':\n            device_type = 'cisco_ios_telnet'\n        self.device = ConnectHandler(device_type=device_type,\n                                     host=self.hostname,\n                                     username=self.username,\n                                     password=self.password,\n                                     **self.netmiko_optional_args)\n        # ensure in enable mode\n        self.device.enable()", "response": "Open a connection to the device."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _create_tmp_file(config):\n        tmp_dir = tempfile.gettempdir()\n        rand_fname = py23_compat.text_type(uuid.uuid4())\n        filename = os.path.join(tmp_dir, rand_fname)\n        with open(filename, 'wt') as fobj:\n            fobj.write(config)\n        return filename", "response": "Write temp file and for use with inline config and SCP."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_candidate_wrapper(self, source_file=None, source_config=None, dest_file=None,\n                                file_system=None):\n        \"\"\"\n        Transfer file to remote device for either merge or replace operations\n\n        Returns (return_status, msg)\n        \"\"\"\n        return_status = False\n        msg = ''\n        if source_file and source_config:\n            raise ValueError(\"Cannot simultaneously set source_file and source_config\")\n\n        if source_config:\n            if self.inline_transfer:\n                (return_status, msg) = self._inline_tcl_xfer(source_config=source_config,\n                                                             dest_file=dest_file,\n                                                             file_system=file_system)\n            else:\n                # Use SCP\n                tmp_file = self._create_tmp_file(source_config)\n                (return_status, msg) = self._scp_file(source_file=tmp_file, dest_file=dest_file,\n                                                      file_system=file_system)\n                if tmp_file and os.path.isfile(tmp_file):\n                    os.remove(tmp_file)\n        if source_file:\n            if self.inline_transfer:\n                (return_status, msg) = self._inline_tcl_xfer(source_file=source_file,\n                                                             dest_file=dest_file,\n                                                             file_system=file_system)\n            else:\n                (return_status, msg) = self._scp_file(source_file=source_file, dest_file=dest_file,\n                                                      file_system=file_system)\n        if not return_status:\n            if msg == '':\n                msg = \"Transfer to remote device failed\"\n        return (return_status, msg)", "response": "Load candidate TCL file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_replace_candidate(self, filename=None, config=None):\n        self.config_replace = True\n        return_status, msg = self._load_candidate_wrapper(source_file=filename,\n                                                          source_config=config,\n                                                          dest_file=self.candidate_cfg,\n                                                          file_system=self.dest_file_system)\n        if not return_status:\n            raise ReplaceConfigException(msg)", "response": "Load a candidate config file from the device filesystem."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload candidate merge configuration from SCP file to remote device.", "response": "def load_merge_candidate(self, filename=None, config=None):\n        \"\"\"\n        SCP file to remote device.\n\n        Merge configuration in: copy <file> running-config\n        \"\"\"\n        self.config_replace = False\n        return_status, msg = self._load_candidate_wrapper(source_file=filename,\n                                                          source_config=config,\n                                                          dest_file=self.merge_cfg,\n                                                          file_system=self.dest_file_system)\n        if not return_status:\n            raise MergeConfigException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform configuration changes on the current running - config.", "response": "def commit_config(self):\n        \"\"\"\n        If replacement operation, perform 'configure replace' for the entire config.\n\n        If merge operation, perform copy <file> running-config.\n        \"\"\"\n        # Always generate a rollback config on commit\n        self._gen_rollback_cfg()\n\n        if self.config_replace:\n            # Replace operation\n            filename = self.candidate_cfg\n            cfg_file = self._gen_full_path(filename)\n            if not self._check_file_exists(cfg_file):\n                raise ReplaceConfigException(\"Candidate config file does not exist\")\n            if self.auto_rollback_on_error:\n                cmd = 'configure replace {} force revert trigger error'.format(cfg_file)\n            else:\n                cmd = 'configure replace {} force'.format(cfg_file)\n            output = self._commit_hostname_handler(cmd)\n            if ('original configuration has been successfully restored' in output) or \\\n               ('error' in output.lower()) or \\\n               ('failed' in output.lower()):\n                msg = \"Candidate config could not be applied\\n{}\".format(output)\n                raise ReplaceConfigException(msg)\n            elif '%Please turn config archive on' in output:\n                msg = \"napalm-ios replace() requires Cisco 'archive' feature to be enabled.\"\n                raise ReplaceConfigException(msg)\n        else:\n            # Merge operation\n            filename = self.merge_cfg\n            cfg_file = self._gen_full_path(filename)\n            if not self._check_file_exists(cfg_file):\n                raise MergeConfigException(\"Merge source config file does not exist\")\n            cmd = 'copy {} running-config'.format(cfg_file)\n            self._disable_confirm()\n            output = self._commit_hostname_handler(cmd)\n            self._enable_confirm()\n            if 'Invalid input detected' in output:\n                self.rollback()\n                err_header = \"Configuration merge failed; automatic rollback attempted\"\n                merge_error = \"{0}:\\n{1}\".format(err_header, output)\n                raise MergeConfigException(merge_error)\n\n        # Save config to startup (both replace and merge)\n        output += self.device.send_command_expect(\"write mem\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discard_config(self):\n        discard_candidate = 'copy running-config {}'.format(self._gen_full_path(self.candidate_cfg))\n        discard_merge = 'copy null: {}'.format(self._gen_full_path(self.merge_cfg))\n        self._disable_confirm()\n        self.device.send_command_expect(discard_candidate)\n        self.device.send_command_expect(discard_merge)\n        self._enable_confirm()", "response": "Erase the candidate_cfg file. Erase the merge_cfg file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _xfer_file(self, source_file=None, source_config=None, dest_file=None, file_system=None,\n                   TransferClass=FileTransfer):\n        \"\"\"Transfer file to remote device.\n\n        By default, this will use Secure Copy if self.inline_transfer is set, then will use\n        Netmiko InlineTransfer method to transfer inline using either SSH or telnet (plus TCL\n        onbox).\n\n        Return (status, msg)\n        status = boolean\n        msg = details on what happened\n        \"\"\"\n        if not source_file and not source_config:\n            raise ValueError(\"File source not specified for transfer.\")\n        if not dest_file or not file_system:\n            raise ValueError(\"Destination file or file system not specified.\")\n\n        if source_file:\n            kwargs = dict(ssh_conn=self.device, source_file=source_file, dest_file=dest_file,\n                          direction='put', file_system=file_system)\n        elif source_config:\n            kwargs = dict(ssh_conn=self.device, source_config=source_config, dest_file=dest_file,\n                          direction='put', file_system=file_system)\n        enable_scp = True\n        if self.inline_transfer:\n            enable_scp = False\n        with TransferClass(**kwargs) as transfer:\n\n            # Check if file already exists and has correct MD5\n            if transfer.check_file_exists() and transfer.compare_md5():\n                msg = \"File already exists and has correct MD5: no SCP needed\"\n                return (True, msg)\n            if not transfer.verify_space_available():\n                msg = \"Insufficient space available on remote device\"\n                return (False, msg)\n\n            if enable_scp:\n                transfer.enable_scp()\n\n            # Transfer file\n            transfer.transfer_file()\n\n            # Compares MD5 between local-remote files\n            if transfer.verify_file():\n                msg = \"File successfully transferred to remote device\"\n                return (True, msg)\n            else:\n                msg = \"File transfer to remote device failed\"\n                return (False, msg)\n            return (False, '')", "response": "Transfer file to remote device."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _gen_full_path(self, filename, file_system=None):\n        if file_system is None:\n            return '{}/{}'.format(self.dest_file_system, filename)\n        else:\n            if \":\" not in file_system:\n                raise ValueError(\"Invalid file_system specified: {}\".format(file_system))\n            return '{}/{}'.format(file_system, filename)", "response": "Generate full file path on remote device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _gen_rollback_cfg(self):\n        cfg_file = self._gen_full_path(self.rollback_cfg)\n        cmd = 'copy running-config {}'.format(cfg_file)\n        self._disable_confirm()\n        self.device.send_command_expect(cmd)\n        self._enable_confirm()", "response": "Save a configuration that can be used for rollback."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that the file exists on remote device using full path.", "response": "def _check_file_exists(self, cfg_file):\n        \"\"\"\n        Check that the file exists on remote device using full path.\n\n        cfg_file is full path i.e. flash:/file_name\n\n        For example\n        # dir flash:/candidate_config.txt\n        Directory of flash:/candidate_config.txt\n\n        33  -rw-        5592  Dec 18 2015 10:50:22 -08:00  candidate_config.txt\n\n        return boolean\n        \"\"\"\n        cmd = 'dir {}'.format(cfg_file)\n        success_pattern = 'Directory of {}'.format(cfg_file)\n        output = self.device.send_command_expect(cmd)\n        if 'Error opening' in output:\n            return False\n        elif success_pattern in output:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands the abbreviated name of an interface into a full name.", "response": "def _expand_interface_name(self, interface_brief):\n        \"\"\"\n        Obtain the full interface name from the abbreviated name.\n\n        Cache mappings in self.interface_map.\n        \"\"\"\n        if self.interface_map.get(interface_brief):\n            return self.interface_map.get(interface_brief)\n        command = 'show int {}'.format(interface_brief)\n        output = self._send_command(command)\n        first_line = output.splitlines()[0]\n        if 'line protocol' in first_line:\n            full_int_name = first_line.split()[0]\n            self.interface_map[interface_brief] = full_int_name\n            return self.interface_map.get(interface_brief)\n        else:\n            return interface_brief"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lldp_neighbors_detail(self, interface=''):\n        lldp = {}\n        lldp_neighbors = self.get_lldp_neighbors()\n\n        # Filter to specific interface\n        if interface:\n            lldp_data = lldp_neighbors.get(interface)\n            if lldp_data:\n                lldp_neighbors = {interface: lldp_data}\n            else:\n                lldp_neighbors = {}\n\n        for interface in lldp_neighbors:\n            local_port = interface\n            lldp_fields = self._lldp_detail_parser(interface)\n            # Convert any 'not advertised' to 'N/A'\n            for field in lldp_fields:\n                for i, value in enumerate(field):\n                    if 'not advertised' in value:\n                        field[i] = 'N/A'\n            number_entries = len(lldp_fields[0])\n\n            # re.findall will return a list. Make sure same number of entries always returned.\n            for test_list in lldp_fields:\n                if len(test_list) != number_entries:\n                    raise ValueError(\"Failure processing show lldp neighbors detail\")\n\n            # Standardize the fields\n            port_id, port_description, chassis_id, system_name, system_description, \\\n                system_capabilities, enabled_capabilities, remote_address = lldp_fields\n            standardized_fields = zip(port_id, port_description, chassis_id, system_name,\n                                      system_description, system_capabilities,\n                                      enabled_capabilities, remote_address)\n\n            lldp.setdefault(local_port, [])\n            for entry in standardized_fields:\n                remote_port_id, remote_port_description, remote_chassis_id, remote_system_name, \\\n                    remote_system_description, remote_system_capab, remote_enabled_capab, \\\n                    remote_mgmt_address = entry\n\n                lldp[local_port].append({\n                    'parent_interface': u'N/A',\n                    'remote_port': remote_port_id,\n                    'remote_port_description': remote_port_description,\n                    'remote_chassis_id': remote_chassis_id,\n                    'remote_system_name': remote_system_name,\n                    'remote_system_description': remote_system_description,\n                    'remote_system_capab': remote_system_capab,\n                    'remote_system_enable_capab': remote_enabled_capab})\n\n        return lldp", "response": "Get the lldp neighbors detail."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_facts(self):\n        # default values.\n        vendor = u'Cisco'\n        uptime = -1\n        serial_number, fqdn, os_version, hostname, domain_name = ('Unknown',) * 5\n\n        # obtain output from device\n        show_ver = self._send_command('show version')\n        show_hosts = self._send_command('show hosts')\n        show_ip_int_br = self._send_command('show ip interface brief')\n\n        # uptime/serial_number/IOS version\n        for line in show_ver.splitlines():\n            if ' uptime is ' in line:\n                hostname, uptime_str = line.split(' uptime is ')\n                uptime = self.parse_uptime(uptime_str)\n                hostname = hostname.strip()\n\n            if 'Processor board ID' in line:\n                _, serial_number = line.split(\"Processor board ID \")\n                serial_number = serial_number.strip()\n\n            if re.search(r\"Cisco IOS Software\", line):\n                try:\n                    _, os_version = line.split(\"Cisco IOS Software, \")\n                except ValueError:\n                    # Handle 'Cisco IOS Software [Denali],'\n                    _, os_version = re.split(r\"Cisco IOS Software \\[.*?\\], \", line)\n                os_version = os_version.strip()\n            elif re.search(r\"IOS (tm).+Software\", line):\n                _, os_version = line.split(\"IOS (tm) \")\n                os_version = os_version.strip()\n\n        # Determine domain_name and fqdn\n        for line in show_hosts.splitlines():\n            if 'Default domain' in line:\n                _, domain_name = line.split(\"Default domain is \")\n                domain_name = domain_name.strip()\n                break\n        if domain_name != 'Unknown' and hostname != 'Unknown':\n            fqdn = u'{}.{}'.format(hostname, domain_name)\n\n        # model filter\n        try:\n            match_model = re.search(r\"Cisco (.+?) .+bytes of\", show_ver, flags=re.IGNORECASE)\n            model = match_model.group(1)\n        except AttributeError:\n            model = u'Unknown'\n\n        # interface_list filter\n        interface_list = []\n        show_ip_int_br = show_ip_int_br.strip()\n        for line in show_ip_int_br.splitlines():\n            if 'Interface ' in line:\n                continue\n            interface = line.split()[0]\n            interface_list.append(interface)\n\n        return {\n            'uptime': uptime,\n            'vendor': vendor,\n            'os_version': py23_compat.text_type(os_version),\n            'serial_number': py23_compat.text_type(serial_number),\n            'model': py23_compat.text_type(model),\n            'hostname': py23_compat.text_type(hostname),\n            'fqdn': fqdn,\n            'interface_list': interface_list\n        }", "response": "Return a set of facts from the devices."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_interfaces(self):\n        # default values.\n        last_flapped = -1.0\n\n        command = 'show interfaces'\n        output = self._send_command(command)\n\n        interface = description = mac_address = speed = speedformat = ''\n        is_enabled = is_up = None\n\n        interface_dict = {}\n        for line in output.splitlines():\n\n            interface_regex_1 = r\"^(\\S+?)\\s+is\\s+(.+?),\\s+line\\s+protocol\\s+is\\s+(\\S+)\"\n            interface_regex_2 = r\"^(\\S+)\\s+is\\s+(up|down)\"\n            for pattern in (interface_regex_1, interface_regex_2):\n                interface_match = re.search(pattern, line)\n                if interface_match:\n                    interface = interface_match.group(1)\n                    status = interface_match.group(2)\n                    try:\n                        protocol = interface_match.group(3)\n                    except IndexError:\n                        protocol = ''\n                    if 'admin' in status.lower():\n                        is_enabled = False\n                    else:\n                        is_enabled = True\n                    if protocol:\n                        is_up = bool('up' in protocol)\n                    else:\n                        is_up = bool('up' in status)\n                    break\n\n            mac_addr_regex = r\"^\\s+Hardware.+address\\s+is\\s+({})\".format(MAC_REGEX)\n            if re.search(mac_addr_regex, line):\n                mac_addr_match = re.search(mac_addr_regex, line)\n                mac_address = napalm_base.helpers.mac(mac_addr_match.groups()[0])\n\n            descr_regex = \"^\\s+Description:\\s+(.+?)$\"\n            if re.search(descr_regex, line):\n                descr_match = re.search(descr_regex, line)\n                description = descr_match.groups()[0]\n\n            speed_regex = r\"^\\s+MTU\\s+\\d+.+BW\\s+(\\d+)\\s+([KMG]?b)\"\n            if re.search(speed_regex, line):\n                speed_match = re.search(speed_regex, line)\n                speed = speed_match.groups()[0]\n                speedformat = speed_match.groups()[1]\n                speed = float(speed)\n                if speedformat.startswith('Kb'):\n                    speed = speed / 1000.0\n                elif speedformat.startswith('Gb'):\n                    speed = speed * 1000\n                speed = int(round(speed))\n\n                if interface == '':\n                    raise ValueError(\"Interface attributes were \\\n                                      found without any known interface\")\n                if not isinstance(is_up, bool) or not isinstance(is_enabled, bool):\n                    raise ValueError(\"Did not correctly find the interface status\")\n\n                interface_dict[interface] = {'is_enabled': is_enabled, 'is_up': is_up,\n                                             'description': description, 'mac_address': mac_address,\n                                             'last_flapped': last_flapped, 'speed': speed}\n\n                interface = description = mac_address = speed = speedformat = ''\n                is_enabled = is_up = None\n\n        return interface_dict", "response": "Get the list of interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interfaces_ip(self):\n        interfaces = {}\n\n        command = 'show ip interface'\n        show_ip_interface = self._send_command(command)\n        command = 'show ipv6 interface'\n        show_ipv6_interface = self._send_command(command)\n\n        INTERNET_ADDRESS = r'\\s+(?:Internet address is|Secondary address)'\n        INTERNET_ADDRESS += r' (?P<ip>{})/(?P<prefix>\\d+)'.format(IPV4_ADDR_REGEX)\n        LINK_LOCAL_ADDRESS = r'\\s+IPv6 is enabled, link-local address is (?P<ip>[a-fA-F0-9:]+)'\n        GLOBAL_ADDRESS = r'\\s+(?P<ip>[a-fA-F0-9:]+), subnet is (?:[a-fA-F0-9:]+)/(?P<prefix>\\d+)'\n\n        interfaces = {}\n        for line in show_ip_interface.splitlines():\n            if(len(line.strip()) == 0):\n                continue\n            if(line[0] != ' '):\n                ipv4 = {}\n                interface_name = line.split()[0]\n            m = re.match(INTERNET_ADDRESS, line)\n            if m:\n                ip, prefix = m.groups()\n                ipv4.update({ip: {\"prefix_length\": int(prefix)}})\n                interfaces[interface_name] = {'ipv4': ipv4}\n\n        for line in show_ipv6_interface.splitlines():\n            if(len(line.strip()) == 0):\n                continue\n            if(line[0] != ' '):\n                ifname = line.split()[0]\n                ipv6 = {}\n                if ifname not in interfaces:\n                    interfaces[ifname] = {'ipv6': ipv6}\n                else:\n                    interfaces[ifname].update({'ipv6': ipv6})\n            m = re.match(LINK_LOCAL_ADDRESS, line)\n            if m:\n                ip = m.group(1)\n                ipv6.update({ip: {\"prefix_length\": 10}})\n            m = re.match(GLOBAL_ADDRESS, line)\n            if m:\n                ip, prefix = m.groups()\n                ipv6.update({ip: {\"prefix_length\": int(prefix)}})\n\n        # Interface without ipv6 doesn't appears in show ipv6 interface\n        return interfaces", "response": "Get interface ip details."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert string time to seconds.", "response": "def bgp_time_conversion(bgp_uptime):\n        \"\"\"\n        Convert string time to seconds.\n\n        Examples\n        00:14:23\n        00:13:40\n        00:00:21\n        00:00:13\n        00:00:49\n        1d11h\n        1d17h\n        1w0d\n        8w5d\n        1y28w\n        never\n        \"\"\"\n        bgp_uptime = bgp_uptime.strip()\n        uptime_letters = set(['w', 'h', 'd'])\n\n        if 'never' in bgp_uptime:\n            return -1\n        elif ':' in bgp_uptime:\n            times = bgp_uptime.split(\":\")\n            times = [int(x) for x in times]\n            hours, minutes, seconds = times\n            return (hours * 3600) + (minutes * 60) + seconds\n        # Check if any letters 'w', 'h', 'd' are in the time string\n        elif uptime_letters & set(bgp_uptime):\n            form1 = r'(\\d+)d(\\d+)h'  # 1d17h\n            form2 = r'(\\d+)w(\\d+)d'  # 8w5d\n            form3 = r'(\\d+)y(\\d+)w'  # 1y28w\n            match = re.search(form1, bgp_uptime)\n            if match:\n                days = int(match.group(1))\n                hours = int(match.group(2))\n                return (days * DAY_SECONDS) + (hours * 3600)\n            match = re.search(form2, bgp_uptime)\n            if match:\n                weeks = int(match.group(1))\n                days = int(match.group(2))\n                return (weeks * WEEK_SECONDS) + (days * DAY_SECONDS)\n            match = re.search(form3, bgp_uptime)\n            if match:\n                years = int(match.group(1))\n                weeks = int(match.group(2))\n                return (years * YEAR_SECONDS) + (weeks * WEEK_SECONDS)\n        raise ValueError(\"Unexpected value for BGP uptime string: {}\".format(bgp_uptime))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget BGP neighbor information.", "response": "def get_bgp_neighbors(self):\n        \"\"\"BGP neighbor information.\n\n        Currently no VRF support. Supports both IPv4 and IPv6.\n        \"\"\"\n        supported_afi = ['ipv4', 'ipv6']\n\n        bgp_neighbor_data = dict()\n        bgp_neighbor_data['global'] = {}\n\n        # get summary output from device\n        cmd_bgp_all_sum = 'show bgp all summary'\n        summary_output = self._send_command(cmd_bgp_all_sum).strip()\n\n        # get neighbor output from device\n        neighbor_output = ''\n        for afi in supported_afi:\n            cmd_bgp_neighbor = 'show bgp %s unicast neighbors' % afi\n            neighbor_output += self._send_command(cmd_bgp_neighbor).strip()\n            # trailing newline required for parsing\n            neighbor_output += \"\\n\"\n\n        # Regular expressions used for parsing BGP summary\n        parse_summary = {\n            'patterns': [\n                # For address family: IPv4 Unicast\n                {'regexp': re.compile(r'^For address family: (?P<afi>\\S+) '),\n                 'record': False},\n                # Capture router_id and local_as values, e.g.:\n                # BGP router identifier 10.0.1.1, local AS number 65000\n                {'regexp': re.compile(r'^.* router identifier (?P<router_id>{}), '\n                                      r'local AS number (?P<local_as>{})'.format(\n                                            IPV4_ADDR_REGEX, ASN_REGEX\n                                      )),\n                 'record': False},\n                # Match neighbor summary row, capturing useful details and\n                # discarding the 5 columns that we don't care about, e.g.:\n                # Neighbor   V          AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd\n                # 10.0.0.2   4       65000 1336020 64337701 1011343614    0    0 8w0d         3143\n                {'regexp': re.compile(r'^\\*?(?P<remote_addr>({})|({}))'\n                                      r'\\s+\\d+\\s+(?P<remote_as>{})(\\s+\\S+){{5}}\\s+'\n                                      r'(?P<uptime>(never)|\\d+\\S+)'\n                                      r'\\s+(?P<accepted_prefixes>\\d+)'.format(\n                                            IPV4_ADDR_REGEX, IPV6_ADDR_REGEX, ASN_REGEX\n                                      )),\n                 'record': True},\n                # Same as above, but for peer that are not Established, e.g.:\n                # Neighbor      V       AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd\n                # 192.168.0.2   4    65002       0       0        1    0    0 never    Active\n                {'regexp': re.compile(r'^\\*?(?P<remote_addr>({})|({}))'\n                                      r'\\s+\\d+\\s+(?P<remote_as>{})(\\s+\\S+){{5}}\\s+'\n                                      r'(?P<uptime>(never)|\\d+\\S+)\\s+(?P<state>\\D.*)'.format(\n                                            IPV4_ADDR_REGEX, IPV6_ADDR_REGEX, ASN_REGEX\n                                      )),\n                 'record': True},\n                # ipv6 peers often break accross rows because of the longer peer address,\n                # match as above, but in separate expressions, e.g.:\n                # Neighbor      V       AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd\n                # 2001:DB8::4\n                #               4    65004 9900690  612449 155362939    0    0 26w6d       36391\n                {'regexp': re.compile(r'^\\*?(?P<remote_addr>({})|({}))'.format(\n                                            IPV4_ADDR_REGEX, IPV6_ADDR_REGEX\n                                     )),\n                 'record': False},\n                {'regexp': re.compile(r'^\\s+\\d+\\s+(?P<remote_as>{})(\\s+\\S+){{5}}\\s+'\n                                      r'(?P<uptime>(never)|\\d+\\S+)'\n                                      r'\\s+(?P<accepted_prefixes>\\d+)'.format(\n                                            ASN_REGEX\n                                      )),\n                 'record': True},\n                # Same as above, but for peers that are not Established, e.g.:\n                # Neighbor      V       AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd\n                # 2001:DB8::3\n                #               4    65003       0       0        1    0    0 never    Idle (Admin)\n                {'regexp': re.compile(r'^\\s+\\d+\\s+(?P<remote_as>{})(\\s+\\S+){{5}}\\s+'\n                                      r'(?P<uptime>(never)|\\d+\\S+)\\s+(?P<state>\\D.*)'.format(\n                                            ASN_REGEX\n                                      )),\n                 'record': True}\n            ],\n            'no_fill_fields': ['accepted_prefixes', 'state', 'uptime', 'remote_as', 'remote_addr']\n        }\n\n        parse_neighbors = {\n            'patterns': [\n                # Capture BGP neighbor is 10.0.0.2,  remote AS 65000, internal link\n                {'regexp': re.compile(r'^BGP neighbor is (?P<remote_addr>({})|({})),'\n                                      r'\\s+remote AS (?P<remote_as>{}).*'.format(\n                                            IPV4_ADDR_REGEX, IPV6_ADDR_REGEX, ASN_REGEX\n                                      )),\n                 'record': False},\n                # Capture description\n                {'regexp': re.compile(r'^\\s+Description: (?P<description>.+)'),\n                 'record': False},\n                # Capture remote_id, e.g.:\n                # BGP version 4, remote router ID 10.0.1.2\n                {'regexp': re.compile(r'^\\s+BGP version \\d+, remote router ID '\n                                      r'(?P<remote_id>{})'.format(IPV4_ADDR_REGEX)),\n                 'record': False},\n                # Capture AFI and SAFI names, e.g.:\n                # For address family: IPv4 Unicast\n                {'regexp': re.compile(r'^\\s+For address family: (?P<afi>\\S+) '),\n                 'record': False},\n                # Capture current sent and accepted prefixes, e.g.:\n                #     Prefixes Current:          637213       3142 (Consumes 377040 bytes)\n                {'regexp': re.compile(r'^\\s+Prefixes Current:\\s+(?P<sent_prefixes>\\d+)\\s+'\n                                      r'(?P<accepted_prefixes>\\d+).*'),\n                 'record': False},\n                # Capture received_prefixes if soft-reconfig is enabled for the peer\n                {'regexp': re.compile(r'^\\s+Saved (soft-reconfig):.+(?P<received_prefixes>\\d+).*'),\n                 'record': True},\n                # Otherwise, use the following as an end of row marker\n                {'regexp': re.compile(r'^\\s+Local Policy Denied Prefixes:.+'),\n                 'record': True}\n            ],\n            # fields that should not be \"filled down\" across table rows\n            'no_fill_fields': ['received_prefixes', 'accepted_prefixes', 'sent_prefixes']\n        }\n\n        # Parse outputs into a list of dicts\n        summary_data = []\n        summary_data_entry = {}\n\n        for line in summary_output.splitlines():\n            # check for matches against each pattern\n            for item in parse_summary['patterns']:\n                match = item['regexp'].match(line)\n                if match:\n                    # a match was found, so update the temp entry with the match's groupdict\n                    summary_data_entry.update(match.groupdict())\n                    if item['record']:\n                        # Record indicates the last piece of data has been obtained; move\n                        # on to next entry\n                        summary_data.append(copy.deepcopy(summary_data_entry))\n                        # remove keys that are listed in no_fill_fields before the next pass\n                        for field in parse_summary['no_fill_fields']:\n                            try:\n                                del summary_data_entry[field]\n                            except KeyError:\n                                pass\n                    break\n\n        neighbor_data = []\n        neighbor_data_entry = {}\n        for line in neighbor_output.splitlines():\n            # check for matches against each pattern\n            for item in parse_neighbors['patterns']:\n                match = item['regexp'].match(line)\n                if match:\n                    # a match was found, so update the temp entry with the match's groupdict\n                    neighbor_data_entry.update(match.groupdict())\n                    if item['record']:\n                        # Record indicates the last piece of data has been obtained; move\n                        # on to next entry\n                        neighbor_data.append(copy.deepcopy(neighbor_data_entry))\n                        # remove keys that are listed in no_fill_fields before the next pass\n                        for field in parse_neighbors['no_fill_fields']:\n                            try:\n                                del neighbor_data_entry[field]\n                            except KeyError:\n                                pass\n                    break\n\n        router_id = None\n\n        for entry in summary_data:\n            if not router_id:\n                router_id = entry['router_id']\n            elif entry['router_id'] != router_id:\n                raise ValueError\n\n        # check the router_id looks like an ipv4 address\n        router_id = napalm_base.helpers.ip(router_id, version=4)\n\n        # add parsed data to output dict\n        bgp_neighbor_data['global']['router_id'] = router_id\n        bgp_neighbor_data['global']['peers'] = {}\n        for entry in summary_data:\n            remote_addr = napalm_base.helpers.ip(entry['remote_addr'])\n            afi = entry['afi'].lower()\n            # check that we're looking at a supported afi\n            if afi not in supported_afi:\n                continue\n            # get neighbor_entry out of neighbor data\n            neighbor_entry = None\n            for neighbor in neighbor_data:\n                if (neighbor['afi'].lower() == afi and\n                        napalm_base.helpers.ip(neighbor['remote_addr']) == remote_addr):\n                    neighbor_entry = neighbor\n                    break\n            if not isinstance(neighbor_entry, dict):\n                raise ValueError(msg=\"Couldn't find neighbor data for %s in afi %s\" %\n                                     (remote_addr, afi))\n\n            # check for admin down state\n            try:\n                if \"(Admin)\" in entry['state']:\n                    is_enabled = False\n                else:\n                    is_enabled = True\n            except KeyError:\n                is_enabled = True\n\n            # parse uptime value\n            uptime = self.bgp_time_conversion(entry['uptime'])\n\n            # Uptime should be -1 if BGP session not up\n            is_up = True if uptime >= 0 else False\n\n            # check whether session is up for address family and get prefix count\n            try:\n                accepted_prefixes = int(entry['accepted_prefixes'])\n            except (ValueError, KeyError):\n                accepted_prefixes = -1\n\n            # Only parse neighbor detailed data if BGP session is-up\n            if is_up:\n                try:\n                    # overide accepted_prefixes with neighbor data if possible (since that's newer)\n                    accepted_prefixes = int(neighbor_entry['accepted_prefixes'])\n                except (ValueError, KeyError):\n                    pass\n\n                # try to get received prefix count, otherwise set to accepted_prefixes\n                received_prefixes = neighbor_entry.get('received_prefixes', accepted_prefixes)\n\n                # try to get sent prefix count and convert to int, otherwise set to -1\n                sent_prefixes = int(neighbor_entry.get('sent_prefixes', -1))\n            else:\n                received_prefixes = -1\n                sent_prefixes = -1\n\n            # get description\n            try:\n                description = py23_compat.text_type(neighbor_entry['description'])\n            except KeyError:\n                description = ''\n\n            # check the remote router_id looks like an ipv4 address\n            remote_id = napalm_base.helpers.ip(neighbor_entry['remote_id'], version=4)\n\n            if remote_addr not in bgp_neighbor_data['global']['peers']:\n                bgp_neighbor_data['global']['peers'][remote_addr] = {\n                    'local_as': napalm_base.helpers.as_number(entry['local_as']),\n                    'remote_as': napalm_base.helpers.as_number(entry['remote_as']),\n                    'remote_id': remote_id,\n                    'is_up': is_up,\n                    'is_enabled': is_enabled,\n                    'description': description,\n                    'uptime': uptime,\n                    'address_family': {\n                        afi: {\n                            'received_prefixes': received_prefixes,\n                            'accepted_prefixes': accepted_prefixes,\n                            'sent_prefixes': sent_prefixes\n                        }\n                    }\n                }\n            else:\n                # found previous data for matching remote_addr, but for different afi\n                existing = bgp_neighbor_data['global']['peers'][remote_addr]\n                assert afi not in existing['address_family']\n                # compare with existing values and croak if they don't match\n                assert existing['local_as'] == napalm_base.helpers.as_number(entry['local_as'])\n                assert existing['remote_as'] == napalm_base.helpers.as_number(entry['remote_as'])\n                assert existing['remote_id'] == remote_id\n                assert existing['is_enabled'] == is_enabled\n                assert existing['description'] == description\n                # merge other values in a sane manner\n                existing['is_up'] = existing['is_up'] or is_up\n                existing['uptime'] = max(existing['uptime'], uptime)\n                existing['address_family'][afi] = {\n                    'received_prefixes': received_prefixes,\n                    'accepted_prefixes': accepted_prefixes,\n                    'sent_prefixes': sent_prefixes\n                }\n        return bgp_neighbor_data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_environment(self):\n        environment = {}\n        cpu_cmd = 'show proc cpu'\n        mem_cmd = 'show memory statistics'\n        temp_cmd = 'show env temperature status'\n\n        output = self._send_command(cpu_cmd)\n        environment.setdefault('cpu', {})\n        environment['cpu'][0] = {}\n        environment['cpu'][0]['%usage'] = 0.0\n        for line in output.splitlines():\n            if 'CPU utilization' in line:\n                # CPU utilization for five seconds: 2%/0%; one minute: 2%; five minutes: 1%\n                cpu_regex = r'^.*one minute: (\\d+)%; five.*$'\n                match = re.search(cpu_regex, line)\n                environment['cpu'][0]['%usage'] = float(match.group(1))\n                break\n\n        output = self._send_command(mem_cmd)\n        for line in output.splitlines():\n            if 'Processor' in line:\n                _, _, _, proc_used_mem, proc_free_mem = line.split()[:5]\n            elif 'I/O' in line or 'io' in line:\n                _, _, _, io_used_mem, io_free_mem = line.split()[:5]\n        used_mem = int(proc_used_mem) + int(io_used_mem)\n        free_mem = int(proc_free_mem) + int(io_free_mem)\n        environment.setdefault('memory', {})\n        environment['memory']['used_ram'] = used_mem\n        environment['memory']['available_ram'] = free_mem\n\n        environment.setdefault('temperature', {})\n        # The 'show env temperature status' is not ubiquitous in Cisco IOS\n        output = self._send_command(temp_cmd)\n        if '% Invalid' not in output:\n            for line in output.splitlines():\n                if 'System Temperature Value' in line:\n                    system_temp = float(line.split(':')[1].split()[0])\n                elif 'Yellow Threshold' in line:\n                    system_temp_alert = float(line.split(':')[1].split()[0])\n                elif 'Red Threshold' in line:\n                    system_temp_crit = float(line.split(':')[1].split()[0])\n            env_value = {'is_alert': system_temp >= system_temp_alert,\n                         'is_critical': system_temp >= system_temp_crit, 'temperature': system_temp}\n            environment['temperature']['system'] = env_value\n        else:\n            env_value = {'is_alert': False, 'is_critical': False, 'temperature': -1.0}\n            environment['temperature']['invalid'] = env_value\n\n        # Initialize 'power' and 'fan' to default values (not implemented)\n        environment.setdefault('power', {})\n        environment['power']['invalid'] = {'status': True, 'output': -1.0, 'capacity': -1.0}\n        environment.setdefault('fans', {})\n        environment['fans']['invalid'] = {'status': True}\n\n        return environment", "response": "Get the environment of the current system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_arp_table(self):\n        arp_table = []\n\n        command = 'show arp | exclude Incomplete'\n        output = self._send_command(command)\n\n        # Skip the first line which is a header\n        output = output.split('\\n')\n        output = output[1:]\n\n        for line in output:\n            if len(line) == 0:\n                return {}\n            if len(line.split()) == 5:\n                # Static ARP entries have no interface\n                # Internet  10.0.0.1                -   0010.2345.1cda  ARPA\n                interface = ''\n                protocol, address, age, mac, eth_type = line.split()\n            elif len(line.split()) == 6:\n                protocol, address, age, mac, eth_type, interface = line.split()\n            else:\n                raise ValueError(\"Unexpected output from: {}\".format(line.split()))\n\n            try:\n                if age == '-':\n                    age = 0\n                age = float(age)\n            except ValueError:\n                raise ValueError(\"Unable to convert age value to float: {}\".format(age))\n\n            # Validate we matched correctly\n            if not re.search(RE_IPADDR, address):\n                raise ValueError(\"Invalid IP Address detected: {}\".format(address))\n            if not re.search(RE_MAC, mac):\n                raise ValueError(\"Invalid MAC Address detected: {}\".format(mac))\n            entry = {\n                'interface': interface,\n                'mac': napalm_base.helpers.mac(mac),\n                'ip': address,\n                'age': age\n            }\n            arp_table.append(entry)\n        return arp_table", "response": "Get the arp table information."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a list of commands and return the output in a dictionary format using the command as the key.", "response": "def cli(self, commands):\n        \"\"\"\n        Execute a list of commands and return the output in a dictionary format using the command\n        as the key.\n\n        Example input:\n        ['show clock', 'show calendar']\n\n        Output example:\n        {   'show calendar': u'22:02:01 UTC Thu Feb 18 2016',\n            'show clock': u'*22:01:51.165 UTC Thu Feb 18 2016'}\n\n        \"\"\"\n        cli_output = dict()\n        if type(commands) is not list:\n            raise TypeError('Please enter a valid list of commands!')\n\n        for command in commands:\n            output = self._send_command(command)\n            if 'Invalid input detected' in output:\n                raise ValueError('Unable to execute command \"{}\"'.format(command))\n            cli_output.setdefault(command, {})\n            cli_output[command] = output\n\n        return cli_output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of dictionaries representing the MAC Address Table and the MAC Address Types of the Mac Address.", "response": "def get_mac_address_table(self):\n        \"\"\"\n        Returns a lists of dictionaries. Each dictionary represents an entry in the MAC Address\n        Table, having the following keys\n            * mac (string)\n            * interface (string)\n            * vlan (int)\n            * active (boolean)\n            * static (boolean)\n            * moves (int)\n            * last_move (float)\n\n        Format1:\n        Destination Address  Address Type  VLAN  Destination Port\n        -------------------  ------------  ----  --------------------\n        6400.f1cf.2cc6          Dynamic       1     Wlan-GigabitEthernet0\n\n        Cat 6500:\n        Legend: * - primary entry\n                age - seconds since last seen\n                n/a - not available\n\n          vlan   mac address     type    learn     age              ports\n        ------+----------------+--------+-----+----------+--------------------------\n        *  999  1111.2222.3333   dynamic  Yes          0   Port-channel1\n           999  1111.2222.3333   dynamic  Yes          0   Port-channel1\n\n        Cat 4948\n        Unicast Entries\n         vlan   mac address     type        protocols               port\n        -------+---------------+--------+---------------------+--------------------\n         999    1111.2222.3333   dynamic ip                    Port-channel1\n\n        Cat 2960\n        Mac Address Table\n        -------------------------------------------\n\n        Vlan    Mac Address       Type        Ports\n        ----    -----------       --------    -----\n        All    1111.2222.3333    STATIC      CPU\n        \"\"\"\n\n        RE_MACTABLE_DEFAULT = r\"^\" + MAC_REGEX\n        RE_MACTABLE_6500_1 = r\"^\\*\\s+{}\\s+{}\\s+\".format(VLAN_REGEX, MAC_REGEX)  # 7 fields\n        RE_MACTABLE_6500_2 = r\"^{}\\s+{}\\s+\".format(VLAN_REGEX, MAC_REGEX)   # 6 fields\n        RE_MACTABLE_6500_3 = r\"^\\s{51}\\S+\"                               # Fill down from prior\n        RE_MACTABLE_4500_1 = r\"^{}\\s+{}\\s+\".format(VLAN_REGEX, MAC_REGEX)     # 5 fields\n        RE_MACTABLE_4500_2 = r\"^\\s{32}\\S+\"                               # Fill down from prior\n        RE_MACTABLE_2960_1 = r\"^All\\s+{}\".format(MAC_REGEX)\n        RE_MACTABLE_GEN_1 = r\"^{}\\s+{}\\s+\".format(VLAN_REGEX, MAC_REGEX)   # 4 fields (2960/4500)\n\n        def process_mac_fields(vlan, mac, mac_type, interface):\n            \"\"\"Return proper data for mac address fields.\"\"\"\n            if mac_type.lower() in ['self', 'static', 'system']:\n                static = True\n                if vlan.lower() == 'all':\n                    vlan = 0\n                if interface.lower() == 'cpu' or re.search(r'router', interface.lower()) or \\\n                        re.search(r'switch', interface.lower()):\n                    interface = ''\n            else:\n                static = False\n            if mac_type.lower() in ['dynamic']:\n                active = True\n            else:\n                active = False\n            return {\n                'mac': napalm_base.helpers.mac(mac),\n                'interface': interface,\n                'vlan': int(vlan),\n                'static': static,\n                'active': active,\n                'moves': -1,\n                'last_move': -1.0\n            }\n\n        mac_address_table = []\n        command = IOS_COMMANDS['show_mac_address']\n        output = self._send_command(command)\n\n        # Skip the header lines\n        output = re.split(r'^----.*', output, flags=re.M)[1:]\n        output = \"\\n\".join(output).strip()\n        # Strip any leading astericks\n        output = re.sub(r\"^\\*\", \"\", output, flags=re.M)\n        fill_down_vlan = fill_down_mac = fill_down_mac_type = ''\n        for line in output.splitlines():\n            # Cat6500 one off anf 4500 multicast format\n            if (re.search(RE_MACTABLE_6500_3, line) or re.search(RE_MACTABLE_4500_2, line)):\n                interface = line.strip()\n                if ',' in interface:\n                    interfaces = interface.split(',')\n                else:\n                    interfaces = []\n                    interfaces.append(interface)\n                for single_interface in interfaces:\n                    mac_address_table.append(process_mac_fields(fill_down_vlan, fill_down_mac,\n                                                                fill_down_mac_type,\n                                                                single_interface))\n                continue\n            line = line.strip()\n            if line == '':\n                continue\n            if re.search(r\"^---\", line):\n                # Convert any '---' to VLAN 0\n                line = re.sub(r\"^---\", \"0\", line, flags=re.M)\n\n            # Format1\n            if re.search(RE_MACTABLE_DEFAULT, line):\n                if len(line.split()) == 4:\n                    mac, mac_type, vlan, interface = line.split()\n                    mac_address_table.append(process_mac_fields(vlan, mac, mac_type, interface))\n                else:\n                    raise ValueError(\"Unexpected output from: {}\".format(line.split()))\n            # Cat6500 format\n            elif (re.search(RE_MACTABLE_6500_1, line) or re.search(RE_MACTABLE_6500_2, line)) and \\\n                    len(line.split()) >= 6:\n                if len(line.split()) == 7:\n                    _, vlan, mac, mac_type, _, _, interface = line.split()\n                elif len(line.split()) == 6:\n                    vlan, mac, mac_type, _, _, interface = line.split()\n                if ',' in interface:\n                    interfaces = interface.split(',')\n                    fill_down_vlan = vlan\n                    fill_down_mac = mac\n                    fill_down_mac_type = mac_type\n                    for single_interface in interfaces:\n                        mac_address_table.append(process_mac_fields(vlan, mac, mac_type,\n                                                                    single_interface))\n                else:\n                    mac_address_table.append(process_mac_fields(vlan, mac, mac_type, interface))\n            # Cat4500 format\n            elif re.search(RE_MACTABLE_4500_1, line) and len(line.split()) == 5:\n                vlan, mac, mac_type, _, interface = line.split()\n                mac_address_table.append(process_mac_fields(vlan, mac, mac_type, interface))\n            # Cat2960 format - ignore extra header line\n            elif re.search(r\"^Vlan\\s+Mac Address\\s+\", line):\n                continue\n            # Cat2960 format (Cat4500 format multicast entries)\n            elif (re.search(RE_MACTABLE_2960_1, line) or re.search(RE_MACTABLE_GEN_1, line)) and \\\n                    len(line.split()) == 4:\n                vlan, mac, mac_type, interface = line.split()\n                if ',' in interface:\n                    interfaces = interface.split(',')\n                    fill_down_vlan = vlan\n                    fill_down_mac = mac\n                    fill_down_mac_type = mac_type\n                    for single_interface in interfaces:\n                        mac_address_table.append(process_mac_fields(vlan, mac, mac_type,\n                                                                    single_interface))\n                else:\n                    mac_address_table.append(process_mac_fields(vlan, mac, mac_type, interface))\n            elif re.search(r\"Total Mac Addresses\", line):\n                continue\n            elif re.search(r\"Multicast Entries\", line):\n                continue\n            elif re.search(r\"vlan.*mac.*address.*type.*\", line):\n                continue\n            else:\n                raise ValueError(\"Unexpected output from: {}\".format(repr(line)))\n\n        return mac_address_table"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a traceroute command on the device and returns a dictionary with the result.", "response": "def traceroute(self, destination, source=C.TRACEROUTE_SOURCE,\n                   ttl=C.TRACEROUTE_TTL, timeout=C.TRACEROUTE_TIMEOUT, vrf=C.TRACEROUTE_VRF):\n        \"\"\"\n        Executes traceroute on the device and returns a dictionary with the result.\n\n        :param destination: Host or IP Address of the destination\n        :param source (optional): Use a specific IP Address to execute the traceroute\n        :param ttl (optional): Maimum number of hops -> int (0-255)\n        :param timeout (optional): Number of seconds to wait for response -> int (1-3600)\n\n        Output dictionary has one of the following keys:\n\n            * success\n            * error\n\n        In case of success, the keys of the dictionary represent the hop ID, while values are\n        dictionaries containing the probes results:\n            * rtt (float)\n            * ip_address (str)\n            * host_name (str)\n        \"\"\"\n\n        # vrf needs to be right after the traceroute command\n        if vrf:\n            command = \"traceroute vrf {} {}\".format(vrf, destination)\n        else:\n            command = \"traceroute {}\".format(destination)\n        if source:\n            command += \" source {}\".format(source)\n        if ttl:\n            if isinstance(ttl, int) and 0 <= timeout <= 255:\n                command += \" ttl 0 {}\".format(str(ttl))\n        if timeout:\n            # Timeout should be an integer between 1 and 3600\n            if isinstance(timeout, int) and 1 <= timeout <= 3600:\n                command += \" timeout {}\".format(str(timeout))\n\n        # Calculation to leave enough time for traceroute to complete assumes send_command\n        # delay of .2 seconds.\n        max_loops = (5 * ttl * timeout) + 150\n        if max_loops < 500:     # Make sure max_loops isn't set artificially low\n            max_loops = 500\n        output = self.device.send_command(command, max_loops=max_loops)\n\n        # Prepare return dict\n        traceroute_dict = dict()\n        if re.search('Unrecognized host or address', output):\n            traceroute_dict['error'] = 'unknown host %s' % destination\n            return traceroute_dict\n        else:\n            traceroute_dict['success'] = dict()\n\n        results = dict()\n        # Find all hops\n        hops = re.findall('\\\\n\\s+[0-9]{1,3}\\s', output)\n        for hop in hops:\n            # Search for hop in the output\n            hop_match = re.search(hop, output)\n            # Find the start index for hop\n            start_index = hop_match.start()\n            # If this is last hop\n            if hops.index(hop) + 1 == len(hops):\n                # Set the stop index for hop to len of output\n                stop_index = len(output)\n            # else, find the start index for next hop\n            else:\n                next_hop_match = re.search(hops[hops.index(hop) + 1], output)\n                stop_index = next_hop_match.start()\n                # Now you have the start and stop index for each hop\n                # and you can parse the probes\n            # Set the hop_variable, and remove spaces between msec for easier matching\n            hop_string = output[start_index:stop_index].replace(' msec', 'msec')\n            hop_list = hop_string.split()\n            current_hop = int(hop_list.pop(0))\n            # Prepare dictionary for each hop (assuming there are 3 probes in each hop)\n            results[current_hop] = dict()\n            results[current_hop]['probes'] = dict()\n            results[current_hop]['probes'][1] = {'rtt': float(),\n                                                 'ip_address': '',\n                                                 'host_name': ''}\n            results[current_hop]['probes'][2] = {'rtt': float(),\n                                                 'ip_address': '',\n                                                 'host_name': ''}\n            results[current_hop]['probes'][3] = {'rtt': float(),\n                                                 'ip_address': '',\n                                                 'host_name': ''}\n            current_probe = 1\n            ip_address = ''\n            host_name = ''\n            while hop_list:\n                current_element = hop_list.pop(0)\n                # If current_element is * move index in dictionary to next probe\n                if current_element == '*':\n                    current_probe += 1\n                # If current_element contains msec record the entry for probe\n                elif 'msec' in current_element:\n                    ip_address = py23_compat.text_type(ip_address)\n                    host_name = py23_compat.text_type(host_name)\n                    rtt = float(current_element.replace('msec', ''))\n                    results[current_hop]['probes'][current_probe]['ip_address'] = ip_address\n                    results[current_hop]['probes'][current_probe]['host_name'] = host_name\n                    results[current_hop]['probes'][current_probe]['rtt'] = rtt\n                    # After recording the entry move the index to next probe\n                    current_probe += 1\n                # If element contains '(' and ')', the output format is 'FQDN (IP_ADDRESS)'\n                # Save the IP address\n                elif '(' in current_element:\n                    ip_address = current_element.replace('(', '').replace(')', '')\n                # Save the probe's ip_address and host_name\n                else:\n                    host_name = current_element\n                    ip_address = current_element\n\n        traceroute_dict['success'] = results\n        return traceroute_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the range of the accelerometer.", "response": "def set_range(self, value):\n        \"\"\"Set the range of the accelerometer to the provided value.  Range value\n        should be one of these constants:\n          - ADXL345_RANGE_2_G   = +/-2G\n          - ADXL345_RANGE_4_G   = +/-4G\n          - ADXL345_RANGE_8_G   = +/-8G\n          - ADXL345_RANGE_16_G  = +/-16G\n        \"\"\"\n        # Read the data format register to preserve bits.  Update the data\n        # rate, make sure that the FULL-RES bit is enabled for range scaling\n        format_reg = self._device.readU8(ADXL345_REG_DATA_FORMAT) & ~0x0F\n        format_reg |= value\n        format_reg |= 0x08  # FULL-RES bit enabled\n        # Write the updated format register.\n        self._device.write8(ADXL345_REG_DATA_FORMAT, format_reg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self):\n        raw = self._device.readList(ADXL345_REG_DATAX0, 6)\n        return struct.unpack('<hhh', raw)", "response": "Read the current value of the accelerometer and return it as a tuple\n        of signed 16 - bit X Y Z axis values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deinit(bus=DEFAULT_SPI_BUS,\n           chip_select=DEFAULT_SPI_CHIP_SELECT):\n    \"\"\"Stops interrupts on all boards. Only required when using\n    :func:`digital_read` and :func:`digital_write`.\n\n    :param bus: SPI bus /dev/spidev<bus>.<chipselect> (default: {bus})\n    :type bus: int\n    :param chip_select: SPI chip select /dev/spidev<bus>.<chipselect>\n        (default: {chip})\n    :type chip_select: int\n    \"\"\"\n    global _pifacedigitals\n    for pfd in _pifacedigitals:\n        try:\n            pfd.deinit_board()\n        except AttributeError:\n            pass", "response": "Stops interrupts on all boards. Only required when using\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the value to the input pin specified.", "response": "def digital_write(pin_num, value, hardware_addr=0):\n    \"\"\"Writes the value to the input pin specified.\n\n    .. note:: This function is for familiarality with users of other types of\n       IO board. Consider accessing the ``output_pins`` attribute of a\n       PiFaceDigital object:\n\n       >>> pfd = PiFaceDigital(hardware_addr)\n       >>> pfd.output_pins[pin_num].value = 1\n\n    :param pin_num: The pin number to write to.\n    :type pin_num: int\n    :param value: The value to write.\n    :type value: int\n    :param hardware_addr: The board to read from (default: 0)\n    :type hardware_addr: int\n    \"\"\"\n    _get_pifacedigital(hardware_addr).output_pins[pin_num].value = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the value to the input pullup specified.", "response": "def digital_write_pullup(pin_num, value, hardware_addr=0):\n    \"\"\"Writes the value to the input pullup specified.\n\n    .. note:: This function is for familiarality with users of other types of\n       IO board. Consider accessing the ``gppub`` attribute of a\n       PiFaceDigital object:\n\n       >>> pfd = PiFaceDigital(hardware_addr)\n       >>> hex(pfd.gppub.value)\n       0xff\n       >>> pfd.gppub.bits[pin_num].value = 1\n\n    :param pin_num: The pin number to write to.\n    :type pin_num: int\n    :param value: The value to write.\n    :type value: int\n    :param hardware_addr: The board to read from (default: 0)\n    :type hardware_addr: int\n    \"\"\"\n    _get_pifacedigital(hardware_addr).gppub.bits[pin_num].value = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_my_ip():\n    ip = subprocess.check_output(GET_IP_CMD, shell=True).decode('utf-8')[:-1]\n    return ip.strip()", "response": "Returns this computers IP address as a string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the output port value to new_value defaults to old_value.", "response": "def set_output_port(self, new_value, old_value=0):\n        \"\"\"Sets the output port value to new_value, defaults to old_value.\"\"\"\n        print(\"Setting output port to {}.\".format(new_value))\n        port_value = old_value\n        try:\n            port_value = int(new_value)  # dec\n        except ValueError:\n            port_value = int(new_value, 16)  # hex\n        finally:\n            self.pifacedigital.output_port.value = port_value\n            return port_value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap the calls the url with the given arguments.", "response": "def _request_api(self, **kwargs):\n        \"\"\"Wrap the calls the url, with the given arguments.\n\n        :param str url: Url to call with the given arguments\n        :param str method: [POST | GET] Method to use on the request\n        :param int status: Expected status code\n        \"\"\"\n        _url = kwargs.get('url')\n        _method = kwargs.get('method', 'GET')\n        _status = kwargs.get('status', 200)\n\n        counter = 0\n        if _method not in ['GET', 'POST']:\n            raise ValueError('Method is not GET or POST')\n\n        while True:\n            try:\n                res = REQ[_method](_url, cookies=self._cookie)\n                if res.status_code == _status:\n                    break\n                else:\n                    raise BadStatusException(res.content)\n            except requests.exceptions.BaseHTTPError:\n                if counter < self._retries:\n                    counter += 1\n                    continue\n                raise MaxRetryError\n        self._last_result = res\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget info about a user based on his id.", "response": "def get_infos_with_id(self, uid):\n        \"\"\"Get info about a user based on his id.\n\n        :return: JSON\n        \"\"\"\n\n        _logid = uid\n        _user_info_url = USER_INFO_URL.format(logid=_logid)\n        return self._request_api(url=_user_info_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_current_activities(self, login=None, **kwargs):\n\n        _login = kwargs.get(\n            'login',\n            login or self._login\n        )\n        _activity_url = ACTIVITY_URL.format(login=_login)\n        return self._request_api(url=_activity_url).json()", "response": "Get the current activities of the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the current notifications of a user.", "response": "def get_notifications(self, login=None, **kwargs):\n        \"\"\"Get the current notifications of a user.\n\n        :return: JSON\n        \"\"\"\n\n        _login = kwargs.get(\n            'login',\n            login or self._login\n        )\n        _notif_url = NOTIF_URL.format(login=_login)\n        return self._request_api(url=_notif_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a user s grades on a single promotion based on his login.", "response": "def get_grades(self, login=None, promotion=None, **kwargs):\n        \"\"\"Get a user's grades on a single promotion based on his login.\n\n        Either use the `login` param, or the client's login if unset.\n        :return: JSON\n        \"\"\"\n\n        _login = kwargs.get(\n            'login',\n            login or self._login\n        )\n        _promotion_id = kwargs.get('promotion', promotion)\n        _grades_url = GRADES_URL.format(login=_login, promo_id=_promotion_id)\n        return self._request_api(url=_grades_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_picture(self, login=None, **kwargs):\n\n        _login = kwargs.get(\n            'login',\n            login or self._login\n        )\n        _activities_url = PICTURE_URL.format(login=_login)\n        return self._request_api(url=_activities_url).content", "response": "Get a user s picture."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a user s project.", "response": "def get_projects(self, **kwargs):\n        \"\"\"Get a user's project.\n\n        :param str login: User's login (Default: self._login)\n        :return: JSON\n        \"\"\"\n\n        _login = kwargs.get('login', self._login)\n        search_url = SEARCH_URL.format(login=_login)\n        return self._request_api(url=search_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the related activities of a project.", "response": "def get_activities_for_project(self, module=None, **kwargs):\n        \"\"\"Get the related activities of a project.\n\n        :param str module: Stages of a given module\n        :return: JSON\n        \"\"\"\n\n        _module_id = kwargs.get('module', module)\n        _activities_url = ACTIVITIES_URL.format(module_id=_module_id)\n        return self._request_api(url=_activities_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the groups for the activity.", "response": "def get_group_for_activity(self, module=None, project=None, **kwargs):\n        \"\"\"Get groups for activity.\n\n        :param str module: Base module\n        :param str module: Project which contains the group requested\n        :return: JSON\n        \"\"\"\n\n        _module_id = kwargs.get('module', module)\n        _project_id = kwargs.get('project', project)\n        _url = GROUPS_URL.format(module_id=_module_id, project_id=_project_id)\n        return self._request_api(url=_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget users by promotion id.", "response": "def get_students(self, **kwargs):\n        \"\"\"Get users by promotion id.\n\n        :param int promotion: Promotion ID\n        :return: JSON\n        \"\"\"\n\n        _promotion_id = kwargs.get('promotion')\n        _url = PROMOTION_URL.format(promo_id=_promotion_id)\n        return self._request_api(url=_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a user s log events.", "response": "def get_log_events(self, login=None, **kwargs):\n        \"\"\"Get a user's log events.\n\n        :param str login: User's login (Default: self._login)\n        :return: JSON\n        \"\"\"\n\n        _login = kwargs.get(\n            'login',\n            login\n        )\n        log_events_url = GSA_EVENTS_URL.format(login=_login)\n        return self._request_api(url=log_events_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_events(self, login=None, start_date=None, end_date=None, **kwargs):\n\n        _login = kwargs.get(\n            'login',\n            login\n        )\n        log_events_url = EVENTS_URL.format(\n            login=_login,\n            start_date=start_date,\n            end_date=end_date,\n        )\n        return self._request_api(url=log_events_url).json()", "response": "Get a user s events."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a user s logs.", "response": "def get_logs(self, login=None, **kwargs):\n        \"\"\"Get a user's logs.\n\n        :param str login: User's login (Default: self._login)\n        :return: JSON\n        \"\"\"\n\n        _login = kwargs.get(\n            'login',\n            login\n        )\n        log_events_url = GSA_LOGS_URL.format(login=_login)\n        return self._request_api(url=log_events_url).json()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef negotiate(cls, headers):\n        # set lower keys\n        headers = {k.lower(): v for k, v in headers.items()}\n\n        accept = headers.get('accept', \"*/*\")\n\n        parsed_accept = accept.split(\";\")\n        parsed_accept = [i.strip() for i in parsed_accept]\n\n        # Protobuffer (only one version)\n        if all([i in parsed_accept for i in cls.PROTOBUF['default']]):\n            return ProtobufFormat\n        elif all([i in parsed_accept for i in cls.PROTOBUF['text']]):\n            return ProtobufTextFormat\n        # Text 0.0.4\n        elif all([i in parsed_accept for i in cls.TEXT['0.0.4']]):\n            return TextFormat\n        # Text (Default)\n        elif all([i in parsed_accept for i in cls.TEXT['default']]):\n            return TextFormat\n        # Default\n        else:\n            return cls.FALLBACK", "response": "Process the headers dict to return the format class\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, collector):\n        if not isinstance(collector, Collector):\n            raise TypeError(\n                \"Can't register instance, not a valid type of collector\")\n\n        if collector.name in self.collectors:\n            raise ValueError(\"Collector already exists or name colision\")\n\n        with mutex:\n            self.collectors[collector.name] = collector", "response": "Registers a collector with the manager."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new entry to the registry.", "response": "def add(self, registry):\n        \"\"\" Add works like replace, but only previously pushed metrics with the\n            same name (and the same job and instance) will be replaced.\n            (It uses HTTP method 'POST' to push to the Pushgateway.)\n        \"\"\"\n        # POST\n        payload = self.formatter.marshall(registry)\n        r = requests.post(self.path, data=payload, headers=self.headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replace(self, registry):\n        # PUT\n        payload = self.formatter.marshall(registry)\n        r = requests.put(self.path, data=payload, headers=self.headers)", "response": "Replaces all collected metrics with the given registry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef marshall_lines(self, collector):\n\n        if isinstance(collector, collectors.Counter):\n            exec_method = self._format_counter\n        elif isinstance(collector, collectors.Gauge):\n            exec_method = self._format_gauge\n        elif isinstance(collector, collectors.Summary):\n            exec_method = self._format_summary\n        else:\n            raise TypeError(\"Not a valid object format\")\n\n        # create headers\n        help_header = TextFormat.HELP_FMT.format(name=collector.name,\n                                                 help_text=collector.help_text)\n\n        type_header = TextFormat.TYPE_FMT.format(name=collector.name,\n                                                 value_type=collector.REPR_STR)\n\n        # Prepare start headers\n        lines = [help_header, type_header]\n\n        for i in collector.get_all():\n            r = exec_method(i, collector.name, collector.const_labels)\n\n            # Check if it returns one or multiple lines\n            if not isinstance(r, str) and isinstance(r, collections.Iterable):\n                lines.extend(r)\n            else:\n                lines.append(r)\n\n        return lines", "response": "Marshalls a collector and returns the storage / transfer format in\n            a tuple"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn bytes representation of the message in the registry.", "response": "def marshall(self, registry):\n        \"\"\"Returns bytes\"\"\"\n        result = b\"\"\n\n        for i in registry.get_all():\n            # Each message needs to be prefixed with a varint with the size of\n            # the message (MetrycType)\n            # https://github.com/matttproud/golang_protobuf_extensions/blob/master/ext/encode.go\n            # http://zombietetris.de/blog/building-your-own-writedelimitedto-for-python-protobuf/\n            body = self.marshall_collector(i).SerializeToString()\n            msg = encoder._VarintBytes(len(body)) + body\n            result += msg\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gather_data(registry):\n\n    # Get the host name of the machine\n    host = socket.gethostname()\n\n    # Create our collectors\n    trig_metric = Gauge(\"trigonometry_example\",\n                        \"Various trigonometry examples.\",\n                        {'host': host})\n\n    # register the metric collectors\n    registry.register(trig_metric)\n\n    # Start gathering metrics every second\n    counter = 0\n    while True:\n        time.sleep(1)\n\n        sine = math.sin(math.radians(counter % 360))\n        cosine = math.cos(math.radians(counter % 360))\n        trig_metric.set({'type': \"sine\"}, sine)\n        trig_metric.set({'type': \"cosine\"}, cosine)\n\n        counter += 1", "response": "Gathers the metrics for the next second\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a value in the container.", "response": "def set_value(self, labels, value):\n        \"\"\" Sets a value in the container\"\"\"\n\n        if labels:\n            self._label_names_correct(labels)\n\n        with mutex:\n            self.values[labels] = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nraising exception if labels not correct", "response": "def _label_names_correct(self, labels):\n        \"\"\"Raise exception (ValueError) if labels not correct\"\"\"\n\n        for k, v in labels.items():\n            # Check reserved labels\n            if k in RESTRICTED_LABELS_NAMES:\n                raise ValueError(\"Labels not correct\")\n\n            # Check prefixes\n            if any(k.startswith(i) for i in RESTRICTED_LABELS_PREFIXES):\n                raise ValueError(\"Labels not correct\")\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of tuples of 2 elements first one is a dict with all the labels and second elemnt is the value of the metric itself", "response": "def get_all(self):\n        \"\"\" Returns a list populated by tuples of 2 elements, first one is\n            a dict with all the labels and the second elemnt is the value\n            of the metric itself\n        \"\"\"\n        with mutex:\n            items = self.values.items()\n\n        result = []\n        for k, v in items:\n            # Check if is a single value dict (custom empty key)\n            if not k or k == MetricDict.EMPTY_KEY:\n                key = None\n            else:\n                key = decoder.decode(k)\n            result.append((key, self.get(k)))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, labels, value):\n\n        try:\n            current = self.get_value(labels)\n        except KeyError:\n            current = 0\n\n        self.set_value(labels, current + value)", "response": "Adds the given value to the Gauge."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, labels, value):\n\n        if type(value) not in (float, int):\n            raise TypeError(\"Summary only works with digits (int, float)\")\n\n        # We have already a lock for data but not for the estimator\n        with mutex:\n            try:\n                e = self.get_value(labels)\n            except KeyError:\n                # Initialize quantile estimator\n                e = quantile.Estimator(*self.__class__.DEFAULT_INVARIANTS)\n                self.set_value(labels, e)\n            e.observe(float(value))", "response": "Adds a single observation to the summary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the data in the form of 0. 5 9 and 0. 99 percentiles. Also get sum and count.", "response": "def get(self, labels):\n        \"\"\" Get gets the data in the form of 0.5, 0.9 and 0.99 percentiles. Also\n            you get sum and count, all in a dict\n        \"\"\"\n\n        return_data = {}\n\n        # We have already a lock for data but not for the estimator\n        with mutex:\n            e = self.get_value(labels)\n\n            # Set invariants data (default to 0.50, 0.90 and 0.99)\n            for i in e._invariants:\n                q = i._quantile\n                return_data[q] = e.query(q)\n\n            # Set sum and count\n            return_data[self.__class__.SUM_KEY] = e._sum\n            return_data[self.__class__.COUNT_KEY] = e._observations\n\n        return return_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngather the metrics for the next available node", "response": "def gather_data(registry):\n    \"\"\"Gathers the metrics\"\"\"\n\n    # Get the host name of the machine\n    host = socket.gethostname()\n\n    # Create our collectors\n    ram_metric = Gauge(\"memory_usage_bytes\", \"Memory usage in bytes.\",\n                       {'host': host})\n    cpu_metric = Gauge(\"cpu_usage_percent\", \"CPU usage percent.\",\n                       {'host': host})\n\n    # register the metric collectors\n    registry.register(ram_metric)\n    registry.register(cpu_metric)\n\n    # Start gathering metrics every second\n    while True:\n        time.sleep(1)\n\n        # Add ram metrics\n        ram = psutil.virtual_memory()\n        swap = psutil.swap_memory()\n\n        ram_metric.set({'type': \"virtual\", }, ram.used)\n        ram_metric.set({'type': \"virtual\", 'status': \"cached\"}, ram.cached)\n        ram_metric.set({'type': \"swap\"}, swap.used)\n\n        # Add cpu metrics\n        for c, p in enumerate(psutil.cpu_percent(interval=1, percpu=True)):\n            cpu_metric.set({'core': c}, p)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_child(self, name, attribs=None):\n        if name == '.':\n            if attribs is None or len(attribs) == 0:\n                return self\n            if attribs == self.attribs:\n                return self\n        return self.child_index.get(nodehash(name, attribs))", "response": "Returns the first child that matches the given name and attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new node in the tree.", "response": "def create(self, path, data=None):\n        \"\"\"\n        Creates the given node, regardless of whether or not it already\n        exists.\n        Returns the new node.\n        \"\"\"\n        node = self.current[-1]\n        path = self._splitpath(path)\n        n_items = len(path)\n        for n, item in enumerate(path):\n            tag, attribs = self._splittag(item)\n\n            # The leaf node is always newly created.\n            if n == n_items-1:\n                node = node.add(Node(tag, attribs))\n                break\n\n            # Parent nodes are only created if they do not exist yet.\n            existing = node.get_child(tag, attribs)\n            if existing is not None:\n                node = existing\n            else:\n                node = node.add(Node(tag, attribs))\n        if data:\n            node.text = unquote(data)\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, path, data=None, replace=False):\n        node = self.current[-1]\n        for item in self._splitpath(path):\n            tag, attribs = self._splittag(item)\n            next_node = node.get_child(tag, attribs)\n            if next_node is not None:\n                node = next_node\n            else:\n                node = node.add(Node(tag, attribs))\n        if replace:\n            node.text = ''\n        if data:\n            if node.text is None:\n                node.text = unquote(data)\n            else:\n                node.text += unquote(data)\n        return node", "response": "Adds a new entry to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_attribute(self, path, name, value):\n        node = self.add(path)\n        node.attribs.append((name, value))\n        return node", "response": "Adds the given attribute to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating and enters the given node. Returns the node that already exists.", "response": "def open(self, path):\n        \"\"\"\n        Creates and enters the given node, regardless of whether it already\n        exists.\n        Returns the new node.\n        \"\"\"\n        self.current.append(self.create(path))\n        return self.current[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enter(self, path):\n        self.current.append(self.add(path))\n        return self.current[-1]", "response": "Enters the given node. Creates it if it does not exist. Returns the node s id."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a converter (as returned by compile()), this function reads the given input file and converts it to the requested output format. Supported output formats are 'xml', 'yaml', 'json', or 'none'. :type converter: compiler.Context :param converter: The compiled converter. :type input_file: str :param input_file: Name of a file to convert. :type format: str :param format: The output format. :type encoding: str :param encoding: Character encoding of the input file. :rtype: str :return: The resulting output.", "response": "def generate(converter, input_file, format='xml', encoding='utf8'):\n    \"\"\"\n    Given a converter (as returned by compile()), this function reads\n    the given input file and converts it to the requested output format.\n\n    Supported output formats are 'xml', 'yaml', 'json', or 'none'.\n\n    :type  converter: compiler.Context\n    :param converter: The compiled converter.\n    :type  input_file: str\n    :param input_file: Name of a file to convert.\n    :type  format: str\n    :param format: The output format.\n    :type  encoding: str\n    :param encoding: Character encoding of the input file.\n    :rtype:  str\n    :return: The resulting output.\n    \"\"\"\n    with codecs.open(input_file, encoding=encoding) as thefile:\n        return generate_string(converter, thefile.read(), format=format)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nliking generate(), but writes the output to the given output file instead. :type converter: compiler.Context :param converter: The compiled converter. :type input_file: str :param input_file: Name of a file to convert. :type output_file: str :param output_file: The output filename. :type format: str :param format: The output format. :type in_encoding: str :param in_encoding: Character encoding of the input file. :type out_encoding: str :param out_encoding: Character encoding of the output file. :rtype: str :return: The resulting output.", "response": "def generate_to_file(converter,\n                     input_file,\n                     output_file,\n                     format='xml',\n                     in_encoding='utf8',\n                     out_encoding='utf8'):\n    \"\"\"\n    Like generate(), but writes the output to the given output file\n    instead.\n\n    :type  converter: compiler.Context\n    :param converter: The compiled converter.\n    :type  input_file: str\n    :param input_file: Name of a file to convert.\n    :type  output_file: str\n    :param output_file: The output filename.\n    :type  format: str\n    :param format: The output format.\n    :type  in_encoding: str\n    :param in_encoding: Character encoding of the input file.\n    :type  out_encoding: str\n    :param out_encoding: Character encoding of the output file.\n    :rtype:  str\n    :return: The resulting output.\n    \"\"\"\n    with codecs.open(output_file, 'w', encoding=out_encoding) as thefile:\n        result = generate(converter, input_file, format=format, encoding=in_encoding)\n        thefile.write(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlikes generate(), but reads the input from a string instead of from a file. :type converter: compiler.Context :param converter: The compiled converter. :type input: str :param input: The string to convert. :type format: str :param format: The output format. :rtype: str :return: The resulting output.", "response": "def generate_string(converter, input, format='xml'):\n    \"\"\"\n    Like generate(), but reads the input from a string instead of\n    from a file.\n\n    :type  converter: compiler.Context\n    :param converter: The compiled converter.\n    :type  input: str\n    :param input: The string to convert.\n    :type  format: str\n    :param format: The output format.\n    :rtype:  str\n    :return: The resulting output.\n    \"\"\"\n    serializer = generator.new(format)\n    if serializer is None:\n        raise TypeError('invalid output format ' + repr(format))\n    builder = Builder()\n    converter.parse_string(input, builder)\n    return builder.serialize(serializer)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_string_to_file(converter,\n                            input,\n                            output_file,\n                            format='xml',\n                            out_encoding='utf8'):\n    \"\"\"\n    Like generate(), but reads the input from a string instead of\n    from a file, and writes the output to the given output file.\n\n    :type  converter: compiler.Context\n    :param converter: The compiled converter.\n    :type  input: str\n    :param input: The string to convert.\n    :type  output_file: str\n    :param output_file: The output filename.\n    :type  format: str\n    :param format: The output format.\n    :type  out_encoding: str\n    :param out_encoding: Character encoding of the output file.\n    :rtype:  str\n    :return: The resulting output.\n    \"\"\"\n    with codecs.open(output_file, 'w', encoding=out_encoding) as thefile:\n        result = generate_string(converter, input, format=format)\n        thefile.write(result)", "response": "This function generates a string from a file instead of a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef best_trial_tid(self, rank=0):\n        candidates = [t for t in self.trials\n                      if t['result']['status'] == STATUS_OK]\n        if len(candidates) == 0:\n            return None\n        losses = [float(t['result']['loss']) for t in candidates]\n        assert not np.any(np.isnan(losses))\n        lid = np.where(np.argsort(losses).argsort() == rank)[0][0]\n        return candidates[lid][\"tid\"]", "response": "Get tid of the best trial with the given rank"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count_by_state_unsynced(self, arg):\n        if self.kill_timeout is not None:\n            self.delete_running(self.kill_timeout)\n        return super(KMongoTrials, self).count_by_state_unsynced(arg)", "response": "Extends the original object in order to inject checking\n            for stalled jobs and killing them if they are still running for too long\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_history(self, tid, scores=[\"loss\", \"f1\", \"accuracy\"],\n                     figsize=(15, 3)):\n        \"\"\"Plot the loss curves\"\"\"\n        history = self.train_history(tid)\n        import matplotlib.pyplot as plt\n\n        fig = plt.figure(figsize=figsize)\n        for i, score in enumerate(scores):\n            plt.subplot(1, len(scores), i + 1)\n            plt.tight_layout()\n            plt.plot(history[score], label=\"train\")\n            plt.plot(history['val_' + score], label=\"validation\")\n            plt.title(score)\n            plt.ylabel(score)\n            plt.xlabel('epoch')\n            plt.legend(loc='best')\n        return fig", "response": "Plot the loss curves for a specific tid"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_model(self, tid, custom_objects=None):\n        if tid is None:\n            tid = self.best_trial_tid()\n\n        model_path = self.get_trial(tid)[\"result\"][\"path\"][\"model\"]\n        return load_model(model_path, custom_objects=custom_objects)", "response": "Load saved keras model of the trial."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nnumber of ok trials in the user.", "response": "def n_ok(self):\n        \"\"\"Number of ok trials()\n        \"\"\"\n        if len(self.trials) == 0:\n            return 0\n        else:\n            return np.sum(np.array(self.statuses()) == \"ok\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ok_results(self, verbose=True):\n        if len(self.trials) == 0:\n            return []\n\n        not_ok = np.where(np.array(self.statuses()) != \"ok\")[0]\n\n        if len(not_ok) > 0 and verbose:\n            print(\"{0}/{1} trials were not ok.\".format(len(not_ok), len(self.trials)))\n            print(\"Trials: \" + str(not_ok))\n            print(\"Statuses: \" + str(np.array(self.statuses())[not_ok]))\n\n        r = [merge_dicts({\"tid\": t[\"tid\"]}, t[\"result\"].to_dict())\n             for t in self.trials if t[\"result\"][\"status\"] == \"ok\"]\n        return r", "response": "Return a list of results with ok status"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pyoidcMiddleware(func):\n\n    def wrapper(environ, start_response):\n        data = get_or_post(environ)\n        cookies = environ.get(\"HTTP_COOKIE\", \"\")\n        resp = func(request=data, cookie=cookies)\n        return resp(environ, start_response)\n\n    return wrapper", "response": "A wrapper for the underlying pyoidc library functions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resp2flask(resp):\n    if isinstance(resp, Redirect) or isinstance(resp, SeeOther):\n        code = int(resp.status.split()[0])\n        raise cherrypy.HTTPRedirect(resp.message, code)\n    return resp.message, resp.status, resp.headers", "response": "Convert an oic. utils. http_util instance to Flask."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_authentication_methods(authn_config, template_env):\n    routing = {}\n    ac = AuthnBroker()\n    for authn_method in authn_config:\n        cls = make_cls_from_name(authn_method[\"class\"])\n        instance = cls(template_env=template_env, **authn_method[\"kwargs\"])\n        ac.add(authn_method[\"acr\"], instance)\n        routing[instance.url_endpoint] = VerifierMiddleware(instance)\n\n    return ac, routing", "response": "Setup all authentication methods specified in the configuration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tuple of SQL select statements and the list of SQL arguments for the features query.", "response": "def featuresQuery(self, **kwargs):\n        \"\"\"\n        Converts a dictionary of keyword arguments into a tuple\n        of SQL select statements and the list of SQL arguments\n        \"\"\"\n        # TODO: Optimize by refactoring out string concatenation\n        sql = \"\"\n        sql_rows = \"SELECT * FROM FEATURE WHERE id > 1 \"\n        sql_args = ()\n        if 'name' in kwargs and kwargs['name']:\n            sql += \"AND name = ? \"\n            sql_args += (kwargs.get('name'),)\n        if 'geneSymbol' in kwargs and kwargs['geneSymbol']:\n            sql += \"AND gene_name = ? \"\n            sql_args += (kwargs.get('geneSymbol'),)\n        if 'start' in kwargs and kwargs['start'] is not None:\n            sql += \"AND end > ? \"\n            sql_args += (kwargs.get('start'),)\n        if 'end' in kwargs and kwargs['end'] is not None:\n            sql += \"AND start < ? \"\n            sql_args += (kwargs.get('end'),)\n        if 'referenceName' in kwargs and kwargs['referenceName']:\n            sql += \"AND reference_name = ?\"\n            sql_args += (kwargs.get('referenceName'),)\n        if 'parentId' in kwargs and kwargs['parentId']:\n            sql += \"AND parent_id = ? \"\n            sql_args += (kwargs['parentId'],)\n        if kwargs.get('featureTypes') is not None \\\n                and len(kwargs['featureTypes']) > 0:\n            sql += \"AND type IN (\"\n            sql += \", \".join([\"?\", ] * len(kwargs.get('featureTypes')))\n            sql += \") \"\n            sql_args += tuple(kwargs.get('featureTypes'))\n        sql_rows += sql\n        sql_rows += \" ORDER BY reference_name, start, end ASC \"\n        return sql_rows, sql_args"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a full features query in database.", "response": "def searchFeaturesInDb(\n            self, startIndex=0, maxResults=None,\n            referenceName=None, start=None, end=None,\n            parentId=None, featureTypes=None,\n            name=None, geneSymbol=None):\n        \"\"\"\n        Perform a full features query in database.\n\n        :param startIndex: int representing first record to return\n        :param maxResults: int representing number of records to return\n        :param referenceName: string representing reference name, ex 'chr1'\n        :param start: int position on reference to start search\n        :param end: int position on reference to end search >= start\n        :param parentId: string restrict search by id of parent node.\n        :param name: match features by name\n        :param geneSymbol: match features by gene symbol\n        :return an array of dictionaries, representing the returned data.\n        \"\"\"\n        # TODO: Refactor out common bits of this and the above count query.\n        sql, sql_args = self.featuresQuery(\n            startIndex=startIndex, maxResults=maxResults,\n            referenceName=referenceName, start=start, end=end,\n            parentId=parentId, featureTypes=featureTypes,\n            name=name, geneSymbol=geneSymbol)\n        sql += sqlite_backend.limitsSql(startIndex, maxResults)\n        query = self._dbconn.execute(sql, sql_args)\n        return sqlite_backend.sqliteRowsToDicts(query.fetchall())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a feature by featureID.", "response": "def getFeatureById(self, featureId):\n        \"\"\"\n        Fetch feature by featureID.\n\n        :param featureId: the FeatureID as found in GFF3 records\n        :return: dictionary representing a feature object,\n            or None if no match is found.\n        \"\"\"\n        sql = \"SELECT * FROM FEATURE WHERE id = ?\"\n        query = self._dbconn.execute(sql, (featureId,))\n        ret = query.fetchone()\n        if ret is None:\n            return None\n        return sqlite_backend.sqliteRowToDict(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef toProtocolElement(self):\n        gaFeatureSet = protocol.FeatureSet()\n        gaFeatureSet.id = self.getId()\n        gaFeatureSet.dataset_id = self.getParentContainer().getId()\n        gaFeatureSet.reference_set_id = pb.string(self._referenceSet.getId())\n        gaFeatureSet.name = self._name\n        gaFeatureSet.source_uri = self._sourceUri\n        attributes = self.getAttributes()\n        for key in attributes:\n            gaFeatureSet.attributes.attr[key] \\\n                .values.extend(protocol.encodeValue(attributes[key]))\n        return gaFeatureSet", "response": "Returns the representation of this FeatureSet as the corresponding\n        ProtocolElement."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getCompoundIdForFeatureId(self, featureId):\n        if featureId is not None and featureId != \"\":\n            compoundId = datamodel.FeatureCompoundId(\n                self.getCompoundId(), str(featureId))\n        else:\n            compoundId = \"\"\n        return str(compoundId)", "response": "Returns server - style compound ID for the specified internal featureId."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getFeature(self, compoundId):\n        if compoundId is None:\n            raise exceptions.ObjectWithIdNotFoundException(compoundId)\n        randomNumberGenerator = random.Random()\n        randomNumberGenerator.seed(self._randomSeed)\n        feature = self._generateSimulatedFeature(randomNumberGenerator)\n        feature.id = str(compoundId)\n        feature.parent_id = \"\"  # TODO: Test with nonempty parentIDs?\n        return feature", "response": "Fetches a simulated feature by ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getFeatures(self, referenceName=None, start=None, end=None,\n                    startIndex=None, maxResults=None,\n                    featureTypes=None, parentId=None,\n                    name=None, geneSymbol=None, numFeatures=10):\n        \"\"\"\n        Returns a set number of simulated features.\n\n        :param referenceName: name of reference to \"search\" on\n        :param start: start coordinate of query\n        :param end: end coordinate of query\n        :param startIndex: None or int\n        :param maxResults: None or int\n        :param featureTypes: optional list of ontology terms to limit query\n        :param parentId: optional parentId to limit query.\n        :param name: the name of the feature\n        :param geneSymbol: the symbol for the gene the features are on\n        :param numFeatures: number of features to generate in the return.\n            10 is a reasonable (if arbitrary) default.\n        :return: Yields feature list\n        \"\"\"\n        randomNumberGenerator = random.Random()\n        randomNumberGenerator.seed(self._randomSeed)\n        for featureId in range(numFeatures):\n            gaFeature = self._generateSimulatedFeature(randomNumberGenerator)\n            gaFeature.id = self.getCompoundIdForFeatureId(featureId)\n            match = (\n                gaFeature.start < end and\n                gaFeature.end > start and\n                gaFeature.reference_name == referenceName and (\n                    featureTypes is None or len(featureTypes) == 0 or\n                    gaFeature.feature_type in featureTypes))\n            if match:\n                gaFeature.parent_id = \"\"  # TODO: Test nonempty parentIDs?\n                yield gaFeature", "response": "Returns a list of simulated features."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populateFromFile(self, dataUrl):\n        self._dbFilePath = dataUrl\n        self._db = Gff3DbBackend(self._dbFilePath)", "response": "Populates the instance variables of this FeatureSet from the specified data URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef populateFromRow(self, featureSetRecord):\n        self._dbFilePath = featureSetRecord.dataurl\n        self.setAttributesJson(featureSetRecord.attributes)\n        self._db = Gff3DbBackend(self._dbFilePath)", "response": "Populates the instance variables of this FeatureSet from the specified featureSetRecord."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a protocol. Feature object corresponding to a datamodel. FeatureCompoundId object.", "response": "def getFeature(self, compoundId):\n        \"\"\"\n        Returns a protocol.Feature object corresponding to a compoundId\n        :param compoundId: a datamodel.FeatureCompoundId object\n        :return: a Feature object.\n        :raises: exceptions.ObjectWithIdNotFoundException if invalid\n            compoundId is provided.\n        \"\"\"\n        featureId = long(compoundId.featureId)\n        with self._db as dataSource:\n            featureReturned = dataSource.getFeatureById(featureId)\n\n        if featureReturned is None:\n            raise exceptions.ObjectWithIdNotFoundException(compoundId)\n        else:\n            gaFeature = self._gaFeatureForFeatureDbRecord(featureReturned)\n            return gaFeature"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _gaFeatureForFeatureDbRecord(self, feature):\n        gaFeature = protocol.Feature()\n        gaFeature.id = self.getCompoundIdForFeatureId(feature['id'])\n        if feature.get('parent_id'):\n            gaFeature.parent_id = self.getCompoundIdForFeatureId(\n                    feature['parent_id'])\n        else:\n            gaFeature.parent_id = \"\"\n        gaFeature.feature_set_id = self.getId()\n        gaFeature.reference_name = pb.string(feature.get('reference_name'))\n        gaFeature.start = pb.int(feature.get('start'))\n        gaFeature.end = pb.int(feature.get('end'))\n        gaFeature.name = pb.string(feature.get('name'))\n        if feature.get('strand', '') == '-':\n            gaFeature.strand = protocol.NEG_STRAND\n        else:\n            # default to positive strand\n            gaFeature.strand = protocol.POS_STRAND\n        gaFeature.child_ids.extend(map(\n                self.getCompoundIdForFeatureId,\n                json.loads(feature['child_ids'])))\n        gaFeature.feature_type.CopyFrom(\n            self._ontology.getGaTermByName(feature['type']))\n        attributes = json.loads(feature['attributes'])\n        # TODO: Identify which values are ExternalIdentifiers and OntologyTerms\n        for key in attributes:\n            for v in attributes[key]:\n                gaFeature.attributes.attr[key].values.add().string_value = v\n        if 'gene_name' in attributes and len(attributes['gene_name']) > 0:\n            gaFeature.gene_symbol = pb.string(attributes['gene_name'][0])\n        return gaFeature", "response": "Returns the GA4GH protocol. Feature object for the given feature in the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a generator that yields a protocol. Feature at a time", "response": "def getFeatures(self, referenceName=None, start=None, end=None,\n                    startIndex=None, maxResults=None,\n                    featureTypes=None, parentId=None,\n                    name=None, geneSymbol=None):\n        \"\"\"\n        method passed to runSearchRequest to fulfill the request\n        :param str referenceName: name of reference (ex: \"chr1\")\n        :param start: castable to int, start position on reference\n        :param end: castable to int, end position on reference\n        :param startIndex: none or castable to int\n        :param maxResults: none or castable to int\n        :param featureTypes: array of str\n        :param parentId: none or featureID of parent\n        :param name: the name of the feature\n        :param geneSymbol: the symbol for the gene the features are on\n        :return: yields a protocol.Feature at a time\n        \"\"\"\n        with self._db as dataSource:\n            features = dataSource.searchFeaturesInDb(\n                startIndex, maxResults,\n                referenceName=referenceName,\n                start=start, end=end,\n                parentId=parentId, featureTypes=featureTypes,\n                name=name, geneSymbol=geneSymbol)\n            for feature in features:\n                gaFeature = self._gaFeatureForFeatureDbRecord(feature)\n                yield gaFeature"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addRnaQuantification(self, rnaQuantification):\n        id_ = rnaQuantification.getId()\n        self._rnaQuantificationIdMap[id_] = rnaQuantification\n        self._rnaQuantificationIds.append(id_)", "response": "Adds an rnaQuantification to this rnaQuantificationSet"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef toProtocolElement(self):\n        protocolElement = protocol.RnaQuantificationSet()\n        protocolElement.id = self.getId()\n        protocolElement.dataset_id = self._parentContainer.getId()\n        protocolElement.name = self._name\n        self.serializeAttributes(protocolElement)\n        return protocolElement", "response": "Converts this rnaQuant into its GA4GH protocol equivalent."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populateFromFile(self, dataUrl):\n        self._dbFilePath = dataUrl\n        self._db = SqliteRnaBackend(self._dbFilePath)\n        self.addRnaQuants()", "response": "Populates the instance variables of this RnaQuantificationSet from the specified data URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate the instance variables of this RnaQuantificationSet from the specified DB row.", "response": "def populateFromRow(self, quantificationSetRecord):\n        \"\"\"\n        Populates the instance variables of this RnaQuantificationSet from the\n        specified DB row.\n        \"\"\"\n        self._dbFilePath = quantificationSetRecord.dataurl\n        self.setAttributesJson(quantificationSetRecord.attributes)\n        self._db = SqliteRnaBackend(self._dbFilePath)\n        self.addRnaQuants()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert this rnaQuantification into its GA4GH protocol equivalent.", "response": "def toProtocolElement(self):\n        \"\"\"\n        Converts this rnaQuant into its GA4GH protocol equivalent.\n        \"\"\"\n        protocolElement = protocol.RnaQuantification()\n        protocolElement.id = self.getId()\n        protocolElement.name = self._name\n        protocolElement.description = self._description\n        protocolElement.read_group_ids.extend(self._readGroupIds)\n        protocolElement.programs.extend(self._programs)\n        protocolElement.biosample_id = self._biosampleId\n        protocolElement.feature_set_ids.extend(self._featureSetIds)\n        protocolElement.rna_quantification_set_id = \\\n            self._parentContainer.getId()\n        self.serializeAttributes(protocolElement)\n        return protocolElement"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the RNA Quantization Metadata to the internal data structure.", "response": "def addRnaQuantMetadata(self, fields):\n        \"\"\"\n        data elements are:\n        Id, annotations, description, name, readGroupId\n        where annotations is a comma separated list\n        \"\"\"\n        self._featureSetIds = fields[\"feature_set_ids\"].split(',')\n        self._description = fields[\"description\"]\n        self._name = fields[\"name\"]\n        self._biosampleId = fields.get(\"biosample_id\", \"\")\n        if fields[\"read_group_ids\"] == \"\":\n            self._readGroupIds = []\n        else:\n            self._readGroupIds = fields[\"read_group_ids\"].split(',')\n        if fields[\"programs\"] == \"\":\n            self._programs = []\n        else:\n            # Need to use program Id's here to generate a list of Programs\n            # for now set to empty\n            self._programs = []"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getRnaQuantMetadata(self):\n        rnaQuantId = self.getLocalId()\n        with self._db as dataSource:\n            rnaQuantReturned = dataSource.getRnaQuantificationById(\n                rnaQuantId)\n        self.addRnaQuantMetadata(rnaQuantReturned)", "response": "Add the metadata for the rnaQuantification for this entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populateFromFile(self, dataUrl):\n        self._dbFilePath = dataUrl\n        self._db = SqliteRnaBackend(self._dbFilePath)\n        self.getRnaQuantMetadata()", "response": "Populates the instance variables of this FeatureSet from the specified data URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populateFromRow(self, row):\n        self._dbFilePath = row[b'dataUrl']\n        self._db = SqliteRnaBackend(self._dbFilePath)\n        self.getRnaQuantMetadata()", "response": "Populates the instance variables of this FeatureSet from the specified DB row."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the list of ExpressionLevels in this RNA Quantification.", "response": "def getExpressionLevels(\n            self, threshold=0.0, names=[], startIndex=0, maxResults=0):\n        \"\"\"\n        Returns the list of ExpressionLevels in this RNA Quantification.\n        \"\"\"\n        rnaQuantificationId = self.getLocalId()\n        with self._db as dataSource:\n            expressionsReturned = dataSource.searchExpressionLevelsInDb(\n                rnaQuantificationId,\n                names=names,\n                threshold=threshold,\n                startIndex=startIndex,\n                maxResults=maxResults)\n            expressionLevels = [\n                SqliteExpressionLevel(self, expressionEntry) for\n                expressionEntry in expressionsReturned]\n            return expressionLevels"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef searchRnaQuantificationsInDb(\n            self, rnaQuantificationId=\"\"):\n        \"\"\"\n        :param rnaQuantificationId: string restrict search by id\n        :return an array of dictionaries, representing the returned data.\n        \"\"\"\n        sql = (\"SELECT * FROM RnaQuantification\")\n        sql_args = ()\n        if len(rnaQuantificationId) > 0:\n            sql += \" WHERE id = ? \"\n            sql_args += (rnaQuantificationId,)\n        query = self._dbconn.execute(sql, sql_args)\n        try:\n            return sqlite_backend.iterativeFetch(query)\n        except AttributeError:\n            raise exceptions.RnaQuantificationNotFoundException(\n                rnaQuantificationId)", "response": "searchRnaQuantificationsInDb - Searches the database for the rnaQuantification with the given id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getRnaQuantificationById(self, rnaQuantificationId):\n        sql = (\"SELECT * FROM RnaQuantification WHERE id = ?\")\n        query = self._dbconn.execute(sql, (rnaQuantificationId,))\n        try:\n            return sqlite_backend.fetchOne(query)\n        except AttributeError:\n            raise exceptions.RnaQuantificationNotFoundException(\n                rnaQuantificationId)", "response": "Returns a dictionary representing an RnaQuantification object and the corresponding object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the dictionary representation of an ExpressionLevel object identified by the given ID.", "response": "def getExpressionLevelById(self, expressionId):\n        \"\"\"\n        :param expressionId: the ExpressionLevel ID\n        :return: dictionary representing an ExpressionLevel object,\n            or None if no match is found.\n        \"\"\"\n        sql = (\"SELECT * FROM Expression WHERE id = ?\")\n        query = self._dbconn.execute(sql, (expressionId,))\n        try:\n            return sqlite_backend.fetchOne(query)\n        except AttributeError:\n            raise exceptions.ExpressionLevelNotFoundException(\n                expressionId)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate this CallSet from the specified DB row.", "response": "def populateFromRow(self, callSetRecord):\n        \"\"\"\n        Populates this CallSet from the specified DB row.\n        \"\"\"\n        self._biosampleId = callSetRecord.biosampleid\n        self.setAttributesJson(callSetRecord.attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef toProtocolElement(self):\n        variantSet = self.getParentContainer()\n        gaCallSet = protocol.CallSet(\n            biosample_id=self.getBiosampleId())\n        if variantSet.getCreationTime():\n            gaCallSet.created = variantSet.getCreationTime()\n        if variantSet.getUpdatedTime():\n            gaCallSet.updated = variantSet.getUpdatedTime()\n        gaCallSet.id = self.getId()\n        gaCallSet.name = self.getLocalId()\n        gaCallSet.variant_set_ids.append(variantSet.getId())\n        self.serializeAttributes(gaCallSet)\n        return gaCallSet", "response": "Returns the representation of this CallSet as the corresponding\n        ProtocolElement."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the specified variantAnnotationSet to this dataset.", "response": "def addVariantAnnotationSet(self, variantAnnotationSet):\n        \"\"\"\n        Adds the specified variantAnnotationSet to this dataset.\n        \"\"\"\n        id_ = variantAnnotationSet.getId()\n        self._variantAnnotationSetIdMap[id_] = variantAnnotationSet\n        self._variantAnnotationSetIds.append(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getVariantAnnotationSet(self, id_):\n        if id_ not in self._variantAnnotationSetIdMap:\n            raise exceptions.AnnotationSetNotFoundException(id_)\n        return self._variantAnnotationSetIdMap[id_]", "response": "Returns the AnnotationSet with the specified id or raises an exception if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addCallSet(self, callSet):\n        callSetId = callSet.getId()\n        self._callSetIdMap[callSetId] = callSet\n        self._callSetNameMap[callSet.getLocalId()] = callSet\n        self._callSetIds.append(callSetId)\n        self._callSetIdToIndex[callSet.getId()] = len(self._callSetIds) - 1", "response": "Adds the specified CallSet to this VariantSet."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a CallSet for the specified sample name.", "response": "def addCallSetFromName(self, sampleName):\n        \"\"\"\n        Adds a CallSet for the specified sample name.\n        \"\"\"\n        callSet = CallSet(self, sampleName)\n        self.addCallSet(callSet)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a CallSet with the specified name or raises a NameException if it does not exist.", "response": "def getCallSetByName(self, name):\n        \"\"\"\n        Returns a CallSet with the specified name, or raises a\n        CallSetNameNotFoundException if it does not exist.\n        \"\"\"\n        if name not in self._callSetNameMap:\n            raise exceptions.CallSetNameNotFoundException(name)\n        return self._callSetNameMap[name]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getCallSet(self, id_):\n        if id_ not in self._callSetIdMap:\n            raise exceptions.CallSetNotFoundException(id_)\n        return self._callSetIdMap[id_]", "response": "Returns a CallSet with the specified id or raises a\nNameException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts this VariantSet into its GA4GH protocol equivalent.", "response": "def toProtocolElement(self):\n        \"\"\"\n        Converts this VariantSet into its GA4GH protocol equivalent.\n        \"\"\"\n        protocolElement = protocol.VariantSet()\n        protocolElement.id = self.getId()\n        protocolElement.dataset_id = self.getParentContainer().getId()\n        protocolElement.reference_set_id = self._referenceSet.getId()\n        protocolElement.metadata.extend(self.getMetadata())\n        protocolElement.dataset_id = self.getParentContainer().getId()\n        protocolElement.reference_set_id = self._referenceSet.getId()\n        protocolElement.name = self.getLocalId()\n        self.serializeAttributes(protocolElement)\n        return protocolElement"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _createGaVariant(self):\n        ret = protocol.Variant()\n        if self._creationTime:\n            ret.created = self._creationTime\n        if self._updatedTime:\n            ret.updated = self._updatedTime\n        ret.variant_set_id = self.getId()\n        return ret", "response": "Creates a new GA Variant object from this variant set."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an ID string suitable for the specified GA Variant object in this variant set.", "response": "def getVariantId(self, gaVariant):\n        \"\"\"\n        Returns an ID string suitable for the specified GA Variant\n        object in this variant set.\n        \"\"\"\n        md5 = self.hashVariant(gaVariant)\n        compoundId = datamodel.VariantCompoundId(\n            self.getCompoundId(), gaVariant.reference_name,\n            str(gaVariant.start), md5)\n        return str(compoundId)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getCallSetId(self, sampleName):\n        compoundId = datamodel.CallSetCompoundId(\n            self.getCompoundId(), sampleName)\n        return str(compoundId)", "response": "Returns the callSetId for the specified sampleName in this VariantSet."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hashVariant(cls, gaVariant):\n        hash_str = gaVariant.reference_bases + \\\n            str(tuple(gaVariant.alternate_bases))\n        return hashlib.md5(hash_str).hexdigest()", "response": "Generates an MD5 hash of the ga variant object to distinguish\n        it from other variants at the same genomic coordinate."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a random variant for the specified position using the specified random number generator.", "response": "def generateVariant(self, referenceName, position, randomNumberGenerator):\n        \"\"\"\n        Generate a random variant for the specified position using the\n        specified random number generator. This generator should be seeded\n        with a value that is unique to this position so that the same variant\n        will always be produced regardless of the order it is generated in.\n        \"\"\"\n        variant = self._createGaVariant()\n        variant.reference_name = referenceName\n        variant.start = position\n        variant.end = position + 1  # SNPs only for now\n        bases = [\"A\", \"C\", \"G\", \"T\"]\n        ref = randomNumberGenerator.choice(bases)\n        variant.reference_bases = ref\n        alt = randomNumberGenerator.choice(\n            [base for base in bases if base != ref])\n        variant.alternate_bases.append(alt)\n        randChoice = randomNumberGenerator.randint(0, 2)\n        if randChoice == 0:\n            variant.filters_applied = False\n        elif randChoice == 1:\n            variant.filters_applied = True\n            variant.filters_passed = True\n        else:\n            variant.filters_applied = True\n            variant.filters_passed = False\n            variant.filters_failed.append('q10')\n        for callSet in self.getCallSets():\n            call = variant.calls.add()\n            call.call_set_id = callSet.getId()\n            # for now, the genotype is either [0,1], [1,1] or [1,0] with equal\n            # probability; probably will want to do something more\n            # sophisticated later.\n            randomChoice = randomNumberGenerator.choice(\n                [[0, 1], [1, 0], [1, 1]])\n            call.genotype.extend(randomChoice)\n            # TODO What is a reasonable model for generating these likelihoods?\n            # Are these log-scaled? Spec does not say.\n            call.genotype_likelihood.extend([-100, -100, -100])\n        variant.id = self.getVariantId(variant)\n        return variant"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef populateFromRow(self, variantSetRecord):\n        self._created = variantSetRecord.created\n        self._updated = variantSetRecord.updated\n        self.setAttributesJson(variantSetRecord.attributes)\n        self._chromFileMap = {}\n        # We can't load directly as we want tuples to be stored\n        # rather than lists.\n        for key, value in json.loads(variantSetRecord.dataurlindexmap).items():\n            self._chromFileMap[key] = tuple(value)\n        self._metadata = []\n        for jsonDict in json.loads(variantSetRecord.metadata):\n            metadata = protocol.fromJson(json.dumps(jsonDict),\n                                         protocol.VariantSetMetadata)\n            self._metadata.append(metadata)", "response": "Populates this VariantSet from the specified DB row."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populateFromFile(self, dataUrls, indexFiles):\n        assert len(dataUrls) == len(indexFiles)\n        for dataUrl, indexFile in zip(dataUrls, indexFiles):\n            varFile = pysam.VariantFile(dataUrl, index_filename=indexFile)\n            try:\n                self._populateFromVariantFile(varFile, dataUrl, indexFile)\n            finally:\n                varFile.close()", "response": "Populates this variant set using the specified data files and indexes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npopulate this VariantSet by examing all the VCF files in the specified directory.", "response": "def populateFromDirectory(self, vcfDirectory):\n        \"\"\"\n        Populates this VariantSet by examing all the VCF files in the\n        specified directory. This is mainly used for as a convenience\n        for testing purposes.\n        \"\"\"\n        pattern = os.path.join(vcfDirectory, \"*.vcf.gz\")\n        dataFiles = []\n        indexFiles = []\n        for vcfFile in glob.glob(pattern):\n            dataFiles.append(vcfFile)\n            indexFiles.append(vcfFile + \".tbi\")\n        self.populateFromFile(dataFiles, indexFiles)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform consistency check on the variant set", "response": "def checkConsistency(self):\n        \"\"\"\n        Perform consistency check on the variant set\n        \"\"\"\n        for referenceName, (dataUrl, indexFile) in self._chromFileMap.items():\n            varFile = pysam.VariantFile(dataUrl, index_filename=indexFile)\n            try:\n                for chrom in varFile.index:\n                    chrom, _, _ = self.sanitizeVariantFileFetch(chrom)\n                    if not isEmptyIter(varFile.fetch(chrom)):\n                        self._checkMetadata(varFile)\n                        self._checkCallSetIds(varFile)\n            finally:\n                varFile.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _populateFromVariantFile(self, varFile, dataUrl, indexFile):\n        if varFile.index is None:\n            raise exceptions.NotIndexedException(dataUrl)\n        for chrom in varFile.index:\n            # Unlike Tabix indices, CSI indices include all contigs defined\n            # in the BCF header.  Thus we must test each one to see if\n            # records exist or else they are likely to trigger spurious\n            # overlapping errors.\n            chrom, _, _ = self.sanitizeVariantFileFetch(chrom)\n            if not isEmptyIter(varFile.fetch(chrom)):\n                if chrom in self._chromFileMap:\n                    raise exceptions.OverlappingVcfException(dataUrl, chrom)\n            self._chromFileMap[chrom] = dataUrl, indexFile\n        self._updateMetadata(varFile)\n        self._updateCallSetIds(varFile)\n        self._updateVariantAnnotationSets(varFile, dataUrl)", "response": "Populates the instance variables of this VariantSet from the specified pysam VariantFile object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the variant annotation set associated with this variant using the information in the specified pysam variantFile.", "response": "def _updateVariantAnnotationSets(self, variantFile, dataUrl):\n        \"\"\"\n        Updates the variant annotation set associated with this variant using\n        information in the specified pysam variantFile.\n        \"\"\"\n        # TODO check the consistency of this between VCF files.\n        if not self.isAnnotated():\n            annotationType = None\n            for record in variantFile.header.records:\n                if record.type == \"GENERIC\":\n                    if record.key == \"SnpEffVersion\":\n                        annotationType = ANNOTATIONS_SNPEFF\n                    elif record.key == \"VEP\":\n                        version = record.value.split()[0]\n                        # TODO we need _much_ more sophisticated processing\n                        # of VEP versions here. When do they become\n                        # incompatible?\n                        if version == \"v82\":\n                            annotationType = ANNOTATIONS_VEP_V82\n                        elif version == \"v77\":\n                            annotationType = ANNOTATIONS_VEP_V77\n                        else:\n                            # TODO raise a proper typed exception there with\n                            # the file name as an argument.\n                            raise ValueError(\n                                \"Unsupported VEP version {} in '{}'\".format(\n                                    version, dataUrl))\n            if annotationType is None:\n                infoKeys = variantFile.header.info.keys()\n                if 'CSQ' in infoKeys or 'ANN' in infoKeys:\n                    # TODO likewise, we want a properly typed exception that\n                    # we can throw back to the repo manager UI and display\n                    # as an import error.\n                    raise ValueError(\n                        \"Unsupported annotations in '{}'\".format(dataUrl))\n            if annotationType is not None:\n                vas = HtslibVariantAnnotationSet(self, self.getLocalId())\n                vas.populateFromFile(variantFile, annotationType)\n                self.addVariantAnnotationSet(vas)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _updateMetadata(self, variantFile):\n        metadata = self._getMetadataFromVcf(variantFile)\n        if self._metadata is None:\n            self._metadata = metadata", "response": "Updates the metadata for his variant set based on the specified variant file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _checkMetadata(self, variantFile):\n        metadata = self._getMetadataFromVcf(variantFile)\n        if self._metadata is not None and self._metadata != metadata:\n            raise exceptions.InconsistentMetaDataException(\n                variantFile.filename)", "response": "Checks that the metadata of the specified variantFile is consistent with the current metadata."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if the callSetIds of the current variantFile are consistent with the current callSetIds.", "response": "def _checkCallSetIds(self, variantFile):\n        \"\"\"\n        Checks callSetIds for consistency\n        \"\"\"\n        if len(self._callSetIdMap) > 0:\n            callSetIds = set([\n                self.getCallSetId(sample)\n                for sample in variantFile.header.samples])\n            if callSetIds != set(self._callSetIdMap.keys()):\n                raise exceptions.InconsistentCallSetIdException(\n                    variantFile.filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the call set IDs based on the specified variant file.", "response": "def _updateCallSetIds(self, variantFile):\n        \"\"\"\n        Updates the call set IDs based on the specified variant file.\n        \"\"\"\n        if len(self._callSetIdMap) == 0:\n            for sample in variantFile.header.samples:\n                self.addCallSetFromName(sample)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the pysam variant record into a GA4GH Variant object.", "response": "def convertVariant(self, record, callSetIds):\n        \"\"\"\n        Converts the specified pysam variant record into a GA4GH Variant\n        object. Only calls for the specified list of callSetIds will\n        be included.\n        \"\"\"\n        variant = self._createGaVariant()\n        variant.reference_name = record.contig\n        if record.id is not None:\n            variant.names.extend(record.id.split(';'))\n        variant.start = record.start          # 0-based inclusive\n        variant.end = record.stop             # 0-based exclusive\n        variant.reference_bases = record.ref\n        if record.alts is not None:\n            variant.alternate_bases.extend(list(record.alts))\n        filterKeys = record.filter.keys()\n        if len(filterKeys) == 0:\n            variant.filters_applied = False\n        else:\n            variant.filters_applied = True\n            if len(filterKeys) == 1 and filterKeys[0] == 'PASS':\n                variant.filters_passed = True\n            else:\n                variant.filters_passed = False\n                variant.filters_failed.extend(filterKeys)\n        # record.qual is also available, when supported by GAVariant.\n        for key, value in record.info.iteritems():\n            if value is None:\n                continue\n            if key == 'SVTYPE':\n                variant.variant_type = value\n            elif key == 'SVLEN':\n                variant.svlen = int(value[0])\n            elif key == 'CIPOS':\n                variant.cipos.extend(value)\n            elif key == 'CIEND':\n                variant.ciend.extend(value)\n            elif isinstance(value, str):\n                value = value.split(',')\n            protocol.setAttribute(\n                variant.attributes.attr[key].values, value)\n        for callSetId in callSetIds:\n            callSet = self.getCallSet(callSetId)\n            pysamCall = record.samples[str(callSet.getSampleName())]\n            variant.calls.add().CopyFrom(\n                self._convertGaCall(callSet, pysamCall))\n        variant.id = self.getVariantId(variant)\n        return variant"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getPysamVariants(self, referenceName, startPosition, endPosition):\n        if referenceName in self._chromFileMap:\n            varFileName = self._chromFileMap[referenceName]\n            referenceName, startPosition, endPosition = \\\n                self.sanitizeVariantFileFetch(\n                    referenceName, startPosition, endPosition)\n            cursor = self.getFileHandle(varFileName).fetch(\n                referenceName, startPosition, endPosition)\n            for record in cursor:\n                yield record", "response": "Returns an iterator over pysam VCF records corresponding to the specified query."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an iterator over the specified variants.", "response": "def getVariants(self, referenceName, startPosition, endPosition,\n                    callSetIds=[]):\n        \"\"\"\n        Returns an iterator over the specified variants. The parameters\n        correspond to the attributes of a GASearchVariantsRequest object.\n        \"\"\"\n        if callSetIds is None:\n            callSetIds = self._callSetIds\n        else:\n            for callSetId in callSetIds:\n                if callSetId not in self._callSetIds:\n                    raise exceptions.CallSetNotInVariantSetException(\n                        callSetId, self.getId())\n        for record in self.getPysamVariants(\n                referenceName, startPosition, endPosition):\n            yield self.convertVariant(record, callSetIds)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the id of a metadata object", "response": "def getMetadataId(self, metadata):\n        \"\"\"\n        Returns the id of a metadata\n        \"\"\"\n        return str(datamodel.VariantSetMetadataCompoundId(\n            self.getCompoundId(), 'metadata:' + metadata.key))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a GA VariantAnnotation object from this variant set.", "response": "def _createGaVariantAnnotation(self):\n        \"\"\"\n        Convenience method to set the common fields in a GA VariantAnnotation\n        object from this variant set.\n        \"\"\"\n        ret = protocol.VariantAnnotation()\n        ret.created = self._creationTime\n        ret.variant_annotation_set_id = self.getId()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert this VariantAnnotationSet into its GA4GH protocol equivalent.", "response": "def toProtocolElement(self):\n        \"\"\"\n        Converts this VariantAnnotationSet into its GA4GH protocol equivalent.\n        \"\"\"\n        protocolElement = protocol.VariantAnnotationSet()\n        protocolElement.id = self.getId()\n        protocolElement.variant_set_id = self._variantSet.getId()\n        protocolElement.name = self.getLocalId()\n        protocolElement.analysis.CopyFrom(self.getAnalysis())\n        self.serializeAttributes(protocolElement)\n        return protocolElement"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an MD5 hash of the gaVariant and gaVariantAnnotation objects", "response": "def hashVariantAnnotation(cls, gaVariant, gaVariantAnnotation):\n        \"\"\"\n        Produces an MD5 hash of the gaVariant and gaVariantAnnotation objects\n        \"\"\"\n        treffs = [treff.id for treff in gaVariantAnnotation.transcript_effects]\n        return hashlib.md5(\n            \"{}\\t{}\\t{}\\t\".format(\n                gaVariant.reference_bases, tuple(gaVariant.alternate_bases),\n                treffs)\n            ).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a stringified compoundId representing a variantAnnotation.", "response": "def getVariantAnnotationId(self, gaVariant, gaAnnotation):\n        \"\"\"\n        Produces a stringified compoundId representing a variant\n        annotation.\n        :param gaVariant:   protocol.Variant\n        :param gaAnnotation: protocol.VariantAnnotation\n        :return:  compoundId String\n        \"\"\"\n        md5 = self.hashVariantAnnotation(gaVariant, gaAnnotation)\n        compoundId = datamodel.VariantAnnotationCompoundId(\n            self.getCompoundId(), gaVariant.reference_name,\n            str(gaVariant.start), md5)\n        return str(compoundId)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generateVariantAnnotation(self, variant):\n        # To make this reproducible, make a seed based on this\n        # specific variant.\n        seed = self._randomSeed + variant.start + variant.end\n        randomNumberGenerator = random.Random()\n        randomNumberGenerator.seed(seed)\n        ann = protocol.VariantAnnotation()\n        ann.variant_annotation_set_id = str(self.getCompoundId())\n        ann.variant_id = variant.id\n        ann.created = datetime.datetime.now().isoformat() + \"Z\"\n        # make a transcript effect for each alternate base element\n        # multiplied by a random integer (1,5)\n        for base in variant.alternate_bases:\n            ann.transcript_effects.add().CopyFrom(\n                self.generateTranscriptEffect(\n                    variant, ann, base, randomNumberGenerator))\n        ann.id = self.getVariantAnnotationId(variant, ann)\n        return ann", "response": "Generates a random variant annotation based on a given variant."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef populateFromRow(self, annotationSetRecord):\n        self._annotationType = annotationSetRecord.annotationtype\n        self._analysis = protocol.fromJson(\n            annotationSetRecord.analysis, protocol.Analysis)\n        self._creationTime = annotationSetRecord.created\n        self._updatedTime = annotationSetRecord.updated\n        self.setAttributesJson(annotationSetRecord.attributes)", "response": "Populates this VariantAnnotationSet from the specified DB row."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a GA4GH Analysis object for the specified VCF header.", "response": "def _getAnnotationAnalysis(self, varFile):\n        \"\"\"\n        Assembles metadata within the VCF header into a GA4GH Analysis object.\n\n        :return: protocol.Analysis\n        \"\"\"\n        header = varFile.header\n        analysis = protocol.Analysis()\n        formats = header.formats.items()\n        infos = header.info.items()\n        filters = header.filters.items()\n        for prefix, content in [(\"FORMAT\", formats), (\"INFO\", infos),\n                                (\"FILTER\", filters)]:\n            for contentKey, value in content:\n                key = \"{0}.{1}\".format(prefix, value.name)\n                if key not in analysis.attributes.attr:\n                    analysis.attributes.attr[key].Clear()\n                if value.description is not None:\n                    analysis.attributes.attr[\n                        key].values.add().string_value = value.description\n        analysis.created = self._creationTime\n        analysis.updated = self._updatedTime\n        for r in header.records:\n            # Don't add a key to info if there's nothing in the value\n            if r.value is not None:\n                if r.key not in analysis.attributes.attr:\n                    analysis.attributes.attr[r.key].Clear()\n                analysis.attributes.attr[r.key] \\\n                    .values.add().string_value = str(r.value)\n            if r.key == \"created\" or r.key == \"fileDate\":\n                # TODO handle more date formats\n                try:\n                    if '-' in r.value:\n                        fmtStr = \"%Y-%m-%d\"\n                    else:\n                        fmtStr = \"%Y%m%d\"\n                    analysis.created = datetime.datetime.strptime(\n                        r.value, fmtStr).isoformat() + \"Z\"\n                except ValueError:\n                    # is there a logger we should tell?\n                    # print(\"INFO: Could not parse variant annotation time\")\n                    pass  # analysis.create_date_time remains datetime.now()\n            if r.key == \"software\":\n                analysis.software.append(r.value)\n            if r.key == \"name\":\n                analysis.name = r.value\n            if r.key == \"description\":\n                analysis.description = r.value\n        analysis.id = str(datamodel.VariantAnnotationSetAnalysisCompoundId(\n            self._compoundId, \"analysis\"))\n        return analysis"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getVariantAnnotations(self, referenceName, startPosition, endPosition):\n        variantIter = self._variantSet.getPysamVariants(\n            referenceName, startPosition, endPosition)\n        for record in variantIter:\n            yield self.convertVariantAnnotation(record)", "response": "Generator for iterating through the variant annotations in this variant annotation set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a position string to a GA4GH AlleleLocation object.", "response": "def convertLocation(self, pos):\n        \"\"\"\n        Accepts a position string (start/length) and returns\n        a GA4GH AlleleLocation with populated fields.\n        :param pos:\n        :return: protocol.AlleleLocation\n        \"\"\"\n        if isUnspecified(pos):\n            return None\n        coordLen = pos.split('/')\n        if len(coordLen) > 1:\n            allLoc = self._createGaAlleleLocation()\n            allLoc.start = int(coordLen[0]) - 1\n            return allLoc\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert an annotation in HGVS notation and returns an AlleleLocation with populated fields.", "response": "def convertLocationHgvsC(self, hgvsc):\n        \"\"\"\n        Accepts an annotation in HGVS notation and returns\n        an AlleleLocation with populated fields.\n        :param hgvsc:\n        :return:\n        \"\"\"\n        if isUnspecified(hgvsc):\n            return None\n        match = re.match(\".*c.(\\d+)(\\D+)>(\\D+)\", hgvsc)\n        if match:\n            pos = int(match.group(1))\n            if pos > 0:\n                allLoc = self._createGaAlleleLocation()\n                allLoc.start = pos - 1\n                allLoc.reference_sequence = match.group(2)\n                allLoc.alternate_sequence = match.group(3)\n                return allLoc\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convertLocationHgvsP(self, hgvsp):\n        if isUnspecified(hgvsp):\n            return None\n        match = re.match(\".*p.(\\D+)(\\d+)(\\D+)\", hgvsp, flags=re.UNICODE)\n        if match is not None:\n            allLoc = self._createGaAlleleLocation()\n            allLoc.reference_sequence = match.group(1)\n            allLoc.start = int(match.group(2)) - 1\n            allLoc.alternate_sequence = match.group(3)\n            return allLoc\n        return None", "response": "Converts an annotation in HGVS notation and returns an AlleleLocation with populated fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd locations to a GA4GH transcript effect object by parsing HGVS annotation fields in concert with and supplied position values.", "response": "def addLocations(self, effect, protPos, cdnaPos):\n        \"\"\"\n        Adds locations to a GA4GH transcript effect object\n        by parsing HGVS annotation fields in concert with\n        and supplied position values.\n        :param effect: protocol.TranscriptEffect\n        :param protPos: String representing protein position from VCF\n        :param cdnaPos: String representing coding DNA location\n        :return: effect protocol.TranscriptEffect\n        \"\"\"\n        self.addCDSLocation(effect, cdnaPos)\n        self.addCDNALocation(effect, cdnaPos)\n        self.addProteinLocation(effect, protPos)\n        return effect"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convertTranscriptEffect(self, annStr, hgvsG):\n        effect = self._createGaTranscriptEffect()\n        effect.hgvs_annotation.CopyFrom(protocol.HGVSAnnotation())\n        annDict = dict()\n        if self._annotationType == ANNOTATIONS_SNPEFF:\n            annDict = dict(zip(self. SNPEFF_FIELDS, annStr.split(\"|\")))\n        elif self._annotationType == ANNOTATIONS_VEP_V82:\n            annDict = dict(zip(self.VEP_FIELDS, annStr.split(\"|\")))\n        else:\n            annDict = dict(zip(self.CSQ_FIELDS, annStr.split(\"|\")))\n        annDict[\"hgvs_annotation.genomic\"] = hgvsG if hgvsG else u''\n        for key, val in annDict.items():\n            try:\n                protocol.deepSetAttr(effect, key, val)\n            except AttributeError:\n                if val and key not in self.EXCLUDED_FIELDS:\n                    protocol.setAttribute(\n                        effect.attributes.attr[key].values, val)\n        effect.effects.extend(self.convertSeqOntology(annDict.get('effects')))\n        self.addLocations(\n            effect, annDict.get('protPos'), annDict.get('cdnaPos'))\n        effect.id = self.getTranscriptEffectId(effect)\n        return effect", "response": "Converts an ANN string of a SnpEff generated VCF into a GA4GH transcript effect object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a string of sequence ontology effects and creates an array of ontology terms for each.", "response": "def convertSeqOntology(self, seqOntStr):\n        \"\"\"\n        Splits a string of sequence ontology effects and creates\n        an ontology term record for each, which are built into\n        an array of return soTerms.\n        :param seqOntStr:\n        :return: [protocol.OntologyTerm]\n        \"\"\"\n        return [\n            self._ontology.getGaTermByName(soName)\n            for soName in seqOntStr.split('&')]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the specified pysam variant record into a GA4GH variant annotation object using the specified function to convert the variant and transcripts.", "response": "def convertVariantAnnotation(self, record):\n        \"\"\"\n        Converts the specfied pysam variant record into a GA4GH variant\n        annotation object using the specified function to convert the\n        transcripts.\n        \"\"\"\n        variant = self._variantSet.convertVariant(record, [])\n        annotation = self._createGaVariantAnnotation()\n        annotation.variant_id = variant.id\n        gDots = record.info.get(b'HGVS.g')\n        # Convert annotations from INFO field into TranscriptEffect\n        transcriptEffects = []\n        annotations = record.info.get(b'ANN') or record.info.get(b'CSQ')\n        for i, ann in enumerate(annotations):\n            hgvsG = gDots[i % len(variant.alternate_bases)] if gDots else None\n            transcriptEffects.append(self.convertTranscriptEffect(ann, hgvsG))\n        annotation.transcript_effects.extend(transcriptEffects)\n        annotation.id = self.getVariantAnnotationId(variant, annotation)\n        return variant, annotation"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning name = value for a single attribute", "response": "def _attributeStr(self, name):\n        \"\"\"\n        Return name=value for a single attribute\n        \"\"\"\n        return \"{}={}\".format(\n            _encodeAttr(name),\n            \",\".join([_encodeAttr(v) for v in self.attributes[name]]))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _attributeStrs(self):\n        return \";\".join([self._attributeStr(name)\n                         for name in self.attributes.iterkeys()])", "response": "Return name = value semi - colon - separated string for attributes"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the feature name of the record.", "response": "def featureName(self):\n        \"\"\"\n        ID attribute from GFF3 or None if record doesn't have it.\n        Called \"Name\" rather than \"Id\" within GA4GH, as there is\n        no guarantee of either uniqueness or existence.\n        \"\"\"\n        featId = self.attributes.get(\"ID\")\n        if featId is not None:\n            featId = featId[0]\n        return featId"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _linkFeature(self, feature):\n        parentNames = feature.attributes.get(\"Parent\")\n        if parentNames is None:\n            self.roots.add(feature)\n        else:\n            for parentName in parentNames:\n                self._linkToParent(feature, parentName)", "response": "Link a feature with its parents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _linkToParent(self, feature, parentName):\n        parentParts = self.byFeatureName.get(parentName)\n        if parentParts is None:\n            raise GFF3Exception(\n                \"Parent feature does not exist: {}\".format(parentName),\n                self.fileName)\n        # parent maybe disjoint\n        for parentPart in parentParts:\n            feature.parents.add(parentPart)\n            parentPart.children.add(feature)", "response": "Link a feature with its children."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlinking child features to parents", "response": "def linkChildFeaturesToParents(self):\n        \"\"\"\n        finish loading the set, constructing the tree\n        \"\"\"\n        # features maybe disjoint\n        for featureParts in self.byFeatureName.itervalues():\n            for feature in featureParts:\n                self._linkFeature(feature)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the key for a record in the order of genomic coordinates.", "response": "def _recSortKey(r):\n        \"\"\"\n        Sort order for Features, by genomic coordinate,\n        disambiguated by feature type (alphabetically).\n        \"\"\"\n        return r.seqname, r.start, -r.end, r.type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _writeRec(self, fh, rec):\n        fh.write(str(rec) + \"\\n\")\n        for child in sorted(rec.children, key=self._recSortKey):\n            self._writeRec(fh, child)", "response": "Writes a single record to a filehandle fh."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, fh):\n        fh.write(GFF3_HEADER+\"\\n\")\n        for root in sorted(self.roots, key=self._recSortKey):\n            self._writeRec(fh, root)", "response": "Write set to a GFF3 format file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _open(self):\n        if self.fileName.endswith(\".gz\"):\n            return gzip.open(self.fileName)\n        elif self.fileName.endswith(\".bz2\"):\n            return bz2.BZ2File(self.fileName)\n        else:\n            return open(self.fileName)", "response": "Open the input file optionally with decompression"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the attribute value from the attribute string.", "response": "def _parseAttrVal(self, attrStr):\n        \"\"\"\n        Returns tuple of tuple of (attr, value), multiple are returned to\n        handle multi-value attributes.\n        \"\"\"\n        m = self.SPLIT_ATTR_RE.match(attrStr)\n        if m is None:\n            raise GFF3Exception(\n                \"can't parse attribute/value: '\" + attrStr +\n                \"'\", self.fileName, self.lineNumber)\n        name = urllib.unquote(m.group(1))\n        val = m.group(2)\n        # Split by comma to separate then unquote.\n        # Commas in values must be url encoded.\n        return name, [urllib.unquote(v) for v in val.split(',')]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the attributes and values from a string.", "response": "def _parseAttrs(self, attrsStr):\n        \"\"\"\n        Parse the attributes and values\n        \"\"\"\n        attributes = dict()\n        for attrStr in self.SPLIT_ATTR_COL_RE.split(attrsStr):\n            name, vals = self._parseAttrVal(attrStr)\n            if name in attributes:\n                raise GFF3Exception(\n                    \"duplicated attribute name: {}\".format(name),\n                    self.fileName, self.lineNumber)\n            attributes[name] = vals\n        return attributes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self):\n        fh = self._open()\n        try:\n            gff3Set = Gff3Set(self.fileName)\n            for line in fh:\n                self.lineNumber += 1\n                self._parseLine(gff3Set, line[0:-1])\n        finally:\n            fh.close()\n        gff3Set.linkChildFeaturesToParents()\n        return gff3Set", "response": "Run the parse and return the resulting Gff3Set object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the specified dataset to this data repository.", "response": "def addDataset(self, dataset):\n        \"\"\"\n        Adds the specified dataset to this data repository.\n        \"\"\"\n        id_ = dataset.getId()\n        self._datasetIdMap[id_] = dataset\n        self._datasetNameMap[dataset.getLocalId()] = dataset\n        self._datasetIds.append(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the specified reference set to this data repository.", "response": "def addReferenceSet(self, referenceSet):\n        \"\"\"\n        Adds the specified reference set to this data repository.\n        \"\"\"\n        id_ = referenceSet.getId()\n        self._referenceSetIdMap[id_] = referenceSet\n        self._referenceSetNameMap[referenceSet.getLocalId()] = referenceSet\n        self._referenceSetIds.append(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addOntology(self, ontology):\n        self._ontologyNameMap[ontology.getName()] = ontology\n        self._ontologyIdMap[ontology.getId()] = ontology\n        self._ontologyIds.append(ontology.getId())", "response": "Add an ontology to this data repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getPeer(self, url):\n        peers = filter(lambda x: x.getUrl() == url, self.getPeers())\n        if len(peers) == 0:\n            raise exceptions.PeerNotFoundException(url)\n        return peers[0]", "response": "Returns the first peer in the datarepo with the given url."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dataset with the specified ID or raises a NameException if the dataset does not exist.", "response": "def getDataset(self, id_):\n        \"\"\"\n        Returns a dataset with the specified ID, or raises a\n        DatasetNotFoundException if it does not exist.\n        \"\"\"\n        if id_ not in self._datasetIdMap:\n            raise exceptions.DatasetNotFoundException(id_)\n        return self._datasetIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the dataset with the specified name.", "response": "def getDatasetByName(self, name):\n        \"\"\"\n        Returns the dataset with the specified name.\n        \"\"\"\n        if name not in self._datasetNameMap:\n            raise exceptions.DatasetNameNotFoundException(name)\n        return self._datasetNameMap[name]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the ontology with the specified ID.", "response": "def getOntology(self, id_):\n        \"\"\"\n        Returns the ontology with the specified ID.\n        \"\"\"\n        if id_ not in self._ontologyIdMap:\n            raise exceptions.OntologyNotFoundException(id_)\n        return self._ontologyIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getOntologyByName(self, name):\n        if name not in self._ontologyNameMap:\n            raise exceptions.OntologyNameNotFoundException(name)\n        return self._ontologyNameMap[name]", "response": "Returns an ontology by name"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the ReferenceSet with the specified ID or raises a Exception if it does not exist.", "response": "def getReferenceSet(self, id_):\n        \"\"\"\n        Retuns the ReferenceSet with the specified ID, or raises a\n        ReferenceSetNotFoundException if it does not exist.\n        \"\"\"\n        if id_ not in self._referenceSetIdMap:\n            raise exceptions.ReferenceSetNotFoundException(id_)\n        return self._referenceSetIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getReferenceSetByName(self, name):\n        if name not in self._referenceSetNameMap:\n            raise exceptions.ReferenceSetNameNotFoundException(name)\n        return self._referenceSetNameMap[name]", "response": "Returns the reference set with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getReadGroupSet(self, id_):\n        compoundId = datamodel.ReadGroupSetCompoundId.parse(id_)\n        dataset = self.getDataset(compoundId.dataset_id)\n        return dataset.getReadGroupSet(id_)", "response": "Returns the readgroup set with the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the readgroup set with the specified ID.", "response": "def getVariantSet(self, id_):\n        \"\"\"\n        Returns the readgroup set with the specified ID.\n        \"\"\"\n        compoundId = datamodel.VariantSetCompoundId.parse(id_)\n        dataset = self.getDataset(compoundId.dataset_id)\n        return dataset.getVariantSet(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint a summary of this data repository to stdout.", "response": "def printSummary(self):\n        \"\"\"\n        Prints a summary of this data repository to stdout.\n        \"\"\"\n        print(\"Ontologies:\")\n        for ontology in self.getOntologys():\n            print(\n                \"\",\n                ontology.getOntologyPrefix(),\n                ontology.getName(),\n                ontology.getDataUrl(),\n                sep=\"\\t\")\n        print(\"ReferenceSets:\")\n        for referenceSet in self.getReferenceSets():\n            print(\n                \"\", referenceSet.getLocalId(), referenceSet.getId(),\n                referenceSet.getDescription(), referenceSet.getDataUrl(),\n                sep=\"\\t\")\n            for reference in referenceSet.getReferences():\n                print(\n                    \"\\t\", reference.getLocalId(), reference.getId(),\n                    sep=\"\\t\")\n        print(\"Datasets:\")\n        for dataset in self.getDatasets():\n            print(\n                \"\", dataset.getLocalId(), dataset.getId(),\n                dataset.getDescription(), sep=\"\\t\")\n            print(\"\\tReadGroupSets:\")\n            for readGroupSet in dataset.getReadGroupSets():\n                print(\n                    \"\\t\", readGroupSet.getLocalId(),\n                    readGroupSet.getReferenceSet().getLocalId(),\n                    readGroupSet.getId(),\n                    readGroupSet.getDataUrl(), sep=\"\\t\")\n                for readGroup in readGroupSet.getReadGroups():\n                    print(\n                        \"\\t\\t\", readGroup.getId(), readGroup.getLocalId(),\n                        sep=\"\\t\")\n            print(\"\\tVariantSets:\")\n            for variantSet in dataset.getVariantSets():\n                print(\n                    \"\\t\", variantSet.getLocalId(),\n                    variantSet.getReferenceSet().getLocalId(),\n                    variantSet.getId(),\n                    sep=\"\\t\")\n                if variantSet.getNumVariantAnnotationSets() > 0:\n                    print(\"\\t\\tVariantAnnotationSets:\")\n                    for vas in variantSet.getVariantAnnotationSets():\n                        print(\n                            \"\\t\\t\", vas.getLocalId(),\n                            vas.getAnnotationType(),\n                            vas.getOntology().getName(), sep=\"\\t\")\n            print(\"\\tFeatureSets:\")\n            for featureSet in dataset.getFeatureSets():\n                print(\n                    \"\\t\", featureSet.getLocalId(),\n                    featureSet.getReferenceSet().getLocalId(),\n                    featureSet.getOntology().getName(),\n                    featureSet.getId(),\n                    sep=\"\\t\")\n            print(\"\\tContinuousSets:\")\n            for continuousSet in dataset.getContinuousSets():\n                print(\n                    \"\\t\", continuousSet.getLocalId(),\n                    continuousSet.getReferenceSet().getLocalId(),\n                    continuousSet.getId(),\n                    sep=\"\\t\")\n            print(\"\\tPhenotypeAssociationSets:\")\n            for phenotypeAssociationSet in \\\n                    dataset.getPhenotypeAssociationSets():\n                print(\n                    \"\\t\", phenotypeAssociationSet.getLocalId(),\n                    phenotypeAssociationSet.getParentContainer().getId(),\n                    sep=\"\\t\")\n                # TODO -  please improve this listing\n            print(\"\\tRnaQuantificationSets:\")\n            for rna_quantification_set in dataset.getRnaQuantificationSets():\n                print(\n                    \"\\t\", rna_quantification_set.getLocalId(),\n                    rna_quantification_set.getId(), sep=\"\\t\")\n                for quant in rna_quantification_set.getRnaQuantifications():\n                        print(\n                            \"\\t\\t\", quant.getLocalId(),\n                            quant._description,\n                            \",\".join(quant._readGroupIds),\n                            \",\".join(quant._featureSetIds), sep=\"\\t\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterator over all read groups in the data repo", "response": "def allReadGroups(self):\n        \"\"\"\n        Return an iterator over all read groups in the data repo\n        \"\"\"\n        for dataset in self.getDatasets():\n            for readGroupSet in dataset.getReadGroupSets():\n                for readGroup in readGroupSet.getReadGroups():\n                    yield readGroup"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef allFeatures(self):\n        for dataset in self.getDatasets():\n            for featureSet in dataset.getFeatureSets():\n                for feature in featureSet.getFeatures():\n                    yield feature", "response": "Return an iterator over all features in the data repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef allCallSets(self):\n        for dataset in self.getDatasets():\n            for variantSet in dataset.getVariantSets():\n                for callSet in variantSet.getCallSets():\n                    yield callSet", "response": "Returns an iterator over all call sets in the data repo"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef allVariantAnnotationSets(self):\n        for dataset in self.getDatasets():\n            for variantSet in dataset.getVariantSets():\n                for vaSet in variantSet.getVariantAnnotationSets():\n                    yield vaSet", "response": "Returns an iterator over all variant annotation sets in the data repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef allRnaQuantifications(self):\n        for dataset in self.getDatasets():\n            for rnaQuantificationSet in dataset.getRnaQuantificationSets():\n                for rnaQuantification in \\\n                        rnaQuantificationSet.getRnaQuantifications():\n                    yield rnaQuantification", "response": "Returns an iterator over all rna quantifications in this instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an iterator over all expression levels in this instance", "response": "def allExpressionLevels(self):\n        \"\"\"\n        Return an iterator over all expression levels\n        \"\"\"\n        for dataset in self.getDatasets():\n            for rnaQuantificationSet in dataset.getRnaQuantificationSets():\n                for rnaQuantification in \\\n                        rnaQuantificationSet.getRnaQuantifications():\n                    for expressionLevel in \\\n                            rnaQuantification.getExpressionLevels():\n                        yield expressionLevel"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind a peer by URL and return the first peer record with that URL.", "response": "def getPeer(self, url):\n        \"\"\"\n        Finds a peer by URL and return the first peer record with that URL.\n        \"\"\"\n        peers = list(models.Peer.select().where(models.Peer.url == url))\n        if len(peers) == 0:\n            raise exceptions.PeerNotFoundException(url)\n        return peers[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getPeers(self, offset=0, limit=1000):\n        select = models.Peer.select().order_by(\n            models.Peer.url).limit(limit).offset(offset)\n        return [peers.Peer(p.url, record=p) for p in select]", "response": "Get the list of peers using an SQL offset and limit. Returns a list of peers in a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a model class and attempts to create a table in TSV format", "response": "def tableToTsv(self, model):\n        \"\"\"\n        Takes a model class and attempts to create a table in TSV format\n        that can be imported into a spreadsheet program.\n        \"\"\"\n        first = True\n        for item in model.select():\n            if first:\n                header = \"\".join(\n                    [\"{}\\t\".format(x) for x in model._meta.fields.keys()])\n                print(header)\n                first = False\n            row = \"\".join(\n                [\"{}\\t\".format(\n                    getattr(item, key)) for key in model._meta.fields.keys()])\n            print(row)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clearAnnouncements(self):\n        try:\n            q = models.Announcement.delete().where(\n                models.Announcement.id > 0)\n            q.execute()\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)", "response": "Clears the announcement table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insertAnnouncement(self, announcement):\n        url = announcement.get('url', None)\n        try:\n            peers.Peer(url)\n        except:\n            raise exceptions.BadUrlException(url)\n        try:\n            # TODO get more details about the user agent\n            models.Announcement.create(\n                url=announcement.get('url'),\n                attributes=json.dumps(announcement.get('attributes', {})),\n                remote_addr=announcement.get('remote_addr', None),\n                user_agent=announcement.get('user_agent', None))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)", "response": "Inserts an announcement into the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens this repo in the specified mode.", "response": "def open(self, mode=MODE_READ):\n        \"\"\"\n        Opens this repo in the specified mode.\n\n        TODO: figure out the correct semantics of this and document\n        the intended future behaviour as well as the current\n        transitional behaviour.\n        \"\"\"\n        if mode not in [MODE_READ, MODE_WRITE]:\n            error = \"Open mode must be '{}' or '{}'\".format(\n                MODE_READ, MODE_WRITE)\n            raise ValueError(error)\n        self._openMode = mode\n        if mode == MODE_READ:\n            self.assertExists()\n        if mode == MODE_READ:\n            # This is part of the transitional behaviour where\n            # we load the whole DB into memory to get access to\n            # the data model.\n            self.load()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verify(self):\n        # TODO this should emit to a log that we can configure so we can\n        # have verbosity levels. We should provide a way to configure\n        # where we look at various chromosomes and so on. This will be\n        # an important debug tool for administrators.\n        for ontology in self.getOntologys():\n            print(\n                \"Verifying Ontology\", ontology.getName(),\n                \"@\", ontology.getDataUrl())\n            # TODO how do we verify this? Check some well-know SO terms?\n        for referenceSet in self.getReferenceSets():\n            print(\n                \"Verifying ReferenceSet\", referenceSet.getLocalId(),\n                \"@\", referenceSet.getDataUrl())\n            for reference in referenceSet.getReferences():\n                length = min(reference.getLength(), 1000)\n                bases = reference.getBases(0, length)\n                assert len(bases) == length\n                print(\n                    \"\\tReading\", length, \"bases from\",\n                    reference.getLocalId())\n        for dataset in self.getDatasets():\n            print(\"Verifying Dataset\", dataset.getLocalId())\n            for featureSet in dataset.getFeatureSets():\n                for referenceSet in self.getReferenceSets():\n                    # TODO cycle through references?\n                    reference = referenceSet.getReferences()[0]\n                    print(\n                        \"\\tVerifying FeatureSet\",\n                        featureSet.getLocalId(),\n                        \"with reference\", reference.getLocalId())\n                    length = min(reference.getLength(), 1000)\n                    features = featureSet.getFeatures(\n                        reference.getLocalId(), 0, length, None, 3)\n                    for feature in features:\n                        print(\"\\t{}\".format(feature))\n            # for continuousSet in dataset.getContinuousSets():\n            # -- there is no getContinuous\n            for readGroupSet in dataset.getReadGroupSets():\n                print(\n                    \"\\tVerifying ReadGroupSet\", readGroupSet.getLocalId(),\n                    \"@\", readGroupSet.getDataUrl())\n                references = readGroupSet.getReferenceSet().getReferences()\n                # TODO should we cycle through the references? Should probably\n                # be an option.\n                reference = references[0]\n                max_alignments = 10\n                for readGroup in readGroupSet.getReadGroups():\n                    alignments = readGroup.getReadAlignments(reference)\n                    for i, alignment in enumerate(alignments):\n                        if i == max_alignments:\n                            break\n                    print(\n                        \"\\t\\tRead\", i, \"alignments from\",\n                        readGroup.getLocalId())\n            for variantSet in dataset.getVariantSets():\n                print(\"\\tVerifying VariantSet\", variantSet.getLocalId())\n                max_variants = 10\n                max_annotations = 10\n                refMap = variantSet.getReferenceToDataUrlIndexMap()\n                for referenceName, (dataUrl, indexFile) in refMap.items():\n                    variants = variantSet.getVariants(referenceName, 0, 2**31)\n                    for i, variant in enumerate(variants):\n                        if i == max_variants:\n                            break\n                    print(\n                        \"\\t\\tRead\", i, \"variants from reference\",\n                        referenceName, \"@\", dataUrl)\n                for annotationSet in variantSet.getVariantAnnotationSets():\n                    print(\n                        \"\\t\\tVerifying VariantAnnotationSet\",\n                        annotationSet.getLocalId())\n                    for referenceName in refMap.keys():\n                        annotations = annotationSet.getVariantAnnotations(\n                            referenceName, 0, 2**31)\n                        for i, annotation in enumerate(annotations):\n                            if i == max_annotations:\n                                break\n                    print(\n                        \"\\t\\t\\tRead\", i, \"annotations from reference\",\n                        referenceName)\n            for phenotypeAssociationSet \\\n                    in dataset.getPhenotypeAssociationSets():\n                print(\"\\t\\tVerifying PhenotypeAssociationSet\")\n                print(\n                    \"\\t\\t\\t\", phenotypeAssociationSet.getLocalId(),\n                    phenotypeAssociationSet.getParentContainer().getId(),\n                    sep=\"\\t\")", "response": "Verify that the data in the repository is consistent."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting the specified ontology into this repository.", "response": "def insertOntology(self, ontology):\n        \"\"\"\n        Inserts the specified ontology into this repository.\n        \"\"\"\n        try:\n            models.Ontology.create(\n                    id=ontology.getName(),\n                    name=ontology.getName(),\n                    dataurl=ontology.getDataUrl(),\n                    ontologyprefix=ontology.getOntologyPrefix())\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                ontology.getName())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef removeOntology(self, ontology):\n        q = models.Ontology.delete().where(id == ontology.getId())\n        q.execute()", "response": "Removes the specified ontology term map from this repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert the specified reference into this repository.", "response": "def insertReference(self, reference):\n        \"\"\"\n        Inserts the specified reference into this repository.\n        \"\"\"\n        models.Reference.create(\n            id=reference.getId(),\n            referencesetid=reference.getParentContainer().getId(),\n            name=reference.getLocalId(),\n            length=reference.getLength(),\n            isderived=reference.getIsDerived(),\n            species=json.dumps(reference.getSpecies()),\n            md5checksum=reference.getMd5Checksum(),\n            sourceaccessions=json.dumps(reference.getSourceAccessions()),\n            sourceuri=reference.getSourceUri())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert the specified referenceSet into this repository.", "response": "def insertReferenceSet(self, referenceSet):\n        \"\"\"\n        Inserts the specified referenceSet into this repository.\n        \"\"\"\n        try:\n            models.Referenceset.create(\n                id=referenceSet.getId(),\n                name=referenceSet.getLocalId(),\n                description=referenceSet.getDescription(),\n                assemblyid=referenceSet.getAssemblyId(),\n                isderived=referenceSet.getIsDerived(),\n                species=json.dumps(referenceSet.getSpecies()),\n                md5checksum=referenceSet.getMd5Checksum(),\n                sourceaccessions=json.dumps(\n                    referenceSet.getSourceAccessions()),\n                sourceuri=referenceSet.getSourceUri(),\n                dataurl=referenceSet.getDataUrl())\n            for reference in referenceSet.getReferences():\n                self.insertReference(reference)\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                referenceSet.getLocalId())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insertDataset(self, dataset):\n        try:\n            models.Dataset.create(\n                id=dataset.getId(),\n                name=dataset.getLocalId(),\n                description=dataset.getDescription(),\n                attributes=json.dumps(dataset.getAttributes()))\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                dataset.getLocalId())", "response": "Inserts the specified dataset into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the specified dataset from this repository.", "response": "def removeDataset(self, dataset):\n        \"\"\"\n        Removes the specified dataset from this repository. This performs\n        a cascading removal of all items within this dataset.\n        \"\"\"\n        for datasetRecord in models.Dataset.select().where(\n                        models.Dataset.id == dataset.getId()):\n            datasetRecord.delete_instance(recursive=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removePhenotypeAssociationSet(self, phenotypeAssociationSet):\n        q = models.Phenotypeassociationset.delete().where(\n            models.Phenotypeassociationset.id ==\n            phenotypeAssociationSet.getId())\n        q.execute()", "response": "Removes a phenotype association set from the repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the specified featureSet from this repository.", "response": "def removeFeatureSet(self, featureSet):\n        \"\"\"\n        Removes the specified featureSet from this repository.\n        \"\"\"\n        q = models.Featureset.delete().where(\n            models.Featureset.id == featureSet.getId())\n        q.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the specified continuousSet from this repository.", "response": "def removeContinuousSet(self, continuousSet):\n        \"\"\"\n        Removes the specified continuousSet from this repository.\n        \"\"\"\n        q = models.ContinuousSet.delete().where(\n            models.ContinuousSet.id == continuousSet.getId())\n        q.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninsert the specified readGroup into the DB.", "response": "def insertReadGroup(self, readGroup):\n        \"\"\"\n        Inserts the specified readGroup into the DB.\n        \"\"\"\n        statsJson = json.dumps(protocol.toJsonDict(readGroup.getStats()))\n        experimentJson = json.dumps(\n            protocol.toJsonDict(readGroup.getExperiment()))\n        try:\n            models.Readgroup.create(\n                id=readGroup.getId(),\n                readgroupsetid=readGroup.getParentContainer().getId(),\n                name=readGroup.getLocalId(),\n                predictedinsertedsize=readGroup.getPredictedInsertSize(),\n                samplename=readGroup.getSampleName(),\n                description=readGroup.getDescription(),\n                stats=statsJson,\n                experiment=experimentJson,\n                biosampleid=readGroup.getBiosampleId(),\n                attributes=json.dumps(readGroup.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the specified readGroupSet from this repository.", "response": "def removeReadGroupSet(self, readGroupSet):\n        \"\"\"\n        Removes the specified readGroupSet from this repository. This performs\n        a cascading removal of all items within this readGroupSet.\n        \"\"\"\n        for readGroupSetRecord in models.Readgroupset.select().where(\n                        models.Readgroupset.id == readGroupSet.getId()):\n            readGroupSetRecord.delete_instance(recursive=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef removeVariantSet(self, variantSet):\n        for variantSetRecord in models.Variantset.select().where(\n                        models.Variantset.id == variantSet.getId()):\n            variantSetRecord.delete_instance(recursive=True)", "response": "Removes the specified variantSet from this repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef removeBiosample(self, biosample):\n        q = models.Biosample.delete().where(\n            models.Biosample.id == biosample.getId())\n        q.execute()", "response": "Removes the specified biosample from this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the specified individual from this repository.", "response": "def removeIndividual(self, individual):\n        \"\"\"\n        Removes the specified individual from this repository.\n        \"\"\"\n        q = models.Individual.delete().where(\n            models.Individual.id == individual.getId())\n        q.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts a the specified readGroupSet into this repository.", "response": "def insertReadGroupSet(self, readGroupSet):\n        \"\"\"\n        Inserts a the specified readGroupSet into this repository.\n        \"\"\"\n        programsJson = json.dumps(\n            [protocol.toJsonDict(program) for program in\n             readGroupSet.getPrograms()])\n        statsJson = json.dumps(protocol.toJsonDict(readGroupSet.getStats()))\n        try:\n            models.Readgroupset.create(\n                id=readGroupSet.getId(),\n                datasetid=readGroupSet.getParentContainer().getId(),\n                referencesetid=readGroupSet.getReferenceSet().getId(),\n                name=readGroupSet.getLocalId(),\n                programs=programsJson,\n                stats=statsJson,\n                dataurl=readGroupSet.getDataUrl(),\n                indexfile=readGroupSet.getIndexFile(),\n                attributes=json.dumps(readGroupSet.getAttributes()))\n            for readGroup in readGroupSet.getReadGroups():\n                self.insertReadGroup(readGroup)\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the specified referenceSet from this repository.", "response": "def removeReferenceSet(self, referenceSet):\n        \"\"\"\n        Removes the specified referenceSet from this repository. This performs\n        a cascading removal of all references within this referenceSet.\n        However, it does not remove any of the ReadGroupSets or items that\n        refer to this ReferenceSet. These must be deleted before the\n        referenceSet can be removed.\n        \"\"\"\n        try:\n            q = models.Reference.delete().where(\n                    models.Reference.referencesetid == referenceSet.getId())\n            q.execute()\n            q = models.Referenceset.delete().where(\n                    models.Referenceset.id == referenceSet.getId())\n            q.execute()\n        except Exception:\n            msg = (\"Unable to delete reference set.  \"\n                   \"There are objects currently in the registry which are \"\n                   \"aligned against it.  Remove these objects before removing \"\n                   \"the reference set.\")\n            raise exceptions.RepoManagerException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insertVariantAnnotationSet(self, variantAnnotationSet):\n        analysisJson = json.dumps(\n            protocol.toJsonDict(variantAnnotationSet.getAnalysis()))\n        try:\n            models.Variantannotationset.create(\n                id=variantAnnotationSet.getId(),\n                variantsetid=variantAnnotationSet.getParentContainer().getId(),\n                ontologyid=variantAnnotationSet.getOntology().getId(),\n                name=variantAnnotationSet.getLocalId(),\n                analysis=analysisJson,\n                annotationtype=variantAnnotationSet.getAnnotationType(),\n                created=variantAnnotationSet.getCreationTime(),\n                updated=variantAnnotationSet.getUpdatedTime(),\n                attributes=json.dumps(variantAnnotationSet.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)", "response": "Inserts a the specified VariantAnnotationSet into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insertCallSet(self, callSet):\n        try:\n            models.Callset.create(\n                id=callSet.getId(),\n                name=callSet.getLocalId(),\n                variantsetid=callSet.getParentContainer().getId(),\n                biosampleid=callSet.getBiosampleId(),\n                attributes=json.dumps(callSet.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)", "response": "Inserts a the specified callSet into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insertVariantSet(self, variantSet):\n        # We cheat a little here with the VariantSetMetadata, and encode these\n        # within the table as a JSON dump. These should really be stored in\n        # their own table\n        metadataJson = json.dumps(\n            [protocol.toJsonDict(metadata) for metadata in\n             variantSet.getMetadata()])\n        urlMapJson = json.dumps(variantSet.getReferenceToDataUrlIndexMap())\n        try:\n            models.Variantset.create(\n                id=variantSet.getId(),\n                datasetid=variantSet.getParentContainer().getId(),\n                referencesetid=variantSet.getReferenceSet().getId(),\n                name=variantSet.getLocalId(),\n                created=datetime.datetime.now(),\n                updated=datetime.datetime.now(),\n                metadata=metadataJson,\n                dataurlindexmap=urlMapJson,\n                attributes=json.dumps(variantSet.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)\n        for callSet in variantSet.getCallSets():\n            self.insertCallSet(callSet)", "response": "Inserts a the specified VariantSet into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insertFeatureSet(self, featureSet):\n        # TODO add support for info and sourceUri fields.\n        try:\n            models.Featureset.create(\n                id=featureSet.getId(),\n                datasetid=featureSet.getParentContainer().getId(),\n                referencesetid=featureSet.getReferenceSet().getId(),\n                ontologyid=featureSet.getOntology().getId(),\n                name=featureSet.getLocalId(),\n                dataurl=featureSet.getDataUrl(),\n                attributes=json.dumps(featureSet.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)", "response": "Inserts a the specified featureSet into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert a the specified continuousSet into this repository.", "response": "def insertContinuousSet(self, continuousSet):\n        \"\"\"\n        Inserts a the specified continuousSet into this repository.\n        \"\"\"\n        # TODO add support for info and sourceUri fields.\n        try:\n            models.ContinuousSet.create(\n                id=continuousSet.getId(),\n                datasetid=continuousSet.getParentContainer().getId(),\n                referencesetid=continuousSet.getReferenceSet().getId(),\n                name=continuousSet.getLocalId(),\n                dataurl=continuousSet.getDataUrl(),\n                attributes=json.dumps(continuousSet.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insertBiosample(self, biosample):\n        try:\n            models.Biosample.create(\n                id=biosample.getId(),\n                datasetid=biosample.getParentContainer().getId(),\n                name=biosample.getLocalId(),\n                description=biosample.getDescription(),\n                disease=json.dumps(biosample.getDisease()),\n                created=biosample.getCreated(),\n                updated=biosample.getUpdated(),\n                individualid=biosample.getIndividualId(),\n                attributes=json.dumps(biosample.getAttributes()),\n                individualAgeAtCollection=json.dumps(\n                        biosample.getIndividualAgeAtCollection()))\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                biosample.getLocalId(),\n                biosample.getParentContainer().getLocalId())", "response": "Inserts the specified biosample into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting the specified individual into this repository.", "response": "def insertIndividual(self, individual):\n        \"\"\"\n        Inserts the specified individual into this repository.\n        \"\"\"\n        try:\n            models.Individual.create(\n                id=individual.getId(),\n                datasetId=individual.getParentContainer().getId(),\n                name=individual.getLocalId(),\n                description=individual.getDescription(),\n                created=individual.getCreated(),\n                updated=individual.getUpdated(),\n                species=json.dumps(individual.getSpecies()),\n                sex=json.dumps(individual.getSex()),\n                attributes=json.dumps(individual.getAttributes()))\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                individual.getLocalId(),\n                individual.getParentContainer().getLocalId())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insertPhenotypeAssociationSet(self, phenotypeAssociationSet):\n        datasetId = phenotypeAssociationSet.getParentContainer().getId()\n        attributes = json.dumps(phenotypeAssociationSet.getAttributes())\n        try:\n            models.Phenotypeassociationset.create(\n                id=phenotypeAssociationSet.getId(),\n                name=phenotypeAssociationSet.getLocalId(),\n                datasetid=datasetId,\n                dataurl=phenotypeAssociationSet._dataUrl,\n                attributes=attributes)\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                phenotypeAssociationSet.getParentContainer().getId())", "response": "Inserts the specified phenotype association set into this repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insertRnaQuantificationSet(self, rnaQuantificationSet):\n        try:\n            models.Rnaquantificationset.create(\n                id=rnaQuantificationSet.getId(),\n                datasetid=rnaQuantificationSet.getParentContainer().getId(),\n                referencesetid=rnaQuantificationSet.getReferenceSet().getId(),\n                name=rnaQuantificationSet.getLocalId(),\n                dataurl=rnaQuantificationSet.getDataUrl(),\n                attributes=json.dumps(rnaQuantificationSet.getAttributes()))\n        except Exception:\n            raise exceptions.DuplicateNameException(\n                rnaQuantificationSet.getLocalId(),\n                rnaQuantificationSet.getParentContainer().getLocalId())", "response": "Inserts a the specified rnaQuantificationSet into this repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the specified rnaQuantificationSet from this repository.", "response": "def removeRnaQuantificationSet(self, rnaQuantificationSet):\n        \"\"\"\n        Removes the specified rnaQuantificationSet from this repository. This\n        performs a cascading removal of all items within this\n        rnaQuantificationSet.\n        \"\"\"\n        q = models.Rnaquantificationset.delete().where(\n            models.Rnaquantificationset.id == rnaQuantificationSet.getId())\n        q.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insertPeer(self, peer):\n        try:\n            models.Peer.create(\n                url=peer.getUrl(),\n                attributes=json.dumps(peer.getAttributes()))\n        except Exception as e:\n            raise exceptions.RepoManagerException(e)", "response": "Inserts a peer object into the registry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove peers by URL.", "response": "def removePeer(self, url):\n        \"\"\"\n        Remove peers by URL.\n        \"\"\"\n        q = models.Peer.delete().where(\n            models.Peer.url == url)\n        q.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initialise(self):\n        self._checkWriteMode()\n        self._createSystemTable()\n        self._createNetworkTables()\n        self._createOntologyTable()\n        self._createReferenceSetTable()\n        self._createReferenceTable()\n        self._createDatasetTable()\n        self._createReadGroupSetTable()\n        self._createReadGroupTable()\n        self._createCallSetTable()\n        self._createVariantSetTable()\n        self._createVariantAnnotationSetTable()\n        self._createFeatureSetTable()\n        self._createContinuousSetTable()\n        self._createBiosampleTable()\n        self._createIndividualTable()\n        self._createPhenotypeAssociationSetTable()\n        self._createRnaQuantificationSetTable()", "response": "Initializes the data repository with the necessary data structures."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self):\n        self._readSystemTable()\n        self._readOntologyTable()\n        self._readReferenceSetTable()\n        self._readReferenceTable()\n        self._readDatasetTable()\n        self._readReadGroupSetTable()\n        self._readReadGroupTable()\n        self._readVariantSetTable()\n        self._readCallSetTable()\n        self._readVariantAnnotationSetTable()\n        self._readFeatureSetTable()\n        self._readContinuousSetTable()\n        self._readBiosampleTable()\n        self._readIndividualTable()\n        self._readPhenotypeAssociationSetTable()\n        self._readRnaQuantificationSetTable()", "response": "Loads the entire data repository into memory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef populateFromRow(self, featureSetRecord):\n        self._dbFilePath = featureSetRecord.dataurl\n        self.setAttributesJson(featureSetRecord.attributes)\n        self.populateFromFile(self._dbFilePath)", "response": "Populates the instance variables of this FeatureSet from the specified featureSetRecord."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef populateFromFile(self, dataUrl):\n        self._dbFilePath = dataUrl\n        # initialize graph\n        self._rdfGraph = rdflib.ConjunctiveGraph()\n        # save the path\n        self._dataUrl = dataUrl\n        self._scanDataFiles(self._dataUrl, ['*.ttl'])\n\n        # extract version\n        cgdTTL = rdflib.URIRef(\"http://data.monarchinitiative.org/ttl/cgd.ttl\")\n        versionInfo = rdflib.URIRef(\n            u'http://www.w3.org/2002/07/owl#versionInfo')\n        self._version = None\n        for _, _, obj in self._rdfGraph.triples((cgdTTL, versionInfo, None)):\n            self._version = obj.toPython()\n\n        # setup location cache\n        self._initializeLocationCache()", "response": "Populates the instance variables of this FeatureSet from the specified data URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding a feature and return ga4gh representation", "response": "def getFeature(self, compoundId):\n        \"\"\"\n        find a feature and return ga4gh representation, use compoundId as\n        featureId\n        \"\"\"\n        feature = self._getFeatureById(compoundId.featureId)\n        feature.id = str(compoundId)\n        return feature"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind a feature and return ga4gh representation use native id as featureId as", "response": "def _getFeatureById(self, featureId):\n        \"\"\"\n        find a feature and return ga4gh representation, use 'native' id as\n        featureId\n        \"\"\"\n        featureRef = rdflib.URIRef(featureId)\n        featureDetails = self._detailTuples([featureRef])\n        feature = {}\n        for detail in featureDetails:\n            feature[detail['predicate']] = []\n\n        for detail in featureDetails:\n            feature[detail['predicate']].append(detail['object'])\n\n        pbFeature = protocol.Feature()\n\n        term = protocol.OntologyTerm()\n        # Schema for feature only supports one type of `type`\n        # here we default to first OBO defined\n        for featureType in sorted(feature[TYPE]):\n            if \"obolibrary\" in featureType:\n                term.term = self._featureTypeLabel(featureType)\n                term.term_id = featureType\n                pbFeature.feature_type.MergeFrom(term)\n                break\n\n        pbFeature.id = featureId\n        # Schema for feature only supports one type of `name` `symbol`\n        # here we default to shortest for symbol and longest for name\n        feature[LABEL].sort(key=len)\n        pbFeature.gene_symbol = feature[LABEL][0]\n        pbFeature.name = feature[LABEL][-1]\n\n        pbFeature.attributes.MergeFrom(protocol.Attributes())\n        for key in feature:\n            for val in sorted(feature[key]):\n                pbFeature.attributes.attr[key].values.add().string_value = val\n\n        if featureId in self._locationMap:\n            location = self._locationMap[featureId]\n            pbFeature.reference_name = location[\"chromosome\"]\n            pbFeature.start = location[\"begin\"]\n            pbFeature.end = location[\"end\"]\n\n        return pbFeature"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nformulate a sparql query string based on parameters start and end", "response": "def _filterSearchFeaturesRequest(self, reference_name, gene_symbol, name,\n                                     start, end):\n        \"\"\"\n        formulate a sparql query string based on parameters\n        \"\"\"\n        filters = []\n        query = self._baseQuery()\n        filters = []\n        location = self._findLocation(reference_name, start, end)\n        if location:\n            filters.append(\"?feature = <{}>\".format(location))\n        if gene_symbol:\n            filters.append('regex(?feature_label, \"{}\")')\n        if name:\n            filters.append(\n                'regex(?feature_label, \"{}\")'.format(name))\n        # apply filters\n        filter = \"FILTER ({})\".format(' && '.join(filters))\n        if len(filters) == 0:\n            filter = \"\"\n        query = query.replace(\"#%FILTER%\", filter)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _findLocation(self, reference_name, start, end):\n        try:\n            # TODO - sequence_annotations does not have build?\n            return self._locationMap['hg19'][reference_name][start][end]\n        except:\n            return None", "response": "find a location key in the locationMap"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addValue(self, protocolElement):\n        self._numElements += 1\n        self._bufferSize += protocolElement.ByteSize()\n        attr = getattr(self._protoObject, self._valueListName)\n        obj = attr.add()\n        obj.CopyFrom(protocolElement)", "response": "Appends the specified protocolElement to the value list for this\n        response."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the response buffer is full and False otherwise.", "response": "def isFull(self):\n        \"\"\"\n        Returns True if the response buffer is full, and False otherwise.\n        The buffer is full if either (1) the number of items in the value\n        list is >= pageSize or (2) the total length of the serialised\n        elements in the page is >= maxBufferSize.\n\n        If page_size or max_response_length were not set in the request\n        then they're not checked.\n        \"\"\"\n        return (\n            (self._pageSize > 0 and self._numElements >= self._pageSize) or\n            (self._bufferSize >= self._maxBufferSize)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getSerializedResponse(self):\n        self._protoObject.next_page_token = pb.string(self._nextPageToken)\n        s = protocol.toJson(self._protoObject)\n        return s", "response": "Returns a string version of the SearchResponse that has been built by this SearchResponseBuilder."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npopulate this Ontology object from the values in the specified DB row.", "response": "def populateFromRow(self, ontologyRecord):\n        \"\"\"\n        Populates this Ontology using values in the specified DB row.\n        \"\"\"\n        self._id = ontologyRecord.id\n        self._dataUrl = ontologyRecord.dataurl\n        self._readFile()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a GA4GH OntologyTerm object by name.", "response": "def getGaTermByName(self, name):\n        \"\"\"\n        Returns a GA4GH OntologyTerm object by name.\n\n        :param name: name of the ontology term, ex. \"gene\".\n        :return: GA4GH OntologyTerm object.\n        \"\"\"\n        # TODO what is the correct value when we have no mapping??\n        termIds = self.getTermIds(name)\n        if len(termIds) == 0:\n            termId = \"\"\n            # TODO add logging for missed term translation.\n        else:\n            # TODO what is the correct behaviour here when we have multiple\n            # IDs matching a given name?\n            termId = termIds[0]\n        term = protocol.OntologyTerm()\n        term.term = name\n        term.term_id = termId\n        return term"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn ( search result as JSON string time elapsed during search", "response": "def timeOneSearch(queryString):\n    \"\"\"\n    Returns (search result as JSON string, time elapsed during search)\n    \"\"\"\n    startTime = time.clock()\n    resultString = backend.runSearchVariants(queryString)\n    endTime = time.clock()\n    elapsedTime = endTime - startTime\n    return resultString, elapsedTime"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef benchmarkOneQuery(request, repeatLimit=3, pageLimit=3):\n    times = []\n    queryString = protocol.toJson(request)\n    for i in range(0, repeatLimit):\n        resultString, elapsedTime = timeOneSearch(queryString)\n        accruedTime = elapsedTime\n        pageCount = 1\n        token = extractNextPageToken(resultString)\n        # Iterate to go beyond the first page of results.\n        while token is not None and pageCount < pageLimit:\n            pageRequest = request\n            pageRequest.page_token = token\n            pageRequestString = protocol.toJson(pageRequest)\n            resultString, elapsedTime = timeOneSearch(pageRequestString)\n            accruedTime += elapsedTime\n            pageCount = pageCount + 1\n            token = extractNextPageToken(resultString)\n        times.append(accruedTime)\n\n    # TODO: more sophisticated statistics. Sometimes we want min(),\n    # sometimes mean = sum() / len(), sometimes other measures,\n    # perhaps exclude outliers...\n\n    # If we compute average we should throw out at least the first one.\n    # return sum(times[2:])/len(times[2:])\n    return min(times)", "response": "Repeat the query several times; perhaps don't go through *all* the\n    pages.  Returns minimum time to run backend.searchVariants() to execute\n    the query (as far as pageLimit allows), *not* including JSON\n    processing to prepare queries or parse responses."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the specified error code into a corresponding class object. Raises a KeyError if the errorCode is not found.", "response": "def getExceptionClass(errorCode):\n    \"\"\"\n    Converts the specified error code into the corresponding class object.\n    Raises a KeyError if the errorCode is not found.\n    \"\"\"\n    classMap = {}\n    for name, class_ in inspect.getmembers(sys.modules[__name__]):\n        if inspect.isclass(class_) and issubclass(class_, BaseServerException):\n            classMap[class_.getErrorCode()] = class_\n    return classMap[errorCode]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef toProtocolElement(self):\n        error = protocol.GAException()\n        error.error_code = self.getErrorCode()\n        error.message = self.getMessage()\n        return error", "response": "Converts this exception into a GA4GH protocol element."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize new reference and perform checks.", "response": "def _init_goterm_ref(self, rec_curr, name, lnum):\n        \"\"\"Initialize new reference and perform checks.\"\"\"\n        if rec_curr is None:\n            return GOTerm()\n        msg = \"PREVIOUS {REC} WAS NOT TERMINATED AS EXPECTED\".format(REC=name)\n        self._die(msg, lnum)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize new typedef and perform checks.", "response": "def _init_typedef(self, typedef_curr, name, lnum):\n        \"\"\"Initialize new typedef and perform checks.\"\"\"\n        if typedef_curr is None:\n            return TypeDef()\n        msg = \"PREVIOUS {REC} WAS NOT TERMINATED AS EXPECTED\".format(REC=name)\n        self._die(msg, lnum)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding new fields to the current reference.", "response": "def _add_to_ref(self, rec_curr, line, lnum):\n        \"\"\"Add new fields to the current reference.\"\"\"\n        # Written by DV Klopfenstein\n        # Examples of record lines containing ':' include:\n        #   id: GO:0000002\n        #   name: mitochondrial genome maintenance\n        #   namespace: biological_process\n        #   def: \"The maintenance of ...\n        #   is_a: GO:0007005 ! mitochondrion organization\n        mtch = re.match(r'^(\\S+):\\s*(\\S.*)$', line)\n        if mtch:\n            field_name = mtch.group(1)\n            field_value = mtch.group(2)\n            if field_name == \"id\":\n                self._chk_none(rec_curr.id, lnum)\n                rec_curr.id = field_value\n            elif field_name == \"alt_id\":\n                rec_curr.alt_ids.append(field_value)\n            elif field_name == \"name\":\n                self._chk_none(rec_curr.name, lnum)\n                rec_curr.name = field_value\n            elif field_name == \"namespace\":\n                self._chk_none(rec_curr.namespace, lnum)\n                rec_curr.namespace = field_value\n            elif field_name == \"is_a\":\n                rec_curr._parents.append(field_value.split()[0])\n            elif field_name == \"is_obsolete\" and field_value == \"true\":\n                rec_curr.is_obsolete = True\n            elif field_name in self.optional_attrs:\n                self.update_rec(rec_curr, field_name, field_value)\n        else:\n            self._die(\"UNEXPECTED FIELD CONTENT: {L}\\n\".format(L=line), lnum)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_rec(self, rec, name, value):\n        # 'def' is a reserved word in python, do not use it as a Class attr.\n        if name == \"def\":\n            name = \"defn\"\n\n        # If we have a relationship, then we will split this into a further\n        # dictionary.\n\n        if hasattr(rec, name):\n            if name not in self.attrs_scalar:\n                if name not in self.attrs_nested:\n                    getattr(rec, name).add(value)\n                else:\n                    self._add_nested(rec, name, value)\n            else:\n                raise Exception(\"ATTR({NAME}) ALREADY SET({VAL})\".format(\n                    NAME=name, VAL=getattr(rec, name)))\n        else: # Initialize new GOTerm attr\n            if name in self.attrs_scalar:\n                setattr(rec, name, value)\n            elif name not in self.attrs_nested:\n                setattr(rec, name, set([value]))\n            else:\n                name = '_{:s}'.format(name)\n                setattr(rec, name, defaultdict(list))\n                self._add_nested(rec, name, value)", "response": "Update the record with optional record."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_to_typedef(self, typedef_curr, line, lnum):\n        mtch = re.match(r'^(\\S+):\\s*(\\S.*)$', line)\n        if mtch:\n            field_name = mtch.group(1)\n            field_value = mtch.group(2).split('!')[0].rstrip()\n\n            if field_name == \"id\":\n                self._chk_none(typedef_curr.id, lnum)\n                typedef_curr.id = field_value\n            elif field_name == \"name\":\n                self._chk_none(typedef_curr.name, lnum)\n                typedef_curr.name = field_value\n            elif field_name == \"transitive_over\":\n                typedef_curr.transitive_over.append(field_value)\n            elif field_name == \"inverse_of\":\n                self._chk_none(typedef_curr.inverse_of, lnum)\n                typedef_curr.inverse_of = field_value\n            # Note: there are other tags that aren't imported here.\n        else:\n            self._die(\"UNEXPECTED FIELD CONTENT: {L}\\n\".format(L=line), lnum)", "response": "Add new fields to the current typedef."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a term s nested attributes.", "response": "def _add_nested(self, rec, name, value):\n        \"\"\"Adds a term's nested attributes.\"\"\"\n        # Remove comments and split term into typedef / target term.\n        (typedef, target_term) = value.split('!')[0].rstrip().split(' ')\n\n        # Save the nested term.\n        getattr(rec, name)[typedef].append(target_term)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the internal state of the optional attributes.", "response": "def _init_optional_attrs(self, optional_attrs):\n        \"\"\"Prepare to store data from user-desired optional fields.\n\n          Not loading these optional fields by default saves in space and speed.\n          But allow the possibility for saving these fields, if the user desires,\n            Including:\n              comment consider def is_class_level is_metadata_tag is_transitive\n              relationship replaced_by subset synonym transitive_over xref\n        \"\"\"\n        # Written by DV Klopfenstein\n        # Required attributes are always loaded. All others are optionally loaded.\n        self.attrs_req = ['id', 'alt_id', 'name', 'namespace', 'is_a', 'is_obsolete']\n        self.attrs_scalar = ['comment', 'defn',\n                             'is_class_level', 'is_metadata_tag',\n                             'is_transitive', 'transitive_over']\n        self.attrs_nested = frozenset(['relationship'])\n        # Allow user to specify either: 'def' or 'defn'\n        #   'def' is an obo field name, but 'defn' is legal Python attribute name\n        fnc = lambda aopt: aopt if aopt != \"defn\" else \"def\"\n        if optional_attrs is None:\n            optional_attrs = []\n        elif isinstance(optional_attrs, str):\n            optional_attrs = [fnc(optional_attrs)] if optional_attrs not in self.attrs_req else []\n        elif isinstance(optional_attrs, list) or isinstance(optional_attrs, set):\n            optional_attrs = set([fnc(f) for f in optional_attrs if f not in self.attrs_req])\n        else:\n            raise Exception(\"optional_attrs arg MUST BE A str, list, or set.\")\n        self.optional_attrs = optional_attrs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _die(self, msg, lnum):\n        raise Exception(\"**FATAL {FILE}({LNUM}): {MSG}\\n\".format(\n            FILE=self.obo_file, LNUM=lnum, MSG=msg))", "response": "Raise an Exception if the file read is unexpected."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a hierarchy for a GO Term record.", "response": "def write_hier_rec(self, gos_printed, out=sys.stdout,\n                      len_dash=1, max_depth=None, num_child=None, short_prt=False,\n                      include_only=None, go_marks=None,\n                      depth=1, dp=\"-\"):\n        \"\"\"Write hierarchy for a GO Term record.\"\"\"\n        # Added by DV Klopfenstein\n        GO_id = self.id\n        # Shortens hierarchy report by only printing the hierarchy\n        # for the sub-set of user-specified GO terms which are connected.\n        if include_only is not None and GO_id not in include_only:\n          return\n        nrp = short_prt and GO_id in gos_printed\n        if go_marks is not None:\n          out.write('{} '.format('>' if GO_id in go_marks else ' '))\n        if len_dash is not None:\n            # Default character indicating hierarchy level is '-'.\n            # '=' is used to indicate a hierarchical path printed in detail previously.\n            letter = '-' if not nrp or not self.children else '='\n            dp = ''.join([letter]*depth)\n            out.write('{DASHES:{N}} '.format(DASHES=dp, N=len_dash))\n        if num_child is not None:\n            out.write('{N:>5} '.format(N=len(self.get_all_children())))\n        out.write('{GO}\\tL-{L:>02}\\tD-{D:>02}\\t{desc}\\n'.format(\n            GO=self.id, L=self.level, D=self.depth, desc=self.name))\n        # Track GOs previously printed only if needed\n        if short_prt:\n          gos_printed.add(GO_id)\n        # Do not print hierarchy below this turn if it has already been printed\n        if nrp:\n            return\n        depth += 1\n        if max_depth is not None and depth > max_depth:\n            return\n        for p in self.children:\n            p.write_hier_rec(gos_printed, out, len_dash, max_depth, num_child, short_prt,\n                include_only, go_marks,\n                depth, dp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite hierarchy for all GO Terms in obo file.", "response": "def write_hier_all(self, out=sys.stdout,\n                      len_dash=1, max_depth=None, num_child=None, short_prt=False):\n        \"\"\"Write hierarchy for all GO Terms in obo file.\"\"\"\n        # Print: [biological_process, molecular_function, and cellular_component]\n        for go_id in ['GO:0008150', 'GO:0003674', 'GO:0005575']:\n          self.write_hier(go_id, out, len_dash, max_depth, num_child, short_prt, None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_hier(self, GO_id, out=sys.stdout,\n                       len_dash=1, max_depth=None, num_child=None, short_prt=False,\n                       include_only=None, go_marks=None):\n        \"\"\"Write hierarchy for a GO Term.\"\"\"\n        gos_printed = set()\n        self[GO_id].write_hier_rec(gos_printed, out, len_dash, max_depth, num_child,\n            short_prt, include_only, go_marks)", "response": "Write a hierarchy for a GO Term."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all possible paths to the root node that include the given term.", "response": "def paths_to_top(self, term):\n        \"\"\" Returns all possible paths to the root node\n\n            Each path includes the term given. The order of the path is\n            top -> bottom, i.e. it starts with the root and ends with the\n            given term (inclusively).\n\n            Parameters:\n            -----------\n            - term:\n                the id of the GO term, where the paths begin (i.e. the\n                accession 'GO:0003682')\n\n            Returns:\n            --------\n            - a list of lists of GO Terms\n        \"\"\"\n        # error handling consistent with original authors\n        if term not in self:\n            print(\"Term %s not found!\" % term, file=sys.stderr)\n            return\n\n        def _paths_to_top_recursive(rec):\n            if rec.level == 0:\n                return [[rec]]\n            paths = []\n            for parent in rec.parents:\n                top_paths = _paths_to_top_recursive(parent)\n                for top_path in top_paths:\n                    top_path.append(rec)\n                    paths.append(top_path)\n            return paths\n\n        go_term = self[term]\n        return _paths_to_top_recursive(go_term)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws AMIGO style network lineage containing one query record.", "response": "def make_graph_pydot(self, recs, nodecolor,\n                     edgecolor, dpi,\n                     draw_parents=True, draw_children=True):\n        \"\"\"draw AMIGO style network, lineage containing one query record.\"\"\"\n        import pydot\n        G = pydot.Dot(graph_type='digraph', dpi=\"{}\".format(dpi)) # Directed Graph\n        edgeset = set()\n        usr_ids = [rec.id for rec in recs]\n        for rec in recs:\n            if draw_parents:\n                edgeset.update(rec.get_all_parent_edges())\n            if draw_children:\n                edgeset.update(rec.get_all_child_edges())\n\n        lw = self._label_wrap\n        rec_id_set = set([rec_id for endpts in edgeset for rec_id in endpts])\n        nodes = {str(ID):pydot.Node(\n              lw(ID).replace(\"GO:\",\"\"),  # Node name\n              shape=\"box\",\n              style=\"rounded, filled\",\n              # Highlight query terms in plum:\n              fillcolor=\"beige\" if ID not in usr_ids else \"plum\",\n              color=nodecolor)\n                for ID in rec_id_set}\n\n        # add nodes explicitly via add_node\n        for rec_id, node in nodes.items():\n            G.add_node(node)\n\n        for src, target in edgeset:\n            # default layout in graphviz is top->bottom, so we invert\n            # the direction and plot using dir=\"back\"\n            G.add_edge(pydot.Edge(nodes[target], nodes[src],\n              shape=\"normal\",\n              color=edgecolor,\n              label=\"is_a\",\n              dir=\"back\"))\n\n        return G"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunpacking sqlite rows as returned by fetchall into an array of simple dicts.", "response": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef limitsSql(startIndex=0, maxResults=0):\n    if startIndex and maxResults:\n        return \" LIMIT {}, {}\".format(startIndex, maxResults)\n    elif startIndex:\n        raise Exception(\"startIndex was provided, but maxResults was not\")\n    elif maxResults:\n        return \" LIMIT {}\".format(maxResults)\n    else:\n        return \"\"", "response": "Construct a SQL LIMIT clause"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning rows of a sql fetch query on demand iterative fetch", "response": "def iterativeFetch(query, batchSize=default_batch_size):\n    \"\"\"\n    Returns rows of a sql fetch query on demand\n    \"\"\"\n    while True:\n        rows = query.fetchmany(batchSize)\n        if not rows:\n            break\n        rowDicts = sqliteRowsToDicts(rows)\n        for rowDict in rowDicts:\n            yield rowDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parsePageToken(pageToken, numValues):\n    tokens = pageToken.split(\":\")\n    if len(tokens) != numValues:\n        msg = \"Invalid number of values in page token\"\n        raise exceptions.BadPageTokenException(msg)\n    try:\n        values = map(int, tokens)\n    except ValueError:\n        msg = \"Malformed integers in page token\"\n        raise exceptions.BadPageTokenException(msg)\n    return values", "response": "Parses the specified pageToken and returns a list of the specified numValues integers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing an integer argument into an integer.", "response": "def _parseIntegerArgument(args, key, defaultValue):\n    \"\"\"\n    Attempts to parse the specified key in the specified argument\n    dictionary into an integer. If the argument cannot be parsed,\n    raises a BadRequestIntegerException. If the key is not present,\n    return the specified default value.\n    \"\"\"\n    ret = defaultValue\n    try:\n        if key in args:\n            try:\n                ret = int(args[key])\n            except ValueError:\n                raise exceptions.BadRequestIntegerException(key, args[key])\n    except TypeError:\n        raise Exception((key, args))\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts a new iteration.", "response": "def _initialiseIteration(self):\n        \"\"\"\n        Starts a new iteration.\n        \"\"\"\n        self._searchIterator = self._search(\n            self._request.start,\n            self._request.end if self._request.end != 0 else None)\n        self._currentObject = next(self._searchIterator, None)\n        if self._currentObject is not None:\n            self._nextObject = next(self._searchIterator, None)\n            self._searchAnchor = self._request.start\n            self._distanceFromAnchor = 0\n            firstObjectStart = self._getStart(self._currentObject)\n            if firstObjectStart > self._request.start:\n                self._searchAnchor = firstObjectStart"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npicks up iteration from a previously provided page token.", "response": "def _pickUpIteration(self, searchAnchor, objectsToSkip):\n        \"\"\"\n        Picks up iteration from a previously provided page token. There are two\n        different phases here:\n        1) We are iterating over the initial set of intervals in which start\n        is < the search start coorindate.\n        2) We are iterating over the remaining intervals in which start >= to\n        the search start coordinate.\n        \"\"\"\n        self._searchAnchor = searchAnchor\n        self._distanceFromAnchor = objectsToSkip\n        self._searchIterator = self._search(\n            searchAnchor,\n            self._request.end if self._request.end != 0 else None)\n        obj = next(self._searchIterator)\n        if searchAnchor == self._request.start:\n            # This is the initial set of intervals, we just skip forward\n            # objectsToSkip positions\n            for _ in range(objectsToSkip):\n                obj = next(self._searchIterator)\n        else:\n            # Now, we are past this initial set of intervals.\n            # First, we need to skip forward over the intervals where\n            # start < searchAnchor, as we've seen these already.\n            while self._getStart(obj) < searchAnchor:\n                obj = next(self._searchIterator)\n            # Now, we skip over objectsToSkip objects such that\n            # start == searchAnchor\n            for _ in range(objectsToSkip):\n                if self._getStart(obj) != searchAnchor:\n                    raise exceptions.BadPageTokenException\n                obj = next(self._searchIterator)\n        self._currentObject = obj\n        self._nextObject = next(self._searchIterator, None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the next ( object nextPageToken ) pair.", "response": "def next(self):\n        \"\"\"\n        Returns the next (object, nextPageToken) pair.\n        \"\"\"\n        if self._currentObject is None:\n            raise StopIteration()\n        nextPageToken = None\n        if self._nextObject is not None:\n            start = self._getStart(self._nextObject)\n            # If start > the search anchor, move the search anchor. Otherwise,\n            # increment the distance from the anchor.\n            if start > self._searchAnchor:\n                self._searchAnchor = start\n                self._distanceFromAnchor = 0\n            else:\n                self._distanceFromAnchor += 1\n            nextPageToken = \"{}:{}\".format(\n                self._searchAnchor, self._distanceFromAnchor)\n        ret = self._extractProtocolObject(self._currentObject), nextPageToken\n        self._currentObject = self._nextObject\n        self._nextObject = next(self._searchIterator, None)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn true when an annotation should be included.", "response": "def filterVariantAnnotation(self, vann):\n        \"\"\"\n        Returns true when an annotation should be included.\n        \"\"\"\n        # TODO reintroduce feature ID search\n        ret = False\n        if len(self._effects) != 0 and not vann.transcript_effects:\n            return False\n        elif len(self._effects) == 0:\n            return True\n        for teff in vann.transcript_effects:\n            if self.filterEffect(teff):\n                ret = True\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filterEffect(self, teff):\n        ret = False\n        for effect in teff.effects:\n            ret = self._matchAnyEffects(effect) or ret\n        return ret", "response": "Returns true if any of the effect in the teff is present in the request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _checkIdEquality(self, requestedEffect, effect):\n        return self._idPresent(requestedEffect) and (\n            effect.term_id == requestedEffect.term_id)", "response": "Tests whether a requested effect and effect have the same term_id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ga4ghImportGlue():\n    path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    sys.path.append(path)", "response": "This method is used to import a ga4gh module in the scripts dir."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the priority of the file handle.", "response": "def _update(self, dataFile, handle):\n        \"\"\"\n        Update the priority of the file handle. The element is first\n        removed and then added to the left of the deque.\n        \"\"\"\n        self._cache.remove((dataFile, handle))\n        self._add(dataFile, handle)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _removeLru(self):\n        (dataFile, handle) = self._cache.pop()\n        handle.close()\n        return dataFile", "response": "Remove the most recently used file from the deque."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getFileHandle(self, dataFile, openMethod):\n        if dataFile in self._memoTable:\n            handle = self._memoTable[dataFile]\n            self._update(dataFile, handle)\n            return handle\n        else:\n            try:\n                handle = openMethod(dataFile)\n            except ValueError:\n                raise exceptions.FileOpenFailedException(dataFile)\n\n            self._memoTable[dataFile] = handle\n            self._add(dataFile, handle)\n            if len(self._memoTable) > self._maxCacheSize:\n                dataFile = self._removeLru()\n                del self._memoTable[dataFile]\n            return handle", "response": "Returns the handle associated to the dataFile. If the file is already opened update its priority in the cache and return the corresponding handle. If the file is already opened store it in the cache and return the corresponding handle. If the file is too large remove it from the cache and return the corresponding handle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\njoin an array of ids into a compound id string", "response": "def join(cls, splits):\n        \"\"\"\n        Join an array of ids into a compound id string\n        \"\"\"\n        segments = []\n        for split in splits:\n            segments.append('\"{}\",'.format(split))\n        if len(segments) > 0:\n            segments[-1] = segments[-1][:-1]\n        jsonString = '[{}]'.format(''.join(segments))\n        return jsonString"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the specified string and returns an instance of this class.", "response": "def parse(cls, compoundIdStr):\n        \"\"\"\n        Parses the specified compoundId string and returns an instance\n        of this CompoundId class.\n\n        :raises: An ObjectWithIdNotFoundException if parsing fails. This is\n        because this method is a client-facing method, and if a malformed\n        identifier (under our internal rules) is provided, the response should\n        be that the identifier does not exist.\n        \"\"\"\n        if not isinstance(compoundIdStr, basestring):\n            raise exceptions.BadIdentifierException(compoundIdStr)\n        try:\n            deobfuscated = cls.deobfuscate(compoundIdStr)\n        except TypeError:\n            # When a string that cannot be converted to base64 is passed\n            # as an argument, b64decode raises a TypeError. We must treat\n            # this as an ID not found error.\n            raise exceptions.ObjectWithIdNotFoundException(compoundIdStr)\n        try:\n            encodedSplits = cls.split(deobfuscated)\n            splits = [cls.decode(split) for split in encodedSplits]\n        except (UnicodeDecodeError, ValueError):\n            # Sometimes base64 decoding succeeds but we're left with\n            # unicode gibberish. This is also and IdNotFound.\n            raise exceptions.ObjectWithIdNotFoundException(compoundIdStr)\n        # pull the differentiator out of the splits before instantiating\n        # the class, if the differentiator exists\n        fieldsLength = len(cls.fields)\n        if cls.differentiator is not None:\n            differentiatorIndex = cls.fields.index(\n                cls.differentiatorFieldName)\n            if differentiatorIndex < len(splits):\n                del splits[differentiatorIndex]\n            else:\n                raise exceptions.ObjectWithIdNotFoundException(\n                    compoundIdStr)\n            fieldsLength -= 1\n        if len(splits) != fieldsLength:\n            raise exceptions.ObjectWithIdNotFoundException(compoundIdStr)\n        return cls(None, *splits)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef obfuscate(cls, idStr):\n        return unicode(base64.urlsafe_b64encode(\n            idStr.encode('utf-8')).replace(b'=', b''))", "response": "Mildly obfuscates the specified ID string in an easily reversible\n        fashion."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreversing the obfuscation done by the :meth:`obfuscate` method. If an identifier arrives without correct base64 padding this function will append it to the end.", "response": "def deobfuscate(cls, data):\n        \"\"\"\n        Reverses the obfuscation done by the :meth:`obfuscate` method.\n        If an identifier arrives without correct base64 padding this\n        function will append it to the end.\n        \"\"\"\n        # the str() call is necessary to convert the unicode string\n        # to an ascii string since the urlsafe_b64decode method\n        # sometimes chokes on unicode strings\n        return base64.urlsafe_b64decode(str((\n            data + b'A=='[(len(data) - 1) % 4:])))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serializeAttributes(self, msg):\n        attributes = self.getAttributes()\n        for key in attributes:\n            protocol.setAttribute(\n                msg.attributes.attr[key].values, attributes[key])\n        return msg", "response": "Sets the attrbutes of a message during serialization."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nscans the specified directory for files with the specified globbing patterns and calls self. _addDataFile for each. Raises an EmptyDirException if no data files are found.", "response": "def _scanDataFiles(self, dataDir, patterns):\n        \"\"\"\n        Scans the specified directory for files with the specified globbing\n        pattern and calls self._addDataFile for each. Raises an\n        EmptyDirException if no data files are found.\n        \"\"\"\n        numDataFiles = 0\n        for pattern in patterns:\n            scanPath = os.path.join(dataDir, pattern)\n            for filename in glob.glob(scanPath):\n                self._addDataFile(filename)\n                numDataFiles += 1\n        if numDataFiles == 0:\n            raise exceptions.EmptyDirException(dataDir, patterns)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattempting to get a list of peers from a file specified in configuration.", "response": "def getInitialPeerList(filePath, logger=None):\n    \"\"\"\n    Attempts to get a list of peers from a file specified in configuration.\n\n    This file has one URL per line and can contain newlines and comments.\n\n        # Main ga4gh node\n        http://1kgenomes.ga4gh.org\n        # Local intranet peer\n        https://192.168.1.1\n\n    The server will attempt to add URLs in this file to its registry at\n    startup and will log a warning if the file isn't found.\n    \"\"\"\n    ret = []\n    with open(filePath) as textFile:\n        ret = textFile.readlines()\n    if len(ret) == 0:\n        if logger:\n            logger.warn(\"Couldn't load the initial \"\n                        \"peer list. Try adding a \"\n                        \"file named 'initial_peers.txt' \"\n                        \"to {}\".format(os.getcwd()))\n    # Remove lines that start with a hash or are empty.\n    return filter(lambda x: x != \"\" and not x.find(\"#\") != -1, ret)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new peer into the registry.", "response": "def insertInitialPeer(dataRepository, url, logger=None):\n    \"\"\"\n    Takes the datarepository, a url, and an optional logger and attempts\n    to add the peer into the repository.\n    \"\"\"\n    insertPeer = dataRepository.insertPeer\n    try:\n        peer = datamodel.peers.Peer(url)\n        insertPeer(peer)\n    except exceptions.RepoManagerException as exc:\n        if logger:\n            logger.debug(\n                \"Peer already in registry {} {}\".format(peer.getUrl(), exc))\n    except exceptions.BadUrlException as exc:\n        if logger:\n            logger.debug(\"A URL in the initial \"\n                         \"peer list {} was malformed. {}\".format(url), exc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isUrl(urlString):\n    parsed = urlparse.urlparse(urlString)\n    urlparseValid = parsed.netloc != '' and parsed.scheme != ''\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)'\n        r'+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n\n    return regex.match(urlString) and urlparseValid", "response": "Checks if a given URL string is valid by checking the urlparse module and checking the urlparse module for the presence of the scheme netloc and scheme."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setUrl(self, url):\n        if isUrl(url):\n            self._url = url\n        else:\n            raise exceptions.BadUrlException(url)\n        return self", "response": "Set the URL of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setAttributesJson(self, attributesJson):\n        try:\n            self._attributes = json.loads(attributesJson)\n        except:\n            raise exceptions.InvalidJsonException(attributesJson)\n        return self", "response": "Sets the attributes dictionary from a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef populateFromRow(self, peerRecord):\n        self.setUrl(peerRecord.url) \\\n            .setAttributesJson(peerRecord.attributes)\n        return self", "response": "Populates the instance variables of this object from the given database row."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a generator over the results for the specified request which contains a single object of the specified size.", "response": "def _topLevelObjectGenerator(self, request, numObjects, getByIndexMethod):\n        \"\"\"\n        Returns a generator over the results for the specified request, which\n        is over a set of objects of the specified size. The objects are\n        returned by call to the specified method, which must take a single\n        integer as an argument. The returned generator yields a sequence of\n        (object, nextPageToken) pairs, which allows this iteration to be picked\n        up at any point.\n        \"\"\"\n        currentIndex = 0\n        if request.page_token:\n            currentIndex, = paging._parsePageToken(\n                request.page_token, 1)\n        while currentIndex < numObjects:\n            object_ = getByIndexMethod(currentIndex)\n            currentIndex += 1\n            nextPageToken = None\n            if currentIndex < numObjects:\n                nextPageToken = str(currentIndex)\n            yield object_.toProtocolElement(), nextPageToken"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _protocolObjectGenerator(self, request, numObjects, getByIndexMethod):\n        currentIndex = 0\n        if request.page_token:\n            currentIndex, = paging._parsePageToken(\n                request.page_token, 1)\n        while currentIndex < numObjects:\n            object_ = getByIndexMethod(currentIndex)\n            currentIndex += 1\n            nextPageToken = None\n            if currentIndex < numObjects:\n                nextPageToken = str(currentIndex)\n            yield object_, nextPageToken", "response": "Returns a generator over the results for the specified request from\n        a set of protocol objects of the specified size."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _protocolListGenerator(self, request, objectList):\n        return self._protocolObjectGenerator(\n            request, len(objectList), lambda index: objectList[index])", "response": "Returns a generator over the objects in the specified list using the _protocolObjectGenerator method to generate page tokens."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a generator over the objects in the specified list using the _topLevelObjectGenerator method to generate page tokens.", "response": "def _objectListGenerator(self, request, objectList):\n        \"\"\"\n        Returns a generator over the objects in the specified list using\n        _topLevelObjectGenerator to generate page tokens.\n        \"\"\"\n        return self._topLevelObjectGenerator(\n            request, len(objectList), lambda index: objectList[index])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef datasetsGenerator(self, request):\n        return self._topLevelObjectGenerator(\n            request, self.getDataRepository().getNumDatasets(),\n            self.getDataRepository().getDatasetByIndex)", "response": "Returns a generator over the dataset and nextPageToken pairs that are defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a generator over the phenotypeAssociationSets defined by the specified request.", "response": "def phenotypeAssociationSetsGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (phenotypeAssociationSet, nextPageToken)\n        pairs defined by the specified request\n        \"\"\"\n        dataset = self.getDataRepository().getDataset(request.dataset_id)\n        return self._topLevelObjectGenerator(\n            request, dataset.getNumPhenotypeAssociationSets(),\n            dataset.getPhenotypeAssociationSetByIndex)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a generator over the readGroupSets defined by the specified request.", "response": "def readGroupSetsGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (readGroupSet, nextPageToken) pairs\n        defined by the specified request.\n        \"\"\"\n        dataset = self.getDataRepository().getDataset(request.dataset_id)\n        return self._readGroupSetsGenerator(\n            request, dataset.getNumReadGroupSets(),\n            dataset.getReadGroupSetByIndex)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _readGroupSetsGenerator(self, request, numObjects, getByIndexMethod):\n        currentIndex = 0\n        if request.page_token:\n            currentIndex, = paging._parsePageToken(\n                request.page_token, 1)\n        while currentIndex < numObjects:\n            obj = getByIndexMethod(currentIndex)\n            include = True\n            rgsp = obj.toProtocolElement()\n            if request.name and request.name != obj.getLocalId():\n                include = False\n            if request.biosample_id and include:\n                rgsp.ClearField(\"read_groups\")\n                for readGroup in obj.getReadGroups():\n                    if request.biosample_id == readGroup.getBiosampleId():\n                        rgsp.read_groups.extend(\n                            [readGroup.toProtocolElement()])\n                # If none of the biosamples match and the readgroupset\n                # contains reagroups, don't include in the response\n                if len(rgsp.read_groups) == 0 and \\\n                        len(obj.getReadGroups()) != 0:\n                    include = False\n            currentIndex += 1\n            nextPageToken = None\n            if currentIndex < numObjects:\n                nextPageToken = str(currentIndex)\n            if include:\n                yield rgsp, nextPageToken", "response": "Returns a generator over the results for the specified request which contains the next set of read groups."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef referenceSetsGenerator(self, request):\n        results = []\n        for obj in self.getDataRepository().getReferenceSets():\n            include = True\n            if request.md5checksum:\n                if request.md5checksum != obj.getMd5Checksum():\n                    include = False\n            if request.accession:\n                if request.accession not in obj.getSourceAccessions():\n                    include = False\n            if request.assembly_id:\n                if request.assembly_id != obj.getAssemblyId():\n                    include = False\n            if include:\n                results.append(obj)\n        return self._objectListGenerator(request, results)", "response": "Returns a generator over the pairs of referenceSets that match the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef referencesGenerator(self, request):\n        referenceSet = self.getDataRepository().getReferenceSet(\n            request.reference_set_id)\n        results = []\n        for obj in referenceSet.getReferences():\n            include = True\n            if request.md5checksum:\n                if request.md5checksum != obj.getMd5Checksum():\n                    include = False\n            if request.accession:\n                if request.accession not in obj.getSourceAccessions():\n                    include = False\n            if include:\n                results.append(obj)\n        return self._objectListGenerator(request, results)", "response": "Returns a generator over the pairs of reference and nextPageToken of the objects in the reference set that match the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef variantSetsGenerator(self, request):\n        dataset = self.getDataRepository().getDataset(request.dataset_id)\n        return self._topLevelObjectGenerator(\n            request, dataset.getNumVariantSets(),\n            dataset.getVariantSetByIndex)", "response": "Returns a generator over the variantSets defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef variantAnnotationSetsGenerator(self, request):\n        compoundId = datamodel.VariantSetCompoundId.parse(\n            request.variant_set_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(request.variant_set_id)\n        return self._topLevelObjectGenerator(\n            request, variantSet.getNumVariantAnnotationSets(),\n            variantSet.getVariantAnnotationSetByIndex)", "response": "Returns a generator over the variantAnnotationSets defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef readsGenerator(self, request):\n        if not request.reference_id:\n            raise exceptions.UnmappedReadsNotSupported()\n        if len(request.read_group_ids) < 1:\n            raise exceptions.BadRequestException(\n                \"At least one readGroupId must be specified\")\n        elif len(request.read_group_ids) == 1:\n            return self._readsGeneratorSingle(request)\n        else:\n            return self._readsGeneratorMultiple(request)", "response": "Returns a generator over the read pairs defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef variantsGenerator(self, request):\n        compoundId = datamodel.VariantSetCompoundId \\\n            .parse(request.variant_set_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        intervalIterator = paging.VariantsIntervalIterator(\n            request, variantSet)\n        return intervalIterator", "response": "Returns an iterator over the variants defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator over the pairs of variantAnnotaitons and nextPageToken.", "response": "def variantAnnotationsGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (variantAnnotaitons, nextPageToken) pairs\n        defined by the specified request.\n        \"\"\"\n        compoundId = datamodel.VariantAnnotationSetCompoundId.parse(\n            request.variant_annotation_set_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        variantAnnotationSet = variantSet.getVariantAnnotationSet(\n            request.variant_annotation_set_id)\n        iterator = paging.VariantAnnotationsIntervalIterator(\n            request, variantAnnotationSet)\n        return iterator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an iterator over the features and nextPageToken pairs of the next page.", "response": "def featuresGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (features, nextPageToken) pairs\n        defined by the (JSON string) request.\n        \"\"\"\n        compoundId = None\n        parentId = None\n        if request.feature_set_id != \"\":\n            compoundId = datamodel.FeatureSetCompoundId.parse(\n                request.feature_set_id)\n        if request.parent_id != \"\":\n            compoundParentId = datamodel.FeatureCompoundId.parse(\n                request.parent_id)\n            parentId = compoundParentId.featureId\n            # A client can optionally specify JUST the (compound) parentID,\n            # and the server needs to derive the dataset & featureSet\n            # from this (compound) parentID.\n            if compoundId is None:\n                compoundId = compoundParentId\n            else:\n                # check that the dataset and featureSet of the parent\n                # compound ID is the same as that of the featureSetId\n                mismatchCheck = (\n                    compoundParentId.dataset_id != compoundId.dataset_id or\n                    compoundParentId.feature_set_id !=\n                    compoundId.feature_set_id)\n                if mismatchCheck:\n                    raise exceptions.ParentIncompatibleWithFeatureSet()\n\n        if compoundId is None:\n            raise exceptions.FeatureSetNotSpecifiedException()\n\n        dataset = self.getDataRepository().getDataset(\n            compoundId.dataset_id)\n        featureSet = dataset.getFeatureSet(compoundId.feature_set_id)\n        iterator = paging.FeaturesIterator(\n            request, featureSet, parentId)\n        return iterator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator over the pairs defined by the request.", "response": "def continuousGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (continuous, nextPageToken) pairs\n        defined by the (JSON string) request.\n        \"\"\"\n        compoundId = None\n        if request.continuous_set_id != \"\":\n            compoundId = datamodel.ContinuousSetCompoundId.parse(\n                request.continuous_set_id)\n        if compoundId is None:\n            raise exceptions.ContinuousSetNotSpecifiedException()\n\n        dataset = self.getDataRepository().getDataset(\n            compoundId.dataset_id)\n        continuousSet = dataset.getContinuousSet(request.continuous_set_id)\n        iterator = paging.ContinuousIterator(request, continuousSet)\n        return iterator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef phenotypesGenerator(self, request):\n        # TODO make paging work using SPARQL?\n        compoundId = datamodel.PhenotypeAssociationSetCompoundId.parse(\n            request.phenotype_association_set_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        phenotypeAssociationSet = dataset.getPhenotypeAssociationSet(\n            compoundId.phenotypeAssociationSetId)\n        associations = phenotypeAssociationSet.getAssociations(request)\n        phenotypes = [association.phenotype for association in associations]\n        return self._protocolListGenerator(\n            request, phenotypes)", "response": "Returns a generator over the pairs\n        defined by the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a generator over the pairs of phenotype and annotation objects defined by the request.", "response": "def genotypesPhenotypesGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (phenotypes, nextPageToken) pairs\n        defined by the (JSON string) request\n        \"\"\"\n        # TODO make paging work using SPARQL?\n        compoundId = datamodel.PhenotypeAssociationSetCompoundId.parse(\n            request.phenotype_association_set_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        phenotypeAssociationSet = dataset.getPhenotypeAssociationSet(\n            compoundId.phenotypeAssociationSetId)\n        featureSets = dataset.getFeatureSets()\n        annotationList = phenotypeAssociationSet.getAssociations(\n            request, featureSets)\n        return self._protocolListGenerator(request, annotationList)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef callSetsGenerator(self, request):\n        compoundId = datamodel.VariantSetCompoundId.parse(\n            request.variant_set_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        results = []\n        for obj in variantSet.getCallSets():\n            include = True\n            if request.name:\n                if request.name != obj.getLocalId():\n                    include = False\n            if request.biosample_id:\n                if request.biosample_id != obj.getBiosampleId():\n                    include = False\n            if include:\n                results.append(obj)\n        return self._objectListGenerator(request, results)", "response": "Returns a generator over the callSets defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef featureSetsGenerator(self, request):\n        dataset = self.getDataRepository().getDataset(request.dataset_id)\n        return self._topLevelObjectGenerator(\n            request, dataset.getNumFeatureSets(),\n            dataset.getFeatureSetByIndex)", "response": "Returns a generator over the featureSets defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef continuousSetsGenerator(self, request):\n        dataset = self.getDataRepository().getDataset(request.dataset_id)\n        return self._topLevelObjectGenerator(\n            request, dataset.getNumContinuousSets(),\n            dataset.getContinuousSetByIndex)", "response": "Returns a generator over the continuousSets defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rnaQuantificationSetsGenerator(self, request):\n        dataset = self.getDataRepository().getDataset(request.dataset_id)\n        return self._topLevelObjectGenerator(\n            request, dataset.getNumRnaQuantificationSets(),\n            dataset.getRnaQuantificationSetByIndex)", "response": "Returns a generator over the rnaQuantificationSets defined by the specified request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rnaQuantificationsGenerator(self, request):\n        if len(request.rna_quantification_set_id) < 1:\n            raise exceptions.BadRequestException(\n                \"Rna Quantification Set Id must be specified\")\n        else:\n            compoundId = datamodel.RnaQuantificationSetCompoundId.parse(\n                request.rna_quantification_set_id)\n            dataset = self.getDataRepository().getDataset(\n                compoundId.dataset_id)\n            rnaQuantSet = dataset.getRnaQuantificationSet(\n                compoundId.rna_quantification_set_id)\n        results = []\n        for obj in rnaQuantSet.getRnaQuantifications():\n            include = True\n            if request.biosample_id:\n                if request.biosample_id != obj.getBiosampleId():\n                    include = False\n            if include:\n                results.append(obj)\n        return self._objectListGenerator(request, results)", "response": "Returns a generator over the pairs of rnaQuantification objects and nextPageToken."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an iterator over the ( expressionLevel nextPageToken ) pairs", "response": "def expressionLevelsGenerator(self, request):\n        \"\"\"\n        Returns a generator over the (expressionLevel, nextPageToken) pairs\n        defined by the specified request.\n\n        Currently only supports searching over a specified rnaQuantification\n        \"\"\"\n        rnaQuantificationId = request.rna_quantification_id\n        compoundId = datamodel.RnaQuantificationCompoundId.parse(\n            request.rna_quantification_id)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        rnaQuantSet = dataset.getRnaQuantificationSet(\n            compoundId.rna_quantification_set_id)\n        rnaQuant = rnaQuantSet.getRnaQuantification(rnaQuantificationId)\n        rnaQuantificationId = rnaQuant.getLocalId()\n        iterator = paging.ExpressionLevelsIterator(\n            request, rnaQuant)\n        return iterator"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef runGetRequest(self, obj):\n        protocolElement = obj.toProtocolElement()\n        jsonString = protocol.toJson(protocolElement)\n        return jsonString", "response": "Runs a get request by converting the specified datamodel\n        object into its protocol representation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef runSearchRequest(\n            self, requestStr, requestClass, responseClass, objectGenerator):\n        \"\"\"\n        Runs the specified request. The request is a string containing\n        a JSON representation of an instance of the specified requestClass.\n        We return a string representation of an instance of the specified\n        responseClass in JSON format. Objects are filled into the page list\n        using the specified object generator, which must return\n        (object, nextPageToken) pairs, and be able to resume iteration from\n        any point using the nextPageToken attribute of the request object.\n        \"\"\"\n        self.startProfile()\n        try:\n            request = protocol.fromJson(requestStr, requestClass)\n        except protocol.json_format.ParseError:\n            raise exceptions.InvalidJsonException(requestStr)\n        # TODO How do we detect when the page size is not set?\n        if not request.page_size:\n            request.page_size = self._defaultPageSize\n        if request.page_size < 0:\n            raise exceptions.BadPageSizeException(request.page_size)\n        responseBuilder = response_builder.SearchResponseBuilder(\n            responseClass, request.page_size, self._maxResponseLength)\n        nextPageToken = None\n        for obj, nextPageToken in objectGenerator(request):\n            responseBuilder.addValue(obj)\n            if responseBuilder.isFull():\n                break\n        responseBuilder.setNextPageToken(nextPageToken)\n        responseString = responseBuilder.getSerializedResponse()\n        self.endProfile()\n        return responseString", "response": "Runs the specified request and returns the response string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a listReferenceBases request for the specified ID and request arguments.", "response": "def runListReferenceBases(self, requestJson):\n        \"\"\"\n        Runs a listReferenceBases request for the specified ID and\n        request arguments.\n        \"\"\"\n        # In the case when an empty post request is made to the endpoint\n        # we instantiate an empty ListReferenceBasesRequest.\n        if not requestJson:\n            request = protocol.ListReferenceBasesRequest()\n        else:\n            try:\n                request = protocol.fromJson(\n                    requestJson,\n                    protocol.ListReferenceBasesRequest)\n            except protocol.json_format.ParseError:\n                raise exceptions.InvalidJsonException(requestJson)\n        compoundId = datamodel.ReferenceCompoundId.parse(request.reference_id)\n        referenceSet = self.getDataRepository().getReferenceSet(\n            compoundId.reference_set_id)\n        reference = referenceSet.getReference(request.reference_id)\n        start = request.start\n        end = request.end\n        if end == 0:  # assume meant \"get all\"\n            end = reference.getLength()\n        if request.page_token:\n            pageTokenStr = request.page_token\n            start = paging._parsePageToken(pageTokenStr, 1)[0]\n\n        chunkSize = self._maxResponseLength\n        nextPageToken = None\n        if start + chunkSize < end:\n            end = start + chunkSize\n            nextPageToken = str(start + chunkSize)\n        sequence = reference.getBases(start, end)\n\n        # build response\n        response = protocol.ListReferenceBasesResponse()\n        response.offset = start\n        response.sequence = sequence\n        if nextPageToken:\n            response.next_page_token = nextPageToken\n        return protocol.toJson(response)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a get request for the given id", "response": "def runGetCallSet(self, id_):\n        \"\"\"\n        Returns a callset with the given id\n        \"\"\"\n        compoundId = datamodel.CallSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        callSet = variantSet.getCallSet(id_)\n        return self.runGetRequest(callSet)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef runGetInfo(self, request):\n        return protocol.toJson(protocol.GetInfoResponse(\n            protocol_version=protocol.version))", "response": "Returns information about the service including protocol version."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef runAddAnnouncement(self, flaskrequest):\n        announcement = {}\n        # We want to parse the request ourselves to collect a little more\n        # data about it.\n        try:\n            requestData = protocol.fromJson(\n                flaskrequest.get_data(), protocol.AnnouncePeerRequest)\n            announcement['hostname'] = flaskrequest.host_url\n            announcement['remote_addr'] = flaskrequest.remote_addr\n            announcement['user_agent'] = flaskrequest.headers.get('User-Agent')\n        except AttributeError:\n            # Sometimes in testing we will send protocol requests instead\n            # of flask requests and so the hostname and user agent won't\n            # be present.\n            try:\n                requestData = protocol.fromJson(\n                    flaskrequest, protocol.AnnouncePeerRequest)\n            except Exception as e:\n                raise exceptions.InvalidJsonException(e)\n        except Exception as e:\n            raise exceptions.InvalidJsonException(e)\n\n        # Validate the url before accepting the announcement\n        peer = datamodel.peers.Peer(requestData.peer.url)\n        peer.setAttributesJson(protocol.toJson(\n                requestData.peer.attributes))\n        announcement['url'] = peer.getUrl()\n        announcement['attributes'] = peer.getAttributes()\n        try:\n            self.getDataRepository().insertAnnouncement(announcement)\n        except:\n            raise exceptions.BadRequestException(announcement['url'])\n        return protocol.toJson(\n            protocol.AnnouncePeerResponse(success=True))", "response": "This method parses a flask request and adds an announcement to the announcement table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a ListPeersRequest and returns a ListPeersResponse.", "response": "def runListPeers(self, request):\n        \"\"\"\n        Takes a ListPeersRequest and returns a ListPeersResponse using\n        a page_token and page_size if provided.\n        \"\"\"\n        return self.runSearchRequest(\n            request,\n            protocol.ListPeersRequest,\n            protocol.ListPeersResponse,\n            self.peersGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef runGetVariant(self, id_):\n        compoundId = datamodel.VariantCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        gaVariant = variantSet.getVariant(compoundId)\n        # TODO variant is a special case here, as it's returning a\n        # protocol element rather than a datamodel object. We should\n        # fix this for consistency.\n        jsonString = protocol.toJson(gaVariant)\n        return jsonString", "response": "Runs a VariantGetRequest and returns the JSON representation of the Variant object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a getBiosample request for the specified ID.", "response": "def runGetBiosample(self, id_):\n        \"\"\"\n        Runs a getBiosample request for the specified ID.\n        \"\"\"\n        compoundId = datamodel.BiosampleCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        biosample = dataset.getBiosample(id_)\n        return self.runGetRequest(biosample)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef runGetIndividual(self, id_):\n        compoundId = datamodel.BiosampleCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        individual = dataset.getIndividual(id_)\n        return self.runGetRequest(individual)", "response": "Runs a getIndividual request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef runGetFeature(self, id_):\n        compoundId = datamodel.FeatureCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        featureSet = dataset.getFeatureSet(compoundId.feature_set_id)\n        gaFeature = featureSet.getFeature(compoundId)\n        jsonString = protocol.toJson(gaFeature)\n        return jsonString", "response": "Runs the GetFeature method of the feature object passed in."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runGetReadGroupSet(self, id_):\n        compoundId = datamodel.ReadGroupSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        readGroupSet = dataset.getReadGroupSet(id_)\n        return self.runGetRequest(readGroupSet)", "response": "Runs a readGroupSet request for the given id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runGetReadGroup(self, id_):\n        compoundId = datamodel.ReadGroupCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        readGroupSet = dataset.getReadGroupSet(compoundId.read_group_set_id)\n        readGroup = readGroupSet.getReadGroup(id_)\n        return self.runGetRequest(readGroup)", "response": "Runs a read group request with the given id"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun a getReference request for the specified ID.", "response": "def runGetReference(self, id_):\n        \"\"\"\n        Runs a getReference request for the specified ID.\n        \"\"\"\n        compoundId = datamodel.ReferenceCompoundId.parse(id_)\n        referenceSet = self.getDataRepository().getReferenceSet(\n            compoundId.reference_set_id)\n        reference = referenceSet.getReference(id_)\n        return self.runGetRequest(reference)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a getReferenceSet request for the specified ID.", "response": "def runGetReferenceSet(self, id_):\n        \"\"\"\n        Runs a getReferenceSet request for the specified ID.\n        \"\"\"\n        referenceSet = self.getDataRepository().getReferenceSet(id_)\n        return self.runGetRequest(referenceSet)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runGetVariantSet(self, id_):\n        compoundId = datamodel.VariantSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(id_)\n        return self.runGetRequest(variantSet)", "response": "Runs a getVariantSet request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runGetFeatureSet(self, id_):\n        compoundId = datamodel.FeatureSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        featureSet = dataset.getFeatureSet(id_)\n        return self.runGetRequest(featureSet)", "response": "Runs a getFeatureSet request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a getContinuousSet request for the specified ID.", "response": "def runGetContinuousSet(self, id_):\n        \"\"\"\n        Runs a getContinuousSet request for the specified ID.\n        \"\"\"\n        compoundId = datamodel.ContinuousSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        continuousSet = dataset.getContinuousSet(id_)\n        return self.runGetRequest(continuousSet)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runGetDataset(self, id_):\n        dataset = self.getDataRepository().getDataset(id_)\n        return self.runGetRequest(dataset)", "response": "Runs a getDataset request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runGetVariantAnnotationSet(self, id_):\n        compoundId = datamodel.VariantAnnotationSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        variantAnnotationSet = variantSet.getVariantAnnotationSet(id_)\n        return self.runGetRequest(variantAnnotationSet)", "response": "Runs a getVariantSet request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef runGetRnaQuantification(self, id_):\n        compoundId = datamodel.RnaQuantificationCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        rnaQuantificationSet = dataset.getRnaQuantificationSet(\n            compoundId.rna_quantification_set_id)\n        rnaQuantification = rnaQuantificationSet.getRnaQuantification(id_)\n        return self.runGetRequest(rnaQuantification)", "response": "Runs a getRnaQuantification request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef runGetRnaQuantificationSet(self, id_):\n        compoundId = datamodel.RnaQuantificationSetCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        rnaQuantificationSet = dataset.getRnaQuantificationSet(id_)\n        return self.runGetRequest(rnaQuantificationSet)", "response": "Runs a getRnaQuantificationSet request for the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a getExpressionLevel request for the specified ID.", "response": "def runGetExpressionLevel(self, id_):\n        \"\"\"\n        Runs a getExpressionLevel request for the specified ID.\n        \"\"\"\n        compoundId = datamodel.ExpressionLevelCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        rnaQuantificationSet = dataset.getRnaQuantificationSet(\n            compoundId.rna_quantification_set_id)\n        rnaQuantification = rnaQuantificationSet.getRnaQuantification(\n            compoundId.rna_quantification_id)\n        expressionLevel = rnaQuantification.getExpressionLevel(compoundId)\n        return self.runGetRequest(expressionLevel)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef runSearchReadGroupSets(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchReadGroupSetsRequest,\n            protocol.SearchReadGroupSetsResponse,\n            self.readGroupSetsGenerator)", "response": "Runs the specified SearchReadGroupSetsRequest."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runSearchIndividuals(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchIndividualsRequest,\n            protocol.SearchIndividualsResponse,\n            self.individualsGenerator)", "response": "Runs the specified search request and returns the SearchIndividualsResponse."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef runSearchBiosamples(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchBiosamplesRequest,\n            protocol.SearchBiosamplesResponse,\n            self.biosamplesGenerator)", "response": "Runs the specified SearchBiosamplesRequest."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef runSearchReads(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchReadsRequest,\n            protocol.SearchReadsResponse,\n            self.readsGenerator)", "response": "Runs the specified SearchReadsRequest."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runSearchReferenceSets(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchReferenceSetsRequest,\n            protocol.SearchReferenceSetsResponse,\n            self.referenceSetsGenerator)", "response": "Runs the specified SearchReferenceSetsRequest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun the specified SearchReferenceRequest.", "response": "def runSearchReferences(self, request):\n        \"\"\"\n        Runs the specified SearchReferenceRequest.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchReferencesRequest,\n            protocol.SearchReferencesResponse,\n            self.referencesGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runSearchVariantSets(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchVariantSetsRequest,\n            protocol.SearchVariantSetsResponse,\n            self.variantSetsGenerator)", "response": "Runs the specified SearchVariantSetsRequest."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the specified SearchVariantAnnotationSetsRequest.", "response": "def runSearchVariantAnnotationSets(self, request):\n        \"\"\"\n        Runs the specified SearchVariantAnnotationSetsRequest.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchVariantAnnotationSetsRequest,\n            protocol.SearchVariantAnnotationSetsResponse,\n            self.variantAnnotationSetsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun the specified SearchVariantRequest.", "response": "def runSearchVariants(self, request):\n        \"\"\"\n        Runs the specified SearchVariantRequest.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchVariantsRequest,\n            protocol.SearchVariantsResponse,\n            self.variantsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the specified SearchVariantAnnotationsRequest.", "response": "def runSearchVariantAnnotations(self, request):\n        \"\"\"\n        Runs the specified SearchVariantAnnotationsRequest.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchVariantAnnotationsRequest,\n            protocol.SearchVariantAnnotationsResponse,\n            self.variantAnnotationsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the specified SearchCallSetsRequest.", "response": "def runSearchCallSets(self, request):\n        \"\"\"\n        Runs the specified SearchCallSetsRequest.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchCallSetsRequest,\n            protocol.SearchCallSetsResponse,\n            self.callSetsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun the specified SearchDatasetsRequest.", "response": "def runSearchDatasets(self, request):\n        \"\"\"\n        Runs the specified SearchDatasetsRequest.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchDatasetsRequest,\n            protocol.SearchDatasetsResponse,\n            self.datasetsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the specified SearchFeatureSetsRequest.", "response": "def runSearchFeatureSets(self, request):\n        \"\"\"\n        Returns a SearchFeatureSetsResponse for the specified\n        SearchFeatureSetsRequest object.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchFeatureSetsRequest,\n            protocol.SearchFeatureSetsResponse,\n            self.featureSetsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef runSearchFeatures(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchFeaturesRequest,\n            protocol.SearchFeaturesResponse,\n            self.featuresGenerator)", "response": "Runs the specified SearchFeaturesRequest object and returns a SearchFeaturesResponse object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the specified SearchContinuousSetsRequest object.", "response": "def runSearchContinuousSets(self, request):\n        \"\"\"\n        Returns a SearchContinuousSetsResponse for the specified\n        SearchContinuousSetsRequest object.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchContinuousSetsRequest,\n            protocol.SearchContinuousSetsResponse,\n            self.continuousSetsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runSearchContinuous(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchContinuousRequest,\n            protocol.SearchContinuousResponse,\n            self.continuousGenerator)", "response": "Runs a SearchContinuousRequest object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the specified SearchRnaQuantificationSetsRequest.", "response": "def runSearchRnaQuantificationSets(self, request):\n        \"\"\"\n        Returns a SearchRnaQuantificationSetsResponse for the specified\n        SearchRnaQuantificationSetsRequest object.\n        \"\"\"\n        return self.runSearchRequest(\n            request, protocol.SearchRnaQuantificationSetsRequest,\n            protocol.SearchRnaQuantificationSetsResponse,\n            self.rnaQuantificationSetsGenerator)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef runSearchRnaQuantifications(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchRnaQuantificationsRequest,\n            protocol.SearchRnaQuantificationsResponse,\n            self.rnaQuantificationsGenerator)", "response": "Runs the specified SearchRnaQuantificationRequest object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runSearchExpressionLevels(self, request):\n        return self.runSearchRequest(\n            request, protocol.SearchExpressionLevelsRequest,\n            protocol.SearchExpressionLevelsResponse,\n            self.expressionLevelsGenerator)", "response": "Runs the specified SearchExpressionLevelRequest object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npopulate the instance variables of this Dataset from the specified database row.", "response": "def populateFromRow(self, dataset):\n        \"\"\"\n        Populates the instance variables of this Dataset from the\n        specified database row.\n        \"\"\"\n        self._description = dataset.description\n        self.setAttributesJson(dataset.attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addVariantSet(self, variantSet):\n        id_ = variantSet.getId()\n        self._variantSetIdMap[id_] = variantSet\n        self._variantSetNameMap[variantSet.getLocalId()] = variantSet\n        self._variantSetIds.append(id_)", "response": "Adds the specified variantSet to this dataset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addBiosample(self, biosample):\n        id_ = biosample.getId()\n        self._biosampleIdMap[id_] = biosample\n        self._biosampleIds.append(id_)\n        self._biosampleNameMap[biosample.getName()] = biosample", "response": "Adds the specified biosample to this dataset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the specified individual to this dataset.", "response": "def addIndividual(self, individual):\n        \"\"\"\n        Adds the specified individual to this dataset.\n        \"\"\"\n        id_ = individual.getId()\n        self._individualIdMap[id_] = individual\n        self._individualIds.append(id_)\n        self._individualNameMap[individual.getName()] = individual"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addFeatureSet(self, featureSet):\n        id_ = featureSet.getId()\n        self._featureSetIdMap[id_] = featureSet\n        self._featureSetIds.append(id_)\n        name = featureSet.getLocalId()\n        self._featureSetNameMap[name] = featureSet", "response": "Adds the specified featureSet to this dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the specified continuousSet to this dataset.", "response": "def addContinuousSet(self, continuousSet):\n        \"\"\"\n        Adds the specified continuousSet to this dataset.\n        \"\"\"\n        id_ = continuousSet.getId()\n        self._continuousSetIdMap[id_] = continuousSet\n        self._continuousSetIds.append(id_)\n        name = continuousSet.getLocalId()\n        self._continuousSetNameMap[name] = continuousSet"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the specified readGroupSet to this dataset.", "response": "def addReadGroupSet(self, readGroupSet):\n        \"\"\"\n        Adds the specified readGroupSet to this dataset.\n        \"\"\"\n        id_ = readGroupSet.getId()\n        self._readGroupSetIdMap[id_] = readGroupSet\n        self._readGroupSetNameMap[readGroupSet.getLocalId()] = readGroupSet\n        self._readGroupSetIds.append(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the specified rnaQuantification set to this dataset.", "response": "def addRnaQuantificationSet(self, rnaQuantSet):\n        \"\"\"\n        Adds the specified rnaQuantification set to this dataset.\n        \"\"\"\n        id_ = rnaQuantSet.getId()\n        self._rnaQuantificationSetIdMap[id_] = rnaQuantSet\n        self._rnaQuantificationSetIds.append(id_)\n        name = rnaQuantSet.getLocalId()\n        self._rnaQuantificationSetNameMap[name] = rnaQuantSet"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the VariantSet with the specified name or raises a Exception if it does not exist.", "response": "def getVariantSet(self, id_):\n        \"\"\"\n        Returns the VariantSet with the specified name, or raises a\n        VariantSetNotFoundException otherwise.\n        \"\"\"\n        if id_ not in self._variantSetIdMap:\n            raise exceptions.VariantSetNotFoundException(id_)\n        return self._variantSetIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getVariantSetByName(self, name):\n        if name not in self._variantSetNameMap:\n            raise exceptions.VariantSetNameNotFoundException(name)\n        return self._variantSetNameMap[name]", "response": "Returns a VariantSet with the specified name or raises a\nxt. VariantSetNameNotFoundException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the specified g2p association set to this backend.", "response": "def addPhenotypeAssociationSet(self, phenotypeAssociationSet):\n        \"\"\"\n        Adds the specified g2p association set to this backend.\n        \"\"\"\n        id_ = phenotypeAssociationSet.getId()\n        self._phenotypeAssociationSetIdMap[id_] = phenotypeAssociationSet\n        self._phenotypeAssociationSetNameMap[\n            phenotypeAssociationSet.getLocalId()] = phenotypeAssociationSet\n        self._phenotypeAssociationSetIds.append(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getFeatureSet(self, id_):\n        if id_ not in self._featureSetIdMap:\n            raise exceptions.FeatureSetNotFoundException(id_)\n        return self._featureSetIdMap[id_]", "response": "Returns the FeatureSet with the specified id or raises a\nNameException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the FeatureSet with the specified name or raises a FeatureSetNameNotFoundException if it does not exist.", "response": "def getFeatureSetByName(self, name):\n        \"\"\"\n        Returns the FeatureSet with the specified name, or raises\n        an exception otherwise.\n        \"\"\"\n        if name not in self._featureSetNameMap:\n            raise exceptions.FeatureSetNameNotFoundException(name)\n        return self._featureSetNameMap[name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getContinuousSet(self, id_):\n        if id_ not in self._continuousSetIdMap:\n            raise exceptions.ContinuousSetNotFoundException(id_)\n        return self._continuousSetIdMap[id_]", "response": "Returns the ContinuousSet with the specified id or raises a\nException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getContinuousSetByName(self, name):\n        if name not in self._continuousSetNameMap:\n            raise exceptions.ContinuousSetNameNotFoundException(name)\n        return self._continuousSetNameMap[name]", "response": "Returns the ContinuousSet with the specified name or raises a ContinuousSetNameNotFoundException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Biosample with the specified name or raises a NameException if it does not exist.", "response": "def getBiosampleByName(self, name):\n        \"\"\"\n        Returns a Biosample with the specified name, or raises a\n        BiosampleNameNotFoundException if it does not exist.\n        \"\"\"\n        if name not in self._biosampleNameMap:\n            raise exceptions.BiosampleNameNotFoundException(name)\n        return self._biosampleNameMap[name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getBiosample(self, id_):\n        if id_ not in self._biosampleIdMap:\n            raise exceptions.BiosampleNotFoundException(id_)\n        return self._biosampleIdMap[id_]", "response": "Returns the Biosample with the specified id or raises a BiosampleNotFoundException otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getIndividualByName(self, name):\n        if name not in self._individualNameMap:\n            raise exceptions.IndividualNameNotFoundException(name)\n        return self._individualNameMap[name]", "response": "Returns an individual with the specified name or raises an individual nameNotFoundException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Individual with the specified id or raises an IndividualNotFoundException otherwise.", "response": "def getIndividual(self, id_):\n        \"\"\"\n        Returns the Individual with the specified id, or raises\n        a IndividualNotFoundException otherwise.\n        \"\"\"\n        if id_ not in self._individualIdMap:\n            raise exceptions.IndividualNotFoundException(id_)\n        return self._individualIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getReadGroupSetByName(self, name):\n        if name not in self._readGroupSetNameMap:\n            raise exceptions.ReadGroupSetNameNotFoundException(name)\n        return self._readGroupSetNameMap[name]", "response": "Returns a ReadGroupSet with the specified name or raises a\nNameException if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the ReadGroupSet with the specified name or raises a ReadGroupSetNotFoundException otherwise.", "response": "def getReadGroupSet(self, id_):\n        \"\"\"\n        Returns the ReadGroupSet with the specified name, or raises\n        a ReadGroupSetNotFoundException otherwise.\n        \"\"\"\n        if id_ not in self._readGroupSetIdMap:\n            raise exceptions.ReadGroupNotFoundException(id_)\n        return self._readGroupSetIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getRnaQuantificationSetByName(self, name):\n        if name not in self._rnaQuantificationSetNameMap:\n            raise exceptions.RnaQuantificationSetNameNotFoundException(name)\n        return self._rnaQuantificationSetNameMap[name]", "response": "Returns the RnaQuantification set with the specified name or raises an exception otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getRnaQuantificationSet(self, id_):\n        if id_ not in self._rnaQuantificationSetIdMap:\n            raise exceptions.RnaQuantificationSetNotFoundException(id_)\n        return self._rnaQuantificationSetIdMap[id_]", "response": "Returns the RnaQuantificationSet with the specified name or raises a RnaQuantificationSetNotFoundException otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parseMalformedBamHeader(headerDict):\n    headerString = \" \".join(\n        \"{}:{}\".format(k, v) for k, v in headerDict.items() if k != 'CL')\n    ret = {}\n    for item in headerString.split():\n        key, value = item.split(\":\", 1)\n        # build up dict, casting everything back to original type\n        ret[key] = type(headerDict.get(key, \"\"))(value)\n    if 'CL' in headerDict:\n        ret['CL'] = headerDict['CL']\n    return ret", "response": "Parses the malformed BAM header dictionary into a dictionary of keys and values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getReadAlignments(\n            self, reference, start, end, readGroupSet, readGroup):\n        \"\"\"\n        Returns an iterator over the specified reads\n        \"\"\"\n        # TODO If reference is None, return against all references,\n        # including unmapped reads.\n        samFile = self.getFileHandle(self._dataUrl)\n        referenceName = reference.getLocalId().encode()\n        # TODO deal with errors from htslib\n        start, end = self.sanitizeAlignmentFileFetch(start, end)\n        readAlignments = samFile.fetch(referenceName, start, end)\n        for readAlignment in readAlignments:\n            tags = dict(readAlignment.tags)\n            if readGroup is None:\n                if 'RG' in tags:\n                    alignmentReadGroupLocalId = tags['RG']\n                    readGroupCompoundId = datamodel.ReadGroupCompoundId(\n                        readGroupSet.getCompoundId(),\n                        str(alignmentReadGroupLocalId))\n                yield self.convertReadAlignment(\n                    readAlignment, readGroupSet, str(readGroupCompoundId))\n            else:\n                if self._filterReads:\n                    if 'RG' in tags and tags['RG'] == self._localId:\n                        yield self.convertReadAlignment(\n                            readAlignment, readGroupSet,\n                            str(readGroup.getCompoundId()))\n                else:\n                    yield self.convertReadAlignment(\n                        readAlignment, readGroupSet,\n                        str(readGroup.getCompoundId()))", "response": "Returns an iterator over the specified reads in the specified reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a pysam ReadAlignment to a GA4GH ReadAlignment object.", "response": "def convertReadAlignment(self, read, readGroupSet, readGroupId):\n        \"\"\"\n        Convert a pysam ReadAlignment to a GA4GH ReadAlignment\n        \"\"\"\n        samFile = self.getFileHandle(self._dataUrl)\n        # TODO fill out remaining fields\n        # TODO refine in tandem with code in converters module\n        ret = protocol.ReadAlignment()\n        # ret.fragmentId = 'TODO'\n        ret.aligned_quality.extend(read.query_qualities)\n        ret.aligned_sequence = read.query_sequence\n        if SamFlags.isFlagSet(read.flag, SamFlags.READ_UNMAPPED):\n            ret.ClearField(\"alignment\")\n        else:\n            ret.alignment.CopyFrom(protocol.LinearAlignment())\n            ret.alignment.mapping_quality = read.mapping_quality\n            ret.alignment.position.CopyFrom(protocol.Position())\n            ret.alignment.position.reference_name = samFile.getrname(\n                read.reference_id)\n            ret.alignment.position.position = read.reference_start\n            ret.alignment.position.strand = protocol.POS_STRAND\n            if SamFlags.isFlagSet(read.flag, SamFlags.READ_REVERSE_STRAND):\n                ret.alignment.position.strand = protocol.NEG_STRAND\n            for operation, length in read.cigar:\n                gaCigarUnit = ret.alignment.cigar.add()\n                gaCigarUnit.operation = SamCigar.int2ga(operation)\n                gaCigarUnit.operation_length = length\n                gaCigarUnit.reference_sequence = \"\"  # TODO fix this!\n        ret.duplicate_fragment = SamFlags.isFlagSet(\n            read.flag, SamFlags.DUPLICATE_READ)\n        ret.failed_vendor_quality_checks = SamFlags.isFlagSet(\n            read.flag, SamFlags.FAILED_QUALITY_CHECK)\n        ret.fragment_length = read.template_length\n        ret.fragment_name = read.query_name\n        for key, value in read.tags:\n            # Useful for inspecting the structure of read tags\n            # print(\"{key} {ktype}: {value}, {vtype}\".format(\n            #     key=key, ktype=type(key), value=value, vtype=type(value)))\n            protocol.setAttribute(ret.attributes.attr[key].values, value)\n\n        if SamFlags.isFlagSet(read.flag, SamFlags.MATE_UNMAPPED):\n            ret.next_mate_position.Clear()\n        else:\n            ret.next_mate_position.Clear()\n            if read.next_reference_id != -1:\n                ret.next_mate_position.reference_name = samFile.getrname(\n                    read.next_reference_id)\n            else:\n                ret.next_mate_position.reference_name = \"\"\n            ret.next_mate_position.position = read.next_reference_start\n            ret.next_mate_position.strand = protocol.POS_STRAND\n            if SamFlags.isFlagSet(read.flag, SamFlags.MATE_REVERSE_STRAND):\n                ret.next_mate_position.strand = protocol.NEG_STRAND\n        if SamFlags.isFlagSet(read.flag, SamFlags.READ_PAIRED):\n            ret.number_reads = 2\n        else:\n            ret.number_reads = 1\n        ret.read_number = -1\n        if SamFlags.isFlagSet(read.flag, SamFlags.FIRST_IN_PAIR):\n            if SamFlags.isFlagSet(read.flag, SamFlags.SECOND_IN_PAIR):\n                ret.read_number = 2\n            else:\n                ret.read_number = 0\n        elif SamFlags.isFlagSet(read.flag, SamFlags.SECOND_IN_PAIR):\n            ret.read_number = 1\n        ret.improper_placement = not SamFlags.isFlagSet(\n            read.flag, SamFlags.READ_PROPER_PAIR)\n        ret.read_group_id = readGroupId\n        ret.secondary_alignment = SamFlags.isFlagSet(\n            read.flag, SamFlags.SECONDARY_ALIGNMENT)\n        ret.supplementary_alignment = SamFlags.isFlagSet(\n            read.flag, SamFlags.SUPPLEMENTARY_ALIGNMENT)\n        ret.id = readGroupSet.getReadAlignmentId(ret)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addReadGroup(self, readGroup):\n        id_ = readGroup.getId()\n        self._readGroupIdMap[id_] = readGroup\n        self._readGroupIds.append(id_)", "response": "Adds the specified ReadGroup to this ReadGroupSet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the ReadGroup with the specified id if it exists in this ReadGroupSet or raises a ReadGroupNotFoundException otherwise.", "response": "def getReadGroup(self, id_):\n        \"\"\"\n        Returns the ReadGroup with the specified id if it exists in this\n        ReadGroupSet, or raises a ReadGroupNotFoundException otherwise.\n        \"\"\"\n        if id_ not in self._readGroupIdMap:\n            raise exceptions.ReadGroupNotFoundException(id_)\n        return self._readGroupIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the GA4GH protocol representation of this ReadGroupSet.", "response": "def toProtocolElement(self):\n        \"\"\"\n        Returns the GA4GH protocol representation of this ReadGroupSet.\n        \"\"\"\n        readGroupSet = protocol.ReadGroupSet()\n        readGroupSet.id = self.getId()\n        readGroupSet.read_groups.extend(\n            [readGroup.toProtocolElement()\n             for readGroup in self.getReadGroups()]\n        )\n        readGroupSet.name = self.getLocalId()\n        readGroupSet.dataset_id = self.getParentContainer().getId()\n        readGroupSet.stats.CopyFrom(self.getStats())\n        self.serializeAttributes(readGroupSet)\n        return readGroupSet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getReadAlignmentId(self, gaAlignment):\n        compoundId = datamodel.ReadAlignmentCompoundId(\n            self.getCompoundId(), gaAlignment.fragment_name)\n        return str(compoundId)", "response": "Returns a string ID suitable for use in the specified GA\n        object in this ReadGroupSet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the GA4GH protocol representation of this read group set s ReadStats.", "response": "def getStats(self):\n        \"\"\"\n        Returns the GA4GH protocol representation of this read group set's\n        ReadStats.\n        \"\"\"\n        stats = protocol.ReadStats()\n        stats.aligned_read_count = self._numAlignedReads\n        stats.unaligned_read_count = self._numUnalignedReads\n        return stats"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an iterator over the specified reads", "response": "def getReadAlignments(self, reference, start=None, end=None):\n        \"\"\"\n        Returns an iterator over the specified reads\n        \"\"\"\n        return self._getReadAlignments(reference, start, end, self, None)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating the instance variables of this ReadGroupSet from the specified database row.", "response": "def populateFromRow(self, readGroupSetRecord):\n        \"\"\"\n        Populates the instance variables of this ReadGroupSet from the\n        specified database row.\n        \"\"\"\n        self._dataUrl = readGroupSetRecord.dataurl\n        self._indexFile = readGroupSetRecord.indexfile\n        self._programs = []\n        for jsonDict in json.loads(readGroupSetRecord.programs):\n            program = protocol.fromJson(json.dumps(jsonDict),\n                                        protocol.Program)\n            self._programs.append(program)\n        stats = protocol.fromJson(readGroupSetRecord.stats, protocol.ReadStats)\n        self._numAlignedReads = stats.aligned_read_count\n        self._numUnalignedReads = stats.unaligned_read_count"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef populateFromFile(self, dataUrl, indexFile=None):\n        self._dataUrl = dataUrl\n        self._indexFile = indexFile\n        if indexFile is None:\n            self._indexFile = dataUrl + \".bai\"\n        samFile = self.getFileHandle(self._dataUrl)\n        self._setHeaderFields(samFile)\n        if 'RG' not in samFile.header or len(samFile.header['RG']) == 0:\n            readGroup = HtslibReadGroup(self, self.defaultReadGroupName)\n            self.addReadGroup(readGroup)\n        else:\n            for readGroupHeader in samFile.header['RG']:\n                readGroup = HtslibReadGroup(self, readGroupHeader['ID'])\n                readGroup.populateFromHeader(readGroupHeader)\n                self.addReadGroup(readGroup)\n        self._bamHeaderReferenceSetName = None\n        for referenceInfo in samFile.header['SQ']:\n            if 'AS' not in referenceInfo:\n                infoDict = parseMalformedBamHeader(referenceInfo)\n            else:\n                infoDict = referenceInfo\n            name = infoDict.get('AS', references.DEFAULT_REFERENCESET_NAME)\n            if self._bamHeaderReferenceSetName is None:\n                self._bamHeaderReferenceSetName = name\n            elif self._bamHeaderReferenceSetName != name:\n                raise exceptions.MultipleReferenceSetsInReadGroupSet(\n                    self._dataUrl, name, self._bamFileReferenceName)\n        self._numAlignedReads = samFile.mapped\n        self._numUnalignedReads = samFile.unmapped", "response": "Populates the instance variables of this ReadGroupSet from the specified dataUrl and indexFile."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef toProtocolElement(self):\n        # TODO this is very incomplete, but we don't have the\n        # implementation to fill out the rest of the fields currently\n        readGroup = protocol.ReadGroup()\n        readGroup.id = self.getId()\n        readGroup.created = self._creationTime\n        readGroup.updated = self._updateTime\n        dataset = self.getParentContainer().getParentContainer()\n        readGroup.dataset_id = dataset.getId()\n        readGroup.name = self.getLocalId()\n        readGroup.predicted_insert_size = pb.int(self.getPredictedInsertSize())\n        referenceSet = self._parentContainer.getReferenceSet()\n        readGroup.sample_name = pb.string(self.getSampleName())\n        readGroup.biosample_id = pb.string(self.getBiosampleId())\n        if referenceSet is not None:\n            readGroup.reference_set_id = referenceSet.getId()\n        readGroup.stats.CopyFrom(self.getStats())\n        readGroup.programs.extend(self.getPrograms())\n        readGroup.description = pb.string(self.getDescription())\n        readGroup.experiment.CopyFrom(self.getExperiment())\n        self.serializeAttributes(readGroup)\n        return readGroup", "response": "Returns the GA4GH protocol representation of this ReadGroup."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the GA4GH protocol representation of this read group s ReadStats.", "response": "def getStats(self):\n        \"\"\"\n        Returns the GA4GH protocol representation of this read group's\n        ReadStats.\n        \"\"\"\n        stats = protocol.ReadStats()\n        stats.aligned_read_count = self.getNumAlignedReads()\n        stats.unaligned_read_count = self.getNumUnalignedReads()\n        # TODO base_count requires iterating through all reads\n        return stats"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the GA4GH protocol representation of this read group s Experiment.", "response": "def getExperiment(self):\n        \"\"\"\n        Returns the GA4GH protocol representation of this read group's\n        Experiment.\n        \"\"\"\n        experiment = protocol.Experiment()\n        experiment.id = self.getExperimentId()\n        experiment.instrument_model = pb.string(self.getInstrumentModel())\n        experiment.sequencing_center = pb.string(self.getSequencingCenter())\n        experiment.description = pb.string(self.getExperimentDescription())\n        experiment.library = pb.string(self.getLibrary())\n        experiment.platform_unit = pb.string(self.getPlatformUnit())\n        experiment.message_create_time = self._iso8601\n        experiment.message_update_time = self._iso8601\n        experiment.run_time = pb.string(self.getRunTime())\n        return experiment"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating the instance variables using the specified SAM header.", "response": "def populateFromHeader(self, readGroupHeader):\n        \"\"\"\n        Populate the instance variables using the specified SAM header.\n        \"\"\"\n        self._sampleName = readGroupHeader.get('SM', None)\n        self._description = readGroupHeader.get('DS', None)\n        if 'PI' in readGroupHeader:\n            self._predictedInsertSize = int(readGroupHeader['PI'])\n        self._instrumentModel = readGroupHeader.get('PL', None)\n        self._sequencingCenter = readGroupHeader.get('CN', None)\n        self._experimentDescription = readGroupHeader.get('DS', None)\n        self._library = readGroupHeader.get('LB', None)\n        self._platformUnit = readGroupHeader.get('PU', None)\n        self._runTime = readGroupHeader.get('DT', None)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating the instance variables using the values in the specified DB row.", "response": "def populateFromRow(self, readGroupRecord):\n        \"\"\"\n        Populate the instance variables using the specified DB row.\n        \"\"\"\n        self._sampleName = readGroupRecord.samplename\n        self._biosampleId = readGroupRecord.biosampleid\n        self._description = readGroupRecord.description\n        self._predictedInsertSize = readGroupRecord.predictedinsertsize\n        stats = protocol.fromJson(readGroupRecord.stats, protocol.ReadStats)\n        self._numAlignedReads = stats.aligned_read_count\n        self._numUnalignedReads = stats.unaligned_read_count\n        experiment = protocol.fromJson(\n            readGroupRecord.experiment, protocol.Experiment)\n        self._instrumentModel = experiment.instrument_model\n        self._sequencingCenter = experiment.sequencing_center\n        self._experimentDescription = experiment.description\n        self._library = experiment.library\n        self._platformUnit = experiment.platform_unit\n        self._runTime = experiment.run_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getNameFromPath(filePath):\n    if len(filePath) == 0:\n        raise ValueError(\"Cannot have empty path for name\")\n    fileName = os.path.split(os.path.normpath(filePath))[1]\n    # We need to handle things like .fa.gz, so we can't use\n    # os.path.splitext\n    ret = fileName.split(\".\")[0]\n    assert ret != \"\"\n    return ret", "response": "Returns the name of the file specified by the specified path without its extensions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexit the repo manager with error status.", "response": "def repoExitError(message):\n    \"\"\"\n    Exits the repo manager with error status.\n    \"\"\"\n    wrapper = textwrap.TextWrapper(\n        break_on_hyphens=False, break_long_words=False)\n    formatted = wrapper.fill(\"{}: error: {}\".format(sys.argv[0], message))\n    sys.exit(formatted)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _updateRepo(self, func, *args, **kwargs):\n        # TODO how do we make this properly transactional?\n        self._repo.open(datarepo.MODE_WRITE)\n        try:\n            func(*args, **kwargs)\n            self._repo.commit()\n        finally:\n            self._repo.close()", "response": "Runs the specified function that updates the repo with the specified arguments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new Ontology to this repo.", "response": "def addOntology(self):\n        \"\"\"\n        Adds a new Ontology to this repo.\n        \"\"\"\n        self._openRepo()\n        name = self._args.name\n        filePath = self._getFilePath(self._args.filePath,\n                                     self._args.relativePath)\n        if name is None:\n            name = getNameFromPath(filePath)\n        ontology = ontologies.Ontology(name)\n        ontology.populateFromFile(filePath)\n        self._updateRepo(self._repo.insertOntology, ontology)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addDataset(self):\n        self._openRepo()\n        dataset = datasets.Dataset(self._args.datasetName)\n        dataset.setDescription(self._args.description)\n        dataset.setAttributes(json.loads(self._args.attributes))\n        self._updateRepo(self._repo.insertDataset, dataset)", "response": "Adds a new dataset into this repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addReferenceSet(self):\n        self._openRepo()\n        name = self._args.name\n        filePath = self._getFilePath(self._args.filePath,\n                                     self._args.relativePath)\n        if name is None:\n            name = getNameFromPath(self._args.filePath)\n        referenceSet = references.HtslibReferenceSet(name)\n        referenceSet.populateFromFile(filePath)\n        referenceSet.setDescription(self._args.description)\n        if self._args.species is not None:\n            referenceSet.setSpeciesFromJson(self._args.species)\n        referenceSet.setIsDerived(self._args.isDerived)\n        referenceSet.setAssemblyId(self._args.assemblyId)\n        referenceSet.setAttributes(json.loads(self._args.attributes))\n        sourceAccessions = []\n        if self._args.sourceAccessions is not None:\n            sourceAccessions = self._args.sourceAccessions.split(\",\")\n        referenceSet.setSourceAccessions(sourceAccessions)\n        referenceSet.setSourceUri(self._args.sourceUri)\n        self._updateRepo(self._repo.insertReferenceSet, referenceSet)", "response": "Adds a new reference set into this repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a new ReadGroupSet into this repo.", "response": "def addReadGroupSet(self):\n        \"\"\"\n        Adds a new ReadGroupSet into this repo.\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        dataUrl = self._args.dataFile\n        indexFile = self._args.indexFile\n        parsed = urlparse.urlparse(dataUrl)\n        # TODO, add https support and others when they have been\n        # tested.\n        if parsed.scheme in ['http', 'ftp']:\n            if indexFile is None:\n                raise exceptions.MissingIndexException(dataUrl)\n        else:\n            if indexFile is None:\n                indexFile = dataUrl + \".bai\"\n            dataUrl = self._getFilePath(self._args.dataFile,\n                                        self._args.relativePath)\n            indexFile = self._getFilePath(indexFile, self._args.relativePath)\n        name = self._args.name\n        if self._args.name is None:\n            name = getNameFromPath(dataUrl)\n        readGroupSet = reads.HtslibReadGroupSet(dataset, name)\n        readGroupSet.populateFromFile(dataUrl, indexFile)\n        referenceSetName = self._args.referenceSetName\n        if referenceSetName is None:\n            # Try to find a reference set name from the BAM header.\n            referenceSetName = readGroupSet.getBamHeaderReferenceSetName()\n        referenceSet = self._repo.getReferenceSetByName(referenceSetName)\n        readGroupSet.setReferenceSet(referenceSet)\n        readGroupSet.setAttributes(json.loads(self._args.attributes))\n        self._updateRepo(self._repo.insertReadGroupSet, readGroupSet)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new VariantSet into this repo.", "response": "def addVariantSet(self):\n        \"\"\"\n        Adds a new VariantSet into this repo.\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        dataUrls = self._args.dataFiles\n        name = self._args.name\n        if len(dataUrls) == 1:\n            if self._args.name is None:\n                name = getNameFromPath(dataUrls[0])\n            if os.path.isdir(dataUrls[0]):\n                # Read in the VCF files from the directory.\n                # TODO support uncompressed VCF and BCF files\n                vcfDir = dataUrls[0]\n                pattern = os.path.join(vcfDir, \"*.vcf.gz\")\n                dataUrls = glob.glob(pattern)\n                if len(dataUrls) == 0:\n                    raise exceptions.RepoManagerException(\n                        \"Cannot find any VCF files in the directory \"\n                        \"'{}'.\".format(vcfDir))\n                dataUrls[0] = self._getFilePath(dataUrls[0],\n                                                self._args.relativePath)\n        elif self._args.name is None:\n            raise exceptions.RepoManagerException(\n                \"Cannot infer the intended name of the VariantSet when \"\n                \"more than one VCF file is provided. Please provide a \"\n                \"name argument using --name.\")\n        parsed = urlparse.urlparse(dataUrls[0])\n        if parsed.scheme not in ['http', 'ftp']:\n            dataUrls = map(lambda url: self._getFilePath(\n                url, self._args.relativePath), dataUrls)\n        # Now, get the index files for the data files that we've now obtained.\n        indexFiles = self._args.indexFiles\n        if indexFiles is None:\n            # First check if all the paths exist locally, as they must\n            # if we are making a default index path.\n            for dataUrl in dataUrls:\n                if not os.path.exists(dataUrl):\n                    raise exceptions.MissingIndexException(\n                        \"Cannot find file '{}'. All variant files must be \"\n                        \"stored locally if the default index location is \"\n                        \"used. If you are trying to create a VariantSet \"\n                        \"based on remote URLs, please download the index \"\n                        \"files to the local file system and provide them \"\n                        \"with the --indexFiles argument\".format(dataUrl))\n            # We assume that the indexes are made by adding .tbi\n            indexSuffix = \".tbi\"\n            # TODO support BCF input properly here by adding .csi\n            indexFiles = [filename + indexSuffix for filename in dataUrls]\n        indexFiles = map(lambda url: self._getFilePath(\n            url, self._args.relativePath), indexFiles)\n        variantSet = variants.HtslibVariantSet(dataset, name)\n        variantSet.populateFromFile(dataUrls, indexFiles)\n        # Get the reference set that is associated with the variant set.\n        referenceSetName = self._args.referenceSetName\n        if referenceSetName is None:\n            # Try to find a reference set name from the VCF header.\n            referenceSetName = variantSet.getVcfHeaderReferenceSetName()\n        if referenceSetName is None:\n            raise exceptions.RepoManagerException(\n                \"Cannot infer the ReferenceSet from the VCF header. Please \"\n                \"specify the ReferenceSet to associate with this \"\n                \"VariantSet using the --referenceSetName option\")\n        referenceSet = self._repo.getReferenceSetByName(referenceSetName)\n        variantSet.setReferenceSet(referenceSet)\n        variantSet.setAttributes(json.loads(self._args.attributes))\n        # Now check for annotations\n        annotationSets = []\n        if variantSet.isAnnotated() and self._args.addAnnotationSets:\n            ontologyName = self._args.ontologyName\n            if ontologyName is None:\n                raise exceptions.RepoManagerException(\n                    \"A sequence ontology name must be provided\")\n            ontology = self._repo.getOntologyByName(ontologyName)\n            self._checkSequenceOntology(ontology)\n            for annotationSet in variantSet.getVariantAnnotationSets():\n                annotationSet.setOntology(ontology)\n                annotationSets.append(annotationSet)\n\n        # Add the annotation sets and the variant set as an atomic update\n        def updateRepo():\n            self._repo.insertVariantSet(variantSet)\n            for annotationSet in annotationSets:\n                self._repo.insertVariantAnnotationSet(annotationSet)\n        self._updateRepo(updateRepo)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addPhenotypeAssociationSet(self):\n        self._openRepo()\n        name = self._args.name\n        if name is None:\n            name = getNameFromPath(self._args.dirPath)\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        phenotypeAssociationSet = \\\n            genotype_phenotype.RdfPhenotypeAssociationSet(\n                dataset, name, self._args.dirPath)\n        phenotypeAssociationSet.setAttributes(\n            json.loads(self._args.attributes))\n        self._updateRepo(\n            self._repo.insertPhenotypeAssociationSet,\n            phenotypeAssociationSet)", "response": "Adds a new phenotype association set to this repo."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a phenotype association set from the repo", "response": "def removePhenotypeAssociationSet(self):\n        \"\"\"\n        Removes a phenotype association set from the repo\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        phenotypeAssociationSet = dataset.getPhenotypeAssociationSetByName(\n            self._args.name)\n\n        def func():\n            self._updateRepo(\n                self._repo.removePhenotypeAssociationSet,\n                phenotypeAssociationSet)\n        self._confirmDelete(\n            \"PhenotypeAssociationSet\",\n            phenotypeAssociationSet.getLocalId(),\n            func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removeReferenceSet(self):\n        self._openRepo()\n        referenceSet = self._repo.getReferenceSetByName(\n            self._args.referenceSetName)\n\n        def func():\n            self._updateRepo(self._repo.removeReferenceSet, referenceSet)\n        self._confirmDelete(\"ReferenceSet\", referenceSet.getLocalId(), func)", "response": "Removes a referenceSet from the repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a readGroupSet from the repo.", "response": "def removeReadGroupSet(self):\n        \"\"\"\n        Removes a readGroupSet from the repo.\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        readGroupSet = dataset.getReadGroupSetByName(\n            self._args.readGroupSetName)\n\n        def func():\n            self._updateRepo(self._repo.removeReadGroupSet, readGroupSet)\n        self._confirmDelete(\"ReadGroupSet\", readGroupSet.getLocalId(), func)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a variantSet from the repo", "response": "def removeVariantSet(self):\n        \"\"\"\n        Removes a variantSet from the repo.\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        variantSet = dataset.getVariantSetByName(self._args.variantSetName)\n\n        def func():\n            self._updateRepo(self._repo.removeVariantSet, variantSet)\n        self._confirmDelete(\"VariantSet\", variantSet.getLocalId(), func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef removeDataset(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n\n        def func():\n            self._updateRepo(self._repo.removeDataset, dataset)\n        self._confirmDelete(\"Dataset\", dataset.getLocalId(), func)", "response": "Removes a dataset from the repo."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addFeatureSet(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        filePath = self._getFilePath(self._args.filePath,\n                                     self._args.relativePath)\n        name = getNameFromPath(self._args.filePath)\n        featureSet = sequence_annotations.Gff3DbFeatureSet(\n            dataset, name)\n        referenceSetName = self._args.referenceSetName\n        if referenceSetName is None:\n            raise exceptions.RepoManagerException(\n                \"A reference set name must be provided\")\n        referenceSet = self._repo.getReferenceSetByName(referenceSetName)\n        featureSet.setReferenceSet(referenceSet)\n        ontologyName = self._args.ontologyName\n        if ontologyName is None:\n            raise exceptions.RepoManagerException(\n                \"A sequence ontology name must be provided\")\n        ontology = self._repo.getOntologyByName(ontologyName)\n        self._checkSequenceOntology(ontology)\n        featureSet.setOntology(ontology)\n        featureSet.populateFromFile(filePath)\n        featureSet.setAttributes(json.loads(self._args.attributes))\n        self._updateRepo(self._repo.insertFeatureSet, featureSet)", "response": "Adds a new feature set into this repo"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removeFeatureSet(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        featureSet = dataset.getFeatureSetByName(self._args.featureSetName)\n\n        def func():\n            self._updateRepo(self._repo.removeFeatureSet, featureSet)\n        self._confirmDelete(\"FeatureSet\", featureSet.getLocalId(), func)", "response": "Removes a feature set from this repo"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addContinuousSet(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        filePath = self._getFilePath(self._args.filePath,\n                                     self._args.relativePath)\n        name = getNameFromPath(self._args.filePath)\n        continuousSet = continuous.FileContinuousSet(dataset, name)\n        referenceSetName = self._args.referenceSetName\n        if referenceSetName is None:\n            raise exceptions.RepoManagerException(\n                \"A reference set name must be provided\")\n        referenceSet = self._repo.getReferenceSetByName(referenceSetName)\n        continuousSet.setReferenceSet(referenceSet)\n        continuousSet.populateFromFile(filePath)\n        self._updateRepo(self._repo.insertContinuousSet, continuousSet)", "response": "Adds a new continuous set into this repo"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a continuous set from this repo", "response": "def removeContinuousSet(self):\n        \"\"\"\n        Removes a continuous set from this repo\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        continuousSet = dataset.getContinuousSetByName(\n                            self._args.continuousSetName)\n\n        def func():\n            self._updateRepo(self._repo.removeContinuousSet, continuousSet)\n        self._confirmDelete(\"ContinuousSet\", continuousSet.getLocalId(), func)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new biosample into this repo", "response": "def addBiosample(self):\n        \"\"\"\n        Adds a new biosample into this repo\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        biosample = bio_metadata.Biosample(\n            dataset, self._args.biosampleName)\n        biosample.populateFromJson(self._args.biosample)\n        self._updateRepo(self._repo.insertBiosample, biosample)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removeBiosample(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        biosample = dataset.getBiosampleByName(self._args.biosampleName)\n\n        def func():\n            self._updateRepo(self._repo.removeBiosample, biosample)\n        self._confirmDelete(\"Biosample\", biosample.getLocalId(), func)", "response": "Removes a biosample from this repo"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addIndividual(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        individual = bio_metadata.Individual(\n            dataset, self._args.individualName)\n        individual.populateFromJson(self._args.individual)\n        self._updateRepo(self._repo.insertIndividual, individual)", "response": "Adds a new individual into this repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef removeIndividual(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        individual = dataset.getIndividualByName(self._args.individualName)\n\n        def func():\n            self._updateRepo(self._repo.removeIndividual, individual)\n        self._confirmDelete(\"Individual\", individual.getLocalId(), func)", "response": "Removes an individual from this repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addPeer(self):\n        self._openRepo()\n        try:\n            peer = peers.Peer(\n                self._args.url, json.loads(self._args.attributes))\n        except exceptions.BadUrlException:\n            raise exceptions.RepoManagerException(\"The URL for the peer was \"\n                                                  \"malformed.\")\n        except ValueError as e:\n            raise exceptions.RepoManagerException(\n                \"The attributes message \"\n                \"was malformed. {}\".format(e))\n        self._updateRepo(self._repo.insertPeer, peer)", "response": "Adds a new peer into this repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a peer by URL from this repo.", "response": "def removePeer(self):\n        \"\"\"\n        Removes a peer by URL from this repo\n        \"\"\"\n        self._openRepo()\n\n        def func():\n            self._updateRepo(self._repo.removePeer, self._args.url)\n        self._confirmDelete(\"Peer\", self._args.url, func)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removeOntology(self):\n        self._openRepo()\n        ontology = self._repo.getOntologyByName(self._args.ontologyName)\n\n        def func():\n            self._updateRepo(self._repo.removeOntology, ontology)\n        self._confirmDelete(\"Ontology\", ontology.getName(), func)", "response": "Removes an ontology from the repo."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an rnaQuantification into this repo", "response": "def addRnaQuantification(self):\n        \"\"\"\n        Adds an rnaQuantification into this repo\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        biosampleId = \"\"\n        if self._args.biosampleName:\n            biosample = dataset.getBiosampleByName(self._args.biosampleName)\n            biosampleId = biosample.getId()\n        if self._args.name is None:\n            name = getNameFromPath(self._args.quantificationFilePath)\n        else:\n            name = self._args.name\n        # TODO: programs not fully supported by GA4GH yet\n        programs = \"\"\n        featureType = \"gene\"\n        if self._args.transcript:\n            featureType = \"transcript\"\n        rnaseq2ga.rnaseq2ga(\n            self._args.quantificationFilePath, self._args.filePath, name,\n            self._args.format, dataset=dataset, featureType=featureType,\n            description=self._args.description, programs=programs,\n            featureSetNames=self._args.featureSetNames,\n            readGroupSetNames=self._args.readGroupSetName,\n            biosampleId=biosampleId)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize an empty RNA quantification set", "response": "def initRnaQuantificationSet(self):\n        \"\"\"\n        Initialize an empty RNA quantification set\n        \"\"\"\n        store = rnaseq2ga.RnaSqliteStore(self._args.filePath)\n        store.createTables()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an rnaQuantificationSet into this repo", "response": "def addRnaQuantificationSet(self):\n        \"\"\"\n        Adds an rnaQuantificationSet into this repo\n        \"\"\"\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        if self._args.name is None:\n            name = getNameFromPath(self._args.filePath)\n        else:\n            name = self._args.name\n        rnaQuantificationSet = rna_quantification.SqliteRnaQuantificationSet(\n            dataset, name)\n        referenceSetName = self._args.referenceSetName\n        if referenceSetName is None:\n            raise exceptions.RepoManagerException(\n                \"A reference set name must be provided\")\n        referenceSet = self._repo.getReferenceSetByName(referenceSetName)\n        rnaQuantificationSet.setReferenceSet(referenceSet)\n        rnaQuantificationSet.populateFromFile(self._args.filePath)\n        rnaQuantificationSet.setAttributes(json.loads(self._args.attributes))\n        self._updateRepo(\n            self._repo.insertRnaQuantificationSet, rnaQuantificationSet)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef removeRnaQuantificationSet(self):\n        self._openRepo()\n        dataset = self._repo.getDatasetByName(self._args.datasetName)\n        rnaQuantSet = dataset.getRnaQuantificationSetByName(\n            self._args.rnaQuantificationSetName)\n\n        def func():\n            self._updateRepo(self._repo.removeRnaQuantificationSet,\n                             rnaQuantSet)\n        self._confirmDelete(\n            \"RnaQuantificationSet\", rnaQuantSet.getLocalId(), func)", "response": "Removes an rnaQuantificationSet from this repo"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the data in one of several formats and stores the data in a GA4GH database.", "response": "def rnaseq2ga(quantificationFilename, sqlFilename, localName, rnaType,\n              dataset=None, featureType=\"gene\",\n              description=\"\", programs=\"\", featureSetNames=\"\",\n              readGroupSetNames=\"\", biosampleId=\"\"):\n    \"\"\"\n    Reads RNA Quantification data in one of several formats and stores the data\n    in a sqlite database for use by the GA4GH reference server.\n\n    Supports the following quantification output types:\n    Cufflinks, kallisto, RSEM.\n    \"\"\"\n    readGroupSetName = \"\"\n    if readGroupSetNames:\n        readGroupSetName = readGroupSetNames.strip().split(\",\")[0]\n    featureSetIds = \"\"\n    readGroupIds = \"\"\n    if dataset:\n        featureSetIdList = []\n        if featureSetNames:\n            for annotationName in featureSetNames.split(\",\"):\n                featureSet = dataset.getFeatureSetByName(annotationName)\n                featureSetIdList.append(featureSet.getId())\n            featureSetIds = \",\".join(featureSetIdList)\n        # TODO: multiple readGroupSets\n        if readGroupSetName:\n            readGroupSet = dataset.getReadGroupSetByName(readGroupSetName)\n            readGroupIds = \",\".join(\n                [x.getId() for x in readGroupSet.getReadGroups()])\n    if rnaType not in SUPPORTED_RNA_INPUT_FORMATS:\n        raise exceptions.UnsupportedFormatException(rnaType)\n    rnaDB = RnaSqliteStore(sqlFilename)\n    if rnaType == \"cufflinks\":\n        writer = CufflinksWriter(rnaDB, featureType, dataset=dataset)\n    elif rnaType == \"kallisto\":\n        writer = KallistoWriter(rnaDB, featureType, dataset=dataset)\n    elif rnaType == \"rsem\":\n        writer = RsemWriter(rnaDB, featureType, dataset=dataset)\n    writeRnaseqTable(rnaDB, [localName], description, featureSetIds,\n                     readGroupId=readGroupIds, programs=programs,\n                     biosampleId=biosampleId)\n    writeExpressionTable(writer, [(localName, quantificationFilename)])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addRNAQuantification(self, datafields):\n        self._rnaValueList.append(datafields)\n        if len(self._rnaValueList) >= self._batchSize:\n            self.batchaddRNAQuantification()", "response": "Adds an RNAQuantification to the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an Expression to the database.", "response": "def addExpression(self, datafields):\n        \"\"\"\n        Adds an Expression to the db.  Datafields is a tuple in the order:\n        id, rna_quantification_id, name, expression,\n        is_normalized, raw_read_count, score, units, conf_low, conf_hi\n        \"\"\"\n        self._expressionValueList.append(datafields)\n        if len(self._expressionValueList) >= self._batchSize:\n            self.batchAddExpression()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the index columns that are queried. The name index can take a long time. The expression index can take a long time.", "response": "def createIndices(self):\n        \"\"\"\n        Index columns that are queried. The expression index can\n        take a long time.\n        \"\"\"\n\n        sql = '''CREATE INDEX name_index\n                 ON Expression (name)'''\n        self._cursor.execute(sql)\n        self._dbConn.commit()\n\n        sql = '''CREATE INDEX expression_index\n                 ON Expression (expression)'''\n        self._cursor.execute(sql)\n        self._dbConn.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeExpression(self, rnaQuantificationId, quantfilename):\n        isNormalized = self._isNormalized\n        units = self._units\n        with open(quantfilename, \"r\") as quantFile:\n            quantificationReader = csv.reader(quantFile, delimiter=b\"\\t\")\n            header = next(quantificationReader)\n            expressionLevelColNum = self.setColNum(\n                                        header, self._expressionLevelCol)\n            nameColNum = self.setColNum(header, self._nameCol)\n            countColNum = self.setColNum(header, self._countCol, -1)\n            confColLowNum = self.setColNum(header, self._confColLow, -1)\n            confColHiNum = self.setColNum(header, self._confColHi, -1)\n            expressionId = 0\n            for expression in quantificationReader:\n                expressionLevel = expression[expressionLevelColNum]\n                name = expression[nameColNum]\n                rawCount = 0.0\n                if countColNum != -1:\n                    rawCount = expression[countColNum]\n                confidenceLow = 0.0\n                confidenceHi = 0.0\n                score = 0.0\n                if confColLowNum != -1 and confColHiNum != -1:\n                    confidenceLow = float(expression[confColLowNum])\n                    confidenceHi = float(expression[confColHiNum])\n                    score = (confidenceLow + confidenceHi)/2\n\n                datafields = (expressionId, rnaQuantificationId, name,\n                              expressionLevel, isNormalized, rawCount, score,\n                              units, confidenceLow, confidenceHi)\n                self._db.addExpression(datafields)\n                expressionId += 1\n            self._db.batchAddExpression()", "response": "Reads the quantification results file and writes the entries to the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching sequences from NCBI using the eself interface.", "response": "def _fetchSequence(ac, startIndex=None, endIndex=None):\n    \"\"\"Fetch sequences from NCBI using the eself interface.\n\n    An interbase interval may be optionally provided with startIndex and\n    endIndex. NCBI eself will return just the requested subsequence, which\n    might greatly reduce payload sizes (especially with chromosome-scale\n    sequences). When wrapped is True, return list of sequence lines rather\n    than concatenated sequence.\n\n    >>> len(_fetchSequence('NP_056374.2'))\n    1596\n\n    Pass the desired interval rather than using Python's [] slice\n    operator.\n\n    >>> _fetchSequence('NP_056374.2',0,10)\n    'MESRETLSSS'\n\n    >>> _fetchSequence('NP_056374.2')[0:10]\n    'MESRETLSSS'\n\n    \"\"\"\n    urlFmt = (\n        \"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?\"\n        \"db=nucleotide&id={ac}&rettype=fasta&retmode=text\")\n    if startIndex is None or endIndex is None:\n        url = urlFmt.format(ac=ac)\n    else:\n        urlFmt += \"&seq_start={start}&seq_stop={stop}\"\n        url = urlFmt.format(ac=ac, start=startIndex + 1, stop=endIndex)\n    resp = requests.get(url)\n    resp.raise_for_status()\n    seqlines = resp.content.splitlines()[1:]\n    print(\"{ac}[{s},{e}) => {n} lines ({u})\".format(\n        ac=ac, s=startIndex, e=endIndex, n=len(seqlines), u=url))\n    # return response as list of lines, already line wrapped\n    return seqlines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new bam header based on the specified base header.", "response": "def createBamHeader(self, baseHeader):\n        \"\"\"\n        Creates a new bam header based on the specified header from the\n        parent BAM file.\n        \"\"\"\n        header = dict(baseHeader)\n        newSequences = []\n        for index, referenceInfo in enumerate(header['SQ']):\n            if index < self.numChromosomes:\n                referenceName = referenceInfo['SN']\n                # The sequence dictionary in the BAM file has to match up\n                # with the sequence ids in the data, so we must be sure\n                # that these still match up.\n                assert referenceName == self.chromosomes[index]\n                newReferenceInfo = {\n                    'AS': self.referenceSetName,\n                    'SN': referenceName,\n                    'LN': 0,  # FIXME\n                    'UR': 'http://example.com',\n                    'M5': 'dbb6e8ece0b5de29da56601613007c2a',  # FIXME\n                    'SP': 'Human'\n                }\n                newSequences.append(newReferenceInfo)\n        header['SQ'] = newSequences\n        return header"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the repository for all the data we just downloaded.", "response": "def createRepo(self):\n        \"\"\"\n        Creates the repository for all the data we've just downloaded.\n        \"\"\"\n        repo = datarepo.SqlDataRepository(self.repoPath)\n        repo.open(\"w\")\n        repo.initialise()\n\n        referenceSet = references.HtslibReferenceSet(\"GRCh37-subset\")\n        referenceSet.populateFromFile(self.fastaFilePath)\n        referenceSet.setDescription(\"Subset of GRCh37 used for demonstration\")\n        referenceSet.setSpeciesFromJson(\n                '{\"id\": \"9606\",'\n                + '\"term\": \"Homo sapiens\", \"source_name\": \"NCBI\"}')\n        for reference in referenceSet.getReferences():\n            reference.setSpeciesFromJson(\n                '{\"id\": \"9606\",'\n                + '\"term\": \"Homo sapiens\", \"source_name\": \"NCBI\"}')\n            reference.setSourceAccessions(\n                self.accessions[reference.getName()] + \".subset\")\n        repo.insertReferenceSet(referenceSet)\n\n        dataset = datasets.Dataset(\"1kg-p3-subset\")\n        dataset.setDescription(\"Sample data from 1000 Genomes phase 3\")\n        repo.insertDataset(dataset)\n\n        variantSet = variants.HtslibVariantSet(dataset, \"mvncall\")\n        variantSet.setReferenceSet(referenceSet)\n        dataUrls = [vcfFile for vcfFile, _ in self.vcfFilePaths]\n        indexFiles = [indexFile for _, indexFile in self.vcfFilePaths]\n        variantSet.populateFromFile(dataUrls, indexFiles)\n        variantSet.checkConsistency()\n        repo.insertVariantSet(variantSet)\n\n        for sample, (bamFile, indexFile) in zip(\n                self.samples, self.bamFilePaths):\n            readGroupSet = reads.HtslibReadGroupSet(dataset, sample)\n            readGroupSet.populateFromFile(bamFile, indexFile)\n            readGroupSet.setReferenceSet(referenceSet)\n            repo.insertReadGroupSet(readGroupSet)\n\n        repo.commit()\n        repo.close()\n        self.log(\"Finished creating the repository; summary:\\n\")\n        repo.open(\"r\")\n        repo.printSummary()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _configure_backend(app):\n    # Allocate the backend\n    # We use URLs to specify the backend. Currently we have file:// URLs (or\n    # URLs with no scheme) for the SqlDataRepository, and special empty:// and\n    # simulated:// URLs for empty or simulated data sources.\n    dataSource = urlparse.urlparse(app.config[\"DATA_SOURCE\"], \"file\")\n\n    if dataSource.scheme == \"simulated\":\n        # Ignore the query string\n        randomSeed = app.config[\"SIMULATED_BACKEND_RANDOM_SEED\"]\n        numCalls = app.config[\"SIMULATED_BACKEND_NUM_CALLS\"]\n        variantDensity = app.config[\"SIMULATED_BACKEND_VARIANT_DENSITY\"]\n        numVariantSets = app.config[\"SIMULATED_BACKEND_NUM_VARIANT_SETS\"]\n        numReferenceSets = app.config[\n            \"SIMULATED_BACKEND_NUM_REFERENCE_SETS\"]\n        numReferencesPerReferenceSet = app.config[\n            \"SIMULATED_BACKEND_NUM_REFERENCES_PER_REFERENCE_SET\"]\n        numAlignmentsPerReadGroup = app.config[\n            \"SIMULATED_BACKEND_NUM_ALIGNMENTS_PER_READ_GROUP\"]\n        numReadGroupsPerReadGroupSet = app.config[\n            \"SIMULATED_BACKEND_NUM_READ_GROUPS_PER_READ_GROUP_SET\"]\n        numPhenotypeAssociations = app.config[\n            \"SIMULATED_BACKEND_NUM_PHENOTYPE_ASSOCIATIONS\"]\n        numPhenotypeAssociationSets = app.config[\n            \"SIMULATED_BACKEND_NUM_PHENOTYPE_ASSOCIATION_SETS\"]\n        numRnaQuantSets = app.config[\n            \"SIMULATED_BACKEND_NUM_RNA_QUANTIFICATION_SETS\"]\n        numExpressionLevels = app.config[\n            \"SIMULATED_BACKEND_NUM_EXPRESSION_LEVELS_PER_RNA_QUANT_SET\"]\n\n        dataRepository = datarepo.SimulatedDataRepository(\n            randomSeed=randomSeed, numCalls=numCalls,\n            variantDensity=variantDensity, numVariantSets=numVariantSets,\n            numReferenceSets=numReferenceSets,\n            numReferencesPerReferenceSet=numReferencesPerReferenceSet,\n            numReadGroupsPerReadGroupSet=numReadGroupsPerReadGroupSet,\n            numAlignments=numAlignmentsPerReadGroup,\n            numPhenotypeAssociations=numPhenotypeAssociations,\n            numPhenotypeAssociationSets=numPhenotypeAssociationSets,\n            numRnaQuantSets=numRnaQuantSets,\n            numExpressionLevels=numExpressionLevels)\n    elif dataSource.scheme == \"empty\":\n        dataRepository = datarepo.EmptyDataRepository()\n    elif dataSource.scheme == \"file\":\n        path = os.path.join(dataSource.netloc, dataSource.path)\n        dataRepository = datarepo.SqlDataRepository(path)\n        dataRepository.open(datarepo.MODE_READ)\n    else:\n        raise exceptions.ConfigurationException(\n            \"Unsupported data source scheme: \" + dataSource.scheme)\n    theBackend = backend.Backend(dataRepository)\n    theBackend.setRequestValidation(app.config[\"REQUEST_VALIDATION\"])\n    theBackend.setDefaultPageSize(app.config[\"DEFAULT_PAGE_SIZE\"])\n    theBackend.setMaxResponseLength(app.config[\"MAX_RESPONSE_LENGTH\"])\n    return theBackend", "response": "A helper function used just to help modularize the code a bit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure(configFile=None, baseConfig=\"ProductionConfig\",\n              port=8000, extraConfig={}):\n    \"\"\"\n    TODO Document this critical function! What does it do? What does\n    it assume?\n    \"\"\"\n    file_handler = StreamHandler()\n    file_handler.setLevel(logging.WARNING)\n    app.logger.addHandler(file_handler)\n    configStr = 'ga4gh.server.serverconfig:{0}'.format(baseConfig)\n    app.config.from_object(configStr)\n    if os.environ.get('GA4GH_CONFIGURATION') is not None:\n        app.config.from_envvar('GA4GH_CONFIGURATION')\n    if configFile is not None:\n        app.config.from_pyfile(configFile)\n    app.config.update(extraConfig.items())\n    # Setup file handle cache max size\n    datamodel.fileHandleCache.setMaxCacheSize(\n        app.config[\"FILE_HANDLE_CACHE_MAX_SIZE\"])\n    # Setup CORS\n    try:\n        cors.CORS(app, allow_headers='Content-Type')\n    except AssertionError:\n        pass\n    app.serverStatus = ServerStatus()\n\n    app.backend = _configure_backend(app)\n    if app.config.get('SECRET_KEY'):\n        app.secret_key = app.config['SECRET_KEY']\n    elif app.config.get('OIDC_PROVIDER'):\n        raise exceptions.ConfigurationException(\n            'OIDC configuration requires a secret key')\n    if app.config.get('CACHE_DIRECTORY'):\n        app.cache_dir = app.config['CACHE_DIRECTORY']\n    else:\n        app.cache_dir = '/tmp/ga4gh'\n    app.cache = FileSystemCache(\n        app.cache_dir, threshold=5000, default_timeout=600, mode=384)\n    # Peer service initialization\n    network.initialize(\n        app.config.get('INITIAL_PEERS'),\n        app.backend.getDataRepository(),\n        app.logger)\n    app.oidcClient = None\n    app.myPort = port\n    if app.config.get('AUTH0_ENABLED'):\n        emails = app.config.get('AUTH0_AUTHORIZED_EMAILS', '').split(',')\n        [auth.authorize_email(e, app.cache) for e in emails]\n    if \"OIDC_PROVIDER\" in app.config:\n        # The oic client. If we're testing, we don't want to verify\n        # SSL certificates\n        app.oidcClient = oic.oic.Client(\n            verify_ssl=('TESTING' not in app.config))\n        try:\n            app.oidcClient.provider_config(app.config['OIDC_PROVIDER'])\n        except requests.exceptions.ConnectionError:\n            configResponse = message.ProviderConfigurationResponse(\n                issuer=app.config['OIDC_PROVIDER'],\n                authorization_endpoint=app.config['OIDC_AUTHZ_ENDPOINT'],\n                token_endpoint=app.config['OIDC_TOKEN_ENDPOINT'],\n                revocation_endpoint=app.config['OIDC_TOKEN_REV_ENDPOINT'])\n            app.oidcClient.handle_provider_config(configResponse,\n                                                  app.config['OIDC_PROVIDER'])\n\n        # The redirect URI comes from the configuration.\n        # If we are testing, then we allow the automatic creation of a\n        # redirect uri if none is configured\n        redirectUri = app.config.get('OIDC_REDIRECT_URI')\n        if redirectUri is None and app.config.get('TESTING'):\n            redirectUri = 'https://{0}:{1}/oauth2callback'.format(\n                socket.gethostname(), app.myPort)\n        app.oidcClient.redirect_uris = [redirectUri]\n        if redirectUri is []:\n            raise exceptions.ConfigurationException(\n                'OIDC configuration requires a redirect uri')\n\n        # We only support dynamic registration while testing.\n        if ('registration_endpoint' in app.oidcClient.provider_info and\n           app.config.get('TESTING')):\n            app.oidcClient.register(\n                app.oidcClient.provider_info[\"registration_endpoint\"],\n                redirect_uris=[redirectUri])\n        else:\n            response = message.RegistrationResponse(\n                client_id=app.config['OIDC_CLIENT_ID'],\n                client_secret=app.config['OIDC_CLIENT_SECRET'],\n                redirect_uris=[redirectUri],\n                verify_ssl=False)\n            app.oidcClient.store_registration_info(response)", "response": "Configure the application with the given configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getFlaskResponse(responseString, httpStatus=200):\n    return flask.Response(responseString, status=httpStatus, mimetype=MIMETYPE)", "response": "Returns a Flask response object for the specified data and HTTP status."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling the specified HTTP POST request.", "response": "def handleHttpPost(request, endpoint):\n    \"\"\"\n    Handles the specified HTTP POST request, which maps to the specified\n    protocol handler endpoint and protocol request class.\n    \"\"\"\n    if request.mimetype and request.mimetype != MIMETYPE:\n        raise exceptions.UnsupportedMediaTypeException()\n    request = request.get_data()\n    if request == '' or request is None:\n        request = '{}'\n    responseStr = endpoint(request)\n    return getFlaskResponse(responseStr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle an exception that occurs somewhere in the process of handling a request.", "response": "def handleException(exception):\n    \"\"\"\n    Handles an exception that occurs somewhere in the process of handling\n    a request.\n    \"\"\"\n    serverException = exception\n    if not isinstance(exception, exceptions.BaseServerException):\n        with app.test_request_context():\n            app.log_exception(exception)\n        serverException = exceptions.getServerError(exception)\n    error = serverException.toProtocolElement()\n    # If the exception is being viewed by a web browser, we can render a nicer\n    # view.\n    if flask.request and 'Accept' in flask.request.headers and \\\n            flask.request.headers['Accept'].find('text/html') != -1:\n        message = \"<h1>Error {}</h1><pre>{}</pre>\".format(\n                    serverException.httpStatus,\n                    protocol.toJson(error))\n        if serverException.httpStatus == 401 \\\n                or serverException.httpStatus == 403:\n            message += \"Please try <a href=\\\"/login\\\">logging in</a>.\"\n        return message\n    else:\n        responseStr = protocol.toJson(error)\n        return getFlaskResponse(responseStr, serverException.httpStatus)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef startLogin():\n    flask.session[\"state\"] = oic.oauth2.rndstr(SECRET_KEY_LENGTH)\n    flask.session[\"nonce\"] = oic.oauth2.rndstr(SECRET_KEY_LENGTH)\n    args = {\n        \"client_id\": app.oidcClient.client_id,\n        \"response_type\": \"code\",\n        \"scope\": [\"openid\", \"profile\"],\n        \"nonce\": flask.session[\"nonce\"],\n        \"redirect_uri\": app.oidcClient.redirect_uris[0],\n        \"state\": flask.session[\"state\"]\n    }\n\n    result = app.oidcClient.do_authorization_request(\n        request_args=args, state=flask.session[\"state\"])\n    return flask.redirect(result.url)", "response": "This function generates the redirect URL to the OIDC provider and returns the redirect response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the request is authenticated and if so starts the login process.", "response": "def checkAuthentication():\n    \"\"\"\n    The request will have a parameter 'key' if it came from the command line\n    client, or have a session key of 'key' if it's the browser.\n    If the token is not found, start the login process.\n\n    If there is no oidcClient, we are running naked and we don't check.\n    If we're being redirected to the oidcCallback we don't check.\n\n    :returns None if all is ok (and the request handler continues as usual).\n    Otherwise if the key was in the session (therefore we're in a browser)\n    then startLogin() will redirect to the OIDC provider. If the key was in\n    the request arguments, we're using the command line and just raise an\n    exception.\n    \"\"\"\n    if app.oidcClient is None:\n        return\n    if flask.request.endpoint == 'oidcCallback':\n        return\n    key = flask.session.get('key') or flask.request.args.get('key')\n    if key is None or not app.cache.get(key):\n        if 'key' in flask.request.args:\n            raise exceptions.NotAuthenticatedException()\n        else:\n            return startLogin()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles a flask request for one of the GET URLs Invokes the specified endpoint to generate a response.", "response": "def handleFlaskGetRequest(id_, flaskRequest, endpoint):\n    \"\"\"\n    Handles the specified flask request for one of the GET URLs\n    Invokes the specified endpoint to generate a response.\n    \"\"\"\n    if flaskRequest.method == \"GET\":\n        return handleHttpGet(id_, endpoint)\n    else:\n        raise exceptions.MethodNotAllowedException()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handleFlaskPostRequest(flaskRequest, endpoint):\n    if flaskRequest.method == \"POST\":\n        return handleHttpPost(flaskRequest, endpoint)\n    elif flaskRequest.method == \"OPTIONS\":\n        return handleHttpOptions()\n    else:\n        raise exceptions.MethodNotAllowedException()", "response": "Handles the specified flask request for one of the POST URLS\n    Invokes the specified endpoint to generate a response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of ReferenceSets for this server.", "response": "def getVariantAnnotationSets(self, datasetId):\n        \"\"\"\n        Returns the list of ReferenceSets for this server.\n        \"\"\"\n        # TODO this should be displayed per-variant set, not per dataset.\n        variantAnnotationSets = []\n        dataset = app.backend.getDataRepository().getDataset(datasetId)\n        for variantSet in dataset.getVariantSets():\n            variantAnnotationSets.extend(\n                variantSet.getVariantAnnotationSets())\n        return variantAnnotationSets"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef auth_decorator(app=None):\n    def requires_auth(f):\n        @functools.wraps(f)\n        def decorated(*args, **kwargs):\n            # This decorator will only apply with AUTH0_ENABLED set to True.\n            if app.config.get('AUTH0_ENABLED', False):\n                client_id = app.config.get(\"AUTH0_CLIENT_ID\")\n                client_secret = app.config.get(\"AUTH0_CLIENT_SECRET\")\n                auth_header = flask.request.headers.get('Authorization', None)\n                # Each of these functions will throw a 401 is there is a\n                # problem decoding the token with some helpful error message.\n                if auth_header:\n                    token, profile = decode_header(\n                        auth_header, client_id, client_secret)\n                else:\n                    raise exceptions.NotAuthorizedException()\n                # We store the token in the session so that later\n                # stages can use it to connect identity and authorization.\n                flask.session['auth0_key'] = token\n                # Now we need to make sure that on top of having a good token\n                # They are authorized, and if not provide an error message\n                is_authorized(app.cache, profile['email'])\n                is_active(app.cache, token)\n            return f(*args, **kwargs)\n        return decorated\n    return requires_auth", "response": "This decorator is used to decorate views that require authentication. It will only be called if the auth header is set to True."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decode_header(auth_header, client_id, client_secret):\n    return _decode_header(\n        _well_formed(\n            _has_token(_has_bearer(_has_header(auth_header)))),\n        client_id, client_secret)", "response": "This function handles decoding a header and returns a tuple containing the token and payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlog out the current session from the cache.", "response": "def logout(cache):\n    \"\"\"\n    Logs out the current session by removing it from the cache. This is\n    expected to only occur when a session has\n    \"\"\"\n    cache.set(flask.session['auth0_key'], None)\n    flask.session.clear()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering the login template", "response": "def render_login(\n        app=None, scopes='', redirect_uri='', domain='', client_id=''):\n    \"\"\"\n    This function will generate a view function that can be used to handle\n    the return from Auth0. The \"callback\" is a redirected session from auth0\n    that includes the token we can use to authenticate that session.\n\n    If the session is properly authenticated Auth0 will provide a code so our\n    application can identify the session. Once this has been done we ask\n    for more information about the identified session from Auth0. We then use\n    the email of the user logged in to Auth0 to authorize their token to make\n    further requests by adding it to the application's cache.\n\n    It sets a value in the cache that sets the current session as logged in. We\n    can then refer to this id_token to later authenticate a session.\n\n    :param app:\n    :param scopes:\n    :param redirect_uri:\n    :param domain:\n    :param client_id:\n    :return : Rendered login template\n    \"\"\"\n    return app.jinja_env.from_string(LOGIN_HTML).render(\n        scopes=scopes,\n        redirect_uri=redirect_uri,\n        domain=domain,\n        client_id=client_id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_key(app, key=\"\"):\n    return app.jinja_env.from_string(KEY_HTML).render(\n        key=key)", "response": "Renders a view from the app and a key that lets the current session grab\n    its token."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking the auth_header and attempts to decode the token and payload.", "response": "def _decode_header(auth_header, client_id, client_secret):\n    \"\"\"\n    Takes the header and tries to return an active token and decoded\n    payload.\n    :param auth_header:\n    :param client_id:\n    :param client_secret:\n    :return: (token, profile)\n    \"\"\"\n    try:\n        token = auth_header.split()[1]\n        payload = jwt.decode(\n            token,\n            client_secret,\n            audience=client_id)\n    except jwt.ExpiredSignature:\n        raise exceptions.NotAuthorizedException(\n            'Token has expired, please log in again.')\n    # is valid client\n    except jwt.InvalidAudienceError:\n        message = 'Incorrect audience, expected: {}'.format(\n            client_id)\n        raise exceptions.NotAuthorizedException(message)\n    # is valid token\n    except jwt.DecodeError:\n        raise exceptions.NotAuthorizedException(\n            'Token signature could not be validated.')\n    except Exception as e:\n        raise exceptions.NotAuthorizedException(\n            'Token signature was malformed. {}'.format(e.message))\n    return token, payload"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks to see if the token is logged in and returns the token if not raises a NotAuthenticatedException", "response": "def is_active(cache, token):\n    \"\"\"\n    Accepts the cache and ID token and checks to see if the profile is\n    currently logged in. If so, return the token, otherwise throw a\n    NotAuthenticatedException.\n    :param cache:\n    :param token:\n    :return:\n    \"\"\"\n    profile = cache.get(token)\n    if not profile:\n        raise exceptions.NotAuthenticatedException(\n            'The token is good, but you are not logged in. Please '\n            'try logging in again.')\n    return profile"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the specified reference to this ReferenceSet.", "response": "def addReference(self, reference):\n        \"\"\"\n        Adds the specified reference to this ReferenceSet.\n        \"\"\"\n        id_ = reference.getId()\n        self._referenceIdMap[id_] = reference\n        self._referenceNameMap[reference.getLocalId()] = reference\n        self._referenceIds.append(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the species an OntologyTerm to the specified value given as a JSON string.", "response": "def setSpeciesFromJson(self, speciesJson):\n        \"\"\"\n        Sets the species, an OntologyTerm, to the specified value, given as\n        a JSON string.\n\n        See the documentation for details of this field.\n        \"\"\"\n        try:\n            parsed = protocol.fromJson(speciesJson, protocol.OntologyTerm)\n        except:\n            raise exceptions.InvalidJsonException(speciesJson)\n        self._species = protocol.toJsonDict(parsed)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getReferenceByName(self, name):\n        if name not in self._referenceNameMap:\n            raise exceptions.ReferenceNameNotFoundException(name)\n        return self._referenceNameMap[name]", "response": "Returns the reference with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the Reference with the specified ID or raises a NameException if it does not exist.", "response": "def getReference(self, id_):\n        \"\"\"\n        Returns the Reference with the specified ID or raises a\n        ReferenceNotFoundException if it does not exist.\n        \"\"\"\n        if id_ not in self._referenceIdMap:\n            raise exceptions.ReferenceNotFoundException(id_)\n        return self._referenceIdMap[id_]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the MD5 checksum for this reference set. This checksum is calculated by making a list of all the Reference. md5checksums for all the Reference s in this set and then taking the MD5 hash of all the strings concatenated together.", "response": "def getMd5Checksum(self):\n        \"\"\"\n        Returns the MD5 checksum for this reference set. This checksum is\n        calculated by making a list of `Reference.md5checksum` for all\n        `Reference`s in this set. We then sort this list, and take the\n        MD5 hash of all the strings concatenated together.\n        \"\"\"\n        references = sorted(\n            self.getReferences(),\n            key=lambda ref: ref.getMd5Checksum())\n        checksums = ''.join([ref.getMd5Checksum() for ref in references])\n        md5checksum = hashlib.md5(checksums).hexdigest()\n        return md5checksum"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef toProtocolElement(self):\n        ret = protocol.ReferenceSet()\n        ret.assembly_id = pb.string(self.getAssemblyId())\n        ret.description = pb.string(self.getDescription())\n        ret.id = self.getId()\n        ret.is_derived = self.getIsDerived()\n        ret.md5checksum = self.getMd5Checksum()\n        if self.getSpecies():\n            term = protocol.fromJson(\n                json.dumps(self.getSpecies()), protocol.OntologyTerm)\n            ret.species.term_id = term.term_id\n            ret.species.term = term.term\n        ret.source_accessions.extend(self.getSourceAccessions())\n        ret.source_uri = pb.string(self.getSourceUri())\n        ret.name = self.getLocalId()\n        self.serializeAttributes(ret)\n        return ret", "response": "Returns the GA4GH protocol representation of this ReferenceSet."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the GA4GH protocol representation of this Reference.", "response": "def toProtocolElement(self):\n        \"\"\"\n        Returns the GA4GH protocol representation of this Reference.\n        \"\"\"\n        reference = protocol.Reference()\n        reference.id = self.getId()\n        reference.is_derived = self.getIsDerived()\n        reference.length = self.getLength()\n        reference.md5checksum = self.getMd5Checksum()\n        reference.name = self.getName()\n        if self.getSpecies():\n            term = protocol.fromJson(\n                json.dumps(self.getSpecies()), protocol.OntologyTerm)\n            reference.species.term_id = term.term_id\n            reference.species.term = term.term\n        reference.source_accessions.extend(self.getSourceAccessions())\n        reference.source_divergence = pb.int(self.getSourceDivergence())\n        reference.source_uri = self.getSourceUri()\n        self.serializeAttributes(reference)\n        return reference"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef checkQueryRange(self, start, end):\n        condition = (\n            (start < 0 or end > self.getLength()) or\n            start > end or start == end)\n        if condition:\n            raise exceptions.ReferenceRangeErrorException(\n                self.getId(), start, end)", "response": "Checks to ensure that the query range is valid within this reference."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef populateFromFile(self, dataUrl):\n        self._dataUrl = dataUrl\n        fastaFile = self.getFastaFile()\n        for referenceName in fastaFile.references:\n            reference = HtslibReference(self, referenceName)\n            # TODO break this up into chunks and calculate the MD5\n            # in bits (say, 64K chunks?)\n            bases = fastaFile.fetch(referenceName)\n            md5checksum = hashlib.md5(bases).hexdigest()\n            reference.setMd5checksum(md5checksum)\n            reference.setLength(len(bases))\n            self.addReference(reference)", "response": "Populates the instance variables of this ReferencSet from the specified data URL."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef populateFromRow(self, referenceSetRecord):\n        self._dataUrl = referenceSetRecord.dataurl\n        self._description = referenceSetRecord.description\n        self._assemblyId = referenceSetRecord.assemblyid\n        self._isDerived = bool(referenceSetRecord.isderived)\n        self._md5checksum = referenceSetRecord.md5checksum\n        species = referenceSetRecord.species\n        if species is not None and species != 'null':\n            self.setSpeciesFromJson(species)\n        self._sourceAccessions = json.loads(\n            referenceSetRecord.sourceaccessions)\n        self._sourceUri = referenceSetRecord.sourceuri", "response": "Populates this reference set from the values in the specified DB\n        row."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef populateFromRow(self, referenceRecord):\n        self._length = referenceRecord.length\n        self._isDerived = bool(referenceRecord.isderived)\n        self._md5checksum = referenceRecord.md5checksum\n        species = referenceRecord.species\n        if species is not None and species != 'null':\n            self.setSpeciesFromJson(species)\n        self._sourceAccessions = json.loads(referenceRecord.sourceaccessions)\n        self._sourceDivergence = referenceRecord.sourcedivergence\n        self._sourceUri = referenceRecord.sourceuri", "response": "Populates this Reference from the values in the specified DB row."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _extractAssociationsDetails(self, associations):\n        detailedURIRef = []\n        for row in associations.bindings:\n            if 'feature' in row:\n                detailedURIRef.append(row['feature'])\n                detailedURIRef.append(row['environment'])\n                detailedURIRef.append(row['phenotype'])\n        return detailedURIRef", "response": "Extract the details from the associations table."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a list of uriRefs return a list of dicts that contain the details of the resource.", "response": "def _detailTuples(self, uriRefs):\n        \"\"\"\n        Given a list of uriRefs, return a list of dicts:\n        {'subject': s, 'predicate': p, 'object': o }\n        all values are strings\n        \"\"\"\n        details = []\n        for uriRef in uriRefs:\n            for subject, predicate, object_ in self._rdfGraph.triples(\n                    (uriRef, None, None)):\n                details.append({\n                    'subject': subject.toPython(),\n                    'predicate': predicate.toPython(),\n                    'object': object_.toPython()\n                })\n        return details"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a dictionary of sparql query result and a dictionary of plain text values create a dict of plain text values", "response": "def _bindingsToDict(self, bindings):\n        \"\"\"\n        Given a binding from the sparql query result,\n        create a dict of plain text\n        \"\"\"\n        myDict = {}\n        for key, val in bindings.iteritems():\n            myDict[key.toPython().replace('?', '')] = val.toPython()\n        return myDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _addDataFile(self, filename):\n        if filename.endswith('.ttl'):\n            self._rdfGraph.parse(filename, format='n3')\n        else:\n            self._rdfGraph.parse(filename, format='xml')", "response": "Add a data file to the graph"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a uriRef return a dict of all the details for that Ref", "response": "def _getDetails(self, uriRef, associations_details):\n        \"\"\"\n        Given a uriRef, return a dict of all the details for that Ref\n        use the uriRef as the 'id' of the dict\n        \"\"\"\n        associationDetail = {}\n        for detail in associations_details:\n            if detail['subject'] == uriRef:\n                associationDetail[detail['predicate']] = detail['object']\n            associationDetail['id'] = uriRef\n        return associationDetail"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat several external identifiers for query", "response": "def _formatExternalIdentifiers(self, element, element_type):\n        \"\"\"\n        Formats several external identifiers for query\n        \"\"\"\n        elementClause = None\n        elements = []\n        if not issubclass(element.__class__, dict):\n            element = protocol.toJsonDict(element)\n        if element['externalIdentifiers']:\n            for _id in element['externalIdentifiers']:\n                elements.append(self._formatExternalIdentifier(\n                    _id, element_type))\n            elementClause = \"({})\".format(\" || \".join(elements))\n        return elementClause"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _formatExternalIdentifier(self, element, element_type):\n        if \"http\" not in element['database']:\n            term = \"{}:{}\".format(element['database'], element['identifier'])\n            namespaceTerm = self._toNamespaceURL(term)\n        else:\n            namespaceTerm = \"{}{}\".format(\n                element['database'], element['identifier'])\n        comparison = '?{} = <{}> '.format(element_type, namespaceTerm)\n        return comparison", "response": "Formats a single external identifier for query"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _formatOntologyTerm(self, element, element_type):\n        elementClause = None\n        if isinstance(element, dict) and element.get('terms'):\n            elements = []\n            for _term in element['terms']:\n                if _term.get('id'):\n                    elements.append('?{} = <{}> '.format(\n                        element_type, _term['id']))\n                else:\n                    elements.append('?{} = <{}> '.format(\n                        element_type, self._toNamespaceURL(_term['term'])))\n            elementClause = \"({})\".format(\" || \".join(elements))\n        return elementClause", "response": "Formats the ontology terms for query\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _formatOntologyTermObject(self, terms, element_type):\n        elementClause = None\n        if not isinstance(terms, collections.Iterable):\n            terms = [terms]\n        elements = []\n        for term in terms:\n            if term.term_id:\n                elements.append('?{} = <{}> '.format(\n                    element_type, term.term_id))\n            else:\n                elements.append('?{} = <{}> '.format(\n                    element_type, self._toNamespaceURL(term.term)))\n        elementClause = \"({})\".format(\" || \".join(elements))\n        return elementClause", "response": "Formats the ontology term object for query"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat a set of identifiers for query", "response": "def _formatIds(self, element, element_type):\n        \"\"\"\n        Formats a set of identifiers for query\n        \"\"\"\n        elementClause = None\n        if isinstance(element, collections.Iterable):\n            elements = []\n            for _id in element:\n                elements.append('?{} = <{}> '.format(\n                    element_type, _id))\n            elementClause = \"({})\".format(\" || \".join(elements))\n        return elementClause"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _formatEvidence(self, elements):\n        elementClause = None\n        filters = []\n        for evidence in elements:\n            if evidence.description:\n                elementClause = 'regex(?{}, \"{}\")'.format(\n                    'environment_label', evidence.description)\n            if (hasattr(evidence, 'externalIdentifiers') and\n                    evidence.externalIdentifiers):\n                # TODO will this pick up > 1 externalIdentifiers ?\n                for externalIdentifier in evidence['externalIdentifiers']:\n                    exid_clause = self._formatExternalIdentifier(\n                        externalIdentifier, 'environment')\n                    # cleanup parens from _formatExternalIdentifier method\n                    elementClause = exid_clause[1:-1]\n            if elementClause:\n                filters.append(elementClause)\n        elementClause = \"({})\".format(\" || \".join(filters))\n        return elementClause", "response": "Formats the elements passed into parts of a query for filtering"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _getIdentifier(self, url):\n        for prefix, namespace in self._rdfGraph.namespaces():\n            if namespace in url:\n                return url.replace(namespace, '')", "response": "Given a url identifier return identifier portion of the graph namespace"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a url return the namespace prefix.", "response": "def _getPrefixURL(self, url):\n        \"\"\"\n        Given a url return namespace prefix.\n        Leverages prefixes already in graph namespace\n        Ex.  \"http://www.drugbank.ca/drugs/DDD\"\n            -> \"http://www.drugbank.ca/drugs/\"\n        \"\"\"\n        for prefix, namespace in self._rdfGraph.namespaces():\n            if namespace.toPython() in url:\n                return namespace"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _toGA4GH(self, association, featureSets=[]):\n\n        # The association dict has the keys: environment, environment\n        # label, evidence, feature label, phenotype and sources. Each\n        # key's value is a dict with the RDF predicates as keys and\n        # subject as values\n\n        # 1) map a GA4GH FeaturePhenotypeAssociation\n        # from the association dict passed to us\n        feature = association['feature']\n\n        fpa = protocol.FeaturePhenotypeAssociation()\n        fpa.id = association['id']\n\n        feature_id = feature['id']\n        for feature_set in featureSets:\n            if self.getLocalId() in feature_set.getLocalId():\n                feature_id = feature_set.getCompoundIdForFeatureId(feature_id)\n\n        fpa.feature_ids.extend([feature_id])\n\n        msg = 'Association: genotype:[{}] phenotype:[{}] environment:[{}] ' \\\n              'evidence:[{}] publications:[{}]'\n        fpa.description = msg.format(\n            association['feature_label'],\n            association['phenotype_label'],\n            association['environment_label'],\n            self._getIdentifier(association['evidence']),\n            association['sources']\n            )\n\n        # 2) map a GA4GH Evidence\n        # from the association's phenotype & evidence\n        evidence = protocol.Evidence()\n        phenotype = association['phenotype']\n\n        term = protocol.OntologyTerm()\n        term.term = association['evidence_type']\n        term.term_id = phenotype['id']\n        evidence.evidence_type.MergeFrom(term)\n\n        evidence.description = self._getIdentifier(association['evidence'])\n\n        # 3) Store publications from the list of sources\n        for source in association['sources'].split(\"|\"):\n            evidence.info['publications'].values.add().string_value = source\n        fpa.evidence.extend([evidence])\n\n        # 4) map environment (drug) to environmentalContext\n        environmentalContext = protocol.EnvironmentalContext()\n        environment = association['environment']\n        environmentalContext.id = environment['id']\n        environmentalContext.description = association['environment_label']\n\n        term = protocol.OntologyTerm()\n        term.term = environment['id']\n        term.term_id = 'http://purl.obolibrary.org/obo/RO_0002606'\n        environmentalContext.environment_type.MergeFrom(term)\n\n        fpa.environmental_contexts.extend([environmentalContext])\n\n        # 5) map the phenotype\n        phenotypeInstance = protocol.PhenotypeInstance()\n        term = protocol.OntologyTerm()\n        term.term = phenotype[TYPE]\n        term.term_id = phenotype['id']\n        phenotypeInstance.type.MergeFrom(term)\n\n        phenotypeInstance.description = phenotype[LABEL]\n        phenotypeInstance.id = phenotype['id']\n        fpa.phenotype.MergeFrom(phenotypeInstance)\n        fpa.phenotype_association_set_id = self.getId()\n        return fpa", "response": "Given an association dict return a GA4GH FeaturePhenotypeAssociation\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getAssociations(\n            self, request=None, featureSets=[]):\n        \"\"\"\n        This query is the main search mechanism.\n        It queries the graph for annotations that match the\n        AND of [feature,environment,phenotype].\n        \"\"\"\n        if len(featureSets) == 0:\n            featureSets = self.getParentContainer().getFeatureSets()\n        # query to do search\n        query = self._formatFilterQuery(request, featureSets)\n        associations = self._rdfGraph.query(query)\n        # associations is now a dict with rdflib terms with variable and\n        # URIrefs or literals\n\n        # given get the details for the feature,phenotype and environment\n        associations_details = self._detailTuples(\n            self._extractAssociationsDetails(\n                associations))\n\n        # association_details is now a list of {subject,predicate,object}\n        # for each of the association detail\n        # http://nmrml.org/cv/v1.0.rc1/doc/doc/objectproperties/BFO0000159___-324347567.html\n        # label \"has quality at all times\" (en)\n        associationList = []\n        for assoc in associations.bindings:\n            if '?feature' in assoc:\n                association = self._bindingsToDict(assoc)\n                association['feature'] = self._getDetails(\n                    association['feature'],\n                    associations_details)\n                association['environment'] = self._getDetails(\n                    association['environment'],\n                    associations_details)\n                association['phenotype'] = self._getDetails(\n                    association['phenotype'],\n                    associations_details)\n                association['evidence'] = association['phenotype'][HAS_QUALITY]\n                association['id'] = association['association']\n                associationList.append(association)\n\n                # our association list is now a list of dicts with the\n                # elements of an association: environment, evidence,\n                # feature, phenotype and sources, each with their\n                # references (labels or URIrefs)\n\n        # create GA4GH objects\n        associations = [\n            self._toGA4GH(assoc, featureSets) for\n            assoc in associationList]\n        return associations", "response": "This method returns a list of dicts with the associations of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a formatted sparql query with appropriate filters", "response": "def _formatFilterQuery(self, request=None, featureSets=[]):\n        \"\"\"\n        Generate a formatted sparql query with appropriate filters\n        \"\"\"\n        query = self._baseQuery()\n        filters = []\n        if issubclass(request.__class__,\n                      protocol.SearchGenotypePhenotypeRequest):\n            filters += self._filterSearchGenotypePhenotypeRequest(\n                request, featureSets)\n\n        if issubclass(request.__class__, protocol.SearchPhenotypesRequest):\n            filters += self._filterSearchPhenotypesRequest(request)\n\n        # apply filters\n        filter = \"FILTER ({})\".format(' && '.join(filters))\n        if len(filters) == 0:\n            filter = \"\"\n        query = query.replace(\"#%FILTER%\", filter)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _filterSearchPhenotypesRequest(self, request):\n        filters = []\n        if request.id:\n            filters.append(\"?phenotype = <{}>\".format(request.id))\n\n        if request.description:\n            filters.append(\n                'regex(?phenotype_label, \"{}\")'.format(request.description))\n        # OntologyTerms\n        # TODO: refactor this repetitive code\n        if hasattr(request.type, 'id') and request.type.id:\n            ontolgytermsClause = self._formatOntologyTermObject(\n                request.type, 'phenotype')\n            if ontolgytermsClause:\n                filters.append(ontolgytermsClause)\n        if len(request.qualifiers) > 0:\n            ontolgytermsClause = self._formatOntologyTermObject(\n                request.qualifiers, 'phenotype_quality')\n            if ontolgytermsClause:\n                filters.append(ontolgytermsClause)\n        if hasattr(request.age_of_onset, 'id') and request.age_of_onset.id:\n            ontolgytermsClause = self._formatOntologyTermObject(\n                request.age_of_onset, 'phenotype_quality')\n            if ontolgytermsClause:\n                filters.append(ontolgytermsClause)\n        return filters", "response": "Filters request for phenotype search requests"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the line describing the mode.", "response": "def parseStep(self, line):\n        \"\"\"\n        Parse the line describing the mode.\n\n        One of:\n        variableStep chrom=<reference> [span=<window_size>]\n        fixedStep chrom=<reference> start=<position> step=<step_interval>\n                  [span=<window_size>]\n\n        Span is optional, defaulting to 1. It indicates that each value\n        applies to region, starting at the given position and extending\n        <span> positions.\n        \"\"\"\n        fields = dict([field.split('=') for field in line.split()[1:]])\n\n        if 'chrom' in fields:\n            self._reference = fields['chrom']\n        else:\n            raise ValueError(\"Missing chrom field in %s\" % line.strip())\n\n        if line.startswith(\"fixedStep\"):\n            if 'start' in fields:\n                self._start = int(fields['start']) - 1  # to 0-based\n            else:\n                raise ValueError(\"Missing start field in %s\" % line.strip())\n\n        if 'span' in fields:\n            self._span = int(fields['span'])\n        if 'step' in fields:\n            self._step = int(fields['step'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a wiggle line.", "response": "def readWiggleLine(self, line):\n        \"\"\"\n        Read a wiggle line. If it is a data line, add values to the\n        protocol object.\n        \"\"\"\n        if(line.isspace() or line.startswith(\"#\")\n                or line.startswith(\"browser\") or line.startswith(\"track\")):\n            return\n        elif line.startswith(\"variableStep\"):\n            self._mode = self._VARIABLE_STEP\n            self.parseStep(line)\n            return\n        elif line.startswith(\"fixedStep\"):\n            self._mode = self._FIXED_STEP\n            self.parseStep(line)\n            return\n        elif self._mode is None:\n            raise ValueError(\"Unexpected input line: %s\" % line.strip())\n\n        if self._queryReference != self._reference:\n            return\n\n        # read data lines\n        fields = line.split()\n        if self._mode == self._VARIABLE_STEP:\n            start = int(fields[0])-1  # to 0-based\n            val = float(fields[1])\n        else:\n            start = self._start\n            self._start += self._step\n            val = float(fields[0])\n\n        if start < self._queryEnd and start > self._queryStart:\n            if self._position is None:\n                self._position = start\n                self._data.start = start\n\n            # fill gap\n            while self._position < start:\n                self._data.values.append(float('NaN'))\n                self._position += 1\n            for _ in xrange(self._span):\n                self._data.values.append(val)\n            self._position += self._span"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wiggleFileHandleToProtocol(self, fileHandle):\n        for line in fileHandle:\n            self.readWiggleLine(line)\n        return self._data", "response": "Returns a continuous protocol object satsifiying the given query\n        parameters from the given wiggle file handle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking the reference for security.", "response": "def checkReference(self, reference):\n        \"\"\"\n        Check the reference for security. Tries to avoid any characters\n        necessary for doing a script injection.\n        \"\"\"\n        pattern = re.compile(r'[\\s,;\"\\'&\\\\]')\n        if pattern.findall(reference.strip()):\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a range of values from a BigWig file and returns a protocol object.", "response": "def readValuesPyBigWig(self, reference, start, end):\n        \"\"\"\n        Use pyBigWig package to read a BigWig file for the\n        given range and return a protocol object.\n\n        pyBigWig returns an array of values that fill the query range.\n        Not sure if it is possible to get the step and span.\n\n        This method trims NaN values from the start and end.\n\n        pyBigWig throws an exception if end is outside of the\n        reference range. This function checks the query range\n        and throws its own exceptions to avoid the ones thrown\n        by pyBigWig.\n        \"\"\"\n        if not self.checkReference(reference):\n            raise exceptions.ReferenceNameNotFoundException(reference)\n        if start < 0:\n            start = 0\n        bw = pyBigWig.open(self._sourceFile)\n        referenceLen = bw.chroms(reference)\n        if referenceLen is None:\n            raise exceptions.ReferenceNameNotFoundException(reference)\n        if end > referenceLen:\n            end = referenceLen\n        if start >= end:\n            raise exceptions.ReferenceRangeErrorException(\n                reference, start, end)\n\n        data = protocol.Continuous()\n        curStart = start\n        curEnd = curStart + self._INCREMENT\n        while curStart < end:\n            if curEnd > end:\n                curEnd = end\n            for i, val in enumerate(bw.values(reference, curStart, curEnd)):\n                if not math.isnan(val):\n                    if len(data.values) == 0:\n                        data.start = curStart + i\n                    data.values.append(val)\n                    if len(data.values) == self._MAX_VALUES:\n                        yield data\n                        data = protocol.Continuous()\n                elif len(data.values) > 0:\n                    # data.values.append(float('NaN'))\n                    yield data\n                    data = protocol.Continuous()\n            curStart = curEnd\n            curEnd = curStart + self._INCREMENT\n\n        bw.close()\n        if len(data.values) > 0:\n            yield data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readValuesBigWigToWig(self, reference, start, end):\n        if not self.checkReference(reference):\n            raise exceptions.ReferenceNameNotFoundException(reference)\n        if start < 0:\n            raise exceptions.ReferenceRangeErrorException(\n                reference, start, end)\n            # TODO: CHECK IF QUERY IS BEYOND END\n\n        cmd = [\"bigWigToWig\", self._sourceFile, \"stdout\", \"-chrom=\"+reference,\n               \"-start=\"+str(start), \"-end=\"+str(end)]\n        wiggleReader = WiggleReader(reference, start, end)\n        try:\n            # run command and grab output simultaneously\n            process = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n            while True:\n                line = process.stdout.readline()\n                if line == '' and process.poll() is not None:\n                    break\n                wiggleReader.readWiggleLine(line.strip())\n        except ValueError:\n            raise\n        except:\n            raise Exception(\"bigWigToWig failed to run\")\n\n        return wiggleReader.getData()", "response": "Reads a bigwig file and returns a protocol object with values\n        within the query range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef toProtocolElement(self):\n        gaContinuousSet = protocol.ContinuousSet()\n        gaContinuousSet.id = self.getId()\n        gaContinuousSet.dataset_id = self.getParentContainer().getId()\n        gaContinuousSet.reference_set_id = pb.string(\n                                            self._referenceSet.getId())\n        gaContinuousSet.name = self._name\n        gaContinuousSet.source_uri = self._sourceUri\n        attributes = self.getAttributes()\n        for key in attributes:\n            gaContinuousSet.attributes.attr[key] \\\n                .values.extend(protocol.encodeValue(attributes[key]))\n        return gaContinuousSet", "response": "Returns the representation of this ContinuousSet as the corresponding\n        ProtocolElement."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef populateFromRow(self, continuousSetRecord):\n        self._filePath = continuousSetRecord.dataurl\n        self.setAttributesJson(continuousSetRecord.attributes)", "response": "Populates the instance variables of this ContinuousSet from the specified DB row."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getContinuous(self, referenceName=None, start=None, end=None):\n        bigWigReader = BigWigDataSource(self._filePath)\n        for continuousObj in bigWigReader.bigWigToProtocol(\n                                            referenceName, start, end):\n            yield continuousObj", "response": "Method that yields continuous protocol objects that satisfy the given query."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getContinuousData(self, referenceName=None, start=None, end=None):\n        randomNumberGenerator = random.Random()\n        randomNumberGenerator.seed(self._randomSeed)\n        for i in range(100):\n            gaContinuous = self._generateSimulatedContinuous(\n                                    randomNumberGenerator)\n            match = (\n                gaContinuous.start < end and\n                gaContinuous.end > start and\n                gaContinuous.reference_name == referenceName)\n            if match:\n                yield gaContinuous", "response": "Returns a set of simulated continuous data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a templated configuration on the device.", "response": "def load_template(self, template_name, template_source=None,\n                      template_path=None, **template_vars):\n        \"\"\"\n        Will load a templated configuration on the device.\n\n        :param cls: Instance of the driver class.\n        :param template_name: Identifies the template name.\n        :param template_source (optional): Custom config template rendered and loaded on device\n        :param template_path (optional): Absolute path to directory for the configuration templates\n        :param template_vars: Dictionary with arguments to be used when the template is rendered.\n        :raise DriverTemplateNotImplemented: No template defined for the device type.\n        :raise TemplateNotImplemented: The template specified in template_name does not exist in \\\n        the default path or in the custom path if any specified using parameter `template_path`.\n        :raise TemplateRenderException: The template could not be rendered. Either the template \\\n        source does not have the right format, either the arguments in `template_vars` are not \\\n        properly specified.\n        \"\"\"\n        return napalm_base.helpers.load_template(self,\n                                                 template_name,\n                                                 template_source=template_source,\n                                                 template_path=template_path,\n                                                 **template_vars)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute ping on the device and returns a dictionary with the result of the ping request.", "response": "def ping(self, destination, source=c.PING_SOURCE, ttl=c.PING_TTL, timeout=c.PING_TIMEOUT,\n             size=c.PING_SIZE, count=c.PING_COUNT, vrf=c.PING_VRF):\n        \"\"\"\n        Executes ping on the device and returns a dictionary with the result\n\n        :param destination: Host or IP Address of the destination\n        :param source (optional): Source address of echo request\n        :param ttl (optional): Maximum number of hops\n        :param timeout (optional): Maximum seconds to wait after sending final packet\n        :param size (optional): Size of request (bytes)\n        :param count (optional): Number of ping request to send\n\n        Output dictionary has one of following keys:\n\n            * success\n            * error\n\n        In case of success, inner dictionary will have the followin keys:\n\n            * probes_sent (int)\n            * packet_loss (int)\n            * rtt_min (float)\n            * rtt_max (float)\n            * rtt_avg (float)\n            * rtt_stddev (float)\n            * results (list)\n\n        'results' is a list of dictionaries with the following keys:\n\n            * ip_address (str)\n            * rtt (float)\n\n        Example::\n\n            {\n                'success': {\n                    'probes_sent': 5,\n                    'packet_loss': 0,\n                    'rtt_min': 72.158,\n                    'rtt_max': 72.433,\n                    'rtt_avg': 72.268,\n                    'rtt_stddev': 0.094,\n                    'results': [\n                        {\n                            'ip_address': u'1.1.1.1',\n                            'rtt': 72.248\n                        },\n                        {\n                            'ip_address': '2.2.2.2',\n                            'rtt': 72.299\n                        }\n                    ]\n                }\n            }\n\n            OR\n\n            {\n                'error': 'unknown host 8.8.8.8.8'\n            }\n\n        \"\"\"\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_commands(self, commands):\n        if \"eos\" in self.profile:\n            return list(self.parent.cli(commands).values())[0]\n        else:\n            raise AttributeError(\"MockedDriver instance has not attribute '_rpc'\")", "response": "Run commands on the mocked instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef textfsm_extractor(cls, template_name, raw_text):\n    textfsm_data = list()\n    cls.__class__.__name__.replace('Driver', '')\n    current_dir = os.path.dirname(os.path.abspath(sys.modules[cls.__module__].__file__))\n    template_dir_path = '{current_dir}/utils/textfsm_templates'.format(\n        current_dir=current_dir\n    )\n    template_path = '{template_dir_path}/{template_name}.tpl'.format(\n        template_dir_path=template_dir_path,\n        template_name=template_name\n    )\n\n    try:\n        fsm_handler = textfsm.TextFSM(open(template_path))\n    except IOError:\n        raise napalm_base.exceptions.TemplateNotImplemented(\n            \"TextFSM template {template_name}.tpl is not defined under {path}\".format(\n                template_name=template_name,\n                path=template_dir_path\n            )\n        )\n    except textfsm.TextFSMTemplateError as tfte:\n        raise napalm_base.exceptions.TemplateRenderException(\n            \"Wrong format of TextFSM template {template_name}: {error}\".format(\n                template_name=template_name,\n                error=py23_compat.text_type(tfte)\n            )\n        )\n\n    objects = fsm_handler.ParseText(raw_text)\n\n    for obj in objects:\n        index = 0\n        entry = {}\n        for entry_value in obj:\n            entry[fsm_handler.header[index].lower()] = entry_value\n            index += 1\n        textfsm_data.append(entry)\n\n    return textfsm_data", "response": "This method extracts the data from a TextFSM template over a raw text and returns the matching table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the text value from an XML tree using XPath.", "response": "def find_txt(xml_tree, path, default=''):\n    \"\"\"\n    Extracts the text value from an XML tree, using XPath.\n    In case of error, will return a default value.\n\n    :param xml_tree: the XML Tree object. Assumed is <type 'lxml.etree._Element'>.\n    :param path:     XPath to be applied, in order to extract the desired data.\n    :param default:  Value to be returned in case of error.\n    :return: a str value.\n    \"\"\"\n    value = ''\n    try:\n        xpath_applied = xml_tree.xpath(path)  # will consider the first match only\n        if len(xpath_applied) and xpath_applied[0] is not None:\n            xpath_result = xpath_applied[0]\n            if isinstance(xpath_result, type(xml_tree)):\n                value = xpath_result.text.strip()\n            else:\n                value = xpath_result\n    except Exception:  # in case of any exception, returns default\n        value = default\n    return py23_compat.text_type(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts data to a specific datatype.", "response": "def convert(to, who, default=u''):\n    \"\"\"\n    Converts data to a specific datatype.\n    In case of error, will return a default value.\n\n    :param to:      datatype to be casted to.\n    :param who:     value to cast.\n    :param default: value to return in case of error.\n    :return: a str value.\n    \"\"\"\n    if who is None:\n        return default\n    try:\n        return to(who)\n    except:  # noqa\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mac(raw):\n    if raw.endswith(':'):\n        flat_raw = raw.replace(':', '')\n        raw = '{flat_raw}{zeros_stuffed}'.format(\n            flat_raw=flat_raw,\n            zeros_stuffed='0'*(12-len(flat_raw))\n        )\n    return py23_compat.text_type(EUI(raw, dialect=_MACFormat))", "response": "Converts a raw string containing the value of the MAC Address in EUI Format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compare_numeric(src_num, dst_num):\n    dst_num = float(dst_num)\n\n    match = numeric_compare_regex.match(src_num)\n    if not match:\n        error = \"Failed numeric comparison. Collected: {}. Expected: {}\".format(dst_num, src_num)\n        raise ValueError(error)\n\n    operand = {\n        \"<\": \"__lt__\",\n        \">\": \"__gt__\",\n        \">=\": \"__ge__\",\n        \"<=\": \"__le__\",\n        \"==\": \"__eq__\",\n        \"!=\": \"__ne__\",\n    }\n    return getattr(dst_num, operand[match.group(1)])(float(match.group(2)))", "response": "Compare numeric values. You can use '<%d','>%d'."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hyphen_range(string):\n    '''\n    Expands a string of numbers separated by commas and hyphens into a list of integers.\n    For example:  2-3,5-7,20-21,23,100-200\n    '''\n    list_numbers = list()\n    temporary_list = string.split(',')\n\n    for element in temporary_list:\n        sub_element = element.split('-')\n\n        if len(sub_element) == 1:\n            list_numbers.append(int(sub_element[0]))\n        elif len(sub_element) == 2:\n            for x in range(int(sub_element[0]), int(sub_element[1])+1):\n                list_numbers.append(x)\n        else:\n            raise Exception('Something went wrong expanding the range'.format(string))\n\n    return list_numbers", "response": "Expands a string of numbers separated by commas and hyphens into a list of integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_uptime_string_seconds(uptime):\n    '''Convert uptime strings to seconds. The string can be formatted various ways.'''\n    regex_list = [\n        # n years, n weeks, n days, n hours, n minutes where each of the fields except minutes\n        # is optional. Additionally, can be either singular or plural\n        (r\"((?P<years>\\d+) year(s)?,\\s+)?((?P<weeks>\\d+) week(s)?,\\s+)?\"\n         r\"((?P<days>\\d+) day(s)?,\\s+)?((?P<hours>\\d+) \"\n         r\"hour(s)?,\\s+)?((?P<minutes>\\d+) minute(s)?)\"),\n        # n days, HH:MM:SS where each field is required (except for days)\n        (r\"((?P<days>\\d+) day(s)?,\\s+)?\"\n         r\"((?P<hours>\\d+)):((?P<minutes>\\d+)):((?P<seconds>\\d+))\"),\n        # 7w6d5h4m3s where each field is optional\n        (r\"((?P<weeks>\\d+)w)?((?P<days>\\d+)d)?((?P<hours>\\d+)h)?\"\n         r\"((?P<minutes>\\d+)m)?((?P<seconds>\\d+)s)?\"),\n    ]\n    regex_list = [re.compile(x) for x in regex_list]\n\n    uptime_dict = {}\n    for regex in regex_list:\n        match = regex.search(uptime)\n        if match:\n            uptime_dict = match.groupdict()\n            break\n\n    uptime_seconds = 0\n    for unit, value in uptime_dict.items():\n        if value is not None:\n            if unit == 'years':\n                uptime_seconds += int(value) * 31536000\n            elif unit == 'weeks':\n                uptime_seconds += int(value) * 604800\n            elif unit == 'days':\n                uptime_seconds += int(value) * 86400\n            elif unit == 'hours':\n                uptime_seconds += int(value) * 3600\n            elif unit == 'minutes':\n                uptime_seconds += int(value) * 60\n            elif unit == 'seconds':\n                uptime_seconds += int(value)\n            else:\n                raise Exception('Unrecognized unit \"{}\" in uptime:{}'.format(unit, uptime))\n\n    if not uptime_dict:\n        raise Exception('Unrecognized uptime string:{}'.format(uptime))\n\n    return uptime_seconds", "response": "Convert uptime strings to seconds. The string can be formatted various ways."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an endpoint using the provided settings. See also: AWS API Documentation :example: response = client.create_endpoint( EndpointIdentifier='string', EndpointType='source'|'target', EngineName='string', Username='string', Password='string', ServerName='string', Port=123, DatabaseName='string', ExtraConnectionAttributes='string', KmsKeyId='string', Tags=[ { 'Key': 'string', 'Value': 'string' }, ], CertificateArn='string', SslMode='none'|'require'|'verify-ca'|'verify-full', DynamoDbSettings={ 'ServiceAccessRoleArn': 'string' }, S3Settings={ 'ServiceAccessRoleArn': 'string', 'ExternalTableDefinition': 'string', 'CsvRowDelimiter': 'string', 'CsvDelimiter': 'string', 'BucketFolder': 'string', 'BucketName': 'string', 'CompressionType': 'none'|'gzip' }, MongoDbSettings={ 'Username': 'string', 'Password': 'string', 'ServerName': 'string', 'Port': 123, 'DatabaseName': 'string', 'AuthType': 'no'|'password', 'AuthMechanism': 'default'|'mongodb_cr'|'scram_sha_1', 'NestingLevel': 'none'|'one', 'ExtractDocId': 'string', 'DocsToInvestigate': 'string', 'AuthSource': 'string' } ) :type EndpointIdentifier: string :param EndpointIdentifier: [REQUIRED] The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens. :type EndpointType: string :param EndpointType: [REQUIRED] The type of endpoint. :type EngineName: string :param EngineName: [REQUIRED] The type of engine for the endpoint. Valid values, depending on the EndPointType, include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, S3, SYBASE, DYNAMODB, MONGODB, and SQLSERVER. :type Username: string :param Username: The user name to be used to login to the endpoint database. :type Password: string :param Password: The password to be used to login to the endpoint database. :type ServerName: string :param ServerName: The name of the server where the endpoint database resides. :type Port: integer :param Port: The port used by the endpoint database. :type DatabaseName: string :param DatabaseName: The name of the endpoint database. :type ExtraConnectionAttributes: string :param ExtraConnectionAttributes: Additional attributes associated with the connection. :type KmsKeyId: string :param KmsKeyId: The KMS key identifier that will be used to encrypt the connection parameters. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. :type Tags: list :param Tags: Tags to be added to the endpoint. (dict) -- Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'dms:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'dms:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). :type CertificateArn: string :param CertificateArn: The Amazon Resource Number (ARN) for the certificate. :type SslMode: string :param SslMode: The SSL mode to use for the SSL connection. SSL mode can be one of four values: none, require, verify-ca, verify-full. The default value is none. :type DynamoDbSettings: dict :param DynamoDbSettings: Settings in JSON format for the target Amazon DynamoDB endpoint. For more information about the available settings, see the Using Object Mapping to Migrate Data to DynamoDB section at Using an Amazon DynamoDB Database as a Target for AWS Database Migration Service . ServiceAccessRoleArn (string) -- [REQUIRED]The Amazon Resource Name (ARN) used by the service access IAM role. :type S3Settings: dict :param S3Settings: Settings in JSON format for the target S3 endpoint. For more information about the available settings, see the Extra Connection Attributes section at Using Amazon S3 as a Target for AWS Database Migration Service . ServiceAccessRoleArn (string) --The Amazon Resource Name (ARN) used by the service access IAM role. ExternalTableDefinition (string) -- CsvRowDelimiter (string) --The delimiter used to separate rows in the source files. The default is a carriage return (n). CsvDelimiter (string) --The delimiter used to separate columns in the source files. The default is a comma. BucketFolder (string) --An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path bucketFolder/schema_name/table_name/. If this parameter is not specified, then the path used is schema_name/table_name/. BucketName (string) --The name of the S3 bucket. CompressionType (string) --An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Set to NONE (the default) or do not use to leave the files uncompressed. :type MongoDbSettings: dict :param MongoDbSettings: Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the Configuration Properties When Using MongoDB as a Source for AWS Database Migration Service section at Using Amazon S3 as a Target for AWS Database Migration Service . Username (string) --The user name you use to access the MongoDB source endpoint. Password (string) --The password for the user account you use to access the MongoDB source endpoint. ServerName (string) --The name of the server on the MongoDB source endpoint. Port (integer) --The port value for the MongoDB source endpoint. DatabaseName (string) --The database name on the MongoDB source endpoint. AuthType (string) --The authentication type you use to access the MongoDB source endpoint. Valid values: NO, PASSWORD When NO is selected, user name and password parameters are not used and can be empty. AuthMechanism (string) --The authentication mechanism you use to access the MongoDB source endpoint. Valid values: DEFAULT, MONGODB_CR, SCRAM_SHA_1 DEFAULT For MongoDB version 2.x, use MONGODB_CR. For MongoDB version 3.x, use SCRAM_SHA_1. This attribute is not used when authType=No. NestingLevel (string) --Specifies either document or table mode. Valid values: NONE, ONE Default value is NONE. Specify NONE to use document mode. Specify ONE to use table mode. ExtractDocId (string) --Specifies the document ID. Use this attribute when NestingLevel is set to NONE. Default value is false. DocsToInvestigate (string) --Indicates the number of documents to preview to determine the document organization. Use this attribute when NestingLevel is set to ONE. Must be a positive value greater than 0. Default value is 1000. AuthSource (string) --The MongoDB database name. This attribute is not used when authType=NO . The default is admin. :rtype: dict :return: { 'Endpoint': { 'EndpointIdentifier': 'string', 'EndpointType': 'source'|'target', 'EngineName': 'string', 'Username': 'string', 'ServerName': 'string', 'Port': 123, 'DatabaseName': 'string', 'ExtraConnectionAttributes': 'string', 'Status': 'string', 'KmsKeyId': 'string', 'EndpointArn': 'string', 'CertificateArn': 'string', 'SslMode': 'none'|'require'|'verify-ca'|'verify-full', 'ExternalId': 'string', 'DynamoDbSettings': { 'ServiceAccessRoleArn': 'string' }, 'S3Settings': { 'ServiceAccessRoleArn': 'string', 'ExternalTableDefinition': 'string', 'CsvRowDelimiter': 'string', 'CsvDelimiter': 'string', 'BucketFolder': 'string', 'BucketName': 'string', 'CompressionType': 'none'|'gzip' }, 'MongoDbSettings': { 'Username': 'string', 'Password': 'string', 'ServerName': 'string', 'Port': 123, 'DatabaseName': 'string', 'AuthType': 'no'|'password', 'AuthMechanism': 'default'|'mongodb_cr'|'scram_sha_1', 'NestingLevel': 'none'|'one', 'ExtractDocId': 'string', 'DocsToInvestigate': 'string', 'AuthSource': 'string' } } }", "response": "def create_endpoint(EndpointIdentifier=None, EndpointType=None, EngineName=None, Username=None, Password=None, ServerName=None, Port=None, DatabaseName=None, ExtraConnectionAttributes=None, KmsKeyId=None, Tags=None, CertificateArn=None, SslMode=None, DynamoDbSettings=None, S3Settings=None, MongoDbSettings=None):\n    \"\"\"\n    Creates an endpoint using the provided settings.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_endpoint(\n        EndpointIdentifier='string',\n        EndpointType='source'|'target',\n        EngineName='string',\n        Username='string',\n        Password='string',\n        ServerName='string',\n        Port=123,\n        DatabaseName='string',\n        ExtraConnectionAttributes='string',\n        KmsKeyId='string',\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        CertificateArn='string',\n        SslMode='none'|'require'|'verify-ca'|'verify-full',\n        DynamoDbSettings={\n            'ServiceAccessRoleArn': 'string'\n        },\n        S3Settings={\n            'ServiceAccessRoleArn': 'string',\n            'ExternalTableDefinition': 'string',\n            'CsvRowDelimiter': 'string',\n            'CsvDelimiter': 'string',\n            'BucketFolder': 'string',\n            'BucketName': 'string',\n            'CompressionType': 'none'|'gzip'\n        },\n        MongoDbSettings={\n            'Username': 'string',\n            'Password': 'string',\n            'ServerName': 'string',\n            'Port': 123,\n            'DatabaseName': 'string',\n            'AuthType': 'no'|'password',\n            'AuthMechanism': 'default'|'mongodb_cr'|'scram_sha_1',\n            'NestingLevel': 'none'|'one',\n            'ExtractDocId': 'string',\n            'DocsToInvestigate': 'string',\n            'AuthSource': 'string'\n        }\n    )\n    \n    \n    :type EndpointIdentifier: string\n    :param EndpointIdentifier: [REQUIRED]\n            The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.\n            \n\n    :type EndpointType: string\n    :param EndpointType: [REQUIRED]\n            The type of endpoint.\n            \n\n    :type EngineName: string\n    :param EngineName: [REQUIRED]\n            The type of engine for the endpoint. Valid values, depending on the EndPointType, include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, S3, SYBASE, DYNAMODB, MONGODB, and SQLSERVER.\n            \n\n    :type Username: string\n    :param Username: The user name to be used to login to the endpoint database.\n\n    :type Password: string\n    :param Password: The password to be used to login to the endpoint database.\n\n    :type ServerName: string\n    :param ServerName: The name of the server where the endpoint database resides.\n\n    :type Port: integer\n    :param Port: The port used by the endpoint database.\n\n    :type DatabaseName: string\n    :param DatabaseName: The name of the endpoint database.\n\n    :type ExtraConnectionAttributes: string\n    :param ExtraConnectionAttributes: Additional attributes associated with the connection.\n\n    :type KmsKeyId: string\n    :param KmsKeyId: The KMS key identifier that will be used to encrypt the connection parameters. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.\n\n    :type Tags: list\n    :param Tags: Tags to be added to the endpoint.\n            (dict) --\n            Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'dms:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'dms:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            \n            \n\n    :type CertificateArn: string\n    :param CertificateArn: The Amazon Resource Number (ARN) for the certificate.\n\n    :type SslMode: string\n    :param SslMode: The SSL mode to use for the SSL connection.\n            SSL mode can be one of four values: none, require, verify-ca, verify-full.\n            The default value is none.\n            \n\n    :type DynamoDbSettings: dict\n    :param DynamoDbSettings: Settings in JSON format for the target Amazon DynamoDB endpoint. For more information about the available settings, see the Using Object Mapping to Migrate Data to DynamoDB section at Using an Amazon DynamoDB Database as a Target for AWS Database Migration Service .\n            ServiceAccessRoleArn (string) -- [REQUIRED]The Amazon Resource Name (ARN) used by the service access IAM role.\n            \n\n    :type S3Settings: dict\n    :param S3Settings: Settings in JSON format for the target S3 endpoint. For more information about the available settings, see the Extra Connection Attributes section at Using Amazon S3 as a Target for AWS Database Migration Service .\n            ServiceAccessRoleArn (string) --The Amazon Resource Name (ARN) used by the service access IAM role.\n            ExternalTableDefinition (string) --\n            CsvRowDelimiter (string) --The delimiter used to separate rows in the source files. The default is a carriage return (n).\n            CsvDelimiter (string) --The delimiter used to separate columns in the source files. The default is a comma.\n            BucketFolder (string) --An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path bucketFolder/schema_name/table_name/. If this parameter is not specified, then the path used is schema_name/table_name/.\n            BucketName (string) --The name of the S3 bucket.\n            CompressionType (string) --An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Set to NONE (the default) or do not use to leave the files uncompressed.\n            \n\n    :type MongoDbSettings: dict\n    :param MongoDbSettings: Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the Configuration Properties When Using MongoDB as a Source for AWS Database Migration Service section at Using Amazon S3 as a Target for AWS Database Migration Service .\n            Username (string) --The user name you use to access the MongoDB source endpoint.\n            Password (string) --The password for the user account you use to access the MongoDB source endpoint.\n            ServerName (string) --The name of the server on the MongoDB source endpoint.\n            Port (integer) --The port value for the MongoDB source endpoint.\n            DatabaseName (string) --The database name on the MongoDB source endpoint.\n            AuthType (string) --The authentication type you use to access the MongoDB source endpoint.\n            Valid values: NO, PASSWORD\n            When NO is selected, user name and password parameters are not used and can be empty.\n            AuthMechanism (string) --The authentication mechanism you use to access the MongoDB source endpoint.\n            Valid values: DEFAULT, MONGODB_CR, SCRAM_SHA_1\n            DEFAULT   For MongoDB version 2.x, use MONGODB_CR. For MongoDB version 3.x, use SCRAM_SHA_1. This attribute is not used when authType=No.\n            NestingLevel (string) --Specifies either document or table mode.\n            Valid values: NONE, ONE\n            Default value is NONE. Specify NONE to use document mode. Specify ONE to use table mode.\n            ExtractDocId (string) --Specifies the document ID. Use this attribute when NestingLevel is set to NONE.\n            Default value is false.\n            DocsToInvestigate (string) --Indicates the number of documents to preview to determine the document organization. Use this attribute when NestingLevel is set to ONE.\n            Must be a positive value greater than 0. Default value is 1000.\n            AuthSource (string) --The MongoDB database name. This attribute is not used when authType=NO .\n            The default is admin.\n            \n\n    :rtype: dict\n    :return: {\n        'Endpoint': {\n            'EndpointIdentifier': 'string',\n            'EndpointType': 'source'|'target',\n            'EngineName': 'string',\n            'Username': 'string',\n            'ServerName': 'string',\n            'Port': 123,\n            'DatabaseName': 'string',\n            'ExtraConnectionAttributes': 'string',\n            'Status': 'string',\n            'KmsKeyId': 'string',\n            'EndpointArn': 'string',\n            'CertificateArn': 'string',\n            'SslMode': 'none'|'require'|'verify-ca'|'verify-full',\n            'ExternalId': 'string',\n            'DynamoDbSettings': {\n                'ServiceAccessRoleArn': 'string'\n            },\n            'S3Settings': {\n                'ServiceAccessRoleArn': 'string',\n                'ExternalTableDefinition': 'string',\n                'CsvRowDelimiter': 'string',\n                'CsvDelimiter': 'string',\n                'BucketFolder': 'string',\n                'BucketName': 'string',\n                'CompressionType': 'none'|'gzip'\n            },\n            'MongoDbSettings': {\n                'Username': 'string',\n                'Password': 'string',\n                'ServerName': 'string',\n                'Port': 123,\n                'DatabaseName': 'string',\n                'AuthType': 'no'|'password',\n                'AuthMechanism': 'default'|'mongodb_cr'|'scram_sha_1',\n                'NestingLevel': 'none'|'one',\n                'ExtractDocId': 'string',\n                'DocsToInvestigate': 'string',\n                'AuthSource': 'string'\n            }\n        }\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_replication_instance(ReplicationInstanceIdentifier=None, AllocatedStorage=None, ReplicationInstanceClass=None, VpcSecurityGroupIds=None, AvailabilityZone=None, ReplicationSubnetGroupIdentifier=None, PreferredMaintenanceWindow=None, MultiAZ=None, EngineVersion=None, AutoMinorVersionUpgrade=None, Tags=None, KmsKeyId=None, PubliclyAccessible=None):\n    pass", "response": "This function creates a new replication instance in AWS Cloud Storage."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_replication_task(ReplicationTaskIdentifier=None, SourceEndpointArn=None, TargetEndpointArn=None, ReplicationInstanceArn=None, MigrationType=None, TableMappings=None, ReplicationTaskSettings=None, CdcStartTime=None, Tags=None):\n    pass", "response": "This function creates a replication task in the DMS."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef describe_events(SourceIdentifier=None, SourceType=None, StartTime=None, EndTime=None, Duration=None, EventCategories=None, Filters=None, MaxRecords=None, Marker=None):\n    pass", "response": "This function returns a list of events for a given source identifier and source type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modify_endpoint(EndpointArn=None, EndpointIdentifier=None, EndpointType=None, EngineName=None, Username=None, Password=None, ServerName=None, Port=None, DatabaseName=None, ExtraConnectionAttributes=None, CertificateArn=None, SslMode=None, DynamoDbSettings=None, S3Settings=None, MongoDbSettings=None):\n    pass", "response": "This function is used to modify an endpoint. You can use the modify_endpoint method to modify an endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmodify the replication instance to apply new settings. You can change one or more parameters by specifying these parameters and the new values in the request. Some settings are applied during the maintenance window. See also: AWS API Documentation :example: response = client.modify_replication_instance( ReplicationInstanceArn='string', AllocatedStorage=123, ApplyImmediately=True|False, ReplicationInstanceClass='string', VpcSecurityGroupIds=[ 'string', ], PreferredMaintenanceWindow='string', MultiAZ=True|False, EngineVersion='string', AllowMajorVersionUpgrade=True|False, AutoMinorVersionUpgrade=True|False, ReplicationInstanceIdentifier='string' ) :type ReplicationInstanceArn: string :param ReplicationInstanceArn: [REQUIRED] The Amazon Resource Name (ARN) of the replication instance. :type AllocatedStorage: integer :param AllocatedStorage: The amount of storage (in gigabytes) to be allocated for the replication instance. :type ApplyImmediately: boolean :param ApplyImmediately: Indicates whether the changes should be applied immediately or during the next maintenance window. :type ReplicationInstanceClass: string :param ReplicationInstanceClass: The compute and memory capacity of the replication instance. Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge :type VpcSecurityGroupIds: list :param VpcSecurityGroupIds: Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. (string) -- :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes :type MultiAZ: boolean :param MultiAZ: Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true . :type EngineVersion: string :param EngineVersion: The engine version number of the replication instance. :type AllowMajorVersionUpgrade: boolean :param AllowMajorVersionUpgrade: Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible. Constraints: This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version. :type AutoMinorVersionUpgrade: boolean :param AutoMinorVersionUpgrade: Indicates that minor version upgrades will be applied automatically to the replication instance during the maintenance window. Changing this parameter does not result in an outage except in the following case and the change is asynchronously applied as soon as possible. An outage will result if this parameter is set to true during the maintenance window, and a newer minor version is available, and AWS DMS has enabled auto patching for that engine version. :type ReplicationInstanceIdentifier: string :param ReplicationInstanceIdentifier: The replication instance identifier. This parameter is stored as a lowercase string. :rtype: dict :return: { 'ReplicationInstance': { 'ReplicationInstanceIdentifier': 'string', 'ReplicationInstanceClass': 'string', 'ReplicationInstanceStatus': 'string', 'AllocatedStorage': 123, 'InstanceCreateTime': datetime(2015, 1, 1), 'VpcSecurityGroups': [ { 'VpcSecurityGroupId': 'string', 'Status': 'string' }, ], 'AvailabilityZone': 'string', 'ReplicationSubnetGroup': { 'ReplicationSubnetGroupIdentifier': 'string', 'ReplicationSubnetGroupDescription': 'string', 'VpcId': 'string', 'SubnetGroupStatus': 'string', 'Subnets': [ { 'SubnetIdentifier': 'string', 'SubnetAvailabilityZone': { 'Name': 'string' }, 'SubnetStatus': 'string' }, ] }, 'PreferredMaintenanceWindow': 'string', 'PendingModifiedValues': { 'ReplicationInstanceClass': 'string', 'AllocatedStorage': 123, 'MultiAZ': True|False, 'EngineVersion': 'string' }, 'MultiAZ': True|False, 'EngineVersion': 'string', 'AutoMinorVersionUpgrade': True|False, 'KmsKeyId': 'string', 'ReplicationInstanceArn': 'string', 'ReplicationInstancePublicIpAddress': 'string', 'ReplicationInstancePrivateIpAddress': 'string', 'ReplicationInstancePublicIpAddresses': [ 'string', ], 'ReplicationInstancePrivateIpAddresses': [ 'string', ], 'PubliclyAccessible': True|False, 'SecondaryAvailabilityZone': 'string' } } :returns: Must contain from 1 to 63 alphanumeric characters or hyphens. First character must be a letter. Cannot end with a hyphen or contain two consecutive hyphens.", "response": "def modify_replication_instance(ReplicationInstanceArn=None, AllocatedStorage=None, ApplyImmediately=None, ReplicationInstanceClass=None, VpcSecurityGroupIds=None, PreferredMaintenanceWindow=None, MultiAZ=None, EngineVersion=None, AllowMajorVersionUpgrade=None, AutoMinorVersionUpgrade=None, ReplicationInstanceIdentifier=None):\n    \"\"\"\n    Modifies the replication instance to apply new settings. You can change one or more parameters by specifying these parameters and the new values in the request.\n    Some settings are applied during the maintenance window.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.modify_replication_instance(\n        ReplicationInstanceArn='string',\n        AllocatedStorage=123,\n        ApplyImmediately=True|False,\n        ReplicationInstanceClass='string',\n        VpcSecurityGroupIds=[\n            'string',\n        ],\n        PreferredMaintenanceWindow='string',\n        MultiAZ=True|False,\n        EngineVersion='string',\n        AllowMajorVersionUpgrade=True|False,\n        AutoMinorVersionUpgrade=True|False,\n        ReplicationInstanceIdentifier='string'\n    )\n    \n    \n    :type ReplicationInstanceArn: string\n    :param ReplicationInstanceArn: [REQUIRED]\n            The Amazon Resource Name (ARN) of the replication instance.\n            \n\n    :type AllocatedStorage: integer\n    :param AllocatedStorage: The amount of storage (in gigabytes) to be allocated for the replication instance.\n\n    :type ApplyImmediately: boolean\n    :param ApplyImmediately: Indicates whether the changes should be applied immediately or during the next maintenance window.\n\n    :type ReplicationInstanceClass: string\n    :param ReplicationInstanceClass: The compute and memory capacity of the replication instance.\n            Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge\n            \n\n    :type VpcSecurityGroupIds: list\n    :param VpcSecurityGroupIds: Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.\n            (string) --\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied.\n            Default: Uses existing setting\n            Format: ddd:hh24:mi-ddd:hh24:mi\n            Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun\n            Constraints: Must be at least 30 minutes\n            \n\n    :type MultiAZ: boolean\n    :param MultiAZ: Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true .\n\n    :type EngineVersion: string\n    :param EngineVersion: The engine version number of the replication instance.\n\n    :type AllowMajorVersionUpgrade: boolean\n    :param AllowMajorVersionUpgrade: Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible.\n            Constraints: This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.\n            \n\n    :type AutoMinorVersionUpgrade: boolean\n    :param AutoMinorVersionUpgrade: Indicates that minor version upgrades will be applied automatically to the replication instance during the maintenance window. Changing this parameter does not result in an outage except in the following case and the change is asynchronously applied as soon as possible. An outage will result if this parameter is set to true during the maintenance window, and a newer minor version is available, and AWS DMS has enabled auto patching for that engine version.\n\n    :type ReplicationInstanceIdentifier: string\n    :param ReplicationInstanceIdentifier: The replication instance identifier. This parameter is stored as a lowercase string.\n\n    :rtype: dict\n    :return: {\n        'ReplicationInstance': {\n            'ReplicationInstanceIdentifier': 'string',\n            'ReplicationInstanceClass': 'string',\n            'ReplicationInstanceStatus': 'string',\n            'AllocatedStorage': 123,\n            'InstanceCreateTime': datetime(2015, 1, 1),\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'AvailabilityZone': 'string',\n            'ReplicationSubnetGroup': {\n                'ReplicationSubnetGroupIdentifier': 'string',\n                'ReplicationSubnetGroupDescription': 'string',\n                'VpcId': 'string',\n                'SubnetGroupStatus': 'string',\n                'Subnets': [\n                    {\n                        'SubnetIdentifier': 'string',\n                        'SubnetAvailabilityZone': {\n                            'Name': 'string'\n                        },\n                        'SubnetStatus': 'string'\n                    },\n                ]\n            },\n            'PreferredMaintenanceWindow': 'string',\n            'PendingModifiedValues': {\n                'ReplicationInstanceClass': 'string',\n                'AllocatedStorage': 123,\n                'MultiAZ': True|False,\n                'EngineVersion': 'string'\n            },\n            'MultiAZ': True|False,\n            'EngineVersion': 'string',\n            'AutoMinorVersionUpgrade': True|False,\n            'KmsKeyId': 'string',\n            'ReplicationInstanceArn': 'string',\n            'ReplicationInstancePublicIpAddress': 'string',\n            'ReplicationInstancePrivateIpAddress': 'string',\n            'ReplicationInstancePublicIpAddresses': [\n                'string',\n            ],\n            'ReplicationInstancePrivateIpAddresses': [\n                'string',\n            ],\n            'PubliclyAccessible': True|False,\n            'SecondaryAvailabilityZone': 'string'\n        }\n    }\n    \n    \n    :returns: \n    Must contain from 1 to 63 alphanumeric characters or hyphens.\n    First character must be a letter.\n    Cannot end with a hyphen or contain two consecutive hyphens.\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_fleet(Name=None, ImageName=None, InstanceType=None, ComputeCapacity=None, VpcConfig=None, MaxUserDurationInSeconds=None, DisconnectTimeoutInSeconds=None, Description=None, DisplayName=None, EnableDefaultInternetAccess=None):\n    pass", "response": "Creates a new fleet."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates an existing fleet. All the attributes except the fleet name can be updated in the STOPPED state. When a fleet is in the RUNNING state, only DisplayName and ComputeCapacity can be updated. A fleet cannot be updated in a status of STARTING or STOPPING . See also: AWS API Documentation :example: response = client.update_fleet( ImageName='string', Name='string', InstanceType='string', ComputeCapacity={ 'DesiredInstances': 123 }, VpcConfig={ 'SubnetIds': [ 'string', ] }, MaxUserDurationInSeconds=123, DisconnectTimeoutInSeconds=123, DeleteVpcConfig=True|False, Description='string', DisplayName='string', EnableDefaultInternetAccess=True|False ) :type ImageName: string :param ImageName: The image name from which a fleet is created. :type Name: string :param Name: [REQUIRED] The name of the fleet. :type InstanceType: string :param InstanceType: The instance type of compute resources for the fleet. Fleet instances are launched from this instance type. :type ComputeCapacity: dict :param ComputeCapacity: The parameters for the capacity allocated to the fleet. DesiredInstances (integer) -- [REQUIRED]The desired number of streaming instances. :type VpcConfig: dict :param VpcConfig: The VPC configuration for the fleet. SubnetIds (list) --The list of subnets to which a network interface is established from the fleet instance. (string) -- :type MaxUserDurationInSeconds: integer :param MaxUserDurationInSeconds: The maximum time for which a streaming session can run. The input can be any numeric value in seconds between 600 and 57600. :type DisconnectTimeoutInSeconds: integer :param DisconnectTimeoutInSeconds: The time after disconnection when a session is considered to have ended. If a user who got disconnected reconnects within this timeout interval, the user is connected back to their previous session. The input can be any numeric value in seconds between 60 and 57600. :type DeleteVpcConfig: boolean :param DeleteVpcConfig: Delete the VPC association for the specified fleet. :type Description: string :param Description: The description displayed to end users on the AppStream 2.0 portal. :type DisplayName: string :param DisplayName: The name displayed to end users on the AppStream 2.0 portal. :type EnableDefaultInternetAccess: boolean :param EnableDefaultInternetAccess: Enables or disables default Internet access for the fleet. :rtype: dict :return: { 'Fleet': { 'Arn': 'string', 'Name': 'string', 'DisplayName': 'string', 'Description': 'string', 'ImageName': 'string', 'InstanceType': 'string', 'ComputeCapacityStatus': { 'Desired': 123, 'Running': 123, 'InUse': 123, 'Available': 123 }, 'MaxUserDurationInSeconds': 123, 'DisconnectTimeoutInSeconds': 123, 'State': 'STARTING'|'RUNNING'|'STOPPING'|'STOPPED', 'VpcConfig': { 'SubnetIds': [ 'string', ] }, 'CreatedTime': datetime(2015, 1, 1), 'FleetErrors': [ { 'ErrorCode': 'IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION'|'IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION'|'IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION'|'NETWORK_INTERFACE_LIMIT_EXCEEDED'|'INTERNAL_SERVICE_ERROR'|'IAM_SERVICE_ROLE_IS_MISSING'|'SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES'|'IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION'|'SUBNET_NOT_FOUND'|'IMAGE_NOT_FOUND'|'INVALID_SUBNET_CONFIGURATION', 'ErrorMessage': 'string' }, ], 'EnableDefaultInternetAccess': True|False } } :returns: (string) --", "response": "def update_fleet(ImageName=None, Name=None, InstanceType=None, ComputeCapacity=None, VpcConfig=None, MaxUserDurationInSeconds=None, DisconnectTimeoutInSeconds=None, DeleteVpcConfig=None, Description=None, DisplayName=None, EnableDefaultInternetAccess=None):\n    \"\"\"\n    Updates an existing fleet. All the attributes except the fleet name can be updated in the STOPPED state. When a fleet is in the RUNNING state, only DisplayName and ComputeCapacity can be updated. A fleet cannot be updated in a status of STARTING or STOPPING .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_fleet(\n        ImageName='string',\n        Name='string',\n        InstanceType='string',\n        ComputeCapacity={\n            'DesiredInstances': 123\n        },\n        VpcConfig={\n            'SubnetIds': [\n                'string',\n            ]\n        },\n        MaxUserDurationInSeconds=123,\n        DisconnectTimeoutInSeconds=123,\n        DeleteVpcConfig=True|False,\n        Description='string',\n        DisplayName='string',\n        EnableDefaultInternetAccess=True|False\n    )\n    \n    \n    :type ImageName: string\n    :param ImageName: The image name from which a fleet is created.\n\n    :type Name: string\n    :param Name: [REQUIRED]\n            The name of the fleet.\n            \n\n    :type InstanceType: string\n    :param InstanceType: The instance type of compute resources for the fleet. Fleet instances are launched from this instance type.\n\n    :type ComputeCapacity: dict\n    :param ComputeCapacity: The parameters for the capacity allocated to the fleet.\n            DesiredInstances (integer) -- [REQUIRED]The desired number of streaming instances.\n            \n\n    :type VpcConfig: dict\n    :param VpcConfig: The VPC configuration for the fleet.\n            SubnetIds (list) --The list of subnets to which a network interface is established from the fleet instance.\n            (string) --\n            \n\n    :type MaxUserDurationInSeconds: integer\n    :param MaxUserDurationInSeconds: The maximum time for which a streaming session can run. The input can be any numeric value in seconds between 600 and 57600.\n\n    :type DisconnectTimeoutInSeconds: integer\n    :param DisconnectTimeoutInSeconds: The time after disconnection when a session is considered to have ended. If a user who got disconnected reconnects within this timeout interval, the user is connected back to their previous session. The input can be any numeric value in seconds between 60 and 57600.\n\n    :type DeleteVpcConfig: boolean\n    :param DeleteVpcConfig: Delete the VPC association for the specified fleet.\n\n    :type Description: string\n    :param Description: The description displayed to end users on the AppStream 2.0 portal.\n\n    :type DisplayName: string\n    :param DisplayName: The name displayed to end users on the AppStream 2.0 portal.\n\n    :type EnableDefaultInternetAccess: boolean\n    :param EnableDefaultInternetAccess: Enables or disables default Internet access for the fleet.\n\n    :rtype: dict\n    :return: {\n        'Fleet': {\n            'Arn': 'string',\n            'Name': 'string',\n            'DisplayName': 'string',\n            'Description': 'string',\n            'ImageName': 'string',\n            'InstanceType': 'string',\n            'ComputeCapacityStatus': {\n                'Desired': 123,\n                'Running': 123,\n                'InUse': 123,\n                'Available': 123\n            },\n            'MaxUserDurationInSeconds': 123,\n            'DisconnectTimeoutInSeconds': 123,\n            'State': 'STARTING'|'RUNNING'|'STOPPING'|'STOPPED',\n            'VpcConfig': {\n                'SubnetIds': [\n                    'string',\n                ]\n            },\n            'CreatedTime': datetime(2015, 1, 1),\n            'FleetErrors': [\n                {\n                    'ErrorCode': 'IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION'|'IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION'|'IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION'|'NETWORK_INTERFACE_LIMIT_EXCEEDED'|'INTERNAL_SERVICE_ERROR'|'IAM_SERVICE_ROLE_IS_MISSING'|'SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES'|'IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION'|'SUBNET_NOT_FOUND'|'IMAGE_NOT_FOUND'|'INVALID_SUBNET_CONFIGURATION',\n                    'ErrorMessage': 'string'\n                },\n            ],\n            'EnableDefaultInternetAccess': True|False\n        }\n    }\n    \n    \n    :returns: \n    (string) --\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_deployment(applicationName=None, deploymentGroupName=None, revision=None, deploymentConfigName=None, description=None, ignoreApplicationStopFailures=None, targetInstances=None, autoRollbackConfiguration=None, updateOutdatedInstancesOnly=None, fileExistsBehavior=None):\n    pass", "response": "Creates a new deployment for an application in a specified deployment group."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new deployment group for the application with the specified properties.", "response": "def create_deployment_group(applicationName=None, deploymentGroupName=None, deploymentConfigName=None, ec2TagFilters=None, onPremisesInstanceTagFilters=None, autoScalingGroups=None, serviceRoleArn=None, triggerConfigurations=None, alarmConfiguration=None, autoRollbackConfiguration=None, deploymentStyle=None, blueGreenDeploymentConfiguration=None, loadBalancerInfo=None):\n    \"\"\"\n    Creates a deployment group to which application revisions will be deployed.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_deployment_group(\n        applicationName='string',\n        deploymentGroupName='string',\n        deploymentConfigName='string',\n        ec2TagFilters=[\n            {\n                'Key': 'string',\n                'Value': 'string',\n                'Type': 'KEY_ONLY'|'VALUE_ONLY'|'KEY_AND_VALUE'\n            },\n        ],\n        onPremisesInstanceTagFilters=[\n            {\n                'Key': 'string',\n                'Value': 'string',\n                'Type': 'KEY_ONLY'|'VALUE_ONLY'|'KEY_AND_VALUE'\n            },\n        ],\n        autoScalingGroups=[\n            'string',\n        ],\n        serviceRoleArn='string',\n        triggerConfigurations=[\n            {\n                'triggerName': 'string',\n                'triggerTargetArn': 'string',\n                'triggerEvents': [\n                    'DeploymentStart'|'DeploymentSuccess'|'DeploymentFailure'|'DeploymentStop'|'DeploymentRollback'|'DeploymentReady'|'InstanceStart'|'InstanceSuccess'|'InstanceFailure'|'InstanceReady',\n                ]\n            },\n        ],\n        alarmConfiguration={\n            'enabled': True|False,\n            'ignorePollAlarmFailure': True|False,\n            'alarms': [\n                {\n                    'name': 'string'\n                },\n            ]\n        },\n        autoRollbackConfiguration={\n            'enabled': True|False,\n            'events': [\n                'DEPLOYMENT_FAILURE'|'DEPLOYMENT_STOP_ON_ALARM'|'DEPLOYMENT_STOP_ON_REQUEST',\n            ]\n        },\n        deploymentStyle={\n            'deploymentType': 'IN_PLACE'|'BLUE_GREEN',\n            'deploymentOption': 'WITH_TRAFFIC_CONTROL'|'WITHOUT_TRAFFIC_CONTROL'\n        },\n        blueGreenDeploymentConfiguration={\n            'terminateBlueInstancesOnDeploymentSuccess': {\n                'action': 'TERMINATE'|'KEEP_ALIVE',\n                'terminationWaitTimeInMinutes': 123\n            },\n            'deploymentReadyOption': {\n                'actionOnTimeout': 'CONTINUE_DEPLOYMENT'|'STOP_DEPLOYMENT',\n                'waitTimeInMinutes': 123\n            },\n            'greenFleetProvisioningOption': {\n                'action': 'DISCOVER_EXISTING'|'COPY_AUTO_SCALING_GROUP'\n            }\n        },\n        loadBalancerInfo={\n            'elbInfoList': [\n                {\n                    'name': 'string'\n                },\n            ]\n        }\n    )\n    \n    \n    :type applicationName: string\n    :param applicationName: [REQUIRED]\n            The name of an AWS CodeDeploy application associated with the applicable IAM user or AWS account.\n            \n\n    :type deploymentGroupName: string\n    :param deploymentGroupName: [REQUIRED]\n            The name of a new deployment group for the specified application.\n            \n\n    :type deploymentConfigName: string\n    :param deploymentConfigName: If specified, the deployment configuration name can be either one of the predefined configurations provided with AWS CodeDeploy or a custom deployment configuration that you create by calling the create deployment configuration operation.\n            CodeDeployDefault.OneAtATime is the default deployment configuration. It is used if a configuration isn't specified for the deployment or the deployment group.\n            For more information about the predefined deployment configurations in AWS CodeDeploy, see Working with Deployment Groups in AWS CodeDeploy in the AWS CodeDeploy User Guide.\n            \n\n    :type ec2TagFilters: list\n    :param ec2TagFilters: The Amazon EC2 tags on which to filter. The deployment group will include EC2 instances with any of the specified tags.\n            (dict) --Information about an EC2 tag filter.\n            Key (string) --The tag filter key.\n            Value (string) --The tag filter value.\n            Type (string) --The tag filter type:\n            KEY_ONLY: Key only.\n            VALUE_ONLY: Value only.\n            KEY_AND_VALUE: Key and value.\n            \n            \n\n    :type onPremisesInstanceTagFilters: list\n    :param onPremisesInstanceTagFilters: The on-premises instance tags on which to filter. The deployment group will include on-premises instances with any of the specified tags.\n            (dict) --Information about an on-premises instance tag filter.\n            Key (string) --The on-premises instance tag filter key.\n            Value (string) --The on-premises instance tag filter value.\n            Type (string) --The on-premises instance tag filter type:\n            KEY_ONLY: Key only.\n            VALUE_ONLY: Value only.\n            KEY_AND_VALUE: Key and value.\n            \n            \n\n    :type autoScalingGroups: list\n    :param autoScalingGroups: A list of associated Auto Scaling groups.\n            (string) --\n            \n\n    :type serviceRoleArn: string\n    :param serviceRoleArn: [REQUIRED]\n            A service role ARN that allows AWS CodeDeploy to act on the user's behalf when interacting with AWS services.\n            \n\n    :type triggerConfigurations: list\n    :param triggerConfigurations: Information about triggers to create when the deployment group is created. For examples, see Create a Trigger for an AWS CodeDeploy Event in the AWS CodeDeploy User Guide.\n            (dict) --Information about notification triggers for the deployment group.\n            triggerName (string) --The name of the notification trigger.\n            triggerTargetArn (string) --The ARN of the Amazon Simple Notification Service topic through which notifications about deployment or instance events are sent.\n            triggerEvents (list) --The event type or types for which notifications are triggered.\n            (string) --\n            \n            \n\n    :type alarmConfiguration: dict\n    :param alarmConfiguration: Information to add about Amazon CloudWatch alarms when the deployment group is created.\n            enabled (boolean) --Indicates whether the alarm configuration is enabled.\n            ignorePollAlarmFailure (boolean) --Indicates whether a deployment should continue if information about the current state of alarms cannot be retrieved from Amazon CloudWatch. The default value is false.\n            true: The deployment will proceed even if alarm status information can't be retrieved from Amazon CloudWatch.\n            false: The deployment will stop if alarm status information can't be retrieved from Amazon CloudWatch.\n            alarms (list) --A list of alarms configured for the deployment group. A maximum of 10 alarms can be added to a deployment group.\n            (dict) --Information about an alarm.\n            name (string) --The name of the alarm. Maximum length is 255 characters. Each alarm name can be used only once in a list of alarms.\n            \n            \n\n    :type autoRollbackConfiguration: dict\n    :param autoRollbackConfiguration: Configuration information for an automatic rollback that is added when a deployment group is created.\n            enabled (boolean) --Indicates whether a defined automatic rollback configuration is currently enabled.\n            events (list) --The event type or types that trigger a rollback.\n            (string) --\n            \n\n    :type deploymentStyle: dict\n    :param deploymentStyle: Information about the type of deployment, in-place or blue/green, that you want to run and whether to route deployment traffic behind a load balancer.\n            deploymentType (string) --Indicates whether to run an in-place deployment or a blue/green deployment.\n            deploymentOption (string) --Indicates whether to route deployment traffic behind a load balancer.\n            \n\n    :type blueGreenDeploymentConfiguration: dict\n    :param blueGreenDeploymentConfiguration: Information about blue/green deployment options for a deployment group.\n            terminateBlueInstancesOnDeploymentSuccess (dict) --Information about whether to terminate instances in the original fleet during a blue/green deployment.\n            action (string) --The action to take on instances in the original environment after a successful blue/green deployment.\n            TERMINATE: Instances are terminated after a specified wait time.\n            KEEP_ALIVE: Instances are left running after they are deregistered from the load balancer and removed from the deployment group.\n            terminationWaitTimeInMinutes (integer) --The number of minutes to wait after a successful blue/green deployment before terminating instances from the original environment.\n            deploymentReadyOption (dict) --Information about the action to take when newly provisioned instances are ready to receive traffic in a blue/green deployment.\n            actionOnTimeout (string) --Information about when to reroute traffic from an original environment to a replacement environment in a blue/green deployment.\n            CONTINUE_DEPLOYMENT: Register new instances with the load balancer immediately after the new application revision is installed on the instances in the replacement environment.\n            STOP_DEPLOYMENT: Do not register new instances with load balancer unless traffic is rerouted manually. If traffic is not rerouted manually before the end of the specified wait period, the deployment status is changed to Stopped.\n            waitTimeInMinutes (integer) --The number of minutes to wait before the status of a blue/green deployment changed to Stopped if rerouting is not started manually. Applies only to the STOP_DEPLOYMENT option for actionOnTimeout\n            greenFleetProvisioningOption (dict) --Information about how instances are provisioned for a replacement environment in a blue/green deployment.\n            action (string) --The method used to add instances to a replacement environment.\n            DISCOVER_EXISTING: Use instances that already exist or will be created manually.\n            COPY_AUTO_SCALING_GROUP: Use settings from a specified Auto Scaling group to define and create instances in a new Auto Scaling group.\n            \n            \n\n    :type loadBalancerInfo: dict\n    :param loadBalancerInfo: Information about the load balancer used in a deployment.\n            elbInfoList (list) --An array containing information about the load balancer in Elastic Load Balancing to use in a deployment.\n            (dict) --Information about a load balancer in Elastic Load Balancing to use in a deployment.\n            name (string) --For blue/green deployments, the name of the load balancer that will be used to route traffic from original instances to replacement instances in a blue/green deployment. For in-place deployments, the name of the load balancer that instances are deregistered from so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.\n            \n            \n\n    :rtype: dict\n    :return: {\n        'deploymentGroupId': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_deployment_group(applicationName=None, currentDeploymentGroupName=None, newDeploymentGroupName=None, deploymentConfigName=None, ec2TagFilters=None, onPremisesInstanceTagFilters=None, autoScalingGroups=None, serviceRoleArn=None, triggerConfigurations=None, alarmConfiguration=None, autoRollbackConfiguration=None, deploymentStyle=None, blueGreenDeploymentConfiguration=None, loadBalancerInfo=None):\n    pass", "response": "This function updates the information about a specific Amazon SageMaker deployment group."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_nfs_file_share(ClientToken=None, NFSFileShareDefaults=None, GatewayARN=None, KMSEncrypted=None, KMSKey=None, Role=None, LocationARN=None, DefaultStorageClass=None, ClientList=None, Squash=None, ReadOnly=None):\n    pass", "response": "This function creates a file share on an existing file system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_target_group(Name=None, Protocol=None, Port=None, VpcId=None, HealthCheckProtocol=None, HealthCheckPort=None, HealthCheckPath=None, HealthCheckIntervalSeconds=None, HealthCheckTimeoutSeconds=None, HealthyThresholdCount=None, UnhealthyThresholdCount=None, Matcher=None):\n    pass", "response": "Creates a target group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modify_target_group(TargetGroupArn=None, HealthCheckProtocol=None, HealthCheckPort=None, HealthCheckPath=None, HealthCheckIntervalSeconds=None, HealthCheckTimeoutSeconds=None, HealthyThresholdCount=None, UnhealthyThresholdCount=None, Matcher=None):\n    pass", "response": "This function is used to modify the health of the targets in a target group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new fleet with the specified properties.", "response": "def create_fleet(Name=None, Description=None, BuildId=None, ServerLaunchPath=None, ServerLaunchParameters=None, LogPaths=None, EC2InstanceType=None, EC2InboundPermissions=None, NewGameSessionProtectionPolicy=None, RuntimeConfiguration=None, ResourceCreationLimitPolicy=None, MetricGroups=None):\n    \"\"\"\n    Creates a new fleet to run your game servers. A fleet is a set of Amazon Elastic Compute Cloud (Amazon EC2) instances, each of which can run multiple server processes to host game sessions. You configure a fleet to create instances with certain hardware specifications (see Amazon EC2 Instance Types for more information), and deploy a specified game build to each instance. A newly created fleet passes through several statuses; once it reaches the ACTIVE status, it can begin hosting game sessions.\n    To create a new fleet, you must specify the following: (1) fleet name, (2) build ID of an uploaded game build, (3) an EC2 instance type, and (4) a runtime configuration that describes which server processes to run on each instance in the fleet. (Although the runtime configuration is not a required parameter, the fleet cannot be successfully created without it.) You can also configure the new fleet with the following settings: fleet description, access permissions for inbound traffic, fleet-wide game session protection, and resource creation limit. If you use Amazon CloudWatch for metrics, you can add the new fleet to a metric group, which allows you to view aggregated metrics for a set of fleets. Once you specify a metric group, the new fleet's metrics are included in the metric group's data.\n    If the CreateFleet call is successful, Amazon GameLift performs the following tasks:\n    After a fleet is created, use the following actions to change fleet properties and configuration:\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_fleet(\n        Name='string',\n        Description='string',\n        BuildId='string',\n        ServerLaunchPath='string',\n        ServerLaunchParameters='string',\n        LogPaths=[\n            'string',\n        ],\n        EC2InstanceType='t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge',\n        EC2InboundPermissions=[\n            {\n                'FromPort': 123,\n                'ToPort': 123,\n                'IpRange': 'string',\n                'Protocol': 'TCP'|'UDP'\n            },\n        ],\n        NewGameSessionProtectionPolicy='NoProtection'|'FullProtection',\n        RuntimeConfiguration={\n            'ServerProcesses': [\n                {\n                    'LaunchPath': 'string',\n                    'Parameters': 'string',\n                    'ConcurrentExecutions': 123\n                },\n            ],\n            'MaxConcurrentGameSessionActivations': 123,\n            'GameSessionActivationTimeoutSeconds': 123\n        },\n        ResourceCreationLimitPolicy={\n            'NewGameSessionsPerCreator': 123,\n            'PolicyPeriodInMinutes': 123\n        },\n        MetricGroups=[\n            'string',\n        ]\n    )\n    \n    \n    :type Name: string\n    :param Name: [REQUIRED]\n            Descriptive label that is associated with a fleet. Fleet names do not need to be unique.\n            \n\n    :type Description: string\n    :param Description: Human-readable description of a fleet.\n\n    :type BuildId: string\n    :param BuildId: [REQUIRED]\n            Unique identifier for a build to be deployed on the new fleet. The build must have been successfully uploaded to Amazon GameLift and be in a READY status. This fleet setting cannot be changed once the fleet is created.\n            \n\n    :type ServerLaunchPath: string\n    :param ServerLaunchPath: This parameter is no longer used. Instead, specify a server launch path using the RuntimeConfiguration parameter. (Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.)\n\n    :type ServerLaunchParameters: string\n    :param ServerLaunchParameters: This parameter is no longer used. Instead, specify server launch parameters in the RuntimeConfiguration parameter. (Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.)\n\n    :type LogPaths: list\n    :param LogPaths: This parameter is no longer used. Instead, to specify where Amazon GameLift should store log files once a server process shuts down, use the Amazon GameLift server API ProcessReady() and specify one or more directory paths in logParameters . See more information in the Server API Reference .\n            (string) --\n            \n\n    :type EC2InstanceType: string\n    :param EC2InstanceType: [REQUIRED]\n            Name of an EC2 instance type that is supported in Amazon GameLift. A fleet instance type determines the computing resources of each instance in the fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift supports the following EC2 instance types. See Amazon EC2 Instance Types for detailed descriptions.\n            \n\n    :type EC2InboundPermissions: list\n    :param EC2InboundPermissions: Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. If no inbound permissions are set, including both IP address range and port range, the server processes in the fleet cannot accept connections. You can specify one or more sets of permissions for a fleet.\n            (dict) --A range of IP addresses and port settings that allow inbound traffic to connect to server processes on Amazon GameLift. Each game session hosted on a fleet is assigned a unique combination of IP address and port number, which must fall into the fleet's allowed ranges. This combination is included in the GameSession object.\n            FromPort (integer) -- [REQUIRED]Starting value for a range of allowed port numbers.\n            ToPort (integer) -- [REQUIRED]Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort .\n            IpRange (string) -- [REQUIRED]Range of allowed IP addresses. This value must be expressed in CIDR notation. Example: '000.000.000.000/[subnet mask] ' or optionally the shortened version '0.0.0.0/[subnet mask] '.\n            Protocol (string) -- [REQUIRED]Network communication protocol used by the fleet.\n            \n            \n\n    :type NewGameSessionProtectionPolicy: string\n    :param NewGameSessionProtectionPolicy: Game session protection policy to apply to all instances in this fleet. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy using UpdateFleetAttributes, but this change will only affect sessions created after the policy change. You can also set protection for individual instances using UpdateGameSession .\n            NoProtection   The game session can be terminated during a scale-down event.\n            FullProtection   If the game session is in an ACTIVE status, it cannot be terminated during a scale-down event.\n            \n\n    :type RuntimeConfiguration: dict\n    :param RuntimeConfiguration: Instructions for launching server processes on each instance in the fleet. The runtime configuration for a fleet has a collection of server process configurations, one for each type of server process to run on an instance. A server process configuration specifies the location of the server executable, launch parameters, and the number of concurrent processes with that configuration to maintain on each instance. A CreateFleet request must include a runtime configuration with at least one server process configuration; otherwise the request will fail with an invalid request exception. (This parameter replaces the parameters ServerLaunchPath and ServerLaunchParameters ; requests that contain values for these parameters instead of a runtime configuration will continue to work.)\n            ServerProcesses (list) --Collection of server process configurations that describe which server processes to run on each instance in a fleet.\n            (dict) --A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's `` RuntimeConfiguration `` .\n            LaunchPath (string) -- [REQUIRED]Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances C:\\game , and for Linux instances /local/game . A Windows game build with an executable file located at MyGame\\latest\\server.exe must have a launch path of 'C:\\game\\MyGame\\latest\\server.exe '. A Linux game build with an executable file located at MyGame/latest/server.exe must have a launch path of '/local/game/MyGame/latest/server.exe '.\n            Parameters (string) --Optional list of parameters to pass to the server executable on launch.\n            ConcurrentExecutions (integer) -- [REQUIRED]Number of server processes using this configuration to run concurrently on an instance.\n            \n            MaxConcurrentGameSessionActivations (integer) --Maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.\n            GameSessionActivationTimeoutSeconds (integer) --Maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.\n            \n\n    :type ResourceCreationLimitPolicy: dict\n    :param ResourceCreationLimitPolicy: Policy that limits the number of game sessions an individual player can create over a span of time for this fleet.\n            NewGameSessionsPerCreator (integer) --Maximum number of game sessions that an individual can create during the policy period.\n            PolicyPeriodInMinutes (integer) --Time span used in evaluating the resource creation limit policy.\n            \n\n    :type MetricGroups: list\n    :param MetricGroups: Names of metric groups to add this fleet to. Use an existing metric group name to add this fleet to the group, or use a new name to create a new metric group. Currently, a fleet can only be included in one metric group at a time.\n            (string) --\n            \n\n    :rtype: dict\n    :return: {\n        'FleetAttributes': {\n            'FleetId': 'string',\n            'FleetArn': 'string',\n            'Description': 'string',\n            'Name': 'string',\n            'CreationTime': datetime(2015, 1, 1),\n            'TerminationTime': datetime(2015, 1, 1),\n            'Status': 'NEW'|'DOWNLOADING'|'VALIDATING'|'BUILDING'|'ACTIVATING'|'ACTIVE'|'DELETING'|'ERROR'|'TERMINATED',\n            'BuildId': 'string',\n            'ServerLaunchPath': 'string',\n            'ServerLaunchParameters': 'string',\n            'LogPaths': [\n                'string',\n            ],\n            'NewGameSessionProtectionPolicy': 'NoProtection'|'FullProtection',\n            'OperatingSystem': 'WINDOWS_2012'|'AMAZON_LINUX',\n            'ResourceCreationLimitPolicy': {\n                'NewGameSessionsPerCreator': 123,\n                'PolicyPeriodInMinutes': 123\n            },\n            'MetricGroups': [\n                'string',\n            ]\n        }\n    }\n    \n    \n    :returns: \n    UpdateFleetAttributes -- Update fleet metadata, including name and description.\n    UpdateFleetCapacity -- Increase or decrease the number of instances you want the fleet to maintain.\n    UpdateFleetPortSettings -- Change the IP address and port ranges that allow access to incoming traffic.\n    UpdateRuntimeConfiguration -- Change how server processes are launched in the fleet, including launch path, launch parameters, and the number of concurrent processes.\n    PutScalingPolicy -- Create or update rules that are used to set the fleet's capacity (autoscaling).\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_email(Source=None, Destination=None, Message=None, ReplyToAddresses=None, ReturnPath=None, SourceArn=None, ReturnPathArn=None, Tags=None, ConfigurationSetName=None):\n    pass", "response": "Sends an email to the specified source and destination."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting statistics for the specified metric. Amazon CloudWatch retains metric data as follows: Note that CloudWatch started retaining 5-minute and 1-hour metric data as of 9 July 2016. The maximum number of data points returned from a single call is 1,440. If you request more than 1,440 data points, Amazon CloudWatch returns an error. To reduce the number of data points, you can narrow the specified time range and make multiple requests across adjacent time ranges, or you can increase the specified period. A period can be as short as one minute (60 seconds). Note that data points are not returned in chronological order. Amazon CloudWatch aggregates data points based on the length of the period that you specify. For example, if you request statistics with a one-hour period, Amazon CloudWatch aggregates all data points with time stamps that fall within each one-hour period. Therefore, the number of values aggregated by CloudWatch is larger than the number of data points returned. CloudWatch needs raw data points to calculate percentile statistics. If you publish data using a statistic set instead, you cannot retrieve percentile statistics for this data unless one of the following conditions is true: For a list of metrics and dimensions supported by AWS services, see the Amazon CloudWatch Metrics and Dimensions Reference in the Amazon CloudWatch User Guide . See also: AWS API Documentation :example: response = client.get_metric_statistics( Namespace='string', MetricName='string', Dimensions=[ { 'Name': 'string', 'Value': 'string' }, ], StartTime=datetime(2015, 1, 1), EndTime=datetime(2015, 1, 1), Period=123, Statistics=[ 'SampleCount'|'Average'|'Sum'|'Minimum'|'Maximum', ], ExtendedStatistics=[ 'string', ], Unit='Seconds'|'Microseconds'|'Milliseconds'|'Bytes'|'Kilobytes'|'Megabytes'|'Gigabytes'|'Terabytes'|'Bits'|'Kilobits'|'Megabits'|'Gigabits'|'Terabits'|'Percent'|'Count'|'Bytes/Second'|'Kilobytes/Second'|'Megabytes/Second'|'Gigabytes/Second'|'Terabytes/Second'|'Bits/Second'|'Kilobits/Second'|'Megabits/Second'|'Gigabits/Second'|'Terabits/Second'|'Count/Second'|'None' ) :type Namespace: string :param Namespace: [REQUIRED] The namespace of the metric, with or without spaces. :type MetricName: string :param MetricName: [REQUIRED] The name of the metric, with or without spaces. :type Dimensions: list :param Dimensions: The dimensions. If the metric contains multiple dimensions, you must include a value for each dimension. CloudWatch treats each unique combination of dimensions as a separate metric. You can't retrieve statistics using combinations of dimensions that were not specially published. You must specify the same dimensions that were used when the metrics were created. For an example, see Dimension Combinations in the Amazon CloudWatch User Guide . For more information on specifying dimensions, see Publishing Metrics in the Amazon CloudWatch User Guide . (dict) --Expands the identity of a metric. Name (string) -- [REQUIRED]The name of the dimension. Value (string) -- [REQUIRED]The value representing the dimension measurement. :type StartTime: datetime :param StartTime: [REQUIRED] The time stamp that determines the first data point to return. Note that start times are evaluated relative to the time that CloudWatch receives the request. The value specified is inclusive; results include data points with the specified time stamp. The time stamp must be in ISO 8601 UTC format (for example, 2016-10-03T23:00:00Z). CloudWatch rounds the specified time stamp as follows: Start time less than 15 days ago - Round down to the nearest whole minute. For example, 12:32:34 is rounded down to 12:32:00. Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval. For example, 12:32:34 is rounded down to 12:30:00. Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval. For example, 12:32:34 is rounded down to 12:00:00. :type EndTime: datetime :param EndTime: [REQUIRED] The time stamp that determines the last data point to return. The value specified is exclusive; results will include data points up to the specified time stamp. The time stamp must be in ISO 8601 UTC format (for example, 2016-10-10T23:00:00Z). :type Period: integer :param Period: [REQUIRED] The granularity, in seconds, of the returned data points. A period can be as short as one minute (60 seconds) and must be a multiple of 60. The default value is 60. If the StartTime parameter specifies a time stamp that is greater than 15 days ago, you must specify the period as follows or no data points in that time range is returned: Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes). Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour). :type Statistics: list :param Statistics: The metric statistics, other than percentile. For percentile statistics, use ExtendedStatistic . (string) -- :type ExtendedStatistics: list :param ExtendedStatistics: The percentile statistics. Specify values between p0.0 and p100. (string) -- :type Unit: string :param Unit: The unit for a given metric. Metrics may be reported in multiple units. Not supplying a unit results in all units being returned. If the metric only ever reports one unit, specifying a unit has no effect. :rtype: dict :return: { 'Label': 'string', 'Datapoints': [ { 'Timestamp': datetime(2015, 1, 1), 'SampleCount': 123.0, 'Average': 123.0, 'Sum': 123.0, 'Minimum': 123.0, 'Maximum': 123.0, 'Unit': 'Seconds'|'Microseconds'|'Milliseconds'|'Bytes'|'Kilobytes'|'Megabytes'|'Gigabytes'|'Terabytes'|'Bits'|'Kilobits'|'Megabits'|'Gigabits'|'Terabits'|'Percent'|'Count'|'Bytes/Second'|'Kilobytes/Second'|'Megabytes/Second'|'Gigabytes/Second'|'Terabytes/Second'|'Bits/Second'|'Kilobits/Second'|'Megabits/Second'|'Gigabits/Second'|'Terabits/Second'|'Count/Second'|'None', 'ExtendedStatistics': { 'string': 123.0 } }, ] } :returns: The SampleCount of the statistic set is 1 The Min and the Max of the statistic set are equal", "response": "def get_metric_statistics(Namespace=None, MetricName=None, Dimensions=None, StartTime=None, EndTime=None, Period=None, Statistics=None, ExtendedStatistics=None, Unit=None):\n    \"\"\"\n    Gets statistics for the specified metric.\n    Amazon CloudWatch retains metric data as follows:\n    Note that CloudWatch started retaining 5-minute and 1-hour metric data as of 9 July 2016.\n    The maximum number of data points returned from a single call is 1,440. If you request more than 1,440 data points, Amazon CloudWatch returns an error. To reduce the number of data points, you can narrow the specified time range and make multiple requests across adjacent time ranges, or you can increase the specified period. A period can be as short as one minute (60 seconds). Note that data points are not returned in chronological order.\n    Amazon CloudWatch aggregates data points based on the length of the period that you specify. For example, if you request statistics with a one-hour period, Amazon CloudWatch aggregates all data points with time stamps that fall within each one-hour period. Therefore, the number of values aggregated by CloudWatch is larger than the number of data points returned.\n    CloudWatch needs raw data points to calculate percentile statistics. If you publish data using a statistic set instead, you cannot retrieve percentile statistics for this data unless one of the following conditions is true:\n    For a list of metrics and dimensions supported by AWS services, see the Amazon CloudWatch Metrics and Dimensions Reference in the Amazon CloudWatch User Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.get_metric_statistics(\n        Namespace='string',\n        MetricName='string',\n        Dimensions=[\n            {\n                'Name': 'string',\n                'Value': 'string'\n            },\n        ],\n        StartTime=datetime(2015, 1, 1),\n        EndTime=datetime(2015, 1, 1),\n        Period=123,\n        Statistics=[\n            'SampleCount'|'Average'|'Sum'|'Minimum'|'Maximum',\n        ],\n        ExtendedStatistics=[\n            'string',\n        ],\n        Unit='Seconds'|'Microseconds'|'Milliseconds'|'Bytes'|'Kilobytes'|'Megabytes'|'Gigabytes'|'Terabytes'|'Bits'|'Kilobits'|'Megabits'|'Gigabits'|'Terabits'|'Percent'|'Count'|'Bytes/Second'|'Kilobytes/Second'|'Megabytes/Second'|'Gigabytes/Second'|'Terabytes/Second'|'Bits/Second'|'Kilobits/Second'|'Megabits/Second'|'Gigabits/Second'|'Terabits/Second'|'Count/Second'|'None'\n    )\n    \n    \n    :type Namespace: string\n    :param Namespace: [REQUIRED]\n            The namespace of the metric, with or without spaces.\n            \n\n    :type MetricName: string\n    :param MetricName: [REQUIRED]\n            The name of the metric, with or without spaces.\n            \n\n    :type Dimensions: list\n    :param Dimensions: The dimensions. If the metric contains multiple dimensions, you must include a value for each dimension. CloudWatch treats each unique combination of dimensions as a separate metric. You can't retrieve statistics using combinations of dimensions that were not specially published. You must specify the same dimensions that were used when the metrics were created. For an example, see Dimension Combinations in the Amazon CloudWatch User Guide . For more information on specifying dimensions, see Publishing Metrics in the Amazon CloudWatch User Guide .\n            (dict) --Expands the identity of a metric.\n            Name (string) -- [REQUIRED]The name of the dimension.\n            Value (string) -- [REQUIRED]The value representing the dimension measurement.\n            \n            \n\n    :type StartTime: datetime\n    :param StartTime: [REQUIRED]\n            The time stamp that determines the first data point to return. Note that start times are evaluated relative to the time that CloudWatch receives the request.\n            The value specified is inclusive; results include data points with the specified time stamp. The time stamp must be in ISO 8601 UTC format (for example, 2016-10-03T23:00:00Z).\n            CloudWatch rounds the specified time stamp as follows:\n            Start time less than 15 days ago - Round down to the nearest whole minute. For example, 12:32:34 is rounded down to 12:32:00.\n            Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval. For example, 12:32:34 is rounded down to 12:30:00.\n            Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval. For example, 12:32:34 is rounded down to 12:00:00.\n            \n\n    :type EndTime: datetime\n    :param EndTime: [REQUIRED]\n            The time stamp that determines the last data point to return.\n            The value specified is exclusive; results will include data points up to the specified time stamp. The time stamp must be in ISO 8601 UTC format (for example, 2016-10-10T23:00:00Z).\n            \n\n    :type Period: integer\n    :param Period: [REQUIRED]\n            The granularity, in seconds, of the returned data points. A period can be as short as one minute (60 seconds) and must be a multiple of 60. The default value is 60.\n            If the StartTime parameter specifies a time stamp that is greater than 15 days ago, you must specify the period as follows or no data points in that time range is returned:\n            Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).\n            Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).\n            \n\n    :type Statistics: list\n    :param Statistics: The metric statistics, other than percentile. For percentile statistics, use ExtendedStatistic .\n            (string) --\n            \n\n    :type ExtendedStatistics: list\n    :param ExtendedStatistics: The percentile statistics. Specify values between p0.0 and p100.\n            (string) --\n            \n\n    :type Unit: string\n    :param Unit: The unit for a given metric. Metrics may be reported in multiple units. Not supplying a unit results in all units being returned. If the metric only ever reports one unit, specifying a unit has no effect.\n\n    :rtype: dict\n    :return: {\n        'Label': 'string',\n        'Datapoints': [\n            {\n                'Timestamp': datetime(2015, 1, 1),\n                'SampleCount': 123.0,\n                'Average': 123.0,\n                'Sum': 123.0,\n                'Minimum': 123.0,\n                'Maximum': 123.0,\n                'Unit': 'Seconds'|'Microseconds'|'Milliseconds'|'Bytes'|'Kilobytes'|'Megabytes'|'Gigabytes'|'Terabytes'|'Bits'|'Kilobits'|'Megabits'|'Gigabits'|'Terabits'|'Percent'|'Count'|'Bytes/Second'|'Kilobytes/Second'|'Megabytes/Second'|'Gigabytes/Second'|'Terabytes/Second'|'Bits/Second'|'Kilobits/Second'|'Megabits/Second'|'Gigabits/Second'|'Terabits/Second'|'Count/Second'|'None',\n                'ExtendedStatistics': {\n                    'string': 123.0\n                }\n            },\n        ]\n    }\n    \n    \n    :returns: \n    The SampleCount of the statistic set is 1\n    The Min and the Max of the statistic set are equal\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate or updates an alarm and associates it with the specified metric. Optionally, this operation can associate one or more Amazon SNS resources with the alarm. When this operation creates an alarm, the alarm state is immediately set to INSUFFICIENT_DATA . The alarm is evaluated and its state is set appropriately. Any actions associated with the state are then executed. When you update an existing alarm, its state is left unchanged, but the update completely overwrites the previous configuration of the alarm. If you are an AWS Identity and Access Management (IAM) user, you must have Amazon EC2 permissions for some operations: If you have read/write permissions for Amazon CloudWatch but not for Amazon EC2, you can still create an alarm, but the stop or terminate actions won't be performed. However, if you are later granted the required permissions, the alarm actions that you created earlier will be performed. If you are using an IAM role (for example, an Amazon EC2 instance profile), you cannot stop or terminate the instance using alarm actions. However, you can still see the alarm state and perform any other actions such as Amazon SNS notifications or Auto Scaling policies. If you are using temporary security credentials granted using the AWS Security Token Service (AWS STS), you cannot stop or terminate an Amazon EC2 instance using alarm actions. Note that you must create at least one stop, terminate, or reboot alarm using the Amazon EC2 or CloudWatch console to create the EC2ActionsAccess IAM role. After this IAM role is created, you can create stop, terminate, or reboot alarms using a command-line interface or an API. See also: AWS API Documentation :example: response = client.put_metric_alarm( AlarmName='string', AlarmDescription='string', ActionsEnabled=True|False, OKActions=[ 'string', ], AlarmActions=[ 'string', ], InsufficientDataActions=[ 'string', ], MetricName='string', Namespace='string', Statistic='SampleCount'|'Average'|'Sum'|'Minimum'|'Maximum', ExtendedStatistic='string', Dimensions=[ { 'Name': 'string', 'Value': 'string' }, ], Period=123, Unit='Seconds'|'Microseconds'|'Milliseconds'|'Bytes'|'Kilobytes'|'Megabytes'|'Gigabytes'|'Terabytes'|'Bits'|'Kilobits'|'Megabits'|'Gigabits'|'Terabits'|'Percent'|'Count'|'Bytes/Second'|'Kilobytes/Second'|'Megabytes/Second'|'Gigabytes/Second'|'Terabytes/Second'|'Bits/Second'|'Kilobits/Second'|'Megabits/Second'|'Gigabits/Second'|'Terabits/Second'|'Count/Second'|'None', EvaluationPeriods=123, Threshold=123.0, ComparisonOperator='GreaterThanOrEqualToThreshold'|'GreaterThanThreshold'|'LessThanThreshold'|'LessThanOrEqualToThreshold', TreatMissingData='string', EvaluateLowSampleCountPercentile='string' ) :type AlarmName: string :param AlarmName: [REQUIRED] The name for the alarm. This name must be unique within the AWS account. :type AlarmDescription: string :param AlarmDescription: The description for the alarm. :type ActionsEnabled: boolean :param ActionsEnabled: Indicates whether actions should be executed during any changes to the alarm state. :type OKActions: list :param OKActions: The actions to execute when this alarm transitions to an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN). Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0 (string) -- :type AlarmActions: list :param AlarmActions: The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN). Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0 (string) -- :type InsufficientDataActions: list :param InsufficientDataActions: The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN). Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0 (string) -- :type MetricName: string :param MetricName: [REQUIRED] The name for the metric associated with the alarm. :type Namespace: string :param Namespace: [REQUIRED] The namespace for the metric associated with the alarm. :type Statistic: string :param Statistic: The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic . :type ExtendedStatistic: string :param ExtendedStatistic: The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. :type Dimensions: list :param Dimensions: The dimensions for the metric associated with the alarm. (dict) --Expands the identity of a metric. Name (string) -- [REQUIRED]The name of the dimension. Value (string) -- [REQUIRED]The value representing the dimension measurement. :type Period: integer :param Period: [REQUIRED] The period, in seconds, over which the specified statistic is applied. :type Unit: string :param Unit: The unit of measure for the statistic. For example, the units for the Amazon EC2 NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance receives on all network interfaces. You can also specify a unit when you create a custom metric. Units help provide conceptual meaning to your data. Metric data points that specify a unit of measure, such as Percent, are aggregated separately. If you specify a unit, you must use a unit that is appropriate for the metric. Otherwise, the Amazon CloudWatch alarm can get stuck in the INSUFFICIENT DATA state. :type EvaluationPeriods: integer :param EvaluationPeriods: [REQUIRED] The number of periods over which data is compared to the specified threshold. :type Threshold: float :param Threshold: [REQUIRED] The value against which the specified statistic is compared. :type ComparisonOperator: string :param ComparisonOperator: [REQUIRED] The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. :type TreatMissingData: string :param TreatMissingData: Sets how this alarm is to handle missing data points. If TreatMissingData is omitted, the default behavior of missing is used. For more information, see Configuring How CloudWatch Alarms Treats Missing Data . Valid Values: breaching | notBreaching | ignore | missing :type EvaluateLowSampleCountPercentile: string :param EvaluateLowSampleCountPercentile: Used only for alarms based on percentiles. If you specify ignore , the alarm state will not change during periods with too few data points to be statistically significant. If you specify evaluate or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. For more information, see Percentile-Based CloudWatch Alarms and Low Data Samples . Valid Values: evaluate | ignore :returns: AlarmName (string) -- [REQUIRED] The name for the alarm. This name must be unique within the AWS account. AlarmDescription (string) -- The description for the alarm. ActionsEnabled (boolean) -- Indicates whether actions should be executed during any changes to the alarm state. OKActions (list) -- The actions to execute when this alarm transitions to an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN). Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0 (string) -- AlarmActions (list) -- The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN). Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0 (string) -- InsufficientDataActions (list) -- The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN). Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0 (string) -- MetricName (string) -- [REQUIRED] The name for the metric associated with the alarm. Namespace (string) -- [REQUIRED] The namespace for the metric associated with the alarm. Statistic (string) -- The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic . ExtendedStatistic (string) -- The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. Dimensions (list) -- The dimensions for the metric associated with the alarm. (dict) --Expands the identity of a metric. Name (string) -- [REQUIRED]The name of the dimension. Value (string) -- [REQUIRED]The value representing the dimension measurement. Period (integer) -- [REQUIRED] The period, in seconds, over which the specified statistic is applied. Unit (string) -- The unit of measure for the statistic. For example, the units for the Amazon EC2 NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance receives on all network interfaces. You can also specify a unit when you create a custom metric. Units help provide conceptual meaning to your data. Metric data points that specify a unit of measure, such as Percent, are aggregated separately. If you specify a unit, you must use a unit that is appropriate for the metric. Otherwise, the Amazon CloudWatch alarm can get stuck in the INSUFFICIENT DATA state. EvaluationPeriods (integer) -- [REQUIRED] The number of periods over which data is compared to the specified threshold. Threshold (float) -- [REQUIRED] The value against which the specified statistic is compared. ComparisonOperator (string) -- [REQUIRED] The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. TreatMissingData (string) -- Sets how this alarm is to handle missing data points. If TreatMissingData is omitted, the default behavior of missing is used. For more information, see Configuring How CloudWatch Alarms Treats Missing Data . Valid Values: breaching | notBreaching | ignore | missing EvaluateLowSampleCountPercentile (string) -- Used only for alarms based on percentiles. If you specify ignore , the alarm state will not change during periods with too few data points to be statistically significant. If you specify evaluate or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. For more information, see Percentile-Based CloudWatch Alarms and Low Data Samples . Valid Values: evaluate | ignore", "response": "def put_metric_alarm(AlarmName=None, AlarmDescription=None, ActionsEnabled=None, OKActions=None, AlarmActions=None, InsufficientDataActions=None, MetricName=None, Namespace=None, Statistic=None, ExtendedStatistic=None, Dimensions=None, Period=None, Unit=None, EvaluationPeriods=None, Threshold=None, ComparisonOperator=None, TreatMissingData=None, EvaluateLowSampleCountPercentile=None):\n    \"\"\"\n    Creates or updates an alarm and associates it with the specified metric. Optionally, this operation can associate one or more Amazon SNS resources with the alarm.\n    When this operation creates an alarm, the alarm state is immediately set to INSUFFICIENT_DATA . The alarm is evaluated and its state is set appropriately. Any actions associated with the state are then executed.\n    When you update an existing alarm, its state is left unchanged, but the update completely overwrites the previous configuration of the alarm.\n    If you are an AWS Identity and Access Management (IAM) user, you must have Amazon EC2 permissions for some operations:\n    If you have read/write permissions for Amazon CloudWatch but not for Amazon EC2, you can still create an alarm, but the stop or terminate actions won't be performed. However, if you are later granted the required permissions, the alarm actions that you created earlier will be performed.\n    If you are using an IAM role (for example, an Amazon EC2 instance profile), you cannot stop or terminate the instance using alarm actions. However, you can still see the alarm state and perform any other actions such as Amazon SNS notifications or Auto Scaling policies.\n    If you are using temporary security credentials granted using the AWS Security Token Service (AWS STS), you cannot stop or terminate an Amazon EC2 instance using alarm actions.\n    Note that you must create at least one stop, terminate, or reboot alarm using the Amazon EC2 or CloudWatch console to create the EC2ActionsAccess IAM role. After this IAM role is created, you can create stop, terminate, or reboot alarms using a command-line interface or an API.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.put_metric_alarm(\n        AlarmName='string',\n        AlarmDescription='string',\n        ActionsEnabled=True|False,\n        OKActions=[\n            'string',\n        ],\n        AlarmActions=[\n            'string',\n        ],\n        InsufficientDataActions=[\n            'string',\n        ],\n        MetricName='string',\n        Namespace='string',\n        Statistic='SampleCount'|'Average'|'Sum'|'Minimum'|'Maximum',\n        ExtendedStatistic='string',\n        Dimensions=[\n            {\n                'Name': 'string',\n                'Value': 'string'\n            },\n        ],\n        Period=123,\n        Unit='Seconds'|'Microseconds'|'Milliseconds'|'Bytes'|'Kilobytes'|'Megabytes'|'Gigabytes'|'Terabytes'|'Bits'|'Kilobits'|'Megabits'|'Gigabits'|'Terabits'|'Percent'|'Count'|'Bytes/Second'|'Kilobytes/Second'|'Megabytes/Second'|'Gigabytes/Second'|'Terabytes/Second'|'Bits/Second'|'Kilobits/Second'|'Megabits/Second'|'Gigabits/Second'|'Terabits/Second'|'Count/Second'|'None',\n        EvaluationPeriods=123,\n        Threshold=123.0,\n        ComparisonOperator='GreaterThanOrEqualToThreshold'|'GreaterThanThreshold'|'LessThanThreshold'|'LessThanOrEqualToThreshold',\n        TreatMissingData='string',\n        EvaluateLowSampleCountPercentile='string'\n    )\n    \n    \n    :type AlarmName: string\n    :param AlarmName: [REQUIRED]\n            The name for the alarm. This name must be unique within the AWS account.\n            \n\n    :type AlarmDescription: string\n    :param AlarmDescription: The description for the alarm.\n\n    :type ActionsEnabled: boolean\n    :param ActionsEnabled: Indicates whether actions should be executed during any changes to the alarm state.\n\n    :type OKActions: list\n    :param OKActions: The actions to execute when this alarm transitions to an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n            Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover\n            Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0\n            (string) --\n            \n\n    :type AlarmActions: list\n    :param AlarmActions: The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n            Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover\n            Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0\n            (string) --\n            \n\n    :type InsufficientDataActions: list\n    :param InsufficientDataActions: The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n            Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover\n            Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0\n            (string) --\n            \n\n    :type MetricName: string\n    :param MetricName: [REQUIRED]\n            The name for the metric associated with the alarm.\n            \n\n    :type Namespace: string\n    :param Namespace: [REQUIRED]\n            The namespace for the metric associated with the alarm.\n            \n\n    :type Statistic: string\n    :param Statistic: The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic .\n\n    :type ExtendedStatistic: string\n    :param ExtendedStatistic: The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.\n\n    :type Dimensions: list\n    :param Dimensions: The dimensions for the metric associated with the alarm.\n            (dict) --Expands the identity of a metric.\n            Name (string) -- [REQUIRED]The name of the dimension.\n            Value (string) -- [REQUIRED]The value representing the dimension measurement.\n            \n            \n\n    :type Period: integer\n    :param Period: [REQUIRED]\n            The period, in seconds, over which the specified statistic is applied.\n            \n\n    :type Unit: string\n    :param Unit: The unit of measure for the statistic. For example, the units for the Amazon EC2 NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance receives on all network interfaces. You can also specify a unit when you create a custom metric. Units help provide conceptual meaning to your data. Metric data points that specify a unit of measure, such as Percent, are aggregated separately.\n            If you specify a unit, you must use a unit that is appropriate for the metric. Otherwise, the Amazon CloudWatch alarm can get stuck in the INSUFFICIENT DATA state.\n            \n\n    :type EvaluationPeriods: integer\n    :param EvaluationPeriods: [REQUIRED]\n            The number of periods over which data is compared to the specified threshold.\n            \n\n    :type Threshold: float\n    :param Threshold: [REQUIRED]\n            The value against which the specified statistic is compared.\n            \n\n    :type ComparisonOperator: string\n    :param ComparisonOperator: [REQUIRED]\n            The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.\n            \n\n    :type TreatMissingData: string\n    :param TreatMissingData: Sets how this alarm is to handle missing data points. If TreatMissingData is omitted, the default behavior of missing is used. For more information, see Configuring How CloudWatch Alarms Treats Missing Data .\n            Valid Values: breaching | notBreaching | ignore | missing\n            \n\n    :type EvaluateLowSampleCountPercentile: string\n    :param EvaluateLowSampleCountPercentile: Used only for alarms based on percentiles. If you specify ignore , the alarm state will not change during periods with too few data points to be statistically significant. If you specify evaluate or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. For more information, see Percentile-Based CloudWatch Alarms and Low Data Samples .\n            Valid Values: evaluate | ignore\n            \n\n    :returns: \n    AlarmName (string) -- [REQUIRED]\n    The name for the alarm. This name must be unique within the AWS account.\n    \n    AlarmDescription (string) -- The description for the alarm.\n    ActionsEnabled (boolean) -- Indicates whether actions should be executed during any changes to the alarm state.\n    OKActions (list) -- The actions to execute when this alarm transitions to an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n    Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover\n    Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0\n    \n    (string) --\n    \n    \n    AlarmActions (list) -- The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n    Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover\n    Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0\n    \n    (string) --\n    \n    \n    InsufficientDataActions (list) -- The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n    Valid Values: arn:aws:automate:region :ec2:stop | arn:aws:automate:region :ec2:terminate | arn:aws:automate:region :ec2:recover\n    Valid Values (for use with IAM roles): arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Stop/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Terminate/1.0 | arn:aws:swf:us-east-1:{customer-account }:action/actions/AWS_EC2.InstanceId.Reboot/1.0\n    \n    (string) --\n    \n    \n    MetricName (string) -- [REQUIRED]\n    The name for the metric associated with the alarm.\n    \n    Namespace (string) -- [REQUIRED]\n    The namespace for the metric associated with the alarm.\n    \n    Statistic (string) -- The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic .\n    ExtendedStatistic (string) -- The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.\n    Dimensions (list) -- The dimensions for the metric associated with the alarm.\n    \n    (dict) --Expands the identity of a metric.\n    \n    Name (string) -- [REQUIRED]The name of the dimension.\n    \n    Value (string) -- [REQUIRED]The value representing the dimension measurement.\n    \n    \n    \n    \n    \n    Period (integer) -- [REQUIRED]\n    The period, in seconds, over which the specified statistic is applied.\n    \n    Unit (string) -- The unit of measure for the statistic. For example, the units for the Amazon EC2 NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance receives on all network interfaces. You can also specify a unit when you create a custom metric. Units help provide conceptual meaning to your data. Metric data points that specify a unit of measure, such as Percent, are aggregated separately.\n    If you specify a unit, you must use a unit that is appropriate for the metric. Otherwise, the Amazon CloudWatch alarm can get stuck in the INSUFFICIENT DATA state.\n    \n    EvaluationPeriods (integer) -- [REQUIRED]\n    The number of periods over which data is compared to the specified threshold.\n    \n    Threshold (float) -- [REQUIRED]\n    The value against which the specified statistic is compared.\n    \n    ComparisonOperator (string) -- [REQUIRED]\n    The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.\n    \n    TreatMissingData (string) -- Sets how this alarm is to handle missing data points. If TreatMissingData is omitted, the default behavior of missing is used. For more information, see Configuring How CloudWatch Alarms Treats Missing Data .\n    Valid Values: breaching | notBreaching | ignore | missing\n    \n    EvaluateLowSampleCountPercentile (string) -- Used only for alarms based on percentiles. If you specify ignore , the alarm state will not change during periods with too few data points to be statistically significant. If you specify evaluate or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. For more information, see Percentile-Based CloudWatch Alarms and Low Data Samples .\n    Valid Values: evaluate | ignore\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_auto_scaling_group(AutoScalingGroupName=None, LaunchConfigurationName=None, InstanceId=None, MinSize=None, MaxSize=None, DesiredCapacity=None, DefaultCooldown=None, AvailabilityZones=None, LoadBalancerNames=None, TargetGroupARNs=None, HealthCheckType=None, HealthCheckGracePeriod=None, PlacementGroup=None, VPCZoneIdentifier=None, TerminationPolicies=None, NewInstancesProtectedFromScaleIn=None, Tags=None):\n    pass", "response": "This function creates an Auto Scaling group. You can use this method to create a new Auto Scaling group. You can use the same name LaunchConfigurationName InstanceId MinSize MaxSize and AvailabilityZones."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_launch_configuration(LaunchConfigurationName=None, ImageId=None, KeyName=None, SecurityGroups=None, ClassicLinkVPCId=None, ClassicLinkVPCSecurityGroups=None, UserData=None, InstanceId=None, InstanceType=None, KernelId=None, RamdiskId=None, BlockDeviceMappings=None, InstanceMonitoring=None, SpotPrice=None, IamInstanceProfile=None, EbsOptimized=None, AssociatePublicIpAddress=None, PlacementTenancy=None):\n    pass", "response": "This function creates a new launch configuration. You can use the Launch Configurations parameter to specify the parameters for the Launch Configuration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef put_scaling_policy(AutoScalingGroupName=None, PolicyName=None, PolicyType=None, AdjustmentType=None, MinAdjustmentStep=None, MinAdjustmentMagnitude=None, ScalingAdjustment=None, Cooldown=None, MetricAggregationType=None, StepAdjustments=None, EstimatedInstanceWarmup=None):\n    pass", "response": "This function creates or updates an Auto Scaling group policy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put_scheduled_update_group_action(AutoScalingGroupName=None, ScheduledActionName=None, Time=None, StartTime=None, EndTime=None, Recurrence=None, MinSize=None, MaxSize=None, DesiredCapacity=None):\n    pass", "response": "This function creates or updates a scheduled update group action."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_auto_scaling_group(AutoScalingGroupName=None, LaunchConfigurationName=None, MinSize=None, MaxSize=None, DesiredCapacity=None, DefaultCooldown=None, AvailabilityZones=None, HealthCheckType=None, HealthCheckGracePeriod=None, PlacementGroup=None, VPCZoneIdentifier=None, TerminationPolicies=None, NewInstancesProtectedFromScaleIn=None):\n    pass", "response": "This function updates the launch configuration of an Auto Scaling group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search(cursor=None, expr=None, facet=None, filterQuery=None, highlight=None, partial=None, query=None, queryOptions=None, queryParser=None, returnFields=None, size=None, sort=None, start=None, stats=None):\n    pass", "response": "Search for documents in a domain."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clone_stack(SourceStackId=None, Name=None, Region=None, VpcId=None, Attributes=None, ServiceRoleArn=None, DefaultInstanceProfileArn=None, DefaultOs=None, HostnameTheme=None, DefaultAvailabilityZone=None, DefaultSubnetId=None, CustomJson=None, ConfigurationManager=None, ChefConfiguration=None, UseCustomCookbooks=None, UseOpsworksSecurityGroups=None, CustomCookbooksSource=None, DefaultSshKeyName=None, ClonePermissions=None, CloneAppIds=None, DefaultRootDeviceType=None, AgentVersion=None):\n    pass", "response": "Creates a clone of a stack."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_app(StackId=None, Shortname=None, Name=None, Description=None, DataSources=None, Type=None, AppSource=None, Domains=None, EnableSsl=None, SslConfiguration=None, Attributes=None, Environment=None):\n    pass", "response": "This function creates an app for a specified stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_instance(StackId=None, LayerIds=None, InstanceType=None, AutoScalingType=None, Hostname=None, Os=None, AmiId=None, SshKeyName=None, AvailabilityZone=None, VirtualizationType=None, SubnetId=None, Architecture=None, RootDeviceType=None, BlockDeviceMappings=None, InstallUpdatesOnBoot=None, EbsOptimized=None, AgentVersion=None, Tenancy=None):\n    pass", "response": "This function creates an instance in a specified stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_layer(StackId=None, Type=None, Name=None, Shortname=None, Attributes=None, CloudWatchLogsConfiguration=None, CustomInstanceProfileArn=None, CustomJson=None, CustomSecurityGroupIds=None, Packages=None, VolumeConfigurations=None, EnableAutoHealing=None, AutoAssignElasticIps=None, AutoAssignPublicIps=None, CustomRecipes=None, InstallUpdatesOnBoot=None, UseEbsOptimizedInstances=None, LifecycleEventConfiguration=None):\n    pass", "response": "Creates a new Layer in AWS Cloud Storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_stack(Name=None, Region=None, VpcId=None, Attributes=None, ServiceRoleArn=None, DefaultInstanceProfileArn=None, DefaultOs=None, HostnameTheme=None, DefaultAvailabilityZone=None, DefaultSubnetId=None, CustomJson=None, ConfigurationManager=None, ChefConfiguration=None, UseCustomCookbooks=None, UseOpsworksSecurityGroups=None, CustomCookbooksSource=None, DefaultSshKeyName=None, DefaultRootDeviceType=None, AgentVersion=None):\n    pass", "response": "Creates a new stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_app(AppId=None, Name=None, Description=None, DataSources=None, Type=None, AppSource=None, Domains=None, EnableSsl=None, SslConfiguration=None, Attributes=None, Environment=None):\n    pass", "response": "Updates a specified app.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_app(\n        AppId='string',\n        Name='string',\n        Description='string',\n        DataSources=[\n            {\n                'Type': 'string',\n                'Arn': 'string',\n                'DatabaseName': 'string'\n            },\n        ],\n        Type='aws-flow-ruby'|'java'|'rails'|'php'|'nodejs'|'static'|'other',\n        AppSource={\n            'Type': 'git'|'svn'|'archive'|'s3',\n            'Url': 'string',\n            'Username': 'string',\n            'Password': 'string',\n            'SshKey': 'string',\n            'Revision': 'string'\n        },\n        Domains=[\n            'string',\n        ],\n        EnableSsl=True|False,\n        SslConfiguration={\n            'Certificate': 'string',\n            'PrivateKey': 'string',\n            'Chain': 'string'\n        },\n        Attributes={\n            'string': 'string'\n        },\n        Environment=[\n            {\n                'Key': 'string',\n                'Value': 'string',\n                'Secure': True|False\n            },\n        ]\n    )\n    \n    \n    :type AppId: string\n    :param AppId: [REQUIRED]\n            The app ID.\n            \n\n    :type Name: string\n    :param Name: The app name.\n\n    :type Description: string\n    :param Description: A description of the app.\n\n    :type DataSources: list\n    :param DataSources: The app's data sources.\n            (dict) --Describes an app's data source.\n            Type (string) --The data source's type, AutoSelectOpsworksMysqlInstance , OpsworksMysqlInstance , or RdsDbInstance .\n            Arn (string) --The data source's ARN.\n            DatabaseName (string) --The database name.\n            \n            \n\n    :type Type: string\n    :param Type: The app type.\n\n    :type AppSource: dict\n    :param AppSource: A Source object that specifies the app repository.\n            Type (string) --The repository type.\n            Url (string) --The source URL.\n            Username (string) --This parameter depends on the repository type.\n            For Amazon S3 bundles, set Username to the appropriate IAM access key ID.\n            For HTTP bundles, Git repositories, and Subversion repositories, set Username to the user name.\n            Password (string) --When included in a request, the parameter depends on the repository type.\n            For Amazon S3 bundles, set Password to the appropriate IAM secret access key.\n            For HTTP bundles and Subversion repositories, set Password to the password.\n            For more information on how to safely handle IAM credentials, see http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html .\n            In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.\n            SshKey (string) --In requests, the repository's SSH key.\n            In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.\n            Revision (string) --The application's version. AWS OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.\n            \n\n    :type Domains: list\n    :param Domains: The app's virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com'\n            (string) --\n            \n\n    :type EnableSsl: boolean\n    :param EnableSsl: Whether SSL is enabled for the app.\n\n    :type SslConfiguration: dict\n    :param SslConfiguration: An SslConfiguration object with the SSL configuration.\n            Certificate (string) -- [REQUIRED]The contents of the certificate's domain.crt file.\n            PrivateKey (string) -- [REQUIRED]The private key; the contents of the certificate's domain.kex file.\n            Chain (string) --Optional. Can be used to specify an intermediate certificate authority key or client authentication.\n            \n\n    :type Attributes: dict\n    :param Attributes: One or more user-defined key/value pairs to be added to the stack attributes.\n            (string) --\n            (string) --\n            \n\n    :type Environment: list\n    :param Environment: An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances.For more information, see Environment Variables .\n            There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 10 KB (10240 Bytes). This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, 'Environment: is too large (maximum is 10KB).'\n            Note\n            This parameter is supported only by Chef 11.10 stacks. If you have specified one or more environment variables, you cannot modify the stack's Chef version.\n            (dict) --Represents an app's environment variable.\n            Key (string) -- [REQUIRED](Required) The environment variable's name, which can consist of up to 64 characters and must be specified. The name can contain upper- and lowercase letters, numbers, and underscores (_), but it must start with a letter or underscore.\n            Value (string) -- [REQUIRED](Optional) The environment variable's value, which can be left empty. If you specify a value, it can contain up to 256 characters, which must all be printable.\n            Secure (boolean) --(Optional) Whether the variable's value will be returned by the DescribeApps action. To conceal an environment variable's value, set Secure to true . DescribeApps then returns *****FILTERED***** instead of the actual value. The default value for Secure is false ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_instance(InstanceId=None, LayerIds=None, InstanceType=None, AutoScalingType=None, Hostname=None, Os=None, AmiId=None, SshKeyName=None, Architecture=None, InstallUpdatesOnBoot=None, EbsOptimized=None, AgentVersion=None):\n    pass", "response": "Updates a specified instance.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_instance(\n        InstanceId='string',\n        LayerIds=[\n            'string',\n        ],\n        InstanceType='string',\n        AutoScalingType='load'|'timer',\n        Hostname='string',\n        Os='string',\n        AmiId='string',\n        SshKeyName='string',\n        Architecture='x86_64'|'i386',\n        InstallUpdatesOnBoot=True|False,\n        EbsOptimized=True|False,\n        AgentVersion='string'\n    )\n    \n    \n    :type InstanceId: string\n    :param InstanceId: [REQUIRED]\n            The instance ID.\n            \n\n    :type LayerIds: list\n    :param LayerIds: The instance's layer IDs.\n            (string) --\n            \n\n    :type InstanceType: string\n    :param InstanceType: The instance type, such as t2.micro . For a list of supported instance types, open the stack in the console, choose Instances , and choose + Instance . The Size list contains the currently supported types. For more information, see Instance Families and Types . The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.\n\n    :type AutoScalingType: string\n    :param AutoScalingType: For load-based or time-based instances, the type. Windows stacks can use only time-based instances.\n\n    :type Hostname: string\n    :param Hostname: The instance host name.\n\n    :type Os: string\n    :param Os: The instance's operating system, which must be set to one of the following. You cannot update an instance that is using a custom AMI.\n            A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.09 , Amazon Linux 2016.03 , Amazon Linux 2015.09 , or Amazon Linux 2015.03 .\n            A supported Ubuntu operating system, such as Ubuntu 16.04 LTS , Ubuntu 14.04 LTS , or Ubuntu 12.04 LTS .\n            CentOS Linux 7\n            Red Hat Enterprise Linux 7\n            A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base , Microsoft Windows Server 2012 R2 with SQL Server Express , Microsoft Windows Server 2012 R2 with SQL Server Standard , or Microsoft Windows Server 2012 R2 with SQL Server Web .\n            For more information on the supported operating systems, see AWS OpsWorks Stacks Operating Systems .\n            The default option is the current Amazon Linux version. If you set this parameter to Custom , you must use the AmiId parameter to specify the custom AMI that you want to use. For more information on the supported operating systems, see Operating Systems . For more information on how to use custom AMIs with OpsWorks, see Using Custom AMIs .\n            Note\n            You can specify a different Linux operating system for the updated stack, but you cannot change from Linux to Windows or Windows to Linux.\n            \n\n    :type AmiId: string\n    :param AmiId: The ID of the AMI that was used to create the instance. The value of this parameter must be the same AMI ID that the instance is already using. You cannot apply a new AMI to an instance by running UpdateInstance. UpdateInstance does not work on instances that are using custom AMIs.\n\n    :type SshKeyName: string\n    :param SshKeyName: The instance's Amazon EC2 key name.\n\n    :type Architecture: string\n    :param Architecture: The instance architecture. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see Instance Families and Types .\n\n    :type InstallUpdatesOnBoot: boolean\n    :param InstallUpdatesOnBoot: Whether to install operating system and package updates when the instance boots. The default value is true . To control when updates are installed, set this value to false . You must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.\n            Note\n            We strongly recommend using the default value of true , to ensure that your instances have the latest security updates.\n            \n\n    :type EbsOptimized: boolean\n    :param EbsOptimized: This property cannot be updated.\n\n    :type AgentVersion: string\n    :param AgentVersion: The default AWS OpsWorks Stacks agent version. You have the following options:\n            INHERIT - Use the stack's default agent version setting.\n            version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, you must edit the instance configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the instance.\n            The default setting is INHERIT . To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions .\n            AgentVersion cannot be set to Chef 12.2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating an existing Amazon SageMaker layer.", "response": "def update_layer(LayerId=None, Name=None, Shortname=None, Attributes=None, CloudWatchLogsConfiguration=None, CustomInstanceProfileArn=None, CustomJson=None, CustomSecurityGroupIds=None, Packages=None, VolumeConfigurations=None, EnableAutoHealing=None, AutoAssignElasticIps=None, AutoAssignPublicIps=None, CustomRecipes=None, InstallUpdatesOnBoot=None, UseEbsOptimizedInstances=None, LifecycleEventConfiguration=None):\n    \"\"\"\n    Updates a specified layer.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_layer(\n        LayerId='string',\n        Name='string',\n        Shortname='string',\n        Attributes={\n            'string': 'string'\n        },\n        CloudWatchLogsConfiguration={\n            'Enabled': True|False,\n            'LogStreams': [\n                {\n                    'LogGroupName': 'string',\n                    'DatetimeFormat': 'string',\n                    'TimeZone': 'LOCAL'|'UTC',\n                    'File': 'string',\n                    'FileFingerprintLines': 'string',\n                    'MultiLineStartPattern': 'string',\n                    'InitialPosition': 'start_of_file'|'end_of_file',\n                    'Encoding': 'ascii'|'big5'|'big5hkscs'|'cp037'|'cp424'|'cp437'|'cp500'|'cp720'|'cp737'|'cp775'|'cp850'|'cp852'|'cp855'|'cp856'|'cp857'|'cp858'|'cp860'|'cp861'|'cp862'|'cp863'|'cp864'|'cp865'|'cp866'|'cp869'|'cp874'|'cp875'|'cp932'|'cp949'|'cp950'|'cp1006'|'cp1026'|'cp1140'|'cp1250'|'cp1251'|'cp1252'|'cp1253'|'cp1254'|'cp1255'|'cp1256'|'cp1257'|'cp1258'|'euc_jp'|'euc_jis_2004'|'euc_jisx0213'|'euc_kr'|'gb2312'|'gbk'|'gb18030'|'hz'|'iso2022_jp'|'iso2022_jp_1'|'iso2022_jp_2'|'iso2022_jp_2004'|'iso2022_jp_3'|'iso2022_jp_ext'|'iso2022_kr'|'latin_1'|'iso8859_2'|'iso8859_3'|'iso8859_4'|'iso8859_5'|'iso8859_6'|'iso8859_7'|'iso8859_8'|'iso8859_9'|'iso8859_10'|'iso8859_13'|'iso8859_14'|'iso8859_15'|'iso8859_16'|'johab'|'koi8_r'|'koi8_u'|'mac_cyrillic'|'mac_greek'|'mac_iceland'|'mac_latin2'|'mac_roman'|'mac_turkish'|'ptcp154'|'shift_jis'|'shift_jis_2004'|'shift_jisx0213'|'utf_32'|'utf_32_be'|'utf_32_le'|'utf_16'|'utf_16_be'|'utf_16_le'|'utf_7'|'utf_8'|'utf_8_sig',\n                    'BufferDuration': 123,\n                    'BatchCount': 123,\n                    'BatchSize': 123\n                },\n            ]\n        },\n        CustomInstanceProfileArn='string',\n        CustomJson='string',\n        CustomSecurityGroupIds=[\n            'string',\n        ],\n        Packages=[\n            'string',\n        ],\n        VolumeConfigurations=[\n            {\n                'MountPoint': 'string',\n                'RaidLevel': 123,\n                'NumberOfDisks': 123,\n                'Size': 123,\n                'VolumeType': 'string',\n                'Iops': 123\n            },\n        ],\n        EnableAutoHealing=True|False,\n        AutoAssignElasticIps=True|False,\n        AutoAssignPublicIps=True|False,\n        CustomRecipes={\n            'Setup': [\n                'string',\n            ],\n            'Configure': [\n                'string',\n            ],\n            'Deploy': [\n                'string',\n            ],\n            'Undeploy': [\n                'string',\n            ],\n            'Shutdown': [\n                'string',\n            ]\n        },\n        InstallUpdatesOnBoot=True|False,\n        UseEbsOptimizedInstances=True|False,\n        LifecycleEventConfiguration={\n            'Shutdown': {\n                'ExecutionTimeout': 123,\n                'DelayUntilElbConnectionsDrained': True|False\n            }\n        }\n    )\n    \n    \n    :type LayerId: string\n    :param LayerId: [REQUIRED]\n            The layer ID.\n            \n\n    :type Name: string\n    :param Name: The layer name, which is used by the console.\n\n    :type Shortname: string\n    :param Shortname: For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters and must be in the following format: /A[a-z0-9-_.]+Z/.\n            The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the Layer Reference\n            \n\n    :type Attributes: dict\n    :param Attributes: One or more user-defined key/value pairs to be added to the stack attributes.\n            (string) --\n            (string) --\n            \n\n    :type CloudWatchLogsConfiguration: dict\n    :param CloudWatchLogsConfiguration: Specifies CloudWatch Logs configuration options for the layer. For more information, see CloudWatchLogsLogStream .\n            Enabled (boolean) --Whether CloudWatch Logs is enabled for a layer.\n            LogStreams (list) --A list of configuration options for CloudWatch Logs.\n            (dict) --Describes the Amazon CloudWatch logs configuration for a layer. For detailed information about members of this data type, see the CloudWatch Logs Agent Reference .\n            LogGroupName (string) --Specifies the destination log group. A log group is created automatically if it doesn't already exist. Log group names can be between 1 and 512 characters long. Allowed characters include a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), '/' (forward slash), and '.' (period).\n            DatetimeFormat (string) --Specifies how the time stamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference .\n            TimeZone (string) --Specifies the time zone of log event time stamps.\n            File (string) --Specifies log files that you want to push to CloudWatch Logs.\n            File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log* ). Only the latest file is pushed to CloudWatch Logs, based on file modification time. We recommend that you use wild card characters to specify a series of files of the same type, such as access_log.2014-06-01-01 , access_log.2014-06-01-02 , and so on by using a pattern like access_log.* . Don't use a wildcard to match multiple file types, such as access_log_80 and access_log_443 . To specify multiple, different file types, add another log stream entry to the configuration file, so that each log file type is stored in a different log group.\n            Zipped files are not supported.\n            FileFingerprintLines (string) --Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as '1', '2-5'. The default value is '1', meaning the first line is used to calculate the fingerprint. Fingerprint lines are not sent to CloudWatch Logs unless all specified lines are available.\n            MultiLineStartPattern (string) --Specifies the pattern for identifying the start of a log message.\n            InitialPosition (string) --Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. This setting is only used if there is no state persisted for that log stream.\n            Encoding (string) --Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8 . Encodings supported by Python codecs.decode() can be used here.\n            BufferDuration (integer) --Specifies the time duration for the batching of log events. The minimum value is 5000ms and default value is 5000ms.\n            BatchCount (integer) --Specifies the max number of log events in a batch, up to 10000. The default value is 1000.\n            BatchSize (integer) --Specifies the maximum size of log events in a batch, in bytes, up to 1048576 bytes. The default value is 32768 bytes. This size is calculated as the sum of all event messages in UTF-8, plus 26 bytes for each log event.\n            \n            \n\n    :type CustomInstanceProfileArn: string\n    :param CustomInstanceProfileArn: The ARN of an IAM profile to be used for all of the layer's EC2 instances. For more information about IAM ARNs, see Using Identifiers .\n\n    :type CustomJson: string\n    :param CustomJson: A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see Using Custom JSON .\n\n    :type CustomSecurityGroupIds: list\n    :param CustomSecurityGroupIds: An array containing the layer's custom security group IDs.\n            (string) --\n            \n\n    :type Packages: list\n    :param Packages: An array of Package objects that describe the layer's packages.\n            (string) --\n            \n\n    :type VolumeConfigurations: list\n    :param VolumeConfigurations: A VolumeConfigurations object that describes the layer's Amazon EBS volumes.\n            (dict) --Describes an Amazon EBS volume configuration.\n            MountPoint (string) -- [REQUIRED]The volume mount point. For example '/dev/sdh'.\n            RaidLevel (integer) --The volume RAID level .\n            NumberOfDisks (integer) -- [REQUIRED]The number of disks in the volume.\n            Size (integer) -- [REQUIRED]The volume size.\n            VolumeType (string) --The volume type:\n            standard - Magnetic\n            io1 - Provisioned IOPS (SSD)\n            gp2 - General Purpose (SSD)\n            Iops (integer) --For PIOPS volumes, the IOPS per disk.\n            \n            \n\n    :type EnableAutoHealing: boolean\n    :param EnableAutoHealing: Whether to disable auto healing for the layer.\n\n    :type AutoAssignElasticIps: boolean\n    :param AutoAssignElasticIps: Whether to automatically assign an Elastic IP address to the layer's instances. For more information, see How to Edit a Layer .\n\n    :type AutoAssignPublicIps: boolean\n    :param AutoAssignPublicIps: For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see How to Edit a Layer .\n\n    :type CustomRecipes: dict\n    :param CustomRecipes: A LayerCustomRecipes object that specifies the layer's custom recipes.\n            Setup (list) --An array of custom recipe names to be run following a setup event.\n            (string) --\n            Configure (list) --An array of custom recipe names to be run following a configure event.\n            (string) --\n            Deploy (list) --An array of custom recipe names to be run following a deploy event.\n            (string) --\n            Undeploy (list) --An array of custom recipe names to be run following a undeploy event.\n            (string) --\n            Shutdown (list) --An array of custom recipe names to be run following a shutdown event.\n            (string) --\n            \n\n    :type InstallUpdatesOnBoot: boolean\n    :param InstallUpdatesOnBoot: Whether to install operating system and package updates when the instance boots. The default value is true . To control when updates are installed, set this value to false . You must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.\n            Note\n            We strongly recommend using the default value of true , to ensure that your instances have the latest security updates.\n            \n\n    :type UseEbsOptimizedInstances: boolean\n    :param UseEbsOptimizedInstances: Whether to use Amazon EBS-optimized instances.\n\n    :type LifecycleEventConfiguration: dict\n    :param LifecycleEventConfiguration: \n            Shutdown (dict) --A ShutdownEventConfiguration object that specifies the Shutdown event configuration.\n            ExecutionTimeout (integer) --The time, in seconds, that AWS OpsWorks Stacks will wait after triggering a Shutdown event before shutting down an instance.\n            DelayUntilElbConnectionsDrained (boolean) --Whether to enable Elastic Load Balancing connection draining. For more information, see Connection Draining\n            \n            \n\n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates a specified stack. See also: AWS API Documentation :example: response = client.update_stack( StackId='string', Name='string', Attributes={ 'string': 'string' }, ServiceRoleArn='string', DefaultInstanceProfileArn='string', DefaultOs='string', HostnameTheme='string', DefaultAvailabilityZone='string', DefaultSubnetId='string', CustomJson='string', ConfigurationManager={ 'Name': 'string', 'Version': 'string' }, ChefConfiguration={ 'ManageBerkshelf': True|False, 'BerkshelfVersion': 'string' }, UseCustomCookbooks=True|False, CustomCookbooksSource={ 'Type': 'git'|'svn'|'archive'|'s3', 'Url': 'string', 'Username': 'string', 'Password': 'string', 'SshKey': 'string', 'Revision': 'string' }, DefaultSshKeyName='string', DefaultRootDeviceType='ebs'|'instance-store', UseOpsworksSecurityGroups=True|False, AgentVersion='string' ) :type StackId: string :param StackId: [REQUIRED] The stack ID. :type Name: string :param Name: The stack's new name. :type Attributes: dict :param Attributes: One or more user-defined key-value pairs to be added to the stack attributes. (string) -- (string) -- :type ServiceRoleArn: string :param ServiceRoleArn: Do not use this parameter. You cannot update a stack's service role. :type DefaultInstanceProfileArn: string :param DefaultInstanceProfileArn: The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see Using Identifiers . :type DefaultOs: string :param DefaultOs: The stack's operating system, which must be set to one of the following: A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.09 , Amazon Linux 2016.03 , Amazon Linux 2015.09 , or Amazon Linux 2015.03 . A supported Ubuntu operating system, such as Ubuntu 16.04 LTS , Ubuntu 14.04 LTS , or Ubuntu 12.04 LTS . CentOS Linux 7 Red Hat Enterprise Linux 7 A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base , Microsoft Windows Server 2012 R2 with SQL Server Express , Microsoft Windows Server 2012 R2 with SQL Server Standard , or Microsoft Windows Server 2012 R2 with SQL Server Web . A custom AMI: Custom . You specify the custom AMI you want to use when you create instances. For more information on how to use custom AMIs with OpsWorks, see Using Custom AMIs . The default option is the stack's current operating system. For more information on the supported operating systems, see AWS OpsWorks Stacks Operating Systems . :type HostnameTheme: string :param HostnameTheme: The stack's new host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent , which creates host names by appending integers to the layer's short name. The other themes are: Baked_Goods Clouds Europe_Cities Fruits Greek_Deities Legendary_creatures_from_Japan Planets_and_Moons Roman_Deities Scottish_Islands US_Cities Wild_Cats To obtain a generated host name, call GetHostNameSuggestion , which returns a host name based on the current theme. :type DefaultAvailabilityZone: string :param DefaultAvailabilityZone: The stack's default Availability Zone, which must be in the stack's region. For more information, see Regions and Endpoints . If you also specify a value for DefaultSubnetId , the subnet must be in the same zone. For more information, see CreateStack . :type DefaultSubnetId: string :param DefaultSubnetId: The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone , the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description. :type CustomJson: string :param CustomJson: A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format: '{\\'key1\\': \\'value1\\', \\'key2\\': \\'value2\\',...}' For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes . :type ConfigurationManager: dict :param ConfigurationManager: The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 11.4. Name (string) --The name. This parameter must be set to 'Chef'. Version (string) --The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 11.4. :type ChefConfiguration: dict :param ChefConfiguration: A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see Create a New Stack . ManageBerkshelf (boolean) --Whether to enable Berkshelf. BerkshelfVersion (string) --The Berkshelf version. :type UseCustomCookbooks: boolean :param UseCustomCookbooks: Whether the stack uses custom cookbooks. :type CustomCookbooksSource: dict :param CustomCookbooksSource: Contains the information required to retrieve an app or cookbook from a repository. For more information, see Creating Apps or Custom Recipes and Cookbooks . Type (string) --The repository type. Url (string) --The source URL. Username (string) --This parameter depends on the repository type. For Amazon S3 bundles, set Username to the appropriate IAM access key ID. For HTTP bundles, Git repositories, and Subversion repositories, set Username to the user name. Password (string) --When included in a request, the parameter depends on the repository type. For Amazon S3 bundles, set Password to the appropriate IAM secret access key. For HTTP bundles and Subversion repositories, set Password to the password. For more information on how to safely handle IAM credentials, see http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html . In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value. SshKey (string) --In requests, the repository's SSH key. In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value. Revision (string) --The application's version. AWS OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed. :type DefaultSshKeyName: string :param DefaultSshKeyName: A default Amazon EC2 key-pair name. The default value is none . If you specify a key-pair name, AWS OpsWorks Stacks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see Using SSH to Communicate with an Instance and Managing SSH Access . You can override this setting by specifying a different key pair, or no key pair, when you create an instance . :type DefaultRootDeviceType: string :param DefaultRootDeviceType: The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see Storage for the Root Device . :type UseOpsworksSecurityGroups: boolean :param UseOpsworksSecurityGroups: Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers. AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. UseOpsworksSecurityGroups allows you to provide your own custom security groups instead of using the built-in groups. UseOpsworksSecurityGroups has the following settings: True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group. False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings. For more information, see Create a New Stack . :type AgentVersion: string :param AgentVersion: The default AWS OpsWorks Stacks agent version. You have the following options: Auto-update - Set this parameter to LATEST . AWS OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available. Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances. The default setting is LATEST . To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions . AgentVersion cannot be set to Chef 12.2. Note You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.", "response": "def update_stack(StackId=None, Name=None, Attributes=None, ServiceRoleArn=None, DefaultInstanceProfileArn=None, DefaultOs=None, HostnameTheme=None, DefaultAvailabilityZone=None, DefaultSubnetId=None, CustomJson=None, ConfigurationManager=None, ChefConfiguration=None, UseCustomCookbooks=None, CustomCookbooksSource=None, DefaultSshKeyName=None, DefaultRootDeviceType=None, UseOpsworksSecurityGroups=None, AgentVersion=None):\n    \"\"\"\n    Updates a specified stack.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_stack(\n        StackId='string',\n        Name='string',\n        Attributes={\n            'string': 'string'\n        },\n        ServiceRoleArn='string',\n        DefaultInstanceProfileArn='string',\n        DefaultOs='string',\n        HostnameTheme='string',\n        DefaultAvailabilityZone='string',\n        DefaultSubnetId='string',\n        CustomJson='string',\n        ConfigurationManager={\n            'Name': 'string',\n            'Version': 'string'\n        },\n        ChefConfiguration={\n            'ManageBerkshelf': True|False,\n            'BerkshelfVersion': 'string'\n        },\n        UseCustomCookbooks=True|False,\n        CustomCookbooksSource={\n            'Type': 'git'|'svn'|'archive'|'s3',\n            'Url': 'string',\n            'Username': 'string',\n            'Password': 'string',\n            'SshKey': 'string',\n            'Revision': 'string'\n        },\n        DefaultSshKeyName='string',\n        DefaultRootDeviceType='ebs'|'instance-store',\n        UseOpsworksSecurityGroups=True|False,\n        AgentVersion='string'\n    )\n    \n    \n    :type StackId: string\n    :param StackId: [REQUIRED]\n            The stack ID.\n            \n\n    :type Name: string\n    :param Name: The stack's new name.\n\n    :type Attributes: dict\n    :param Attributes: One or more user-defined key-value pairs to be added to the stack attributes.\n            (string) --\n            (string) --\n            \n\n    :type ServiceRoleArn: string\n    :param ServiceRoleArn: Do not use this parameter. You cannot update a stack's service role.\n\n    :type DefaultInstanceProfileArn: string\n    :param DefaultInstanceProfileArn: The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see Using Identifiers .\n\n    :type DefaultOs: string\n    :param DefaultOs: The stack's operating system, which must be set to one of the following:\n            A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.09 , Amazon Linux 2016.03 , Amazon Linux 2015.09 , or Amazon Linux 2015.03 .\n            A supported Ubuntu operating system, such as Ubuntu 16.04 LTS , Ubuntu 14.04 LTS , or Ubuntu 12.04 LTS .\n            CentOS Linux 7\n            Red Hat Enterprise Linux 7\n            A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base , Microsoft Windows Server 2012 R2 with SQL Server Express , Microsoft Windows Server 2012 R2 with SQL Server Standard , or Microsoft Windows Server 2012 R2 with SQL Server Web .\n            A custom AMI: Custom . You specify the custom AMI you want to use when you create instances. For more information on how to use custom AMIs with OpsWorks, see Using Custom AMIs .\n            The default option is the stack's current operating system. For more information on the supported operating systems, see AWS OpsWorks Stacks Operating Systems .\n            \n\n    :type HostnameTheme: string\n    :param HostnameTheme: The stack's new host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent , which creates host names by appending integers to the layer's short name. The other themes are:\n            Baked_Goods\n            Clouds\n            Europe_Cities\n            Fruits\n            Greek_Deities\n            Legendary_creatures_from_Japan\n            Planets_and_Moons\n            Roman_Deities\n            Scottish_Islands\n            US_Cities\n            Wild_Cats\n            To obtain a generated host name, call GetHostNameSuggestion , which returns a host name based on the current theme.\n            \n\n    :type DefaultAvailabilityZone: string\n    :param DefaultAvailabilityZone: The stack's default Availability Zone, which must be in the stack's region. For more information, see Regions and Endpoints . If you also specify a value for DefaultSubnetId , the subnet must be in the same zone. For more information, see CreateStack .\n\n    :type DefaultSubnetId: string\n    :param DefaultSubnetId: The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone , the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.\n\n    :type CustomJson: string\n    :param CustomJson: A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format:\n            '{\\'key1\\': \\'value1\\', \\'key2\\': \\'value2\\',...}'\n            For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes .\n            \n\n    :type ConfigurationManager: dict\n    :param ConfigurationManager: The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 11.4.\n            Name (string) --The name. This parameter must be set to 'Chef'.\n            Version (string) --The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 11.4.\n            \n\n    :type ChefConfiguration: dict\n    :param ChefConfiguration: A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see Create a New Stack .\n            ManageBerkshelf (boolean) --Whether to enable Berkshelf.\n            BerkshelfVersion (string) --The Berkshelf version.\n            \n\n    :type UseCustomCookbooks: boolean\n    :param UseCustomCookbooks: Whether the stack uses custom cookbooks.\n\n    :type CustomCookbooksSource: dict\n    :param CustomCookbooksSource: Contains the information required to retrieve an app or cookbook from a repository. For more information, see Creating Apps or Custom Recipes and Cookbooks .\n            Type (string) --The repository type.\n            Url (string) --The source URL.\n            Username (string) --This parameter depends on the repository type.\n            For Amazon S3 bundles, set Username to the appropriate IAM access key ID.\n            For HTTP bundles, Git repositories, and Subversion repositories, set Username to the user name.\n            Password (string) --When included in a request, the parameter depends on the repository type.\n            For Amazon S3 bundles, set Password to the appropriate IAM secret access key.\n            For HTTP bundles and Subversion repositories, set Password to the password.\n            For more information on how to safely handle IAM credentials, see http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html .\n            In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.\n            SshKey (string) --In requests, the repository's SSH key.\n            In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.\n            Revision (string) --The application's version. AWS OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.\n            \n\n    :type DefaultSshKeyName: string\n    :param DefaultSshKeyName: A default Amazon EC2 key-pair name. The default value is none . If you specify a key-pair name, AWS OpsWorks Stacks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see Using SSH to Communicate with an Instance and Managing SSH Access . You can override this setting by specifying a different key pair, or no key pair, when you create an instance .\n\n    :type DefaultRootDeviceType: string\n    :param DefaultRootDeviceType: The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see Storage for the Root Device .\n\n    :type UseOpsworksSecurityGroups: boolean\n    :param UseOpsworksSecurityGroups: Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.\n            AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. UseOpsworksSecurityGroups allows you to provide your own custom security groups instead of using the built-in groups. UseOpsworksSecurityGroups has the following settings:\n            True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.\n            False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings.\n            For more information, see Create a New Stack .\n            \n\n    :type AgentVersion: string\n    :param AgentVersion: The default AWS OpsWorks Stacks agent version. You have the following options:\n            Auto-update - Set this parameter to LATEST . AWS OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.\n            Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.\n            The default setting is LATEST . To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions . AgentVersion cannot be set to Chef 12.2.\n            Note\n            You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.\n            \n\n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_project(name=None, description=None, source=None, artifacts=None, environment=None, serviceRole=None, timeoutInMinutes=None, encryptionKey=None, tags=None):\n    pass", "response": "Creates a build project."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates or updates an existing conversational bot.", "response": "def put_bot(name=None, description=None, intents=None, clarificationPrompt=None, abortStatement=None, idleSessionTTLInSeconds=None, voiceId=None, checksum=None, processBehavior=None, locale=None, childDirected=None):\n    \"\"\"\n    Creates an Amazon Lex conversational bot or replaces an existing bot. When you create or update a bot you only required to specify a name. You can use this to add intents later, or to remove intents from an existing bot. When you create a bot with a name only, the bot is created or updated but Amazon Lex returns the ```` response FAILED . You can build the bot after you add one or more intents. For more information about Amazon Lex bots, see  how-it-works .\n    If you specify the name of an existing bot, the fields in the request replace the existing values in the $LATEST version of the bot. Amazon Lex removes any fields that you don't provide values for in the request, except for the idleTTLInSeconds and privacySettings fields, which are set to their default values. If you don't specify values for required fields, Amazon Lex throws an exception.\n    This operation requires permissions for the lex:PutBot action. For more information, see  auth-and-access-control .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.put_bot(\n        name='string',\n        description='string',\n        intents=[\n            {\n                'intentName': 'string',\n                'intentVersion': 'string'\n            },\n        ],\n        clarificationPrompt={\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'maxAttempts': 123,\n            'responseCard': 'string'\n        },\n        abortStatement={\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'responseCard': 'string'\n        },\n        idleSessionTTLInSeconds=123,\n        voiceId='string',\n        checksum='string',\n        processBehavior='SAVE'|'BUILD',\n        locale='en-US',\n        childDirected=True|False\n    )\n    \n    \n    :type name: string\n    :param name: [REQUIRED]\n            The name of the bot. The name is not case sensitive.\n            \n\n    :type description: string\n    :param description: A description of the bot.\n\n    :type intents: list\n    :param intents: An array of Intent objects. Each intent represents a command that a user can express. For example, a pizza ordering bot might support an OrderPizza intent. For more information, see how-it-works .\n            (dict) --Identifies the specific version of an intent.\n            intentName (string) -- [REQUIRED]The name of the intent.\n            intentVersion (string) -- [REQUIRED]The version of the intent.\n            \n            \n\n    :type clarificationPrompt: dict\n    :param clarificationPrompt: When Amazon Lex doesn't understand the user's intent, it uses one of these messages to get clarification. For example, 'Sorry, I didn't understand. Please repeat.' Amazon Lex repeats the clarification prompt the number of times specified in maxAttempts . If Amazon Lex still can't understand, it sends the message specified in abortStatement .\n            messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML).\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information.\n            responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card .\n            \n\n    :type abortStatement: dict\n    :param abortStatement: When Amazon Lex can't understand the user's input in context, it tries to elicit the information a few times. After that, Amazon Lex sends the message defined in abortStatement to the user, and then aborts the conversation. To set the number of retries, use the valueElicitationPrompt field for the slot type.\n            For example, in a pizza ordering bot, Amazon Lex might ask a user 'What type of crust would you like?' If the user's response is not one of the expected responses (for example, 'thin crust, 'deep dish,' etc.), Amazon Lex tries to elicit a correct response a few more times.\n            For example, in a pizza ordering application, OrderPizza might be one of the intents. This intent might require the CrustType slot. You specify the valueElicitationPrompt field when you create the CrustType slot.\n            messages (list) -- [REQUIRED]A collection of message objects.\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card.\n            \n\n    :type idleSessionTTLInSeconds: integer\n    :param idleSessionTTLInSeconds: The maximum time in seconds that Amazon Lex retains the data gathered in a conversation.\n            A user interaction session remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout.\n            For example, suppose that a user chooses the OrderPizza intent, but gets sidetracked halfway through placing an order. If the user doesn't complete the order within the specified time, Amazon Lex discards the slot information that it gathered, and the user must start over.\n            If you don't include the idleSessionTTLInSeconds element in a PutBot operation request, Amazon Lex uses the default value. This is also true if the request replaces an existing bot.\n            The default is 300 seconds (5 minutes).\n            \n\n    :type voiceId: string\n    :param voiceId: The Amazon Polly voice ID that you want Amazon Lex to use for voice interactions with the user. The locale configured for the voice must match the locale of the bot. For more information, see Voice in the Amazon Polly Developer Guide .\n\n    :type checksum: string\n    :param checksum: Identifies a specific revision of the $LATEST version.\n            When you create a new bot, leave the checksum field blank. If you specify a checksum you get a BadRequestException exception.\n            When you want to update a bot, set the checksum field to the checksum of the most recent revision of the $LATEST version. If you don't specify the checksum field, or if the checksum does not match the $LATEST version, you get a PreconditionFailedException exception.\n            \n\n    :type processBehavior: string\n    :param processBehavior: If you set the processBehavior element to Build , Amazon Lex builds the bot so that it can be run. If you set the element to Save Amazon Lex saves the bot, but doesn't build it.\n            If you don't specify this value, the default value is Save .\n            \n\n    :type locale: string\n    :param locale: [REQUIRED]\n            Specifies the target locale for the bot. Any intent used in the bot must be compatible with the locale of the bot.\n            The default is en-US .\n            \n\n    :type childDirected: boolean\n    :param childDirected: [REQUIRED]\n            For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying true or false in the childDirected field. By specifying true in the childDirected field, you confirm that your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying false in the childDirected field, you confirm that your use of Amazon Lex is not related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the childDirected field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA.\n            If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the Amazon Lex FAQ.\n            \n\n    :rtype: dict\n    :return: {\n        'name': 'string',\n        'description': 'string',\n        'intents': [\n            {\n                'intentName': 'string',\n                'intentVersion': 'string'\n            },\n        ],\n        'clarificationPrompt': {\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'maxAttempts': 123,\n            'responseCard': 'string'\n        },\n        'abortStatement': {\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'responseCard': 'string'\n        },\n        'status': 'BUILDING'|'READY'|'FAILED'|'NOT_BUILT',\n        'failureReason': 'string',\n        'lastUpdatedDate': datetime(2015, 1, 1),\n        'createdDate': datetime(2015, 1, 1),\n        'idleSessionTTLInSeconds': 123,\n        'voiceId': 'string',\n        'checksum': 'string',\n        'version': 'string',\n        'locale': 'en-US',\n        'childDirected': True|False\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an intent or replaces an existing intent. To define the interaction between the user and your bot, you use one or more intents. For a pizza ordering bot, for example, you would create an OrderPizza intent. To create an intent or replace an existing intent, you must provide the following: You can specify other optional information in the request, such as: If you specify an existing intent name to update the intent, Amazon Lex replaces the values in the $LATEST version of the slot type with the values in the request. Amazon Lex removes fields that you don't provide in the request. If you don't specify the required fields, Amazon Lex throws an exception. For more information, see how-it-works . This operation requires permissions for the lex:PutIntent action. See also: AWS API Documentation :example: response = client.put_intent( name='string', description='string', slots=[ { 'name': 'string', 'description': 'string', 'slotConstraint': 'Required'|'Optional', 'slotType': 'string', 'slotTypeVersion': 'string', 'valueElicitationPrompt': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'maxAttempts': 123, 'responseCard': 'string' }, 'priority': 123, 'sampleUtterances': [ 'string', ], 'responseCard': 'string' }, ], sampleUtterances=[ 'string', ], confirmationPrompt={ 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'maxAttempts': 123, 'responseCard': 'string' }, rejectionStatement={ 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'responseCard': 'string' }, followUpPrompt={ 'prompt': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'maxAttempts': 123, 'responseCard': 'string' }, 'rejectionStatement': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'responseCard': 'string' } }, conclusionStatement={ 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'responseCard': 'string' }, dialogCodeHook={ 'uri': 'string', 'messageVersion': 'string' }, fulfillmentActivity={ 'type': 'ReturnIntent'|'CodeHook', 'codeHook': { 'uri': 'string', 'messageVersion': 'string' } }, parentIntentSignature='string', checksum='string' ) :type name: string :param name: [REQUIRED] The name of the intent. The name is not case sensitive. The name can't match a built-in intent name, or a built-in intent name with 'AMAZON.' removed. For example, because there is a built-in intent called AMAZON.HelpIntent , you can't create a custom intent called HelpIntent . For a list of built-in intents, see Standard Built-in Intents in the Alexa Skills Kit . :type description: string :param description: A description of the intent. :type slots: list :param slots: An array of intent slots. At runtime, Amazon Lex elicits required slot values from the user using prompts defined in the slots. For more information, see xref linkend='how-it-works'/. (dict) --Identifies the version of a specific slot. name (string) -- [REQUIRED]The name of the slot. description (string) --A description of the slot. slotConstraint (string) -- [REQUIRED]Specifies whether the slot is required or optional. slotType (string) --The type of the slot, either a custom slot type that you defined or one of the built-in slot types. slotTypeVersion (string) --The version of the slot type. valueElicitationPrompt (dict) --The prompt that Amazon Lex uses to elicit the slot value from the user. messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). (dict) --The message object that provides the message text and its type. contentType (string) -- [REQUIRED]The content type of the message string. content (string) -- [REQUIRED]The text of the message. maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information. responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card . priority (integer) --Directs Lex the order in which to elicit this slot value from the user. For example, if the intent has two slots with priorities 1 and 2, AWS Lex first elicits a value for the slot with priority 1. If multiple slots share the same priority, the order in which Lex elicits values is arbitrary. sampleUtterances (list) --If you know a specific pattern with which users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances. (string) -- responseCard (string) --A set of possible responses for the slot type used by text-based clients. A user chooses an option from the response card, instead of using text to reply. :type sampleUtterances: list :param sampleUtterances: An array of utterances (strings) that a user might say to signal the intent. For example, 'I want {PizzaSize} pizza', 'Order {Quantity} {PizzaSize} pizzas'. In each utterance, a slot name is enclosed in curly braces. (string) -- :type confirmationPrompt: dict :param confirmationPrompt: Prompts the user to confirm the intent. This question should have a yes or no answer. Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the OrderPizza intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information. Note You you must provide both the rejectionStatement and the confirmationPrompt , or neither. messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). (dict) --The message object that provides the message text and its type. contentType (string) -- [REQUIRED]The content type of the message string. content (string) -- [REQUIRED]The text of the message. maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information. responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card . :type rejectionStatement: dict :param rejectionStatement: When the user answers 'no' to the question defined in confirmationPrompt , Amazon Lex responds with this statement to acknowledge that the intent was canceled. Note You must provide both the rejectionStatement and the confirmationPrompt , or neither. messages (list) -- [REQUIRED]A collection of message objects. (dict) --The message object that provides the message text and its type. contentType (string) -- [REQUIRED]The content type of the message string. content (string) -- [REQUIRED]The text of the message. responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card. :type followUpPrompt: dict :param followUpPrompt: A user prompt for additional activity after an intent is fulfilled. For example, after the OrderPizza intent is fulfilled (your Lambda function placed an order with a pizzeria), you might prompt the user to find if they want to order a drink (assuming that you have defined an OrderDrink intent in your bot). Note The followUpPrompt and conclusionStatement are mutually exclusive. You can specify only one. For example, your bot may not solicit both the following: Follow up prompt - '$session.FirstName , your pizza order has been placed. Would you like to order a drink or a dessert?' Conclusion statement - '$session.FirstName , your pizza order has been placed.' prompt (dict) -- [REQUIRED]Obtains information from the user. messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). (dict) --The message object that provides the message text and its type. contentType (string) -- [REQUIRED]The content type of the message string. content (string) -- [REQUIRED]The text of the message. maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information. responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card . rejectionStatement (dict) -- [REQUIRED]If the user answers 'no' to the question defined in confirmationPrompt , Amazon Lex responds with this statement to acknowledge that the intent was canceled. messages (list) -- [REQUIRED]A collection of message objects. (dict) --The message object that provides the message text and its type. contentType (string) -- [REQUIRED]The content type of the message string. content (string) -- [REQUIRED]The text of the message. responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card. :type conclusionStatement: dict :param conclusionStatement: The statement that you want Amazon Lex to convey to the user after the intent is successfully fulfilled by the Lambda function. This element is relevant only if you provide a Lambda function in the fulfillmentActivity . If you return the intent to the client application, you can't specify this element. Note The followUpPrompt and conclusionStatement are mutually exclusive. You can specify only one. messages (list) -- [REQUIRED]A collection of message objects. (dict) --The message object that provides the message text and its type. contentType (string) -- [REQUIRED]The content type of the message string. content (string) -- [REQUIRED]The text of the message. responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card. :type dialogCodeHook: dict :param dialogCodeHook: Specifies a Lambda function to invoke for each user input. You can invoke this Lambda function to personalize user interaction. For example, suppose your bot determines that the user is John. Your Lambda function might retrieve John's information from a backend database and prepopulate some of the values. For example, if you find that John is gluten intolerant, you might set the corresponding intent slot, GlutenIntolerant , to true. You might find John's phone number and set the corresponding session attribute. uri (string) -- [REQUIRED]The Amazon Resource Name (ARN) of the Lambda function. messageVersion (string) -- [REQUIRED]The version of the request-response that you want Amazon Lex to use to invoke your Lambda function. For more information, see using-lambda . :type fulfillmentActivity: dict :param fulfillmentActivity: Describes how the intent is fulfilled. For example, after a user provides all of the information for a pizza order, fulfillmentActivity defines how the bot places an order with a local pizza store. You might configure Amazon Lex to return all of the intent information to the client application, or direct it to invoke a Lambda function that can process the intent (for example, place an order with a pizzeria). type (string) -- [REQUIRED]How the intent should be fulfilled, either by running a Lambda function or by returning the slot data to the client application. codeHook (dict) --A description of the Lambda function that is run to fulfill the intent. uri (string) -- [REQUIRED]The Amazon Resource Name (ARN) of the Lambda function. messageVersion (string) -- [REQUIRED]The version of the request-response that you want Amazon Lex to use to invoke your Lambda function. For more information, see using-lambda . :type parentIntentSignature: string :param parentIntentSignature: A unique identifier for the built-in intent to base this intent on. To find the signature for an intent, see Standard Built-in Intents in the Alexa Skills Kit . :type checksum: string :param checksum: Identifies a specific revision of the $LATEST version. When you create a new intent, leave the checksum field blank. If you specify a checksum you get a BadRequestException exception. When you want to update a intent, set the checksum field to the checksum of the most recent revision of the $LATEST version. If you don't specify the checksum field, or if the checksum does not match the $LATEST version, you get a PreconditionFailedException exception. :rtype: dict :return: { 'name': 'string', 'description': 'string', 'slots': [ { 'name': 'string', 'description': 'string', 'slotConstraint': 'Required'|'Optional', 'slotType': 'string', 'slotTypeVersion': 'string', 'valueElicitationPrompt': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'maxAttempts': 123, 'responseCard': 'string' }, 'priority': 123, 'sampleUtterances': [ 'string', ], 'responseCard': 'string' }, ], 'sampleUtterances': [ 'string', ], 'confirmationPrompt': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'maxAttempts': 123, 'responseCard': 'string' }, 'rejectionStatement': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'responseCard': 'string' }, 'followUpPrompt': { 'prompt': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'maxAttempts': 123, 'responseCard': 'string' }, 'rejectionStatement': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'responseCard': 'string' } }, 'conclusionStatement': { 'messages': [ { 'contentType': 'PlainText'|'SSML', 'content': 'string' }, ], 'responseCard': 'string' }, 'dialogCodeHook': { 'uri': 'string', 'messageVersion': 'string' }, 'fulfillmentActivity': { 'type': 'ReturnIntent'|'CodeHook', 'codeHook': { 'uri': 'string', 'messageVersion': 'string' } }, 'parentIntentSignature': 'string', 'lastUpdatedDate': datetime(2015, 1, 1), 'createdDate': datetime(2015, 1, 1), 'version': 'string', 'checksum': 'string' } :returns: A confirmation prompt to ask the user to confirm an intent. For example, \"Shall I order your pizza?\" A conclusion statement to send to the user after the intent has been fulfilled. For example, \"I placed your pizza order.\" A follow-up prompt that asks the user for additional activity. For example, asking \"Do you want to order a drink with your pizza?\"", "response": "def put_intent(name=None, description=None, slots=None, sampleUtterances=None, confirmationPrompt=None, rejectionStatement=None, followUpPrompt=None, conclusionStatement=None, dialogCodeHook=None, fulfillmentActivity=None, parentIntentSignature=None, checksum=None):\n    \"\"\"\n    Creates an intent or replaces an existing intent.\n    To define the interaction between the user and your bot, you use one or more intents. For a pizza ordering bot, for example, you would create an OrderPizza intent.\n    To create an intent or replace an existing intent, you must provide the following:\n    You can specify other optional information in the request, such as:\n    If you specify an existing intent name to update the intent, Amazon Lex replaces the values in the $LATEST version of the slot type with the values in the request. Amazon Lex removes fields that you don't provide in the request. If you don't specify the required fields, Amazon Lex throws an exception.\n    For more information, see  how-it-works .\n    This operation requires permissions for the lex:PutIntent action.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.put_intent(\n        name='string',\n        description='string',\n        slots=[\n            {\n                'name': 'string',\n                'description': 'string',\n                'slotConstraint': 'Required'|'Optional',\n                'slotType': 'string',\n                'slotTypeVersion': 'string',\n                'valueElicitationPrompt': {\n                    'messages': [\n                        {\n                            'contentType': 'PlainText'|'SSML',\n                            'content': 'string'\n                        },\n                    ],\n                    'maxAttempts': 123,\n                    'responseCard': 'string'\n                },\n                'priority': 123,\n                'sampleUtterances': [\n                    'string',\n                ],\n                'responseCard': 'string'\n            },\n        ],\n        sampleUtterances=[\n            'string',\n        ],\n        confirmationPrompt={\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'maxAttempts': 123,\n            'responseCard': 'string'\n        },\n        rejectionStatement={\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'responseCard': 'string'\n        },\n        followUpPrompt={\n            'prompt': {\n                'messages': [\n                    {\n                        'contentType': 'PlainText'|'SSML',\n                        'content': 'string'\n                    },\n                ],\n                'maxAttempts': 123,\n                'responseCard': 'string'\n            },\n            'rejectionStatement': {\n                'messages': [\n                    {\n                        'contentType': 'PlainText'|'SSML',\n                        'content': 'string'\n                    },\n                ],\n                'responseCard': 'string'\n            }\n        },\n        conclusionStatement={\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'responseCard': 'string'\n        },\n        dialogCodeHook={\n            'uri': 'string',\n            'messageVersion': 'string'\n        },\n        fulfillmentActivity={\n            'type': 'ReturnIntent'|'CodeHook',\n            'codeHook': {\n                'uri': 'string',\n                'messageVersion': 'string'\n            }\n        },\n        parentIntentSignature='string',\n        checksum='string'\n    )\n    \n    \n    :type name: string\n    :param name: [REQUIRED]\n            The name of the intent. The name is not case sensitive.\n            The name can't match a built-in intent name, or a built-in intent name with 'AMAZON.' removed. For example, because there is a built-in intent called AMAZON.HelpIntent , you can't create a custom intent called HelpIntent .\n            For a list of built-in intents, see Standard Built-in Intents in the Alexa Skills Kit .\n            \n\n    :type description: string\n    :param description: A description of the intent.\n\n    :type slots: list\n    :param slots: An array of intent slots. At runtime, Amazon Lex elicits required slot values from the user using prompts defined in the slots. For more information, see xref linkend='how-it-works'/.\n            (dict) --Identifies the version of a specific slot.\n            name (string) -- [REQUIRED]The name of the slot.\n            description (string) --A description of the slot.\n            slotConstraint (string) -- [REQUIRED]Specifies whether the slot is required or optional.\n            slotType (string) --The type of the slot, either a custom slot type that you defined or one of the built-in slot types.\n            slotTypeVersion (string) --The version of the slot type.\n            valueElicitationPrompt (dict) --The prompt that Amazon Lex uses to elicit the slot value from the user.\n            messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML).\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information.\n            responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card .\n            priority (integer) --Directs Lex the order in which to elicit this slot value from the user. For example, if the intent has two slots with priorities 1 and 2, AWS Lex first elicits a value for the slot with priority 1.\n            If multiple slots share the same priority, the order in which Lex elicits values is arbitrary.\n            sampleUtterances (list) --If you know a specific pattern with which users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.\n            (string) --\n            responseCard (string) --A set of possible responses for the slot type used by text-based clients. A user chooses an option from the response card, instead of using text to reply.\n            \n            \n\n    :type sampleUtterances: list\n    :param sampleUtterances: An array of utterances (strings) that a user might say to signal the intent. For example, 'I want {PizzaSize} pizza', 'Order {Quantity} {PizzaSize} pizzas'.\n            In each utterance, a slot name is enclosed in curly braces.\n            (string) --\n            \n\n    :type confirmationPrompt: dict\n    :param confirmationPrompt: Prompts the user to confirm the intent. This question should have a yes or no answer.\n            Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the OrderPizza intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.\n            Note\n            You you must provide both the rejectionStatement and the confirmationPrompt , or neither.\n            messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML).\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information.\n            responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card .\n            \n\n    :type rejectionStatement: dict\n    :param rejectionStatement: When the user answers 'no' to the question defined in confirmationPrompt , Amazon Lex responds with this statement to acknowledge that the intent was canceled.\n            Note\n            You must provide both the rejectionStatement and the confirmationPrompt , or neither.\n            messages (list) -- [REQUIRED]A collection of message objects.\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card.\n            \n\n    :type followUpPrompt: dict\n    :param followUpPrompt: A user prompt for additional activity after an intent is fulfilled. For example, after the OrderPizza intent is fulfilled (your Lambda function placed an order with a pizzeria), you might prompt the user to find if they want to order a drink (assuming that you have defined an OrderDrink intent in your bot).\n            Note\n            The followUpPrompt and conclusionStatement are mutually exclusive. You can specify only one. For example, your bot may not solicit both the following:\n            Follow up prompt - '$session.FirstName , your pizza order has been placed. Would you like to order a drink or a dessert?'\n            Conclusion statement - '$session.FirstName , your pizza order has been placed.'\n            prompt (dict) -- [REQUIRED]Obtains information from the user.\n            messages (list) -- [REQUIRED]An array of objects, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML).\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            maxAttempts (integer) -- [REQUIRED]The number of times to prompt the user for information.\n            responseCard (string) --A response card. Amazon Lex uses this prompt at runtime, in the PostText API response. It substitutes session attributes and slot values for placeholders in the response card. For more information, see ex-resp-card .\n            rejectionStatement (dict) -- [REQUIRED]If the user answers 'no' to the question defined in confirmationPrompt , Amazon Lex responds with this statement to acknowledge that the intent was canceled.\n            messages (list) -- [REQUIRED]A collection of message objects.\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card.\n            \n            \n\n    :type conclusionStatement: dict\n    :param conclusionStatement: The statement that you want Amazon Lex to convey to the user after the intent is successfully fulfilled by the Lambda function.\n            This element is relevant only if you provide a Lambda function in the fulfillmentActivity . If you return the intent to the client application, you can't specify this element.\n            Note\n            The followUpPrompt and conclusionStatement are mutually exclusive. You can specify only one.\n            messages (list) -- [REQUIRED]A collection of message objects.\n            (dict) --The message object that provides the message text and its type.\n            contentType (string) -- [REQUIRED]The content type of the message string.\n            content (string) -- [REQUIRED]The text of the message.\n            \n            responseCard (string) --At runtime, if the client is using the API, Amazon Lex includes the response card in the response. It substitutes all of the session attributes and slot values for placeholders in the response card.\n            \n\n    :type dialogCodeHook: dict\n    :param dialogCodeHook: Specifies a Lambda function to invoke for each user input. You can invoke this Lambda function to personalize user interaction.\n            For example, suppose your bot determines that the user is John. Your Lambda function might retrieve John's information from a backend database and prepopulate some of the values. For example, if you find that John is gluten intolerant, you might set the corresponding intent slot, GlutenIntolerant , to true. You might find John's phone number and set the corresponding session attribute.\n            uri (string) -- [REQUIRED]The Amazon Resource Name (ARN) of the Lambda function.\n            messageVersion (string) -- [REQUIRED]The version of the request-response that you want Amazon Lex to use to invoke your Lambda function. For more information, see using-lambda .\n            \n\n    :type fulfillmentActivity: dict\n    :param fulfillmentActivity: Describes how the intent is fulfilled. For example, after a user provides all of the information for a pizza order, fulfillmentActivity defines how the bot places an order with a local pizza store.\n            You might configure Amazon Lex to return all of the intent information to the client application, or direct it to invoke a Lambda function that can process the intent (for example, place an order with a pizzeria).\n            type (string) -- [REQUIRED]How the intent should be fulfilled, either by running a Lambda function or by returning the slot data to the client application.\n            codeHook (dict) --A description of the Lambda function that is run to fulfill the intent.\n            uri (string) -- [REQUIRED]The Amazon Resource Name (ARN) of the Lambda function.\n            messageVersion (string) -- [REQUIRED]The version of the request-response that you want Amazon Lex to use to invoke your Lambda function. For more information, see using-lambda .\n            \n            \n\n    :type parentIntentSignature: string\n    :param parentIntentSignature: A unique identifier for the built-in intent to base this intent on. To find the signature for an intent, see Standard Built-in Intents in the Alexa Skills Kit .\n\n    :type checksum: string\n    :param checksum: Identifies a specific revision of the $LATEST version.\n            When you create a new intent, leave the checksum field blank. If you specify a checksum you get a BadRequestException exception.\n            When you want to update a intent, set the checksum field to the checksum of the most recent revision of the $LATEST version. If you don't specify the checksum field, or if the checksum does not match the $LATEST version, you get a PreconditionFailedException exception.\n            \n\n    :rtype: dict\n    :return: {\n        'name': 'string',\n        'description': 'string',\n        'slots': [\n            {\n                'name': 'string',\n                'description': 'string',\n                'slotConstraint': 'Required'|'Optional',\n                'slotType': 'string',\n                'slotTypeVersion': 'string',\n                'valueElicitationPrompt': {\n                    'messages': [\n                        {\n                            'contentType': 'PlainText'|'SSML',\n                            'content': 'string'\n                        },\n                    ],\n                    'maxAttempts': 123,\n                    'responseCard': 'string'\n                },\n                'priority': 123,\n                'sampleUtterances': [\n                    'string',\n                ],\n                'responseCard': 'string'\n            },\n        ],\n        'sampleUtterances': [\n            'string',\n        ],\n        'confirmationPrompt': {\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'maxAttempts': 123,\n            'responseCard': 'string'\n        },\n        'rejectionStatement': {\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'responseCard': 'string'\n        },\n        'followUpPrompt': {\n            'prompt': {\n                'messages': [\n                    {\n                        'contentType': 'PlainText'|'SSML',\n                        'content': 'string'\n                    },\n                ],\n                'maxAttempts': 123,\n                'responseCard': 'string'\n            },\n            'rejectionStatement': {\n                'messages': [\n                    {\n                        'contentType': 'PlainText'|'SSML',\n                        'content': 'string'\n                    },\n                ],\n                'responseCard': 'string'\n            }\n        },\n        'conclusionStatement': {\n            'messages': [\n                {\n                    'contentType': 'PlainText'|'SSML',\n                    'content': 'string'\n                },\n            ],\n            'responseCard': 'string'\n        },\n        'dialogCodeHook': {\n            'uri': 'string',\n            'messageVersion': 'string'\n        },\n        'fulfillmentActivity': {\n            'type': 'ReturnIntent'|'CodeHook',\n            'codeHook': {\n                'uri': 'string',\n                'messageVersion': 'string'\n            }\n        },\n        'parentIntentSignature': 'string',\n        'lastUpdatedDate': datetime(2015, 1, 1),\n        'createdDate': datetime(2015, 1, 1),\n        'version': 'string',\n        'checksum': 'string'\n    }\n    \n    \n    :returns: \n    A confirmation prompt to ask the user to confirm an intent. For example, \"Shall I order your pizza?\"\n    A conclusion statement to send to the user after the intent has been fulfilled. For example, \"I placed your pizza order.\"\n    A follow-up prompt that asks the user for additional activity. For example, asking \"Do you want to order a drink with your pizza?\"\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a cache cluster. All nodes in the cache cluster run the same protocol-compliant cache engine software, either Memcached or Redis. See also: AWS API Documentation :example: response = client.create_cache_cluster( CacheClusterId='string', ReplicationGroupId='string', AZMode='single-az'|'cross-az', PreferredAvailabilityZone='string', PreferredAvailabilityZones=[ 'string', ], NumCacheNodes=123, CacheNodeType='string', Engine='string', EngineVersion='string', CacheParameterGroupName='string', CacheSubnetGroupName='string', CacheSecurityGroupNames=[ 'string', ], SecurityGroupIds=[ 'string', ], Tags=[ { 'Key': 'string', 'Value': 'string' }, ], SnapshotArns=[ 'string', ], SnapshotName='string', PreferredMaintenanceWindow='string', Port=123, NotificationTopicArn='string', AutoMinorVersionUpgrade=True|False, SnapshotRetentionLimit=123, SnapshotWindow='string', AuthToken='string' ) :type CacheClusterId: string :param CacheClusterId: [REQUIRED] The node group (shard) identifier. This parameter is stored as a lowercase string. Constraints: A name must contain from 1 to 20 alphanumeric characters or hyphens. The first character must be a letter. A name cannot end with a hyphen or contain two consecutive hyphens. :type ReplicationGroupId: string :param ReplicationGroupId: Warning Due to current limitations on Redis (cluster mode disabled), this operation or parameter is not supported on Redis (cluster mode enabled) replication groups. The ID of the replication group to which this cache cluster should belong. If this parameter is specified, the cache cluster is added to the specified replication group as a read replica; otherwise, the cache cluster is a standalone primary that is not part of any replication group. If the specified replication group is Multi-AZ enabled and the Availability Zone is not specified, the cache cluster is created in Availability Zones that provide the best spread of read replicas across Availability Zones. Note This parameter is only valid if the Engine parameter is redis . :type AZMode: string :param AZMode: Specifies whether the nodes in this Memcached cluster are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. This parameter is only supported for Memcached cache clusters. If the AZMode and PreferredAvailabilityZones are not specified, ElastiCache assumes single-az mode. :type PreferredAvailabilityZone: string :param PreferredAvailabilityZone: The EC2 Availability Zone in which the cache cluster is created. All nodes belonging to this Memcached cache cluster are placed in the preferred Availability Zone. If you want to create your nodes across multiple Availability Zones, use PreferredAvailabilityZones . Default: System chosen Availability Zone. :type PreferredAvailabilityZones: list :param PreferredAvailabilityZones: A list of the Availability Zones in which cache nodes are created. The order of the zones in the list is not important. This option is only supported on Memcached. Note If you are creating your cache cluster in an Amazon VPC (recommended) you can only locate nodes in Availability Zones that are associated with the subnets in the selected subnet group. The number of Availability Zones listed must equal the value of NumCacheNodes . If you want all the nodes in the same Availability Zone, use PreferredAvailabilityZone instead, or repeat the Availability Zone multiple times in the list. Default: System chosen Availability Zones. (string) -- :type NumCacheNodes: integer :param NumCacheNodes: The initial number of cache nodes that the cache cluster has. For clusters running Redis, this value must be 1. For clusters running Memcached, this value must be between 1 and 20. If you need more than 20 nodes for your Memcached cluster, please fill out the ElastiCache Limit Increase Request form at http://aws.amazon.com/contact-us/elasticache-node-limit-request/ . :type CacheNodeType: string :param CacheNodeType: The compute and memory capacity of the nodes in the node group (shard). Valid node types are as follows: General purpose: Current generation: cache.t2.micro , cache.t2.small , cache.t2.medium , cache.m3.medium , cache.m3.large , cache.m3.xlarge , cache.m3.2xlarge , cache.m4.large , cache.m4.xlarge , cache.m4.2xlarge , cache.m4.4xlarge , cache.m4.10xlarge Previous generation: cache.t1.micro , cache.m1.small , cache.m1.medium , cache.m1.large , cache.m1.xlarge Compute optimized: cache.c1.xlarge Memory optimized: Current generation: cache.r3.large , cache.r3.xlarge , cache.r3.2xlarge , cache.r3.4xlarge , cache.r3.8xlarge Previous generation: cache.m2.xlarge , cache.m2.2xlarge , cache.m2.4xlarge Notes: All T2 instances are created in an Amazon Virtual Private Cloud (Amazon VPC). Redis backup/restore is not supported for Redis (cluster mode disabled) T1 and T2 instances. Backup/restore is supported on Redis (cluster mode enabled) T2 instances. Redis Append-only files (AOF) functionality is not supported for T1 or T2 instances. For a complete listing of node types and specifications, see Amazon ElastiCache Product Features and Details and either Cache Node Type-Specific Parameters for Memcached or Cache Node Type-Specific Parameters for Redis . :type Engine: string :param Engine: The name of the cache engine to be used for this cache cluster. Valid values for this parameter are: memcached | redis :type EngineVersion: string :param EngineVersion: The version number of the cache engine to be used for this cache cluster. To view the supported cache engine versions, use the DescribeCacheEngineVersions operation. Important: You can upgrade to a newer engine version (see Selecting a Cache Engine and Version ), but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cache cluster or replication group and create it anew with the earlier engine version. :type CacheParameterGroupName: string :param CacheParameterGroupName: The name of the parameter group to associate with this cache cluster. If this argument is omitted, the default parameter group for the specified engine is used. You cannot use any parameter group which has cluster-enabled='yes' when creating a cluster. :type CacheSubnetGroupName: string :param CacheSubnetGroupName: The name of the subnet group to be used for the cache cluster. Use this parameter only when you are creating a cache cluster in an Amazon Virtual Private Cloud (Amazon VPC). Warning If you're going to launch your cluster in an Amazon VPC, you need to create a subnet group before you start creating a cluster. For more information, see Subnets and Subnet Groups . :type CacheSecurityGroupNames: list :param CacheSecurityGroupNames: A list of security group names to associate with this cache cluster. Use this parameter only when you are creating a cache cluster outside of an Amazon Virtual Private Cloud (Amazon VPC). (string) -- :type SecurityGroupIds: list :param SecurityGroupIds: One or more VPC security groups associated with the cache cluster. Use this parameter only when you are creating a cache cluster in an Amazon Virtual Private Cloud (Amazon VPC). (string) -- :type Tags: list :param Tags: A list of cost allocation tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value. (dict) --A cost allocation Tag that can be added to an ElastiCache cluster or replication group. Tags are composed of a Key/Value pair. A tag with a null Value is permitted. Key (string) --The key for the tag. May not be null. Value (string) --The tag's value. May be null. :type SnapshotArns: list :param SnapshotArns: A single-element string list containing an Amazon Resource Name (ARN) that uniquely identifies a Redis RDB snapshot file stored in Amazon S3. The snapshot file is used to populate the node group (shard). The Amazon S3 object name in the ARN cannot contain any commas. Note This parameter is only valid if the Engine parameter is redis . Example of an Amazon S3 ARN: arn:aws:s3:::my_bucket/snapshot1.rdb (string) -- :type SnapshotName: string :param SnapshotName: The name of a Redis snapshot from which to restore data into the new node group (shard). The snapshot status changes to restoring while the new node group (shard) is being created. Note This parameter is only valid if the Engine parameter is redis . :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: Specifies the weekly time range during which maintenance on the cache cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are: sun mon tue wed thu fri sat Example: sun:23:00-mon:01:30 :type Port: integer :param Port: The port number on which each of the cache nodes accepts connections. :type NotificationTopicArn: string :param NotificationTopicArn: The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent. Note The Amazon SNS topic owner must be the same as the cache cluster owner. :type AutoMinorVersionUpgrade: boolean :param AutoMinorVersionUpgrade: This parameter is currently disabled. :type SnapshotRetentionLimit: integer :param SnapshotRetentionLimit: The number of days for which ElastiCache retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot taken today is retained for 5 days before being deleted. Note This parameter is only valid if the Engine parameter is redis . Default: 0 (i.e., automatic backups are disabled for this cache cluster). :type SnapshotWindow: string :param SnapshotWindow: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your node group (shard). Example: 05:00-09:00 If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range. Note: This parameter is only valid if the Engine parameter is redis . :type AuthToken: string :param AuthToken: Reserved parameter. The password used to access a password protected server. Password constraints: Must be only printable ASCII characters. Must be at least 16 characters and no more than 128 characters in length. Cannot contain any of the following characters: '/', ''', or '@'. For more information, see AUTH password at Redis. :rtype: dict :return: { 'CacheCluster': { 'CacheClusterId': 'string', 'ConfigurationEndpoint': { 'Address': 'string', 'Port': 123 }, 'ClientDownloadLandingPage': 'string', 'CacheNodeType': 'string', 'Engine': 'string', 'EngineVersion': 'string', 'CacheClusterStatus': 'string', 'NumCacheNodes': 123, 'PreferredAvailabilityZone': 'string', 'CacheClusterCreateTime': datetime(2015, 1, 1), 'PreferredMaintenanceWindow': 'string', 'PendingModifiedValues': { 'NumCacheNodes': 123, 'CacheNodeIdsToRemove': [ 'string', ], 'EngineVersion': 'string', 'CacheNodeType': 'string' }, 'NotificationConfiguration': { 'TopicArn': 'string', 'TopicStatus': 'string' }, 'CacheSecurityGroups': [ { 'CacheSecurityGroupName': 'string', 'Status': 'string' }, ], 'CacheParameterGroup': { 'CacheParameterGroupName': 'string', 'ParameterApplyStatus': 'string', 'CacheNodeIdsToReboot': [ 'string', ] }, 'CacheSubnetGroupName': 'string', 'CacheNodes': [ { 'CacheNodeId': 'string', 'CacheNodeStatus': 'string', 'CacheNodeCreateTime': datetime(2015, 1, 1), 'Endpoint': { 'Address': 'string', 'Port': 123 }, 'ParameterGroupStatus': 'string', 'SourceCacheNodeId': 'string', 'CustomerAvailabilityZone': 'string' }, ], 'AutoMinorVersionUpgrade': True|False, 'SecurityGroups': [ { 'SecurityGroupId': 'string', 'Status': 'string' }, ], 'ReplicationGroupId': 'string', 'SnapshotRetentionLimit': 123, 'SnapshotWindow': 'string' } } :returns: General purpose: Current generation: cache.t2.micro , cache.t2.small , cache.t2.medium , cache.m3.medium , cache.m3.large , cache.m3.xlarge , cache.m3.2xlarge , cache.m4.large , cache.m4.xlarge , cache.m4.2xlarge , cache.m4.4xlarge , cache.m4.10xlarge Previous generation: cache.t1.micro , cache.m1.small , cache.m1.medium , cache.m1.large , cache.m1.xlarge Compute optimized: cache.c1.xlarge Memory optimized: Current generation: cache.r3.large , cache.r3.xlarge , cache.r3.2xlarge , cache.r3.4xlarge , cache.r3.8xlarge Previous generation: cache.m2.xlarge , cache.m2.2xlarge , cache.m2.4xlarge", "response": "def create_cache_cluster(CacheClusterId=None, ReplicationGroupId=None, AZMode=None, PreferredAvailabilityZone=None, PreferredAvailabilityZones=None, NumCacheNodes=None, CacheNodeType=None, Engine=None, EngineVersion=None, CacheParameterGroupName=None, CacheSubnetGroupName=None, CacheSecurityGroupNames=None, SecurityGroupIds=None, Tags=None, SnapshotArns=None, SnapshotName=None, PreferredMaintenanceWindow=None, Port=None, NotificationTopicArn=None, AutoMinorVersionUpgrade=None, SnapshotRetentionLimit=None, SnapshotWindow=None, AuthToken=None):\n    \"\"\"\n    Creates a cache cluster. All nodes in the cache cluster run the same protocol-compliant cache engine software, either Memcached or Redis.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_cache_cluster(\n        CacheClusterId='string',\n        ReplicationGroupId='string',\n        AZMode='single-az'|'cross-az',\n        PreferredAvailabilityZone='string',\n        PreferredAvailabilityZones=[\n            'string',\n        ],\n        NumCacheNodes=123,\n        CacheNodeType='string',\n        Engine='string',\n        EngineVersion='string',\n        CacheParameterGroupName='string',\n        CacheSubnetGroupName='string',\n        CacheSecurityGroupNames=[\n            'string',\n        ],\n        SecurityGroupIds=[\n            'string',\n        ],\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        SnapshotArns=[\n            'string',\n        ],\n        SnapshotName='string',\n        PreferredMaintenanceWindow='string',\n        Port=123,\n        NotificationTopicArn='string',\n        AutoMinorVersionUpgrade=True|False,\n        SnapshotRetentionLimit=123,\n        SnapshotWindow='string',\n        AuthToken='string'\n    )\n    \n    \n    :type CacheClusterId: string\n    :param CacheClusterId: [REQUIRED]\n            The node group (shard) identifier. This parameter is stored as a lowercase string.\n            Constraints:\n            A name must contain from 1 to 20 alphanumeric characters or hyphens.\n            The first character must be a letter.\n            A name cannot end with a hyphen or contain two consecutive hyphens.\n            \n\n    :type ReplicationGroupId: string\n    :param ReplicationGroupId: \n            Warning\n            Due to current limitations on Redis (cluster mode disabled), this operation or parameter is not supported on Redis (cluster mode enabled) replication groups.\n            The ID of the replication group to which this cache cluster should belong. If this parameter is specified, the cache cluster is added to the specified replication group as a read replica; otherwise, the cache cluster is a standalone primary that is not part of any replication group.\n            If the specified replication group is Multi-AZ enabled and the Availability Zone is not specified, the cache cluster is created in Availability Zones that provide the best spread of read replicas across Availability Zones.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            \n\n    :type AZMode: string\n    :param AZMode: Specifies whether the nodes in this Memcached cluster are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region.\n            This parameter is only supported for Memcached cache clusters.\n            If the AZMode and PreferredAvailabilityZones are not specified, ElastiCache assumes single-az mode.\n            \n\n    :type PreferredAvailabilityZone: string\n    :param PreferredAvailabilityZone: The EC2 Availability Zone in which the cache cluster is created.\n            All nodes belonging to this Memcached cache cluster are placed in the preferred Availability Zone. If you want to create your nodes across multiple Availability Zones, use PreferredAvailabilityZones .\n            Default: System chosen Availability Zone.\n            \n\n    :type PreferredAvailabilityZones: list\n    :param PreferredAvailabilityZones: A list of the Availability Zones in which cache nodes are created. The order of the zones in the list is not important.\n            This option is only supported on Memcached.\n            Note\n            If you are creating your cache cluster in an Amazon VPC (recommended) you can only locate nodes in Availability Zones that are associated with the subnets in the selected subnet group.\n            The number of Availability Zones listed must equal the value of NumCacheNodes .\n            If you want all the nodes in the same Availability Zone, use PreferredAvailabilityZone instead, or repeat the Availability Zone multiple times in the list.\n            Default: System chosen Availability Zones.\n            (string) --\n            \n\n    :type NumCacheNodes: integer\n    :param NumCacheNodes: The initial number of cache nodes that the cache cluster has.\n            For clusters running Redis, this value must be 1. For clusters running Memcached, this value must be between 1 and 20.\n            If you need more than 20 nodes for your Memcached cluster, please fill out the ElastiCache Limit Increase Request form at http://aws.amazon.com/contact-us/elasticache-node-limit-request/ .\n            \n\n    :type CacheNodeType: string\n    :param CacheNodeType: The compute and memory capacity of the nodes in the node group (shard).\n            Valid node types are as follows:\n            General purpose:\n            Current generation: cache.t2.micro , cache.t2.small , cache.t2.medium , cache.m3.medium , cache.m3.large , cache.m3.xlarge , cache.m3.2xlarge , cache.m4.large , cache.m4.xlarge , cache.m4.2xlarge , cache.m4.4xlarge , cache.m4.10xlarge\n            Previous generation: cache.t1.micro , cache.m1.small , cache.m1.medium , cache.m1.large , cache.m1.xlarge\n            Compute optimized: cache.c1.xlarge\n            Memory optimized:\n            Current generation: cache.r3.large , cache.r3.xlarge , cache.r3.2xlarge , cache.r3.4xlarge , cache.r3.8xlarge\n            Previous generation: cache.m2.xlarge , cache.m2.2xlarge , cache.m2.4xlarge\n            \n            Notes:\n            All T2 instances are created in an Amazon Virtual Private Cloud (Amazon VPC).\n            Redis backup/restore is not supported for Redis (cluster mode disabled) T1 and T2 instances. Backup/restore is supported on Redis (cluster mode enabled) T2 instances.\n            Redis Append-only files (AOF) functionality is not supported for T1 or T2 instances.\n            For a complete listing of node types and specifications, see Amazon ElastiCache Product Features and Details and either Cache Node Type-Specific Parameters for Memcached or Cache Node Type-Specific Parameters for Redis .\n            \n\n    :type Engine: string\n    :param Engine: The name of the cache engine to be used for this cache cluster.\n            Valid values for this parameter are: memcached | redis\n            \n\n    :type EngineVersion: string\n    :param EngineVersion: The version number of the cache engine to be used for this cache cluster. To view the supported cache engine versions, use the DescribeCacheEngineVersions operation.\n            Important: You can upgrade to a newer engine version (see Selecting a Cache Engine and Version ), but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cache cluster or replication group and create it anew with the earlier engine version.\n            \n\n    :type CacheParameterGroupName: string\n    :param CacheParameterGroupName: The name of the parameter group to associate with this cache cluster. If this argument is omitted, the default parameter group for the specified engine is used. You cannot use any parameter group which has cluster-enabled='yes' when creating a cluster.\n\n    :type CacheSubnetGroupName: string\n    :param CacheSubnetGroupName: The name of the subnet group to be used for the cache cluster.\n            Use this parameter only when you are creating a cache cluster in an Amazon Virtual Private Cloud (Amazon VPC).\n            Warning\n            If you're going to launch your cluster in an Amazon VPC, you need to create a subnet group before you start creating a cluster. For more information, see Subnets and Subnet Groups .\n            \n\n    :type CacheSecurityGroupNames: list\n    :param CacheSecurityGroupNames: A list of security group names to associate with this cache cluster.\n            Use this parameter only when you are creating a cache cluster outside of an Amazon Virtual Private Cloud (Amazon VPC).\n            (string) --\n            \n\n    :type SecurityGroupIds: list\n    :param SecurityGroupIds: One or more VPC security groups associated with the cache cluster.\n            Use this parameter only when you are creating a cache cluster in an Amazon Virtual Private Cloud (Amazon VPC).\n            (string) --\n            \n\n    :type Tags: list\n    :param Tags: A list of cost allocation tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value.\n            (dict) --A cost allocation Tag that can be added to an ElastiCache cluster or replication group. Tags are composed of a Key/Value pair. A tag with a null Value is permitted.\n            Key (string) --The key for the tag. May not be null.\n            Value (string) --The tag's value. May be null.\n            \n            \n\n    :type SnapshotArns: list\n    :param SnapshotArns: A single-element string list containing an Amazon Resource Name (ARN) that uniquely identifies a Redis RDB snapshot file stored in Amazon S3. The snapshot file is used to populate the node group (shard). The Amazon S3 object name in the ARN cannot contain any commas.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            Example of an Amazon S3 ARN: arn:aws:s3:::my_bucket/snapshot1.rdb\n            (string) --\n            \n\n    :type SnapshotName: string\n    :param SnapshotName: The name of a Redis snapshot from which to restore data into the new node group (shard). The snapshot status changes to restoring while the new node group (shard) is being created.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: Specifies the weekly time range during which maintenance on the cache cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:\n            Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.\n            Valid values for ddd are:\n            sun\n            mon\n            tue\n            wed\n            thu\n            fri\n            sat\n            Example: sun:23:00-mon:01:30\n            \n\n    :type Port: integer\n    :param Port: The port number on which each of the cache nodes accepts connections.\n\n    :type NotificationTopicArn: string\n    :param NotificationTopicArn: The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.\n            Note\n            The Amazon SNS topic owner must be the same as the cache cluster owner.\n            \n\n    :type AutoMinorVersionUpgrade: boolean\n    :param AutoMinorVersionUpgrade: This parameter is currently disabled.\n\n    :type SnapshotRetentionLimit: integer\n    :param SnapshotRetentionLimit: The number of days for which ElastiCache retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot taken today is retained for 5 days before being deleted.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            Default: 0 (i.e., automatic backups are disabled for this cache cluster).\n            \n\n    :type SnapshotWindow: string\n    :param SnapshotWindow: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your node group (shard).\n            Example: 05:00-09:00\n            If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range.\n            Note: This parameter is only valid if the Engine parameter is redis .\n            \n\n    :type AuthToken: string\n    :param AuthToken: \n            Reserved parameter. The password used to access a password protected server.\n            Password constraints:\n            Must be only printable ASCII characters.\n            Must be at least 16 characters and no more than 128 characters in length.\n            Cannot contain any of the following characters: '/', ''', or '@'.\n            For more information, see AUTH password at Redis.\n            \n\n    :rtype: dict\n    :return: {\n        'CacheCluster': {\n            'CacheClusterId': 'string',\n            'ConfigurationEndpoint': {\n                'Address': 'string',\n                'Port': 123\n            },\n            'ClientDownloadLandingPage': 'string',\n            'CacheNodeType': 'string',\n            'Engine': 'string',\n            'EngineVersion': 'string',\n            'CacheClusterStatus': 'string',\n            'NumCacheNodes': 123,\n            'PreferredAvailabilityZone': 'string',\n            'CacheClusterCreateTime': datetime(2015, 1, 1),\n            'PreferredMaintenanceWindow': 'string',\n            'PendingModifiedValues': {\n                'NumCacheNodes': 123,\n                'CacheNodeIdsToRemove': [\n                    'string',\n                ],\n                'EngineVersion': 'string',\n                'CacheNodeType': 'string'\n            },\n            'NotificationConfiguration': {\n                'TopicArn': 'string',\n                'TopicStatus': 'string'\n            },\n            'CacheSecurityGroups': [\n                {\n                    'CacheSecurityGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'CacheParameterGroup': {\n                'CacheParameterGroupName': 'string',\n                'ParameterApplyStatus': 'string',\n                'CacheNodeIdsToReboot': [\n                    'string',\n                ]\n            },\n            'CacheSubnetGroupName': 'string',\n            'CacheNodes': [\n                {\n                    'CacheNodeId': 'string',\n                    'CacheNodeStatus': 'string',\n                    'CacheNodeCreateTime': datetime(2015, 1, 1),\n                    'Endpoint': {\n                        'Address': 'string',\n                        'Port': 123\n                    },\n                    'ParameterGroupStatus': 'string',\n                    'SourceCacheNodeId': 'string',\n                    'CustomerAvailabilityZone': 'string'\n                },\n            ],\n            'AutoMinorVersionUpgrade': True|False,\n            'SecurityGroups': [\n                {\n                    'SecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'ReplicationGroupId': 'string',\n            'SnapshotRetentionLimit': 123,\n            'SnapshotWindow': 'string'\n        }\n    }\n    \n    \n    :returns: \n    General purpose:\n    Current generation: cache.t2.micro , cache.t2.small , cache.t2.medium , cache.m3.medium , cache.m3.large , cache.m3.xlarge , cache.m3.2xlarge , cache.m4.large , cache.m4.xlarge , cache.m4.2xlarge , cache.m4.4xlarge , cache.m4.10xlarge\n    Previous generation: cache.t1.micro , cache.m1.small , cache.m1.medium , cache.m1.large , cache.m1.xlarge\n    \n    \n    Compute optimized: cache.c1.xlarge\n    Memory optimized:\n    Current generation: cache.r3.large , cache.r3.xlarge , cache.r3.2xlarge , cache.r3.4xlarge , cache.r3.8xlarge\n    Previous generation: cache.m2.xlarge , cache.m2.2xlarge , cache.m2.4xlarge\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a replication group.", "response": "def create_replication_group(ReplicationGroupId=None, ReplicationGroupDescription=None, PrimaryClusterId=None, AutomaticFailoverEnabled=None, NumCacheClusters=None, PreferredCacheClusterAZs=None, NumNodeGroups=None, ReplicasPerNodeGroup=None, NodeGroupConfiguration=None, CacheNodeType=None, Engine=None, EngineVersion=None, CacheParameterGroupName=None, CacheSubnetGroupName=None, CacheSecurityGroupNames=None, SecurityGroupIds=None, Tags=None, SnapshotArns=None, SnapshotName=None, PreferredMaintenanceWindow=None, Port=None, NotificationTopicArn=None, AutoMinorVersionUpgrade=None, SnapshotRetentionLimit=None, SnapshotWindow=None, AuthToken=None):\n    \"\"\"\n    Creates a Redis (cluster mode disabled) or a Redis (cluster mode enabled) replication group.\n    A Redis (cluster mode disabled) replication group is a collection of cache clusters, where one of the cache clusters is a read/write primary and the others are read-only replicas. Writes to the primary are asynchronously propagated to the replicas.\n    A Redis (cluster mode enabled) replication group is a collection of 1 to 15 node groups (shards). Each node group (shard) has one read/write primary node and up to 5 read-only replica nodes. Writes to the primary are asynchronously propagated to the replicas. Redis (cluster mode enabled) replication groups partition the data across node groups (shards).\n    When a Redis (cluster mode disabled) replication group has been successfully created, you can add one or more read replicas to it, up to a total of 5 read replicas. You cannot alter a Redis (cluster mode enabled) replication group after it has been created. However, if you need to increase or decrease the number of node groups (console: shards), you can avail yourself of ElastiCache for Redis' enhanced backup and restore. For more information, see Restoring From a Backup with Cluster Resizing in the ElastiCache User Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_replication_group(\n        ReplicationGroupId='string',\n        ReplicationGroupDescription='string',\n        PrimaryClusterId='string',\n        AutomaticFailoverEnabled=True|False,\n        NumCacheClusters=123,\n        PreferredCacheClusterAZs=[\n            'string',\n        ],\n        NumNodeGroups=123,\n        ReplicasPerNodeGroup=123,\n        NodeGroupConfiguration=[\n            {\n                'Slots': 'string',\n                'ReplicaCount': 123,\n                'PrimaryAvailabilityZone': 'string',\n                'ReplicaAvailabilityZones': [\n                    'string',\n                ]\n            },\n        ],\n        CacheNodeType='string',\n        Engine='string',\n        EngineVersion='string',\n        CacheParameterGroupName='string',\n        CacheSubnetGroupName='string',\n        CacheSecurityGroupNames=[\n            'string',\n        ],\n        SecurityGroupIds=[\n            'string',\n        ],\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        SnapshotArns=[\n            'string',\n        ],\n        SnapshotName='string',\n        PreferredMaintenanceWindow='string',\n        Port=123,\n        NotificationTopicArn='string',\n        AutoMinorVersionUpgrade=True|False,\n        SnapshotRetentionLimit=123,\n        SnapshotWindow='string',\n        AuthToken='string'\n    )\n    \n    \n    :type ReplicationGroupId: string\n    :param ReplicationGroupId: [REQUIRED]\n            The replication group identifier. This parameter is stored as a lowercase string.\n            Constraints:\n            A name must contain from 1 to 20 alphanumeric characters or hyphens.\n            The first character must be a letter.\n            A name cannot end with a hyphen or contain two consecutive hyphens.\n            \n\n    :type ReplicationGroupDescription: string\n    :param ReplicationGroupDescription: [REQUIRED]\n            A user-created description for the replication group.\n            \n\n    :type PrimaryClusterId: string\n    :param PrimaryClusterId: The identifier of the cache cluster that serves as the primary for this replication group. This cache cluster must already exist and have a status of available .\n            This parameter is not required if NumCacheClusters , NumNodeGroups , or ReplicasPerNodeGroup is specified.\n            \n\n    :type AutomaticFailoverEnabled: boolean\n    :param AutomaticFailoverEnabled: Specifies whether a read-only replica is automatically promoted to read/write primary if the existing primary fails.\n            If true , Multi-AZ is enabled for this replication group. If false , Multi-AZ is disabled for this replication group.\n            AutomaticFailoverEnabled must be enabled for Redis (cluster mode enabled) replication groups.\n            Default: false\n            Note\n            ElastiCache Multi-AZ replication groups is not supported on:\n            Redis versions earlier than 2.8.6.\n            Redis (cluster mode disabled): T1 and T2 node types. Redis (cluster mode enabled): T2 node types.\n            \n\n    :type NumCacheClusters: integer\n    :param NumCacheClusters: The number of clusters this replication group initially has.\n            This parameter is not used if there is more than one node group (shard). You should use ReplicasPerNodeGroup instead.\n            If AutomaticFailoverEnabled is true , the value of this parameter must be at least 2. If AutomaticFailoverEnabled is false you can omit this parameter (it will default to 1), or you can explicitly set it to a value between 2 and 6.\n            The maximum permitted value for NumCacheClusters is 6 (primary plus 5 replicas).\n            \n\n    :type PreferredCacheClusterAZs: list\n    :param PreferredCacheClusterAZs: A list of EC2 Availability Zones in which the replication group's cache clusters are created. The order of the Availability Zones in the list is the order in which clusters are allocated. The primary cluster is created in the first AZ in the list.\n            This parameter is not used if there is more than one node group (shard). You should use NodeGroupConfiguration instead.\n            Note\n            If you are creating your replication group in an Amazon VPC (recommended), you can only locate cache clusters in Availability Zones associated with the subnets in the selected subnet group.\n            The number of Availability Zones listed must equal the value of NumCacheClusters .\n            Default: system chosen Availability Zones.\n            (string) --\n            \n\n    :type NumNodeGroups: integer\n    :param NumNodeGroups: An optional parameter that specifies the number of node groups (shards) for this Redis (cluster mode enabled) replication group. For Redis (cluster mode disabled) either omit this parameter or set it to 1.\n            Default: 1\n            \n\n    :type ReplicasPerNodeGroup: integer\n    :param ReplicasPerNodeGroup: An optional parameter that specifies the number of replica nodes in each node group (shard). Valid values are 0 to 5.\n\n    :type NodeGroupConfiguration: list\n    :param NodeGroupConfiguration: A list of node group (shard) configuration options. Each node group (shard) configuration has the following: Slots, PrimaryAvailabilityZone, ReplicaAvailabilityZones, ReplicaCount.\n            If you're creating a Redis (cluster mode disabled) or a Redis (cluster mode enabled) replication group, you can use this parameter to individually configure each node group (shard), or you can omit this parameter.\n            (dict) --node group (shard) configuration options. Each node group (shard) configuration has the following: Slots , PrimaryAvailabilityZone , ReplicaAvailabilityZones , ReplicaCount .\n            Slots (string) --A string that specifies the keyspace for a particular node group. Keyspaces range from 0 to 16,383. The string is in the format startkey-endkey .\n            Example: '0-3999'\n            ReplicaCount (integer) --The number of read replica nodes in this node group (shard).\n            PrimaryAvailabilityZone (string) --The Availability Zone where the primary node of this node group (shard) is launched.\n            ReplicaAvailabilityZones (list) --A list of Availability Zones to be used for the read replicas. The number of Availability Zones in this list must match the value of ReplicaCount or ReplicasPerNodeGroup if not specified.\n            (string) --\n            \n            \n\n    :type CacheNodeType: string\n    :param CacheNodeType: The compute and memory capacity of the nodes in the node group (shard).\n            Valid node types are as follows:\n            General purpose:\n            Current generation: cache.t2.micro , cache.t2.small , cache.t2.medium , cache.m3.medium , cache.m3.large , cache.m3.xlarge , cache.m3.2xlarge , cache.m4.large , cache.m4.xlarge , cache.m4.2xlarge , cache.m4.4xlarge , cache.m4.10xlarge\n            Previous generation: cache.t1.micro , cache.m1.small , cache.m1.medium , cache.m1.large , cache.m1.xlarge\n            Compute optimized: cache.c1.xlarge\n            Memory optimized:\n            Current generation: cache.r3.large , cache.r3.xlarge , cache.r3.2xlarge , cache.r3.4xlarge , cache.r3.8xlarge\n            Previous generation: cache.m2.xlarge , cache.m2.2xlarge , cache.m2.4xlarge\n            \n            Notes:\n            All T2 instances are created in an Amazon Virtual Private Cloud (Amazon VPC).\n            Redis backup/restore is not supported for Redis (cluster mode disabled) T1 and T2 instances. Backup/restore is supported on Redis (cluster mode enabled) T2 instances.\n            Redis Append-only files (AOF) functionality is not supported for T1 or T2 instances.\n            For a complete listing of node types and specifications, see Amazon ElastiCache Product Features and Details and either Cache Node Type-Specific Parameters for Memcached or Cache Node Type-Specific Parameters for Redis .\n            \n\n    :type Engine: string\n    :param Engine: The name of the cache engine to be used for the cache clusters in this replication group.\n\n    :type EngineVersion: string\n    :param EngineVersion: The version number of the cache engine to be used for the cache clusters in this replication group. To view the supported cache engine versions, use the DescribeCacheEngineVersions operation.\n            Important: You can upgrade to a newer engine version (see Selecting a Cache Engine and Version ) in the ElastiCache User Guide , but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cache cluster or replication group and create it anew with the earlier engine version.\n            \n\n    :type CacheParameterGroupName: string\n    :param CacheParameterGroupName: The name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used.\n            If you are running Redis version 3.2.4 or later, only one node group (shard), and want to use a default parameter group, we recommend that you specify the parameter group by name.\n            To create a Redis (cluster mode disabled) replication group, use CacheParameterGroupName=default.redis3.2 .\n            To create a Redis (cluster mode enabled) replication group, use CacheParameterGroupName=default.redis3.2.cluster.on .\n            \n\n    :type CacheSubnetGroupName: string\n    :param CacheSubnetGroupName: The name of the cache subnet group to be used for the replication group.\n            Warning\n            If you're going to launch your cluster in an Amazon VPC, you need to create a subnet group before you start creating a cluster. For more information, see Subnets and Subnet Groups .\n            \n\n    :type CacheSecurityGroupNames: list\n    :param CacheSecurityGroupNames: A list of cache security group names to associate with this replication group.\n            (string) --\n            \n\n    :type SecurityGroupIds: list\n    :param SecurityGroupIds: One or more Amazon VPC security groups associated with this replication group.\n            Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud (Amazon VPC).\n            (string) --\n            \n\n    :type Tags: list\n    :param Tags: A list of cost allocation tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value.\n            (dict) --A cost allocation Tag that can be added to an ElastiCache cluster or replication group. Tags are composed of a Key/Value pair. A tag with a null Value is permitted.\n            Key (string) --The key for the tag. May not be null.\n            Value (string) --The tag's value. May be null.\n            \n            \n\n    :type SnapshotArns: list\n    :param SnapshotArns: A list of Amazon Resource Names (ARN) that uniquely identify the Redis RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new replication group. The Amazon S3 object name in the ARN cannot contain any commas. The new replication group will have the number of node groups (console: shards) specified by the parameter NumNodeGroups or the number of node groups configured by NodeGroupConfiguration regardless of the number of ARNs specified here.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            Example of an Amazon S3 ARN: arn:aws:s3:::my_bucket/snapshot1.rdb\n            (string) --\n            \n\n    :type SnapshotName: string\n    :param SnapshotName: The name of a snapshot from which to restore data into the new replication group. The snapshot status changes to restoring while the new replication group is being created.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: Specifies the weekly time range during which maintenance on the cache cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:\n            Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.\n            Valid values for ddd are:\n            sun\n            mon\n            tue\n            wed\n            thu\n            fri\n            sat\n            Example: sun:23:00-mon:01:30\n            \n\n    :type Port: integer\n    :param Port: The port number on which each member of the replication group accepts connections.\n\n    :type NotificationTopicArn: string\n    :param NotificationTopicArn: The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.\n            Note\n            The Amazon SNS topic owner must be the same as the cache cluster owner.\n            \n\n    :type AutoMinorVersionUpgrade: boolean\n    :param AutoMinorVersionUpgrade: This parameter is currently disabled.\n\n    :type SnapshotRetentionLimit: integer\n    :param SnapshotRetentionLimit: The number of days for which ElastiCache retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            Default: 0 (i.e., automatic backups are disabled for this cache cluster).\n            \n\n    :type SnapshotWindow: string\n    :param SnapshotWindow: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your node group (shard).\n            Example: 05:00-09:00\n            If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range.\n            Note\n            This parameter is only valid if the Engine parameter is redis .\n            \n\n    :type AuthToken: string\n    :param AuthToken: \n            Reserved parameter. The password used to access a password protected server.\n            Password constraints:\n            Must be only printable ASCII characters.\n            Must be at least 16 characters and no more than 128 characters in length.\n            Cannot contain any of the following characters: '/', ''', or '@'.\n            For more information, see AUTH password at Redis.\n            \n\n    :rtype: dict\n    :return: {\n        'ReplicationGroup': {\n            'ReplicationGroupId': 'string',\n            'Description': 'string',\n            'Status': 'string',\n            'PendingModifiedValues': {\n                'PrimaryClusterId': 'string',\n                'AutomaticFailoverStatus': 'enabled'|'disabled'\n            },\n            'MemberClusters': [\n                'string',\n            ],\n            'NodeGroups': [\n                {\n                    'NodeGroupId': 'string',\n                    'Status': 'string',\n                    'PrimaryEndpoint': {\n                        'Address': 'string',\n                        'Port': 123\n                    },\n                    'Slots': 'string',\n                    'NodeGroupMembers': [\n                        {\n                            'CacheClusterId': 'string',\n                            'CacheNodeId': 'string',\n                            'ReadEndpoint': {\n                                'Address': 'string',\n                                'Port': 123\n                            },\n                            'PreferredAvailabilityZone': 'string',\n                            'CurrentRole': 'string'\n                        },\n                    ]\n                },\n            ],\n            'SnapshottingClusterId': 'string',\n            'AutomaticFailover': 'enabled'|'disabled'|'enabling'|'disabling',\n            'ConfigurationEndpoint': {\n                'Address': 'string',\n                'Port': 123\n            },\n            'SnapshotRetentionLimit': 123,\n            'SnapshotWindow': 'string',\n            'ClusterEnabled': True|False,\n            'CacheNodeType': 'string'\n        }\n    }\n    \n    \n    :returns: \n    Redis versions earlier than 2.8.6.\n    Redis (cluster mode disabled):T1 and T2 cache node types. Redis (cluster mode enabled): T1 node types.\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modify_cache_cluster(CacheClusterId=None, NumCacheNodes=None, CacheNodeIdsToRemove=None, AZMode=None, NewAvailabilityZones=None, CacheSecurityGroupNames=None, SecurityGroupIds=None, PreferredMaintenanceWindow=None, NotificationTopicArn=None, CacheParameterGroupName=None, NotificationTopicStatus=None, ApplyImmediately=None, EngineVersion=None, AutoMinorVersionUpgrade=None, SnapshotRetentionLimit=None, SnapshotWindow=None, CacheNodeType=None):\n    pass", "response": "This function is used to modify the settings for a single or cross - az cache cluster. You can use this operation to change the settings for a single or cross - az cache cluster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmodify the settings for a replication group. See also: AWS API Documentation :example: response = client.modify_replication_group( ReplicationGroupId='string', ReplicationGroupDescription='string', PrimaryClusterId='string', SnapshottingClusterId='string', AutomaticFailoverEnabled=True|False, CacheSecurityGroupNames=[ 'string', ], SecurityGroupIds=[ 'string', ], PreferredMaintenanceWindow='string', NotificationTopicArn='string', CacheParameterGroupName='string', NotificationTopicStatus='string', ApplyImmediately=True|False, EngineVersion='string', AutoMinorVersionUpgrade=True|False, SnapshotRetentionLimit=123, SnapshotWindow='string', CacheNodeType='string', NodeGroupId='string' ) :type ReplicationGroupId: string :param ReplicationGroupId: [REQUIRED] The identifier of the replication group to modify. :type ReplicationGroupDescription: string :param ReplicationGroupDescription: A description for the replication group. Maximum length is 255 characters. :type PrimaryClusterId: string :param PrimaryClusterId: For replication groups with a single primary, if this parameter is specified, ElastiCache promotes the specified cluster in the specified replication group to the primary role. The nodes of all other clusters in the replication group are read replicas. :type SnapshottingClusterId: string :param SnapshottingClusterId: The cache cluster ID that is used as the daily snapshot source for the replication group. This parameter cannot be set for Redis (cluster mode enabled) replication groups. :type AutomaticFailoverEnabled: boolean :param AutomaticFailoverEnabled: Determines whether a read replica is automatically promoted to read/write primary if the existing primary encounters a failure. Valid values: true | false Note ElastiCache Multi-AZ replication groups are not supported on: Redis versions earlier than 2.8.6. Redis (cluster mode disabled):T1 and T2 cache node types. Redis (cluster mode enabled): T1 node types. :type CacheSecurityGroupNames: list :param CacheSecurityGroupNames: A list of cache security group names to authorize for the clusters in this replication group. This change is asynchronously applied as soon as possible. This parameter can be used only with replication group containing cache clusters running outside of an Amazon Virtual Private Cloud (Amazon VPC). Constraints: Must contain no more than 255 alphanumeric characters. Must not be Default . (string) -- :type SecurityGroupIds: list :param SecurityGroupIds: Specifies the VPC Security Groups associated with the cache clusters in the replication group. This parameter can be used only with replication group containing cache clusters running in an Amazon Virtual Private Cloud (Amazon VPC). (string) -- :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are: sun mon tue wed thu fri sat Example: sun:23:00-mon:01:30 :type NotificationTopicArn: string :param NotificationTopicArn: The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications are sent. Note The Amazon SNS topic owner must be same as the replication group owner. :type CacheParameterGroupName: string :param CacheParameterGroupName: The name of the cache parameter group to apply to all of the clusters in this replication group. This change is asynchronously applied as soon as possible for parameters when the ApplyImmediately parameter is specified as true for this request. :type NotificationTopicStatus: string :param NotificationTopicStatus: The status of the Amazon SNS notification topic for the replication group. Notifications are sent only if the status is active . Valid values: active | inactive :type ApplyImmediately: boolean :param ApplyImmediately: If true , this parameter causes the modifications in this request and any pending modifications to be applied, asynchronously and as soon as possible, regardless of the PreferredMaintenanceWindow setting for the replication group. If false , changes to the nodes in the replication group are applied on the next maintenance reboot, or the next failure reboot, whichever occurs first. Valid values: true | false Default: false :type EngineVersion: string :param EngineVersion: The upgraded version of the cache engine to be run on the cache clusters in the replication group. Important: You can upgrade to a newer engine version (see Selecting a Cache Engine and Version ), but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing replication group and create it anew with the earlier engine version. :type AutoMinorVersionUpgrade: boolean :param AutoMinorVersionUpgrade: This parameter is currently disabled. :type SnapshotRetentionLimit: integer :param SnapshotRetentionLimit: The number of days for which ElastiCache retains automatic node group (shard) snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted. Important If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off. :type SnapshotWindow: string :param SnapshotWindow: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of the node group (shard) specified by SnapshottingClusterId . Example: 05:00-09:00 If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range. :type CacheNodeType: string :param CacheNodeType: A valid cache node type that you want to scale this replication group to. :type NodeGroupId: string :param NodeGroupId: The name of the Node Group (called shard in the console). :rtype: dict :return: { 'ReplicationGroup': { 'ReplicationGroupId': 'string', 'Description': 'string', 'Status': 'string', 'PendingModifiedValues': { 'PrimaryClusterId': 'string', 'AutomaticFailoverStatus': 'enabled'|'disabled' }, 'MemberClusters': [ 'string', ], 'NodeGroups': [ { 'NodeGroupId': 'string', 'Status': 'string', 'PrimaryEndpoint': { 'Address': 'string', 'Port': 123 }, 'Slots': 'string', 'NodeGroupMembers': [ { 'CacheClusterId': 'string', 'CacheNodeId': 'string', 'ReadEndpoint': { 'Address': 'string', 'Port': 123 }, 'PreferredAvailabilityZone': 'string', 'CurrentRole': 'string' }, ] }, ], 'SnapshottingClusterId': 'string', 'AutomaticFailover': 'enabled'|'disabled'|'enabling'|'disabling', 'ConfigurationEndpoint': { 'Address': 'string', 'Port': 123 }, 'SnapshotRetentionLimit': 123, 'SnapshotWindow': 'string', 'ClusterEnabled': True|False, 'CacheNodeType': 'string' } } :returns: Redis versions earlier than 2.8.6. Redis (cluster mode disabled):T1 and T2 cache node types. Redis (cluster mode enabled): T1 node types.", "response": "def modify_replication_group(ReplicationGroupId=None, ReplicationGroupDescription=None, PrimaryClusterId=None, SnapshottingClusterId=None, AutomaticFailoverEnabled=None, CacheSecurityGroupNames=None, SecurityGroupIds=None, PreferredMaintenanceWindow=None, NotificationTopicArn=None, CacheParameterGroupName=None, NotificationTopicStatus=None, ApplyImmediately=None, EngineVersion=None, AutoMinorVersionUpgrade=None, SnapshotRetentionLimit=None, SnapshotWindow=None, CacheNodeType=None, NodeGroupId=None):\n    \"\"\"\n    Modifies the settings for a replication group.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.modify_replication_group(\n        ReplicationGroupId='string',\n        ReplicationGroupDescription='string',\n        PrimaryClusterId='string',\n        SnapshottingClusterId='string',\n        AutomaticFailoverEnabled=True|False,\n        CacheSecurityGroupNames=[\n            'string',\n        ],\n        SecurityGroupIds=[\n            'string',\n        ],\n        PreferredMaintenanceWindow='string',\n        NotificationTopicArn='string',\n        CacheParameterGroupName='string',\n        NotificationTopicStatus='string',\n        ApplyImmediately=True|False,\n        EngineVersion='string',\n        AutoMinorVersionUpgrade=True|False,\n        SnapshotRetentionLimit=123,\n        SnapshotWindow='string',\n        CacheNodeType='string',\n        NodeGroupId='string'\n    )\n    \n    \n    :type ReplicationGroupId: string\n    :param ReplicationGroupId: [REQUIRED]\n            The identifier of the replication group to modify.\n            \n\n    :type ReplicationGroupDescription: string\n    :param ReplicationGroupDescription: A description for the replication group. Maximum length is 255 characters.\n\n    :type PrimaryClusterId: string\n    :param PrimaryClusterId: For replication groups with a single primary, if this parameter is specified, ElastiCache promotes the specified cluster in the specified replication group to the primary role. The nodes of all other clusters in the replication group are read replicas.\n\n    :type SnapshottingClusterId: string\n    :param SnapshottingClusterId: The cache cluster ID that is used as the daily snapshot source for the replication group. This parameter cannot be set for Redis (cluster mode enabled) replication groups.\n\n    :type AutomaticFailoverEnabled: boolean\n    :param AutomaticFailoverEnabled: Determines whether a read replica is automatically promoted to read/write primary if the existing primary encounters a failure.\n            Valid values: true | false\n            Note\n            ElastiCache Multi-AZ replication groups are not supported on:\n            Redis versions earlier than 2.8.6.\n            Redis (cluster mode disabled):T1 and T2 cache node types. Redis (cluster mode enabled): T1 node types.\n            \n\n    :type CacheSecurityGroupNames: list\n    :param CacheSecurityGroupNames: A list of cache security group names to authorize for the clusters in this replication group. This change is asynchronously applied as soon as possible.\n            This parameter can be used only with replication group containing cache clusters running outside of an Amazon Virtual Private Cloud (Amazon VPC).\n            Constraints: Must contain no more than 255 alphanumeric characters. Must not be Default .\n            (string) --\n            \n\n    :type SecurityGroupIds: list\n    :param SecurityGroupIds: Specifies the VPC Security Groups associated with the cache clusters in the replication group.\n            This parameter can be used only with replication group containing cache clusters running in an Amazon Virtual Private Cloud (Amazon VPC).\n            (string) --\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.\n            Valid values for ddd are:\n            sun\n            mon\n            tue\n            wed\n            thu\n            fri\n            sat\n            Example: sun:23:00-mon:01:30\n            \n\n    :type NotificationTopicArn: string\n    :param NotificationTopicArn: The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications are sent.\n            Note\n            The Amazon SNS topic owner must be same as the replication group owner.\n            \n\n    :type CacheParameterGroupName: string\n    :param CacheParameterGroupName: The name of the cache parameter group to apply to all of the clusters in this replication group. This change is asynchronously applied as soon as possible for parameters when the ApplyImmediately parameter is specified as true for this request.\n\n    :type NotificationTopicStatus: string\n    :param NotificationTopicStatus: The status of the Amazon SNS notification topic for the replication group. Notifications are sent only if the status is active .\n            Valid values: active | inactive\n            \n\n    :type ApplyImmediately: boolean\n    :param ApplyImmediately: If true , this parameter causes the modifications in this request and any pending modifications to be applied, asynchronously and as soon as possible, regardless of the PreferredMaintenanceWindow setting for the replication group.\n            If false , changes to the nodes in the replication group are applied on the next maintenance reboot, or the next failure reboot, whichever occurs first.\n            Valid values: true | false\n            Default: false\n            \n\n    :type EngineVersion: string\n    :param EngineVersion: The upgraded version of the cache engine to be run on the cache clusters in the replication group.\n            Important: You can upgrade to a newer engine version (see Selecting a Cache Engine and Version ), but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing replication group and create it anew with the earlier engine version.\n            \n\n    :type AutoMinorVersionUpgrade: boolean\n    :param AutoMinorVersionUpgrade: This parameter is currently disabled.\n\n    :type SnapshotRetentionLimit: integer\n    :param SnapshotRetentionLimit: The number of days for which ElastiCache retains automatic node group (shard) snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.\n            Important If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off.\n            \n\n    :type SnapshotWindow: string\n    :param SnapshotWindow: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of the node group (shard) specified by SnapshottingClusterId .\n            Example: 05:00-09:00\n            If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range.\n            \n\n    :type CacheNodeType: string\n    :param CacheNodeType: A valid cache node type that you want to scale this replication group to.\n\n    :type NodeGroupId: string\n    :param NodeGroupId: The name of the Node Group (called shard in the console).\n\n    :rtype: dict\n    :return: {\n        'ReplicationGroup': {\n            'ReplicationGroupId': 'string',\n            'Description': 'string',\n            'Status': 'string',\n            'PendingModifiedValues': {\n                'PrimaryClusterId': 'string',\n                'AutomaticFailoverStatus': 'enabled'|'disabled'\n            },\n            'MemberClusters': [\n                'string',\n            ],\n            'NodeGroups': [\n                {\n                    'NodeGroupId': 'string',\n                    'Status': 'string',\n                    'PrimaryEndpoint': {\n                        'Address': 'string',\n                        'Port': 123\n                    },\n                    'Slots': 'string',\n                    'NodeGroupMembers': [\n                        {\n                            'CacheClusterId': 'string',\n                            'CacheNodeId': 'string',\n                            'ReadEndpoint': {\n                                'Address': 'string',\n                                'Port': 123\n                            },\n                            'PreferredAvailabilityZone': 'string',\n                            'CurrentRole': 'string'\n                        },\n                    ]\n                },\n            ],\n            'SnapshottingClusterId': 'string',\n            'AutomaticFailover': 'enabled'|'disabled'|'enabling'|'disabling',\n            'ConfigurationEndpoint': {\n                'Address': 'string',\n                'Port': 123\n            },\n            'SnapshotRetentionLimit': 123,\n            'SnapshotWindow': 'string',\n            'ClusterEnabled': True|False,\n            'CacheNodeType': 'string'\n        }\n    }\n    \n    \n    :returns: \n    Redis versions earlier than 2.8.6.\n    Redis (cluster mode disabled):T1 and T2 cache node types. Redis (cluster mode enabled): T1 node types.\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_job_flow(Name=None, LogUri=None, AdditionalInfo=None, AmiVersion=None, ReleaseLabel=None, Instances=None, Steps=None, BootstrapActions=None, SupportedProducts=None, NewSupportedProducts=None, Applications=None, Configurations=None, VisibleToAllUsers=None, JobFlowRole=None, ServiceRole=None, Tags=None, SecurityConfiguration=None, AutoScalingRole=None, ScaleDownBehavior=None):\n    pass", "response": "This function creates a new cluster and runs the specified steps."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of BatchPrediction operations that match the search criteria in the request. See also: AWS API Documentation :example: response = client.describe_batch_predictions( FilterVariable='CreatedAt'|'LastUpdatedAt'|'Status'|'Name'|'IAMUser'|'MLModelId'|'DataSourceId'|'DataURI', EQ='string', GT='string', LT='string', GE='string', LE='string', NE='string', Prefix='string', SortOrder='asc'|'dsc', NextToken='string', Limit=123 ) :type FilterVariable: string :param FilterVariable: Use one of the following variables to filter a list of BatchPrediction : CreatedAt - Sets the search criteria to the BatchPrediction creation date. Status - Sets the search criteria to the BatchPrediction status. Name - Sets the search criteria to the contents of the BatchPrediction **** Name . IAMUser - Sets the search criteria to the user account that invoked the BatchPrediction creation. MLModelId - Sets the search criteria to the MLModel used in the BatchPrediction . DataSourceId - Sets the search criteria to the DataSource used in the BatchPrediction . DataURI - Sets the search criteria to the data file(s) used in the BatchPrediction . The URL can identify either a file or an Amazon Simple Storage Solution (Amazon S3) bucket or directory. :type EQ: string :param EQ: The equal to operator. The BatchPrediction results will have FilterVariable values that exactly match the value specified with EQ . :type GT: string :param GT: The greater than operator. The BatchPrediction results will have FilterVariable values that are greater than the value specified with GT . :type LT: string :param LT: The less than operator. The BatchPrediction results will have FilterVariable values that are less than the value specified with LT . :type GE: string :param GE: The greater than or equal to operator. The BatchPrediction results will have FilterVariable values that are greater than or equal to the value specified with GE . :type LE: string :param LE: The less than or equal to operator. The BatchPrediction results will have FilterVariable values that are less than or equal to the value specified with LE . :type NE: string :param NE: The not equal to operator. The BatchPrediction results will have FilterVariable values not equal to the value specified with NE . :type Prefix: string :param Prefix: A string that is found at the beginning of a variable, such as Name or Id . For example, a Batch Prediction operation could have the Name 2014-09-09-HolidayGiftMailer . To search for this BatchPrediction , select Name for the FilterVariable and any of the following strings for the Prefix : 2014-09 2014-09-09 2014-09-09-Holiday :type SortOrder: string :param SortOrder: A two-value parameter that determines the sequence of the resulting list of MLModel s. asc - Arranges the list in ascending order (A-Z, 0-9). dsc - Arranges the list in descending order (Z-A, 9-0). Results are sorted by FilterVariable . :type NextToken: string :param NextToken: An ID of the page in the paginated results. :type Limit: integer :param Limit: The number of pages of information to include in the result. The range of acceptable values is 1 through 100 . The default value is 100 . :rtype: dict :return: { 'Results': [ { 'BatchPredictionId': 'string', 'MLModelId': 'string', 'BatchPredictionDataSourceId': 'string', 'InputDataLocationS3': 'string', 'CreatedByIamUser': 'string', 'CreatedAt': datetime(2015, 1, 1), 'LastUpdatedAt': datetime(2015, 1, 1), 'Name': 'string', 'Status': 'PENDING'|'INPROGRESS'|'FAILED'|'COMPLETED'|'DELETED', 'OutputUri': 'string', 'Message': 'string', 'ComputeTime': 123, 'FinishedAt': datetime(2015, 1, 1), 'StartedAt': datetime(2015, 1, 1), 'TotalRecordCount': 123, 'InvalidRecordCount': 123 }, ], 'NextToken': 'string' } :returns: PENDING - Amazon Machine Learning (Amazon ML) submitted a request to generate predictions for a batch of observations. INPROGRESS - The process is underway. FAILED - The request to perform a batch prediction did not run to completion. It is not usable. COMPLETED - The batch prediction process completed successfully. DELETED - The BatchPrediction is marked as deleted. It is not usable.", "response": "def describe_batch_predictions(FilterVariable=None, EQ=None, GT=None, LT=None, GE=None, LE=None, NE=None, Prefix=None, SortOrder=None, NextToken=None, Limit=None):\n    \"\"\"\n    Returns a list of BatchPrediction operations that match the search criteria in the request.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.describe_batch_predictions(\n        FilterVariable='CreatedAt'|'LastUpdatedAt'|'Status'|'Name'|'IAMUser'|'MLModelId'|'DataSourceId'|'DataURI',\n        EQ='string',\n        GT='string',\n        LT='string',\n        GE='string',\n        LE='string',\n        NE='string',\n        Prefix='string',\n        SortOrder='asc'|'dsc',\n        NextToken='string',\n        Limit=123\n    )\n    \n    \n    :type FilterVariable: string\n    :param FilterVariable: Use one of the following variables to filter a list of BatchPrediction :\n            CreatedAt - Sets the search criteria to the BatchPrediction creation date.\n            Status - Sets the search criteria to the BatchPrediction status.\n            Name - Sets the search criteria to the contents of the BatchPrediction **** Name .\n            IAMUser - Sets the search criteria to the user account that invoked the BatchPrediction creation.\n            MLModelId - Sets the search criteria to the MLModel used in the BatchPrediction .\n            DataSourceId - Sets the search criteria to the DataSource used in the BatchPrediction .\n            DataURI - Sets the search criteria to the data file(s) used in the BatchPrediction . The URL can identify either a file or an Amazon Simple Storage Solution (Amazon S3) bucket or directory.\n            \n\n    :type EQ: string\n    :param EQ: The equal to operator. The BatchPrediction results will have FilterVariable values that exactly match the value specified with EQ .\n\n    :type GT: string\n    :param GT: The greater than operator. The BatchPrediction results will have FilterVariable values that are greater than the value specified with GT .\n\n    :type LT: string\n    :param LT: The less than operator. The BatchPrediction results will have FilterVariable values that are less than the value specified with LT .\n\n    :type GE: string\n    :param GE: The greater than or equal to operator. The BatchPrediction results will have FilterVariable values that are greater than or equal to the value specified with GE .\n\n    :type LE: string\n    :param LE: The less than or equal to operator. The BatchPrediction results will have FilterVariable values that are less than or equal to the value specified with LE .\n\n    :type NE: string\n    :param NE: The not equal to operator. The BatchPrediction results will have FilterVariable values not equal to the value specified with NE .\n\n    :type Prefix: string\n    :param Prefix: A string that is found at the beginning of a variable, such as Name or Id .\n            For example, a Batch Prediction operation could have the Name 2014-09-09-HolidayGiftMailer . To search for this BatchPrediction , select Name for the FilterVariable and any of the following strings for the Prefix :\n            2014-09\n            2014-09-09\n            2014-09-09-Holiday\n            \n\n    :type SortOrder: string\n    :param SortOrder: A two-value parameter that determines the sequence of the resulting list of MLModel s.\n            asc - Arranges the list in ascending order (A-Z, 0-9).\n            dsc - Arranges the list in descending order (Z-A, 9-0).\n            Results are sorted by FilterVariable .\n            \n\n    :type NextToken: string\n    :param NextToken: An ID of the page in the paginated results.\n\n    :type Limit: integer\n    :param Limit: The number of pages of information to include in the result. The range of acceptable values is 1 through 100 . The default value is 100 .\n\n    :rtype: dict\n    :return: {\n        'Results': [\n            {\n                'BatchPredictionId': 'string',\n                'MLModelId': 'string',\n                'BatchPredictionDataSourceId': 'string',\n                'InputDataLocationS3': 'string',\n                'CreatedByIamUser': 'string',\n                'CreatedAt': datetime(2015, 1, 1),\n                'LastUpdatedAt': datetime(2015, 1, 1),\n                'Name': 'string',\n                'Status': 'PENDING'|'INPROGRESS'|'FAILED'|'COMPLETED'|'DELETED',\n                'OutputUri': 'string',\n                'Message': 'string',\n                'ComputeTime': 123,\n                'FinishedAt': datetime(2015, 1, 1),\n                'StartedAt': datetime(2015, 1, 1),\n                'TotalRecordCount': 123,\n                'InvalidRecordCount': 123\n            },\n        ],\n        'NextToken': 'string'\n    }\n    \n    \n    :returns: \n    PENDING - Amazon Machine Learning (Amazon ML) submitted a request to generate predictions for a batch of observations.\n    INPROGRESS - The process is underway.\n    FAILED - The request to perform a batch prediction did not run to completion. It is not usable.\n    COMPLETED - The batch prediction process completed successfully.\n    DELETED - The BatchPrediction is marked as deleted. It is not usable.\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_item(TableName=None, Key=None, Expected=None, ConditionalOperator=None, ReturnValues=None, ReturnConsumedCapacity=None, ReturnItemCollectionMetrics=None, ConditionExpression=None, ExpressionAttributeNames=None, ExpressionAttributeValues=None):\n    pass", "response": "This function deletes an item from a Music table by primary key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef put_item(TableName=None, Item=None, Expected=None, ReturnValues=None, ReturnConsumedCapacity=None, ReturnItemCollectionMetrics=None, ConditionalOperator=None, ConditionExpression=None, ExpressionAttributeNames=None, ExpressionAttributeValues=None):\n    pass", "response": "This function creates a new item or replaces an existing item with a new item."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query(TableName=None, IndexName=None, Select=None, AttributesToGet=None, Limit=None, ConsistentRead=None, KeyConditions=None, QueryFilter=None, ConditionalOperator=None, ScanIndexForward=None, ExclusiveStartKey=None, ReturnConsumedCapacity=None, ProjectionExpression=None, FilterExpression=None, KeyConditionExpression=None, ExpressionAttributeNames=None, ExpressionAttributeValues=None):\n    pass", "response": "This function performs a query on a Music table or index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_item(TableName=None, Key=None, AttributeUpdates=None, Expected=None, ConditionalOperator=None, ReturnValues=None, ReturnConsumedCapacity=None, ReturnItemCollectionMetrics=None, UpdateExpression=None, ConditionExpression=None, ExpressionAttributeNames=None, ExpressionAttributeValues=None):\n    pass", "response": "This function updates an item in the Music table. You can update an item in the Music table or adds a new item to the Music table. You can also update an item in the Music table using the UpdateItem operation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new service in the specified cluster.", "response": "def create_service(cluster=None, serviceName=None, taskDefinition=None, loadBalancers=None, desiredCount=None, clientToken=None, role=None, deploymentConfiguration=None, placementConstraints=None, placementStrategy=None):\n    \"\"\"\n    Runs and maintains a desired number of tasks from a specified task definition. If the number of tasks running in a service drops below desiredCount , Amazon ECS spawns another copy of the task in the specified cluster. To update an existing service, see  UpdateService .\n    In addition to maintaining the desired count of tasks in your service, you can optionally run your service behind a load balancer. The load balancer distributes traffic across the tasks that are associated with the service. For more information, see Service Load Balancing in the Amazon EC2 Container Service Developer Guide .\n    You can optionally specify a deployment configuration for your service. During a deployment (which is triggered by changing the task definition or the desired count of a service with an  UpdateService operation), the service scheduler uses the minimumHealthyPercent and maximumPercent parameters to determine the deployment strategy.\n    The minimumHealthyPercent represents a lower limit on the number of your service's tasks that must remain in the RUNNING state during a deployment, as a percentage of the desiredCount (rounded up to the nearest integer). This parameter enables you to deploy without using additional cluster capacity. For example, if your service has a desiredCount of four tasks and a minimumHealthyPercent of 50%, the scheduler can stop two existing tasks to free up cluster capacity before starting two new tasks. Tasks for services that do not use a load balancer are considered healthy if they are in the RUNNING state. Tasks for services that do use a load balancer are considered healthy if they are in the RUNNING state and the container instance they are hosted on is reported as healthy by the load balancer. The default value for minimumHealthyPercent is 50% in the console and 100% for the AWS CLI, the AWS SDKs, and the APIs.\n    The maximumPercent parameter represents an upper limit on the number of your service's tasks that are allowed in the RUNNING or PENDING state during a deployment, as a percentage of the desiredCount (rounded down to the nearest integer). This parameter enables you to define the deployment batch size. For example, if your service has a desiredCount of four tasks and a maximumPercent value of 200%, the scheduler can start four new tasks before stopping the four older tasks (provided that the cluster resources required to do this are available). The default value for maximumPercent is 200%.\n    When the service scheduler launches new tasks, it determines task placement in your cluster using the following logic:\n    See also: AWS API Documentation\n    \n    Examples\n    This example creates a service in your default region called ecs-simple-service. The service uses the hello_world task definition and it maintains 10 copies of that task.\n    Expected Output:\n    This example creates a service in your default region called ecs-simple-service-elb. The service uses the ecs-demo task definition and it maintains 10 copies of that task. You must reference an existing load balancer in the same region by its name.\n    Expected Output:\n    \n    :example: response = client.create_service(\n        cluster='string',\n        serviceName='string',\n        taskDefinition='string',\n        loadBalancers=[\n            {\n                'targetGroupArn': 'string',\n                'loadBalancerName': 'string',\n                'containerName': 'string',\n                'containerPort': 123\n            },\n        ],\n        desiredCount=123,\n        clientToken='string',\n        role='string',\n        deploymentConfiguration={\n            'maximumPercent': 123,\n            'minimumHealthyPercent': 123\n        },\n        placementConstraints=[\n            {\n                'type': 'distinctInstance'|'memberOf',\n                'expression': 'string'\n            },\n        ],\n        placementStrategy=[\n            {\n                'type': 'random'|'spread'|'binpack',\n                'field': 'string'\n            },\n        ]\n    )\n    \n    \n    :type cluster: string\n    :param cluster: The short name or full Amazon Resource Name (ARN) of the cluster on which to run your service. If you do not specify a cluster, the default cluster is assumed.\n\n    :type serviceName: string\n    :param serviceName: [REQUIRED]\n            The name of your service. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed. Service names must be unique within a cluster, but you can have similarly named services in multiple clusters within a region or across multiple regions.\n            \n\n    :type taskDefinition: string\n    :param taskDefinition: [REQUIRED]\n            The family and revision (family:revision ) or full Amazon Resource Name (ARN) of the task definition to run in your service. If a revision is not specified, the latest ACTIVE revision is used.\n            \n\n    :type loadBalancers: list\n    :param loadBalancers: A load balancer object representing the load balancer to use with your service. Currently, you are limited to one load balancer or target group per service. After you create a service, the load balancer name or target group ARN, container name, and container port specified in the service definition are immutable.\n            For Elastic Load Balancing Classic load balancers, this object must contain the load balancer name, the container name (as it appears in a container definition), and the container port to access from the load balancer. When a task from this service is placed on a container instance, the container instance is registered with the load balancer specified here.\n            For Elastic Load Balancing Application load balancers, this object must contain the load balancer target group ARN, the container name (as it appears in a container definition), and the container port to access from the load balancer. When a task from this service is placed on a container instance, the container instance and port combination is registered as a target in the target group specified here.\n            (dict) --Details on a load balancer that is used with a service.\n            targetGroupArn (string) --The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group associated with a service.\n            loadBalancerName (string) --The name of a Classic load balancer.\n            containerName (string) --The name of the container (as it appears in a container definition) to associate with the load balancer.\n            containerPort (integer) --The port on the container to associate with the load balancer. This port must correspond to a containerPort in the service's task definition. Your container instances must allow ingress traffic on the hostPort of the port mapping.\n            \n            \n\n    :type desiredCount: integer\n    :param desiredCount: [REQUIRED]\n            The number of instantiations of the specified task definition to place and keep running on your cluster.\n            \n\n    :type clientToken: string\n    :param clientToken: Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.\n\n    :type role: string\n    :param role: The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service. If you specify the role parameter, you must also specify a load balancer object with the loadBalancers parameter.\n            If your specified role has a path other than / , then you must either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a role with the name bar has a path of /foo/ then you would specify /foo/bar as the role name. For more information, see Friendly Names and Paths in the IAM User Guide .\n            \n\n    :type deploymentConfiguration: dict\n    :param deploymentConfiguration: Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.\n            maximumPercent (integer) --The upper limit (as a percentage of the service's desiredCount ) of the number of tasks that are allowed in the RUNNING or PENDING state in a service during a deployment. The maximum number of tasks during a deployment is the desiredCount multiplied by maximumPercent /100, rounded down to the nearest integer value.\n            minimumHealthyPercent (integer) --The lower limit (as a percentage of the service's desiredCount ) of the number of running tasks that must remain in the RUNNING state in a service during a deployment. The minimum healthy tasks during a deployment is the desiredCount multiplied by minimumHealthyPercent /100, rounded up to the nearest integer value.\n            \n\n    :type placementConstraints: list\n    :param placementConstraints: An array of placement constraint objects to use for tasks in your service. You can specify a maximum of 10 constraints per task (this limit includes constraints in the task definition and those specified at run time).\n            (dict) --An object representing a constraint on task placement. For more information, see Task Placement Constraints in the Amazon EC2 Container Service Developer Guide .\n            type (string) --The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict selection to a group of valid candidates. Note that distinctInstance is not supported in task definitions.\n            expression (string) --A cluster query language expression to apply to the constraint. Note you cannot specify an expression if the constraint type is distinctInstance . For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide .\n            \n            \n\n    :type placementStrategy: list\n    :param placementStrategy: The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules per service.\n            (dict) --The task placement strategy for a task or service. For more information, see Task Placement Strategies in the Amazon EC2 Container Service Developer Guide .\n            type (string) --The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).\n            field (string) --The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host , which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone . For the binpack placement strategy, valid values are cpu and memory . For the random placement strategy, this field is not used.\n            \n            \n\n    :rtype: dict\n    :return: {\n        'service': {\n            'serviceArn': 'string',\n            'serviceName': 'string',\n            'clusterArn': 'string',\n            'loadBalancers': [\n                {\n                    'targetGroupArn': 'string',\n                    'loadBalancerName': 'string',\n                    'containerName': 'string',\n                    'containerPort': 123\n                },\n            ],\n            'status': 'string',\n            'desiredCount': 123,\n            'runningCount': 123,\n            'pendingCount': 123,\n            'taskDefinition': 'string',\n            'deploymentConfiguration': {\n                'maximumPercent': 123,\n                'minimumHealthyPercent': 123\n            },\n            'deployments': [\n                {\n                    'id': 'string',\n                    'status': 'string',\n                    'taskDefinition': 'string',\n                    'desiredCount': 123,\n                    'pendingCount': 123,\n                    'runningCount': 123,\n                    'createdAt': datetime(2015, 1, 1),\n                    'updatedAt': datetime(2015, 1, 1)\n                },\n            ],\n            'roleArn': 'string',\n            'events': [\n                {\n                    'id': 'string',\n                    'createdAt': datetime(2015, 1, 1),\n                    'message': 'string'\n                },\n            ],\n            'createdAt': datetime(2015, 1, 1),\n            'placementConstraints': [\n                {\n                    'type': 'distinctInstance'|'memberOf',\n                    'expression': 'string'\n                },\n            ],\n            'placementStrategy': [\n                {\n                    'type': 'random'|'spread'|'binpack',\n                    'field': 'string'\n                },\n            ]\n        }\n    }\n    \n    \n    :returns: \n    cluster (string) -- The short name or full Amazon Resource Name (ARN) of the cluster on which to run your service. If you do not specify a cluster, the default cluster is assumed.\n    serviceName (string) -- [REQUIRED]\n    The name of your service. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed. Service names must be unique within a cluster, but you can have similarly named services in multiple clusters within a region or across multiple regions.\n    \n    taskDefinition (string) -- [REQUIRED]\n    The family and revision (family:revision ) or full Amazon Resource Name (ARN) of the task definition to run in your service. If a revision is not specified, the latest ACTIVE revision is used.\n    \n    loadBalancers (list) -- A load balancer object representing the load balancer to use with your service. Currently, you are limited to one load balancer or target group per service. After you create a service, the load balancer name or target group ARN, container name, and container port specified in the service definition are immutable.\n    For Elastic Load Balancing Classic load balancers, this object must contain the load balancer name, the container name (as it appears in a container definition), and the container port to access from the load balancer. When a task from this service is placed on a container instance, the container instance is registered with the load balancer specified here.\n    For Elastic Load Balancing Application load balancers, this object must contain the load balancer target group ARN, the container name (as it appears in a container definition), and the container port to access from the load balancer. When a task from this service is placed on a container instance, the container instance and port combination is registered as a target in the target group specified here.\n    \n    (dict) --Details on a load balancer that is used with a service.\n    \n    targetGroupArn (string) --The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group associated with a service.\n    \n    loadBalancerName (string) --The name of a Classic load balancer.\n    \n    containerName (string) --The name of the container (as it appears in a container definition) to associate with the load balancer.\n    \n    containerPort (integer) --The port on the container to associate with the load balancer. This port must correspond to a containerPort in the service's task definition. Your container instances must allow ingress traffic on the hostPort of the port mapping.\n    \n    \n    \n    \n    \n    desiredCount (integer) -- [REQUIRED]\n    The number of instantiations of the specified task definition to place and keep running on your cluster.\n    \n    clientToken (string) -- Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.\n    role (string) -- The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service. If you specify the role parameter, you must also specify a load balancer object with the loadBalancers parameter.\n    If your specified role has a path other than / , then you must either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a role with the name bar has a path of /foo/ then you would specify /foo/bar as the role name. For more information, see Friendly Names and Paths in the IAM User Guide .\n    \n    deploymentConfiguration (dict) -- Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.\n    \n    maximumPercent (integer) --The upper limit (as a percentage of the service's desiredCount ) of the number of tasks that are allowed in the RUNNING or PENDING state in a service during a deployment. The maximum number of tasks during a deployment is the desiredCount multiplied by maximumPercent /100, rounded down to the nearest integer value.\n    \n    minimumHealthyPercent (integer) --The lower limit (as a percentage of the service's desiredCount ) of the number of running tasks that must remain in the RUNNING state in a service during a deployment. The minimum healthy tasks during a deployment is the desiredCount multiplied by minimumHealthyPercent /100, rounded up to the nearest integer value.\n    \n    \n    \n    placementConstraints (list) -- An array of placement constraint objects to use for tasks in your service. You can specify a maximum of 10 constraints per task (this limit includes constraints in the task definition and those specified at run time).\n    \n    (dict) --An object representing a constraint on task placement. For more information, see Task Placement Constraints in the Amazon EC2 Container Service Developer Guide .\n    \n    type (string) --The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict selection to a group of valid candidates. Note that distinctInstance is not supported in task definitions.\n    \n    expression (string) --A cluster query language expression to apply to the constraint. Note you cannot specify an expression if the constraint type is distinctInstance . For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide .\n    \n    \n    \n    \n    \n    placementStrategy (list) -- The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules per service.\n    \n    (dict) --The task placement strategy for a task or service. For more information, see Task Placement Strategies in the Amazon EC2 Container Service Developer Guide .\n    \n    type (string) --The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).\n    \n    field (string) --The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host , which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone . For the binpack placement strategy, valid values are cpu and memory . For the random placement strategy, this field is not used.\n    \n    \n    \n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_domain(DomainName=None, IdnLangCode=None, DurationInYears=None, AutoRenew=None, AdminContact=None, RegistrantContact=None, TechContact=None, PrivacyProtectAdminContact=None, PrivacyProtectRegistrantContact=None, PrivacyProtectTechContact=None):\n    pass", "response": "This operation registers a domain in Amazon Route 53."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef simulate_custom_policy(PolicyInputList=None, ActionNames=None, ResourceArns=None, ResourcePolicy=None, ResourceOwner=None, CallerArn=None, ContextEntries=None, ResourceHandlingOption=None, MaxItems=None, Marker=None):\n    pass", "response": "Simulate how a set of IAM policies and optionally a resource - based policy works with a list of API actions and AWS resources."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsimulate a set of IAM policies attached to a principal entity.", "response": "def simulate_principal_policy(PolicySourceArn=None, PolicyInputList=None, ActionNames=None, ResourceArns=None, ResourcePolicy=None, ResourceOwner=None, CallerArn=None, ContextEntries=None, ResourceHandlingOption=None, MaxItems=None, Marker=None):\n    \"\"\"\n    Simulate how a set of IAM policies attached to an IAM entity works with a list of API actions and AWS resources to determine the policies' effective permissions. The entity can be an IAM user, group, or role. If you specify a user, then the simulation also includes all of the policies that are attached to groups that the user belongs to .\n    You can optionally include a list of one or more additional policies specified as strings to include in the simulation. If you want to simulate only policies specified as strings, use  SimulateCustomPolicy instead.\n    You can also optionally include one resource-based policy to be evaluated with each of the resources included in the simulation.\n    The simulation does not perform the API actions, it only checks the authorization to determine if the simulated policies allow or deny the actions.\n    Context keys are variables maintained by AWS and its services that provide details about the context of an API query request. You can use the Condition element of an IAM policy to evaluate context keys. To get the list of context keys that the policies require for correct simulation, use  GetContextKeysForPrincipalPolicy .\n    If the output is long, you can use the MaxItems and Marker parameters to paginate the results.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.simulate_principal_policy(\n        PolicySourceArn='string',\n        PolicyInputList=[\n            'string',\n        ],\n        ActionNames=[\n            'string',\n        ],\n        ResourceArns=[\n            'string',\n        ],\n        ResourcePolicy='string',\n        ResourceOwner='string',\n        CallerArn='string',\n        ContextEntries=[\n            {\n                'ContextKeyName': 'string',\n                'ContextKeyValues': [\n                    'string',\n                ],\n                'ContextKeyType': 'string'|'stringList'|'numeric'|'numericList'|'boolean'|'booleanList'|'ip'|'ipList'|'binary'|'binaryList'|'date'|'dateList'\n            },\n        ],\n        ResourceHandlingOption='string',\n        MaxItems=123,\n        Marker='string'\n    )\n    \n    \n    :type PolicySourceArn: string\n    :param PolicySourceArn: [REQUIRED]\n            The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to include in the simulation. If you specify a user, group, or role, the simulation includes all policies that are associated with that entity. If you specify a user, the simulation also includes all policies that are attached to any groups the user belongs to.\n            For more information about ARNs, see Amazon Resource Names (ARNs) and AWS Service Namespaces in the AWS General Reference .\n            \n\n    :type PolicyInputList: list\n    :param PolicyInputList: An optional list of additional policy documents to include in the simulation. Each document is specified as a string containing the complete, valid JSON text of an IAM policy.\n            The regex pattern used to validate this parameter is a string of characters consisting of any printable ASCII character ranging from the space character (u0020) through end of the ASCII character range as well as the printable characters in the Basic Latin and Latin-1 Supplement character set (through u00FF). It also includes the special characters tab (u0009), line feed (u000A), and carriage return (u000D).\n            (string) --\n            \n\n    :type ActionNames: list\n    :param ActionNames: [REQUIRED]\n            A list of names of API actions to evaluate in the simulation. Each action is evaluated for each resource. Each action must include the service identifier, such as iam:CreateUser .\n            (string) --\n            \n\n    :type ResourceArns: list\n    :param ResourceArns: A list of ARNs of AWS resources to include in the simulation. If this parameter is not provided then the value defaults to * (all resources). Each API in the ActionNames parameter is evaluated for each resource in this list. The simulation determines the access result (allowed or denied) of each combination and reports it in the response.\n            The simulation does not automatically retrieve policies for the specified resources. If you want to include a resource policy in the simulation, then you must include the policy as a string in the ResourcePolicy parameter.\n            For more information about ARNs, see Amazon Resource Names (ARNs) and AWS Service Namespaces in the AWS General Reference .\n            (string) --\n            \n\n    :type ResourcePolicy: string\n    :param ResourcePolicy: A resource-based policy to include in the simulation provided as a string. Each resource in the simulation is treated as if it had this policy attached. You can include only one resource-based policy in a simulation.\n            The regex pattern used to validate this parameter is a string of characters consisting of any printable ASCII character ranging from the space character (u0020) through end of the ASCII character range as well as the printable characters in the Basic Latin and Latin-1 Supplement character set (through u00FF). It also includes the special characters tab (u0009), line feed (u000A), and carriage return (u000D).\n            \n\n    :type ResourceOwner: string\n    :param ResourceOwner: An AWS account ID that specifies the owner of any simulated resource that does not identify its owner in the resource ARN, such as an S3 bucket or object. If ResourceOwner is specified, it is also used as the account owner of any ResourcePolicy included in the simulation. If the ResourceOwner parameter is not specified, then the owner of the resources and the resource policy defaults to the account of the identity provided in CallerArn . This parameter is required only if you specify a resource-based policy and account that owns the resource is different from the account that owns the simulated calling user CallerArn .\n\n    :type CallerArn: string\n    :param CallerArn: The ARN of the IAM user that you want to specify as the simulated caller of the APIs. If you do not specify a CallerArn , it defaults to the ARN of the user that you specify in PolicySourceArn , if you specified a user. If you include both a PolicySourceArn (for example, arn:aws:iam::123456789012:user/David ) and a CallerArn (for example, arn:aws:iam::123456789012:user/Bob ), the result is that you simulate calling the APIs as Bob, as if Bob had David's policies.\n            You can specify only the ARN of an IAM user. You cannot specify the ARN of an assumed role, federated user, or a service principal.\n            CallerArn is required if you include a ResourcePolicy and the PolicySourceArn is not the ARN for an IAM user. This is required so that the resource-based policy's Principal element has a value to use in evaluating the policy.\n            For more information about ARNs, see Amazon Resource Names (ARNs) and AWS Service Namespaces in the AWS General Reference .\n            \n\n    :type ContextEntries: list\n    :param ContextEntries: A list of context keys and corresponding values for the simulation to use. Whenever a context key is evaluated in one of the simulated IAM permission policies, the corresponding value is supplied.\n            (dict) --Contains information about a condition context key. It includes the name of the key and specifies the value (or values, if the context key supports multiple values) to use in the simulation. This information is used when evaluating the Condition elements of the input policies.\n            This data type is used as an input parameter to `` SimulateCustomPolicy `` and `` SimulateCustomPolicy `` .\n            ContextKeyName (string) --The full name of a condition context key, including the service prefix. For example, aws:SourceIp or s3:VersionId .\n            ContextKeyValues (list) --The value (or values, if the condition context key supports multiple values) to provide to the simulation for use when the key is referenced by a Condition element in an input policy.\n            (string) --\n            ContextKeyType (string) --The data type of the value (or values) specified in the ContextKeyValues parameter.\n            \n            \n\n    :type ResourceHandlingOption: string\n    :param ResourceHandlingOption: Specifies the type of simulation to run. Different APIs that support resource-based policies require different combinations of resources. By specifying the type of simulation to run, you enable the policy simulator to enforce the presence of the required resources to ensure reliable simulation results. If your simulation does not match one of the following scenarios, then you can omit this parameter. The following list shows each of the supported scenario values and the resources that you must define to run the simulation.\n            Each of the EC2 scenarios requires that you specify instance, image, and security-group resources. If your scenario includes an EBS volume, then you must specify that volume as a resource. If the EC2 scenario includes VPC, then you must supply the network-interface resource. If it includes an IP subnet, then you must specify the subnet resource. For more information on the EC2 scenario options, see Supported Platforms in the AWS EC2 User Guide .\n            EC2-Classic-InstanceStore  instance, image, security-group\n            EC2-Classic-EBS  instance, image, security-group, volume\n            EC2-VPC-InstanceStore  instance, image, security-group, network-interface\n            EC2-VPC-InstanceStore-Subnet  instance, image, security-group, network-interface, subnet\n            EC2-VPC-EBS  instance, image, security-group, network-interface, volume\n            EC2-VPC-EBS-Subnet  instance, image, security-group, network-interface, subnet, volume\n            \n\n    :type MaxItems: integer\n    :param MaxItems: (Optional) Use this only when paginating results to indicate the maximum number of items you want in the response. If additional items exist beyond the maximum you specify, the IsTruncated response element is true .\n            If you do not include this parameter, it defaults to 100. Note that IAM might return fewer results, even when there are more results available. In that case, the IsTruncated response element returns true and Marker contains a value to include in the subsequent call that tells the service where to continue from.\n            \n\n    :type Marker: string\n    :param Marker: Use this parameter only when paginating results and only after you receive a response indicating that the results are truncated. Set it to the value of the Marker element in the response that you received to indicate where the next call should start.\n\n    :rtype: dict\n    :return: {\n        'EvaluationResults': [\n            {\n                'EvalActionName': 'string',\n                'EvalResourceName': 'string',\n                'EvalDecision': 'allowed'|'explicitDeny'|'implicitDeny',\n                'MatchedStatements': [\n                    {\n                        'SourcePolicyId': 'string',\n                        'SourcePolicyType': 'user'|'group'|'role'|'aws-managed'|'user-managed'|'resource'|'none',\n                        'StartPosition': {\n                            'Line': 123,\n                            'Column': 123\n                        },\n                        'EndPosition': {\n                            'Line': 123,\n                            'Column': 123\n                        }\n                    },\n                ],\n                'MissingContextValues': [\n                    'string',\n                ],\n                'OrganizationsDecisionDetail': {\n                    'AllowedByOrganizations': True|False\n                },\n                'EvalDecisionDetails': {\n                    'string': 'allowed'|'explicitDeny'|'implicitDeny'\n                },\n                'ResourceSpecificResults': [\n                    {\n                        'EvalResourceName': 'string',\n                        'EvalResourceDecision': 'allowed'|'explicitDeny'|'implicitDeny',\n                        'MatchedStatements': [\n                            {\n                                'SourcePolicyId': 'string',\n                                'SourcePolicyType': 'user'|'group'|'role'|'aws-managed'|'user-managed'|'resource'|'none',\n                                'StartPosition': {\n                                    'Line': 123,\n                                    'Column': 123\n                                },\n                                'EndPosition': {\n                                    'Line': 123,\n                                    'Column': 123\n                                }\n                            },\n                        ],\n                        'MissingContextValues': [\n                            'string',\n                        ],\n                        'EvalDecisionDetails': {\n                            'string': 'allowed'|'explicitDeny'|'implicitDeny'\n                        }\n                    },\n                ]\n            },\n        ],\n        'IsTruncated': True|False,\n        'Marker': 'string'\n    }\n    \n    \n    :returns: \n    (string) --\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the password policy settings for the AWS account. For more information about using a password policy, see Managing an IAM Password Policy in the IAM User Guide . See also: AWS API Documentation Examples The following command sets the password policy to require a minimum length of eight characters and to require one or more numbers in the password: Expected Output: :example: response = client.update_account_password_policy( MinimumPasswordLength=123, RequireSymbols=True|False, RequireNumbers=True|False, RequireUppercaseCharacters=True|False, RequireLowercaseCharacters=True|False, AllowUsersToChangePassword=True|False, MaxPasswordAge=123, PasswordReusePrevention=123, HardExpiry=True|False ) :type MinimumPasswordLength: integer :param MinimumPasswordLength: The minimum number of characters allowed in an IAM user password. Default value: 6 :type RequireSymbols: boolean :param RequireSymbols: Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters: ! @ # $ % ^ amp; * ( ) _ + - = [ ] { } | ' Default value: false :type RequireNumbers: boolean :param RequireNumbers: Specifies whether IAM user passwords must contain at least one numeric character (0 to 9). Default value: false :type RequireUppercaseCharacters: boolean :param RequireUppercaseCharacters: Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z). Default value: false :type RequireLowercaseCharacters: boolean :param RequireLowercaseCharacters: Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z). Default value: false :type AllowUsersToChangePassword: boolean :param AllowUsersToChangePassword: Allows all IAM users in your account to use the AWS Management Console to change their own passwords. For more information, see Letting IAM Users Change Their Own Passwords in the IAM User Guide . Default value: false :type MaxPasswordAge: integer :param MaxPasswordAge: The number of days that an IAM user password is valid. The default value of 0 means IAM user passwords never expire. Default value: 0 :type PasswordReusePrevention: integer :param PasswordReusePrevention: Specifies the number of previous passwords that IAM users are prevented from reusing. The default value of 0 means IAM users are not prevented from reusing previous passwords. Default value: 0 :type HardExpiry: boolean :param HardExpiry: Prevents IAM users from setting a new password after their password has expired. Default value: false :return: response = client.update_account_password_policy( MinimumPasswordLength=8, RequireNumbers=True, ) print(response)", "response": "def update_account_password_policy(MinimumPasswordLength=None, RequireSymbols=None, RequireNumbers=None, RequireUppercaseCharacters=None, RequireLowercaseCharacters=None, AllowUsersToChangePassword=None, MaxPasswordAge=None, PasswordReusePrevention=None, HardExpiry=None):\n    \"\"\"\n    Updates the password policy settings for the AWS account.\n    For more information about using a password policy, see Managing an IAM Password Policy in the IAM User Guide .\n    See also: AWS API Documentation\n    \n    Examples\n    The following command sets the password policy to require a minimum length of eight characters and to require one or more numbers in the password:\n    Expected Output:\n    \n    :example: response = client.update_account_password_policy(\n        MinimumPasswordLength=123,\n        RequireSymbols=True|False,\n        RequireNumbers=True|False,\n        RequireUppercaseCharacters=True|False,\n        RequireLowercaseCharacters=True|False,\n        AllowUsersToChangePassword=True|False,\n        MaxPasswordAge=123,\n        PasswordReusePrevention=123,\n        HardExpiry=True|False\n    )\n    \n    \n    :type MinimumPasswordLength: integer\n    :param MinimumPasswordLength: The minimum number of characters allowed in an IAM user password.\n            Default value: 6\n            \n\n    :type RequireSymbols: boolean\n    :param RequireSymbols: Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters:\n            ! @ # $ % ^ amp; * ( ) _ + - = [ ] { } | '\n            Default value: false\n            \n\n    :type RequireNumbers: boolean\n    :param RequireNumbers: Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).\n            Default value: false\n            \n\n    :type RequireUppercaseCharacters: boolean\n    :param RequireUppercaseCharacters: Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).\n            Default value: false\n            \n\n    :type RequireLowercaseCharacters: boolean\n    :param RequireLowercaseCharacters: Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).\n            Default value: false\n            \n\n    :type AllowUsersToChangePassword: boolean\n    :param AllowUsersToChangePassword: Allows all IAM users in your account to use the AWS Management Console to change their own passwords. For more information, see Letting IAM Users Change Their Own Passwords in the IAM User Guide .\n            Default value: false\n            \n\n    :type MaxPasswordAge: integer\n    :param MaxPasswordAge: The number of days that an IAM user password is valid. The default value of 0 means IAM user passwords never expire.\n            Default value: 0\n            \n\n    :type PasswordReusePrevention: integer\n    :param PasswordReusePrevention: Specifies the number of previous passwords that IAM users are prevented from reusing. The default value of 0 means IAM users are not prevented from reusing previous passwords.\n            Default value: 0\n            \n\n    :type HardExpiry: boolean\n    :param HardExpiry: Prevents IAM users from setting a new password after their password has expired.\n            Default value: false\n            \n\n    :return: response = client.update_account_password_policy(\n        MinimumPasswordLength=8,\n        RequireNumbers=True,\n    )\n    \n    print(response)\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new network profile for a single object.", "response": "def create_network_profile(projectArn=None, name=None, description=None, type=None, uplinkBandwidthBits=None, downlinkBandwidthBits=None, uplinkDelayMs=None, downlinkDelayMs=None, uplinkJitterMs=None, downlinkJitterMs=None, uplinkLossPercent=None, downlinkLossPercent=None):\n    \"\"\"\n    Creates a network profile.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_network_profile(\n        projectArn='string',\n        name='string',\n        description='string',\n        type='CURATED'|'PRIVATE',\n        uplinkBandwidthBits=123,\n        downlinkBandwidthBits=123,\n        uplinkDelayMs=123,\n        downlinkDelayMs=123,\n        uplinkJitterMs=123,\n        downlinkJitterMs=123,\n        uplinkLossPercent=123,\n        downlinkLossPercent=123\n    )\n    \n    \n    :type projectArn: string\n    :param projectArn: [REQUIRED]\n            The Amazon Resource Name (ARN) of the project for which you want to create a network profile.\n            \n\n    :type name: string\n    :param name: [REQUIRED]\n            The name you wish to specify for the new network profile.\n            \n\n    :type description: string\n    :param description: The description of the network profile.\n\n    :type type: string\n    :param type: The type of network profile you wish to create. Valid values are listed below.\n\n    :type uplinkBandwidthBits: integer\n    :param uplinkBandwidthBits: The data throughput rate in bits per second, as an integer from 0 to 104857600.\n\n    :type downlinkBandwidthBits: integer\n    :param downlinkBandwidthBits: The data throughput rate in bits per second, as an integer from 0 to 104857600.\n\n    :type uplinkDelayMs: integer\n    :param uplinkDelayMs: Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.\n\n    :type downlinkDelayMs: integer\n    :param downlinkDelayMs: Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.\n\n    :type uplinkJitterMs: integer\n    :param uplinkJitterMs: Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.\n\n    :type downlinkJitterMs: integer\n    :param downlinkJitterMs: Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.\n\n    :type uplinkLossPercent: integer\n    :param uplinkLossPercent: Proportion of transmitted packets that fail to arrive from 0 to 100 percent.\n\n    :type downlinkLossPercent: integer\n    :param downlinkLossPercent: Proportion of received packets that fail to arrive from 0 to 100 percent.\n\n    :rtype: dict\n    :return: {\n        'networkProfile': {\n            'arn': 'string',\n            'name': 'string',\n            'description': 'string',\n            'type': 'CURATED'|'PRIVATE',\n            'uplinkBandwidthBits': 123,\n            'downlinkBandwidthBits': 123,\n            'uplinkDelayMs': 123,\n            'downlinkDelayMs': 123,\n            'uplinkJitterMs': 123,\n            'downlinkJitterMs': 123,\n            'uplinkLossPercent': 123,\n            'downlinkLossPercent': 123\n        }\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the network profile with specific settings. See also: AWS API Documentation :example: response = client.update_network_profile( arn='string', name='string', description='string', type='CURATED'|'PRIVATE', uplinkBandwidthBits=123, downlinkBandwidthBits=123, uplinkDelayMs=123, downlinkDelayMs=123, uplinkJitterMs=123, downlinkJitterMs=123, uplinkLossPercent=123, downlinkLossPercent=123 ) :type arn: string :param arn: [REQUIRED] The Amazon Resource Name (ARN) of the project that you wish to update network profile settings. :type name: string :param name: The name of the network profile about which you are returning information. :type description: string :param description: The descriptoin of the network profile about which you are returning information. :type type: string :param type: The type of network profile you wish to return information about. Valid values are listed below. :type uplinkBandwidthBits: integer :param uplinkBandwidthBits: The data throughput rate in bits per second, as an integer from 0 to 104857600. :type downlinkBandwidthBits: integer :param downlinkBandwidthBits: The data throughput rate in bits per second, as an integer from 0 to 104857600. :type uplinkDelayMs: integer :param uplinkDelayMs: Delay time for all packets to destination in milliseconds as an integer from 0 to 2000. :type downlinkDelayMs: integer :param downlinkDelayMs: Delay time for all packets to destination in milliseconds as an integer from 0 to 2000. :type uplinkJitterMs: integer :param uplinkJitterMs: Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000. :type downlinkJitterMs: integer :param downlinkJitterMs: Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000. :type uplinkLossPercent: integer :param uplinkLossPercent: Proportion of transmitted packets that fail to arrive from 0 to 100 percent. :type downlinkLossPercent: integer :param downlinkLossPercent: Proportion of received packets that fail to arrive from 0 to 100 percent. :rtype: dict :return: { 'networkProfile': { 'arn': 'string', 'name': 'string', 'description': 'string', 'type': 'CURATED'|'PRIVATE', 'uplinkBandwidthBits': 123, 'downlinkBandwidthBits': 123, 'uplinkDelayMs': 123, 'downlinkDelayMs': 123, 'uplinkJitterMs': 123, 'downlinkJitterMs': 123, 'uplinkLossPercent': 123, 'downlinkLossPercent': 123 } }", "response": "def update_network_profile(arn=None, name=None, description=None, type=None, uplinkBandwidthBits=None, downlinkBandwidthBits=None, uplinkDelayMs=None, downlinkDelayMs=None, uplinkJitterMs=None, downlinkJitterMs=None, uplinkLossPercent=None, downlinkLossPercent=None):\n    \"\"\"\n    Updates the network profile with specific settings.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_network_profile(\n        arn='string',\n        name='string',\n        description='string',\n        type='CURATED'|'PRIVATE',\n        uplinkBandwidthBits=123,\n        downlinkBandwidthBits=123,\n        uplinkDelayMs=123,\n        downlinkDelayMs=123,\n        uplinkJitterMs=123,\n        downlinkJitterMs=123,\n        uplinkLossPercent=123,\n        downlinkLossPercent=123\n    )\n    \n    \n    :type arn: string\n    :param arn: [REQUIRED]\n            The Amazon Resource Name (ARN) of the project that you wish to update network profile settings.\n            \n\n    :type name: string\n    :param name: The name of the network profile about which you are returning information.\n\n    :type description: string\n    :param description: The descriptoin of the network profile about which you are returning information.\n\n    :type type: string\n    :param type: The type of network profile you wish to return information about. Valid values are listed below.\n\n    :type uplinkBandwidthBits: integer\n    :param uplinkBandwidthBits: The data throughput rate in bits per second, as an integer from 0 to 104857600.\n\n    :type downlinkBandwidthBits: integer\n    :param downlinkBandwidthBits: The data throughput rate in bits per second, as an integer from 0 to 104857600.\n\n    :type uplinkDelayMs: integer\n    :param uplinkDelayMs: Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.\n\n    :type downlinkDelayMs: integer\n    :param downlinkDelayMs: Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.\n\n    :type uplinkJitterMs: integer\n    :param uplinkJitterMs: Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.\n\n    :type downlinkJitterMs: integer\n    :param downlinkJitterMs: Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.\n\n    :type uplinkLossPercent: integer\n    :param uplinkLossPercent: Proportion of transmitted packets that fail to arrive from 0 to 100 percent.\n\n    :type downlinkLossPercent: integer\n    :param downlinkLossPercent: Proportion of received packets that fail to arrive from 0 to 100 percent.\n\n    :rtype: dict\n    :return: {\n        'networkProfile': {\n            'arn': 'string',\n            'name': 'string',\n            'description': 'string',\n            'type': 'CURATED'|'PRIVATE',\n            'uplinkBandwidthBits': 123,\n            'downlinkBandwidthBits': 123,\n            'uplinkDelayMs': 123,\n            'downlinkDelayMs': 123,\n            'uplinkJitterMs': 123,\n            'downlinkJitterMs': 123,\n            'uplinkLossPercent': 123,\n            'downlinkLossPercent': 123\n        }\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_shipping_label(jobIds=None, name=None, company=None, phoneNumber=None, country=None, stateOrProvince=None, city=None, postalCode=None, street1=None, street2=None, street3=None, APIVersion=None):\n    pass", "response": "This operation generates a pre - paid UPS shipping label for a single UPS project."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_authorizer(restApiId=None, name=None, type=None, providerARNs=None, authType=None, authorizerUri=None, authorizerCredentials=None, identitySource=None, identityValidationExpression=None, authorizerResultTtlInSeconds=None):\n    pass", "response": "Creates a new Authorizer resource in the RestApi."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put_integration(restApiId=None, resourceId=None, httpMethod=None, type=None, integrationHttpMethod=None, uri=None, credentials=None, requestParameters=None, requestTemplates=None, passthroughBehavior=None, cacheNamespace=None, cacheKeyParameters=None, contentHandling=None):\n    pass", "response": "This function creates an integration for a given resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a method to an existing method in the PetStore.", "response": "def put_method(restApiId=None, resourceId=None, httpMethod=None, authorizationType=None, authorizerId=None, apiKeyRequired=None, operationName=None, requestParameters=None, requestModels=None, requestValidatorId=None):\n    \"\"\"\n    Add a method to an existing  Resource resource.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.put_method(\n        restApiId='string',\n        resourceId='string',\n        httpMethod='string',\n        authorizationType='string',\n        authorizerId='string',\n        apiKeyRequired=True|False,\n        operationName='string',\n        requestParameters={\n            'string': True|False\n        },\n        requestModels={\n            'string': 'string'\n        },\n        requestValidatorId='string'\n    )\n    \n    \n    :type restApiId: string\n    :param restApiId: [REQUIRED]\n            The RestApi identifier for the new Method resource.\n            \n\n    :type resourceId: string\n    :param resourceId: [REQUIRED]\n            The Resource identifier for the new Method resource.\n            \n\n    :type httpMethod: string\n    :param httpMethod: [REQUIRED]\n            Specifies the method request's HTTP method type.\n            \n\n    :type authorizationType: string\n    :param authorizationType: [REQUIRED]\n            The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.\n            \n\n    :type authorizerId: string\n    :param authorizerId: Specifies the identifier of an Authorizer to use on this Method, if the type is CUSTOM.\n\n    :type apiKeyRequired: boolean\n    :param apiKeyRequired: Specifies whether the method required a valid ApiKey .\n\n    :type operationName: string\n    :param operationName: A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in PetStore example.\n\n    :type requestParameters: dict\n    :param requestParameters: A key-value map defining required or optional method request parameters that can be accepted by Amazon API Gateway. A key defines a method request parameter name matching the pattern of method.request.{location}.{name} , where location is querystring , path , or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true ) or optional (false ). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or body-mapping templates.\n            (string) --\n            (boolean) --\n            \n\n    :type requestModels: dict\n    :param requestModels: Specifies the Model resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a Model name as the value.\n            (string) --\n            (string) --\n            \n\n    :type requestValidatorId: string\n    :param requestValidatorId: The identifier of a RequestValidator for validating the method request.\n\n    :rtype: dict\n    :return: {\n        'httpMethod': 'string',\n        'authorizationType': 'string',\n        'authorizerId': 'string',\n        'apiKeyRequired': True|False,\n        'requestValidatorId': 'string',\n        'operationName': 'string',\n        'requestParameters': {\n            'string': True|False\n        },\n        'requestModels': {\n            'string': 'string'\n        },\n        'methodResponses': {\n            'string': {\n                'statusCode': 'string',\n                'responseParameters': {\n                    'string': True|False\n                },\n                'responseModels': {\n                    'string': 'string'\n                }\n            }\n        },\n        'methodIntegration': {\n            'type': 'HTTP'|'AWS'|'MOCK'|'HTTP_PROXY'|'AWS_PROXY',\n            'httpMethod': 'string',\n            'uri': 'string',\n            'credentials': 'string',\n            'requestParameters': {\n                'string': 'string'\n            },\n            'requestTemplates': {\n                'string': 'string'\n            },\n            'passthroughBehavior': 'string',\n            'contentHandling': 'CONVERT_TO_BINARY'|'CONVERT_TO_TEXT',\n            'cacheNamespace': 'string',\n            'cacheKeyParameters': [\n                'string',\n            ],\n            'integrationResponses': {\n                'string': {\n                    'statusCode': 'string',\n                    'selectionPattern': 'string',\n                    'responseParameters': {\n                        'string': 'string'\n                    },\n                    'responseTemplates': {\n                        'string': 'string'\n                    },\n                    'contentHandling': 'CONVERT_TO_BINARY'|'CONVERT_TO_TEXT'\n                }\n            }\n        }\n    }\n    \n    \n    :returns: \n    (string) --\n    (boolean) --\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef describe_users(OrganizationId=None, UserIds=None, Query=None, Include=None, Order=None, Sort=None, Marker=None, Limit=None, Fields=None):\n    pass", "response": "This function returns the details of the specified users in the organization."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a change set for a stack.", "response": "def create_change_set(StackName=None, TemplateBody=None, TemplateURL=None, UsePreviousTemplate=None, Parameters=None, Capabilities=None, ResourceTypes=None, RoleARN=None, NotificationARNs=None, Tags=None, ChangeSetName=None, ClientToken=None, Description=None, ChangeSetType=None):\n    \"\"\"\n    Creates a list of changes that will be applied to a stack so that you can review the changes before executing them. You can create a change set for a stack that doesn't exist or an existing stack. If you create a change set for a stack that doesn't exist, the change set shows all of the resources that AWS CloudFormation will create. If you create a change set for an existing stack, AWS CloudFormation compares the stack's information with the information that you submit in the change set and lists the differences. Use change sets to understand which resources AWS CloudFormation will create or change, and how it will change resources in an existing stack, before you create or update a stack.\n    To create a change set for a stack that doesn't exist, for the ChangeSetType parameter, specify CREATE . To create a change set for an existing stack, specify UPDATE for the ChangeSetType parameter. After the CreateChangeSet call successfully completes, AWS CloudFormation starts creating the change set. To check the status of the change set or to review it, use the  DescribeChangeSet action.\n    When you are satisfied with the changes the change set will make, execute the change set by using the  ExecuteChangeSet action. AWS CloudFormation doesn't make changes until you execute the change set.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_change_set(\n        StackName='string',\n        TemplateBody='string',\n        TemplateURL='string',\n        UsePreviousTemplate=True|False,\n        Parameters=[\n            {\n                'ParameterKey': 'string',\n                'ParameterValue': 'string',\n                'UsePreviousValue': True|False\n            },\n        ],\n        Capabilities=[\n            'CAPABILITY_IAM'|'CAPABILITY_NAMED_IAM',\n        ],\n        ResourceTypes=[\n            'string',\n        ],\n        RoleARN='string',\n        NotificationARNs=[\n            'string',\n        ],\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        ChangeSetName='string',\n        ClientToken='string',\n        Description='string',\n        ChangeSetType='CREATE'|'UPDATE'\n    )\n    \n    \n    :type StackName: string\n    :param StackName: [REQUIRED]\n            The name or the unique ID of the stack for which you are creating a change set. AWS CloudFormation generates the change set by comparing this stack's information with the information that you submit, such as a modified template or different parameter input values.\n            \n\n    :type TemplateBody: string\n    :param TemplateBody: A structure that contains the body of the revised template, with a minimum length of 1 byte and a maximum length of 51,200 bytes. AWS CloudFormation generates the change set by comparing this template with the template of the stack that you specified.\n            Conditional: You must specify only TemplateBody or TemplateURL .\n            \n\n    :type TemplateURL: string\n    :param TemplateURL: The location of the file that contains the revised template. The URL must point to a template (max size: 460,800 bytes) that is located in an S3 bucket. AWS CloudFormation generates the change set by comparing this template with the stack that you specified.\n            Conditional: You must specify only TemplateBody or TemplateURL .\n            \n\n    :type UsePreviousTemplate: boolean\n    :param UsePreviousTemplate: Whether to reuse the template that is associated with the stack to create the change set.\n\n    :type Parameters: list\n    :param Parameters: A list of Parameter structures that specify input parameters for the change set. For more information, see the Parameter data type.\n            (dict) --The Parameter data type.\n            ParameterKey (string) --The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.\n            ParameterValue (string) --The value associated with the parameter.\n            UsePreviousValue (boolean) --During a stack update, use the existing parameter value that the stack is using for a given parameter key. If you specify true , do not specify a parameter value.\n            \n            \n\n    :type Capabilities: list\n    :param Capabilities: A list of values that you must specify before AWS CloudFormation can update certain stacks. Some stack templates might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter.\n            The only valid values are CAPABILITY_IAM and CAPABILITY_NAMED_IAM . The following resources require you to specify this parameter: AWS::IAM::AccessKey , AWS::IAM::Group , AWS::IAM::InstanceProfile , AWS::IAM::Policy , AWS::IAM::Role , AWS::IAM::User , and AWS::IAM::UserToGroupAddition . If your stack template contains these resources, we recommend that you review all permissions associated with them and edit their permissions if necessary.\n            If you have IAM resources, you can specify either capability. If you have IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM . If you don't specify this parameter, this action returns an InsufficientCapabilities error.\n            For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates .\n            (string) --\n            \n\n    :type ResourceTypes: list\n    :param ResourceTypes: The template resource types that you have permissions to work with if you execute this change set, such as AWS::EC2::Instance , AWS::EC2::* , or Custom::MyCustomInstance .\n            If the list of resource types doesn't include a resource type that you're updating, the stack update fails. By default, AWS CloudFormation grants permissions to all resource types. AWS Identity and Access Management (IAM) uses this parameter for condition keys in IAM policies for AWS CloudFormation. For more information, see Controlling Access with AWS Identity and Access Management in the AWS CloudFormation User Guide.\n            (string) --\n            \n\n    :type RoleARN: string\n    :param RoleARN: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that AWS CloudFormation assumes when executing the change set. AWS CloudFormation uses the role's credentials to make calls on your behalf. AWS CloudFormation uses this role for all future operations on the stack. As long as users have permission to operate on the stack, AWS CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants least privilege.\n            If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials.\n            \n\n    :type NotificationARNs: list\n    :param NotificationARNs: The Amazon Resource Names (ARNs) of Amazon Simple Notification Service (Amazon SNS) topics that AWS CloudFormation associates with the stack. To remove all associated notification topics, specify an empty list.\n            (string) --\n            \n\n    :type Tags: list\n    :param Tags: Key-value pairs to associate with this stack. AWS CloudFormation also propagates these tags to resources in the stack. You can specify a maximum of 10 tags.\n            (dict) --The Tag type enables you to specify a key-value pair that can be used to store information about an AWS CloudFormation stack.\n            Key (string) --\n            Required . A string used to identify this tag. You can specify a maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the reserved prefix: aws: .\n            Value (string) --\n            Required . A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value.\n            \n            \n\n    :type ChangeSetName: string\n    :param ChangeSetName: [REQUIRED]\n            The name of the change set. The name must be unique among all change sets that are associated with the specified stack.\n            A change set name can contain only alphanumeric, case sensitive characters and hyphens. It must start with an alphabetic character and cannot exceed 128 characters.\n            \n\n    :type ClientToken: string\n    :param ClientToken: A unique identifier for this CreateChangeSet request. Specify this token if you plan to retry requests so that AWS CloudFormation knows that you're not attempting to create another change set with the same name. You might retry CreateChangeSet requests to ensure that AWS CloudFormation successfully received them.\n\n    :type Description: string\n    :param Description: A description to help you identify this change set.\n\n    :type ChangeSetType: string\n    :param ChangeSetType: The type of change set operation. To create a change set for a new stack, specify CREATE . To create a change set for an existing stack, specify UPDATE .\n            If you create a change set for a new stack, AWS Cloudformation creates a stack with a unique stack ID, but no template or resources. The stack will be in the ` REVIEW_IN_PROGRESS http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-describing-stacks.html#d0e11995`_ state until you execute the change set.\n            By default, AWS CloudFormation specifies UPDATE . You can't use the UPDATE type to create a change set for a new stack or the CREATE type to create a change set for an existing stack.\n            \n\n    :rtype: dict\n    :return: {\n        'Id': 'string',\n        'StackId': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a stack as specified in the template. After the call completes successfully, the stack creation starts. You can check the status of the stack via the DescribeStacks API. See also: AWS API Documentation :example: response = client.create_stack( StackName='string', TemplateBody='string', TemplateURL='string', Parameters=[ { 'ParameterKey': 'string', 'ParameterValue': 'string', 'UsePreviousValue': True|False }, ], DisableRollback=True|False, TimeoutInMinutes=123, NotificationARNs=[ 'string', ], Capabilities=[ 'CAPABILITY_IAM'|'CAPABILITY_NAMED_IAM', ], ResourceTypes=[ 'string', ], RoleARN='string', OnFailure='DO_NOTHING'|'ROLLBACK'|'DELETE', StackPolicyBody='string', StackPolicyURL='string', Tags=[ { 'Key': 'string', 'Value': 'string' }, ], ClientRequestToken='string' ) :type StackName: string :param StackName: [REQUIRED] The name that is associated with the stack. The name must be unique in the region in which you are creating the stack. Note A stack name can contain only alphanumeric characters (case sensitive) and hyphens. It must start with an alphabetic character and cannot be longer than 128 characters. :type TemplateBody: string :param TemplateBody: Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. For more information, go to Template Anatomy in the AWS CloudFormation User Guide. Conditional: You must specify either the TemplateBody or the TemplateURL parameter, but not both. :type TemplateURL: string :param TemplateURL: Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket. For more information, go to the Template Anatomy in the AWS CloudFormation User Guide. Conditional: You must specify either the TemplateBody or the TemplateURL parameter, but not both. :type Parameters: list :param Parameters: A list of Parameter structures that specify input parameters for the stack. For more information, see the Parameter data type. (dict) --The Parameter data type. ParameterKey (string) --The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template. ParameterValue (string) --The value associated with the parameter. UsePreviousValue (boolean) --During a stack update, use the existing parameter value that the stack is using for a given parameter key. If you specify true , do not specify a parameter value. :type DisableRollback: boolean :param DisableRollback: Set to true to disable rollback of the stack if stack creation failed. You can specify either DisableRollback or OnFailure , but not both. Default: false :type TimeoutInMinutes: integer :param TimeoutInMinutes: The amount of time that can pass before the stack status becomes CREATE_FAILED; if DisableRollback is not set or is set to false , the stack will be rolled back. :type NotificationARNs: list :param NotificationARNs: The Simple Notification Service (SNS) topic ARNs to publish stack related events. You can find your SNS topic ARNs using the SNS console or your Command Line Interface (CLI). (string) -- :type Capabilities: list :param Capabilities: A list of values that you must specify before AWS CloudFormation can create certain stacks. Some stack templates might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter. The only valid values are CAPABILITY_IAM and CAPABILITY_NAMED_IAM . The following resources require you to specify this parameter: AWS::IAM::AccessKey , AWS::IAM::Group , AWS::IAM::InstanceProfile , AWS::IAM::Policy , AWS::IAM::Role , AWS::IAM::User , and AWS::IAM::UserToGroupAddition . If your stack template contains these resources, we recommend that you review all permissions associated with them and edit their permissions if necessary. If you have IAM resources, you can specify either capability. If you have IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM . If you don't specify this parameter, this action returns an InsufficientCapabilities error. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates . (string) -- :type ResourceTypes: list :param ResourceTypes: The template resource types that you have permissions to work with for this create stack action, such as AWS::EC2::Instance , AWS::EC2::* , or Custom::MyCustomInstance . Use the following syntax to describe template resource types: AWS::* (for all AWS resource), Custom::* (for all custom resources), Custom::*logical_ID* `` (for a specific custom resource), ``AWS::*service_name* ::* (for all resources of a particular AWS service), and ``AWS::service_name ::resource_logical_ID `` (for a specific AWS resource). If the list of resource types doesn't include a resource that you're creating, the stack creation fails. By default, AWS CloudFormation grants permissions to all resource types. AWS Identity and Access Management (IAM) uses this parameter for AWS CloudFormation-specific condition keys in IAM policies. For more information, see Controlling Access with AWS Identity and Access Management . (string) -- :type RoleARN: string :param RoleARN: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that AWS CloudFormation assumes to create the stack. AWS CloudFormation uses the role's credentials to make calls on your behalf. AWS CloudFormation always uses this role for all future operations on the stack. As long as users have permission to operate on the stack, AWS CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants least privilege. If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials. :type OnFailure: string :param OnFailure: Determines what action will be taken if stack creation fails. This must be one of: DO_NOTHING, ROLLBACK, or DELETE. You can specify either OnFailure or DisableRollback , but not both. Default: ROLLBACK :type StackPolicyBody: string :param StackPolicyBody: Structure containing the stack policy body. For more information, go to Prevent Updates to Stack Resources in the AWS CloudFormation User Guide . You can specify either the StackPolicyBody or the StackPolicyURL parameter, but not both. :type StackPolicyURL: string :param StackPolicyURL: Location of a file containing the stack policy. The URL must point to a policy (maximum size: 16 KB) located in an S3 bucket in the same region as the stack. You can specify either the StackPolicyBody or the StackPolicyURL parameter, but not both. :type Tags: list :param Tags: Key-value pairs to associate with this stack. AWS CloudFormation also propagates these tags to the resources created in the stack. A maximum number of 10 tags can be specified. (dict) --The Tag type enables you to specify a key-value pair that can be used to store information about an AWS CloudFormation stack. Key (string) -- Required . A string used to identify this tag. You can specify a maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the reserved prefix: aws: . Value (string) -- Required . A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value. :type ClientRequestToken: string :param ClientRequestToken: A unique identifier for this CreateStack request. Specify this token if you plan to retry requests so that AWS CloudFormation knows that you're not attempting to create a stack with the same name. You might retry CreateStack requests to ensure that AWS CloudFormation successfully received them. :rtype: dict :return: { 'StackId': 'string' }", "response": "def create_stack(StackName=None, TemplateBody=None, TemplateURL=None, Parameters=None, DisableRollback=None, TimeoutInMinutes=None, NotificationARNs=None, Capabilities=None, ResourceTypes=None, RoleARN=None, OnFailure=None, StackPolicyBody=None, StackPolicyURL=None, Tags=None, ClientRequestToken=None):\n    \"\"\"\n    Creates a stack as specified in the template. After the call completes successfully, the stack creation starts. You can check the status of the stack via the  DescribeStacks API.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_stack(\n        StackName='string',\n        TemplateBody='string',\n        TemplateURL='string',\n        Parameters=[\n            {\n                'ParameterKey': 'string',\n                'ParameterValue': 'string',\n                'UsePreviousValue': True|False\n            },\n        ],\n        DisableRollback=True|False,\n        TimeoutInMinutes=123,\n        NotificationARNs=[\n            'string',\n        ],\n        Capabilities=[\n            'CAPABILITY_IAM'|'CAPABILITY_NAMED_IAM',\n        ],\n        ResourceTypes=[\n            'string',\n        ],\n        RoleARN='string',\n        OnFailure='DO_NOTHING'|'ROLLBACK'|'DELETE',\n        StackPolicyBody='string',\n        StackPolicyURL='string',\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        ClientRequestToken='string'\n    )\n    \n    \n    :type StackName: string\n    :param StackName: [REQUIRED]\n            The name that is associated with the stack. The name must be unique in the region in which you are creating the stack.\n            Note\n            A stack name can contain only alphanumeric characters (case sensitive) and hyphens. It must start with an alphabetic character and cannot be longer than 128 characters.\n            \n\n    :type TemplateBody: string\n    :param TemplateBody: Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. For more information, go to Template Anatomy in the AWS CloudFormation User Guide.\n            Conditional: You must specify either the TemplateBody or the TemplateURL parameter, but not both.\n            \n\n    :type TemplateURL: string\n    :param TemplateURL: Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket. For more information, go to the Template Anatomy in the AWS CloudFormation User Guide.\n            Conditional: You must specify either the TemplateBody or the TemplateURL parameter, but not both.\n            \n\n    :type Parameters: list\n    :param Parameters: A list of Parameter structures that specify input parameters for the stack. For more information, see the Parameter data type.\n            (dict) --The Parameter data type.\n            ParameterKey (string) --The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.\n            ParameterValue (string) --The value associated with the parameter.\n            UsePreviousValue (boolean) --During a stack update, use the existing parameter value that the stack is using for a given parameter key. If you specify true , do not specify a parameter value.\n            \n            \n\n    :type DisableRollback: boolean\n    :param DisableRollback: Set to true to disable rollback of the stack if stack creation failed. You can specify either DisableRollback or OnFailure , but not both.\n            Default: false\n            \n\n    :type TimeoutInMinutes: integer\n    :param TimeoutInMinutes: The amount of time that can pass before the stack status becomes CREATE_FAILED; if DisableRollback is not set or is set to false , the stack will be rolled back.\n\n    :type NotificationARNs: list\n    :param NotificationARNs: The Simple Notification Service (SNS) topic ARNs to publish stack related events. You can find your SNS topic ARNs using the SNS console or your Command Line Interface (CLI).\n            (string) --\n            \n\n    :type Capabilities: list\n    :param Capabilities: A list of values that you must specify before AWS CloudFormation can create certain stacks. Some stack templates might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter.\n            The only valid values are CAPABILITY_IAM and CAPABILITY_NAMED_IAM . The following resources require you to specify this parameter: AWS::IAM::AccessKey , AWS::IAM::Group , AWS::IAM::InstanceProfile , AWS::IAM::Policy , AWS::IAM::Role , AWS::IAM::User , and AWS::IAM::UserToGroupAddition . If your stack template contains these resources, we recommend that you review all permissions associated with them and edit their permissions if necessary.\n            If you have IAM resources, you can specify either capability. If you have IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM . If you don't specify this parameter, this action returns an InsufficientCapabilities error.\n            For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates .\n            (string) --\n            \n\n    :type ResourceTypes: list\n    :param ResourceTypes: The template resource types that you have permissions to work with for this create stack action, such as AWS::EC2::Instance , AWS::EC2::* , or Custom::MyCustomInstance . Use the following syntax to describe template resource types: AWS::* (for all AWS resource), Custom::* (for all custom resources), Custom::*logical_ID* `` (for a specific custom resource), ``AWS::*service_name* ::* (for all resources of a particular AWS service), and ``AWS::service_name ::resource_logical_ID `` (for a specific AWS resource).\n            If the list of resource types doesn't include a resource that you're creating, the stack creation fails. By default, AWS CloudFormation grants permissions to all resource types. AWS Identity and Access Management (IAM) uses this parameter for AWS CloudFormation-specific condition keys in IAM policies. For more information, see Controlling Access with AWS Identity and Access Management .\n            (string) --\n            \n\n    :type RoleARN: string\n    :param RoleARN: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that AWS CloudFormation assumes to create the stack. AWS CloudFormation uses the role's credentials to make calls on your behalf. AWS CloudFormation always uses this role for all future operations on the stack. As long as users have permission to operate on the stack, AWS CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants least privilege.\n            If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials.\n            \n\n    :type OnFailure: string\n    :param OnFailure: Determines what action will be taken if stack creation fails. This must be one of: DO_NOTHING, ROLLBACK, or DELETE. You can specify either OnFailure or DisableRollback , but not both.\n            Default: ROLLBACK\n            \n\n    :type StackPolicyBody: string\n    :param StackPolicyBody: Structure containing the stack policy body. For more information, go to Prevent Updates to Stack Resources in the AWS CloudFormation User Guide . You can specify either the StackPolicyBody or the StackPolicyURL parameter, but not both.\n\n    :type StackPolicyURL: string\n    :param StackPolicyURL: Location of a file containing the stack policy. The URL must point to a policy (maximum size: 16 KB) located in an S3 bucket in the same region as the stack. You can specify either the StackPolicyBody or the StackPolicyURL parameter, but not both.\n\n    :type Tags: list\n    :param Tags: Key-value pairs to associate with this stack. AWS CloudFormation also propagates these tags to the resources created in the stack. A maximum number of 10 tags can be specified.\n            (dict) --The Tag type enables you to specify a key-value pair that can be used to store information about an AWS CloudFormation stack.\n            Key (string) --\n            Required . A string used to identify this tag. You can specify a maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the reserved prefix: aws: .\n            Value (string) --\n            Required . A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value.\n            \n            \n\n    :type ClientRequestToken: string\n    :param ClientRequestToken: A unique identifier for this CreateStack request. Specify this token if you plan to retry requests so that AWS CloudFormation knows that you're not attempting to create a stack with the same name. You might retry CreateStack requests to ensure that AWS CloudFormation successfully received them.\n\n    :rtype: dict\n    :return: {\n        'StackId': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_stack(StackName=None, TemplateBody=None, TemplateURL=None, UsePreviousTemplate=None, StackPolicyDuringUpdateBody=None, StackPolicyDuringUpdateURL=None, Parameters=None, Capabilities=None, ResourceTypes=None, RoleARN=None, StackPolicyBody=None, StackPolicyURL=None, NotificationARNs=None, Tags=None, ClientRequestToken=None):\n    pass", "response": "This function updates a stack with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_case(subject=None, serviceCode=None, severityCode=None, categoryCode=None, communicationBody=None, ccEmailAddresses=None, language=None, issueType=None, attachmentSetId=None):\n    pass", "response": "This function creates a new AWS Support case in the AWS Support Center."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of cases that you specify by passing one or more case IDs. In addition, you can filter the cases by date by setting values for the afterTime and beforeTime request parameters. You can set values for the includeResolvedCases and includeCommunications request parameters to control how much information is returned. Case data is available for 12 months after creation. If a case was created more than 12 months ago, a request for data might cause an error. The response returns the following in JSON format: See also: AWS API Documentation :example: response = client.describe_cases( caseIdList=[ 'string', ], displayId='string', afterTime='string', beforeTime='string', includeResolvedCases=True|False, nextToken='string', maxResults=123, language='string', includeCommunications=True|False ) :type caseIdList: list :param caseIdList: A list of ID numbers of the support cases you want returned. The maximum number of cases is 100. (string) -- :type displayId: string :param displayId: The ID displayed for a case in the AWS Support Center user interface. :type afterTime: string :param afterTime: The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation. :type beforeTime: string :param beforeTime: The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation. :type includeResolvedCases: boolean :param includeResolvedCases: Specifies whether resolved support cases should be included in the DescribeCases results. The default is false . :type nextToken: string :param nextToken: A resumption point for pagination. :type maxResults: integer :param maxResults: The maximum number of results to return before paginating. :type language: string :param language: The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ('en') and Japanese ('ja'). Language parameters must be passed explicitly for operations that take them. :type includeCommunications: boolean :param includeCommunications: Specifies whether communications should be included in the DescribeCases results. The default is true . :rtype: dict :return: { 'cases': [ { 'caseId': 'string', 'displayId': 'string', 'subject': 'string', 'status': 'string', 'serviceCode': 'string', 'categoryCode': 'string', 'severityCode': 'string', 'submittedBy': 'string', 'timeCreated': 'string', 'recentCommunications': { 'communications': [ { 'caseId': 'string', 'body': 'string', 'submittedBy': 'string', 'timeCreated': 'string', 'attachmentSet': [ { 'attachmentId': 'string', 'fileName': 'string' }, ] }, ], 'nextToken': 'string' }, 'ccEmailAddresses': [ 'string', ], 'language': 'string' }, ], 'nextToken': 'string' } :returns: caseIdList (list) -- A list of ID numbers of the support cases you want returned. The maximum number of cases is 100. (string) -- displayId (string) -- The ID displayed for a case in the AWS Support Center user interface. afterTime (string) -- The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation. beforeTime (string) -- The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation. includeResolvedCases (boolean) -- Specifies whether resolved support cases should be included in the DescribeCases results. The default is false . nextToken (string) -- A resumption point for pagination. maxResults (integer) -- The maximum number of results to return before paginating. language (string) -- The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English (\"en\") and Japanese (\"ja\"). Language parameters must be passed explicitly for operations that take them. includeCommunications (boolean) -- Specifies whether communications should be included in the DescribeCases results. The default is true .", "response": "def describe_cases(caseIdList=None, displayId=None, afterTime=None, beforeTime=None, includeResolvedCases=None, nextToken=None, maxResults=None, language=None, includeCommunications=None):\n    \"\"\"\n    Returns a list of cases that you specify by passing one or more case IDs. In addition, you can filter the cases by date by setting values for the afterTime and beforeTime request parameters. You can set values for the includeResolvedCases and includeCommunications request parameters to control how much information is returned.\n    Case data is available for 12 months after creation. If a case was created more than 12 months ago, a request for data might cause an error.\n    The response returns the following in JSON format:\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.describe_cases(\n        caseIdList=[\n            'string',\n        ],\n        displayId='string',\n        afterTime='string',\n        beforeTime='string',\n        includeResolvedCases=True|False,\n        nextToken='string',\n        maxResults=123,\n        language='string',\n        includeCommunications=True|False\n    )\n    \n    \n    :type caseIdList: list\n    :param caseIdList: A list of ID numbers of the support cases you want returned. The maximum number of cases is 100.\n            (string) --\n            \n\n    :type displayId: string\n    :param displayId: The ID displayed for a case in the AWS Support Center user interface.\n\n    :type afterTime: string\n    :param afterTime: The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation.\n\n    :type beforeTime: string\n    :param beforeTime: The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation.\n\n    :type includeResolvedCases: boolean\n    :param includeResolvedCases: Specifies whether resolved support cases should be included in the DescribeCases results. The default is false .\n\n    :type nextToken: string\n    :param nextToken: A resumption point for pagination.\n\n    :type maxResults: integer\n    :param maxResults: The maximum number of results to return before paginating.\n\n    :type language: string\n    :param language: The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ('en') and Japanese ('ja'). Language parameters must be passed explicitly for operations that take them.\n\n    :type includeCommunications: boolean\n    :param includeCommunications: Specifies whether communications should be included in the DescribeCases results. The default is true .\n\n    :rtype: dict\n    :return: {\n        'cases': [\n            {\n                'caseId': 'string',\n                'displayId': 'string',\n                'subject': 'string',\n                'status': 'string',\n                'serviceCode': 'string',\n                'categoryCode': 'string',\n                'severityCode': 'string',\n                'submittedBy': 'string',\n                'timeCreated': 'string',\n                'recentCommunications': {\n                    'communications': [\n                        {\n                            'caseId': 'string',\n                            'body': 'string',\n                            'submittedBy': 'string',\n                            'timeCreated': 'string',\n                            'attachmentSet': [\n                                {\n                                    'attachmentId': 'string',\n                                    'fileName': 'string'\n                                },\n                            ]\n                        },\n                    ],\n                    'nextToken': 'string'\n                },\n                'ccEmailAddresses': [\n                    'string',\n                ],\n                'language': 'string'\n            },\n        ],\n        'nextToken': 'string'\n    }\n    \n    \n    :returns: \n    caseIdList (list) -- A list of ID numbers of the support cases you want returned. The maximum number of cases is 100.\n    \n    (string) --\n    \n    \n    displayId (string) -- The ID displayed for a case in the AWS Support Center user interface.\n    afterTime (string) -- The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation.\n    beforeTime (string) -- The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation.\n    includeResolvedCases (boolean) -- Specifies whether resolved support cases should be included in the  DescribeCases results. The default is false .\n    nextToken (string) -- A resumption point for pagination.\n    maxResults (integer) -- The maximum number of results to return before paginating.\n    language (string) -- The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English (\"en\") and Japanese (\"ja\"). Language parameters must be passed explicitly for operations that take them.\n    includeCommunications (boolean) -- Specifies whether communications should be included in the  DescribeCases results. The default is true .\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_user_pool(PoolName=None, Policies=None, LambdaConfig=None, AutoVerifiedAttributes=None, AliasAttributes=None, SmsVerificationMessage=None, EmailVerificationMessage=None, EmailVerificationSubject=None, SmsAuthenticationMessage=None, MfaConfiguration=None, DeviceConfiguration=None, EmailConfiguration=None, SmsConfiguration=None, UserPoolTags=None, AdminCreateUserConfig=None, Schema=None):\n    pass", "response": "Creates a new Amazon Cognito user pool."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_user_pool_client(UserPoolId=None, ClientName=None, GenerateSecret=None, RefreshTokenValidity=None, ReadAttributes=None, WriteAttributes=None, ExplicitAuthFlows=None, SupportedIdentityProviders=None, CallbackURLs=None, LogoutURLs=None, DefaultRedirectURI=None, AllowedOAuthFlows=None, AllowedOAuthScopes=None, AllowedOAuthFlowsUserPoolClient=None):\n    pass", "response": "Creates a user pool client."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_user_pool(UserPoolId=None, Policies=None, LambdaConfig=None, AutoVerifiedAttributes=None, SmsVerificationMessage=None, EmailVerificationMessage=None, EmailVerificationSubject=None, SmsAuthenticationMessage=None, MfaConfiguration=None, DeviceConfiguration=None, EmailConfiguration=None, SmsConfiguration=None, UserPoolTags=None, AdminCreateUserConfig=None):\n    pass", "response": "This function updates the specified user pool with the specified attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nallows the developer to update the specified user pool client and password policy. See also: AWS API Documentation :example: response = client.update_user_pool_client( UserPoolId='string', ClientId='string', ClientName='string', RefreshTokenValidity=123, ReadAttributes=[ 'string', ], WriteAttributes=[ 'string', ], ExplicitAuthFlows=[ 'ADMIN_NO_SRP_AUTH'|'CUSTOM_AUTH_FLOW_ONLY', ], SupportedIdentityProviders=[ 'string', ], CallbackURLs=[ 'string', ], LogoutURLs=[ 'string', ], DefaultRedirectURI='string', AllowedOAuthFlows=[ 'code'|'implicit'|'client_credentials', ], AllowedOAuthScopes=[ 'string', ], AllowedOAuthFlowsUserPoolClient=True|False ) :type UserPoolId: string :param UserPoolId: [REQUIRED] The user pool ID for the user pool where you want to update the user pool client. :type ClientId: string :param ClientId: [REQUIRED] The ID of the client associated with the user pool. :type ClientName: string :param ClientName: The client name from the update user pool client request. :type RefreshTokenValidity: integer :param RefreshTokenValidity: The time limit, in days, after which the refresh token is no longer valid and cannot be used. :type ReadAttributes: list :param ReadAttributes: The read-only attributes of the user pool. (string) -- :type WriteAttributes: list :param WriteAttributes: The writeable attributes of the user pool. (string) -- :type ExplicitAuthFlows: list :param ExplicitAuthFlows: Explicit authentication flows. (string) -- :type SupportedIdentityProviders: list :param SupportedIdentityProviders: A list of provider names for the identity providers that are supported on this client. (string) -- :type CallbackURLs: list :param CallbackURLs: A list of allowed callback URLs for the identity providers. (string) -- :type LogoutURLs: list :param LogoutURLs: A list ofallowed logout URLs for the identity providers. (string) -- :type DefaultRedirectURI: string :param DefaultRedirectURI: The default redirect URI. Must be in the CallbackURLs list. :type AllowedOAuthFlows: list :param AllowedOAuthFlows: Set to code to initiate a code grant flow, which provides an authorization code as the response. This code can be exchanged for access tokens with the token endpoint. Set to token to specify that the client should get the access token (and, optionally, ID token, based on scopes) directly. (string) -- :type AllowedOAuthScopes: list :param AllowedOAuthScopes: A list of allowed OAuth scopes. Currently supported values are 'phone' , 'email' , 'openid' , and 'Cognito' . (string) -- :type AllowedOAuthFlowsUserPoolClient: boolean :param AllowedOAuthFlowsUserPoolClient: Set to TRUE if the client is allowed to follow the OAuth protocol when interacting with Cognito user pools. :rtype: dict :return: { 'UserPoolClient': { 'UserPoolId': 'string', 'ClientName': 'string', 'ClientId': 'string', 'ClientSecret': 'string', 'LastModifiedDate': datetime(2015, 1, 1), 'CreationDate': datetime(2015, 1, 1), 'RefreshTokenValidity': 123, 'ReadAttributes': [ 'string', ], 'WriteAttributes': [ 'string', ], 'ExplicitAuthFlows': [ 'ADMIN_NO_SRP_AUTH'|'CUSTOM_AUTH_FLOW_ONLY', ], 'SupportedIdentityProviders': [ 'string', ], 'CallbackURLs': [ 'string', ], 'LogoutURLs': [ 'string', ], 'DefaultRedirectURI': 'string', 'AllowedOAuthFlows': [ 'code'|'implicit'|'client_credentials', ], 'AllowedOAuthScopes': [ 'string', ], 'AllowedOAuthFlowsUserPoolClient': True|False } } :returns: (string) --", "response": "def update_user_pool_client(UserPoolId=None, ClientId=None, ClientName=None, RefreshTokenValidity=None, ReadAttributes=None, WriteAttributes=None, ExplicitAuthFlows=None, SupportedIdentityProviders=None, CallbackURLs=None, LogoutURLs=None, DefaultRedirectURI=None, AllowedOAuthFlows=None, AllowedOAuthScopes=None, AllowedOAuthFlowsUserPoolClient=None):\n    \"\"\"\n    Allows the developer to update the specified user pool client and password policy.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_user_pool_client(\n        UserPoolId='string',\n        ClientId='string',\n        ClientName='string',\n        RefreshTokenValidity=123,\n        ReadAttributes=[\n            'string',\n        ],\n        WriteAttributes=[\n            'string',\n        ],\n        ExplicitAuthFlows=[\n            'ADMIN_NO_SRP_AUTH'|'CUSTOM_AUTH_FLOW_ONLY',\n        ],\n        SupportedIdentityProviders=[\n            'string',\n        ],\n        CallbackURLs=[\n            'string',\n        ],\n        LogoutURLs=[\n            'string',\n        ],\n        DefaultRedirectURI='string',\n        AllowedOAuthFlows=[\n            'code'|'implicit'|'client_credentials',\n        ],\n        AllowedOAuthScopes=[\n            'string',\n        ],\n        AllowedOAuthFlowsUserPoolClient=True|False\n    )\n    \n    \n    :type UserPoolId: string\n    :param UserPoolId: [REQUIRED]\n            The user pool ID for the user pool where you want to update the user pool client.\n            \n\n    :type ClientId: string\n    :param ClientId: [REQUIRED]\n            The ID of the client associated with the user pool.\n            \n\n    :type ClientName: string\n    :param ClientName: The client name from the update user pool client request.\n\n    :type RefreshTokenValidity: integer\n    :param RefreshTokenValidity: The time limit, in days, after which the refresh token is no longer valid and cannot be used.\n\n    :type ReadAttributes: list\n    :param ReadAttributes: The read-only attributes of the user pool.\n            (string) --\n            \n\n    :type WriteAttributes: list\n    :param WriteAttributes: The writeable attributes of the user pool.\n            (string) --\n            \n\n    :type ExplicitAuthFlows: list\n    :param ExplicitAuthFlows: Explicit authentication flows.\n            (string) --\n            \n\n    :type SupportedIdentityProviders: list\n    :param SupportedIdentityProviders: A list of provider names for the identity providers that are supported on this client.\n            (string) --\n            \n\n    :type CallbackURLs: list\n    :param CallbackURLs: A list of allowed callback URLs for the identity providers.\n            (string) --\n            \n\n    :type LogoutURLs: list\n    :param LogoutURLs: A list ofallowed logout URLs for the identity providers.\n            (string) --\n            \n\n    :type DefaultRedirectURI: string\n    :param DefaultRedirectURI: The default redirect URI. Must be in the CallbackURLs list.\n\n    :type AllowedOAuthFlows: list\n    :param AllowedOAuthFlows: Set to code to initiate a code grant flow, which provides an authorization code as the response. This code can be exchanged for access tokens with the token endpoint.\n            Set to token to specify that the client should get the access token (and, optionally, ID token, based on scopes) directly.\n            (string) --\n            \n\n    :type AllowedOAuthScopes: list\n    :param AllowedOAuthScopes: A list of allowed OAuth scopes. Currently supported values are 'phone' , 'email' , 'openid' , and 'Cognito' .\n            (string) --\n            \n\n    :type AllowedOAuthFlowsUserPoolClient: boolean\n    :param AllowedOAuthFlowsUserPoolClient: Set to TRUE if the client is allowed to follow the OAuth protocol when interacting with Cognito user pools.\n\n    :rtype: dict\n    :return: {\n        'UserPoolClient': {\n            'UserPoolId': 'string',\n            'ClientName': 'string',\n            'ClientId': 'string',\n            'ClientSecret': 'string',\n            'LastModifiedDate': datetime(2015, 1, 1),\n            'CreationDate': datetime(2015, 1, 1),\n            'RefreshTokenValidity': 123,\n            'ReadAttributes': [\n                'string',\n            ],\n            'WriteAttributes': [\n                'string',\n            ],\n            'ExplicitAuthFlows': [\n                'ADMIN_NO_SRP_AUTH'|'CUSTOM_AUTH_FLOW_ONLY',\n            ],\n            'SupportedIdentityProviders': [\n                'string',\n            ],\n            'CallbackURLs': [\n                'string',\n            ],\n            'LogoutURLs': [\n                'string',\n            ],\n            'DefaultRedirectURI': 'string',\n            'AllowedOAuthFlows': [\n                'code'|'implicit'|'client_credentials',\n            ],\n            'AllowedOAuthScopes': [\n                'string',\n            ],\n            'AllowedOAuthFlowsUserPoolClient': True|False\n        }\n    }\n    \n    \n    :returns: \n    (string) --\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncopies an object from an existing object to an Amazon S3 bucket.", "response": "def copy_object(ACL=None, Bucket=None, CacheControl=None, ContentDisposition=None, ContentEncoding=None, ContentLanguage=None, ContentType=None, CopySource=None, CopySourceIfMatch=None, CopySourceIfModifiedSince=None, CopySourceIfNoneMatch=None, CopySourceIfUnmodifiedSince=None, Expires=None, GrantFullControl=None, GrantRead=None, GrantReadACP=None, GrantWriteACP=None, Key=None, Metadata=None, MetadataDirective=None, TaggingDirective=None, ServerSideEncryption=None, StorageClass=None, WebsiteRedirectLocation=None, SSECustomerAlgorithm=None, SSECustomerKey=None, SSECustomerKeyMD5=None, SSEKMSKeyId=None, CopySourceSSECustomerAlgorithm=None, CopySourceSSECustomerKey=None, CopySourceSSECustomerKeyMD5=None, RequestPayer=None, Tagging=None):\n    \"\"\"\n    Creates a copy of an object that is already stored in Amazon S3.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.copy_object(\n        ACL='private'|'public-read'|'public-read-write'|'authenticated-read'|'aws-exec-read'|'bucket-owner-read'|'bucket-owner-full-control',\n        Bucket='string',\n        CacheControl='string',\n        ContentDisposition='string',\n        ContentEncoding='string',\n        ContentLanguage='string',\n        ContentType='string',\n        CopySource='string' or {'Bucket': 'string', 'Key': 'string', 'VersionId': 'string'},\n        CopySourceIfMatch='string',\n        CopySourceIfModifiedSince=datetime(2015, 1, 1),\n        CopySourceIfNoneMatch='string',\n        CopySourceIfUnmodifiedSince=datetime(2015, 1, 1),\n        Expires=datetime(2015, 1, 1),\n        GrantFullControl='string',\n        GrantRead='string',\n        GrantReadACP='string',\n        GrantWriteACP='string',\n        Key='string',\n        Metadata={\n            'string': 'string'\n        },\n        MetadataDirective='COPY'|'REPLACE',\n        TaggingDirective='COPY'|'REPLACE',\n        ServerSideEncryption='AES256'|'aws:kms',\n        StorageClass='STANDARD'|'REDUCED_REDUNDANCY'|'STANDARD_IA',\n        WebsiteRedirectLocation='string',\n        SSECustomerAlgorithm='string',\n        SSECustomerKey='string',\n        SSEKMSKeyId='string',\n        CopySourceSSECustomerAlgorithm='string',\n        CopySourceSSECustomerKey='string',\n        RequestPayer='requester',\n        Tagging='string'\n    )\n    \n    \n    :type ACL: string\n    :param ACL: The canned ACL to apply to the object.\n\n    :type Bucket: string\n    :param Bucket: [REQUIRED]\n\n    :type CacheControl: string\n    :param CacheControl: Specifies caching behavior along the request/reply chain.\n\n    :type ContentDisposition: string\n    :param ContentDisposition: Specifies presentational information for the object.\n\n    :type ContentEncoding: string\n    :param ContentEncoding: Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.\n\n    :type ContentLanguage: string\n    :param ContentLanguage: The language the content is in.\n\n    :type ContentType: string\n    :param ContentType: A standard MIME type describing the format of the object data.\n\n    :type CopySource: str or dict\n    :param CopySource: [REQUIRED] The name of the source bucket, key name of the source object, and optional version ID of the source object. You can either provide this value as a string or a dictionary. The string form is {bucket}/{key} or {bucket}/{key}?versionId={versionId} if you want to copy a specific version. You can also provide this value as a dictionary. The dictionary format is recommended over the string format because it is more explicit. The dictionary format is: {'Bucket': 'bucket', 'Key': 'key', 'VersionId': 'id'}. Note that the VersionId key is optional and may be omitted.\n\n    :type CopySourceIfMatch: string\n    :param CopySourceIfMatch: Copies the object if its entity tag (ETag) matches the specified tag.\n\n    :type CopySourceIfModifiedSince: datetime\n    :param CopySourceIfModifiedSince: Copies the object if it has been modified since the specified time.\n\n    :type CopySourceIfNoneMatch: string\n    :param CopySourceIfNoneMatch: Copies the object if its entity tag (ETag) is different than the specified ETag.\n\n    :type CopySourceIfUnmodifiedSince: datetime\n    :param CopySourceIfUnmodifiedSince: Copies the object if it hasn't been modified since the specified time.\n\n    :type Expires: datetime\n    :param Expires: The date and time at which the object is no longer cacheable.\n\n    :type GrantFullControl: string\n    :param GrantFullControl: Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.\n\n    :type GrantRead: string\n    :param GrantRead: Allows grantee to read the object data and its metadata.\n\n    :type GrantReadACP: string\n    :param GrantReadACP: Allows grantee to read the object ACL.\n\n    :type GrantWriteACP: string\n    :param GrantWriteACP: Allows grantee to write the ACL for the applicable object.\n\n    :type Key: string\n    :param Key: [REQUIRED]\n\n    :type Metadata: dict\n    :param Metadata: A map of metadata to store with the object in S3.\n            (string) --\n            (string) --\n            \n\n    :type MetadataDirective: string\n    :param MetadataDirective: Specifies whether the metadata is copied from the source object or replaced with metadata provided in the request.\n\n    :type TaggingDirective: string\n    :param TaggingDirective: Specifies whether the object tag-set are copied from the source object or replaced with tag-set provided in the request.\n\n    :type ServerSideEncryption: string\n    :param ServerSideEncryption: The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).\n\n    :type StorageClass: string\n    :param StorageClass: The type of storage to use for the object. Defaults to 'STANDARD'.\n\n    :type WebsiteRedirectLocation: string\n    :param WebsiteRedirectLocation: If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.\n\n    :type SSECustomerAlgorithm: string\n    :param SSECustomerAlgorithm: Specifies the algorithm to use to when encrypting the object (e.g., AES256).\n\n    :type SSECustomerKey: string\n    :param SSECustomerKey: Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side -encryption -customer-algorithm header.\n\n    :type SSECustomerKeyMD5: string\n    :param SSECustomerKeyMD5: Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.   Please note that this parameter is automatically populated if it is not provided. Including this parameter is not required\n\n    :type SSEKMSKeyId: string\n    :param SSEKMSKeyId: Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not made via SSL or using SigV4. Documentation on configuring any of the officially supported AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version\n\n    :type CopySourceSSECustomerAlgorithm: string\n    :param CopySourceSSECustomerAlgorithm: Specifies the algorithm to use when decrypting the source object (e.g., AES256).\n\n    :type CopySourceSSECustomerKey: string\n    :param CopySourceSSECustomerKey: Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.\n\n    :type CopySourceSSECustomerKeyMD5: string\n    :param CopySourceSSECustomerKeyMD5: Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.   Please note that this parameter is automatically populated if it is not provided. Including this parameter is not required\n\n    :type RequestPayer: string\n    :param RequestPayer: Confirms that the requester knows that she or he will be charged for the request. Bucket owners need not specify this parameter in their requests. Documentation on downloading objects from requester pays buckets can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html\n\n    :type Tagging: string\n    :param Tagging: The tag-set for the object destination object this value must be used in conjunction with the TaggingDirective. The tag-set must be encoded as URL Query parameters\n\n    :rtype: dict\n    :return: {\n        'CopyObjectResult': {\n            'ETag': 'string',\n            'LastModified': datetime(2015, 1, 1)\n        },\n        'Expiration': 'string',\n        'CopySourceVersionId': 'string',\n        'VersionId': 'string',\n        'ServerSideEncryption': 'AES256'|'aws:kms',\n        'SSECustomerAlgorithm': 'string',\n        'SSECustomerKeyMD5': 'string',\n        'SSEKMSKeyId': 'string',\n        'RequestCharged': 'requester'\n    }\n    \n    \n    :returns: \n    (dict) --\n    CopyObjectResult (dict) --\n    ETag (string) --\n    LastModified (datetime) --\n    \n    \n    Expiration (string) -- If the object expiration is configured, the response includes this header.\n    CopySourceVersionId (string) --\n    VersionId (string) -- Version ID of the newly created copy.\n    ServerSideEncryption (string) -- The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).\n    SSECustomerAlgorithm (string) -- If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.\n    SSECustomerKeyMD5 (string) -- If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.\n    SSEKMSKeyId (string) -- If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.\n    RequestCharged (string) -- If present, indicates that the requester was successfully charged for the request.\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_multipart_upload(ACL=None, Bucket=None, CacheControl=None, ContentDisposition=None, ContentEncoding=None, ContentLanguage=None, ContentType=None, Expires=None, GrantFullControl=None, GrantRead=None, GrantReadACP=None, GrantWriteACP=None, Key=None, Metadata=None, ServerSideEncryption=None, StorageClass=None, WebsiteRedirectLocation=None, SSECustomerAlgorithm=None, SSECustomerKey=None, SSECustomerKeyMD5=None, SSEKMSKeyId=None, RequestPayer=None):\n    pass", "response": "This function creates a multipart upload."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_object(Bucket=None, IfMatch=None, IfModifiedSince=None, IfNoneMatch=None, IfUnmodifiedSince=None, Key=None, Range=None, ResponseCacheControl=None, ResponseContentDisposition=None, ResponseContentEncoding=None, ResponseContentLanguage=None, ResponseContentType=None, ResponseExpires=None, VersionId=None, SSECustomerAlgorithm=None, SSECustomerKey=None, SSECustomerKeyMD5=None, RequestPayer=None, PartNumber=None):\n    pass", "response": "This function returns an object from an Amazon S3 bucket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting objects in a bucket in a V2 bucket.", "response": "def list_objects_v2(Bucket=None, Delimiter=None, EncodingType=None, MaxKeys=None, Prefix=None, ContinuationToken=None, FetchOwner=None, StartAfter=None, RequestPayer=None):\n    \"\"\"\n    Returns some or all (up to 1000) of the objects in a bucket. You can use the request parameters as selection criteria to return a subset of the objects in a bucket. Note: ListObjectsV2 is the revised List Objects API and we recommend you use this revised API for new application development.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.list_objects_v2(\n        Bucket='string',\n        Delimiter='string',\n        EncodingType='url',\n        MaxKeys=123,\n        Prefix='string',\n        ContinuationToken='string',\n        FetchOwner=True|False,\n        StartAfter='string',\n        RequestPayer='requester'\n    )\n    \n    \n    :type Bucket: string\n    :param Bucket: [REQUIRED] Name of the bucket to list.\n\n    :type Delimiter: string\n    :param Delimiter: A delimiter is a character you use to group keys.\n\n    :type EncodingType: string\n    :param EncodingType: Encoding type used by Amazon S3 to encode object keys in the response.\n\n    :type MaxKeys: integer\n    :param MaxKeys: Sets the maximum number of keys returned in the response. The response might contain fewer keys but will never contain more.\n\n    :type Prefix: string\n    :param Prefix: Limits the response to keys that begin with the specified prefix.\n\n    :type ContinuationToken: string\n    :param ContinuationToken: ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key\n\n    :type FetchOwner: boolean\n    :param FetchOwner: The owner field is not present in listV2 by default, if you want to return owner field with each key in the result then set the fetch owner field to true\n\n    :type StartAfter: string\n    :param StartAfter: StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this specified key. StartAfter can be any key in the bucket\n\n    :type RequestPayer: string\n    :param RequestPayer: Confirms that the requester knows that she or he will be charged for the list objects request in V2 style. Bucket owners need not specify this parameter in their requests.\n\n    :rtype: dict\n    :return: {\n        'IsTruncated': True|False,\n        'Contents': [\n            {\n                'Key': 'string',\n                'LastModified': datetime(2015, 1, 1),\n                'ETag': 'string',\n                'Size': 123,\n                'StorageClass': 'STANDARD'|'REDUCED_REDUNDANCY'|'GLACIER',\n                'Owner': {\n                    'DisplayName': 'string',\n                    'ID': 'string'\n                }\n            },\n        ],\n        'Name': 'string',\n        'Prefix': 'string',\n        'Delimiter': 'string',\n        'MaxKeys': 123,\n        'CommonPrefixes': [\n            {\n                'Prefix': 'string'\n            },\n        ],\n        'EncodingType': 'url',\n        'KeyCount': 123,\n        'ContinuationToken': 'string',\n        'NextContinuationToken': 'string',\n        'StartAfter': 'string'\n    }\n    \n    \n    :returns: \n    (dict) --\n    IsTruncated (boolean) -- A flag that indicates whether or not Amazon S3 returned all of the results that satisfied the search criteria.\n    Contents (list) -- Metadata about each object returned.\n    (dict) --\n    Key (string) --\n    LastModified (datetime) --\n    ETag (string) --\n    Size (integer) --\n    StorageClass (string) -- The class of storage used to store the object.\n    Owner (dict) --\n    DisplayName (string) --\n    ID (string) --\n    \n    \n    \n    \n    \n    \n    Name (string) -- Name of the bucket to list.\n    Prefix (string) -- Limits the response to keys that begin with the specified prefix.\n    Delimiter (string) -- A delimiter is a character you use to group keys.\n    MaxKeys (integer) -- Sets the maximum number of keys returned in the response. The response might contain fewer keys but will never contain more.\n    CommonPrefixes (list) -- CommonPrefixes contains all (if there are any) keys between Prefix and the next occurrence of the string specified by delimiter\n    (dict) --\n    Prefix (string) --\n    \n    \n    \n    \n    EncodingType (string) -- Encoding type used by Amazon S3 to encode object keys in the response.\n    KeyCount (integer) -- KeyCount is the number of keys returned with this request. KeyCount will always be less than equals to MaxKeys field. Say you ask for 50 keys, your result will include less than equals 50 keys\n    ContinuationToken (string) -- ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key\n    NextContinuationToken (string) -- NextContinuationToken is sent when isTruncated is true which means there are more keys in the bucket that can be listed. The next list requests to Amazon S3 can be continued with this NextContinuationToken. NextContinuationToken is obfuscated and is not a real key\n    StartAfter (string) -- StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this specified key. StartAfter can be any key in the bucket\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an object to a bucket.", "response": "def put_object(ACL=None, Body=None, Bucket=None, CacheControl=None, ContentDisposition=None, ContentEncoding=None, ContentLanguage=None, ContentLength=None, ContentMD5=None, ContentType=None, Expires=None, GrantFullControl=None, GrantRead=None, GrantReadACP=None, GrantWriteACP=None, Key=None, Metadata=None, ServerSideEncryption=None, StorageClass=None, WebsiteRedirectLocation=None, SSECustomerAlgorithm=None, SSECustomerKey=None, SSECustomerKeyMD5=None, SSEKMSKeyId=None, RequestPayer=None, Tagging=None):\n    \"\"\"\n    Adds an object to a bucket.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.put_object(\n        ACL='private'|'public-read'|'public-read-write'|'authenticated-read'|'aws-exec-read'|'bucket-owner-read'|'bucket-owner-full-control',\n        Body=b'bytes'|file,\n        Bucket='string',\n        CacheControl='string',\n        ContentDisposition='string',\n        ContentEncoding='string',\n        ContentLanguage='string',\n        ContentLength=123,\n        ContentMD5='string',\n        ContentType='string',\n        Expires=datetime(2015, 1, 1),\n        GrantFullControl='string',\n        GrantRead='string',\n        GrantReadACP='string',\n        GrantWriteACP='string',\n        Key='string',\n        Metadata={\n            'string': 'string'\n        },\n        ServerSideEncryption='AES256'|'aws:kms',\n        StorageClass='STANDARD'|'REDUCED_REDUNDANCY'|'STANDARD_IA',\n        WebsiteRedirectLocation='string',\n        SSECustomerAlgorithm='string',\n        SSECustomerKey='string',\n        SSEKMSKeyId='string',\n        RequestPayer='requester',\n        Tagging='string'\n    )\n    \n    \n    :type ACL: string\n    :param ACL: The canned ACL to apply to the object.\n\n    :type Body: bytes or seekable file-like object\n    :param Body: Object data.\n\n    :type Bucket: string\n    :param Bucket: [REQUIRED] Name of the bucket to which the PUT operation was initiated.\n\n    :type CacheControl: string\n    :param CacheControl: Specifies caching behavior along the request/reply chain.\n\n    :type ContentDisposition: string\n    :param ContentDisposition: Specifies presentational information for the object.\n\n    :type ContentEncoding: string\n    :param ContentEncoding: Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.\n\n    :type ContentLanguage: string\n    :param ContentLanguage: The language the content is in.\n\n    :type ContentLength: integer\n    :param ContentLength: Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically.\n\n    :type ContentMD5: string\n    :param ContentMD5: The base64-encoded 128-bit MD5 digest of the part data.\n\n    :type ContentType: string\n    :param ContentType: A standard MIME type describing the format of the object data.\n\n    :type Expires: datetime\n    :param Expires: The date and time at which the object is no longer cacheable.\n\n    :type GrantFullControl: string\n    :param GrantFullControl: Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.\n\n    :type GrantRead: string\n    :param GrantRead: Allows grantee to read the object data and its metadata.\n\n    :type GrantReadACP: string\n    :param GrantReadACP: Allows grantee to read the object ACL.\n\n    :type GrantWriteACP: string\n    :param GrantWriteACP: Allows grantee to write the ACL for the applicable object.\n\n    :type Key: string\n    :param Key: [REQUIRED] Object key for which the PUT operation was initiated.\n\n    :type Metadata: dict\n    :param Metadata: A map of metadata to store with the object in S3.\n            (string) --\n            (string) --\n            \n\n    :type ServerSideEncryption: string\n    :param ServerSideEncryption: The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).\n\n    :type StorageClass: string\n    :param StorageClass: The type of storage to use for the object. Defaults to 'STANDARD'.\n\n    :type WebsiteRedirectLocation: string\n    :param WebsiteRedirectLocation: If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.\n\n    :type SSECustomerAlgorithm: string\n    :param SSECustomerAlgorithm: Specifies the algorithm to use to when encrypting the object (e.g., AES256).\n\n    :type SSECustomerKey: string\n    :param SSECustomerKey: Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side -encryption -customer-algorithm header.\n\n    :type SSECustomerKeyMD5: string\n    :param SSECustomerKeyMD5: Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.   Please note that this parameter is automatically populated if it is not provided. Including this parameter is not required\n\n    :type SSEKMSKeyId: string\n    :param SSEKMSKeyId: Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not made via SSL or using SigV4. Documentation on configuring any of the officially supported AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version\n\n    :type RequestPayer: string\n    :param RequestPayer: Confirms that the requester knows that she or he will be charged for the request. Bucket owners need not specify this parameter in their requests. Documentation on downloading objects from requester pays buckets can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html\n\n    :type Tagging: string\n    :param Tagging: The tag-set for the object. The tag-set must be encoded as URL Query parameters\n\n    :rtype: dict\n    :return: {\n        'Expiration': 'string',\n        'ETag': 'string',\n        'ServerSideEncryption': 'AES256'|'aws:kms',\n        'VersionId': 'string',\n        'SSECustomerAlgorithm': 'string',\n        'SSECustomerKeyMD5': 'string',\n        'SSEKMSKeyId': 'string',\n        'RequestCharged': 'requester'\n    }\n    \n    \n    :returns: \n    (dict) --\n    Expiration (string) -- If the object expiration is configured, this will contain the expiration date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.\n    ETag (string) -- Entity tag for the uploaded object.\n    ServerSideEncryption (string) -- The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).\n    VersionId (string) -- Version of the object.\n    SSECustomerAlgorithm (string) -- If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.\n    SSECustomerKeyMD5 (string) -- If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.\n    SSEKMSKeyId (string) -- If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.\n    RequestCharged (string) -- If present, indicates that the requester was successfully charged for the request.\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses the acl subresource to set the access control list (ACL) permissions for an object that already exists in a bucket See also: AWS API Documentation :example: response = client.put_object_acl( ACL='private'|'public-read'|'public-read-write'|'authenticated-read'|'aws-exec-read'|'bucket-owner-read'|'bucket-owner-full-control', AccessControlPolicy={ 'Grants': [ { 'Grantee': { 'DisplayName': 'string', 'EmailAddress': 'string', 'ID': 'string', 'Type': 'CanonicalUser'|'AmazonCustomerByEmail'|'Group', 'URI': 'string' }, 'Permission': 'FULL_CONTROL'|'WRITE'|'WRITE_ACP'|'READ'|'READ_ACP' }, ], 'Owner': { 'DisplayName': 'string', 'ID': 'string' } }, Bucket='string', GrantFullControl='string', GrantRead='string', GrantReadACP='string', GrantWrite='string', GrantWriteACP='string', Key='string', RequestPayer='requester', VersionId='string' ) :type ACL: string :param ACL: The canned ACL to apply to the object. :type AccessControlPolicy: dict :param AccessControlPolicy: Grants (list) -- A list of grants. (dict) -- Grantee (dict) -- DisplayName (string) -- Screen name of the grantee. EmailAddress (string) -- Email address of the grantee. ID (string) -- The canonical user ID of the grantee. Type (string) -- [REQUIRED] Type of grantee URI (string) -- URI of the grantee group. Permission (string) -- Specifies the permission given to the grantee. Owner (dict) -- DisplayName (string) -- ID (string) -- :type Bucket: string :param Bucket: [REQUIRED] :type GrantFullControl: string :param GrantFullControl: Allows grantee the read, write, read ACP, and write ACP permissions on the bucket. :type GrantRead: string :param GrantRead: Allows grantee to list the objects in the bucket. :type GrantReadACP: string :param GrantReadACP: Allows grantee to read the bucket ACL. :type GrantWrite: string :param GrantWrite: Allows grantee to create, overwrite, and delete any object in the bucket. :type GrantWriteACP: string :param GrantWriteACP: Allows grantee to write the ACL for the applicable bucket. :type Key: string :param Key: [REQUIRED] :type RequestPayer: string :param RequestPayer: Confirms that the requester knows that she or he will be charged for the request. Bucket owners need not specify this parameter in their requests. Documentation on downloading objects from requester pays buckets can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html :type VersionId: string :param VersionId: VersionId used to reference a specific version of the object. :rtype: dict :return: { 'RequestCharged': 'requester' } :returns: (dict) -- RequestCharged (string) -- If present, indicates that the requester was successfully charged for the request.", "response": "def put_object_acl(ACL=None, AccessControlPolicy=None, Bucket=None, GrantFullControl=None, GrantRead=None, GrantReadACP=None, GrantWrite=None, GrantWriteACP=None, Key=None, RequestPayer=None, VersionId=None):\n    \"\"\"\n    uses the acl subresource to set the access control list (ACL) permissions for an object that already exists in a bucket\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.put_object_acl(\n        ACL='private'|'public-read'|'public-read-write'|'authenticated-read'|'aws-exec-read'|'bucket-owner-read'|'bucket-owner-full-control',\n        AccessControlPolicy={\n            'Grants': [\n                {\n                    'Grantee': {\n                        'DisplayName': 'string',\n                        'EmailAddress': 'string',\n                        'ID': 'string',\n                        'Type': 'CanonicalUser'|'AmazonCustomerByEmail'|'Group',\n                        'URI': 'string'\n                    },\n                    'Permission': 'FULL_CONTROL'|'WRITE'|'WRITE_ACP'|'READ'|'READ_ACP'\n                },\n            ],\n            'Owner': {\n                'DisplayName': 'string',\n                'ID': 'string'\n            }\n        },\n        Bucket='string',\n        GrantFullControl='string',\n        GrantRead='string',\n        GrantReadACP='string',\n        GrantWrite='string',\n        GrantWriteACP='string',\n        Key='string',\n        RequestPayer='requester',\n        VersionId='string'\n    )\n    \n    \n    :type ACL: string\n    :param ACL: The canned ACL to apply to the object.\n\n    :type AccessControlPolicy: dict\n    :param AccessControlPolicy: \n            Grants (list) -- A list of grants.\n            (dict) --\n            Grantee (dict) --\n            DisplayName (string) -- Screen name of the grantee.\n            EmailAddress (string) -- Email address of the grantee.\n            ID (string) -- The canonical user ID of the grantee.\n            Type (string) -- [REQUIRED] Type of grantee\n            URI (string) -- URI of the grantee group.\n            Permission (string) -- Specifies the permission given to the grantee.\n            \n            Owner (dict) --\n            DisplayName (string) --\n            ID (string) --\n            \n\n    :type Bucket: string\n    :param Bucket: [REQUIRED]\n\n    :type GrantFullControl: string\n    :param GrantFullControl: Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.\n\n    :type GrantRead: string\n    :param GrantRead: Allows grantee to list the objects in the bucket.\n\n    :type GrantReadACP: string\n    :param GrantReadACP: Allows grantee to read the bucket ACL.\n\n    :type GrantWrite: string\n    :param GrantWrite: Allows grantee to create, overwrite, and delete any object in the bucket.\n\n    :type GrantWriteACP: string\n    :param GrantWriteACP: Allows grantee to write the ACL for the applicable bucket.\n\n    :type Key: string\n    :param Key: [REQUIRED]\n\n    :type RequestPayer: string\n    :param RequestPayer: Confirms that the requester knows that she or he will be charged for the request. Bucket owners need not specify this parameter in their requests. Documentation on downloading objects from requester pays buckets can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html\n\n    :type VersionId: string\n    :param VersionId: VersionId used to reference a specific version of the object.\n\n    :rtype: dict\n    :return: {\n        'RequestCharged': 'requester'\n    }\n    \n    \n    :returns: \n    (dict) --\n    RequestCharged (string) -- If present, indicates that the requester was successfully charged for the request.\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef upload_part(Body=None, Bucket=None, ContentLength=None, ContentMD5=None, Key=None, PartNumber=None, UploadId=None, SSECustomerAlgorithm=None, SSECustomerKey=None, SSECustomerKeyMD5=None, RequestPayer=None):\n    pass", "response": "Uploads a part in a multipart upload."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload_part_copy(Bucket=None, CopySource=None, CopySourceIfMatch=None, CopySourceIfModifiedSince=None, CopySourceIfNoneMatch=None, CopySourceIfUnmodifiedSince=None, CopySourceRange=None, Key=None, PartNumber=None, UploadId=None, SSECustomerAlgorithm=None, SSECustomerKey=None, SSECustomerKeyMD5=None, CopySourceSSECustomerAlgorithm=None, CopySourceSSECustomerKey=None, CopySourceSSECustomerKeyMD5=None, RequestPayer=None):\n    pass", "response": "Uploads a part of a source object to an existing object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef authorize_security_group_ingress(DryRun=None, GroupName=None, GroupId=None, SourceSecurityGroupName=None, SourceSecurityGroupOwnerId=None, IpProtocol=None, FromPort=None, ToPort=None, CidrIp=None, IpPermissions=None):\n    pass", "response": "This function is used to add one or more ingress rules to a security group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_network_interface(SubnetId=None, Description=None, PrivateIpAddress=None, Groups=None, PrivateIpAddresses=None, SecondaryPrivateIpAddressCount=None, Ipv6Addresses=None, Ipv6AddressCount=None, DryRun=None):\n    pass", "response": "Creates a network interface in the specified subnet."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_volume(DryRun=None, Size=None, SnapshotId=None, AvailabilityZone=None, VolumeType=None, Iops=None, Encrypted=None, KmsKeyId=None, TagSpecifications=None):\n    pass", "response": "This function creates an EBS volume in the specified Availability Zone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of Reserved Instances offerings for a given instance.", "response": "def describe_reserved_instances_offerings(DryRun=None, ReservedInstancesOfferingIds=None, InstanceType=None, AvailabilityZone=None, ProductDescription=None, Filters=None, InstanceTenancy=None, OfferingType=None, NextToken=None, MaxResults=None, IncludeMarketplace=None, MinDuration=None, MaxDuration=None, MaxInstanceCount=None, OfferingClass=None):\n    \"\"\"\n    Describes Reserved Instance offerings that are available for purchase. With Reserved Instances, you purchase the right to launch instances for a period of time. During that time period, you do not receive insufficient capacity errors, and you pay a lower usage rate than the rate charged for On-Demand instances for the actual time used.\n    If you have listed your own Reserved Instances for sale in the Reserved Instance Marketplace, they will be excluded from these results. This is to ensure that you do not purchase your own Reserved Instances.\n    For more information, see Reserved Instance Marketplace in the Amazon Elastic Compute Cloud User Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.describe_reserved_instances_offerings(\n        DryRun=True|False,\n        ReservedInstancesOfferingIds=[\n            'string',\n        ],\n        InstanceType='t1.micro'|'t2.nano'|'t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'t2.xlarge'|'t2.2xlarge'|'m1.small'|'m1.medium'|'m1.large'|'m1.xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge'|'m4.16xlarge'|'m2.xlarge'|'m2.2xlarge'|'m2.4xlarge'|'cr1.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'r4.large'|'r4.xlarge'|'r4.2xlarge'|'r4.4xlarge'|'r4.8xlarge'|'r4.16xlarge'|'x1.16xlarge'|'x1.32xlarge'|'i2.xlarge'|'i2.2xlarge'|'i2.4xlarge'|'i2.8xlarge'|'i3.large'|'i3.xlarge'|'i3.2xlarge'|'i3.4xlarge'|'i3.8xlarge'|'i3.16xlarge'|'hi1.4xlarge'|'hs1.8xlarge'|'c1.medium'|'c1.xlarge'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'cc1.4xlarge'|'cc2.8xlarge'|'g2.2xlarge'|'g2.8xlarge'|'cg1.4xlarge'|'p2.xlarge'|'p2.8xlarge'|'p2.16xlarge'|'d2.xlarge'|'d2.2xlarge'|'d2.4xlarge'|'d2.8xlarge'|'f1.2xlarge'|'f1.16xlarge',\n        AvailabilityZone='string',\n        ProductDescription='Linux/UNIX'|'Linux/UNIX (Amazon VPC)'|'Windows'|'Windows (Amazon VPC)',\n        Filters=[\n            {\n                'Name': 'string',\n                'Values': [\n                    'string',\n                ]\n            },\n        ],\n        InstanceTenancy='default'|'dedicated'|'host',\n        OfferingType='Heavy Utilization'|'Medium Utilization'|'Light Utilization'|'No Upfront'|'Partial Upfront'|'All Upfront',\n        NextToken='string',\n        MaxResults=123,\n        IncludeMarketplace=True|False,\n        MinDuration=123,\n        MaxDuration=123,\n        MaxInstanceCount=123,\n        OfferingClass='standard'|'convertible'\n    )\n    \n    \n    :type DryRun: boolean\n    :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation .\n\n    :type ReservedInstancesOfferingIds: list\n    :param ReservedInstancesOfferingIds: One or more Reserved Instances offering IDs.\n            (string) --\n            \n\n    :type InstanceType: string\n    :param InstanceType: The instance type that the reservation will cover (for example, m1.small ). For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide .\n\n    :type AvailabilityZone: string\n    :param AvailabilityZone: The Availability Zone in which the Reserved Instance can be used.\n\n    :type ProductDescription: string\n    :param ProductDescription: The Reserved Instance product platform description. Instances that include (Amazon VPC) in the description are for use with Amazon VPC.\n\n    :type Filters: list\n    :param Filters: One or more filters.\n            availability-zone - The Availability Zone where the Reserved Instance can be used.\n            duration - The duration of the Reserved Instance (for example, one year or three years), in seconds (31536000 | 94608000 ).\n            fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).\n            instance-type - The instance type that is covered by the reservation.\n            marketplace - Set to true to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.\n            product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web | Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC) )\n            reserved-instances-offering-id - The Reserved Instances offering ID.\n            scope - The scope of the Reserved Instance (Availability Zone or Region ).\n            usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).\n            (dict) --A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria, such as tags, attributes, or IDs.\n            Name (string) --The name of the filter. Filter names are case-sensitive.\n            Values (list) --One or more filter values. Filter values are case-sensitive.\n            (string) --\n            \n            \n\n    :type InstanceTenancy: string\n    :param InstanceTenancy: The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of dedicated is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances).\n            Important: The host value cannot be used with this parameter. Use the default or dedicated values only.\n            Default: default\n            \n\n    :type OfferingType: string\n    :param OfferingType: The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type.\n\n    :type NextToken: string\n    :param NextToken: The token to retrieve the next page of results.\n\n    :type MaxResults: integer\n    :param MaxResults: The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. The maximum is 100.\n            Default: 100\n            \n\n    :type IncludeMarketplace: boolean\n    :param IncludeMarketplace: Include Reserved Instance Marketplace offerings in the response.\n\n    :type MinDuration: integer\n    :param MinDuration: The minimum duration (in seconds) to filter when searching for offerings.\n            Default: 2592000 (1 month)\n            \n\n    :type MaxDuration: integer\n    :param MaxDuration: The maximum duration (in seconds) to filter when searching for offerings.\n            Default: 94608000 (3 years)\n            \n\n    :type MaxInstanceCount: integer\n    :param MaxInstanceCount: The maximum number of instances to filter when searching for offerings.\n            Default: 20\n            \n\n    :type OfferingClass: string\n    :param OfferingClass: The offering class of the Reserved Instance. Can be standard or convertible .\n\n    :rtype: dict\n    :return: {\n        'ReservedInstancesOfferings': [\n            {\n                'ReservedInstancesOfferingId': 'string',\n                'InstanceType': 't1.micro'|'t2.nano'|'t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'t2.xlarge'|'t2.2xlarge'|'m1.small'|'m1.medium'|'m1.large'|'m1.xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge'|'m4.16xlarge'|'m2.xlarge'|'m2.2xlarge'|'m2.4xlarge'|'cr1.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'r4.large'|'r4.xlarge'|'r4.2xlarge'|'r4.4xlarge'|'r4.8xlarge'|'r4.16xlarge'|'x1.16xlarge'|'x1.32xlarge'|'i2.xlarge'|'i2.2xlarge'|'i2.4xlarge'|'i2.8xlarge'|'i3.large'|'i3.xlarge'|'i3.2xlarge'|'i3.4xlarge'|'i3.8xlarge'|'i3.16xlarge'|'hi1.4xlarge'|'hs1.8xlarge'|'c1.medium'|'c1.xlarge'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'cc1.4xlarge'|'cc2.8xlarge'|'g2.2xlarge'|'g2.8xlarge'|'cg1.4xlarge'|'p2.xlarge'|'p2.8xlarge'|'p2.16xlarge'|'d2.xlarge'|'d2.2xlarge'|'d2.4xlarge'|'d2.8xlarge'|'f1.2xlarge'|'f1.16xlarge',\n                'AvailabilityZone': 'string',\n                'Duration': 123,\n                'UsagePrice': ...,\n                'FixedPrice': ...,\n                'ProductDescription': 'Linux/UNIX'|'Linux/UNIX (Amazon VPC)'|'Windows'|'Windows (Amazon VPC)',\n                'InstanceTenancy': 'default'|'dedicated'|'host',\n                'CurrencyCode': 'USD',\n                'OfferingType': 'Heavy Utilization'|'Medium Utilization'|'Light Utilization'|'No Upfront'|'Partial Upfront'|'All Upfront',\n                'RecurringCharges': [\n                    {\n                        'Frequency': 'Hourly',\n                        'Amount': 123.0\n                    },\n                ],\n                'Marketplace': True|False,\n                'PricingDetails': [\n                    {\n                        'Price': 123.0,\n                        'Count': 123\n                    },\n                ],\n                'OfferingClass': 'standard'|'convertible',\n                'Scope': 'Availability Zone'|'Region'\n            },\n        ],\n        'NextToken': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef describe_spot_price_history(DryRun=None, StartTime=None, EndTime=None, InstanceTypes=None, ProductDescriptions=None, Filters=None, AvailabilityZone=None, MaxResults=None, NextToken=None):\n    pass", "response": "Returns the Spot Price History for the specified instance types and product descriptions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_image(DryRun=None, Description=None, DiskContainers=None, LicenseType=None, Hypervisor=None, Architecture=None, Platform=None, ClientData=None, ClientToken=None, RoleName=None):\n    pass", "response": "This function imports a single or multi - volume disk image or EBS snapshots into an Amazon Machine Image."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmodifying the specified attribute of the specified instance. You can specify only one attribute at a time. To modify some attributes, the instance must be stopped. For more information, see Modifying Attributes of a Stopped Instance in the Amazon Elastic Compute Cloud User Guide . See also: AWS API Documentation :example: response = client.modify_instance_attribute( DryRun=True|False, InstanceId='string', Attribute='instanceType'|'kernel'|'ramdisk'|'userData'|'disableApiTermination'|'instanceInitiatedShutdownBehavior'|'rootDeviceName'|'blockDeviceMapping'|'productCodes'|'sourceDestCheck'|'groupSet'|'ebsOptimized'|'sriovNetSupport'|'enaSupport', Value='string', BlockDeviceMappings=[ { 'DeviceName': 'string', 'Ebs': { 'VolumeId': 'string', 'DeleteOnTermination': True|False }, 'VirtualName': 'string', 'NoDevice': 'string' }, ], SourceDestCheck={ 'Value': True|False }, DisableApiTermination={ 'Value': True|False }, InstanceType={ 'Value': 'string' }, Kernel={ 'Value': 'string' }, Ramdisk={ 'Value': 'string' }, UserData={ 'Value': b'bytes' }, InstanceInitiatedShutdownBehavior={ 'Value': 'string' }, Groups=[ 'string', ], EbsOptimized={ 'Value': True|False }, SriovNetSupport={ 'Value': 'string' }, EnaSupport={ 'Value': True|False } ) :type DryRun: boolean :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation . :type InstanceId: string :param InstanceId: [REQUIRED] The ID of the instance. :type Attribute: string :param Attribute: The name of the attribute. :type Value: string :param Value: A new value for the attribute. Use only with the kernel , ramdisk , userData , disableApiTermination , or instanceInitiatedShutdownBehavior attribute. :type BlockDeviceMappings: list :param BlockDeviceMappings: Modifies the DeleteOnTermination attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for DeleteOnTermination , the default is true and the volume is deleted when the instance is terminated. To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see Updating the Block Device Mapping when Launching an Instance in the Amazon Elastic Compute Cloud User Guide . (dict) --Describes a block device mapping entry. DeviceName (string) --The device name exposed to the instance (for example, /dev/sdh or xvdh ). Ebs (dict) --Parameters used to automatically set up EBS volumes when the instance is launched. VolumeId (string) --The ID of the EBS volume. DeleteOnTermination (boolean) --Indicates whether the volume is deleted on instance termination. VirtualName (string) --The virtual device name. NoDevice (string) --suppress the specified device included in the block device mapping. :type SourceDestCheck: dict :param SourceDestCheck: Specifies whether source/destination checking is enabled. A value of true means that checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT. Value (boolean) --The attribute value. The valid values are true or false . :type DisableApiTermination: dict :param DisableApiTermination: If the value is true , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances. Value (boolean) --The attribute value. The valid values are true or false . :type InstanceType: dict :param InstanceType: Changes the instance type to the specified value. For more information, see Instance Types . If the instance type is not valid, the error returned is InvalidInstanceAttributeValue . Value (string) --The attribute value. Note that the value is case-sensitive. :type Kernel: dict :param Kernel: Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB . Value (string) --The attribute value. Note that the value is case-sensitive. :type Ramdisk: dict :param Ramdisk: Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB . Value (string) --The attribute value. Note that the value is case-sensitive. :type UserData: dict :param UserData: Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text. Value (bytes) -- :type InstanceInitiatedShutdownBehavior: dict :param InstanceInitiatedShutdownBehavior: Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Value (string) --The attribute value. Note that the value is case-sensitive. :type Groups: list :param Groups: [EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name. (string) -- :type EbsOptimized: dict :param EbsOptimized: Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Value (boolean) --The attribute value. The valid values are true or false . :type SriovNetSupport: dict :param SriovNetSupport: Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance. There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable. Value (string) --The attribute value. Note that the value is case-sensitive. :type EnaSupport: dict :param EnaSupport: Set to true to enable enhanced networking with ENA for the instance. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable. Value (boolean) --The attribute value. The valid values are true or false .", "response": "def modify_instance_attribute(DryRun=None, InstanceId=None, Attribute=None, Value=None, BlockDeviceMappings=None, SourceDestCheck=None, DisableApiTermination=None, InstanceType=None, Kernel=None, Ramdisk=None, UserData=None, InstanceInitiatedShutdownBehavior=None, Groups=None, EbsOptimized=None, SriovNetSupport=None, EnaSupport=None):\n    \"\"\"\n    Modifies the specified attribute of the specified instance. You can specify only one attribute at a time.\n    To modify some attributes, the instance must be stopped. For more information, see Modifying Attributes of a Stopped Instance in the Amazon Elastic Compute Cloud User Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.modify_instance_attribute(\n        DryRun=True|False,\n        InstanceId='string',\n        Attribute='instanceType'|'kernel'|'ramdisk'|'userData'|'disableApiTermination'|'instanceInitiatedShutdownBehavior'|'rootDeviceName'|'blockDeviceMapping'|'productCodes'|'sourceDestCheck'|'groupSet'|'ebsOptimized'|'sriovNetSupport'|'enaSupport',\n        Value='string',\n        BlockDeviceMappings=[\n            {\n                'DeviceName': 'string',\n                'Ebs': {\n                    'VolumeId': 'string',\n                    'DeleteOnTermination': True|False\n                },\n                'VirtualName': 'string',\n                'NoDevice': 'string'\n            },\n        ],\n        SourceDestCheck={\n            'Value': True|False\n        },\n        DisableApiTermination={\n            'Value': True|False\n        },\n        InstanceType={\n            'Value': 'string'\n        },\n        Kernel={\n            'Value': 'string'\n        },\n        Ramdisk={\n            'Value': 'string'\n        },\n        UserData={\n            'Value': b'bytes'\n        },\n        InstanceInitiatedShutdownBehavior={\n            'Value': 'string'\n        },\n        Groups=[\n            'string',\n        ],\n        EbsOptimized={\n            'Value': True|False\n        },\n        SriovNetSupport={\n            'Value': 'string'\n        },\n        EnaSupport={\n            'Value': True|False\n        }\n    )\n    \n    \n    :type DryRun: boolean\n    :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation .\n\n    :type InstanceId: string\n    :param InstanceId: [REQUIRED]\n            The ID of the instance.\n            \n\n    :type Attribute: string\n    :param Attribute: The name of the attribute.\n\n    :type Value: string\n    :param Value: A new value for the attribute. Use only with the kernel , ramdisk , userData , disableApiTermination , or instanceInitiatedShutdownBehavior attribute.\n\n    :type BlockDeviceMappings: list\n    :param BlockDeviceMappings: Modifies the DeleteOnTermination attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for DeleteOnTermination , the default is true and the volume is deleted when the instance is terminated.\n            To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see Updating the Block Device Mapping when Launching an Instance in the Amazon Elastic Compute Cloud User Guide .\n            (dict) --Describes a block device mapping entry.\n            DeviceName (string) --The device name exposed to the instance (for example, /dev/sdh or xvdh ).\n            Ebs (dict) --Parameters used to automatically set up EBS volumes when the instance is launched.\n            VolumeId (string) --The ID of the EBS volume.\n            DeleteOnTermination (boolean) --Indicates whether the volume is deleted on instance termination.\n            VirtualName (string) --The virtual device name.\n            NoDevice (string) --suppress the specified device included in the block device mapping.\n            \n            \n\n    :type SourceDestCheck: dict\n    :param SourceDestCheck: Specifies whether source/destination checking is enabled. A value of true means that checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.\n            Value (boolean) --The attribute value. The valid values are true or false .\n            \n\n    :type DisableApiTermination: dict\n    :param DisableApiTermination: If the value is true , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.\n            Value (boolean) --The attribute value. The valid values are true or false .\n            \n\n    :type InstanceType: dict\n    :param InstanceType: Changes the instance type to the specified value. For more information, see Instance Types . If the instance type is not valid, the error returned is InvalidInstanceAttributeValue .\n            Value (string) --The attribute value. Note that the value is case-sensitive.\n            \n\n    :type Kernel: dict\n    :param Kernel: Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB .\n            Value (string) --The attribute value. Note that the value is case-sensitive.\n            \n\n    :type Ramdisk: dict\n    :param Ramdisk: Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB .\n            Value (string) --The attribute value. Note that the value is case-sensitive.\n            \n\n    :type UserData: dict\n    :param UserData: Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.\n            Value (bytes) --\n            \n\n    :type InstanceInitiatedShutdownBehavior: dict\n    :param InstanceInitiatedShutdownBehavior: Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).\n            Value (string) --The attribute value. Note that the value is case-sensitive.\n            \n\n    :type Groups: list\n    :param Groups: [EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.\n            (string) --\n            \n\n    :type EbsOptimized: dict\n    :param EbsOptimized: Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.\n            Value (boolean) --The attribute value. The valid values are true or false .\n            \n\n    :type SriovNetSupport: dict\n    :param SriovNetSupport: Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance.\n            There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time.\n            This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.\n            Value (string) --The attribute value. Note that the value is case-sensitive.\n            \n\n    :type EnaSupport: dict\n    :param EnaSupport: Set to true to enable enhanced networking with ENA for the instance.\n            This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.\n            Value (boolean) --The attribute value. The valid values are true or false .\n            \n\n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_image(DryRun=None, ImageLocation=None, Name=None, Description=None, Architecture=None, KernelId=None, RamdiskId=None, BillingProducts=None, RootDeviceName=None, BlockDeviceMappings=None, VirtualizationType=None, SriovNetSupport=None, EnaSupport=None):\n    pass", "response": "Register an image with the AMI backend."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces an entry in a network ACL.", "response": "def replace_network_acl_entry(DryRun=None, NetworkAclId=None, RuleNumber=None, Protocol=None, RuleAction=None, Egress=None, CidrBlock=None, Ipv6CidrBlock=None, IcmpTypeCode=None, PortRange=None):\n    \"\"\"\n    Replaces an entry (rule) in a network ACL. For more information about network ACLs, see Network ACLs in the Amazon Virtual Private Cloud User Guide .\n    See also: AWS API Documentation\n    \n    Examples\n    This example replaces an entry for the specified network ACL. The new rule 100 allows ingress traffic from 203.0.113.12/24 on UDP port 53 (DNS) into any associated subnet.\n    Expected Output:\n    \n    :example: response = client.replace_network_acl_entry(\n        DryRun=True|False,\n        NetworkAclId='string',\n        RuleNumber=123,\n        Protocol='string',\n        RuleAction='allow'|'deny',\n        Egress=True|False,\n        CidrBlock='string',\n        Ipv6CidrBlock='string',\n        IcmpTypeCode={\n            'Type': 123,\n            'Code': 123\n        },\n        PortRange={\n            'From': 123,\n            'To': 123\n        }\n    )\n    \n    \n    :type DryRun: boolean\n    :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation .\n\n    :type NetworkAclId: string\n    :param NetworkAclId: [REQUIRED]\n            The ID of the ACL.\n            \n\n    :type RuleNumber: integer\n    :param RuleNumber: [REQUIRED]\n            The rule number of the entry to replace.\n            \n\n    :type Protocol: string\n    :param Protocol: [REQUIRED]\n            The IP protocol. You can specify all or -1 to mean all protocols. If you specify all , -1 , or a protocol number other than tcp , udp , or icmp , traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.\n            \n\n    :type RuleAction: string\n    :param RuleAction: [REQUIRED]\n            Indicates whether to allow or deny the traffic that matches the rule.\n            \n\n    :type Egress: boolean\n    :param Egress: [REQUIRED]\n            Indicates whether to replace the egress rule.\n            Default: If no value is specified, we replace the ingress rule.\n            \n\n    :type CidrBlock: string\n    :param CidrBlock: The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24 ).\n\n    :type Ipv6CidrBlock: string\n    :param Ipv6CidrBlock: The IPv6 network range to allow or deny, in CIDR notation (for example 2001:bd8:1234:1a00::/64 ).\n\n    :type IcmpTypeCode: dict\n    :param IcmpTypeCode: ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.\n            Type (integer) --The ICMP type. A value of -1 means all types.\n            Code (integer) --The ICMP code. A value of -1 means all codes for the specified ICMP type.\n            \n\n    :type PortRange: dict\n    :param PortRange: TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.\n            From (integer) --The first port in the range.\n            To (integer) --The last port in the range.\n            \n\n    :return: response = client.replace_network_acl_entry(\n        CidrBlock='203.0.113.12/24',\n        Egress=False,\n        NetworkAclId='acl-5fb85d36',\n        PortRange={\n            'From': 53,\n            'To': 53,\n        },\n        Protocol='udp',\n        RuleAction='allow',\n        RuleNumber=100,\n    )\n    \n    print(response)\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace an existing route within a route table in a VPC. You must provide only one of the following: Internet gateway or virtual private gateway, NAT instance, NAT gateway, VPC peering connection, network interface, or egress-only Internet gateway. For more information about route tables, see Route Tables in the Amazon Virtual Private Cloud User Guide . See also: AWS API Documentation Examples This example replaces the specified route in the specified table table. The new route matches the specified CIDR and sends the traffic to the specified virtual private gateway. Expected Output: :example: response = client.replace_route( DryRun=True|False, RouteTableId='string', DestinationCidrBlock='string', GatewayId='string', DestinationIpv6CidrBlock='string', EgressOnlyInternetGatewayId='string', InstanceId='string', NetworkInterfaceId='string', VpcPeeringConnectionId='string', NatGatewayId='string' ) :type DryRun: boolean :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation . :type RouteTableId: string :param RouteTableId: [REQUIRED] The ID of the route table. :type DestinationCidrBlock: string :param DestinationCidrBlock: The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table. :type GatewayId: string :param GatewayId: The ID of an Internet gateway or virtual private gateway. :type DestinationIpv6CidrBlock: string :param DestinationIpv6CidrBlock: The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table. :type EgressOnlyInternetGatewayId: string :param EgressOnlyInternetGatewayId: [IPv6 traffic only] The ID of an egress-only Internet gateway. :type InstanceId: string :param InstanceId: The ID of a NAT instance in your VPC. :type NetworkInterfaceId: string :param NetworkInterfaceId: The ID of a network interface. :type VpcPeeringConnectionId: string :param VpcPeeringConnectionId: The ID of a VPC peering connection. :type NatGatewayId: string :param NatGatewayId: [IPv4 traffic only] The ID of a NAT gateway. :return: response = client.replace_route( DestinationCidrBlock='10.0.0.0/16', GatewayId='vgw-9a4cacf3', RouteTableId='rtb-22574640', ) print(response)", "response": "def replace_route(DryRun=None, RouteTableId=None, DestinationCidrBlock=None, GatewayId=None, DestinationIpv6CidrBlock=None, EgressOnlyInternetGatewayId=None, InstanceId=None, NetworkInterfaceId=None, VpcPeeringConnectionId=None, NatGatewayId=None):\n    \"\"\"\n    Replaces an existing route within a route table in a VPC. You must provide only one of the following: Internet gateway or virtual private gateway, NAT instance, NAT gateway, VPC peering connection, network interface, or egress-only Internet gateway.\n    For more information about route tables, see Route Tables in the Amazon Virtual Private Cloud User Guide .\n    See also: AWS API Documentation\n    \n    Examples\n    This example replaces the specified route in the specified table table. The new route matches the specified CIDR and sends the traffic to the specified virtual private gateway.\n    Expected Output:\n    \n    :example: response = client.replace_route(\n        DryRun=True|False,\n        RouteTableId='string',\n        DestinationCidrBlock='string',\n        GatewayId='string',\n        DestinationIpv6CidrBlock='string',\n        EgressOnlyInternetGatewayId='string',\n        InstanceId='string',\n        NetworkInterfaceId='string',\n        VpcPeeringConnectionId='string',\n        NatGatewayId='string'\n    )\n    \n    \n    :type DryRun: boolean\n    :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation .\n\n    :type RouteTableId: string\n    :param RouteTableId: [REQUIRED]\n            The ID of the route table.\n            \n\n    :type DestinationCidrBlock: string\n    :param DestinationCidrBlock: The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.\n\n    :type GatewayId: string\n    :param GatewayId: The ID of an Internet gateway or virtual private gateway.\n\n    :type DestinationIpv6CidrBlock: string\n    :param DestinationIpv6CidrBlock: The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.\n\n    :type EgressOnlyInternetGatewayId: string\n    :param EgressOnlyInternetGatewayId: [IPv6 traffic only] The ID of an egress-only Internet gateway.\n\n    :type InstanceId: string\n    :param InstanceId: The ID of a NAT instance in your VPC.\n\n    :type NetworkInterfaceId: string\n    :param NetworkInterfaceId: The ID of a network interface.\n\n    :type VpcPeeringConnectionId: string\n    :param VpcPeeringConnectionId: The ID of a VPC peering connection.\n\n    :type NatGatewayId: string\n    :param NatGatewayId: [IPv4 traffic only] The ID of a NAT gateway.\n\n    :return: response = client.replace_route(\n        DestinationCidrBlock='10.0.0.0/16',\n        GatewayId='vgw-9a4cacf3',\n        RouteTableId='rtb-22574640',\n    )\n    \n    print(response)\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a Spot instance request. Spot instances are instances that Amazon EC2 launches when the bid price that you specify exceeds the current Spot price. Amazon EC2 periodically sets the Spot price based on available Spot Instance capacity and current Spot instance requests. For more information, see Spot Instance Requests in the Amazon Elastic Compute Cloud User Guide . See also: AWS API Documentation Examples This example creates a one-time Spot Instance request for five instances in the specified Availability Zone. If your account supports EC2-VPC only, Amazon EC2 launches the instances in the default subnet of the specified Availability Zone. If your account supports EC2-Classic, Amazon EC2 launches the instances in EC2-Classic in the specified Availability Zone. Expected Output: This example command creates a one-time Spot Instance request for five instances in the specified subnet. Amazon EC2 launches the instances in the specified subnet. If the VPC is a nondefault VPC, the instances do not receive a public IP address by default. Expected Output: :example: response = client.request_spot_instances( DryRun=True|False, SpotPrice='string', ClientToken='string', InstanceCount=123, Type='one-time'|'persistent', ValidFrom=datetime(2015, 1, 1), ValidUntil=datetime(2015, 1, 1), LaunchGroup='string', AvailabilityZoneGroup='string', BlockDurationMinutes=123, LaunchSpecification={ 'ImageId': 'string', 'KeyName': 'string', 'SecurityGroups': [ 'string', ], 'UserData': 'string', 'AddressingType': 'string', 'InstanceType': 't1.micro'|'t2.nano'|'t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'t2.xlarge'|'t2.2xlarge'|'m1.small'|'m1.medium'|'m1.large'|'m1.xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge'|'m4.16xlarge'|'m2.xlarge'|'m2.2xlarge'|'m2.4xlarge'|'cr1.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'r4.large'|'r4.xlarge'|'r4.2xlarge'|'r4.4xlarge'|'r4.8xlarge'|'r4.16xlarge'|'x1.16xlarge'|'x1.32xlarge'|'i2.xlarge'|'i2.2xlarge'|'i2.4xlarge'|'i2.8xlarge'|'i3.large'|'i3.xlarge'|'i3.2xlarge'|'i3.4xlarge'|'i3.8xlarge'|'i3.16xlarge'|'hi1.4xlarge'|'hs1.8xlarge'|'c1.medium'|'c1.xlarge'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'cc1.4xlarge'|'cc2.8xlarge'|'g2.2xlarge'|'g2.8xlarge'|'cg1.4xlarge'|'p2.xlarge'|'p2.8xlarge'|'p2.16xlarge'|'d2.xlarge'|'d2.2xlarge'|'d2.4xlarge'|'d2.8xlarge'|'f1.2xlarge'|'f1.16xlarge', 'Placement': { 'AvailabilityZone': 'string', 'GroupName': 'string', 'Tenancy': 'default'|'dedicated'|'host' }, 'KernelId': 'string', 'RamdiskId': 'string', 'BlockDeviceMappings': [ { 'VirtualName': 'string', 'DeviceName': 'string', 'Ebs': { 'SnapshotId': 'string', 'VolumeSize': 123, 'DeleteOnTermination': True|False, 'VolumeType': 'standard'|'io1'|'gp2'|'sc1'|'st1', 'Iops': 123, 'Encrypted': True|False }, 'NoDevice': 'string' }, ], 'SubnetId': 'string', 'NetworkInterfaces': [ { 'NetworkInterfaceId': 'string', 'DeviceIndex': 123, 'SubnetId': 'string', 'Description': 'string', 'PrivateIpAddress': 'string', 'Groups': [ 'string', ], 'DeleteOnTermination': True|False, 'PrivateIpAddresses': [ { 'PrivateIpAddress': 'string', 'Primary': True|False }, ], 'SecondaryPrivateIpAddressCount': 123, 'AssociatePublicIpAddress': True|False, 'Ipv6Addresses': [ { 'Ipv6Address': 'string' }, ], 'Ipv6AddressCount': 123 }, ], 'IamInstanceProfile': { 'Arn': 'string', 'Name': 'string' }, 'EbsOptimized': True|False, 'Monitoring': { 'Enabled': True|False }, 'SecurityGroupIds': [ 'string', ] } ) :type DryRun: boolean :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation . :type SpotPrice: string :param SpotPrice: [REQUIRED] The maximum hourly price (bid) for any Spot instance launched to fulfill the request. :type ClientToken: string :param ClientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide . :type InstanceCount: integer :param InstanceCount: The maximum number of Spot instances to launch. Default: 1 :type Type: string :param Type: The Spot instance request type. Default: one-time :type ValidFrom: datetime :param ValidFrom: The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled. Default: The request is effective indefinitely. :type ValidUntil: datetime :param ValidUntil: The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. Default: The request is effective indefinitely. :type LaunchGroup: string :param LaunchGroup: The instance launch group. Launch groups are Spot instances that launch together and terminate together. Default: Instances are launched and terminated individually :type AvailabilityZoneGroup: string :param AvailabilityZoneGroup: The user-specified name for a logical grouping of bids. When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active. If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group. Default: Instances are launched in any available Availability Zone. :type BlockDurationMinutes: integer :param BlockDurationMinutes: The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360). The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates. Note that you can't specify an Availability Zone group or a launch group if you specify a duration. :type LaunchSpecification: dict :param LaunchSpecification: Describes the launch specification for an instance. ImageId (string) --The ID of the AMI. KeyName (string) --The name of the key pair. SecurityGroups (list) -- (string) -- UserData (string) --The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text. AddressingType (string) --Deprecated. InstanceType (string) --The instance type. Placement (dict) --The placement information for the instance. AvailabilityZone (string) --The Availability Zone. [Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, 'us-west-2a, us-west-2b'. GroupName (string) --The name of the placement group (for cluster instances). Tenancy (string) --The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for Spot instances. KernelId (string) --The ID of the kernel. RamdiskId (string) --The ID of the RAM disk. BlockDeviceMappings (list) --One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted. (dict) --Describes a block device mapping. VirtualName (string) --The virtual device name (ephemeral N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1 .The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI. DeviceName (string) --The device name exposed to the instance (for example, /dev/sdh or xvdh ). Ebs (dict) --Parameters used to automatically set up EBS volumes when the instance is launched. SnapshotId (string) --The ID of the snapshot. VolumeSize (integer) --The size of the volume, in GiB. Constraints: 1-16384 for General Purpose SSD (gp2 ), 4-16384 for Provisioned IOPS SSD (io1 ), 500-16384 for Throughput Optimized HDD (st1 ), 500-16384 for Cold HDD (sc1 ), and 1-1024 for Magnetic (standard ) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size. DeleteOnTermination (boolean) --Indicates whether the EBS volume is deleted on instance termination. VolumeType (string) --The volume type: gp2 , io1 , st1 , sc1 , or standard . Default: standard Iops (integer) --The number of I/O operations per second (IOPS) that the volume supports. For io1 , this represents the number of IOPS that are provisioned for the volume. For gp2 , this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide . Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2 , st1 , sc1 , or standard volumes. Encrypted (boolean) --Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. NoDevice (string) --Suppresses the specified device included in the block device mapping of the AMI. SubnetId (string) --The ID of the subnet in which to launch the instance. NetworkInterfaces (list) --One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface. (dict) --Describes a network interface. NetworkInterfaceId (string) --The ID of the network interface. DeviceIndex (integer) --The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a RunInstances request, you must provide the device index. SubnetId (string) --The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance. Description (string) --The description of the network interface. Applies only if creating a network interface when launching an instance. PrivateIpAddress (string) --The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances request. Groups (list) --The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance. (string) -- DeleteOnTermination (boolean) --If set to true , the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance. PrivateIpAddresses (list) --One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances request. (dict) --Describes a secondary private IPv4 address for a network interface. PrivateIpAddress (string) -- [REQUIRED]The private IPv4 addresses. Primary (boolean) --Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary. SecondaryPrivateIpAddressCount (integer) --The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances request. AssociatePublicIpAddress (boolean) --Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true . Ipv6Addresses (list) --One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. (dict) --Describes an IPv6 address. Ipv6Address (string) --The IPv6 address. Ipv6AddressCount (integer) --A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. IamInstanceProfile (dict) --The IAM instance profile. Arn (string) --The Amazon Resource Name (ARN) of the instance profile. Name (string) --The name of the instance profile. EbsOptimized (boolean) --Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false Monitoring (dict) --Describes the monitoring of an instance. Enabled (boolean) -- [REQUIRED]Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled. SecurityGroupIds (list) -- (string) -- :rtype: dict :return: { 'SpotInstanceRequests': [ { 'SpotInstanceRequestId': 'string', 'SpotPrice': 'string', 'Type': 'one-time'|'persistent', 'State': 'open'|'active'|'closed'|'cancelled'|'failed', 'Fault': { 'Code': 'string', 'Message': 'string' }, 'Status': { 'Code': 'string', 'UpdateTime': datetime(2015, 1, 1), 'Message': 'string' }, 'ValidFrom': datetime(2015, 1, 1), 'ValidUntil': datetime(2015, 1, 1), 'LaunchGroup': 'string', 'AvailabilityZoneGroup': 'string', 'LaunchSpecification': { 'ImageId': 'string', 'KeyName': 'string', 'SecurityGroups': [ { 'GroupName': 'string', 'GroupId': 'string' }, ], 'UserData': 'string', 'AddressingType': 'string', 'InstanceType': 't1.micro'|'t2.nano'|'t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'t2.xlarge'|'t2.2xlarge'|'m1.small'|'m1.medium'|'m1.large'|'m1.xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge'|'m4.16xlarge'|'m2.xlarge'|'m2.2xlarge'|'m2.4xlarge'|'cr1.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'r4.large'|'r4.xlarge'|'r4.2xlarge'|'r4.4xlarge'|'r4.8xlarge'|'r4.16xlarge'|'x1.16xlarge'|'x1.32xlarge'|'i2.xlarge'|'i2.2xlarge'|'i2.4xlarge'|'i2.8xlarge'|'i3.large'|'i3.xlarge'|'i3.2xlarge'|'i3.4xlarge'|'i3.8xlarge'|'i3.16xlarge'|'hi1.4xlarge'|'hs1.8xlarge'|'c1.medium'|'c1.xlarge'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'cc1.4xlarge'|'cc2.8xlarge'|'g2.2xlarge'|'g2.8xlarge'|'cg1.4xlarge'|'p2.xlarge'|'p2.8xlarge'|'p2.16xlarge'|'d2.xlarge'|'d2.2xlarge'|'d2.4xlarge'|'d2.8xlarge'|'f1.2xlarge'|'f1.16xlarge', 'Placement': { 'AvailabilityZone': 'string', 'GroupName': 'string', 'Tenancy': 'default'|'dedicated'|'host' }, 'KernelId': 'string', 'RamdiskId': 'string', 'BlockDeviceMappings': [ { 'VirtualName': 'string', 'DeviceName': 'string', 'Ebs': { 'SnapshotId': 'string', 'VolumeSize': 123, 'DeleteOnTermination': True|False, 'VolumeType': 'standard'|'io1'|'gp2'|'sc1'|'st1', 'Iops': 123, 'Encrypted': True|False }, 'NoDevice': 'string' }, ], 'SubnetId': 'string', 'NetworkInterfaces': [ { 'NetworkInterfaceId': 'string', 'DeviceIndex': 123, 'SubnetId': 'string', 'Description': 'string', 'PrivateIpAddress': 'string', 'Groups': [ 'string', ], 'DeleteOnTermination': True|False, 'PrivateIpAddresses': [ { 'PrivateIpAddress': 'string', 'Primary': True|False }, ], 'SecondaryPrivateIpAddressCount': 123, 'AssociatePublicIpAddress': True|False, 'Ipv6Addresses': [ { 'Ipv6Address': 'string' }, ], 'Ipv6AddressCount': 123 }, ], 'IamInstanceProfile': { 'Arn': 'string', 'Name': 'string' }, 'EbsOptimized': True|False, 'Monitoring': { 'Enabled': True|False } }, 'InstanceId': 'string', 'CreateTime': datetime(2015, 1, 1), 'ProductDescription': 'Linux/UNIX'|'Linux/UNIX (Amazon VPC)'|'Windows'|'Windows (Amazon VPC)', 'BlockDurationMinutes': 123, 'ActualBlockHourlyPrice': 'string', 'Tags': [ { 'Key': 'string', 'Value': 'string' }, ], 'LaunchedAvailabilityZone': 'string' }, ] } :returns: (string) --", "response": "def request_spot_instances(DryRun=None, SpotPrice=None, ClientToken=None, InstanceCount=None, Type=None, ValidFrom=None, ValidUntil=None, LaunchGroup=None, AvailabilityZoneGroup=None, BlockDurationMinutes=None, LaunchSpecification=None):\n    \"\"\"\n    Creates a Spot instance request. Spot instances are instances that Amazon EC2 launches when the bid price that you specify exceeds the current Spot price. Amazon EC2 periodically sets the Spot price based on available Spot Instance capacity and current Spot instance requests. For more information, see Spot Instance Requests in the Amazon Elastic Compute Cloud User Guide .\n    See also: AWS API Documentation\n    \n    Examples\n    This example creates a one-time Spot Instance request for five instances in the specified Availability Zone. If your account supports EC2-VPC only, Amazon EC2 launches the instances in the default subnet of the specified Availability Zone. If your account supports EC2-Classic, Amazon EC2 launches the instances in EC2-Classic in the specified Availability Zone.\n    Expected Output:\n    This example command creates a one-time Spot Instance request for five instances in the specified subnet. Amazon EC2 launches the instances in the specified subnet. If the VPC is a nondefault VPC, the instances do not receive a public IP address by default.\n    Expected Output:\n    \n    :example: response = client.request_spot_instances(\n        DryRun=True|False,\n        SpotPrice='string',\n        ClientToken='string',\n        InstanceCount=123,\n        Type='one-time'|'persistent',\n        ValidFrom=datetime(2015, 1, 1),\n        ValidUntil=datetime(2015, 1, 1),\n        LaunchGroup='string',\n        AvailabilityZoneGroup='string',\n        BlockDurationMinutes=123,\n        LaunchSpecification={\n            'ImageId': 'string',\n            'KeyName': 'string',\n            'SecurityGroups': [\n                'string',\n            ],\n            'UserData': 'string',\n            'AddressingType': 'string',\n            'InstanceType': 't1.micro'|'t2.nano'|'t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'t2.xlarge'|'t2.2xlarge'|'m1.small'|'m1.medium'|'m1.large'|'m1.xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge'|'m4.16xlarge'|'m2.xlarge'|'m2.2xlarge'|'m2.4xlarge'|'cr1.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'r4.large'|'r4.xlarge'|'r4.2xlarge'|'r4.4xlarge'|'r4.8xlarge'|'r4.16xlarge'|'x1.16xlarge'|'x1.32xlarge'|'i2.xlarge'|'i2.2xlarge'|'i2.4xlarge'|'i2.8xlarge'|'i3.large'|'i3.xlarge'|'i3.2xlarge'|'i3.4xlarge'|'i3.8xlarge'|'i3.16xlarge'|'hi1.4xlarge'|'hs1.8xlarge'|'c1.medium'|'c1.xlarge'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'cc1.4xlarge'|'cc2.8xlarge'|'g2.2xlarge'|'g2.8xlarge'|'cg1.4xlarge'|'p2.xlarge'|'p2.8xlarge'|'p2.16xlarge'|'d2.xlarge'|'d2.2xlarge'|'d2.4xlarge'|'d2.8xlarge'|'f1.2xlarge'|'f1.16xlarge',\n            'Placement': {\n                'AvailabilityZone': 'string',\n                'GroupName': 'string',\n                'Tenancy': 'default'|'dedicated'|'host'\n            },\n            'KernelId': 'string',\n            'RamdiskId': 'string',\n            'BlockDeviceMappings': [\n                {\n                    'VirtualName': 'string',\n                    'DeviceName': 'string',\n                    'Ebs': {\n                        'SnapshotId': 'string',\n                        'VolumeSize': 123,\n                        'DeleteOnTermination': True|False,\n                        'VolumeType': 'standard'|'io1'|'gp2'|'sc1'|'st1',\n                        'Iops': 123,\n                        'Encrypted': True|False\n                    },\n                    'NoDevice': 'string'\n                },\n            ],\n            'SubnetId': 'string',\n            'NetworkInterfaces': [\n                {\n                    'NetworkInterfaceId': 'string',\n                    'DeviceIndex': 123,\n                    'SubnetId': 'string',\n                    'Description': 'string',\n                    'PrivateIpAddress': 'string',\n                    'Groups': [\n                        'string',\n                    ],\n                    'DeleteOnTermination': True|False,\n                    'PrivateIpAddresses': [\n                        {\n                            'PrivateIpAddress': 'string',\n                            'Primary': True|False\n                        },\n                    ],\n                    'SecondaryPrivateIpAddressCount': 123,\n                    'AssociatePublicIpAddress': True|False,\n                    'Ipv6Addresses': [\n                        {\n                            'Ipv6Address': 'string'\n                        },\n                    ],\n                    'Ipv6AddressCount': 123\n                },\n            ],\n            'IamInstanceProfile': {\n                'Arn': 'string',\n                'Name': 'string'\n            },\n            'EbsOptimized': True|False,\n            'Monitoring': {\n                'Enabled': True|False\n            },\n            'SecurityGroupIds': [\n                'string',\n            ]\n        }\n    )\n    \n    \n    :type DryRun: boolean\n    :param DryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation . Otherwise, it is UnauthorizedOperation .\n\n    :type SpotPrice: string\n    :param SpotPrice: [REQUIRED]\n            The maximum hourly price (bid) for any Spot instance launched to fulfill the request.\n            \n\n    :type ClientToken: string\n    :param ClientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide .\n\n    :type InstanceCount: integer\n    :param InstanceCount: The maximum number of Spot instances to launch.\n            Default: 1\n            \n\n    :type Type: string\n    :param Type: The Spot instance request type.\n            Default: one-time\n            \n\n    :type ValidFrom: datetime\n    :param ValidFrom: The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled.\n            Default: The request is effective indefinitely.\n            \n\n    :type ValidUntil: datetime\n    :param ValidUntil: The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.\n            Default: The request is effective indefinitely.\n            \n\n    :type LaunchGroup: string\n    :param LaunchGroup: The instance launch group. Launch groups are Spot instances that launch together and terminate together.\n            Default: Instances are launched and terminated individually\n            \n\n    :type AvailabilityZoneGroup: string\n    :param AvailabilityZoneGroup: The user-specified name for a logical grouping of bids.\n            When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active.\n            If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group.\n            Default: Instances are launched in any available Availability Zone.\n            \n\n    :type BlockDurationMinutes: integer\n    :param BlockDurationMinutes: The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).\n            The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.\n            Note that you can't specify an Availability Zone group or a launch group if you specify a duration.\n            \n\n    :type LaunchSpecification: dict\n    :param LaunchSpecification: Describes the launch specification for an instance.\n            ImageId (string) --The ID of the AMI.\n            KeyName (string) --The name of the key pair.\n            SecurityGroups (list) --\n            (string) --\n            UserData (string) --The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.\n            AddressingType (string) --Deprecated.\n            InstanceType (string) --The instance type.\n            Placement (dict) --The placement information for the instance.\n            AvailabilityZone (string) --The Availability Zone.\n            [Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, 'us-west-2a, us-west-2b'.\n            GroupName (string) --The name of the placement group (for cluster instances).\n            Tenancy (string) --The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for Spot instances.\n            KernelId (string) --The ID of the kernel.\n            RamdiskId (string) --The ID of the RAM disk.\n            BlockDeviceMappings (list) --One or more block device mapping entries.\n            Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.\n            (dict) --Describes a block device mapping.\n            VirtualName (string) --The virtual device name (ephemeral N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1 .The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.\n            Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.\n            DeviceName (string) --The device name exposed to the instance (for example, /dev/sdh or xvdh ).\n            Ebs (dict) --Parameters used to automatically set up EBS volumes when the instance is launched.\n            SnapshotId (string) --The ID of the snapshot.\n            VolumeSize (integer) --The size of the volume, in GiB.\n            Constraints: 1-16384 for General Purpose SSD (gp2 ), 4-16384 for Provisioned IOPS SSD (io1 ), 500-16384 for Throughput Optimized HDD (st1 ), 500-16384 for Cold HDD (sc1 ), and 1-1024 for Magnetic (standard ) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.\n            Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.\n            DeleteOnTermination (boolean) --Indicates whether the EBS volume is deleted on instance termination.\n            VolumeType (string) --The volume type: gp2 , io1 , st1 , sc1 , or standard .\n            Default: standard\n            Iops (integer) --The number of I/O operations per second (IOPS) that the volume supports. For io1 , this represents the number of IOPS that are provisioned for the volume. For gp2 , this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide .\n            Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes.\n            Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2 , st1 , sc1 , or standard volumes.\n            Encrypted (boolean) --Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.\n            NoDevice (string) --Suppresses the specified device included in the block device mapping of the AMI.\n            \n            SubnetId (string) --The ID of the subnet in which to launch the instance.\n            NetworkInterfaces (list) --One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.\n            (dict) --Describes a network interface.\n            NetworkInterfaceId (string) --The ID of the network interface.\n            DeviceIndex (integer) --The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a RunInstances request, you must provide the device index.\n            SubnetId (string) --The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.\n            Description (string) --The description of the network interface. Applies only if creating a network interface when launching an instance.\n            PrivateIpAddress (string) --The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances request.\n            Groups (list) --The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.\n            (string) --\n            DeleteOnTermination (boolean) --If set to true , the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance.\n            PrivateIpAddresses (list) --One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances request.\n            (dict) --Describes a secondary private IPv4 address for a network interface.\n            PrivateIpAddress (string) -- [REQUIRED]The private IPv4 addresses.\n            Primary (boolean) --Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.\n            \n            SecondaryPrivateIpAddressCount (integer) --The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances request.\n            AssociatePublicIpAddress (boolean) --Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true .\n            Ipv6Addresses (list) --One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.\n            (dict) --Describes an IPv6 address.\n            Ipv6Address (string) --The IPv6 address.\n            \n            Ipv6AddressCount (integer) --A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.\n            \n            IamInstanceProfile (dict) --The IAM instance profile.\n            Arn (string) --The Amazon Resource Name (ARN) of the instance profile.\n            Name (string) --The name of the instance profile.\n            EbsOptimized (boolean) --Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.\n            Default: false\n            Monitoring (dict) --Describes the monitoring of an instance.\n            Enabled (boolean) -- [REQUIRED]Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.\n            SecurityGroupIds (list) --\n            (string) --\n            \n\n    :rtype: dict\n    :return: {\n        'SpotInstanceRequests': [\n            {\n                'SpotInstanceRequestId': 'string',\n                'SpotPrice': 'string',\n                'Type': 'one-time'|'persistent',\n                'State': 'open'|'active'|'closed'|'cancelled'|'failed',\n                'Fault': {\n                    'Code': 'string',\n                    'Message': 'string'\n                },\n                'Status': {\n                    'Code': 'string',\n                    'UpdateTime': datetime(2015, 1, 1),\n                    'Message': 'string'\n                },\n                'ValidFrom': datetime(2015, 1, 1),\n                'ValidUntil': datetime(2015, 1, 1),\n                'LaunchGroup': 'string',\n                'AvailabilityZoneGroup': 'string',\n                'LaunchSpecification': {\n                    'ImageId': 'string',\n                    'KeyName': 'string',\n                    'SecurityGroups': [\n                        {\n                            'GroupName': 'string',\n                            'GroupId': 'string'\n                        },\n                    ],\n                    'UserData': 'string',\n                    'AddressingType': 'string',\n                    'InstanceType': 't1.micro'|'t2.nano'|'t2.micro'|'t2.small'|'t2.medium'|'t2.large'|'t2.xlarge'|'t2.2xlarge'|'m1.small'|'m1.medium'|'m1.large'|'m1.xlarge'|'m3.medium'|'m3.large'|'m3.xlarge'|'m3.2xlarge'|'m4.large'|'m4.xlarge'|'m4.2xlarge'|'m4.4xlarge'|'m4.10xlarge'|'m4.16xlarge'|'m2.xlarge'|'m2.2xlarge'|'m2.4xlarge'|'cr1.8xlarge'|'r3.large'|'r3.xlarge'|'r3.2xlarge'|'r3.4xlarge'|'r3.8xlarge'|'r4.large'|'r4.xlarge'|'r4.2xlarge'|'r4.4xlarge'|'r4.8xlarge'|'r4.16xlarge'|'x1.16xlarge'|'x1.32xlarge'|'i2.xlarge'|'i2.2xlarge'|'i2.4xlarge'|'i2.8xlarge'|'i3.large'|'i3.xlarge'|'i3.2xlarge'|'i3.4xlarge'|'i3.8xlarge'|'i3.16xlarge'|'hi1.4xlarge'|'hs1.8xlarge'|'c1.medium'|'c1.xlarge'|'c3.large'|'c3.xlarge'|'c3.2xlarge'|'c3.4xlarge'|'c3.8xlarge'|'c4.large'|'c4.xlarge'|'c4.2xlarge'|'c4.4xlarge'|'c4.8xlarge'|'cc1.4xlarge'|'cc2.8xlarge'|'g2.2xlarge'|'g2.8xlarge'|'cg1.4xlarge'|'p2.xlarge'|'p2.8xlarge'|'p2.16xlarge'|'d2.xlarge'|'d2.2xlarge'|'d2.4xlarge'|'d2.8xlarge'|'f1.2xlarge'|'f1.16xlarge',\n                    'Placement': {\n                        'AvailabilityZone': 'string',\n                        'GroupName': 'string',\n                        'Tenancy': 'default'|'dedicated'|'host'\n                    },\n                    'KernelId': 'string',\n                    'RamdiskId': 'string',\n                    'BlockDeviceMappings': [\n                        {\n                            'VirtualName': 'string',\n                            'DeviceName': 'string',\n                            'Ebs': {\n                                'SnapshotId': 'string',\n                                'VolumeSize': 123,\n                                'DeleteOnTermination': True|False,\n                                'VolumeType': 'standard'|'io1'|'gp2'|'sc1'|'st1',\n                                'Iops': 123,\n                                'Encrypted': True|False\n                            },\n                            'NoDevice': 'string'\n                        },\n                    ],\n                    'SubnetId': 'string',\n                    'NetworkInterfaces': [\n                        {\n                            'NetworkInterfaceId': 'string',\n                            'DeviceIndex': 123,\n                            'SubnetId': 'string',\n                            'Description': 'string',\n                            'PrivateIpAddress': 'string',\n                            'Groups': [\n                                'string',\n                            ],\n                            'DeleteOnTermination': True|False,\n                            'PrivateIpAddresses': [\n                                {\n                                    'PrivateIpAddress': 'string',\n                                    'Primary': True|False\n                                },\n                            ],\n                            'SecondaryPrivateIpAddressCount': 123,\n                            'AssociatePublicIpAddress': True|False,\n                            'Ipv6Addresses': [\n                                {\n                                    'Ipv6Address': 'string'\n                                },\n                            ],\n                            'Ipv6AddressCount': 123\n                        },\n                    ],\n                    'IamInstanceProfile': {\n                        'Arn': 'string',\n                        'Name': 'string'\n                    },\n                    'EbsOptimized': True|False,\n                    'Monitoring': {\n                        'Enabled': True|False\n                    }\n                },\n                'InstanceId': 'string',\n                'CreateTime': datetime(2015, 1, 1),\n                'ProductDescription': 'Linux/UNIX'|'Linux/UNIX (Amazon VPC)'|'Windows'|'Windows (Amazon VPC)',\n                'BlockDurationMinutes': 123,\n                'ActualBlockHourlyPrice': 'string',\n                'Tags': [\n                    {\n                        'Key': 'string',\n                        'Value': 'string'\n                    },\n                ],\n                'LaunchedAvailabilityZone': 'string'\n            },\n        ]\n    }\n    \n    \n    :returns: \n    (string) --\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_instances(DryRun=None, ImageId=None, MinCount=None, MaxCount=None, KeyName=None, SecurityGroups=None, SecurityGroupIds=None, UserData=None, InstanceType=None, Placement=None, KernelId=None, RamdiskId=None, BlockDeviceMappings=None, Monitoring=None, SubnetId=None, DisableApiTermination=None, InstanceInitiatedShutdownBehavior=None, PrivateIpAddress=None, Ipv6Addresses=None, Ipv6AddressCount=None, ClientToken=None, AdditionalInfo=None, NetworkInterfaces=None, IamInstanceProfile=None, EbsOptimized=None, TagSpecifications=None):\n    pass", "response": "Runs a number of Linux Instances."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_environment(ApplicationName=None, EnvironmentName=None, GroupName=None, Description=None, CNAMEPrefix=None, Tier=None, Tags=None, VersionLabel=None, TemplateName=None, SolutionStackName=None, PlatformArn=None, OptionSettings=None, OptionsToRemove=None):\n    pass", "response": "Create an environment for a specified application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns list of event descriptions matching criteria up to the last 6 weeks. See also: AWS API Documentation Examples The following operation retrieves events for an environment named my-env: Expected Output: :example: response = client.describe_events( ApplicationName='string', VersionLabel='string', TemplateName='string', EnvironmentId='string', EnvironmentName='string', PlatformArn='string', RequestId='string', Severity='TRACE'|'DEBUG'|'INFO'|'WARN'|'ERROR'|'FATAL', StartTime=datetime(2015, 1, 1), EndTime=datetime(2015, 1, 1), MaxRecords=123, NextToken='string' ) :type ApplicationName: string :param ApplicationName: If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only those associated with this application. :type VersionLabel: string :param VersionLabel: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those associated with this application version. :type TemplateName: string :param TemplateName: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that are associated with this environment configuration. :type EnvironmentId: string :param EnvironmentId: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those associated with this environment. :type EnvironmentName: string :param EnvironmentName: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those associated with this environment. :type PlatformArn: string :param PlatformArn: The ARN of the version of the custom platform. :type RequestId: string :param RequestId: If specified, AWS Elastic Beanstalk restricts the described events to include only those associated with this request ID. :type Severity: string :param Severity: If specified, limits the events returned from this call to include only those with the specified severity or higher. :type StartTime: datetime :param StartTime: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that occur on or after this time. :type EndTime: datetime :param EndTime: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that occur up to, but not including, the EndTime . :type MaxRecords: integer :param MaxRecords: Specifies the maximum number of events that can be returned, beginning with the most recent event. :type NextToken: string :param NextToken: Pagination token. If specified, the events return the next batch of results. :rtype: dict :return: { 'Events': [ { 'EventDate': datetime(2015, 1, 1), 'Message': 'string', 'ApplicationName': 'string', 'VersionLabel': 'string', 'TemplateName': 'string', 'EnvironmentName': 'string', 'PlatformArn': 'string', 'RequestId': 'string', 'Severity': 'TRACE'|'DEBUG'|'INFO'|'WARN'|'ERROR'|'FATAL' }, ], 'NextToken': 'string' }", "response": "def describe_events(ApplicationName=None, VersionLabel=None, TemplateName=None, EnvironmentId=None, EnvironmentName=None, PlatformArn=None, RequestId=None, Severity=None, StartTime=None, EndTime=None, MaxRecords=None, NextToken=None):\n    \"\"\"\n    Returns list of event descriptions matching criteria up to the last 6 weeks.\n    See also: AWS API Documentation\n    \n    Examples\n    The following operation retrieves events for an environment named my-env:\n    Expected Output:\n    \n    :example: response = client.describe_events(\n        ApplicationName='string',\n        VersionLabel='string',\n        TemplateName='string',\n        EnvironmentId='string',\n        EnvironmentName='string',\n        PlatformArn='string',\n        RequestId='string',\n        Severity='TRACE'|'DEBUG'|'INFO'|'WARN'|'ERROR'|'FATAL',\n        StartTime=datetime(2015, 1, 1),\n        EndTime=datetime(2015, 1, 1),\n        MaxRecords=123,\n        NextToken='string'\n    )\n    \n    \n    :type ApplicationName: string\n    :param ApplicationName: If specified, AWS Elastic Beanstalk restricts the returned descriptions to include only those associated with this application.\n\n    :type VersionLabel: string\n    :param VersionLabel: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those associated with this application version.\n\n    :type TemplateName: string\n    :param TemplateName: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that are associated with this environment configuration.\n\n    :type EnvironmentId: string\n    :param EnvironmentId: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those associated with this environment.\n\n    :type EnvironmentName: string\n    :param EnvironmentName: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those associated with this environment.\n\n    :type PlatformArn: string\n    :param PlatformArn: The ARN of the version of the custom platform.\n\n    :type RequestId: string\n    :param RequestId: If specified, AWS Elastic Beanstalk restricts the described events to include only those associated with this request ID.\n\n    :type Severity: string\n    :param Severity: If specified, limits the events returned from this call to include only those with the specified severity or higher.\n\n    :type StartTime: datetime\n    :param StartTime: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that occur on or after this time.\n\n    :type EndTime: datetime\n    :param EndTime: If specified, AWS Elastic Beanstalk restricts the returned descriptions to those that occur up to, but not including, the EndTime .\n\n    :type MaxRecords: integer\n    :param MaxRecords: Specifies the maximum number of events that can be returned, beginning with the most recent event.\n\n    :type NextToken: string\n    :param NextToken: Pagination token. If specified, the events return the next batch of results.\n\n    :rtype: dict\n    :return: {\n        'Events': [\n            {\n                'EventDate': datetime(2015, 1, 1),\n                'Message': 'string',\n                'ApplicationName': 'string',\n                'VersionLabel': 'string',\n                'TemplateName': 'string',\n                'EnvironmentName': 'string',\n                'PlatformArn': 'string',\n                'RequestId': 'string',\n                'Severity': 'TRACE'|'DEBUG'|'INFO'|'WARN'|'ERROR'|'FATAL'\n            },\n        ],\n        'NextToken': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the environment description, deploys a new application version, updates the configuration settings to an entirely new configuration template, or updates select configuration option values in the running environment. Attempting to update both the release and configuration is not allowed and AWS Elastic Beanstalk returns an InvalidParameterCombination error. When updating the configuration settings to a new template or individual settings, a draft configuration is created and DescribeConfigurationSettings for this environment returns two setting descriptions with different DeploymentStatus values. See also: AWS API Documentation Examples The following operation updates an environment named \"my-env\" to version \"v2\" of the application to which it belongs: Expected Output: The following operation configures several options in the aws:elb:loadbalancer namespace: Expected Output: :example: response = client.update_environment( ApplicationName='string', EnvironmentId='string', EnvironmentName='string', GroupName='string', Description='string', Tier={ 'Name': 'string', 'Type': 'string', 'Version': 'string' }, VersionLabel='string', TemplateName='string', SolutionStackName='string', PlatformArn='string', OptionSettings=[ { 'ResourceName': 'string', 'Namespace': 'string', 'OptionName': 'string', 'Value': 'string' }, ], OptionsToRemove=[ { 'ResourceName': 'string', 'Namespace': 'string', 'OptionName': 'string' }, ] ) :type ApplicationName: string :param ApplicationName: The name of the application with which the environment is associated. :type EnvironmentId: string :param EnvironmentId: The ID of the environment to update. If no environment with this ID exists, AWS Elastic Beanstalk returns an InvalidParameterValue error. Condition: You must specify either this or an EnvironmentName, or both. If you do not specify either, AWS Elastic Beanstalk returns MissingRequiredParameter error. :type EnvironmentName: string :param EnvironmentName: The name of the environment to update. If no environment with this name exists, AWS Elastic Beanstalk returns an InvalidParameterValue error. Condition: You must specify either this or an EnvironmentId, or both. If you do not specify either, AWS Elastic Beanstalk returns MissingRequiredParameter error. :type GroupName: string :param GroupName: The name of the group to which the target environment belongs. Specify a group name only if the environment's name is specified in an environment manifest and not with the environment name or environment ID parameters. See Environment Manifest (env.yaml) for details. :type Description: string :param Description: If this parameter is specified, AWS Elastic Beanstalk updates the description of this environment. :type Tier: dict :param Tier: This specifies the tier to use to update the environment. Condition: At this time, if you change the tier version, name, or type, AWS Elastic Beanstalk returns InvalidParameterValue error. Name (string) --The name of this environment tier. Type (string) --The type of this environment tier. Version (string) --The version of this environment tier. :type VersionLabel: string :param VersionLabel: If this parameter is specified, AWS Elastic Beanstalk deploys the named application version to the environment. If no such application version is found, returns an InvalidParameterValue error. :type TemplateName: string :param TemplateName: If this parameter is specified, AWS Elastic Beanstalk deploys this configuration template to the environment. If no such configuration template is found, AWS Elastic Beanstalk returns an InvalidParameterValue error. :type SolutionStackName: string :param SolutionStackName: This specifies the platform version that the environment will run after the environment is updated. :type PlatformArn: string :param PlatformArn: The ARN of the platform, if used. :type OptionSettings: list :param OptionSettings: If specified, AWS Elastic Beanstalk updates the configuration set associated with the running environment and sets the specified configuration options to the requested value. (dict) --A specification identifying an individual configuration option along with its current value. For a list of possible option values, go to Option Values in the AWS Elastic Beanstalk Developer Guide . ResourceName (string) --A unique resource name for a time-based scaling configuration option. Namespace (string) --A unique namespace identifying the option's associated AWS resource. OptionName (string) --The name of the configuration option. Value (string) --The current value for the configuration option. :type OptionsToRemove: list :param OptionsToRemove: A list of custom user-defined configuration options to remove from the configuration set for this environment. (dict) --A specification identifying an individual configuration option. ResourceName (string) --A unique resource name for a time-based scaling configuration option. Namespace (string) --A unique namespace identifying the option's associated AWS resource. OptionName (string) --The name of the configuration option. :rtype: dict :return: { 'EnvironmentName': 'string', 'EnvironmentId': 'string', 'ApplicationName': 'string', 'VersionLabel': 'string', 'SolutionStackName': 'string', 'PlatformArn': 'string', 'TemplateName': 'string', 'Description': 'string', 'EndpointURL': 'string', 'CNAME': 'string', 'DateCreated': datetime(2015, 1, 1), 'DateUpdated': datetime(2015, 1, 1), 'Status': 'Launching'|'Updating'|'Ready'|'Terminating'|'Terminated', 'AbortableOperationInProgress': True|False, 'Health': 'Green'|'Yellow'|'Red'|'Grey', 'HealthStatus': 'NoData'|'Unknown'|'Pending'|'Ok'|'Info'|'Warning'|'Degraded'|'Severe', 'Resources': { 'LoadBalancer': { 'LoadBalancerName': 'string', 'Domain': 'string', 'Listeners': [ { 'Protocol': 'string', 'Port': 123 }, ] } }, 'Tier': { 'Name': 'string', 'Type': 'string', 'Version': 'string' }, 'EnvironmentLinks': [ { 'LinkName': 'string', 'EnvironmentName': 'string' }, ] } :returns: Launching : Environment is in the process of initial deployment. Updating : Environment is in the process of updating its configuration settings or application version. Ready : Environment is available to have an action performed on it, such as update or terminate. Terminating : Environment is in the shut-down process. Terminated : Environment is not running.", "response": "def update_environment(ApplicationName=None, EnvironmentId=None, EnvironmentName=None, GroupName=None, Description=None, Tier=None, VersionLabel=None, TemplateName=None, SolutionStackName=None, PlatformArn=None, OptionSettings=None, OptionsToRemove=None):\n    \"\"\"\n    Updates the environment description, deploys a new application version, updates the configuration settings to an entirely new configuration template, or updates select configuration option values in the running environment.\n    Attempting to update both the release and configuration is not allowed and AWS Elastic Beanstalk returns an InvalidParameterCombination error.\n    When updating the configuration settings to a new template or individual settings, a draft configuration is created and  DescribeConfigurationSettings for this environment returns two setting descriptions with different DeploymentStatus values.\n    See also: AWS API Documentation\n    \n    Examples\n    The following operation updates an environment named \"my-env\" to version \"v2\" of the application to which it belongs:\n    Expected Output:\n    The following operation configures several options in the aws:elb:loadbalancer namespace:\n    Expected Output:\n    \n    :example: response = client.update_environment(\n        ApplicationName='string',\n        EnvironmentId='string',\n        EnvironmentName='string',\n        GroupName='string',\n        Description='string',\n        Tier={\n            'Name': 'string',\n            'Type': 'string',\n            'Version': 'string'\n        },\n        VersionLabel='string',\n        TemplateName='string',\n        SolutionStackName='string',\n        PlatformArn='string',\n        OptionSettings=[\n            {\n                'ResourceName': 'string',\n                'Namespace': 'string',\n                'OptionName': 'string',\n                'Value': 'string'\n            },\n        ],\n        OptionsToRemove=[\n            {\n                'ResourceName': 'string',\n                'Namespace': 'string',\n                'OptionName': 'string'\n            },\n        ]\n    )\n    \n    \n    :type ApplicationName: string\n    :param ApplicationName: The name of the application with which the environment is associated.\n\n    :type EnvironmentId: string\n    :param EnvironmentId: The ID of the environment to update.\n            If no environment with this ID exists, AWS Elastic Beanstalk returns an InvalidParameterValue error.\n            Condition: You must specify either this or an EnvironmentName, or both. If you do not specify either, AWS Elastic Beanstalk returns MissingRequiredParameter error.\n            \n\n    :type EnvironmentName: string\n    :param EnvironmentName: The name of the environment to update. If no environment with this name exists, AWS Elastic Beanstalk returns an InvalidParameterValue error.\n            Condition: You must specify either this or an EnvironmentId, or both. If you do not specify either, AWS Elastic Beanstalk returns MissingRequiredParameter error.\n            \n\n    :type GroupName: string\n    :param GroupName: The name of the group to which the target environment belongs. Specify a group name only if the environment's name is specified in an environment manifest and not with the environment name or environment ID parameters. See Environment Manifest (env.yaml) for details.\n\n    :type Description: string\n    :param Description: If this parameter is specified, AWS Elastic Beanstalk updates the description of this environment.\n\n    :type Tier: dict\n    :param Tier: This specifies the tier to use to update the environment.\n            Condition: At this time, if you change the tier version, name, or type, AWS Elastic Beanstalk returns InvalidParameterValue error.\n            Name (string) --The name of this environment tier.\n            Type (string) --The type of this environment tier.\n            Version (string) --The version of this environment tier.\n            \n\n    :type VersionLabel: string\n    :param VersionLabel: If this parameter is specified, AWS Elastic Beanstalk deploys the named application version to the environment. If no such application version is found, returns an InvalidParameterValue error.\n\n    :type TemplateName: string\n    :param TemplateName: If this parameter is specified, AWS Elastic Beanstalk deploys this configuration template to the environment. If no such configuration template is found, AWS Elastic Beanstalk returns an InvalidParameterValue error.\n\n    :type SolutionStackName: string\n    :param SolutionStackName: This specifies the platform version that the environment will run after the environment is updated.\n\n    :type PlatformArn: string\n    :param PlatformArn: The ARN of the platform, if used.\n\n    :type OptionSettings: list\n    :param OptionSettings: If specified, AWS Elastic Beanstalk updates the configuration set associated with the running environment and sets the specified configuration options to the requested value.\n            (dict) --A specification identifying an individual configuration option along with its current value. For a list of possible option values, go to Option Values in the AWS Elastic Beanstalk Developer Guide .\n            ResourceName (string) --A unique resource name for a time-based scaling configuration option.\n            Namespace (string) --A unique namespace identifying the option's associated AWS resource.\n            OptionName (string) --The name of the configuration option.\n            Value (string) --The current value for the configuration option.\n            \n            \n\n    :type OptionsToRemove: list\n    :param OptionsToRemove: A list of custom user-defined configuration options to remove from the configuration set for this environment.\n            (dict) --A specification identifying an individual configuration option.\n            ResourceName (string) --A unique resource name for a time-based scaling configuration option.\n            Namespace (string) --A unique namespace identifying the option's associated AWS resource.\n            OptionName (string) --The name of the configuration option.\n            \n            \n\n    :rtype: dict\n    :return: {\n        'EnvironmentName': 'string',\n        'EnvironmentId': 'string',\n        'ApplicationName': 'string',\n        'VersionLabel': 'string',\n        'SolutionStackName': 'string',\n        'PlatformArn': 'string',\n        'TemplateName': 'string',\n        'Description': 'string',\n        'EndpointURL': 'string',\n        'CNAME': 'string',\n        'DateCreated': datetime(2015, 1, 1),\n        'DateUpdated': datetime(2015, 1, 1),\n        'Status': 'Launching'|'Updating'|'Ready'|'Terminating'|'Terminated',\n        'AbortableOperationInProgress': True|False,\n        'Health': 'Green'|'Yellow'|'Red'|'Grey',\n        'HealthStatus': 'NoData'|'Unknown'|'Pending'|'Ok'|'Info'|'Warning'|'Degraded'|'Severe',\n        'Resources': {\n            'LoadBalancer': {\n                'LoadBalancerName': 'string',\n                'Domain': 'string',\n                'Listeners': [\n                    {\n                        'Protocol': 'string',\n                        'Port': 123\n                    },\n                ]\n            }\n        },\n        'Tier': {\n            'Name': 'string',\n            'Type': 'string',\n            'Version': 'string'\n        },\n        'EnvironmentLinks': [\n            {\n                'LinkName': 'string',\n                'EnvironmentName': 'string'\n            },\n        ]\n    }\n    \n    \n    :returns: \n    Launching : Environment is in the process of initial deployment.\n    Updating : Environment is in the process of updating its configuration settings or application version.\n    Ready : Environment is available to have an action performed on it, such as update or terminate.\n    Terminating : Environment is in the shut-down process.\n    Terminated : Environment is not running.\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_function(FunctionName=None, Runtime=None, Role=None, Handler=None, Code=None, Description=None, Timeout=None, MemorySize=None, Publish=None, VpcConfig=None, DeadLetterConfig=None, Environment=None, KMSKeyArn=None, TracingConfig=None, Tags=None):\n    pass", "response": "This function creates a new Lambda function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the configuration parameters for the specified Lambda function by using the values provided in the request. You provide only the parameters you want to change. This operation must only be used on an existing Lambda function and cannot be used to update the function's code. If you are using the versioning feature, note this API will always update the $LATEST version of your Lambda function. For information about the versioning feature, see AWS Lambda Function Versioning and Aliases . This operation requires permission for the lambda:UpdateFunctionConfiguration action. See also: AWS API Documentation Examples This operation updates a Lambda function's configuration Expected Output: :example: response = client.update_function_configuration( FunctionName='string', Role='string', Handler='string', Description='string', Timeout=123, MemorySize=123, VpcConfig={ 'SubnetIds': [ 'string', ], 'SecurityGroupIds': [ 'string', ] }, Environment={ 'Variables': { 'string': 'string' } }, Runtime='nodejs'|'nodejs4.3'|'nodejs6.10'|'java8'|'python2.7'|'python3.6'|'dotnetcore1.0'|'nodejs4.3-edge', DeadLetterConfig={ 'TargetArn': 'string' }, KMSKeyArn='string', TracingConfig={ 'Mode': 'Active'|'PassThrough' } ) :type FunctionName: string :param FunctionName: [REQUIRED] The name of the Lambda function. You can specify a function name (for example, Thumbnail ) or you can specify Amazon Resource Name (ARN) of the function (for example, arn:aws:lambda:us-west-2:account-id:function:ThumbNail ). AWS Lambda also allows you to specify a partial ARN (for example, account-id:Thumbnail ). Note that the length constraint applies only to the ARN. If you specify only the function name, it is limited to 64 character in length. :type Role: string :param Role: The Amazon Resource Name (ARN) of the IAM role that Lambda will assume when it executes your function. :type Handler: string :param Handler: The function that Lambda calls to begin executing your function. For Node.js, it is the module-name.export value in your function. :type Description: string :param Description: A short user-defined function description. AWS Lambda does not use this value. Assign a meaningful description as you see fit. :type Timeout: integer :param Timeout: The function execution time at which AWS Lambda should terminate the function. Because the execution time has cost implications, we recommend you set this value based on your expected execution time. The default is 3 seconds. :type MemorySize: integer :param MemorySize: The amount of memory, in MB, your Lambda function is given. AWS Lambda uses this memory size to infer the amount of CPU allocated to your function. Your function use-case determines your CPU and memory requirements. For example, a database operation might need less memory compared to an image processing function. The default value is 128 MB. The value must be a multiple of 64 MB. :type VpcConfig: dict :param VpcConfig: If your Lambda function accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID. SubnetIds (list) --A list of one or more subnet IDs in your VPC. (string) -- SecurityGroupIds (list) --A list of one or more security groups IDs in your VPC. (string) -- :type Environment: dict :param Environment: The parent object that contains your environment's configuration settings. Variables (dict) --The key-value pairs that represent your environment's configuration settings. (string) -- (string) -- :type Runtime: string :param Runtime: The runtime environment for the Lambda function. To use the Python runtime v3.6, set the value to 'python3.6'. To use the Python runtime v2.7, set the value to 'python2.7'. To use the Node.js runtime v6.10, set the value to 'nodejs6.10'. To use the Node.js runtime v4.3, set the value to 'nodejs4.3'. To use the Python runtime v3.6, set the value to 'python3.6'. To use the Python runtime v2.7, set the value to 'python2.7'. Note You can no longer downgrade to the v0.10.42 runtime version. This version will no longer be supported as of early 2017. :type DeadLetterConfig: dict :param DeadLetterConfig: The parent object that contains the target ARN (Amazon Resource Name) of an Amazon SQS queue or Amazon SNS topic. TargetArn (string) --The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic you specify as your Dead Letter Queue (DLQ). :type KMSKeyArn: string :param KMSKeyArn: The Amazon Resource Name (ARN) of the KMS key used to encrypt your function's environment variables. If you elect to use the AWS Lambda default service key, pass in an empty string ('') for this parameter. :type TracingConfig: dict :param TracingConfig: The parent object that contains your function's tracing settings. Mode (string) --Can be either PassThrough or Active. If PassThrough, Lambda will only trace the request from an upstream service if it contains a tracing header with 'sampled=1'. If Active, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision. :rtype: dict :return: { 'FunctionName': 'string', 'FunctionArn': 'string', 'Runtime': 'nodejs'|'nodejs4.3'|'nodejs6.10'|'java8'|'python2.7'|'python3.6'|'dotnetcore1.0'|'nodejs4.3-edge', 'Role': 'string', 'Handler': 'string', 'CodeSize': 123, 'Description': 'string', 'Timeout': 123, 'MemorySize': 123, 'LastModified': 'string', 'CodeSha256': 'string', 'Version': 'string', 'VpcConfig': { 'SubnetIds': [ 'string', ], 'SecurityGroupIds': [ 'string', ], 'VpcId': 'string' }, 'DeadLetterConfig': { 'TargetArn': 'string' }, 'Environment': { 'Variables': { 'string': 'string' }, 'Error': { 'ErrorCode': 'string', 'Message': 'string' } }, 'KMSKeyArn': 'string', 'TracingConfig': { 'Mode': 'Active'|'PassThrough' } } :returns: (string) --", "response": "def update_function_configuration(FunctionName=None, Role=None, Handler=None, Description=None, Timeout=None, MemorySize=None, VpcConfig=None, Environment=None, Runtime=None, DeadLetterConfig=None, KMSKeyArn=None, TracingConfig=None):\n    \"\"\"\n    Updates the configuration parameters for the specified Lambda function by using the values provided in the request. You provide only the parameters you want to change. This operation must only be used on an existing Lambda function and cannot be used to update the function's code.\n    If you are using the versioning feature, note this API will always update the $LATEST version of your Lambda function. For information about the versioning feature, see AWS Lambda Function Versioning and Aliases .\n    This operation requires permission for the lambda:UpdateFunctionConfiguration action.\n    See also: AWS API Documentation\n    \n    Examples\n    This operation updates a Lambda function's configuration\n    Expected Output:\n    \n    :example: response = client.update_function_configuration(\n        FunctionName='string',\n        Role='string',\n        Handler='string',\n        Description='string',\n        Timeout=123,\n        MemorySize=123,\n        VpcConfig={\n            'SubnetIds': [\n                'string',\n            ],\n            'SecurityGroupIds': [\n                'string',\n            ]\n        },\n        Environment={\n            'Variables': {\n                'string': 'string'\n            }\n        },\n        Runtime='nodejs'|'nodejs4.3'|'nodejs6.10'|'java8'|'python2.7'|'python3.6'|'dotnetcore1.0'|'nodejs4.3-edge',\n        DeadLetterConfig={\n            'TargetArn': 'string'\n        },\n        KMSKeyArn='string',\n        TracingConfig={\n            'Mode': 'Active'|'PassThrough'\n        }\n    )\n    \n    \n    :type FunctionName: string\n    :param FunctionName: [REQUIRED]\n            The name of the Lambda function.\n            You can specify a function name (for example, Thumbnail ) or you can specify Amazon Resource Name (ARN) of the function (for example, arn:aws:lambda:us-west-2:account-id:function:ThumbNail ). AWS Lambda also allows you to specify a partial ARN (for example, account-id:Thumbnail ). Note that the length constraint applies only to the ARN. If you specify only the function name, it is limited to 64 character in length.\n            \n\n    :type Role: string\n    :param Role: The Amazon Resource Name (ARN) of the IAM role that Lambda will assume when it executes your function.\n\n    :type Handler: string\n    :param Handler: The function that Lambda calls to begin executing your function. For Node.js, it is the module-name.export value in your function.\n\n    :type Description: string\n    :param Description: A short user-defined function description. AWS Lambda does not use this value. Assign a meaningful description as you see fit.\n\n    :type Timeout: integer\n    :param Timeout: The function execution time at which AWS Lambda should terminate the function. Because the execution time has cost implications, we recommend you set this value based on your expected execution time. The default is 3 seconds.\n\n    :type MemorySize: integer\n    :param MemorySize: The amount of memory, in MB, your Lambda function is given. AWS Lambda uses this memory size to infer the amount of CPU allocated to your function. Your function use-case determines your CPU and memory requirements. For example, a database operation might need less memory compared to an image processing function. The default value is 128 MB. The value must be a multiple of 64 MB.\n\n    :type VpcConfig: dict\n    :param VpcConfig: If your Lambda function accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.\n            SubnetIds (list) --A list of one or more subnet IDs in your VPC.\n            (string) --\n            SecurityGroupIds (list) --A list of one or more security groups IDs in your VPC.\n            (string) --\n            \n\n    :type Environment: dict\n    :param Environment: The parent object that contains your environment's configuration settings.\n            Variables (dict) --The key-value pairs that represent your environment's configuration settings.\n            (string) --\n            (string) --\n            \n            \n\n    :type Runtime: string\n    :param Runtime: The runtime environment for the Lambda function.\n            To use the Python runtime v3.6, set the value to 'python3.6'. To use the Python runtime v2.7, set the value to 'python2.7'. To use the Node.js runtime v6.10, set the value to 'nodejs6.10'. To use the Node.js runtime v4.3, set the value to 'nodejs4.3'. To use the Python runtime v3.6, set the value to 'python3.6'. To use the Python runtime v2.7, set the value to 'python2.7'.\n            Note\n            You can no longer downgrade to the v0.10.42 runtime version. This version will no longer be supported as of early 2017.\n            \n\n    :type DeadLetterConfig: dict\n    :param DeadLetterConfig: The parent object that contains the target ARN (Amazon Resource Name) of an Amazon SQS queue or Amazon SNS topic.\n            TargetArn (string) --The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic you specify as your Dead Letter Queue (DLQ).\n            \n\n    :type KMSKeyArn: string\n    :param KMSKeyArn: The Amazon Resource Name (ARN) of the KMS key used to encrypt your function's environment variables. If you elect to use the AWS Lambda default service key, pass in an empty string ('') for this parameter.\n\n    :type TracingConfig: dict\n    :param TracingConfig: The parent object that contains your function's tracing settings.\n            Mode (string) --Can be either PassThrough or Active. If PassThrough, Lambda will only trace the request from an upstream service if it contains a tracing header with 'sampled=1'. If Active, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.\n            \n\n    :rtype: dict\n    :return: {\n        'FunctionName': 'string',\n        'FunctionArn': 'string',\n        'Runtime': 'nodejs'|'nodejs4.3'|'nodejs6.10'|'java8'|'python2.7'|'python3.6'|'dotnetcore1.0'|'nodejs4.3-edge',\n        'Role': 'string',\n        'Handler': 'string',\n        'CodeSize': 123,\n        'Description': 'string',\n        'Timeout': 123,\n        'MemorySize': 123,\n        'LastModified': 'string',\n        'CodeSha256': 'string',\n        'Version': 'string',\n        'VpcConfig': {\n            'SubnetIds': [\n                'string',\n            ],\n            'SecurityGroupIds': [\n                'string',\n            ],\n            'VpcId': 'string'\n        },\n        'DeadLetterConfig': {\n            'TargetArn': 'string'\n        },\n        'Environment': {\n            'Variables': {\n                'string': 'string'\n            },\n            'Error': {\n                'ErrorCode': 'string',\n                'Message': 'string'\n            }\n        },\n        'KMSKeyArn': 'string',\n        'TracingConfig': {\n            'Mode': 'Active'|'PassThrough'\n        }\n    }\n    \n    \n    :returns: \n    (string) --\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_trail(Name=None, S3BucketName=None, S3KeyPrefix=None, SnsTopicName=None, IncludeGlobalServiceEvents=None, IsMultiRegionTrail=None, EnableLogFileValidation=None, CloudWatchLogsLogGroupArn=None, CloudWatchLogsRoleArn=None, KmsKeyId=None):\n    pass", "response": "Creates a new CloudTrail log trail."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new cluster in a Virtual Private Cloud.", "response": "def create_cluster(DBName=None, ClusterIdentifier=None, ClusterType=None, NodeType=None, MasterUsername=None, MasterUserPassword=None, ClusterSecurityGroups=None, VpcSecurityGroupIds=None, ClusterSubnetGroupName=None, AvailabilityZone=None, PreferredMaintenanceWindow=None, ClusterParameterGroupName=None, AutomatedSnapshotRetentionPeriod=None, Port=None, ClusterVersion=None, AllowVersionUpgrade=None, NumberOfNodes=None, PubliclyAccessible=None, Encrypted=None, HsmClientCertificateIdentifier=None, HsmConfigurationIdentifier=None, ElasticIp=None, Tags=None, KmsKeyId=None, EnhancedVpcRouting=None, AdditionalInfo=None, IamRoles=None):\n    \"\"\"\n    Creates a new cluster.\n    To create the cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to Amazon Redshift Clusters in the Amazon Redshift Cluster Management Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.create_cluster(\n        DBName='string',\n        ClusterIdentifier='string',\n        ClusterType='string',\n        NodeType='string',\n        MasterUsername='string',\n        MasterUserPassword='string',\n        ClusterSecurityGroups=[\n            'string',\n        ],\n        VpcSecurityGroupIds=[\n            'string',\n        ],\n        ClusterSubnetGroupName='string',\n        AvailabilityZone='string',\n        PreferredMaintenanceWindow='string',\n        ClusterParameterGroupName='string',\n        AutomatedSnapshotRetentionPeriod=123,\n        Port=123,\n        ClusterVersion='string',\n        AllowVersionUpgrade=True|False,\n        NumberOfNodes=123,\n        PubliclyAccessible=True|False,\n        Encrypted=True|False,\n        HsmClientCertificateIdentifier='string',\n        HsmConfigurationIdentifier='string',\n        ElasticIp='string',\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        KmsKeyId='string',\n        EnhancedVpcRouting=True|False,\n        AdditionalInfo='string',\n        IamRoles=[\n            'string',\n        ]\n    )\n    \n    \n    :type DBName: string\n    :param DBName: The name of the first database to be created when the cluster is created.\n            To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to Create a Database in the Amazon Redshift Database Developer Guide.\n            Default: dev\n            Constraints:\n            Must contain 1 to 64 alphanumeric characters.\n            Must contain only lowercase letters.\n            Cannot be a word that is reserved by the service. A list of reserved words can be found in Reserved Words in the Amazon Redshift Database Developer Guide.\n            \n\n    :type ClusterIdentifier: string\n    :param ClusterIdentifier: [REQUIRED]\n            A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.\n            Constraints:\n            Must contain from 1 to 63 alphanumeric characters or hyphens.\n            Alphabetic characters must be lowercase.\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            Must be unique for all clusters within an AWS account.\n            Example: myexamplecluster\n            \n\n    :type ClusterType: string\n    :param ClusterType: The type of the cluster. When cluster type is specified as\n            single-node , the NumberOfNodes parameter is not required.\n            multi-node , the NumberOfNodes parameter is required.\n            Valid Values: multi-node | single-node\n            Default: multi-node\n            \n\n    :type NodeType: string\n    :param NodeType: [REQUIRED]\n            The node type to be provisioned for the cluster. For information about node types, go to Working with Clusters in the Amazon Redshift Cluster Management Guide .\n            Valid Values: ds1.xlarge | ds1.8xlarge | ds2.xlarge | ds2.8xlarge | dc1.large | dc1.8xlarge .\n            \n\n    :type MasterUsername: string\n    :param MasterUsername: [REQUIRED]\n            The user name associated with the master user account for the cluster that is being created.\n            Constraints:\n            Must be 1 - 128 alphanumeric characters.\n            First character must be a letter.\n            Cannot be a reserved word. A list of reserved words can be found in Reserved Words in the Amazon Redshift Database Developer Guide.\n            \n\n    :type MasterUserPassword: string\n    :param MasterUserPassword: [REQUIRED]\n            The password associated with the master user account for the cluster that is being created.\n            Constraints:\n            Must be between 8 and 64 characters in length.\n            Must contain at least one uppercase letter.\n            Must contain at least one lowercase letter.\n            Must contain one number.\n            Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), ' (double quote), , /, @, or space.\n            \n\n    :type ClusterSecurityGroups: list\n    :param ClusterSecurityGroups: A list of security groups to be associated with this cluster.\n            Default: The default cluster security group for Amazon Redshift.\n            (string) --\n            \n\n    :type VpcSecurityGroupIds: list\n    :param VpcSecurityGroupIds: A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.\n            Default: The default VPC security group is associated with the cluster.\n            (string) --\n            \n\n    :type ClusterSubnetGroupName: string\n    :param ClusterSubnetGroupName: The name of a cluster subnet group to be associated with this cluster.\n            If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).\n            \n\n    :type AvailabilityZone: string\n    :param AvailabilityZone: The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.\n            Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.\n            Example: us-east-1d\n            Constraint: The specified Availability Zone must be in the same region as the current endpoint.\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: The weekly time range (in UTC) during which automated cluster maintenance can occur.\n            Format: ddd:hh24:mi-ddd:hh24:mi\n            Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see Maintenance Windows in Amazon Redshift Cluster Management Guide.\n            Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun\n            Constraints: Minimum 30-minute window.\n            \n\n    :type ClusterParameterGroupName: string\n    :param ClusterParameterGroupName: The name of the parameter group to be associated with this cluster.\n            Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to Working with Amazon Redshift Parameter Groups\n            Constraints:\n            Must be 1 to 255 alphanumeric characters or hyphens.\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            \n\n    :type AutomatedSnapshotRetentionPeriod: integer\n    :param AutomatedSnapshotRetentionPeriod: The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with CreateClusterSnapshot .\n            Default: 1\n            Constraints: Must be a value from 0 to 35.\n            \n\n    :type Port: integer\n    :param Port: The port number on which the cluster accepts incoming connections.\n            The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.\n            Default: 5439\n            Valid Values: 1150-65535\n            \n\n    :type ClusterVersion: string\n    :param ClusterVersion: The version of the Amazon Redshift engine software that you want to deploy on the cluster.\n            The version selected runs on all the nodes in the cluster.\n            Constraints: Only version 1.0 is currently available.\n            Example: 1.0\n            \n\n    :type AllowVersionUpgrade: boolean\n    :param AllowVersionUpgrade: If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.\n            When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.\n            Default: true\n            \n\n    :type NumberOfNodes: integer\n    :param NumberOfNodes: The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node .\n            For information about determining how many nodes you need, go to Working with Clusters in the Amazon Redshift Cluster Management Guide .\n            If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.\n            Default: 1\n            Constraints: Value must be at least 1 and no more than 100.\n            \n\n    :type PubliclyAccessible: boolean\n    :param PubliclyAccessible: If true , the cluster can be accessed from a public network.\n\n    :type Encrypted: boolean\n    :param Encrypted: If true , the data in the cluster is encrypted at rest.\n            Default: false\n            \n\n    :type HsmClientCertificateIdentifier: string\n    :param HsmClientCertificateIdentifier: Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.\n\n    :type HsmConfigurationIdentifier: string\n    :param HsmConfigurationIdentifier: Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.\n\n    :type ElasticIp: string\n    :param ElasticIp: The Elastic IP (EIP) address for the cluster.\n            Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to Supported Platforms to Launch Your Cluster in the Amazon Redshift Cluster Management Guide.\n            \n\n    :type Tags: list\n    :param Tags: A list of tag instances.\n            (dict) --A tag consisting of a name/value pair for a resource.\n            Key (string) --The key, or name, for the resource tag.\n            Value (string) --The value for the resource tag.\n            \n            \n\n    :type KmsKeyId: string\n    :param KmsKeyId: The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.\n\n    :type EnhancedVpcRouting: boolean\n    :param EnhancedVpcRouting: An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing in the Amazon Redshift Cluster Management Guide.\n            If this option is true , enhanced VPC routing is enabled.\n            Default: false\n            \n\n    :type AdditionalInfo: string\n    :param AdditionalInfo: Reserved.\n\n    :type IamRoles: list\n    :param IamRoles: A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.\n            A cluster can have up to 10 IAM roles associated with it at any time.\n            (string) --\n            \n\n    :rtype: dict\n    :return: {\n        'Cluster': {\n            'ClusterIdentifier': 'string',\n            'NodeType': 'string',\n            'ClusterStatus': 'string',\n            'ModifyStatus': 'string',\n            'MasterUsername': 'string',\n            'DBName': 'string',\n            'Endpoint': {\n                'Address': 'string',\n                'Port': 123\n            },\n            'ClusterCreateTime': datetime(2015, 1, 1),\n            'AutomatedSnapshotRetentionPeriod': 123,\n            'ClusterSecurityGroups': [\n                {\n                    'ClusterSecurityGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'ClusterParameterGroups': [\n                {\n                    'ParameterGroupName': 'string',\n                    'ParameterApplyStatus': 'string',\n                    'ClusterParameterStatusList': [\n                        {\n                            'ParameterName': 'string',\n                            'ParameterApplyStatus': 'string',\n                            'ParameterApplyErrorDescription': 'string'\n                        },\n                    ]\n                },\n            ],\n            'ClusterSubnetGroupName': 'string',\n            'VpcId': 'string',\n            'AvailabilityZone': 'string',\n            'PreferredMaintenanceWindow': 'string',\n            'PendingModifiedValues': {\n                'MasterUserPassword': 'string',\n                'NodeType': 'string',\n                'NumberOfNodes': 123,\n                'ClusterType': 'string',\n                'ClusterVersion': 'string',\n                'AutomatedSnapshotRetentionPeriod': 123,\n                'ClusterIdentifier': 'string',\n                'PubliclyAccessible': True|False,\n                'EnhancedVpcRouting': True|False\n            },\n            'ClusterVersion': 'string',\n            'AllowVersionUpgrade': True|False,\n            'NumberOfNodes': 123,\n            'PubliclyAccessible': True|False,\n            'Encrypted': True|False,\n            'RestoreStatus': {\n                'Status': 'string',\n                'CurrentRestoreRateInMegaBytesPerSecond': 123.0,\n                'SnapshotSizeInMegaBytes': 123,\n                'ProgressInMegaBytes': 123,\n                'ElapsedTimeInSeconds': 123,\n                'EstimatedTimeToCompletionInSeconds': 123\n            },\n            'HsmStatus': {\n                'HsmClientCertificateIdentifier': 'string',\n                'HsmConfigurationIdentifier': 'string',\n                'Status': 'string'\n            },\n            'ClusterSnapshotCopyStatus': {\n                'DestinationRegion': 'string',\n                'RetentionPeriod': 123,\n                'SnapshotCopyGrantName': 'string'\n            },\n            'ClusterPublicKey': 'string',\n            'ClusterNodes': [\n                {\n                    'NodeRole': 'string',\n                    'PrivateIPAddress': 'string',\n                    'PublicIPAddress': 'string'\n                },\n            ],\n            'ElasticIpStatus': {\n                'ElasticIp': 'string',\n                'Status': 'string'\n            },\n            'ClusterRevisionNumber': 'string',\n            'Tags': [\n                {\n                    'Key': 'string',\n                    'Value': 'string'\n                },\n            ],\n            'KmsKeyId': 'string',\n            'EnhancedVpcRouting': True|False,\n            'IamRoles': [\n                {\n                    'IamRoleArn': 'string',\n                    'ApplyStatus': 'string'\n                },\n            ]\n        }\n    }\n    \n    \n    :returns: \n    available\n    creating\n    deleting\n    final-snapshot\n    hardware-failure\n    incompatible-hsm\n    incompatible-network\n    incompatible-parameters\n    incompatible-restore\n    modifying\n    rebooting\n    renaming\n    resizing\n    rotating-keys\n    storage-full\n    updating-hsm\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef describe_cluster_snapshots(ClusterIdentifier=None, SnapshotIdentifier=None, SnapshotType=None, StartTime=None, EndTime=None, MaxRecords=None, Marker=None, OwnerAccount=None, TagKeys=None, TagValues=None):\n    pass", "response": "This function returns one or more snapshot objects which contain metadata about your cluster snapshots."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef modify_cluster(ClusterIdentifier=None, ClusterType=None, NodeType=None, NumberOfNodes=None, ClusterSecurityGroups=None, VpcSecurityGroupIds=None, MasterUserPassword=None, ClusterParameterGroupName=None, AutomatedSnapshotRetentionPeriod=None, PreferredMaintenanceWindow=None, ClusterVersion=None, AllowVersionUpgrade=None, HsmClientCertificateIdentifier=None, HsmConfigurationIdentifier=None, NewClusterIdentifier=None, PubliclyAccessible=None, ElasticIp=None, EnhancedVpcRouting=None):\n    pass", "response": "This function is used to modify the settings for a cluster. You can modify the settings for a cluster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the ModifyCluster API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore. If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored. For more information about working with snapshots, go to Amazon Redshift Snapshots in the Amazon Redshift Cluster Management Guide . See also: AWS API Documentation :example: response = client.restore_from_cluster_snapshot( ClusterIdentifier='string', SnapshotIdentifier='string', SnapshotClusterIdentifier='string', Port=123, AvailabilityZone='string', AllowVersionUpgrade=True|False, ClusterSubnetGroupName='string', PubliclyAccessible=True|False, OwnerAccount='string', HsmClientCertificateIdentifier='string', HsmConfigurationIdentifier='string', ElasticIp='string', ClusterParameterGroupName='string', ClusterSecurityGroups=[ 'string', ], VpcSecurityGroupIds=[ 'string', ], PreferredMaintenanceWindow='string', AutomatedSnapshotRetentionPeriod=123, KmsKeyId='string', NodeType='string', EnhancedVpcRouting=True|False, AdditionalInfo='string', IamRoles=[ 'string', ] ) :type ClusterIdentifier: string :param ClusterIdentifier: [REQUIRED] The identifier of the cluster that will be created from restoring the snapshot. Constraints: Must contain from 1 to 63 alphanumeric characters or hyphens. Alphabetic characters must be lowercase. First character must be a letter. Cannot end with a hyphen or contain two consecutive hyphens. Must be unique for all clusters within an AWS account. :type SnapshotIdentifier: string :param SnapshotIdentifier: [REQUIRED] The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive. Example: my-snapshot-id :type SnapshotClusterIdentifier: string :param SnapshotClusterIdentifier: The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. :type Port: integer :param Port: The port number on which the cluster accepts connections. Default: The same port as the original cluster. Constraints: Must be between 1115 and 65535 . :type AvailabilityZone: string :param AvailabilityZone: The Amazon EC2 Availability Zone in which to restore the cluster. Default: A random, system-chosen Availability Zone. Example: us-east-1a :type AllowVersionUpgrade: boolean :param AllowVersionUpgrade: If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default: true :type ClusterSubnetGroupName: string :param ClusterSubnetGroupName: The name of the subnet group where you want to cluster restored. A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored. :type PubliclyAccessible: boolean :param PubliclyAccessible: If true , the cluster can be accessed from a public network. :type OwnerAccount: string :param OwnerAccount: The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. :type HsmClientCertificateIdentifier: string :param HsmClientCertificateIdentifier: Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. :type HsmConfigurationIdentifier: string :param HsmConfigurationIdentifier: Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. :type ElasticIp: string :param ElasticIp: The elastic IP (EIP) address for the cluster. :type ClusterParameterGroupName: string :param ClusterParameterGroupName: The name of the parameter group to be associated with this cluster. Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to Working with Amazon Redshift Parameter Groups . Constraints: Must be 1 to 255 alphanumeric characters or hyphens. First character must be a letter. Cannot end with a hyphen or contain two consecutive hyphens. :type ClusterSecurityGroups: list :param ClusterSecurityGroups: A list of security groups to be associated with this cluster. Default: The default cluster security group for Amazon Redshift. Cluster security groups only apply to clusters outside of VPCs. (string) -- :type VpcSecurityGroupIds: list :param VpcSecurityGroupIds: A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster. Default: The default VPC security group is associated with the cluster. VPC security groups only apply to clusters in VPCs. (string) -- :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: The weekly time range (in UTC) during which automated cluster maintenance can occur. Format: ddd:hh24:mi-ddd:hh24:mi Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see Maintenance Windows in Amazon Redshift Cluster Management Guide. Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Minimum 30-minute window. :type AutomatedSnapshotRetentionPeriod: integer :param AutomatedSnapshotRetentionPeriod: The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with CreateClusterSnapshot . Default: The value selected for the cluster from which the snapshot was taken. Constraints: Must be a value from 0 to 35. :type KmsKeyId: string :param KmsKeyId: The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot. :type NodeType: string :param NodeType: The node type that the restored cluster will be provisioned with. Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds2.xlarge into ds1.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type. For more information about node types, see About Clusters and Nodes in the Amazon Redshift Cluster Management Guide :type EnhancedVpcRouting: boolean :param EnhancedVpcRouting: An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing in the Amazon Redshift Cluster Management Guide. If this option is true , enhanced VPC routing is enabled. Default: false :type AdditionalInfo: string :param AdditionalInfo: Reserved. :type IamRoles: list :param IamRoles: A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request. A cluster can have up to 10 IAM roles associated at any time. (string) -- :rtype: dict :return: { 'Cluster': { 'ClusterIdentifier': 'string', 'NodeType': 'string', 'ClusterStatus': 'string', 'ModifyStatus': 'string', 'MasterUsername': 'string', 'DBName': 'string', 'Endpoint': { 'Address': 'string', 'Port': 123 }, 'ClusterCreateTime': datetime(2015, 1, 1), 'AutomatedSnapshotRetentionPeriod': 123, 'ClusterSecurityGroups': [ { 'ClusterSecurityGroupName': 'string', 'Status': 'string' }, ], 'VpcSecurityGroups': [ { 'VpcSecurityGroupId': 'string', 'Status': 'string' }, ], 'ClusterParameterGroups': [ { 'ParameterGroupName': 'string', 'ParameterApplyStatus': 'string', 'ClusterParameterStatusList': [ { 'ParameterName': 'string', 'ParameterApplyStatus': 'string', 'ParameterApplyErrorDescription': 'string' }, ] }, ], 'ClusterSubnetGroupName': 'string', 'VpcId': 'string', 'AvailabilityZone': 'string', 'PreferredMaintenanceWindow': 'string', 'PendingModifiedValues': { 'MasterUserPassword': 'string', 'NodeType': 'string', 'NumberOfNodes': 123, 'ClusterType': 'string', 'ClusterVersion': 'string', 'AutomatedSnapshotRetentionPeriod': 123, 'ClusterIdentifier': 'string', 'PubliclyAccessible': True|False, 'EnhancedVpcRouting': True|False }, 'ClusterVersion': 'string', 'AllowVersionUpgrade': True|False, 'NumberOfNodes': 123, 'PubliclyAccessible': True|False, 'Encrypted': True|False, 'RestoreStatus': { 'Status': 'string', 'CurrentRestoreRateInMegaBytesPerSecond': 123.0, 'SnapshotSizeInMegaBytes': 123, 'ProgressInMegaBytes': 123, 'ElapsedTimeInSeconds': 123, 'EstimatedTimeToCompletionInSeconds': 123 }, 'HsmStatus': { 'HsmClientCertificateIdentifier': 'string', 'HsmConfigurationIdentifier': 'string', 'Status': 'string' }, 'ClusterSnapshotCopyStatus': { 'DestinationRegion': 'string', 'RetentionPeriod': 123, 'SnapshotCopyGrantName': 'string' }, 'ClusterPublicKey': 'string', 'ClusterNodes': [ { 'NodeRole': 'string', 'PrivateIPAddress': 'string', 'PublicIPAddress': 'string' }, ], 'ElasticIpStatus': { 'ElasticIp': 'string', 'Status': 'string' }, 'ClusterRevisionNumber': 'string', 'Tags': [ { 'Key': 'string', 'Value': 'string' }, ], 'KmsKeyId': 'string', 'EnhancedVpcRouting': True|False, 'IamRoles': [ { 'IamRoleArn': 'string', 'ApplyStatus': 'string' }, ] } } :returns: available creating deleting final-snapshot hardware-failure incompatible-hsm incompatible-network incompatible-parameters incompatible-restore modifying rebooting renaming resizing rotating-keys storage-full updating-hsm", "response": "def restore_from_cluster_snapshot(ClusterIdentifier=None, SnapshotIdentifier=None, SnapshotClusterIdentifier=None, Port=None, AvailabilityZone=None, AllowVersionUpgrade=None, ClusterSubnetGroupName=None, PubliclyAccessible=None, OwnerAccount=None, HsmClientCertificateIdentifier=None, HsmConfigurationIdentifier=None, ElasticIp=None, ClusterParameterGroupName=None, ClusterSecurityGroups=None, VpcSecurityGroupIds=None, PreferredMaintenanceWindow=None, AutomatedSnapshotRetentionPeriod=None, KmsKeyId=None, NodeType=None, EnhancedVpcRouting=None, AdditionalInfo=None, IamRoles=None):\n    \"\"\"\n    Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the  ModifyCluster API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.\n    If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.\n    For more information about working with snapshots, go to Amazon Redshift Snapshots in the Amazon Redshift Cluster Management Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.restore_from_cluster_snapshot(\n        ClusterIdentifier='string',\n        SnapshotIdentifier='string',\n        SnapshotClusterIdentifier='string',\n        Port=123,\n        AvailabilityZone='string',\n        AllowVersionUpgrade=True|False,\n        ClusterSubnetGroupName='string',\n        PubliclyAccessible=True|False,\n        OwnerAccount='string',\n        HsmClientCertificateIdentifier='string',\n        HsmConfigurationIdentifier='string',\n        ElasticIp='string',\n        ClusterParameterGroupName='string',\n        ClusterSecurityGroups=[\n            'string',\n        ],\n        VpcSecurityGroupIds=[\n            'string',\n        ],\n        PreferredMaintenanceWindow='string',\n        AutomatedSnapshotRetentionPeriod=123,\n        KmsKeyId='string',\n        NodeType='string',\n        EnhancedVpcRouting=True|False,\n        AdditionalInfo='string',\n        IamRoles=[\n            'string',\n        ]\n    )\n    \n    \n    :type ClusterIdentifier: string\n    :param ClusterIdentifier: [REQUIRED]\n            The identifier of the cluster that will be created from restoring the snapshot.\n            Constraints:\n            Must contain from 1 to 63 alphanumeric characters or hyphens.\n            Alphabetic characters must be lowercase.\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            Must be unique for all clusters within an AWS account.\n            \n\n    :type SnapshotIdentifier: string\n    :param SnapshotIdentifier: [REQUIRED]\n            The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.\n            Example: my-snapshot-id\n            \n\n    :type SnapshotClusterIdentifier: string\n    :param SnapshotClusterIdentifier: The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.\n\n    :type Port: integer\n    :param Port: The port number on which the cluster accepts connections.\n            Default: The same port as the original cluster.\n            Constraints: Must be between 1115 and 65535 .\n            \n\n    :type AvailabilityZone: string\n    :param AvailabilityZone: The Amazon EC2 Availability Zone in which to restore the cluster.\n            Default: A random, system-chosen Availability Zone.\n            Example: us-east-1a\n            \n\n    :type AllowVersionUpgrade: boolean\n    :param AllowVersionUpgrade: If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.\n            Default: true\n            \n\n    :type ClusterSubnetGroupName: string\n    :param ClusterSubnetGroupName: The name of the subnet group where you want to cluster restored.\n            A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.\n            \n\n    :type PubliclyAccessible: boolean\n    :param PubliclyAccessible: If true , the cluster can be accessed from a public network.\n\n    :type OwnerAccount: string\n    :param OwnerAccount: The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.\n\n    :type HsmClientCertificateIdentifier: string\n    :param HsmClientCertificateIdentifier: Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.\n\n    :type HsmConfigurationIdentifier: string\n    :param HsmConfigurationIdentifier: Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.\n\n    :type ElasticIp: string\n    :param ElasticIp: The elastic IP (EIP) address for the cluster.\n\n    :type ClusterParameterGroupName: string\n    :param ClusterParameterGroupName: The name of the parameter group to be associated with this cluster.\n            Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to Working with Amazon Redshift Parameter Groups .\n            Constraints:\n            Must be 1 to 255 alphanumeric characters or hyphens.\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            \n\n    :type ClusterSecurityGroups: list\n    :param ClusterSecurityGroups: A list of security groups to be associated with this cluster.\n            Default: The default cluster security group for Amazon Redshift.\n            Cluster security groups only apply to clusters outside of VPCs.\n            (string) --\n            \n\n    :type VpcSecurityGroupIds: list\n    :param VpcSecurityGroupIds: A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.\n            Default: The default VPC security group is associated with the cluster.\n            VPC security groups only apply to clusters in VPCs.\n            (string) --\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: The weekly time range (in UTC) during which automated cluster maintenance can occur.\n            Format: ddd:hh24:mi-ddd:hh24:mi\n            Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see Maintenance Windows in Amazon Redshift Cluster Management Guide.\n            Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun\n            Constraints: Minimum 30-minute window.\n            \n\n    :type AutomatedSnapshotRetentionPeriod: integer\n    :param AutomatedSnapshotRetentionPeriod: The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with CreateClusterSnapshot .\n            Default: The value selected for the cluster from which the snapshot was taken.\n            Constraints: Must be a value from 0 to 35.\n            \n\n    :type KmsKeyId: string\n    :param KmsKeyId: The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.\n\n    :type NodeType: string\n    :param NodeType: The node type that the restored cluster will be provisioned with.\n            Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds2.xlarge into ds1.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type. For more information about node types, see About Clusters and Nodes in the Amazon Redshift Cluster Management Guide\n            \n\n    :type EnhancedVpcRouting: boolean\n    :param EnhancedVpcRouting: An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing in the Amazon Redshift Cluster Management Guide.\n            If this option is true , enhanced VPC routing is enabled.\n            Default: false\n            \n\n    :type AdditionalInfo: string\n    :param AdditionalInfo: Reserved.\n\n    :type IamRoles: list\n    :param IamRoles: A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.\n            A cluster can have up to 10 IAM roles associated at any time.\n            (string) --\n            \n\n    :rtype: dict\n    :return: {\n        'Cluster': {\n            'ClusterIdentifier': 'string',\n            'NodeType': 'string',\n            'ClusterStatus': 'string',\n            'ModifyStatus': 'string',\n            'MasterUsername': 'string',\n            'DBName': 'string',\n            'Endpoint': {\n                'Address': 'string',\n                'Port': 123\n            },\n            'ClusterCreateTime': datetime(2015, 1, 1),\n            'AutomatedSnapshotRetentionPeriod': 123,\n            'ClusterSecurityGroups': [\n                {\n                    'ClusterSecurityGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'ClusterParameterGroups': [\n                {\n                    'ParameterGroupName': 'string',\n                    'ParameterApplyStatus': 'string',\n                    'ClusterParameterStatusList': [\n                        {\n                            'ParameterName': 'string',\n                            'ParameterApplyStatus': 'string',\n                            'ParameterApplyErrorDescription': 'string'\n                        },\n                    ]\n                },\n            ],\n            'ClusterSubnetGroupName': 'string',\n            'VpcId': 'string',\n            'AvailabilityZone': 'string',\n            'PreferredMaintenanceWindow': 'string',\n            'PendingModifiedValues': {\n                'MasterUserPassword': 'string',\n                'NodeType': 'string',\n                'NumberOfNodes': 123,\n                'ClusterType': 'string',\n                'ClusterVersion': 'string',\n                'AutomatedSnapshotRetentionPeriod': 123,\n                'ClusterIdentifier': 'string',\n                'PubliclyAccessible': True|False,\n                'EnhancedVpcRouting': True|False\n            },\n            'ClusterVersion': 'string',\n            'AllowVersionUpgrade': True|False,\n            'NumberOfNodes': 123,\n            'PubliclyAccessible': True|False,\n            'Encrypted': True|False,\n            'RestoreStatus': {\n                'Status': 'string',\n                'CurrentRestoreRateInMegaBytesPerSecond': 123.0,\n                'SnapshotSizeInMegaBytes': 123,\n                'ProgressInMegaBytes': 123,\n                'ElapsedTimeInSeconds': 123,\n                'EstimatedTimeToCompletionInSeconds': 123\n            },\n            'HsmStatus': {\n                'HsmClientCertificateIdentifier': 'string',\n                'HsmConfigurationIdentifier': 'string',\n                'Status': 'string'\n            },\n            'ClusterSnapshotCopyStatus': {\n                'DestinationRegion': 'string',\n                'RetentionPeriod': 123,\n                'SnapshotCopyGrantName': 'string'\n            },\n            'ClusterPublicKey': 'string',\n            'ClusterNodes': [\n                {\n                    'NodeRole': 'string',\n                    'PrivateIPAddress': 'string',\n                    'PublicIPAddress': 'string'\n                },\n            ],\n            'ElasticIpStatus': {\n                'ElasticIp': 'string',\n                'Status': 'string'\n            },\n            'ClusterRevisionNumber': 'string',\n            'Tags': [\n                {\n                    'Key': 'string',\n                    'Value': 'string'\n                },\n            ],\n            'KmsKeyId': 'string',\n            'EnhancedVpcRouting': True|False,\n            'IamRoles': [\n                {\n                    'IamRoleArn': 'string',\n                    'ApplyStatus': 'string'\n                },\n            ]\n        }\n    }\n    \n    \n    :returns: \n    available\n    creating\n    deleting\n    final-snapshot\n    hardware-failure\n    incompatible-hsm\n    incompatible-network\n    incompatible-parameters\n    incompatible-restore\n    modifying\n    rebooting\n    renaming\n    resizing\n    rotating-keys\n    storage-full\n    updating-hsm\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an empty cluster.", "response": "def create_cluster(JobType=None, Resources=None, Description=None, AddressId=None, KmsKeyARN=None, RoleARN=None, SnowballType=None, ShippingOption=None, Notification=None, ForwardingAddressId=None):\n    \"\"\"\n    Creates an empty cluster. Each cluster supports five nodes. You use the  CreateJob action separately to create the jobs for each of these nodes. The cluster does not ship until these five node jobs have been created.\n    See also: AWS API Documentation\n    \n    Examples\n    Creates an empty cluster. Each cluster supports five nodes. You use the CreateJob action separately to create the jobs for each of these nodes. The cluster does not ship until these five node jobs have been created.\n    Expected Output:\n    \n    :example: response = client.create_cluster(\n        JobType='IMPORT'|'EXPORT'|'LOCAL_USE',\n        Resources={\n            'S3Resources': [\n                {\n                    'BucketArn': 'string',\n                    'KeyRange': {\n                        'BeginMarker': 'string',\n                        'EndMarker': 'string'\n                    }\n                },\n            ],\n            'LambdaResources': [\n                {\n                    'LambdaArn': 'string',\n                    'EventTriggers': [\n                        {\n                            'EventResourceARN': 'string'\n                        },\n                    ]\n                },\n            ]\n        },\n        Description='string',\n        AddressId='string',\n        KmsKeyARN='string',\n        RoleARN='string',\n        SnowballType='STANDARD'|'EDGE',\n        ShippingOption='SECOND_DAY'|'NEXT_DAY'|'EXPRESS'|'STANDARD',\n        Notification={\n            'SnsTopicARN': 'string',\n            'JobStatesToNotify': [\n                'New'|'PreparingAppliance'|'PreparingShipment'|'InTransitToCustomer'|'WithCustomer'|'InTransitToAWS'|'WithAWS'|'InProgress'|'Complete'|'Cancelled'|'Listing'|'Pending',\n            ],\n            'NotifyAll': True|False\n        },\n        ForwardingAddressId='string'\n    )\n    \n    \n    :type JobType: string\n    :param JobType: [REQUIRED]\n            The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE .\n            \n\n    :type Resources: dict\n    :param Resources: [REQUIRED]\n            The resources associated with the cluster job. These resources include Amazon S3 buckets and optional AWS Lambda functions written in the Python language.\n            S3Resources (list) --An array of S3Resource objects.\n            (dict) --Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into. For export jobs, this object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker , an inclusive EndMarker , or both. Ranges are UTF-8 binary sorted.\n            BucketArn (string) --The Amazon Resource Name (ARN) of an Amazon S3 bucket.\n            KeyRange (dict) --For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker , an inclusive EndMarker , or both. Ranges are UTF-8 binary sorted.\n            BeginMarker (string) --The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.\n            EndMarker (string) --The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.\n            \n            LambdaResources (list) --The Python-language Lambda functions for this job.\n            (dict) --Identifies\n            LambdaArn (string) --An Amazon Resource Name (ARN) that represents an AWS Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource.\n            EventTriggers (list) --The array of ARNs for S3Resource objects to trigger the LambdaResource objects associated with this job.\n            (dict) --The container for the EventTriggerDefinition$EventResourceARN .\n            EventResourceARN (string) --The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an AWS Lambda function's event trigger associated with this job.\n            \n            \n            \n\n    :type Description: string\n    :param Description: An optional description of this specific cluster, for example Environmental Data Cluster-01 .\n\n    :type AddressId: string\n    :param AddressId: [REQUIRED]\n            The ID for the address that you want the cluster shipped to.\n            \n\n    :type KmsKeyARN: string\n    :param KmsKeyARN: The KmsKeyARN value that you want to associate with this cluster. KmsKeyARN values are created by using the CreateKey API action in AWS Key Management Service (AWS KMS).\n\n    :type RoleARN: string\n    :param RoleARN: [REQUIRED]\n            The RoleARN that you want to associate with this cluster. RoleArn values are created by using the CreateRole API action in AWS Identity and Access Management (IAM).\n            \n\n    :type SnowballType: string\n    :param SnowballType: The type of AWS Snowball appliance to use for this cluster. Currently, the only supported appliance type for cluster jobs is EDGE .\n\n    :type ShippingOption: string\n    :param ShippingOption: [REQUIRED]\n            The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each Snowball Edge appliance, rather it represents how quickly each appliance moves to its destination while in transit. Regional shipping speeds are as follows:\n            In Australia, you have access to express shipping. Typically, appliances shipped express are delivered in about a day.\n            In the European Union (EU), you have access to express shipping. Typically, Snowball Edges shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.\n            In India, Snowball Edges are delivered in one to seven days.\n            In the US, you have access to one-day shipping and two-day shipping.\n            \n\n    :type Notification: dict\n    :param Notification: The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.\n            SnsTopicARN (string) --The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the CreateTopic Amazon SNS API action.\n            You can subscribe email addresses to an Amazon SNS topic through the AWS Management Console, or by using the Subscribe AWS Simple Notification Service (SNS) API action.\n            JobStatesToNotify (list) --The list of job states that will trigger a notification for this job.\n            (string) --\n            NotifyAll (boolean) --Any change in job state will trigger a notification for this job.\n            \n\n    :type ForwardingAddressId: string\n    :param ForwardingAddressId: The forwarding address ID for a cluster. This field is not supported in most regions.\n\n    :rtype: dict\n    :return: {\n        'ClusterId': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_job(JobType=None, Resources=None, Description=None, AddressId=None, KmsKeyARN=None, RoleARN=None, SnowballCapacityPreference=None, ShippingOption=None, Notification=None, ClusterId=None, SnowballType=None, ForwardingAddressId=None):\n    pass", "response": "This function creates a job for the given resource type and resources."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwhiling a job's JobState value is New , you can update some of the information associated with a job. Once the job changes to a different job state, usually within 60 minutes of the job being created, this action is no longer available. See also: AWS API Documentation Examples This action allows you to update certain parameters for a job. Once the job changes to a different job state, usually within 60 minutes of the job being created, this action is no longer available. Expected Output: :example: response = client.update_job( JobId='string', RoleARN='string', Notification={ 'SnsTopicARN': 'string', 'JobStatesToNotify': [ 'New'|'PreparingAppliance'|'PreparingShipment'|'InTransitToCustomer'|'WithCustomer'|'InTransitToAWS'|'WithAWS'|'InProgress'|'Complete'|'Cancelled'|'Listing'|'Pending', ], 'NotifyAll': True|False }, Resources={ 'S3Resources': [ { 'BucketArn': 'string', 'KeyRange': { 'BeginMarker': 'string', 'EndMarker': 'string' } }, ], 'LambdaResources': [ { 'LambdaArn': 'string', 'EventTriggers': [ { 'EventResourceARN': 'string' }, ] }, ] }, AddressId='string', ShippingOption='SECOND_DAY'|'NEXT_DAY'|'EXPRESS'|'STANDARD', Description='string', SnowballCapacityPreference='T50'|'T80'|'T100'|'NoPreference', ForwardingAddressId='string' ) :type JobId: string :param JobId: [REQUIRED] The job ID of the job that you want to update, for example JID123e4567-e89b-12d3-a456-426655440000 . :type RoleARN: string :param RoleARN: The new role Amazon Resource Name (ARN) that you want to associate with this job. To create a role ARN, use the CreateRole AWS Identity and Access Management (IAM) API action. :type Notification: dict :param Notification: The new or updated Notification object. SnsTopicARN (string) --The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the CreateTopic Amazon SNS API action. You can subscribe email addresses to an Amazon SNS topic through the AWS Management Console, or by using the Subscribe AWS Simple Notification Service (SNS) API action. JobStatesToNotify (list) --The list of job states that will trigger a notification for this job. (string) -- NotifyAll (boolean) --Any change in job state will trigger a notification for this job. :type Resources: dict :param Resources: The updated S3Resource object (for a single Amazon S3 bucket or key range), or the updated JobResource object (for multiple buckets or key ranges). S3Resources (list) --An array of S3Resource objects. (dict) --Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into. For export jobs, this object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker , an inclusive EndMarker , or both. Ranges are UTF-8 binary sorted. BucketArn (string) --The Amazon Resource Name (ARN) of an Amazon S3 bucket. KeyRange (dict) --For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker , an inclusive EndMarker , or both. Ranges are UTF-8 binary sorted. BeginMarker (string) --The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted. EndMarker (string) --The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted. LambdaResources (list) --The Python-language Lambda functions for this job. (dict) --Identifies LambdaArn (string) --An Amazon Resource Name (ARN) that represents an AWS Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource. EventTriggers (list) --The array of ARNs for S3Resource objects to trigger the LambdaResource objects associated with this job. (dict) --The container for the EventTriggerDefinition$EventResourceARN . EventResourceARN (string) --The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an AWS Lambda function's event trigger associated with this job. :type AddressId: string :param AddressId: The ID of the updated Address object. :type ShippingOption: string :param ShippingOption: The updated shipping option value of this job's ShippingDetails object. :type Description: string :param Description: The updated description of this job's JobMetadata object. :type SnowballCapacityPreference: string :param SnowballCapacityPreference: The updated SnowballCapacityPreference of this job's JobMetadata object. The 50 TB Snowballs are only available in the US regions. :type ForwardingAddressId: string :param ForwardingAddressId: The updated ID for the forwarding address for a job. This field is not supported in most regions. :rtype: dict :return: {} :returns: (dict) --", "response": "def update_job(JobId=None, RoleARN=None, Notification=None, Resources=None, AddressId=None, ShippingOption=None, Description=None, SnowballCapacityPreference=None, ForwardingAddressId=None):\n    \"\"\"\n    While a job's JobState value is New , you can update some of the information associated with a job. Once the job changes to a different job state, usually within 60 minutes of the job being created, this action is no longer available.\n    See also: AWS API Documentation\n    \n    Examples\n    This action allows you to update certain parameters for a job. Once the job changes to a different job state, usually within 60 minutes of the job being created, this action is no longer available.\n    Expected Output:\n    \n    :example: response = client.update_job(\n        JobId='string',\n        RoleARN='string',\n        Notification={\n            'SnsTopicARN': 'string',\n            'JobStatesToNotify': [\n                'New'|'PreparingAppliance'|'PreparingShipment'|'InTransitToCustomer'|'WithCustomer'|'InTransitToAWS'|'WithAWS'|'InProgress'|'Complete'|'Cancelled'|'Listing'|'Pending',\n            ],\n            'NotifyAll': True|False\n        },\n        Resources={\n            'S3Resources': [\n                {\n                    'BucketArn': 'string',\n                    'KeyRange': {\n                        'BeginMarker': 'string',\n                        'EndMarker': 'string'\n                    }\n                },\n            ],\n            'LambdaResources': [\n                {\n                    'LambdaArn': 'string',\n                    'EventTriggers': [\n                        {\n                            'EventResourceARN': 'string'\n                        },\n                    ]\n                },\n            ]\n        },\n        AddressId='string',\n        ShippingOption='SECOND_DAY'|'NEXT_DAY'|'EXPRESS'|'STANDARD',\n        Description='string',\n        SnowballCapacityPreference='T50'|'T80'|'T100'|'NoPreference',\n        ForwardingAddressId='string'\n    )\n    \n    \n    :type JobId: string\n    :param JobId: [REQUIRED]\n            The job ID of the job that you want to update, for example JID123e4567-e89b-12d3-a456-426655440000 .\n            \n\n    :type RoleARN: string\n    :param RoleARN: The new role Amazon Resource Name (ARN) that you want to associate with this job. To create a role ARN, use the CreateRole AWS Identity and Access Management (IAM) API action.\n\n    :type Notification: dict\n    :param Notification: The new or updated Notification object.\n            SnsTopicARN (string) --The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the CreateTopic Amazon SNS API action.\n            You can subscribe email addresses to an Amazon SNS topic through the AWS Management Console, or by using the Subscribe AWS Simple Notification Service (SNS) API action.\n            JobStatesToNotify (list) --The list of job states that will trigger a notification for this job.\n            (string) --\n            NotifyAll (boolean) --Any change in job state will trigger a notification for this job.\n            \n\n    :type Resources: dict\n    :param Resources: The updated S3Resource object (for a single Amazon S3 bucket or key range), or the updated JobResource object (for multiple buckets or key ranges).\n            S3Resources (list) --An array of S3Resource objects.\n            (dict) --Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into. For export jobs, this object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker , an inclusive EndMarker , or both. Ranges are UTF-8 binary sorted.\n            BucketArn (string) --The Amazon Resource Name (ARN) of an Amazon S3 bucket.\n            KeyRange (dict) --For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker , an inclusive EndMarker , or both. Ranges are UTF-8 binary sorted.\n            BeginMarker (string) --The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.\n            EndMarker (string) --The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.\n            \n            LambdaResources (list) --The Python-language Lambda functions for this job.\n            (dict) --Identifies\n            LambdaArn (string) --An Amazon Resource Name (ARN) that represents an AWS Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource.\n            EventTriggers (list) --The array of ARNs for S3Resource objects to trigger the LambdaResource objects associated with this job.\n            (dict) --The container for the EventTriggerDefinition$EventResourceARN .\n            EventResourceARN (string) --The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an AWS Lambda function's event trigger associated with this job.\n            \n            \n            \n\n    :type AddressId: string\n    :param AddressId: The ID of the updated Address object.\n\n    :type ShippingOption: string\n    :param ShippingOption: The updated shipping option value of this job's ShippingDetails object.\n\n    :type Description: string\n    :param Description: The updated description of this job's JobMetadata object.\n\n    :type SnowballCapacityPreference: string\n    :param SnowballCapacityPreference: The updated SnowballCapacityPreference of this job's JobMetadata object. The 50 TB Snowballs are only available in the US regions.\n\n    :type ForwardingAddressId: string\n    :param ForwardingAddressId: The updated ID for the forwarding address for a job. This field is not supported in most regions.\n\n    :rtype: dict\n    :return: {}\n    \n    \n    :returns: \n    (dict) --\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new task to a Maintenance Window.", "response": "def register_task_with_maintenance_window(WindowId=None, Targets=None, TaskArn=None, ServiceRoleArn=None, TaskType=None, TaskParameters=None, Priority=None, MaxConcurrency=None, MaxErrors=None, LoggingInfo=None, ClientToken=None):\n    \"\"\"\n    Adds a new task to a Maintenance Window.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.register_task_with_maintenance_window(\n        WindowId='string',\n        Targets=[\n            {\n                'Key': 'string',\n                'Values': [\n                    'string',\n                ]\n            },\n        ],\n        TaskArn='string',\n        ServiceRoleArn='string',\n        TaskType='RUN_COMMAND',\n        TaskParameters={\n            'string': {\n                'Values': [\n                    'string',\n                ]\n            }\n        },\n        Priority=123,\n        MaxConcurrency='string',\n        MaxErrors='string',\n        LoggingInfo={\n            'S3BucketName': 'string',\n            'S3KeyPrefix': 'string',\n            'S3Region': 'string'\n        },\n        ClientToken='string'\n    )\n    \n    \n    :type WindowId: string\n    :param WindowId: [REQUIRED]\n            The id of the Maintenance Window the task should be added to.\n            \n\n    :type Targets: list\n    :param Targets: [REQUIRED]\n            The targets (either instances or tags). Instances are specified using Key=instanceids,Values=instanceid1,instanceid2. Tags are specified using Key=tag name,Values=tag value.\n            (dict) --An array of search criteria that targets instances using a Key,Value combination that you specify. Targets is required if you don't provide one or more instance IDs in the call.\n            Key (string) --User-defined criteria for sending commands that target instances that meet the criteria. Key can be tag:Amazon EC2 tagor InstanceIds. For more information about how to send commands that target instances using Key,Value parameters, see Executing a Command Using Systems Manager Run Command .\n            Values (list) --User-defined criteria that maps to Key. For example, if you specified tag:ServerRole, you could specify value:WebServer to execute a command on instances that include Amazon EC2 tags of ServerRole,WebServer. For more information about how to send commands that target instances using Key,Value parameters, see Executing a Command Using Systems Manager Run Command .\n            (string) --\n            \n            \n\n    :type TaskArn: string\n    :param TaskArn: [REQUIRED]\n            The ARN of the task to execute\n            \n\n    :type ServiceRoleArn: string\n    :param ServiceRoleArn: [REQUIRED]\n            The role that should be assumed when executing the task.\n            \n\n    :type TaskType: string\n    :param TaskType: [REQUIRED]\n            The type of task being registered.\n            \n\n    :type TaskParameters: dict\n    :param TaskParameters: The parameters that should be passed to the task when it is executed.\n            (string) --\n            (dict) --Defines the values for a task parameter.\n            Values (list) --This field contains an array of 0 or more strings, each 1 to 255 characters in length.\n            (string) --\n            \n            \n\n    :type Priority: integer\n    :param Priority: The priority of the task in the Maintenance Window, the lower the number the higher the priority. Tasks in a Maintenance Window are scheduled in priority order with tasks that have the same priority scheduled in parallel.\n\n    :type MaxConcurrency: string\n    :param MaxConcurrency: [REQUIRED]\n            The maximum number of targets this task can be run for in parallel.\n            \n\n    :type MaxErrors: string\n    :param MaxErrors: [REQUIRED]\n            The maximum number of errors allowed before this task stops being scheduled.\n            \n\n    :type LoggingInfo: dict\n    :param LoggingInfo: A structure containing information about an Amazon S3 bucket to write instance-level logs to.\n            S3BucketName (string) -- [REQUIRED]The name of an Amazon S3 bucket where execution logs are stored .\n            S3KeyPrefix (string) --(Optional) The Amazon S3 bucket subfolder.\n            S3Region (string) -- [REQUIRED]The region where the Amazon S3 bucket is located.\n            \n\n    :type ClientToken: string\n    :param ClientToken: User-provided idempotency token.\n            This field is autopopulated if not provided.\n            \n\n    :rtype: dict\n    :return: {\n        'WindowTaskId': 'string'\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a command to one or more instances.", "response": "def send_command(InstanceIds=None, Targets=None, DocumentName=None, DocumentHash=None, DocumentHashType=None, TimeoutSeconds=None, Comment=None, Parameters=None, OutputS3Region=None, OutputS3BucketName=None, OutputS3KeyPrefix=None, MaxConcurrency=None, MaxErrors=None, ServiceRoleArn=None, NotificationConfig=None):\n    \"\"\"\n    Executes commands on one or more remote instances.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.send_command(\n        InstanceIds=[\n            'string',\n        ],\n        Targets=[\n            {\n                'Key': 'string',\n                'Values': [\n                    'string',\n                ]\n            },\n        ],\n        DocumentName='string',\n        DocumentHash='string',\n        DocumentHashType='Sha256'|'Sha1',\n        TimeoutSeconds=123,\n        Comment='string',\n        Parameters={\n            'string': [\n                'string',\n            ]\n        },\n        OutputS3Region='string',\n        OutputS3BucketName='string',\n        OutputS3KeyPrefix='string',\n        MaxConcurrency='string',\n        MaxErrors='string',\n        ServiceRoleArn='string',\n        NotificationConfig={\n            'NotificationArn': 'string',\n            'NotificationEvents': [\n                'All'|'InProgress'|'Success'|'TimedOut'|'Cancelled'|'Failed',\n            ],\n            'NotificationType': 'Command'|'Invocation'\n        }\n    )\n    \n    \n    :type InstanceIds: list\n    :param InstanceIds: The instance IDs where the command should execute. You can specify a maximum of 50 IDs. If you prefer not to list individual instance IDs, you can instead send commands to a fleet of instances using the Targets parameter, which accepts EC2 tags.\n            (string) --\n            \n\n    :type Targets: list\n    :param Targets: (Optional) An array of search criteria that targets instances using a Key,Value combination that you specify. Targets is required if you don't provide one or more instance IDs in the call. For more information about how to use Targets, see Executing a Command Using Systems Manager Run Command .\n            (dict) --An array of search criteria that targets instances using a Key,Value combination that you specify. Targets is required if you don't provide one or more instance IDs in the call.\n            Key (string) --User-defined criteria for sending commands that target instances that meet the criteria. Key can be tag:Amazon EC2 tagor InstanceIds. For more information about how to send commands that target instances using Key,Value parameters, see Executing a Command Using Systems Manager Run Command .\n            Values (list) --User-defined criteria that maps to Key. For example, if you specified tag:ServerRole, you could specify value:WebServer to execute a command on instances that include Amazon EC2 tags of ServerRole,WebServer. For more information about how to send commands that target instances using Key,Value parameters, see Executing a Command Using Systems Manager Run Command .\n            (string) --\n            \n            \n\n    :type DocumentName: string\n    :param DocumentName: [REQUIRED]\n            Required. The name of the Systems Manager document to execute. This can be a public document or a custom document.\n            \n\n    :type DocumentHash: string\n    :param DocumentHash: The Sha256 or Sha1 hash created by the system when the document was created.\n            Note\n            Sha1 hashes have been deprecated.\n            \n\n    :type DocumentHashType: string\n    :param DocumentHashType: Sha256 or Sha1.\n            Note\n            Sha1 hashes have been deprecated.\n            \n\n    :type TimeoutSeconds: integer\n    :param TimeoutSeconds: If this time is reached and the command has not already started executing, it will not execute.\n\n    :type Comment: string\n    :param Comment: User-specified information about the command, such as a brief description of what the command should do.\n\n    :type Parameters: dict\n    :param Parameters: The required and optional parameters specified in the document being executed.\n            (string) --\n            (list) --\n            (string) --\n            \n            \n\n    :type OutputS3Region: string\n    :param OutputS3Region: (Optional) The region where the Amazon Simple Storage Service (Amazon S3) output bucket is located. The default value is the region where Run Command is being called.\n\n    :type OutputS3BucketName: string\n    :param OutputS3BucketName: The name of the S3 bucket where command execution responses should be stored.\n\n    :type OutputS3KeyPrefix: string\n    :param OutputS3KeyPrefix: The directory structure within the S3 bucket where the responses should be stored.\n\n    :type MaxConcurrency: string\n    :param MaxConcurrency: (Optional) The maximum number of instances that are allowed to execute the command at the same time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see Executing a Command Using Systems Manager Run Command .\n\n    :type MaxErrors: string\n    :param MaxErrors: The maximum number of errors allowed without the command failing. When the command fails one more time beyond the value of MaxErrors, the systems stops sending the command to additional targets. You can specify a number like 10 or a percentage like 10%. The default value is 50. For more information about how to use MaxErrors, see Executing a Command Using Systems Manager Run Command .\n\n    :type ServiceRoleArn: string\n    :param ServiceRoleArn: The IAM role that Systems Manager uses to send notifications.\n\n    :type NotificationConfig: dict\n    :param NotificationConfig: Configurations for sending notifications.\n            NotificationArn (string) --An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.\n            NotificationEvents (list) --The different events for which you can receive notifications. These events include the following: All (events), InProgress, Success, TimedOut, Cancelled, Failed. To learn more about these events, see Setting Up Events and Notifications in the Amazon EC2 Systems Manager User Guide .\n            (string) --\n            NotificationType (string) --Command: Receive notification when the status of a command changes. Invocation: For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.\n            \n\n    :rtype: dict\n    :return: {\n        'Command': {\n            'CommandId': 'string',\n            'DocumentName': 'string',\n            'Comment': 'string',\n            'ExpiresAfter': datetime(2015, 1, 1),\n            'Parameters': {\n                'string': [\n                    'string',\n                ]\n            },\n            'InstanceIds': [\n                'string',\n            ],\n            'Targets': [\n                {\n                    'Key': 'string',\n                    'Values': [\n                        'string',\n                    ]\n                },\n            ],\n            'RequestedDateTime': datetime(2015, 1, 1),\n            'Status': 'Pending'|'InProgress'|'Success'|'Cancelled'|'Failed'|'TimedOut'|'Cancelling',\n            'StatusDetails': 'string',\n            'OutputS3Region': 'string',\n            'OutputS3BucketName': 'string',\n            'OutputS3KeyPrefix': 'string',\n            'MaxConcurrency': 'string',\n            'MaxErrors': 'string',\n            'TargetCount': 123,\n            'CompletedCount': 123,\n            'ErrorCount': 123,\n            'ServiceRole': 'string',\n            'NotificationConfig': {\n                'NotificationArn': 'string',\n                'NotificationEvents': [\n                    'All'|'InProgress'|'Success'|'TimedOut'|'Cancelled'|'Failed',\n                ],\n                'NotificationType': 'Command'|'Invocation'\n            }\n        }\n    }\n    \n    \n    :returns: \n    (string) --\n    (list) --\n    (string) --\n    \n    \n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_server(AssociatePublicIpAddress=None, DisableAutomatedBackup=None, Engine=None, EngineModel=None, EngineVersion=None, EngineAttributes=None, BackupRetentionCount=None, ServerName=None, InstanceProfileArn=None, InstanceType=None, KeyPair=None, PreferredMaintenanceWindow=None, PreferredBackupWindow=None, SecurityGroupIds=None, ServiceRoleArn=None, SubnetIds=None, BackupId=None):\n    pass", "response": "Creates and immedately starts a new server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_product(AcceptLanguage=None, Name=None, Owner=None, Description=None, Distributor=None, SupportDescription=None, SupportEmail=None, SupportUrl=None, ProductType=None, Tags=None, ProvisioningArtifactParameters=None, IdempotencyToken=None):\n    pass", "response": "Creates a new product."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef provision_product(AcceptLanguage=None, ProductId=None, ProvisioningArtifactId=None, PathId=None, ProvisionedProductName=None, ProvisioningParameters=None, Tags=None, NotificationArns=None, ProvisionToken=None):\n    pass", "response": "This function is used to provision a specified product."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates an existing product. See also: AWS API Documentation :example: response = client.update_product( AcceptLanguage='string', Id='string', Name='string', Owner='string', Description='string', Distributor='string', SupportDescription='string', SupportEmail='string', SupportUrl='string', AddTags=[ { 'Key': 'string', 'Value': 'string' }, ], RemoveTags=[ 'string', ] ) :type AcceptLanguage: string :param AcceptLanguage: The language code to use for this operation. Supported language codes are as follows: 'en' (English) 'jp' (Japanese) 'zh' (Chinese) If no code is specified, 'en' is used as the default. :type Id: string :param Id: [REQUIRED] The identifier of the product for the update request. :type Name: string :param Name: The updated product name. :type Owner: string :param Owner: The updated owner of the product. :type Description: string :param Description: The updated text description of the product. :type Distributor: string :param Distributor: The updated distributor of the product. :type SupportDescription: string :param SupportDescription: The updated support description for the product. :type SupportEmail: string :param SupportEmail: The updated support email for the product. :type SupportUrl: string :param SupportUrl: The updated support URL for the product. :type AddTags: list :param AddTags: Tags to add to the existing list of tags associated with the product. (dict) --Key/value pairs to associate with this provisioning. These tags are entirely discretionary and are propagated to the resources created in the provisioning. Key (string) -- [REQUIRED]The ProvisioningArtifactParameter.TagKey parameter from DescribeProvisioningParameters . Value (string) -- [REQUIRED]The esired value for this key. :type RemoveTags: list :param RemoveTags: Tags to remove from the existing list of tags associated with the product. (string) -- :rtype: dict :return: { 'ProductViewDetail': { 'ProductViewSummary': { 'Id': 'string', 'ProductId': 'string', 'Name': 'string', 'Owner': 'string', 'ShortDescription': 'string', 'Type': 'CLOUD_FORMATION_TEMPLATE', 'Distributor': 'string', 'HasDefaultPath': True|False, 'SupportEmail': 'string', 'SupportDescription': 'string', 'SupportUrl': 'string' }, 'Status': 'AVAILABLE'|'CREATING'|'FAILED', 'ProductARN': 'string', 'CreatedTime': datetime(2015, 1, 1) }, 'Tags': [ { 'Key': 'string', 'Value': 'string' }, ] }", "response": "def update_product(AcceptLanguage=None, Id=None, Name=None, Owner=None, Description=None, Distributor=None, SupportDescription=None, SupportEmail=None, SupportUrl=None, AddTags=None, RemoveTags=None):\n    \"\"\"\n    Updates an existing product.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_product(\n        AcceptLanguage='string',\n        Id='string',\n        Name='string',\n        Owner='string',\n        Description='string',\n        Distributor='string',\n        SupportDescription='string',\n        SupportEmail='string',\n        SupportUrl='string',\n        AddTags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        RemoveTags=[\n            'string',\n        ]\n    )\n    \n    \n    :type AcceptLanguage: string\n    :param AcceptLanguage: The language code to use for this operation. Supported language codes are as follows:\n            'en' (English)\n            'jp' (Japanese)\n            'zh' (Chinese)\n            If no code is specified, 'en' is used as the default.\n            \n\n    :type Id: string\n    :param Id: [REQUIRED]\n            The identifier of the product for the update request.\n            \n\n    :type Name: string\n    :param Name: The updated product name.\n\n    :type Owner: string\n    :param Owner: The updated owner of the product.\n\n    :type Description: string\n    :param Description: The updated text description of the product.\n\n    :type Distributor: string\n    :param Distributor: The updated distributor of the product.\n\n    :type SupportDescription: string\n    :param SupportDescription: The updated support description for the product.\n\n    :type SupportEmail: string\n    :param SupportEmail: The updated support email for the product.\n\n    :type SupportUrl: string\n    :param SupportUrl: The updated support URL for the product.\n\n    :type AddTags: list\n    :param AddTags: Tags to add to the existing list of tags associated with the product.\n            (dict) --Key/value pairs to associate with this provisioning. These tags are entirely discretionary and are propagated to the resources created in the provisioning.\n            Key (string) -- [REQUIRED]The ProvisioningArtifactParameter.TagKey parameter from DescribeProvisioningParameters .\n            Value (string) -- [REQUIRED]The esired value for this key.\n            \n            \n\n    :type RemoveTags: list\n    :param RemoveTags: Tags to remove from the existing list of tags associated with the product.\n            (string) --\n            \n\n    :rtype: dict\n    :return: {\n        'ProductViewDetail': {\n            'ProductViewSummary': {\n                'Id': 'string',\n                'ProductId': 'string',\n                'Name': 'string',\n                'Owner': 'string',\n                'ShortDescription': 'string',\n                'Type': 'CLOUD_FORMATION_TEMPLATE',\n                'Distributor': 'string',\n                'HasDefaultPath': True|False,\n                'SupportEmail': 'string',\n                'SupportDescription': 'string',\n                'SupportUrl': 'string'\n            },\n            'Status': 'AVAILABLE'|'CREATING'|'FAILED',\n            'ProductARN': 'string',\n            'CreatedTime': datetime(2015, 1, 1)\n        },\n        'Tags': [\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ]\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of closed workflow executions in the specified domain that meet the filtering criteria. The results may be split into multiple pages. To retrieve subsequent pages, make the call again using the nextPageToken returned by the initial call. Access Control You can use IAM policies to control this action's access to Amazon SWF resources as follows: If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's cause parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see Using IAM to Manage Access to Amazon SWF Workflows . See also: AWS API Documentation :example: response = client.list_closed_workflow_executions( domain='string', startTimeFilter={ 'oldestDate': datetime(2015, 1, 1), 'latestDate': datetime(2015, 1, 1) }, closeTimeFilter={ 'oldestDate': datetime(2015, 1, 1), 'latestDate': datetime(2015, 1, 1) }, executionFilter={ 'workflowId': 'string' }, closeStatusFilter={ 'status': 'COMPLETED'|'FAILED'|'CANCELED'|'TERMINATED'|'CONTINUED_AS_NEW'|'TIMED_OUT' }, typeFilter={ 'name': 'string', 'version': 'string' }, tagFilter={ 'tag': 'string' }, nextPageToken='string', maximumPageSize=123, reverseOrder=True|False ) :type domain: string :param domain: [REQUIRED] The name of the domain that contains the workflow executions to list. :type startTimeFilter: dict :param startTimeFilter: If specified, the workflow executions are included in the returned results based on whether their start times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their start times. Note startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both. oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return. latestDate (datetime) --Specifies the latest start or close date and time to return. :type closeTimeFilter: dict :param closeTimeFilter: If specified, the workflow executions are included in the returned results based on whether their close times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their close times. Note startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both. oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return. latestDate (datetime) --Specifies the latest start or close date and time to return. :type executionFilter: dict :param executionFilter: If specified, only workflow executions matching the workflow ID specified in the filter are returned. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. workflowId (string) -- [REQUIRED]The workflowId to pass of match the criteria of this filter. :type closeStatusFilter: dict :param closeStatusFilter: If specified, only workflow executions that match this close status are listed. For example, if TERMINATED is specified, then only TERMINATED workflow executions are listed. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. status (string) -- [REQUIRED]Required. The close status that must match the close status of an execution for it to meet the criteria of this filter. :type typeFilter: dict :param typeFilter: If specified, only executions of the type specified in the filter are returned. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. name (string) -- [REQUIRED]Required. Name of the workflow type. version (string) --Version of the workflow type. :type tagFilter: dict :param tagFilter: If specified, only executions that have the matching tag are listed. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. tag (string) -- [REQUIRED]Required. Specifies the tag that must be associated with the execution for it to meet the filter criteria. :type nextPageToken: string :param nextPageToken: If a NextPageToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextPageToken . Keep all other arguments unchanged. The configured maximumPageSize determines how many results can be returned in a single call. :type maximumPageSize: integer :param maximumPageSize: The maximum number of results that will be returned per call. nextPageToken can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size smaller than the maximum. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum. :type reverseOrder: boolean :param reverseOrder: When set to true , returns the results in reverse order. By default the results are returned in descending order of the start or the close time of the executions. :rtype: dict :return: { 'executionInfos': [ { 'execution': { 'workflowId': 'string', 'runId': 'string' }, 'workflowType': { 'name': 'string', 'version': 'string' }, 'startTimestamp': datetime(2015, 1, 1), 'closeTimestamp': datetime(2015, 1, 1), 'executionStatus': 'OPEN'|'CLOSED', 'closeStatus': 'COMPLETED'|'FAILED'|'CANCELED'|'TERMINATED'|'CONTINUED_AS_NEW'|'TIMED_OUT', 'parent': { 'workflowId': 'string', 'runId': 'string' }, 'tagList': [ 'string', ], 'cancelRequested': True|False }, ], 'nextPageToken': 'string' } :returns: domain (string) -- [REQUIRED] The name of the domain that contains the workflow executions to list. startTimeFilter (dict) -- If specified, the workflow executions are included in the returned results based on whether their start times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their start times. Note startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both. oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return. latestDate (datetime) --Specifies the latest start or close date and time to return. closeTimeFilter (dict) -- If specified, the workflow executions are included in the returned results based on whether their close times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their close times. Note startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both. oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return. latestDate (datetime) --Specifies the latest start or close date and time to return. executionFilter (dict) -- If specified, only workflow executions matching the workflow ID specified in the filter are returned. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. workflowId (string) -- [REQUIRED]The workflowId to pass of match the criteria of this filter. closeStatusFilter (dict) -- If specified, only workflow executions that match this close status are listed. For example, if TERMINATED is specified, then only TERMINATED workflow executions are listed. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. status (string) -- [REQUIRED]Required. The close status that must match the close status of an execution for it to meet the criteria of this filter. typeFilter (dict) -- If specified, only executions of the type specified in the filter are returned. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. name (string) -- [REQUIRED]Required. Name of the workflow type. version (string) --Version of the workflow type. tagFilter (dict) -- If specified, only executions that have the matching tag are listed. Note closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request. tag (string) -- [REQUIRED]Required. Specifies the tag that must be associated with the execution for it to meet the filter criteria. nextPageToken (string) -- If a NextPageToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextPageToken . Keep all other arguments unchanged. The configured maximumPageSize determines how many results can be returned in a single call. maximumPageSize (integer) -- The maximum number of results that will be returned per call. nextPageToken can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size smaller than the maximum. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum. reverseOrder (boolean) -- When set to true , returns the results in reverse order. By default the results are returned in descending order of the start or the close time of the executions.", "response": "def list_closed_workflow_executions(domain=None, startTimeFilter=None, closeTimeFilter=None, executionFilter=None, closeStatusFilter=None, typeFilter=None, tagFilter=None, nextPageToken=None, maximumPageSize=None, reverseOrder=None):\n    \"\"\"\n    Returns a list of closed workflow executions in the specified domain that meet the filtering criteria. The results may be split into multiple pages. To retrieve subsequent pages, make the call again using the nextPageToken returned by the initial call.\n    Access Control\n    You can use IAM policies to control this action's access to Amazon SWF resources as follows:\n    If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's cause parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see Using IAM to Manage Access to Amazon SWF Workflows .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.list_closed_workflow_executions(\n        domain='string',\n        startTimeFilter={\n            'oldestDate': datetime(2015, 1, 1),\n            'latestDate': datetime(2015, 1, 1)\n        },\n        closeTimeFilter={\n            'oldestDate': datetime(2015, 1, 1),\n            'latestDate': datetime(2015, 1, 1)\n        },\n        executionFilter={\n            'workflowId': 'string'\n        },\n        closeStatusFilter={\n            'status': 'COMPLETED'|'FAILED'|'CANCELED'|'TERMINATED'|'CONTINUED_AS_NEW'|'TIMED_OUT'\n        },\n        typeFilter={\n            'name': 'string',\n            'version': 'string'\n        },\n        tagFilter={\n            'tag': 'string'\n        },\n        nextPageToken='string',\n        maximumPageSize=123,\n        reverseOrder=True|False\n    )\n    \n    \n    :type domain: string\n    :param domain: [REQUIRED]\n            The name of the domain that contains the workflow executions to list.\n            \n\n    :type startTimeFilter: dict\n    :param startTimeFilter: If specified, the workflow executions are included in the returned results based on whether their start times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their start times.\n            Note\n            startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both.\n            oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return.\n            latestDate (datetime) --Specifies the latest start or close date and time to return.\n            \n\n    :type closeTimeFilter: dict\n    :param closeTimeFilter: If specified, the workflow executions are included in the returned results based on whether their close times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their close times.\n            Note\n            startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both.\n            oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return.\n            latestDate (datetime) --Specifies the latest start or close date and time to return.\n            \n\n    :type executionFilter: dict\n    :param executionFilter: If specified, only workflow executions matching the workflow ID specified in the filter are returned.\n            Note\n            closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n            workflowId (string) -- [REQUIRED]The workflowId to pass of match the criteria of this filter.\n            \n\n    :type closeStatusFilter: dict\n    :param closeStatusFilter: If specified, only workflow executions that match this close status are listed. For example, if TERMINATED is specified, then only TERMINATED workflow executions are listed.\n            Note\n            closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n            status (string) -- [REQUIRED]Required. The close status that must match the close status of an execution for it to meet the criteria of this filter.\n            \n\n    :type typeFilter: dict\n    :param typeFilter: If specified, only executions of the type specified in the filter are returned.\n            Note\n            closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n            name (string) -- [REQUIRED]Required. Name of the workflow type.\n            version (string) --Version of the workflow type.\n            \n\n    :type tagFilter: dict\n    :param tagFilter: If specified, only executions that have the matching tag are listed.\n            Note\n            closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n            tag (string) -- [REQUIRED]Required. Specifies the tag that must be associated with the execution for it to meet the filter criteria.\n            \n\n    :type nextPageToken: string\n    :param nextPageToken: If a NextPageToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextPageToken . Keep all other arguments unchanged.\n            The configured maximumPageSize determines how many results can be returned in a single call.\n            \n\n    :type maximumPageSize: integer\n    :param maximumPageSize: The maximum number of results that will be returned per call. nextPageToken can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size smaller than the maximum.\n            This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.\n            \n\n    :type reverseOrder: boolean\n    :param reverseOrder: When set to true , returns the results in reverse order. By default the results are returned in descending order of the start or the close time of the executions.\n\n    :rtype: dict\n    :return: {\n        'executionInfos': [\n            {\n                'execution': {\n                    'workflowId': 'string',\n                    'runId': 'string'\n                },\n                'workflowType': {\n                    'name': 'string',\n                    'version': 'string'\n                },\n                'startTimestamp': datetime(2015, 1, 1),\n                'closeTimestamp': datetime(2015, 1, 1),\n                'executionStatus': 'OPEN'|'CLOSED',\n                'closeStatus': 'COMPLETED'|'FAILED'|'CANCELED'|'TERMINATED'|'CONTINUED_AS_NEW'|'TIMED_OUT',\n                'parent': {\n                    'workflowId': 'string',\n                    'runId': 'string'\n                },\n                'tagList': [\n                    'string',\n                ],\n                'cancelRequested': True|False\n            },\n        ],\n        'nextPageToken': 'string'\n    }\n    \n    \n    :returns: \n    domain (string) -- [REQUIRED]\n    The name of the domain that contains the workflow executions to list.\n    \n    startTimeFilter (dict) -- If specified, the workflow executions are included in the returned results based on whether their start times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their start times.\n    \n    Note\n    startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both.\n    \n    \n    oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return.\n    \n    latestDate (datetime) --Specifies the latest start or close date and time to return.\n    \n    \n    \n    closeTimeFilter (dict) -- If specified, the workflow executions are included in the returned results based on whether their close times are within the range specified by this filter. Also, if this parameter is specified, the returned results are ordered by their close times.\n    \n    Note\n    startTimeFilter and closeTimeFilter are mutually exclusive. You must specify one of these in a request but not both.\n    \n    \n    oldestDate (datetime) -- [REQUIRED]Specifies the oldest start or close date and time to return.\n    \n    latestDate (datetime) --Specifies the latest start or close date and time to return.\n    \n    \n    \n    executionFilter (dict) -- If specified, only workflow executions matching the workflow ID specified in the filter are returned.\n    \n    Note\n    closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n    \n    \n    workflowId (string) -- [REQUIRED]The workflowId to pass of match the criteria of this filter.\n    \n    \n    \n    closeStatusFilter (dict) -- If specified, only workflow executions that match this close status are listed. For example, if TERMINATED is specified, then only TERMINATED workflow executions are listed.\n    \n    Note\n    closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n    \n    \n    status (string) -- [REQUIRED]Required. The close status that must match the close status of an execution for it to meet the criteria of this filter.\n    \n    \n    \n    typeFilter (dict) -- If specified, only executions of the type specified in the filter are returned.\n    \n    Note\n    closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n    \n    \n    name (string) -- [REQUIRED]Required. Name of the workflow type.\n    \n    version (string) --Version of the workflow type.\n    \n    \n    \n    tagFilter (dict) -- If specified, only executions that have the matching tag are listed.\n    \n    Note\n    closeStatusFilter , executionFilter , typeFilter and tagFilter are mutually exclusive. You can specify at most one of these in a request.\n    \n    \n    tag (string) -- [REQUIRED]Required. Specifies the tag that must be associated with the execution for it to meet the filter criteria.\n    \n    \n    \n    nextPageToken (string) -- If a NextPageToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextPageToken . Keep all other arguments unchanged.\n    The configured maximumPageSize determines how many results can be returned in a single call.\n    \n    maximumPageSize (integer) -- The maximum number of results that will be returned per call. nextPageToken can be used to obtain futher pages of results. The default is 1000, which is the maximum allowed page size. You can, however, specify a page size smaller than the maximum.\n    This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.\n    \n    reverseOrder (boolean) -- When set to true , returns the results in reverse order. By default the results are returned in descending order of the start or the close time of the executions.\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister a new activity type along with its configuration settings in the specified domain. Access Control You can use IAM policies to control this action's access to Amazon SWF resources as follows: If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's cause parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see Using IAM to Manage Access to Amazon SWF Workflows . See also: AWS API Documentation :example: response = client.register_activity_type( domain='string', name='string', version='string', description='string', defaultTaskStartToCloseTimeout='string', defaultTaskHeartbeatTimeout='string', defaultTaskList={ 'name': 'string' }, defaultTaskPriority='string', defaultTaskScheduleToStartTimeout='string', defaultTaskScheduleToCloseTimeout='string' ) :type domain: string :param domain: [REQUIRED] The name of the domain in which this activity is to be registered. :type name: string :param name: [REQUIRED] The name of the activity type within the domain. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. :type version: string :param version: [REQUIRED] The version of the activity type. Note The activity type consists of the name and version, the combination of which must be unique within the domain. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. :type description: string :param description: A textual description of the activity type. :type defaultTaskStartToCloseTimeout: string :param defaultTaskStartToCloseTimeout: If set, specifies the default maximum duration that a worker can take to process tasks of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration. :type defaultTaskHeartbeatTimeout: string :param defaultTaskHeartbeatTimeout: If set, specifies the default maximum time before which a worker processing a task of this type must report progress by calling RecordActivityTaskHeartbeat . If the timeout is exceeded, the activity task is automatically timed out. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. If the activity worker subsequently attempts to record a heartbeat or returns a result, the activity worker receives an UnknownResource fault. In this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should clean up the activity task. The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration. :type defaultTaskList: dict :param defaultTaskList: If set, specifies the default task list to use for scheduling tasks of this activity type. This default task list is used if a task list is not provided when a task is scheduled through the ScheduleActivityTask decision. name (string) -- [REQUIRED]The name of the task list. :type defaultTaskPriority: string :param defaultTaskPriority: The default task priority to assign to the activity type. If not assigned, then '0' will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority. For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide . :type defaultTaskScheduleToStartTimeout: string :param defaultTaskScheduleToStartTimeout: If set, specifies the default maximum duration that a task of this activity type can wait before being assigned to a worker. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration. :type defaultTaskScheduleToCloseTimeout: string :param defaultTaskScheduleToCloseTimeout: If set, specifies the default maximum duration for a task of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration. :returns: domain (string) -- [REQUIRED] The name of the domain in which this activity is to be registered. name (string) -- [REQUIRED] The name of the activity type within the domain. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. version (string) -- [REQUIRED] The version of the activity type. Note The activity type consists of the name and version, the combination of which must be unique within the domain. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. description (string) -- A textual description of the activity type. defaultTaskStartToCloseTimeout (string) -- If set, specifies the default maximum duration that a worker can take to process tasks of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration. defaultTaskHeartbeatTimeout (string) -- If set, specifies the default maximum time before which a worker processing a task of this type must report progress by calling RecordActivityTaskHeartbeat . If the timeout is exceeded, the activity task is automatically timed out. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. If the activity worker subsequently attempts to record a heartbeat or returns a result, the activity worker receives an UnknownResource fault. In this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should clean up the activity task. The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration. defaultTaskList (dict) -- If set, specifies the default task list to use for scheduling tasks of this activity type. This default task list is used if a task list is not provided when a task is scheduled through the ScheduleActivityTask decision. name (string) -- [REQUIRED]The name of the task list. defaultTaskPriority (string) -- The default task priority to assign to the activity type. If not assigned, then \"0\" will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority. For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide . defaultTaskScheduleToStartTimeout (string) -- If set, specifies the default maximum duration that a task of this activity type can wait before being assigned to a worker. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration. defaultTaskScheduleToCloseTimeout (string) -- If set, specifies the default maximum duration for a task of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.", "response": "def register_activity_type(domain=None, name=None, version=None, description=None, defaultTaskStartToCloseTimeout=None, defaultTaskHeartbeatTimeout=None, defaultTaskList=None, defaultTaskPriority=None, defaultTaskScheduleToStartTimeout=None, defaultTaskScheduleToCloseTimeout=None):\n    \"\"\"\n    Registers a new activity type along with its configuration settings in the specified domain.\n    Access Control\n    You can use IAM policies to control this action's access to Amazon SWF resources as follows:\n    If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's cause parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see Using IAM to Manage Access to Amazon SWF Workflows .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.register_activity_type(\n        domain='string',\n        name='string',\n        version='string',\n        description='string',\n        defaultTaskStartToCloseTimeout='string',\n        defaultTaskHeartbeatTimeout='string',\n        defaultTaskList={\n            'name': 'string'\n        },\n        defaultTaskPriority='string',\n        defaultTaskScheduleToStartTimeout='string',\n        defaultTaskScheduleToCloseTimeout='string'\n    )\n    \n    \n    :type domain: string\n    :param domain: [REQUIRED]\n            The name of the domain in which this activity is to be registered.\n            \n\n    :type name: string\n    :param name: [REQUIRED]\n            The name of the activity type within the domain.\n            The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n            \n\n    :type version: string\n    :param version: [REQUIRED]\n            The version of the activity type.\n            Note\n            The activity type consists of the name and version, the combination of which must be unique within the domain.\n            The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n            \n\n    :type description: string\n    :param description: A textual description of the activity type.\n\n    :type defaultTaskStartToCloseTimeout: string\n    :param defaultTaskStartToCloseTimeout: If set, specifies the default maximum duration that a worker can take to process tasks of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision.\n            The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration.\n            \n\n    :type defaultTaskHeartbeatTimeout: string\n    :param defaultTaskHeartbeatTimeout: If set, specifies the default maximum time before which a worker processing a task of this type must report progress by calling RecordActivityTaskHeartbeat . If the timeout is exceeded, the activity task is automatically timed out. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. If the activity worker subsequently attempts to record a heartbeat or returns a result, the activity worker receives an UnknownResource fault. In this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should clean up the activity task.\n            The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration.\n            \n\n    :type defaultTaskList: dict\n    :param defaultTaskList: If set, specifies the default task list to use for scheduling tasks of this activity type. This default task list is used if a task list is not provided when a task is scheduled through the ScheduleActivityTask decision.\n            name (string) -- [REQUIRED]The name of the task list.\n            \n\n    :type defaultTaskPriority: string\n    :param defaultTaskPriority: The default task priority to assign to the activity type. If not assigned, then '0' will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority.\n            For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide .\n            \n\n    :type defaultTaskScheduleToStartTimeout: string\n    :param defaultTaskScheduleToStartTimeout: If set, specifies the default maximum duration that a task of this activity type can wait before being assigned to a worker. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision.\n            The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration.\n            \n\n    :type defaultTaskScheduleToCloseTimeout: string\n    :param defaultTaskScheduleToCloseTimeout: If set, specifies the default maximum duration for a task of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision.\n            The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration.\n            \n\n    :returns: \n    domain (string) -- [REQUIRED]\n    The name of the domain in which this activity is to be registered.\n    \n    name (string) -- [REQUIRED]\n    The name of the activity type within the domain.\n    The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n    \n    version (string) -- [REQUIRED]\n    The version of the activity type.\n    \n    Note\n    The activity type consists of the name and version, the combination of which must be unique within the domain.\n    \n    The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n    \n    description (string) -- A textual description of the activity type.\n    defaultTaskStartToCloseTimeout (string) -- If set, specifies the default maximum duration that a worker can take to process tasks of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision.\n    The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.\n    \n    defaultTaskHeartbeatTimeout (string) -- If set, specifies the default maximum time before which a worker processing a task of this type must report progress by calling  RecordActivityTaskHeartbeat . If the timeout is exceeded, the activity task is automatically timed out. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision. If the activity worker subsequently attempts to record a heartbeat or returns a result, the activity worker receives an UnknownResource fault. In this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should clean up the activity task.\n    The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.\n    \n    defaultTaskList (dict) -- If set, specifies the default task list to use for scheduling tasks of this activity type. This default task list is used if a task list is not provided when a task is scheduled through the ScheduleActivityTask decision.\n    \n    name (string) -- [REQUIRED]The name of the task list.\n    \n    \n    \n    defaultTaskPriority (string) -- The default task priority to assign to the activity type. If not assigned, then \"0\" will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority.\n    For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide .\n    \n    defaultTaskScheduleToStartTimeout (string) -- If set, specifies the default maximum duration that a task of this activity type can wait before being assigned to a worker. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision.\n    The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.\n    \n    defaultTaskScheduleToCloseTimeout (string) -- If set, specifies the default maximum duration for a task of this activity type. This default can be overridden when scheduling an activity task using the ScheduleActivityTask decision.\n    The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_workflow_type(domain=None, name=None, version=None, description=None, defaultTaskStartToCloseTimeout=None, defaultExecutionStartToCloseTimeout=None, defaultTaskList=None, defaultTaskPriority=None, defaultChildPolicy=None, defaultLambdaRole=None):\n    pass", "response": "This function registers a new workflow type with the SWF domain."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts an execution of the workflow type in the specified domain using the provided workflowId and input data. This action returns the newly started workflow execution. Access Control You can use IAM policies to control this action's access to Amazon SWF resources as follows: If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's cause parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see Using IAM to Manage Access to Amazon SWF Workflows . See also: AWS API Documentation :example: response = client.start_workflow_execution( domain='string', workflowId='string', workflowType={ 'name': 'string', 'version': 'string' }, taskList={ 'name': 'string' }, taskPriority='string', input='string', executionStartToCloseTimeout='string', tagList=[ 'string', ], taskStartToCloseTimeout='string', childPolicy='TERMINATE'|'REQUEST_CANCEL'|'ABANDON', lambdaRole='string' ) :type domain: string :param domain: [REQUIRED] The name of the domain in which the workflow execution is created. :type workflowId: string :param workflowId: [REQUIRED] The user defined identifier associated with the workflow execution. You can use this to associate a custom identifier with the workflow execution. You may specify the same identifier if a workflow execution is logically a restart of a previous execution. You cannot have two open workflow executions with the same workflowId at the same time. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. :type workflowType: dict :param workflowType: [REQUIRED] The type of the workflow to start. name (string) -- [REQUIRED]Required. The name of the workflow type. Note The combination of workflow type name and version must be unique with in a domain. version (string) -- [REQUIRED]Required. The version of the workflow type. Note The combination of workflow type name and version must be unique with in a domain. :type taskList: dict :param taskList: The task list to use for the decision tasks generated for this workflow execution. This overrides the defaultTaskList specified when registering the workflow type. Note A task list for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task list was specified at registration time then a fault will be returned. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. name (string) -- [REQUIRED]The name of the task list. :type taskPriority: string :param taskPriority: The task priority to use for this workflow execution. This will override any default priority that was assigned when the workflow type was registered. If not set, then the default task priority for the workflow type will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority. For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide . :type input: string :param input: The input for the workflow execution. This is a free form string which should be meaningful to the workflow you are starting. This input is made available to the new workflow execution in the WorkflowExecutionStarted history event. :type executionStartToCloseTimeout: string :param executionStartToCloseTimeout: The total duration for this workflow execution. This overrides the defaultExecutionStartToCloseTimeout specified when registering the workflow type. The duration is specified in seconds; an integer greater than or equal to 0. Exceeding this limit will cause the workflow execution to time out. Unlike some of the other timeout parameters in Amazon SWF, you cannot specify a value of 'NONE' for this timeout; there is a one-year max limit on the time that a workflow execution can run. Note An execution start-to-close timeout must be specified either through this parameter or as a default when the workflow type is registered. If neither this parameter nor a default execution start-to-close timeout is specified, a fault is returned. :type tagList: list :param tagList: The list of tags to associate with the workflow execution. You can specify a maximum of 5 tags. You can list workflow executions with a specific tag by calling ListOpenWorkflowExecutions or ListClosedWorkflowExecutions and specifying a TagFilter . (string) -- :type taskStartToCloseTimeout: string :param taskStartToCloseTimeout: Specifies the maximum duration of decision tasks for this workflow execution. This parameter overrides the defaultTaskStartToCloseTimout specified when registering the workflow type using RegisterWorkflowType . The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration. Note A task start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task start-to-close timeout was specified at registration time then a fault will be returned. :type childPolicy: string :param childPolicy: If set, specifies the policy to use for the child workflow executions of this workflow execution if it is terminated, by calling the TerminateWorkflowExecution action explicitly or due to an expired timeout. This policy overrides the default child policy specified when registering the workflow type using RegisterWorkflowType . The supported child policies are: TERMINATE: the child executions will be terminated. REQUEST_CANCEL: a request to cancel will be attempted for each child execution by recording a WorkflowExecutionCancelRequested event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event. ABANDON: no action will be taken. The child executions will continue to run. Note A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned. :type lambdaRole: string :param lambdaRole: The ARN of an IAM role that authorizes Amazon SWF to invoke AWS Lambda functions. Note In order for this workflow execution to invoke AWS Lambda functions, an appropriate IAM role must be specified either as a default for the workflow type or through this field. :rtype: dict :return: { 'runId': 'string' } :returns: domain (string) -- [REQUIRED] The name of the domain in which the workflow execution is created. workflowId (string) -- [REQUIRED] The user defined identifier associated with the workflow execution. You can use this to associate a custom identifier with the workflow execution. You may specify the same identifier if a workflow execution is logically a restart of a previous execution. You cannot have two open workflow executions with the same workflowId at the same time. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. workflowType (dict) -- [REQUIRED] The type of the workflow to start. name (string) -- [REQUIRED]Required. The name of the workflow type. Note The combination of workflow type name and version must be unique with in a domain. version (string) -- [REQUIRED]Required. The version of the workflow type. Note The combination of workflow type name and version must be unique with in a domain. taskList (dict) -- The task list to use for the decision tasks generated for this workflow execution. This overrides the defaultTaskList specified when registering the workflow type. Note A task list for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task list was specified at registration time then a fault will be returned. The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot. name (string) -- [REQUIRED]The name of the task list. taskPriority (string) -- The task priority to use for this workflow execution. This will override any default priority that was assigned when the workflow type was registered. If not set, then the default task priority for the workflow type will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority. For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide . input (string) -- The input for the workflow execution. This is a free form string which should be meaningful to the workflow you are starting. This input is made available to the new workflow execution in the WorkflowExecutionStarted history event. executionStartToCloseTimeout (string) -- The total duration for this workflow execution. This overrides the defaultExecutionStartToCloseTimeout specified when registering the workflow type. The duration is specified in seconds; an integer greater than or equal to 0. Exceeding this limit will cause the workflow execution to time out. Unlike some of the other timeout parameters in Amazon SWF, you cannot specify a value of \"NONE\" for this timeout; there is a one-year max limit on the time that a workflow execution can run. Note An execution start-to-close timeout must be specified either through this parameter or as a default when the workflow type is registered. If neither this parameter nor a default execution start-to-close timeout is specified, a fault is returned. tagList (list) -- The list of tags to associate with the workflow execution. You can specify a maximum of 5 tags. You can list workflow executions with a specific tag by calling ListOpenWorkflowExecutions or ListClosedWorkflowExecutions and specifying a TagFilter . (string) -- taskStartToCloseTimeout (string) -- Specifies the maximum duration of decision tasks for this workflow execution. This parameter overrides the defaultTaskStartToCloseTimout specified when registering the workflow type using RegisterWorkflowType . The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration. Note A task start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task start-to-close timeout was specified at registration time then a fault will be returned. childPolicy (string) -- If set, specifies the policy to use for the child workflow executions of this workflow execution if it is terminated, by calling the TerminateWorkflowExecution action explicitly or due to an expired timeout. This policy overrides the default child policy specified when registering the workflow type using RegisterWorkflowType . The supported child policies are: TERMINATE: the child executions will be terminated. REQUEST_CANCEL: a request to cancel will be attempted for each child execution by recording a WorkflowExecutionCancelRequested event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event. ABANDON: no action will be taken. The child executions will continue to run. Note A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned. lambdaRole (string) -- The ARN of an IAM role that authorizes Amazon SWF to invoke AWS Lambda functions. Note In order for this workflow execution to invoke AWS Lambda functions, an appropriate IAM role must be specified either as a default for the workflow type or through this field.", "response": "def start_workflow_execution(domain=None, workflowId=None, workflowType=None, taskList=None, taskPriority=None, input=None, executionStartToCloseTimeout=None, tagList=None, taskStartToCloseTimeout=None, childPolicy=None, lambdaRole=None):\n    \"\"\"\n    Starts an execution of the workflow type in the specified domain using the provided workflowId and input data.\n    This action returns the newly started workflow execution.\n    Access Control\n    You can use IAM policies to control this action's access to Amazon SWF resources as follows:\n    If the caller does not have sufficient permissions to invoke the action, or the parameter values fall outside the specified constraints, the action fails. The associated event attribute's cause parameter will be set to OPERATION_NOT_PERMITTED. For details and example IAM policies, see Using IAM to Manage Access to Amazon SWF Workflows .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.start_workflow_execution(\n        domain='string',\n        workflowId='string',\n        workflowType={\n            'name': 'string',\n            'version': 'string'\n        },\n        taskList={\n            'name': 'string'\n        },\n        taskPriority='string',\n        input='string',\n        executionStartToCloseTimeout='string',\n        tagList=[\n            'string',\n        ],\n        taskStartToCloseTimeout='string',\n        childPolicy='TERMINATE'|'REQUEST_CANCEL'|'ABANDON',\n        lambdaRole='string'\n    )\n    \n    \n    :type domain: string\n    :param domain: [REQUIRED]\n            The name of the domain in which the workflow execution is created.\n            \n\n    :type workflowId: string\n    :param workflowId: [REQUIRED]\n            The user defined identifier associated with the workflow execution. You can use this to associate a custom identifier with the workflow execution. You may specify the same identifier if a workflow execution is logically a restart of a previous execution. You cannot have two open workflow executions with the same workflowId at the same time.\n            The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n            \n\n    :type workflowType: dict\n    :param workflowType: [REQUIRED]\n            The type of the workflow to start.\n            name (string) -- [REQUIRED]Required. The name of the workflow type.\n            Note\n            The combination of workflow type name and version must be unique with in a domain.\n            version (string) -- [REQUIRED]Required. The version of the workflow type.\n            Note\n            The combination of workflow type name and version must be unique with in a domain.\n            \n\n    :type taskList: dict\n    :param taskList: The task list to use for the decision tasks generated for this workflow execution. This overrides the defaultTaskList specified when registering the workflow type.\n            Note\n            A task list for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task list was specified at registration time then a fault will be returned.\n            The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n            name (string) -- [REQUIRED]The name of the task list.\n            \n\n    :type taskPriority: string\n    :param taskPriority: The task priority to use for this workflow execution. This will override any default priority that was assigned when the workflow type was registered. If not set, then the default task priority for the workflow type will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority.\n            For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide .\n            \n\n    :type input: string\n    :param input: The input for the workflow execution. This is a free form string which should be meaningful to the workflow you are starting. This input is made available to the new workflow execution in the WorkflowExecutionStarted history event.\n\n    :type executionStartToCloseTimeout: string\n    :param executionStartToCloseTimeout: The total duration for this workflow execution. This overrides the defaultExecutionStartToCloseTimeout specified when registering the workflow type.\n            The duration is specified in seconds; an integer greater than or equal to 0. Exceeding this limit will cause the workflow execution to time out. Unlike some of the other timeout parameters in Amazon SWF, you cannot specify a value of 'NONE' for this timeout; there is a one-year max limit on the time that a workflow execution can run.\n            Note\n            An execution start-to-close timeout must be specified either through this parameter or as a default when the workflow type is registered. If neither this parameter nor a default execution start-to-close timeout is specified, a fault is returned.\n            \n\n    :type tagList: list\n    :param tagList: The list of tags to associate with the workflow execution. You can specify a maximum of 5 tags. You can list workflow executions with a specific tag by calling ListOpenWorkflowExecutions or ListClosedWorkflowExecutions and specifying a TagFilter .\n            (string) --\n            \n\n    :type taskStartToCloseTimeout: string\n    :param taskStartToCloseTimeout: Specifies the maximum duration of decision tasks for this workflow execution. This parameter overrides the defaultTaskStartToCloseTimout specified when registering the workflow type using RegisterWorkflowType .\n            The duration is specified in seconds; an integer greater than or equal to 0. The value 'NONE' can be used to specify unlimited duration.\n            Note\n            A task start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task start-to-close timeout was specified at registration time then a fault will be returned.\n            \n\n    :type childPolicy: string\n    :param childPolicy: If set, specifies the policy to use for the child workflow executions of this workflow execution if it is terminated, by calling the TerminateWorkflowExecution action explicitly or due to an expired timeout. This policy overrides the default child policy specified when registering the workflow type using RegisterWorkflowType .\n            The supported child policies are:\n            TERMINATE: the child executions will be terminated.\n            REQUEST_CANCEL: a request to cancel will be attempted for each child execution by recording a WorkflowExecutionCancelRequested event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.\n            ABANDON: no action will be taken. The child executions will continue to run.\n            Note\n            A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned.\n            \n\n    :type lambdaRole: string\n    :param lambdaRole: The ARN of an IAM role that authorizes Amazon SWF to invoke AWS Lambda functions.\n            Note\n            In order for this workflow execution to invoke AWS Lambda functions, an appropriate IAM role must be specified either as a default for the workflow type or through this field.\n            \n\n    :rtype: dict\n    :return: {\n        'runId': 'string'\n    }\n    \n    \n    :returns: \n    domain (string) -- [REQUIRED]\n    The name of the domain in which the workflow execution is created.\n    \n    workflowId (string) -- [REQUIRED]\n    The user defined identifier associated with the workflow execution. You can use this to associate a custom identifier with the workflow execution. You may specify the same identifier if a workflow execution is logically a restart of a previous execution. You cannot have two open workflow executions with the same workflowId at the same time.\n    The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n    \n    workflowType (dict) -- [REQUIRED]\n    The type of the workflow to start.\n    \n    name (string) -- [REQUIRED]Required. The name of the workflow type.\n    \n    Note\n    The combination of workflow type name and version must be unique with in a domain.\n    \n    \n    version (string) -- [REQUIRED]Required. The version of the workflow type.\n    \n    Note\n    The combination of workflow type name and version must be unique with in a domain.\n    \n    \n    \n    \n    taskList (dict) -- The task list to use for the decision tasks generated for this workflow execution. This overrides the defaultTaskList specified when registering the workflow type.\n    \n    Note\n    A task list for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task list was specified at registration time then a fault will be returned.\n    \n    The specified string must not start or end with whitespace. It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (u0000-u001f | u007f - u009f). Also, it must not contain the literal string quotarnquot.\n    \n    name (string) -- [REQUIRED]The name of the task list.\n    \n    \n    \n    taskPriority (string) -- The task priority to use for this workflow execution. This will override any default priority that was assigned when the workflow type was registered. If not set, then the default task priority for the workflow type will be used. Valid values are integers that range from Java's Integer.MIN_VALUE (-2147483648) to Integer.MAX_VALUE (2147483647). Higher numbers indicate higher priority.\n    For more information about setting task priority, see Setting Task Priority in the Amazon Simple Workflow Developer Guide .\n    \n    input (string) -- The input for the workflow execution. This is a free form string which should be meaningful to the workflow you are starting. This input is made available to the new workflow execution in the WorkflowExecutionStarted history event.\n    executionStartToCloseTimeout (string) -- The total duration for this workflow execution. This overrides the defaultExecutionStartToCloseTimeout specified when registering the workflow type.\n    The duration is specified in seconds; an integer greater than or equal to 0. Exceeding this limit will cause the workflow execution to time out. Unlike some of the other timeout parameters in Amazon SWF, you cannot specify a value of \"NONE\" for this timeout; there is a one-year max limit on the time that a workflow execution can run.\n    \n    Note\n    An execution start-to-close timeout must be specified either through this parameter or as a default when the workflow type is registered. If neither this parameter nor a default execution start-to-close timeout is specified, a fault is returned.\n    \n    \n    tagList (list) -- The list of tags to associate with the workflow execution. You can specify a maximum of 5 tags. You can list workflow executions with a specific tag by calling  ListOpenWorkflowExecutions or  ListClosedWorkflowExecutions and specifying a  TagFilter .\n    \n    (string) --\n    \n    \n    taskStartToCloseTimeout (string) -- Specifies the maximum duration of decision tasks for this workflow execution. This parameter overrides the defaultTaskStartToCloseTimout specified when registering the workflow type using  RegisterWorkflowType .\n    The duration is specified in seconds; an integer greater than or equal to 0. The value \"NONE\" can be used to specify unlimited duration.\n    \n    Note\n    A task start-to-close timeout for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default task start-to-close timeout was specified at registration time then a fault will be returned.\n    \n    \n    childPolicy (string) -- If set, specifies the policy to use for the child workflow executions of this workflow execution if it is terminated, by calling the  TerminateWorkflowExecution action explicitly or due to an expired timeout. This policy overrides the default child policy specified when registering the workflow type using  RegisterWorkflowType .\n    The supported child policies are:\n    \n    TERMINATE: the child executions will be terminated.\n    REQUEST_CANCEL: a request to cancel will be attempted for each child execution by recording a WorkflowExecutionCancelRequested event in its history. It is up to the decider to take appropriate actions when it receives an execution history with this event.\n    ABANDON: no action will be taken. The child executions will continue to run.\n    \n    \n    Note\n    A child policy for this workflow execution must be specified either as a default for the workflow type or through this parameter. If neither this parameter is set nor a default child policy was specified at registration time then a fault will be returned.\n    \n    \n    lambdaRole (string) -- The ARN of an IAM role that authorizes Amazon SWF to invoke AWS Lambda functions.\n    \n    Note\n    In order for this workflow execution to invoke AWS Lambda functions, an appropriate IAM role must be specified either as a default for the workflow type or through this field.\n    \n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new Amazon Aurora DB cluster. You can use the ReplicationSourceIdentifier parameter to create the DB cluster as a Read Replica of another DB cluster or Amazon RDS MySQL DB instance. For cross-region replication where the DB cluster identified by ReplicationSourceIdentifier is encrypted, you must also specify the PreSignedUrl parameter. For more information on Amazon Aurora, see Aurora on Amazon RDS in the Amazon RDS User Guide. See also: AWS API Documentation Examples This example creates a DB cluster. Expected Output: :example: response = client.create_db_cluster( AvailabilityZones=[ 'string', ], BackupRetentionPeriod=123, CharacterSetName='string', DatabaseName='string', DBClusterIdentifier='string', DBClusterParameterGroupName='string', VpcSecurityGroupIds=[ 'string', ], DBSubnetGroupName='string', Engine='string', EngineVersion='string', Port=123, MasterUsername='string', MasterUserPassword='string', OptionGroupName='string', PreferredBackupWindow='string', PreferredMaintenanceWindow='string', ReplicationSourceIdentifier='string', Tags=[ { 'Key': 'string', 'Value': 'string' }, ], StorageEncrypted=True|False, KmsKeyId='string', EnableIAMDatabaseAuthentication=True|False, SourceRegion='string' ) :type AvailabilityZones: list :param AvailabilityZones: A list of EC2 Availability Zones that instances in the DB cluster can be created in. For information on regions and Availability Zones, see Regions and Availability Zones . (string) -- :type BackupRetentionPeriod: integer :param BackupRetentionPeriod: The number of days for which automated backups are retained. You must specify a minimum value of 1. Default: 1 Constraints: Must be a value from 1 to 35 :type CharacterSetName: string :param CharacterSetName: A value that indicates that the DB cluster should be associated with the specified CharacterSet. :type DatabaseName: string :param DatabaseName: The name for your database of up to 64 alpha-numeric characters. If you do not provide a name, Amazon RDS will not create a database in the DB cluster you are creating. :type DBClusterIdentifier: string :param DBClusterIdentifier: [REQUIRED] The DB cluster identifier. This parameter is stored as a lowercase string. Constraints: Must contain from 1 to 63 alphanumeric characters or hyphens. First character must be a letter. Cannot end with a hyphen or contain two consecutive hyphens. Example: my-cluster1 :type DBClusterParameterGroupName: string :param DBClusterParameterGroupName: The name of the DB cluster parameter group to associate with this DB cluster. If this argument is omitted, default.aurora5.6 will be used. Constraints: Must be 1 to 255 alphanumeric characters First character must be a letter Cannot end with a hyphen or contain two consecutive hyphens :type VpcSecurityGroupIds: list :param VpcSecurityGroupIds: A list of EC2 VPC security groups to associate with this DB cluster. (string) -- :type DBSubnetGroupName: string :param DBSubnetGroupName: A DB subnet group to associate with this DB cluster. Constraints: Must contain no more than 255 alphanumeric characters, periods, underscores, spaces, or hyphens. Must not be default. Example: mySubnetgroup :type Engine: string :param Engine: [REQUIRED] The name of the database engine to be used for this DB cluster. Valid Values: aurora :type EngineVersion: string :param EngineVersion: The version number of the database engine to use. Aurora Example: 5.6.10a :type Port: integer :param Port: The port number on which the instances in the DB cluster accept connections. Default: 3306 :type MasterUsername: string :param MasterUsername: The name of the master user for the DB cluster. Constraints: Must be 1 to 16 alphanumeric characters. First character must be a letter. Cannot be a reserved word for the chosen database engine. :type MasterUserPassword: string :param MasterUserPassword: The password for the master database user. This password can contain any printable ASCII character except '/', ''', or '@'. Constraints: Must contain from 8 to 41 characters. :type OptionGroupName: string :param OptionGroupName: A value that indicates that the DB cluster should be associated with the specified option group. Permanent options cannot be removed from an option group. The option group cannot be removed from a DB cluster once it is associated with a DB cluster. :type PreferredBackupWindow: string :param PreferredBackupWindow: The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. Default: A 30-minute window selected at random from an 8-hour block of time per region. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide. Constraints: Must be in the format hh24:mi-hh24:mi . Times should be in Universal Coordinated Time (UTC). Must not conflict with the preferred maintenance window. Must be at least 30 minutes. :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window. :type ReplicationSourceIdentifier: string :param ReplicationSourceIdentifier: The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a Read Replica. :type Tags: list :param Tags: A list of tags. (dict) --Metadata assigned to an Amazon RDS resource consisting of a key-value pair. Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). :type StorageEncrypted: boolean :param StorageEncrypted: Specifies whether the DB cluster is encrypted. :type KmsKeyId: string :param KmsKeyId: The KMS key identifier for an encrypted DB cluster. The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a DB cluster with the same AWS account that owns the KMS encryption key used to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the KMS encryption key. If the StorageEncrypted parameter is true, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. If you create a Read Replica of an encrypted DB cluster in another region, you must set KmsKeyId to a KMS key ID that is valid in the destination region. This key is used to encrypt the Read Replica in that region. :type PreSignedUrl: string :param PreSignedUrl: A URL that contains a Signature Version 4 signed request for the CreateDBCluster action to be called in the source region where the DB cluster will be replicated from. You only need to specify PreSignedUrl when you are performing cross-region replication from an encrypted DB cluster. The pre-signed URL must be a valid request for the CreateDBCluster API action that can be executed in the source region that contains the encrypted DB cluster to be copied. The pre-signed URL request must contain the following parameter values: KmsKeyId - The KMS key identifier for the key to use to encrypt the copy of the DB cluster in the destination region. This should refer to the same KMS key for both the CreateDBCluster action that is called in the destination region, and the action contained in the pre-signed URL. DestinationRegion - The name of the region that Aurora Read Replica will be created in. ReplicationSourceIdentifier - The DB cluster identifier for the encrypted DB cluster to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source region. For example, if you are copying an encrypted DB cluster from the us-west-2 region, then your ReplicationSourceIdentifier would look like Example: arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1 . To learn how to generate a Signature Version 4 signed request, see Authenticating Requests: Using Query Parameters (AWS Signature Version 4) and Signature Version 4 Signing Process . Please note that this parameter is automatically populated if it is not provided. Including this parameter is not required :type EnableIAMDatabaseAuthentication: boolean :param EnableIAMDatabaseAuthentication: A Boolean value that is true to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts, and otherwise false. Default: false :type SourceRegion: string :param SourceRegion: The ID of the region that contains the source for the db cluster. :rtype: dict :return: { 'DBCluster': { 'AllocatedStorage': 123, 'AvailabilityZones': [ 'string', ], 'BackupRetentionPeriod': 123, 'CharacterSetName': 'string', 'DatabaseName': 'string', 'DBClusterIdentifier': 'string', 'DBClusterParameterGroup': 'string', 'DBSubnetGroup': 'string', 'Status': 'string', 'PercentProgress': 'string', 'EarliestRestorableTime': datetime(2015, 1, 1), 'Endpoint': 'string', 'ReaderEndpoint': 'string', 'MultiAZ': True|False, 'Engine': 'string', 'EngineVersion': 'string', 'LatestRestorableTime': datetime(2015, 1, 1), 'Port': 123, 'MasterUsername': 'string', 'DBClusterOptionGroupMemberships': [ { 'DBClusterOptionGroupName': 'string', 'Status': 'string' }, ], 'PreferredBackupWindow': 'string', 'PreferredMaintenanceWindow': 'string', 'ReplicationSourceIdentifier': 'string', 'ReadReplicaIdentifiers': [ 'string', ], 'DBClusterMembers': [ { 'DBInstanceIdentifier': 'string', 'IsClusterWriter': True|False, 'DBClusterParameterGroupStatus': 'string', 'PromotionTier': 123 }, ], 'VpcSecurityGroups': [ { 'VpcSecurityGroupId': 'string', 'Status': 'string' }, ], 'HostedZoneId': 'string', 'StorageEncrypted': True|False, 'KmsKeyId': 'string', 'DbClusterResourceId': 'string', 'DBClusterArn': 'string', 'AssociatedRoles': [ { 'RoleArn': 'string', 'Status': 'string' }, ], 'IAMDatabaseAuthenticationEnabled': True|False, 'ClusterCreateTime': datetime(2015, 1, 1) } } :returns: CreateDBCluster DeleteDBCluster FailoverDBCluster ModifyDBCluster RestoreDBClusterFromSnapshot RestoreDBClusterToPointInTime", "response": "def create_db_cluster(AvailabilityZones=None, BackupRetentionPeriod=None, CharacterSetName=None, DatabaseName=None, DBClusterIdentifier=None, DBClusterParameterGroupName=None, VpcSecurityGroupIds=None, DBSubnetGroupName=None, Engine=None, EngineVersion=None, Port=None, MasterUsername=None, MasterUserPassword=None, OptionGroupName=None, PreferredBackupWindow=None, PreferredMaintenanceWindow=None, ReplicationSourceIdentifier=None, Tags=None, StorageEncrypted=None, KmsKeyId=None, PreSignedUrl=None, EnableIAMDatabaseAuthentication=None, SourceRegion=None):\n    \"\"\"\n    Creates a new Amazon Aurora DB cluster.\n    You can use the ReplicationSourceIdentifier parameter to create the DB cluster as a Read Replica of another DB cluster or Amazon RDS MySQL DB instance. For cross-region replication where the DB cluster identified by ReplicationSourceIdentifier is encrypted, you must also specify the PreSignedUrl parameter.\n    For more information on Amazon Aurora, see Aurora on Amazon RDS in the Amazon RDS User Guide.\n    See also: AWS API Documentation\n    \n    Examples\n    This example creates a DB cluster.\n    Expected Output:\n    \n    :example: response = client.create_db_cluster(\n        AvailabilityZones=[\n            'string',\n        ],\n        BackupRetentionPeriod=123,\n        CharacterSetName='string',\n        DatabaseName='string',\n        DBClusterIdentifier='string',\n        DBClusterParameterGroupName='string',\n        VpcSecurityGroupIds=[\n            'string',\n        ],\n        DBSubnetGroupName='string',\n        Engine='string',\n        EngineVersion='string',\n        Port=123,\n        MasterUsername='string',\n        MasterUserPassword='string',\n        OptionGroupName='string',\n        PreferredBackupWindow='string',\n        PreferredMaintenanceWindow='string',\n        ReplicationSourceIdentifier='string',\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        StorageEncrypted=True|False,\n        KmsKeyId='string',\n        EnableIAMDatabaseAuthentication=True|False,\n        SourceRegion='string'\n    )\n    \n    \n    :type AvailabilityZones: list\n    :param AvailabilityZones: A list of EC2 Availability Zones that instances in the DB cluster can be created in. For information on regions and Availability Zones, see Regions and Availability Zones .\n            (string) --\n            \n\n    :type BackupRetentionPeriod: integer\n    :param BackupRetentionPeriod: The number of days for which automated backups are retained. You must specify a minimum value of 1.\n            Default: 1\n            Constraints:\n            Must be a value from 1 to 35\n            \n\n    :type CharacterSetName: string\n    :param CharacterSetName: A value that indicates that the DB cluster should be associated with the specified CharacterSet.\n\n    :type DatabaseName: string\n    :param DatabaseName: The name for your database of up to 64 alpha-numeric characters. If you do not provide a name, Amazon RDS will not create a database in the DB cluster you are creating.\n\n    :type DBClusterIdentifier: string\n    :param DBClusterIdentifier: [REQUIRED]\n            The DB cluster identifier. This parameter is stored as a lowercase string.\n            Constraints:\n            Must contain from 1 to 63 alphanumeric characters or hyphens.\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            Example: my-cluster1\n            \n\n    :type DBClusterParameterGroupName: string\n    :param DBClusterParameterGroupName: The name of the DB cluster parameter group to associate with this DB cluster. If this argument is omitted, default.aurora5.6 will be used.\n            Constraints:\n            Must be 1 to 255 alphanumeric characters\n            First character must be a letter\n            Cannot end with a hyphen or contain two consecutive hyphens\n            \n\n    :type VpcSecurityGroupIds: list\n    :param VpcSecurityGroupIds: A list of EC2 VPC security groups to associate with this DB cluster.\n            (string) --\n            \n\n    :type DBSubnetGroupName: string\n    :param DBSubnetGroupName: A DB subnet group to associate with this DB cluster.\n            Constraints: Must contain no more than 255 alphanumeric characters, periods, underscores, spaces, or hyphens. Must not be default.\n            Example: mySubnetgroup\n            \n\n    :type Engine: string\n    :param Engine: [REQUIRED]\n            The name of the database engine to be used for this DB cluster.\n            Valid Values: aurora\n            \n\n    :type EngineVersion: string\n    :param EngineVersion: The version number of the database engine to use.\n            Aurora\n            Example: 5.6.10a\n            \n\n    :type Port: integer\n    :param Port: The port number on which the instances in the DB cluster accept connections.\n            Default: 3306\n            \n\n    :type MasterUsername: string\n    :param MasterUsername: The name of the master user for the DB cluster.\n            Constraints:\n            Must be 1 to 16 alphanumeric characters.\n            First character must be a letter.\n            Cannot be a reserved word for the chosen database engine.\n            \n\n    :type MasterUserPassword: string\n    :param MasterUserPassword: The password for the master database user. This password can contain any printable ASCII character except '/', ''', or '@'.\n            Constraints: Must contain from 8 to 41 characters.\n            \n\n    :type OptionGroupName: string\n    :param OptionGroupName: A value that indicates that the DB cluster should be associated with the specified option group.\n            Permanent options cannot be removed from an option group. The option group cannot be removed from a DB cluster once it is associated with a DB cluster.\n            \n\n    :type PreferredBackupWindow: string\n    :param PreferredBackupWindow: The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.\n            Default: A 30-minute window selected at random from an 8-hour block of time per region. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.\n            Constraints:\n            Must be in the format hh24:mi-hh24:mi .\n            Times should be in Universal Coordinated Time (UTC).\n            Must not conflict with the preferred maintenance window.\n            Must be at least 30 minutes.\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).\n            Format: ddd:hh24:mi-ddd:hh24:mi\n            Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.\n            Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun\n            Constraints: Minimum 30-minute window.\n            \n\n    :type ReplicationSourceIdentifier: string\n    :param ReplicationSourceIdentifier: The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a Read Replica.\n\n    :type Tags: list\n    :param Tags: A list of tags.\n            (dict) --Metadata assigned to an Amazon RDS resource consisting of a key-value pair.\n            Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            \n            \n\n    :type StorageEncrypted: boolean\n    :param StorageEncrypted: Specifies whether the DB cluster is encrypted.\n\n    :type KmsKeyId: string\n    :param KmsKeyId: The KMS key identifier for an encrypted DB cluster.\n            The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a DB cluster with the same AWS account that owns the KMS encryption key used to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the KMS encryption key.\n            If the StorageEncrypted parameter is true, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.\n            If you create a Read Replica of an encrypted DB cluster in another region, you must set KmsKeyId to a KMS key ID that is valid in the destination region. This key is used to encrypt the Read Replica in that region.\n            \n\n    :type PreSignedUrl: string\n    :param PreSignedUrl: A URL that contains a Signature Version 4 signed request for the CreateDBCluster action to be called in the source region where the DB cluster will be replicated from. You only need to specify PreSignedUrl when you are performing cross-region replication from an encrypted DB cluster.\n            The pre-signed URL must be a valid request for the CreateDBCluster API action that can be executed in the source region that contains the encrypted DB cluster to be copied.\n            The pre-signed URL request must contain the following parameter values:\n            KmsKeyId - The KMS key identifier for the key to use to encrypt the copy of the DB cluster in the destination region. This should refer to the same KMS key for both the CreateDBCluster action that is called in the destination region, and the action contained in the pre-signed URL.\n            DestinationRegion - The name of the region that Aurora Read Replica will be created in.\n            ReplicationSourceIdentifier - The DB cluster identifier for the encrypted DB cluster to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source region. For example, if you are copying an encrypted DB cluster from the us-west-2 region, then your ReplicationSourceIdentifier would look like Example: arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1 .\n            To learn how to generate a Signature Version 4 signed request, see Authenticating Requests: Using Query Parameters (AWS Signature Version 4) and Signature Version 4 Signing Process .\n            Please note that this parameter is automatically populated if it is not provided. Including this parameter is not required\n            \n\n    :type EnableIAMDatabaseAuthentication: boolean\n    :param EnableIAMDatabaseAuthentication: A Boolean value that is true to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts, and otherwise false.\n            Default: false\n            \n\n    :type SourceRegion: string\n    :param SourceRegion: The ID of the region that contains the source for the db cluster.\n\n    :rtype: dict\n    :return: {\n        'DBCluster': {\n            'AllocatedStorage': 123,\n            'AvailabilityZones': [\n                'string',\n            ],\n            'BackupRetentionPeriod': 123,\n            'CharacterSetName': 'string',\n            'DatabaseName': 'string',\n            'DBClusterIdentifier': 'string',\n            'DBClusterParameterGroup': 'string',\n            'DBSubnetGroup': 'string',\n            'Status': 'string',\n            'PercentProgress': 'string',\n            'EarliestRestorableTime': datetime(2015, 1, 1),\n            'Endpoint': 'string',\n            'ReaderEndpoint': 'string',\n            'MultiAZ': True|False,\n            'Engine': 'string',\n            'EngineVersion': 'string',\n            'LatestRestorableTime': datetime(2015, 1, 1),\n            'Port': 123,\n            'MasterUsername': 'string',\n            'DBClusterOptionGroupMemberships': [\n                {\n                    'DBClusterOptionGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'PreferredBackupWindow': 'string',\n            'PreferredMaintenanceWindow': 'string',\n            'ReplicationSourceIdentifier': 'string',\n            'ReadReplicaIdentifiers': [\n                'string',\n            ],\n            'DBClusterMembers': [\n                {\n                    'DBInstanceIdentifier': 'string',\n                    'IsClusterWriter': True|False,\n                    'DBClusterParameterGroupStatus': 'string',\n                    'PromotionTier': 123\n                },\n            ],\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'HostedZoneId': 'string',\n            'StorageEncrypted': True|False,\n            'KmsKeyId': 'string',\n            'DbClusterResourceId': 'string',\n            'DBClusterArn': 'string',\n            'AssociatedRoles': [\n                {\n                    'RoleArn': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'IAMDatabaseAuthenticationEnabled': True|False,\n            'ClusterCreateTime': datetime(2015, 1, 1)\n        }\n    }\n    \n    \n    :returns: \n    CreateDBCluster\n    DeleteDBCluster\n    FailoverDBCluster\n    ModifyDBCluster\n    RestoreDBClusterFromSnapshot\n    RestoreDBClusterToPointInTime\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new DB instance. See also: AWS API Documentation Examples This example creates a DB instance. Expected Output: :example: response = client.create_db_instance( DBName='string', DBInstanceIdentifier='string', AllocatedStorage=123, DBInstanceClass='string', Engine='string', MasterUsername='string', MasterUserPassword='string', DBSecurityGroups=[ 'string', ], VpcSecurityGroupIds=[ 'string', ], AvailabilityZone='string', DBSubnetGroupName='string', PreferredMaintenanceWindow='string', DBParameterGroupName='string', BackupRetentionPeriod=123, PreferredBackupWindow='string', Port=123, MultiAZ=True|False, EngineVersion='string', AutoMinorVersionUpgrade=True|False, LicenseModel='string', Iops=123, OptionGroupName='string', CharacterSetName='string', PubliclyAccessible=True|False, Tags=[ { 'Key': 'string', 'Value': 'string' }, ], DBClusterIdentifier='string', StorageType='string', TdeCredentialArn='string', TdeCredentialPassword='string', StorageEncrypted=True|False, KmsKeyId='string', Domain='string', CopyTagsToSnapshot=True|False, MonitoringInterval=123, MonitoringRoleArn='string', DomainIAMRoleName='string', PromotionTier=123, Timezone='string', EnableIAMDatabaseAuthentication=True|False ) :type DBName: string :param DBName: The meaning of this parameter differs according to the database engine you use. Type: String MySQL The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints: Must contain 1 to 64 alphanumeric characters Cannot be a word reserved by the specified database engine MariaDB The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints: Must contain 1 to 64 alphanumeric characters Cannot be a word reserved by the specified database engine PostgreSQL The name of the database to create when the DB instance is created. If this parameter is not specified, the default 'postgres' database is created in the DB instance. Constraints: Must contain 1 to 63 alphanumeric characters Must begin with a letter or an underscore. Subsequent characters can be letters, underscores, or digits (0-9). Cannot be a word reserved by the specified database engine Oracle The Oracle System ID (SID) of the created DB instance. If you specify null , the default value ORCL is used. You can't specify the string NULL, or any other reserved word, for DBName . Default: ORCL Constraints: Cannot be longer than 8 characters SQL Server Not applicable. Must be null. Amazon Aurora The name of the database to create when the primary instance of the DB cluster is created. If this parameter is not specified, no database is created in the DB instance. Constraints: Must contain 1 to 64 alphanumeric characters Cannot be a word reserved by the specified database engine :type DBInstanceIdentifier: string :param DBInstanceIdentifier: [REQUIRED] The DB instance identifier. This parameter is stored as a lowercase string. Constraints: Must contain from 1 to 63 alphanumeric characters or hyphens (1 to 15 for SQL Server). First character must be a letter. Cannot end with a hyphen or contain two consecutive hyphens. Example: mydbinstance :type AllocatedStorage: integer :param AllocatedStorage: The amount of storage (in gigabytes) to be initially allocated for the database instance. Type: Integer Amazon Aurora Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume. MySQL Constraints: Must be an integer from 5 to 6144. MariaDB Constraints: Must be an integer from 5 to 6144. PostgreSQL Constraints: Must be an integer from 5 to 6144. Oracle Constraints: Must be an integer from 10 to 6144. SQL Server Constraints: Must be an integer from 200 to 4096 (Standard Edition and Enterprise Edition) or from 20 to 4096 (Express Edition and Web Edition) :type DBInstanceClass: string :param DBInstanceClass: [REQUIRED] The compute and memory capacity of the DB instance. Note that not all instance classes are available in all regions for all DB engines. Valid Values: db.t1.micro | db.m1.small | db.m1.medium | db.m1.large | db.m1.xlarge | db.m2.xlarge |db.m2.2xlarge | db.m2.4xlarge | db.m3.medium | db.m3.large | db.m3.xlarge | db.m3.2xlarge | db.m4.large | db.m4.xlarge | db.m4.2xlarge | db.m4.4xlarge | db.m4.10xlarge | db.r3.large | db.r3.xlarge | db.r3.2xlarge | db.r3.4xlarge | db.r3.8xlarge | db.t2.micro | db.t2.small | db.t2.medium | db.t2.large :type Engine: string :param Engine: [REQUIRED] The name of the database engine to be used for this instance. Valid Values: mysql | mariadb | oracle-se1 | oracle-se2 | oracle-se | oracle-ee | sqlserver-ee | sqlserver-se | sqlserver-ex | sqlserver-web | postgres | aurora Not every database engine is available for every AWS region. :type MasterUsername: string :param MasterUsername: The name for the master database user. Amazon Aurora Not applicable. You specify the name for the master database user when you create your DB cluster. MariaDB Constraints: Must be 1 to 16 alphanumeric characters. Cannot be a reserved word for the chosen database engine. Microsoft SQL Server Constraints: Must be 1 to 128 alphanumeric characters. First character must be a letter. Cannot be a reserved word for the chosen database engine. MySQL Constraints: Must be 1 to 16 alphanumeric characters. First character must be a letter. Cannot be a reserved word for the chosen database engine. Oracle Constraints: Must be 1 to 30 alphanumeric characters. First character must be a letter. Cannot be a reserved word for the chosen database engine. PostgreSQL Constraints: Must be 1 to 63 alphanumeric characters. First character must be a letter. Cannot be a reserved word for the chosen database engine. :type MasterUserPassword: string :param MasterUserPassword: The password for the master database user. Can be any printable ASCII character except '/', ''', or '@'. Amazon Aurora Not applicable. You specify the password for the master database user when you create your DB cluster. MariaDB Constraints: Must contain from 8 to 41 characters. Microsoft SQL Server Constraints: Must contain from 8 to 128 characters. MySQL Constraints: Must contain from 8 to 41 characters. Oracle Constraints: Must contain from 8 to 30 characters. PostgreSQL Constraints: Must contain from 8 to 128 characters. :type DBSecurityGroups: list :param DBSecurityGroups: A list of DB security groups to associate with this DB instance. Default: The default DB security group for the database engine. (string) -- :type VpcSecurityGroupIds: list :param VpcSecurityGroupIds: A list of EC2 VPC security groups to associate with this DB instance. Default: The default EC2 VPC security group for the DB subnet group's VPC. (string) -- :type AvailabilityZone: string :param AvailabilityZone: The EC2 Availability Zone that the database instance will be created in. For information on regions and Availability Zones, see Regions and Availability Zones . Default: A random, system-chosen Availability Zone in the endpoint's region. Example: us-east-1d Constraint: The AvailabilityZone parameter cannot be specified if the MultiAZ parameter is set to true . The specified Availability Zone must be in the same region as the current endpoint. :type DBSubnetGroupName: string :param DBSubnetGroupName: A DB subnet group to associate with this DB instance. If there is no DB subnet group, then it is a non-VPC DB instance. :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). For more information, see DB Instance Maintenance . Format: ddd:hh24:mi-ddd:hh24:mi Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window. :type DBParameterGroupName: string :param DBParameterGroupName: The name of the DB parameter group to associate with this DB instance. If this argument is omitted, the default DBParameterGroup for the specified engine will be used. Constraints: Must be 1 to 255 alphanumeric characters First character must be a letter Cannot end with a hyphen or contain two consecutive hyphens :type BackupRetentionPeriod: integer :param BackupRetentionPeriod: The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. Default: 1 Constraints: Must be a value from 0 to 35 Cannot be set to 0 if the DB instance is a source to Read Replicas :type PreferredBackupWindow: string :param PreferredBackupWindow: The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. For more information, see DB Instance Backups . Default: A 30-minute window selected at random from an 8-hour block of time per region. To see the time blocks available, see Adjusting the Preferred DB Instance Maintenance Window . Constraints: Must be in the format hh24:mi-hh24:mi . Times should be in Universal Coordinated Time (UTC). Must not conflict with the preferred maintenance window. Must be at least 30 minutes. :type Port: integer :param Port: The port number on which the database accepts connections. MySQL Default: 3306 Valid Values: 1150-65535 Type: Integer MariaDB Default: 3306 Valid Values: 1150-65535 Type: Integer PostgreSQL Default: 5432 Valid Values: 1150-65535 Type: Integer Oracle Default: 1521 Valid Values: 1150-65535 SQL Server Default: 1433 Valid Values: 1150-65535 except for 1434 , 3389 , 47001 , 49152 , and 49152 through 49156 . Amazon Aurora Default: 3306 Valid Values: 1150-65535 Type: Integer :type MultiAZ: boolean :param MultiAZ: Specifies if the DB instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the MultiAZ parameter is set to true. :type EngineVersion: string :param EngineVersion: The version number of the database engine to use. The following are the database engines and major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS region. Amazon Aurora Version 5.6 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-2, eu-west-1, us-east-1, us-east-2, us-west-2): 5.6.10a MariaDB Version 10.1 (available in these AWS regions: us-east-2): 10.1.16 Version 10.1 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-west-1, us-west-2): 10.1.14 Version 10.0 (available in all AWS regions): 10.0.24 Version 10.0 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 10.0.17 Microsoft SQL Server 2016 13.00.2164.0.v1 (supported for all editions, and all AWS regions except sa-east-1) Microsoft SQL Server 2014 12.00.5000.0.v1 (supported for all editions, and all AWS regions) 12.00.4422.0.v1 (supported for all editions except Enterprise Edition, and all AWS regions except us-east-2) Microsoft SQL Server 2012 11.00.6020.0.v1 (supported for all editions, and all AWS regions) 11.00.5058.0.v1 (supported for all editions, and all AWS regions except us-east-2) 11.00.2100.60.v1 (supported for all editions, and all AWS regions except us-east-2) Microsoft SQL Server 2008 R2 10.50.6529.0.v1 (supported for all editions, and all AWS regions except us-east-2) 10.50.6000.34.v1 (supported for all editions, and all AWS regions except us-east-2) 10.50.2789.0.v1 (supported for all editions, and all AWS regions except us-east-2) MySQL Version 5.7 (available in all AWS regions): 5.7.11 Version 5.7 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.7.10 Version 5.6 (available in all AWS regions): 5.6.29 Version 5.6 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.6.27 Version 5.6 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.6.23 Version 5.6 (available in these AWS regions: ap-northeast-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.6.19a | 5.6.19b | 5.6.21 | 5.6.21b | 5.6.22 Version 5.5 (available in all AWS regions): 5.5.46 Version 5.1 (only available in AWS regions ap-northeast-1, ap-southeast-1, ap-southeast-2, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.1.73a | 5.1.73b Oracle 12c 12.1.0.2.v8 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v7 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v6 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v5 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v4 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v3 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v2 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) 12.1.0.2.v1 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1) Oracle 11g 11.2.0.4.v12 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v11 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v10 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v9 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v8 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v7 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v6 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v5 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v4 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v3 (supported for EE, SE1, and SE, in all AWS regions) 11.2.0.4.v1 (supported for EE, SE1, and SE, in all AWS regions) PostgreSQL Version 9.6.x: 9.6.1 | 9.6.2 Version 9.5.x: 9.5.6 | 9.5.4 | 9.5.2 Version 9.4.x: 9.4.11 | 9.4.9 | 9.4.7 Version 9.3.x: 9.3.16 | 9.3.14 | 9.3.12 :type AutoMinorVersionUpgrade: boolean :param AutoMinorVersionUpgrade: Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Default: true :type LicenseModel: string :param LicenseModel: License model information for this DB instance. Valid values: license-included | bring-your-own-license | general-public-license :type Iops: integer :param Iops: The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance. Constraints: Must be a multiple between 3 and 10 of the storage amount for the DB instance. Must also be an integer multiple of 1000. For example, if the size of your DB instance is 500 GB, then your Iops value can be 2000, 3000, 4000, or 5000. :type OptionGroupName: string :param OptionGroupName: Indicates that the DB instance should be associated with the specified option group. Permanent options, such as the TDE option for Oracle Advanced Security TDE, cannot be removed from an option group, and that option group cannot be removed from a DB instance once it is associated with a DB instance :type CharacterSetName: string :param CharacterSetName: For supported engines, indicates that the DB instance should be associated with the specified CharacterSet. :type PubliclyAccessible: boolean :param PubliclyAccessible: Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether a VPC has been requested or not. The following list shows the default behavior in each case. Default VPC: true VPC: false If no DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be publicly accessible. If a specific DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be private. :type Tags: list :param Tags: A list of tags. (dict) --Metadata assigned to an Amazon RDS resource consisting of a key-value pair. Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). :type DBClusterIdentifier: string :param DBClusterIdentifier: The identifier of the DB cluster that the instance will belong to. For information on creating a DB cluster, see CreateDBCluster . Type: String :type StorageType: string :param StorageType: Specifies the storage type to be associated with the DB instance. Valid values: standard | gp2 | io1 If you specify io1 , you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified; otherwise standard :type TdeCredentialArn: string :param TdeCredentialArn: The ARN from the Key Store with which to associate the instance for TDE encryption. :type TdeCredentialPassword: string :param TdeCredentialPassword: The password for the given ARN from the Key Store in order to access the device. :type StorageEncrypted: boolean :param StorageEncrypted: Specifies whether the DB instance is encrypted. Default: false :type KmsKeyId: string :param KmsKeyId: The KMS key identifier for an encrypted DB instance. The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a DB instance with the same AWS account that owns the KMS encryption key used to encrypt the new DB instance, then you can use the KMS key alias instead of the ARN for the KM encryption key. If the StorageEncrypted parameter is true, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. :type Domain: string :param Domain: Specify the Active Directory Domain to create the instance in. :type CopyTagsToSnapshot: boolean :param CopyTagsToSnapshot: True to copy all tags from the DB instance to snapshots of the DB instance; otherwise false. The default is false. :type MonitoringInterval: integer :param MonitoringInterval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. If MonitoringRoleArn is specified, then you must also set MonitoringInterval to a value other than 0. Valid Values: 0, 1, 5, 10, 15, 30, 60 :type MonitoringRoleArn: string :param MonitoringRoleArn: The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess . For information on creating a monitoring role, go to Setting Up and Enabling Enhanced Monitoring . If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value. :type DomainIAMRoleName: string :param DomainIAMRoleName: Specify the name of the IAM role to be used when making API calls to the Directory Service. :type PromotionTier: integer :param PromotionTier: A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see Fault Tolerance for an Aurora DB Cluster . Default: 1 Valid Values: 0 - 15 :type Timezone: string :param Timezone: The time zone of the DB instance. The time zone parameter is currently supported only by Microsoft SQL Server . :type EnableIAMDatabaseAuthentication: boolean :param EnableIAMDatabaseAuthentication: True to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts; otherwise false. You can enable IAM database authentication for the following database engines For MySQL 5.6, minor version 5.6.34 or higher For MySQL 5.7, minor version 5.7.16 or higher Default: false :rtype: dict :return: { 'DBInstance': { 'DBInstanceIdentifier': 'string', 'DBInstanceClass': 'string', 'Engine': 'string', 'DBInstanceStatus': 'string', 'MasterUsername': 'string', 'DBName': 'string', 'Endpoint': { 'Address': 'string', 'Port': 123, 'HostedZoneId': 'string' }, 'AllocatedStorage': 123, 'InstanceCreateTime': datetime(2015, 1, 1), 'PreferredBackupWindow': 'string', 'BackupRetentionPeriod': 123, 'DBSecurityGroups': [ { 'DBSecurityGroupName': 'string', 'Status': 'string' }, ], 'VpcSecurityGroups': [ { 'VpcSecurityGroupId': 'string', 'Status': 'string' }, ], 'DBParameterGroups': [ { 'DBParameterGroupName': 'string', 'ParameterApplyStatus': 'string' }, ], 'AvailabilityZone': 'string', 'DBSubnetGroup': { 'DBSubnetGroupName': 'string', 'DBSubnetGroupDescription': 'string', 'VpcId': 'string', 'SubnetGroupStatus': 'string', 'Subnets': [ { 'SubnetIdentifier': 'string', 'SubnetAvailabilityZone': { 'Name': 'string' }, 'SubnetStatus': 'string' }, ], 'DBSubnetGroupArn': 'string' }, 'PreferredMaintenanceWindow': 'string', 'PendingModifiedValues': { 'DBInstanceClass': 'string', 'AllocatedStorage': 123, 'MasterUserPassword': 'string', 'Port': 123, 'BackupRetentionPeriod': 123, 'MultiAZ': True|False, 'EngineVersion': 'string', 'LicenseModel': 'string', 'Iops': 123, 'DBInstanceIdentifier': 'string', 'StorageType': 'string', 'CACertificateIdentifier': 'string', 'DBSubnetGroupName': 'string' }, 'LatestRestorableTime': datetime(2015, 1, 1), 'MultiAZ': True|False, 'EngineVersion': 'string', 'AutoMinorVersionUpgrade': True|False, 'ReadReplicaSourceDBInstanceIdentifier': 'string', 'ReadReplicaDBInstanceIdentifiers': [ 'string', ], 'ReadReplicaDBClusterIdentifiers': [ 'string', ], 'LicenseModel': 'string', 'Iops': 123, 'OptionGroupMemberships': [ { 'OptionGroupName': 'string', 'Status': 'string' }, ], 'CharacterSetName': 'string', 'SecondaryAvailabilityZone': 'string', 'PubliclyAccessible': True|False, 'StatusInfos': [ { 'StatusType': 'string', 'Normal': True|False, 'Status': 'string', 'Message': 'string' }, ], 'StorageType': 'string', 'TdeCredentialArn': 'string', 'DbInstancePort': 123, 'DBClusterIdentifier': 'string', 'StorageEncrypted': True|False, 'KmsKeyId': 'string', 'DbiResourceId': 'string', 'CACertificateIdentifier': 'string', 'DomainMemberships': [ { 'Domain': 'string', 'Status': 'string', 'FQDN': 'string', 'IAMRoleName': 'string' }, ], 'CopyTagsToSnapshot': True|False, 'MonitoringInterval': 123, 'EnhancedMonitoringResourceArn': 'string', 'MonitoringRoleArn': 'string', 'PromotionTier': 123, 'DBInstanceArn': 'string', 'Timezone': 'string', 'IAMDatabaseAuthenticationEnabled': True|False } } :returns: CreateDBInstance DeleteDBInstance ModifyDBInstance", "response": "def create_db_instance(DBName=None, DBInstanceIdentifier=None, AllocatedStorage=None, DBInstanceClass=None, Engine=None, MasterUsername=None, MasterUserPassword=None, DBSecurityGroups=None, VpcSecurityGroupIds=None, AvailabilityZone=None, DBSubnetGroupName=None, PreferredMaintenanceWindow=None, DBParameterGroupName=None, BackupRetentionPeriod=None, PreferredBackupWindow=None, Port=None, MultiAZ=None, EngineVersion=None, AutoMinorVersionUpgrade=None, LicenseModel=None, Iops=None, OptionGroupName=None, CharacterSetName=None, PubliclyAccessible=None, Tags=None, DBClusterIdentifier=None, StorageType=None, TdeCredentialArn=None, TdeCredentialPassword=None, StorageEncrypted=None, KmsKeyId=None, Domain=None, CopyTagsToSnapshot=None, MonitoringInterval=None, MonitoringRoleArn=None, DomainIAMRoleName=None, PromotionTier=None, Timezone=None, EnableIAMDatabaseAuthentication=None):\n    \"\"\"\n    Creates a new DB instance.\n    See also: AWS API Documentation\n    \n    Examples\n    This example creates a DB instance.\n    Expected Output:\n    \n    :example: response = client.create_db_instance(\n        DBName='string',\n        DBInstanceIdentifier='string',\n        AllocatedStorage=123,\n        DBInstanceClass='string',\n        Engine='string',\n        MasterUsername='string',\n        MasterUserPassword='string',\n        DBSecurityGroups=[\n            'string',\n        ],\n        VpcSecurityGroupIds=[\n            'string',\n        ],\n        AvailabilityZone='string',\n        DBSubnetGroupName='string',\n        PreferredMaintenanceWindow='string',\n        DBParameterGroupName='string',\n        BackupRetentionPeriod=123,\n        PreferredBackupWindow='string',\n        Port=123,\n        MultiAZ=True|False,\n        EngineVersion='string',\n        AutoMinorVersionUpgrade=True|False,\n        LicenseModel='string',\n        Iops=123,\n        OptionGroupName='string',\n        CharacterSetName='string',\n        PubliclyAccessible=True|False,\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        DBClusterIdentifier='string',\n        StorageType='string',\n        TdeCredentialArn='string',\n        TdeCredentialPassword='string',\n        StorageEncrypted=True|False,\n        KmsKeyId='string',\n        Domain='string',\n        CopyTagsToSnapshot=True|False,\n        MonitoringInterval=123,\n        MonitoringRoleArn='string',\n        DomainIAMRoleName='string',\n        PromotionTier=123,\n        Timezone='string',\n        EnableIAMDatabaseAuthentication=True|False\n    )\n    \n    \n    :type DBName: string\n    :param DBName: The meaning of this parameter differs according to the database engine you use.\n            Type: String\n            MySQL\n            The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance.\n            Constraints:\n            Must contain 1 to 64 alphanumeric characters\n            Cannot be a word reserved by the specified database engine\n            MariaDB\n            The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance.\n            Constraints:\n            Must contain 1 to 64 alphanumeric characters\n            Cannot be a word reserved by the specified database engine\n            PostgreSQL\n            The name of the database to create when the DB instance is created. If this parameter is not specified, the default 'postgres' database is created in the DB instance.\n            Constraints:\n            Must contain 1 to 63 alphanumeric characters\n            Must begin with a letter or an underscore. Subsequent characters can be letters, underscores, or digits (0-9).\n            Cannot be a word reserved by the specified database engine\n            Oracle\n            The Oracle System ID (SID) of the created DB instance. If you specify null , the default value ORCL is used. You can't specify the string NULL, or any other reserved word, for DBName .\n            Default: ORCL\n            Constraints:\n            Cannot be longer than 8 characters\n            SQL Server\n            Not applicable. Must be null.\n            Amazon Aurora\n            The name of the database to create when the primary instance of the DB cluster is created. If this parameter is not specified, no database is created in the DB instance.\n            Constraints:\n            Must contain 1 to 64 alphanumeric characters\n            Cannot be a word reserved by the specified database engine\n            \n\n    :type DBInstanceIdentifier: string\n    :param DBInstanceIdentifier: [REQUIRED]\n            The DB instance identifier. This parameter is stored as a lowercase string.\n            Constraints:\n            Must contain from 1 to 63 alphanumeric characters or hyphens (1 to 15 for SQL Server).\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            Example: mydbinstance\n            \n\n    :type AllocatedStorage: integer\n    :param AllocatedStorage: The amount of storage (in gigabytes) to be initially allocated for the database instance.\n            Type: Integer\n            Amazon Aurora\n            Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume.\n            MySQL\n            Constraints: Must be an integer from 5 to 6144.\n            MariaDB\n            Constraints: Must be an integer from 5 to 6144.\n            PostgreSQL\n            Constraints: Must be an integer from 5 to 6144.\n            Oracle\n            Constraints: Must be an integer from 10 to 6144.\n            SQL Server\n            Constraints: Must be an integer from 200 to 4096 (Standard Edition and Enterprise Edition) or from 20 to 4096 (Express Edition and Web Edition)\n            \n\n    :type DBInstanceClass: string\n    :param DBInstanceClass: [REQUIRED]\n            The compute and memory capacity of the DB instance. Note that not all instance classes are available in all regions for all DB engines.\n            Valid Values: db.t1.micro | db.m1.small | db.m1.medium | db.m1.large | db.m1.xlarge | db.m2.xlarge |db.m2.2xlarge | db.m2.4xlarge | db.m3.medium | db.m3.large | db.m3.xlarge | db.m3.2xlarge | db.m4.large | db.m4.xlarge | db.m4.2xlarge | db.m4.4xlarge | db.m4.10xlarge | db.r3.large | db.r3.xlarge | db.r3.2xlarge | db.r3.4xlarge | db.r3.8xlarge | db.t2.micro | db.t2.small | db.t2.medium | db.t2.large\n            \n\n    :type Engine: string\n    :param Engine: [REQUIRED]\n            The name of the database engine to be used for this instance.\n            Valid Values: mysql | mariadb | oracle-se1 | oracle-se2 | oracle-se | oracle-ee | sqlserver-ee | sqlserver-se | sqlserver-ex | sqlserver-web | postgres | aurora\n            Not every database engine is available for every AWS region.\n            \n\n    :type MasterUsername: string\n    :param MasterUsername: The name for the master database user.\n            Amazon Aurora\n            Not applicable. You specify the name for the master database user when you create your DB cluster.\n            MariaDB\n            Constraints:\n            Must be 1 to 16 alphanumeric characters.\n            Cannot be a reserved word for the chosen database engine.\n            Microsoft SQL Server\n            Constraints:\n            Must be 1 to 128 alphanumeric characters.\n            First character must be a letter.\n            Cannot be a reserved word for the chosen database engine.\n            MySQL\n            Constraints:\n            Must be 1 to 16 alphanumeric characters.\n            First character must be a letter.\n            Cannot be a reserved word for the chosen database engine.\n            Oracle\n            Constraints:\n            Must be 1 to 30 alphanumeric characters.\n            First character must be a letter.\n            Cannot be a reserved word for the chosen database engine.\n            PostgreSQL\n            Constraints:\n            Must be 1 to 63 alphanumeric characters.\n            First character must be a letter.\n            Cannot be a reserved word for the chosen database engine.\n            \n\n    :type MasterUserPassword: string\n    :param MasterUserPassword: The password for the master database user. Can be any printable ASCII character except '/', ''', or '@'.\n            Amazon Aurora\n            Not applicable. You specify the password for the master database user when you create your DB cluster.\n            MariaDB\n            Constraints: Must contain from 8 to 41 characters.\n            Microsoft SQL Server\n            Constraints: Must contain from 8 to 128 characters.\n            MySQL\n            Constraints: Must contain from 8 to 41 characters.\n            Oracle\n            Constraints: Must contain from 8 to 30 characters.\n            PostgreSQL\n            Constraints: Must contain from 8 to 128 characters.\n            \n\n    :type DBSecurityGroups: list\n    :param DBSecurityGroups: A list of DB security groups to associate with this DB instance.\n            Default: The default DB security group for the database engine.\n            (string) --\n            \n\n    :type VpcSecurityGroupIds: list\n    :param VpcSecurityGroupIds: A list of EC2 VPC security groups to associate with this DB instance.\n            Default: The default EC2 VPC security group for the DB subnet group's VPC.\n            (string) --\n            \n\n    :type AvailabilityZone: string\n    :param AvailabilityZone: The EC2 Availability Zone that the database instance will be created in. For information on regions and Availability Zones, see Regions and Availability Zones .\n            Default: A random, system-chosen Availability Zone in the endpoint's region.\n            Example: us-east-1d\n            Constraint: The AvailabilityZone parameter cannot be specified if the MultiAZ parameter is set to true . The specified Availability Zone must be in the same region as the current endpoint.\n            \n\n    :type DBSubnetGroupName: string\n    :param DBSubnetGroupName: A DB subnet group to associate with this DB instance.\n            If there is no DB subnet group, then it is a non-VPC DB instance.\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). For more information, see DB Instance Maintenance .\n            Format: ddd:hh24:mi-ddd:hh24:mi\n            Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.\n            Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun\n            Constraints: Minimum 30-minute window.\n            \n\n    :type DBParameterGroupName: string\n    :param DBParameterGroupName: The name of the DB parameter group to associate with this DB instance. If this argument is omitted, the default DBParameterGroup for the specified engine will be used.\n            Constraints:\n            Must be 1 to 255 alphanumeric characters\n            First character must be a letter\n            Cannot end with a hyphen or contain two consecutive hyphens\n            \n\n    :type BackupRetentionPeriod: integer\n    :param BackupRetentionPeriod: The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.\n            Default: 1\n            Constraints:\n            Must be a value from 0 to 35\n            Cannot be set to 0 if the DB instance is a source to Read Replicas\n            \n\n    :type PreferredBackupWindow: string\n    :param PreferredBackupWindow: The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. For more information, see DB Instance Backups .\n            Default: A 30-minute window selected at random from an 8-hour block of time per region. To see the time blocks available, see Adjusting the Preferred DB Instance Maintenance Window .\n            Constraints:\n            Must be in the format hh24:mi-hh24:mi .\n            Times should be in Universal Coordinated Time (UTC).\n            Must not conflict with the preferred maintenance window.\n            Must be at least 30 minutes.\n            \n\n    :type Port: integer\n    :param Port: The port number on which the database accepts connections.\n            MySQL\n            Default: 3306\n            Valid Values: 1150-65535\n            Type: Integer\n            MariaDB\n            Default: 3306\n            Valid Values: 1150-65535\n            Type: Integer\n            PostgreSQL\n            Default: 5432\n            Valid Values: 1150-65535\n            Type: Integer\n            Oracle\n            Default: 1521\n            Valid Values: 1150-65535\n            SQL Server\n            Default: 1433\n            Valid Values: 1150-65535 except for 1434 , 3389 , 47001 , 49152 , and 49152 through 49156 .\n            Amazon Aurora\n            Default: 3306\n            Valid Values: 1150-65535\n            Type: Integer\n            \n\n    :type MultiAZ: boolean\n    :param MultiAZ: Specifies if the DB instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the MultiAZ parameter is set to true.\n\n    :type EngineVersion: string\n    :param EngineVersion: The version number of the database engine to use.\n            The following are the database engines and major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS region.\n            Amazon Aurora\n            Version 5.6 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-2, eu-west-1, us-east-1, us-east-2, us-west-2): 5.6.10a\n            MariaDB\n            Version 10.1 (available in these AWS regions: us-east-2): 10.1.16\n            Version 10.1 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-west-1, us-west-2): 10.1.14\n            Version 10.0 (available in all AWS regions): 10.0.24\n            Version 10.0 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 10.0.17\n            Microsoft SQL Server 2016\n            13.00.2164.0.v1 (supported for all editions, and all AWS regions except sa-east-1)\n            Microsoft SQL Server 2014\n            12.00.5000.0.v1 (supported for all editions, and all AWS regions)\n            12.00.4422.0.v1 (supported for all editions except Enterprise Edition, and all AWS regions except us-east-2)\n            Microsoft SQL Server 2012\n            11.00.6020.0.v1 (supported for all editions, and all AWS regions)\n            11.00.5058.0.v1 (supported for all editions, and all AWS regions except us-east-2)\n            11.00.2100.60.v1 (supported for all editions, and all AWS regions except us-east-2)\n            Microsoft SQL Server 2008 R2\n            10.50.6529.0.v1 (supported for all editions, and all AWS regions except us-east-2)\n            10.50.6000.34.v1 (supported for all editions, and all AWS regions except us-east-2)\n            10.50.2789.0.v1 (supported for all editions, and all AWS regions except us-east-2)\n            MySQL\n            Version 5.7 (available in all AWS regions): 5.7.11\n            Version 5.7 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.7.10\n            Version 5.6 (available in all AWS regions): 5.6.29\n            Version 5.6 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.6.27\n            Version 5.6 (available in these AWS regions: ap-northeast-1, ap-northeast-2, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.6.23\n            Version 5.6 (available in these AWS regions: ap-northeast-1, ap-southeast-1, ap-southeast-2, eu-central-1, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.6.19a | 5.6.19b | 5.6.21 | 5.6.21b | 5.6.22\n            Version 5.5 (available in all AWS regions): 5.5.46\n            Version 5.1 (only available in AWS regions ap-northeast-1, ap-southeast-1, ap-southeast-2, eu-west-1, sa-east-1, us-east-1, us-gov-west-1, us-west-1, us-west-2): 5.1.73a | 5.1.73b\n            Oracle 12c\n            12.1.0.2.v8 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v7 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v6 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v5 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v4 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v3 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v2 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            12.1.0.2.v1 (supported for EE in all AWS regions, and SE2 in all AWS regions except us-gov-west-1)\n            Oracle 11g\n            11.2.0.4.v12 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v11 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v10 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v9 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v8 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v7 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v6 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v5 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v4 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v3 (supported for EE, SE1, and SE, in all AWS regions)\n            11.2.0.4.v1 (supported for EE, SE1, and SE, in all AWS regions)\n            PostgreSQL\n            Version 9.6.x: 9.6.1 | 9.6.2\n            Version 9.5.x: 9.5.6 | 9.5.4 | 9.5.2\n            Version 9.4.x: 9.4.11 | 9.4.9 | 9.4.7\n            Version 9.3.x: 9.3.16 | 9.3.14 | 9.3.12\n            \n\n    :type AutoMinorVersionUpgrade: boolean\n    :param AutoMinorVersionUpgrade: Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window.\n            Default: true\n            \n\n    :type LicenseModel: string\n    :param LicenseModel: License model information for this DB instance.\n            Valid values: license-included | bring-your-own-license | general-public-license\n            \n\n    :type Iops: integer\n    :param Iops: The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.\n            Constraints: Must be a multiple between 3 and 10 of the storage amount for the DB instance. Must also be an integer multiple of 1000. For example, if the size of your DB instance is 500 GB, then your Iops value can be 2000, 3000, 4000, or 5000.\n            \n\n    :type OptionGroupName: string\n    :param OptionGroupName: Indicates that the DB instance should be associated with the specified option group.\n            Permanent options, such as the TDE option for Oracle Advanced Security TDE, cannot be removed from an option group, and that option group cannot be removed from a DB instance once it is associated with a DB instance\n            \n\n    :type CharacterSetName: string\n    :param CharacterSetName: For supported engines, indicates that the DB instance should be associated with the specified CharacterSet.\n\n    :type PubliclyAccessible: boolean\n    :param PubliclyAccessible: Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.\n            Default: The default behavior varies depending on whether a VPC has been requested or not. The following list shows the default behavior in each case.\n            Default VPC: true\n            VPC: false\n            If no DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be publicly accessible. If a specific DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be private.\n            \n\n    :type Tags: list\n    :param Tags: A list of tags.\n            (dict) --Metadata assigned to an Amazon RDS resource consisting of a key-value pair.\n            Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            \n            \n\n    :type DBClusterIdentifier: string\n    :param DBClusterIdentifier: The identifier of the DB cluster that the instance will belong to.\n            For information on creating a DB cluster, see CreateDBCluster .\n            Type: String\n            \n\n    :type StorageType: string\n    :param StorageType: Specifies the storage type to be associated with the DB instance.\n            Valid values: standard | gp2 | io1\n            If you specify io1 , you must also include a value for the Iops parameter.\n            Default: io1 if the Iops parameter is specified; otherwise standard\n            \n\n    :type TdeCredentialArn: string\n    :param TdeCredentialArn: The ARN from the Key Store with which to associate the instance for TDE encryption.\n\n    :type TdeCredentialPassword: string\n    :param TdeCredentialPassword: The password for the given ARN from the Key Store in order to access the device.\n\n    :type StorageEncrypted: boolean\n    :param StorageEncrypted: Specifies whether the DB instance is encrypted.\n            Default: false\n            \n\n    :type KmsKeyId: string\n    :param KmsKeyId: The KMS key identifier for an encrypted DB instance.\n            The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a DB instance with the same AWS account that owns the KMS encryption key used to encrypt the new DB instance, then you can use the KMS key alias instead of the ARN for the KM encryption key.\n            If the StorageEncrypted parameter is true, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.\n            \n\n    :type Domain: string\n    :param Domain: Specify the Active Directory Domain to create the instance in.\n\n    :type CopyTagsToSnapshot: boolean\n    :param CopyTagsToSnapshot: True to copy all tags from the DB instance to snapshots of the DB instance; otherwise false. The default is false.\n\n    :type MonitoringInterval: integer\n    :param MonitoringInterval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0.\n            If MonitoringRoleArn is specified, then you must also set MonitoringInterval to a value other than 0.\n            Valid Values: 0, 1, 5, 10, 15, 30, 60\n            \n\n    :type MonitoringRoleArn: string\n    :param MonitoringRoleArn: The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess . For information on creating a monitoring role, go to Setting Up and Enabling Enhanced Monitoring .\n            If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value.\n            \n\n    :type DomainIAMRoleName: string\n    :param DomainIAMRoleName: Specify the name of the IAM role to be used when making API calls to the Directory Service.\n\n    :type PromotionTier: integer\n    :param PromotionTier: A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see Fault Tolerance for an Aurora DB Cluster .\n            Default: 1\n            Valid Values: 0 - 15\n            \n\n    :type Timezone: string\n    :param Timezone: The time zone of the DB instance. The time zone parameter is currently supported only by Microsoft SQL Server .\n\n    :type EnableIAMDatabaseAuthentication: boolean\n    :param EnableIAMDatabaseAuthentication: True to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts; otherwise false.\n            You can enable IAM database authentication for the following database engines\n            For MySQL 5.6, minor version 5.6.34 or higher\n            For MySQL 5.7, minor version 5.7.16 or higher\n            Default: false\n            \n\n    :rtype: dict\n    :return: {\n        'DBInstance': {\n            'DBInstanceIdentifier': 'string',\n            'DBInstanceClass': 'string',\n            'Engine': 'string',\n            'DBInstanceStatus': 'string',\n            'MasterUsername': 'string',\n            'DBName': 'string',\n            'Endpoint': {\n                'Address': 'string',\n                'Port': 123,\n                'HostedZoneId': 'string'\n            },\n            'AllocatedStorage': 123,\n            'InstanceCreateTime': datetime(2015, 1, 1),\n            'PreferredBackupWindow': 'string',\n            'BackupRetentionPeriod': 123,\n            'DBSecurityGroups': [\n                {\n                    'DBSecurityGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'DBParameterGroups': [\n                {\n                    'DBParameterGroupName': 'string',\n                    'ParameterApplyStatus': 'string'\n                },\n            ],\n            'AvailabilityZone': 'string',\n            'DBSubnetGroup': {\n                'DBSubnetGroupName': 'string',\n                'DBSubnetGroupDescription': 'string',\n                'VpcId': 'string',\n                'SubnetGroupStatus': 'string',\n                'Subnets': [\n                    {\n                        'SubnetIdentifier': 'string',\n                        'SubnetAvailabilityZone': {\n                            'Name': 'string'\n                        },\n                        'SubnetStatus': 'string'\n                    },\n                ],\n                'DBSubnetGroupArn': 'string'\n            },\n            'PreferredMaintenanceWindow': 'string',\n            'PendingModifiedValues': {\n                'DBInstanceClass': 'string',\n                'AllocatedStorage': 123,\n                'MasterUserPassword': 'string',\n                'Port': 123,\n                'BackupRetentionPeriod': 123,\n                'MultiAZ': True|False,\n                'EngineVersion': 'string',\n                'LicenseModel': 'string',\n                'Iops': 123,\n                'DBInstanceIdentifier': 'string',\n                'StorageType': 'string',\n                'CACertificateIdentifier': 'string',\n                'DBSubnetGroupName': 'string'\n            },\n            'LatestRestorableTime': datetime(2015, 1, 1),\n            'MultiAZ': True|False,\n            'EngineVersion': 'string',\n            'AutoMinorVersionUpgrade': True|False,\n            'ReadReplicaSourceDBInstanceIdentifier': 'string',\n            'ReadReplicaDBInstanceIdentifiers': [\n                'string',\n            ],\n            'ReadReplicaDBClusterIdentifiers': [\n                'string',\n            ],\n            'LicenseModel': 'string',\n            'Iops': 123,\n            'OptionGroupMemberships': [\n                {\n                    'OptionGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'CharacterSetName': 'string',\n            'SecondaryAvailabilityZone': 'string',\n            'PubliclyAccessible': True|False,\n            'StatusInfos': [\n                {\n                    'StatusType': 'string',\n                    'Normal': True|False,\n                    'Status': 'string',\n                    'Message': 'string'\n                },\n            ],\n            'StorageType': 'string',\n            'TdeCredentialArn': 'string',\n            'DbInstancePort': 123,\n            'DBClusterIdentifier': 'string',\n            'StorageEncrypted': True|False,\n            'KmsKeyId': 'string',\n            'DbiResourceId': 'string',\n            'CACertificateIdentifier': 'string',\n            'DomainMemberships': [\n                {\n                    'Domain': 'string',\n                    'Status': 'string',\n                    'FQDN': 'string',\n                    'IAMRoleName': 'string'\n                },\n            ],\n            'CopyTagsToSnapshot': True|False,\n            'MonitoringInterval': 123,\n            'EnhancedMonitoringResourceArn': 'string',\n            'MonitoringRoleArn': 'string',\n            'PromotionTier': 123,\n            'DBInstanceArn': 'string',\n            'Timezone': 'string',\n            'IAMDatabaseAuthenticationEnabled': True|False\n        }\n    }\n    \n    \n    :returns: \n    CreateDBInstance\n    DeleteDBInstance\n    ModifyDBInstance\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_db_instance_read_replica(DBInstanceIdentifier=None, SourceDBInstanceIdentifier=None, DBInstanceClass=None, AvailabilityZone=None, Port=None, AutoMinorVersionUpgrade=None, Iops=None, OptionGroupName=None, PubliclyAccessible=None, Tags=None, DBSubnetGroupName=None, StorageType=None, CopyTagsToSnapshot=None, MonitoringInterval=None, MonitoringRoleArn=None, KmsKeyId=None, PreSignedUrl=None, EnableIAMDatabaseAuthentication=None, SourceRegion=None):\n    pass", "response": "This function creates a DB instance read replica for a source DB instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef describe_db_engine_versions(Engine=None, EngineVersion=None, DBParameterGroupFamily=None, Filters=None, MaxRecords=None, Marker=None, DefaultOnly=None, ListSupportedCharacterSets=None, ListSupportedTimezones=None):\n    pass", "response": "This function returns a list of the available DB engines and DB parameter group versions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning information about reserved DB instances for this account, or about a specified reserved DB instance. See also: AWS API Documentation Examples This example lists information for all reserved DB instances for the specified DB instance class, duration, product, offering type, and availability zone settings. Expected Output: :example: response = client.describe_reserved_db_instances( ReservedDBInstanceId='string', ReservedDBInstancesOfferingId='string', DBInstanceClass='string', Duration='string', ProductDescription='string', OfferingType='string', MultiAZ=True|False, Filters=[ { 'Name': 'string', 'Values': [ 'string', ] }, ], MaxRecords=123, Marker='string' ) :type ReservedDBInstanceId: string :param ReservedDBInstanceId: The reserved DB instance identifier filter value. Specify this parameter to show only the reservation that matches the specified reservation ID. :type ReservedDBInstancesOfferingId: string :param ReservedDBInstancesOfferingId: The offering identifier filter value. Specify this parameter to show only purchased reservations matching the specified offering identifier. :type DBInstanceClass: string :param DBInstanceClass: The DB instance class filter value. Specify this parameter to show only those reservations matching the specified DB instances class. :type Duration: string :param Duration: The duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration. Valid Values: 1 | 3 | 31536000 | 94608000 :type ProductDescription: string :param ProductDescription: The product description filter value. Specify this parameter to show only those reservations matching the specified product description. :type OfferingType: string :param OfferingType: The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type. Valid Values: 'Partial Upfront' | 'All Upfront' | 'No Upfront' :type MultiAZ: boolean :param MultiAZ: The Multi-AZ filter value. Specify this parameter to show only those reservations matching the specified Multi-AZ parameter. :type Filters: list :param Filters: This parameter is not currently supported. (dict) --This type is not currently supported. Name (string) -- [REQUIRED]This parameter is not currently supported. Values (list) -- [REQUIRED]This parameter is not currently supported. (string) -- :type MaxRecords: integer :param MaxRecords: The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so that the following results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100. :type Marker: string :param Marker: An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords . :rtype: dict :return: { 'Marker': 'string', 'ReservedDBInstances': [ { 'ReservedDBInstanceId': 'string', 'ReservedDBInstancesOfferingId': 'string', 'DBInstanceClass': 'string', 'StartTime': datetime(2015, 1, 1), 'Duration': 123, 'FixedPrice': 123.0, 'UsagePrice': 123.0, 'CurrencyCode': 'string', 'DBInstanceCount': 123, 'ProductDescription': 'string', 'OfferingType': 'string', 'MultiAZ': True|False, 'State': 'string', 'RecurringCharges': [ { 'RecurringChargeAmount': 123.0, 'RecurringChargeFrequency': 'string' }, ], 'ReservedDBInstanceArn': 'string' }, ] }", "response": "def describe_reserved_db_instances(ReservedDBInstanceId=None, ReservedDBInstancesOfferingId=None, DBInstanceClass=None, Duration=None, ProductDescription=None, OfferingType=None, MultiAZ=None, Filters=None, MaxRecords=None, Marker=None):\n    \"\"\"\n    Returns information about reserved DB instances for this account, or about a specified reserved DB instance.\n    See also: AWS API Documentation\n    \n    Examples\n    This example lists information for all reserved DB instances for the specified DB instance class, duration, product, offering type, and availability zone settings.\n    Expected Output:\n    \n    :example: response = client.describe_reserved_db_instances(\n        ReservedDBInstanceId='string',\n        ReservedDBInstancesOfferingId='string',\n        DBInstanceClass='string',\n        Duration='string',\n        ProductDescription='string',\n        OfferingType='string',\n        MultiAZ=True|False,\n        Filters=[\n            {\n                'Name': 'string',\n                'Values': [\n                    'string',\n                ]\n            },\n        ],\n        MaxRecords=123,\n        Marker='string'\n    )\n    \n    \n    :type ReservedDBInstanceId: string\n    :param ReservedDBInstanceId: The reserved DB instance identifier filter value. Specify this parameter to show only the reservation that matches the specified reservation ID.\n\n    :type ReservedDBInstancesOfferingId: string\n    :param ReservedDBInstancesOfferingId: The offering identifier filter value. Specify this parameter to show only purchased reservations matching the specified offering identifier.\n\n    :type DBInstanceClass: string\n    :param DBInstanceClass: The DB instance class filter value. Specify this parameter to show only those reservations matching the specified DB instances class.\n\n    :type Duration: string\n    :param Duration: The duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration.\n            Valid Values: 1 | 3 | 31536000 | 94608000\n            \n\n    :type ProductDescription: string\n    :param ProductDescription: The product description filter value. Specify this parameter to show only those reservations matching the specified product description.\n\n    :type OfferingType: string\n    :param OfferingType: The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type.\n            Valid Values: 'Partial Upfront' | 'All Upfront' | 'No Upfront'\n            \n\n    :type MultiAZ: boolean\n    :param MultiAZ: The Multi-AZ filter value. Specify this parameter to show only those reservations matching the specified Multi-AZ parameter.\n\n    :type Filters: list\n    :param Filters: This parameter is not currently supported.\n            (dict) --This type is not currently supported.\n            Name (string) -- [REQUIRED]This parameter is not currently supported.\n            Values (list) -- [REQUIRED]This parameter is not currently supported.\n            (string) --\n            \n            \n\n    :type MaxRecords: integer\n    :param MaxRecords: The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so that the following results can be retrieved.\n            Default: 100\n            Constraints: Minimum 20, maximum 100.\n            \n\n    :type Marker: string\n    :param Marker: An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .\n\n    :rtype: dict\n    :return: {\n        'Marker': 'string',\n        'ReservedDBInstances': [\n            {\n                'ReservedDBInstanceId': 'string',\n                'ReservedDBInstancesOfferingId': 'string',\n                'DBInstanceClass': 'string',\n                'StartTime': datetime(2015, 1, 1),\n                'Duration': 123,\n                'FixedPrice': 123.0,\n                'UsagePrice': 123.0,\n                'CurrencyCode': 'string',\n                'DBInstanceCount': 123,\n                'ProductDescription': 'string',\n                'OfferingType': 'string',\n                'MultiAZ': True|False,\n                'State': 'string',\n                'RecurringCharges': [\n                    {\n                        'RecurringChargeAmount': 123.0,\n                        'RecurringChargeFrequency': 'string'\n                    },\n                ],\n                'ReservedDBInstanceArn': 'string'\n            },\n        ]\n    }\n    \n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef describe_reserved_db_instances_offerings(ReservedDBInstancesOfferingId=None, DBInstanceClass=None, Duration=None, ProductDescription=None, OfferingType=None, MultiAZ=None, Filters=None, MaxRecords=None, Marker=None):\n    pass", "response": "This function returns a list of available reserved DB instance offerings for the specified DB instance class duration product description and availability zone settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmodifies a setting for an Amazon Aurora DB cluster. You can change one or more database configuration parameters by specifying these parameters and the new values in the request. For more information on Amazon Aurora, see Aurora on Amazon RDS in the Amazon RDS User Guide. See also: AWS API Documentation Examples This example changes the specified settings for the specified DB cluster. Expected Output: :example: response = client.modify_db_cluster( DBClusterIdentifier='string', NewDBClusterIdentifier='string', ApplyImmediately=True|False, BackupRetentionPeriod=123, DBClusterParameterGroupName='string', VpcSecurityGroupIds=[ 'string', ], Port=123, MasterUserPassword='string', OptionGroupName='string', PreferredBackupWindow='string', PreferredMaintenanceWindow='string', EnableIAMDatabaseAuthentication=True|False ) :type DBClusterIdentifier: string :param DBClusterIdentifier: [REQUIRED] The DB cluster identifier for the cluster being modified. This parameter is not case-sensitive. Constraints: Must be the identifier for an existing DB cluster. Must contain from 1 to 63 alphanumeric characters or hyphens. First character must be a letter. Cannot end with a hyphen or contain two consecutive hyphens. :type NewDBClusterIdentifier: string :param NewDBClusterIdentifier: The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is stored as a lowercase string. Constraints: Must contain from 1 to 63 alphanumeric characters or hyphens First character must be a letter Cannot end with a hyphen or contain two consecutive hyphens Example: my-cluster2 :type ApplyImmediately: boolean :param ApplyImmediately: A value that specifies whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB cluster. If this parameter is set to false , changes to the DB cluster are applied during the next maintenance window. The ApplyImmediately parameter only affects the NewDBClusterIdentifier and MasterUserPassword values. If you set the ApplyImmediately parameter value to false, then changes to the NewDBClusterIdentifier and MasterUserPassword values are applied during the next maintenance window. All other changes are applied immediately, regardless of the value of the ApplyImmediately parameter. Default: false :type BackupRetentionPeriod: integer :param BackupRetentionPeriod: The number of days for which automated backups are retained. You must specify a minimum value of 1. Default: 1 Constraints: Must be a value from 1 to 35 :type DBClusterParameterGroupName: string :param DBClusterParameterGroupName: The name of the DB cluster parameter group to use for the DB cluster. :type VpcSecurityGroupIds: list :param VpcSecurityGroupIds: A list of VPC security groups that the DB cluster will belong to. (string) -- :type Port: integer :param Port: The port number on which the DB cluster accepts connections. Constraints: Value must be 1150-65535 Default: The same port as the original DB cluster. :type MasterUserPassword: string :param MasterUserPassword: The new password for the master database user. This password can contain any printable ASCII character except '/', ''', or '@'. Constraints: Must contain from 8 to 41 characters. :type OptionGroupName: string :param OptionGroupName: A value that indicates that the DB cluster should be associated with the specified option group. Changing this parameter does not result in an outage except in the following case, and the change is applied during the next maintenance window unless the ApplyImmediately parameter is set to true for this request. If the parameter change results in an option group that enables OEM, this change can cause a brief (sub-second) period during which new connections are rejected but existing connections are not interrupted. Permanent options cannot be removed from an option group. The option group cannot be removed from a DB cluster once it is associated with a DB cluster. :type PreferredBackupWindow: string :param PreferredBackupWindow: The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. Default: A 30-minute window selected at random from an 8-hour block of time per region. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide. Constraints: Must be in the format hh24:mi-hh24:mi . Times should be in Universal Coordinated Time (UTC). Must not conflict with the preferred maintenance window. Must be at least 30 minutes. :type PreferredMaintenanceWindow: string :param PreferredMaintenanceWindow: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window. :type EnableIAMDatabaseAuthentication: boolean :param EnableIAMDatabaseAuthentication: A Boolean value that is true to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts, and otherwise false. Default: false :rtype: dict :return: { 'DBCluster': { 'AllocatedStorage': 123, 'AvailabilityZones': [ 'string', ], 'BackupRetentionPeriod': 123, 'CharacterSetName': 'string', 'DatabaseName': 'string', 'DBClusterIdentifier': 'string', 'DBClusterParameterGroup': 'string', 'DBSubnetGroup': 'string', 'Status': 'string', 'PercentProgress': 'string', 'EarliestRestorableTime': datetime(2015, 1, 1), 'Endpoint': 'string', 'ReaderEndpoint': 'string', 'MultiAZ': True|False, 'Engine': 'string', 'EngineVersion': 'string', 'LatestRestorableTime': datetime(2015, 1, 1), 'Port': 123, 'MasterUsername': 'string', 'DBClusterOptionGroupMemberships': [ { 'DBClusterOptionGroupName': 'string', 'Status': 'string' }, ], 'PreferredBackupWindow': 'string', 'PreferredMaintenanceWindow': 'string', 'ReplicationSourceIdentifier': 'string', 'ReadReplicaIdentifiers': [ 'string', ], 'DBClusterMembers': [ { 'DBInstanceIdentifier': 'string', 'IsClusterWriter': True|False, 'DBClusterParameterGroupStatus': 'string', 'PromotionTier': 123 }, ], 'VpcSecurityGroups': [ { 'VpcSecurityGroupId': 'string', 'Status': 'string' }, ], 'HostedZoneId': 'string', 'StorageEncrypted': True|False, 'KmsKeyId': 'string', 'DbClusterResourceId': 'string', 'DBClusterArn': 'string', 'AssociatedRoles': [ { 'RoleArn': 'string', 'Status': 'string' }, ], 'IAMDatabaseAuthenticationEnabled': True|False, 'ClusterCreateTime': datetime(2015, 1, 1) } } :returns: CreateDBCluster DeleteDBCluster FailoverDBCluster ModifyDBCluster RestoreDBClusterFromSnapshot RestoreDBClusterToPointInTime", "response": "def modify_db_cluster(DBClusterIdentifier=None, NewDBClusterIdentifier=None, ApplyImmediately=None, BackupRetentionPeriod=None, DBClusterParameterGroupName=None, VpcSecurityGroupIds=None, Port=None, MasterUserPassword=None, OptionGroupName=None, PreferredBackupWindow=None, PreferredMaintenanceWindow=None, EnableIAMDatabaseAuthentication=None):\n    \"\"\"\n    Modify a setting for an Amazon Aurora DB cluster. You can change one or more database configuration parameters by specifying these parameters and the new values in the request. For more information on Amazon Aurora, see Aurora on Amazon RDS in the Amazon RDS User Guide.\n    See also: AWS API Documentation\n    \n    Examples\n    This example changes the specified settings for the specified DB cluster.\n    Expected Output:\n    \n    :example: response = client.modify_db_cluster(\n        DBClusterIdentifier='string',\n        NewDBClusterIdentifier='string',\n        ApplyImmediately=True|False,\n        BackupRetentionPeriod=123,\n        DBClusterParameterGroupName='string',\n        VpcSecurityGroupIds=[\n            'string',\n        ],\n        Port=123,\n        MasterUserPassword='string',\n        OptionGroupName='string',\n        PreferredBackupWindow='string',\n        PreferredMaintenanceWindow='string',\n        EnableIAMDatabaseAuthentication=True|False\n    )\n    \n    \n    :type DBClusterIdentifier: string\n    :param DBClusterIdentifier: [REQUIRED]\n            The DB cluster identifier for the cluster being modified. This parameter is not case-sensitive.\n            Constraints:\n            Must be the identifier for an existing DB cluster.\n            Must contain from 1 to 63 alphanumeric characters or hyphens.\n            First character must be a letter.\n            Cannot end with a hyphen or contain two consecutive hyphens.\n            \n\n    :type NewDBClusterIdentifier: string\n    :param NewDBClusterIdentifier: The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is stored as a lowercase string.\n            Constraints:\n            Must contain from 1 to 63 alphanumeric characters or hyphens\n            First character must be a letter\n            Cannot end with a hyphen or contain two consecutive hyphens\n            Example: my-cluster2\n            \n\n    :type ApplyImmediately: boolean\n    :param ApplyImmediately: A value that specifies whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB cluster. If this parameter is set to false , changes to the DB cluster are applied during the next maintenance window.\n            The ApplyImmediately parameter only affects the NewDBClusterIdentifier and MasterUserPassword values. If you set the ApplyImmediately parameter value to false, then changes to the NewDBClusterIdentifier and MasterUserPassword values are applied during the next maintenance window. All other changes are applied immediately, regardless of the value of the ApplyImmediately parameter.\n            Default: false\n            \n\n    :type BackupRetentionPeriod: integer\n    :param BackupRetentionPeriod: The number of days for which automated backups are retained. You must specify a minimum value of 1.\n            Default: 1\n            Constraints:\n            Must be a value from 1 to 35\n            \n\n    :type DBClusterParameterGroupName: string\n    :param DBClusterParameterGroupName: The name of the DB cluster parameter group to use for the DB cluster.\n\n    :type VpcSecurityGroupIds: list\n    :param VpcSecurityGroupIds: A list of VPC security groups that the DB cluster will belong to.\n            (string) --\n            \n\n    :type Port: integer\n    :param Port: The port number on which the DB cluster accepts connections.\n            Constraints: Value must be 1150-65535\n            Default: The same port as the original DB cluster.\n            \n\n    :type MasterUserPassword: string\n    :param MasterUserPassword: The new password for the master database user. This password can contain any printable ASCII character except '/', ''', or '@'.\n            Constraints: Must contain from 8 to 41 characters.\n            \n\n    :type OptionGroupName: string\n    :param OptionGroupName: A value that indicates that the DB cluster should be associated with the specified option group. Changing this parameter does not result in an outage except in the following case, and the change is applied during the next maintenance window unless the ApplyImmediately parameter is set to true for this request. If the parameter change results in an option group that enables OEM, this change can cause a brief (sub-second) period during which new connections are rejected but existing connections are not interrupted.\n            Permanent options cannot be removed from an option group. The option group cannot be removed from a DB cluster once it is associated with a DB cluster.\n            \n\n    :type PreferredBackupWindow: string\n    :param PreferredBackupWindow: The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter.\n            Default: A 30-minute window selected at random from an 8-hour block of time per region. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.\n            Constraints:\n            Must be in the format hh24:mi-hh24:mi .\n            Times should be in Universal Coordinated Time (UTC).\n            Must not conflict with the preferred maintenance window.\n            Must be at least 30 minutes.\n            \n\n    :type PreferredMaintenanceWindow: string\n    :param PreferredMaintenanceWindow: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).\n            Format: ddd:hh24:mi-ddd:hh24:mi\n            Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.\n            Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun\n            Constraints: Minimum 30-minute window.\n            \n\n    :type EnableIAMDatabaseAuthentication: boolean\n    :param EnableIAMDatabaseAuthentication: A Boolean value that is true to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts, and otherwise false.\n            Default: false\n            \n\n    :rtype: dict\n    :return: {\n        'DBCluster': {\n            'AllocatedStorage': 123,\n            'AvailabilityZones': [\n                'string',\n            ],\n            'BackupRetentionPeriod': 123,\n            'CharacterSetName': 'string',\n            'DatabaseName': 'string',\n            'DBClusterIdentifier': 'string',\n            'DBClusterParameterGroup': 'string',\n            'DBSubnetGroup': 'string',\n            'Status': 'string',\n            'PercentProgress': 'string',\n            'EarliestRestorableTime': datetime(2015, 1, 1),\n            'Endpoint': 'string',\n            'ReaderEndpoint': 'string',\n            'MultiAZ': True|False,\n            'Engine': 'string',\n            'EngineVersion': 'string',\n            'LatestRestorableTime': datetime(2015, 1, 1),\n            'Port': 123,\n            'MasterUsername': 'string',\n            'DBClusterOptionGroupMemberships': [\n                {\n                    'DBClusterOptionGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'PreferredBackupWindow': 'string',\n            'PreferredMaintenanceWindow': 'string',\n            'ReplicationSourceIdentifier': 'string',\n            'ReadReplicaIdentifiers': [\n                'string',\n            ],\n            'DBClusterMembers': [\n                {\n                    'DBInstanceIdentifier': 'string',\n                    'IsClusterWriter': True|False,\n                    'DBClusterParameterGroupStatus': 'string',\n                    'PromotionTier': 123\n                },\n            ],\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'HostedZoneId': 'string',\n            'StorageEncrypted': True|False,\n            'KmsKeyId': 'string',\n            'DbClusterResourceId': 'string',\n            'DBClusterArn': 'string',\n            'AssociatedRoles': [\n                {\n                    'RoleArn': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'IAMDatabaseAuthenticationEnabled': True|False,\n            'ClusterCreateTime': datetime(2015, 1, 1)\n        }\n    }\n    \n    \n    :returns: \n    CreateDBCluster\n    DeleteDBCluster\n    FailoverDBCluster\n    ModifyDBCluster\n    RestoreDBClusterFromSnapshot\n    RestoreDBClusterToPointInTime\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modify_db_instance(DBInstanceIdentifier=None, AllocatedStorage=None, DBInstanceClass=None, DBSubnetGroupName=None, DBSecurityGroups=None, VpcSecurityGroupIds=None, ApplyImmediately=None, MasterUserPassword=None, DBParameterGroupName=None, BackupRetentionPeriod=None, PreferredBackupWindow=None, PreferredMaintenanceWindow=None, MultiAZ=None, EngineVersion=None, AllowMajorVersionUpgrade=None, AutoMinorVersionUpgrade=None, LicenseModel=None, Iops=None, OptionGroupName=None, NewDBInstanceIdentifier=None, StorageType=None, TdeCredentialArn=None, TdeCredentialPassword=None, CACertificateIdentifier=None, Domain=None, CopyTagsToSnapshot=None, MonitoringInterval=None, DBPortNumber=None, PubliclyAccessible=None, MonitoringRoleArn=None, DomainIAMRoleName=None, PromotionTier=None, EnableIAMDatabaseAuthentication=None):\n    pass", "response": "This function is used to modify the settings for a DB instance. You can specify one or more parameters and the new values in the request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restore_db_cluster_from_s3(AvailabilityZones=None, BackupRetentionPeriod=None, CharacterSetName=None, DatabaseName=None, DBClusterIdentifier=None, DBClusterParameterGroupName=None, VpcSecurityGroupIds=None, DBSubnetGroupName=None, Engine=None, EngineVersion=None, Port=None, MasterUsername=None, MasterUserPassword=None, OptionGroupName=None, PreferredBackupWindow=None, PreferredMaintenanceWindow=None, Tags=None, StorageEncrypted=None, KmsKeyId=None, EnableIAMDatabaseAuthentication=None, SourceEngine=None, SourceEngineVersion=None, S3BucketName=None, S3Prefix=None, S3IngestionRoleArn=None):\n    pass", "response": "This function creates an Amazon Aurora DB cluster from data stored in an Amazon S3 bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef restore_db_cluster_from_snapshot(AvailabilityZones=None, DBClusterIdentifier=None, SnapshotIdentifier=None, Engine=None, EngineVersion=None, Port=None, DBSubnetGroupName=None, DatabaseName=None, OptionGroupName=None, VpcSecurityGroupIds=None, Tags=None, KmsKeyId=None, EnableIAMDatabaseAuthentication=None):\n    pass", "response": "This function restores an Amazon Aurora DB cluster from a DB cluster snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restore_db_cluster_to_point_in_time(DBClusterIdentifier=None, SourceDBClusterIdentifier=None, RestoreToTime=None, UseLatestRestorableTime=None, Port=None, DBSubnetGroupName=None, OptionGroupName=None, VpcSecurityGroupIds=None, Tags=None, KmsKeyId=None, EnableIAMDatabaseAuthentication=None):\n    pass", "response": "This function restores a DB cluster to an arbitrary point in time. Users can restore to any point in time before LatestRestorableTime."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new DB instance from a DB snapshot. The target database is created from the source database restore point with the most of original configuration with the default security group and the default DB parameter group. By default, the new DB instance is created as a single-AZ deployment except when the instance is a SQL Server instance that has an option group that is associated with mirroring; in this case, the instance becomes a mirrored AZ deployment and not a single-AZ deployment. If your intent is to replace your original DB instance with the new, restored DB instance, then rename your original DB instance before you call the RestoreDBInstanceFromDBSnapshot action. RDS does not allow two DB instances with the same name. Once you have renamed your original DB instance with a different identifier, then you can pass the original name of the DB instance as the DBInstanceIdentifier in the call to the RestoreDBInstanceFromDBSnapshot action. The result is that you will replace the original DB instance with the DB instance created from the snapshot. If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier must be the ARN of the shared DB snapshot. See also: AWS API Documentation :example: response = client.restore_db_instance_from_db_snapshot( DBInstanceIdentifier='string', DBSnapshotIdentifier='string', DBInstanceClass='string', Port=123, AvailabilityZone='string', DBSubnetGroupName='string', MultiAZ=True|False, PubliclyAccessible=True|False, AutoMinorVersionUpgrade=True|False, LicenseModel='string', DBName='string', Engine='string', Iops=123, OptionGroupName='string', Tags=[ { 'Key': 'string', 'Value': 'string' }, ], StorageType='string', TdeCredentialArn='string', TdeCredentialPassword='string', Domain='string', CopyTagsToSnapshot=True|False, DomainIAMRoleName='string', EnableIAMDatabaseAuthentication=True|False ) :type DBInstanceIdentifier: string :param DBInstanceIdentifier: [REQUIRED] Name of the DB instance to create from the DB snapshot. This parameter isn't case-sensitive. Constraints: Must contain from 1 to 63 alphanumeric characters or hyphens (1 to 15 for SQL Server) First character must be a letter Cannot end with a hyphen or contain two consecutive hyphens Example: my-snapshot-id :type DBSnapshotIdentifier: string :param DBSnapshotIdentifier: [REQUIRED] The identifier for the DB snapshot to restore from. Constraints: Must contain from 1 to 255 alphanumeric characters or hyphens First character must be a letter Cannot end with a hyphen or contain two consecutive hyphens If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier must be the ARN of the shared DB snapshot. :type DBInstanceClass: string :param DBInstanceClass: The compute and memory capacity of the Amazon RDS DB instance. Valid Values: db.t1.micro | db.m1.small | db.m1.medium | db.m1.large | db.m1.xlarge | db.m2.2xlarge | db.m2.4xlarge | db.m3.medium | db.m3.large | db.m3.xlarge | db.m3.2xlarge | db.m4.large | db.m4.xlarge | db.m4.2xlarge | db.m4.4xlarge | db.m4.10xlarge | db.r3.large | db.r3.xlarge | db.r3.2xlarge | db.r3.4xlarge | db.r3.8xlarge | db.t2.micro | db.t2.small | db.t2.medium | db.t2.large :type Port: integer :param Port: The port number on which the database accepts connections. Default: The same port as the original DB instance Constraints: Value must be 1150-65535 :type AvailabilityZone: string :param AvailabilityZone: The EC2 Availability Zone that the database instance will be created in. Default: A random, system-chosen Availability Zone. Constraint: You cannot specify the AvailabilityZone parameter if the MultiAZ parameter is set to true . Example: us-east-1a :type DBSubnetGroupName: string :param DBSubnetGroupName: The DB subnet group name to use for the new instance. Constraints: Must contain no more than 255 alphanumeric characters, periods, underscores, spaces, or hyphens. Must not be default. Example: mySubnetgroup :type MultiAZ: boolean :param MultiAZ: Specifies if the DB instance is a Multi-AZ deployment. Constraint: You cannot specify the AvailabilityZone parameter if the MultiAZ parameter is set to true . :type PubliclyAccessible: boolean :param PubliclyAccessible: Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether a VPC has been requested or not. The following list shows the default behavior in each case. Default VPC: true VPC: false If no DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be publicly accessible. If a specific DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be private. :type AutoMinorVersionUpgrade: boolean :param AutoMinorVersionUpgrade: Indicates that minor version upgrades will be applied automatically to the DB instance during the maintenance window. :type LicenseModel: string :param LicenseModel: License model information for the restored DB instance. Default: Same as source. Valid values: license-included | bring-your-own-license | general-public-license :type DBName: string :param DBName: The database name for the restored DB instance. Note This parameter doesn't apply to the MySQL, PostgreSQL, or MariaDB engines. :type Engine: string :param Engine: The database engine to use for the new instance. Default: The same as source Constraint: Must be compatible with the engine of the source. You can restore a MariaDB 10.1 DB instance from a MySQL 5.6 snapshot. Valid Values: MySQL | mariadb | oracle-se1 | oracle-se | oracle-ee | sqlserver-ee | sqlserver-se | sqlserver-ex | sqlserver-web | postgres | aurora :type Iops: integer :param Iops: Specifies the amount of provisioned IOPS for the DB instance, expressed in I/O operations per second. If this parameter is not specified, the IOPS value will be taken from the backup. If this parameter is set to 0, the new instance will be converted to a non-PIOPS instance, which will take additional time, though your DB instance will be available for connections before the conversion starts. Constraints: Must be an integer greater than 1000. SQL Server Setting the IOPS value for the SQL Server database engine is not supported. :type OptionGroupName: string :param OptionGroupName: The name of the option group to be used for the restored DB instance. Permanent options, such as the TDE option for Oracle Advanced Security TDE, cannot be removed from an option group, and that option group cannot be removed from a DB instance once it is associated with a DB instance :type Tags: list :param Tags: A list of tags. (dict) --Metadata assigned to an Amazon RDS resource consisting of a key-value pair. Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$'). :type StorageType: string :param StorageType: Specifies the storage type to be associated with the DB instance. Valid values: standard | gp2 | io1 If you specify io1 , you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified; otherwise standard :type TdeCredentialArn: string :param TdeCredentialArn: The ARN from the Key Store with which to associate the instance for TDE encryption. :type TdeCredentialPassword: string :param TdeCredentialPassword: The password for the given ARN from the Key Store in order to access the device. :type Domain: string :param Domain: Specify the Active Directory Domain to restore the instance in. :type CopyTagsToSnapshot: boolean :param CopyTagsToSnapshot: True to copy all tags from the restored DB instance to snapshots of the DB instance; otherwise false. The default is false. :type DomainIAMRoleName: string :param DomainIAMRoleName: Specify the name of the IAM role to be used when making API calls to the Directory Service. :type EnableIAMDatabaseAuthentication: boolean :param EnableIAMDatabaseAuthentication: True to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts; otherwise false. You can enable IAM database authentication for the following database engines For MySQL 5.6, minor version 5.6.34 or higher For MySQL 5.7, minor version 5.7.16 or higher Aurora 5.6 or higher. Default: false :rtype: dict :return: { 'DBInstance': { 'DBInstanceIdentifier': 'string', 'DBInstanceClass': 'string', 'Engine': 'string', 'DBInstanceStatus': 'string', 'MasterUsername': 'string', 'DBName': 'string', 'Endpoint': { 'Address': 'string', 'Port': 123, 'HostedZoneId': 'string' }, 'AllocatedStorage': 123, 'InstanceCreateTime': datetime(2015, 1, 1), 'PreferredBackupWindow': 'string', 'BackupRetentionPeriod': 123, 'DBSecurityGroups': [ { 'DBSecurityGroupName': 'string', 'Status': 'string' }, ], 'VpcSecurityGroups': [ { 'VpcSecurityGroupId': 'string', 'Status': 'string' }, ], 'DBParameterGroups': [ { 'DBParameterGroupName': 'string', 'ParameterApplyStatus': 'string' }, ], 'AvailabilityZone': 'string', 'DBSubnetGroup': { 'DBSubnetGroupName': 'string', 'DBSubnetGroupDescription': 'string', 'VpcId': 'string', 'SubnetGroupStatus': 'string', 'Subnets': [ { 'SubnetIdentifier': 'string', 'SubnetAvailabilityZone': { 'Name': 'string' }, 'SubnetStatus': 'string' }, ], 'DBSubnetGroupArn': 'string' }, 'PreferredMaintenanceWindow': 'string', 'PendingModifiedValues': { 'DBInstanceClass': 'string', 'AllocatedStorage': 123, 'MasterUserPassword': 'string', 'Port': 123, 'BackupRetentionPeriod': 123, 'MultiAZ': True|False, 'EngineVersion': 'string', 'LicenseModel': 'string', 'Iops': 123, 'DBInstanceIdentifier': 'string', 'StorageType': 'string', 'CACertificateIdentifier': 'string', 'DBSubnetGroupName': 'string' }, 'LatestRestorableTime': datetime(2015, 1, 1), 'MultiAZ': True|False, 'EngineVersion': 'string', 'AutoMinorVersionUpgrade': True|False, 'ReadReplicaSourceDBInstanceIdentifier': 'string', 'ReadReplicaDBInstanceIdentifiers': [ 'string', ], 'ReadReplicaDBClusterIdentifiers': [ 'string', ], 'LicenseModel': 'string', 'Iops': 123, 'OptionGroupMemberships': [ { 'OptionGroupName': 'string', 'Status': 'string' }, ], 'CharacterSetName': 'string', 'SecondaryAvailabilityZone': 'string', 'PubliclyAccessible': True|False, 'StatusInfos': [ { 'StatusType': 'string', 'Normal': True|False, 'Status': 'string', 'Message': 'string' }, ], 'StorageType': 'string', 'TdeCredentialArn': 'string', 'DbInstancePort': 123, 'DBClusterIdentifier': 'string', 'StorageEncrypted': True|False, 'KmsKeyId': 'string', 'DbiResourceId': 'string', 'CACertificateIdentifier': 'string', 'DomainMemberships': [ { 'Domain': 'string', 'Status': 'string', 'FQDN': 'string', 'IAMRoleName': 'string' }, ], 'CopyTagsToSnapshot': True|False, 'MonitoringInterval': 123, 'EnhancedMonitoringResourceArn': 'string', 'MonitoringRoleArn': 'string', 'PromotionTier': 123, 'DBInstanceArn': 'string', 'Timezone': 'string', 'IAMDatabaseAuthenticationEnabled': True|False } } :returns: CreateDBInstance DeleteDBInstance ModifyDBInstance", "response": "def restore_db_instance_from_db_snapshot(DBInstanceIdentifier=None, DBSnapshotIdentifier=None, DBInstanceClass=None, Port=None, AvailabilityZone=None, DBSubnetGroupName=None, MultiAZ=None, PubliclyAccessible=None, AutoMinorVersionUpgrade=None, LicenseModel=None, DBName=None, Engine=None, Iops=None, OptionGroupName=None, Tags=None, StorageType=None, TdeCredentialArn=None, TdeCredentialPassword=None, Domain=None, CopyTagsToSnapshot=None, DomainIAMRoleName=None, EnableIAMDatabaseAuthentication=None):\n    \"\"\"\n    Creates a new DB instance from a DB snapshot. The target database is created from the source database restore point with the most of original configuration with the default security group and the default DB parameter group. By default, the new DB instance is created as a single-AZ deployment except when the instance is a SQL Server instance that has an option group that is associated with mirroring; in this case, the instance becomes a mirrored AZ deployment and not a single-AZ deployment.\n    If your intent is to replace your original DB instance with the new, restored DB instance, then rename your original DB instance before you call the RestoreDBInstanceFromDBSnapshot action. RDS does not allow two DB instances with the same name. Once you have renamed your original DB instance with a different identifier, then you can pass the original name of the DB instance as the DBInstanceIdentifier in the call to the RestoreDBInstanceFromDBSnapshot action. The result is that you will replace the original DB instance with the DB instance created from the snapshot.\n    If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier must be the ARN of the shared DB snapshot.\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.restore_db_instance_from_db_snapshot(\n        DBInstanceIdentifier='string',\n        DBSnapshotIdentifier='string',\n        DBInstanceClass='string',\n        Port=123,\n        AvailabilityZone='string',\n        DBSubnetGroupName='string',\n        MultiAZ=True|False,\n        PubliclyAccessible=True|False,\n        AutoMinorVersionUpgrade=True|False,\n        LicenseModel='string',\n        DBName='string',\n        Engine='string',\n        Iops=123,\n        OptionGroupName='string',\n        Tags=[\n            {\n                'Key': 'string',\n                'Value': 'string'\n            },\n        ],\n        StorageType='string',\n        TdeCredentialArn='string',\n        TdeCredentialPassword='string',\n        Domain='string',\n        CopyTagsToSnapshot=True|False,\n        DomainIAMRoleName='string',\n        EnableIAMDatabaseAuthentication=True|False\n    )\n    \n    \n    :type DBInstanceIdentifier: string\n    :param DBInstanceIdentifier: [REQUIRED]\n            Name of the DB instance to create from the DB snapshot. This parameter isn't case-sensitive.\n            Constraints:\n            Must contain from 1 to 63 alphanumeric characters or hyphens (1 to 15 for SQL Server)\n            First character must be a letter\n            Cannot end with a hyphen or contain two consecutive hyphens\n            Example: my-snapshot-id\n            \n\n    :type DBSnapshotIdentifier: string\n    :param DBSnapshotIdentifier: [REQUIRED]\n            The identifier for the DB snapshot to restore from.\n            Constraints:\n            Must contain from 1 to 255 alphanumeric characters or hyphens\n            First character must be a letter\n            Cannot end with a hyphen or contain two consecutive hyphens\n            If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier must be the ARN of the shared DB snapshot.\n            \n\n    :type DBInstanceClass: string\n    :param DBInstanceClass: The compute and memory capacity of the Amazon RDS DB instance.\n            Valid Values: db.t1.micro | db.m1.small | db.m1.medium | db.m1.large | db.m1.xlarge | db.m2.2xlarge | db.m2.4xlarge | db.m3.medium | db.m3.large | db.m3.xlarge | db.m3.2xlarge | db.m4.large | db.m4.xlarge | db.m4.2xlarge | db.m4.4xlarge | db.m4.10xlarge | db.r3.large | db.r3.xlarge | db.r3.2xlarge | db.r3.4xlarge | db.r3.8xlarge | db.t2.micro | db.t2.small | db.t2.medium | db.t2.large\n            \n\n    :type Port: integer\n    :param Port: The port number on which the database accepts connections.\n            Default: The same port as the original DB instance\n            Constraints: Value must be 1150-65535\n            \n\n    :type AvailabilityZone: string\n    :param AvailabilityZone: The EC2 Availability Zone that the database instance will be created in.\n            Default: A random, system-chosen Availability Zone.\n            Constraint: You cannot specify the AvailabilityZone parameter if the MultiAZ parameter is set to true .\n            Example: us-east-1a\n            \n\n    :type DBSubnetGroupName: string\n    :param DBSubnetGroupName: The DB subnet group name to use for the new instance.\n            Constraints: Must contain no more than 255 alphanumeric characters, periods, underscores, spaces, or hyphens. Must not be default.\n            Example: mySubnetgroup\n            \n\n    :type MultiAZ: boolean\n    :param MultiAZ: Specifies if the DB instance is a Multi-AZ deployment.\n            Constraint: You cannot specify the AvailabilityZone parameter if the MultiAZ parameter is set to true .\n            \n\n    :type PubliclyAccessible: boolean\n    :param PubliclyAccessible: Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.\n            Default: The default behavior varies depending on whether a VPC has been requested or not. The following list shows the default behavior in each case.\n            Default VPC: true\n            VPC: false\n            If no DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be publicly accessible. If a specific DB subnet group has been specified as part of the request and the PubliclyAccessible value has not been set, the DB instance will be private.\n            \n\n    :type AutoMinorVersionUpgrade: boolean\n    :param AutoMinorVersionUpgrade: Indicates that minor version upgrades will be applied automatically to the DB instance during the maintenance window.\n\n    :type LicenseModel: string\n    :param LicenseModel: License model information for the restored DB instance.\n            Default: Same as source.\n            Valid values: license-included | bring-your-own-license | general-public-license\n            \n\n    :type DBName: string\n    :param DBName: The database name for the restored DB instance.\n            Note\n            This parameter doesn't apply to the MySQL, PostgreSQL, or MariaDB engines.\n            \n\n    :type Engine: string\n    :param Engine: The database engine to use for the new instance.\n            Default: The same as source\n            Constraint: Must be compatible with the engine of the source. You can restore a MariaDB 10.1 DB instance from a MySQL 5.6 snapshot.\n            Valid Values: MySQL | mariadb | oracle-se1 | oracle-se | oracle-ee | sqlserver-ee | sqlserver-se | sqlserver-ex | sqlserver-web | postgres | aurora\n            \n\n    :type Iops: integer\n    :param Iops: Specifies the amount of provisioned IOPS for the DB instance, expressed in I/O operations per second. If this parameter is not specified, the IOPS value will be taken from the backup. If this parameter is set to 0, the new instance will be converted to a non-PIOPS instance, which will take additional time, though your DB instance will be available for connections before the conversion starts.\n            Constraints: Must be an integer greater than 1000.\n            SQL Server\n            Setting the IOPS value for the SQL Server database engine is not supported.\n            \n\n    :type OptionGroupName: string\n    :param OptionGroupName: The name of the option group to be used for the restored DB instance.\n            Permanent options, such as the TDE option for Oracle Advanced Security TDE, cannot be removed from an option group, and that option group cannot be removed from a DB instance once it is associated with a DB instance\n            \n\n    :type Tags: list\n    :param Tags: A list of tags.\n            (dict) --Metadata assigned to an Amazon RDS resource consisting of a key-value pair.\n            Key (string) --A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            Value (string) --A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with 'aws:' or 'rds:'. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: '^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$').\n            \n            \n\n    :type StorageType: string\n    :param StorageType: Specifies the storage type to be associated with the DB instance.\n            Valid values: standard | gp2 | io1\n            If you specify io1 , you must also include a value for the Iops parameter.\n            Default: io1 if the Iops parameter is specified; otherwise standard\n            \n\n    :type TdeCredentialArn: string\n    :param TdeCredentialArn: The ARN from the Key Store with which to associate the instance for TDE encryption.\n\n    :type TdeCredentialPassword: string\n    :param TdeCredentialPassword: The password for the given ARN from the Key Store in order to access the device.\n\n    :type Domain: string\n    :param Domain: Specify the Active Directory Domain to restore the instance in.\n\n    :type CopyTagsToSnapshot: boolean\n    :param CopyTagsToSnapshot: True to copy all tags from the restored DB instance to snapshots of the DB instance; otherwise false. The default is false.\n\n    :type DomainIAMRoleName: string\n    :param DomainIAMRoleName: Specify the name of the IAM role to be used when making API calls to the Directory Service.\n\n    :type EnableIAMDatabaseAuthentication: boolean\n    :param EnableIAMDatabaseAuthentication: True to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts; otherwise false.\n            You can enable IAM database authentication for the following database engines\n            For MySQL 5.6, minor version 5.6.34 or higher\n            For MySQL 5.7, minor version 5.7.16 or higher\n            Aurora 5.6 or higher.\n            Default: false\n            \n\n    :rtype: dict\n    :return: {\n        'DBInstance': {\n            'DBInstanceIdentifier': 'string',\n            'DBInstanceClass': 'string',\n            'Engine': 'string',\n            'DBInstanceStatus': 'string',\n            'MasterUsername': 'string',\n            'DBName': 'string',\n            'Endpoint': {\n                'Address': 'string',\n                'Port': 123,\n                'HostedZoneId': 'string'\n            },\n            'AllocatedStorage': 123,\n            'InstanceCreateTime': datetime(2015, 1, 1),\n            'PreferredBackupWindow': 'string',\n            'BackupRetentionPeriod': 123,\n            'DBSecurityGroups': [\n                {\n                    'DBSecurityGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'VpcSecurityGroups': [\n                {\n                    'VpcSecurityGroupId': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'DBParameterGroups': [\n                {\n                    'DBParameterGroupName': 'string',\n                    'ParameterApplyStatus': 'string'\n                },\n            ],\n            'AvailabilityZone': 'string',\n            'DBSubnetGroup': {\n                'DBSubnetGroupName': 'string',\n                'DBSubnetGroupDescription': 'string',\n                'VpcId': 'string',\n                'SubnetGroupStatus': 'string',\n                'Subnets': [\n                    {\n                        'SubnetIdentifier': 'string',\n                        'SubnetAvailabilityZone': {\n                            'Name': 'string'\n                        },\n                        'SubnetStatus': 'string'\n                    },\n                ],\n                'DBSubnetGroupArn': 'string'\n            },\n            'PreferredMaintenanceWindow': 'string',\n            'PendingModifiedValues': {\n                'DBInstanceClass': 'string',\n                'AllocatedStorage': 123,\n                'MasterUserPassword': 'string',\n                'Port': 123,\n                'BackupRetentionPeriod': 123,\n                'MultiAZ': True|False,\n                'EngineVersion': 'string',\n                'LicenseModel': 'string',\n                'Iops': 123,\n                'DBInstanceIdentifier': 'string',\n                'StorageType': 'string',\n                'CACertificateIdentifier': 'string',\n                'DBSubnetGroupName': 'string'\n            },\n            'LatestRestorableTime': datetime(2015, 1, 1),\n            'MultiAZ': True|False,\n            'EngineVersion': 'string',\n            'AutoMinorVersionUpgrade': True|False,\n            'ReadReplicaSourceDBInstanceIdentifier': 'string',\n            'ReadReplicaDBInstanceIdentifiers': [\n                'string',\n            ],\n            'ReadReplicaDBClusterIdentifiers': [\n                'string',\n            ],\n            'LicenseModel': 'string',\n            'Iops': 123,\n            'OptionGroupMemberships': [\n                {\n                    'OptionGroupName': 'string',\n                    'Status': 'string'\n                },\n            ],\n            'CharacterSetName': 'string',\n            'SecondaryAvailabilityZone': 'string',\n            'PubliclyAccessible': True|False,\n            'StatusInfos': [\n                {\n                    'StatusType': 'string',\n                    'Normal': True|False,\n                    'Status': 'string',\n                    'Message': 'string'\n                },\n            ],\n            'StorageType': 'string',\n            'TdeCredentialArn': 'string',\n            'DbInstancePort': 123,\n            'DBClusterIdentifier': 'string',\n            'StorageEncrypted': True|False,\n            'KmsKeyId': 'string',\n            'DbiResourceId': 'string',\n            'CACertificateIdentifier': 'string',\n            'DomainMemberships': [\n                {\n                    'Domain': 'string',\n                    'Status': 'string',\n                    'FQDN': 'string',\n                    'IAMRoleName': 'string'\n                },\n            ],\n            'CopyTagsToSnapshot': True|False,\n            'MonitoringInterval': 123,\n            'EnhancedMonitoringResourceArn': 'string',\n            'MonitoringRoleArn': 'string',\n            'PromotionTier': 123,\n            'DBInstanceArn': 'string',\n            'Timezone': 'string',\n            'IAMDatabaseAuthenticationEnabled': True|False\n        }\n    }\n    \n    \n    :returns: \n    CreateDBInstance\n    DeleteDBInstance\n    ModifyDBInstance\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef restore_db_instance_to_point_in_time(SourceDBInstanceIdentifier=None, TargetDBInstanceIdentifier=None, RestoreTime=None, UseLatestRestorableTime=None, DBInstanceClass=None, Port=None, AvailabilityZone=None, DBSubnetGroupName=None, MultiAZ=None, PubliclyAccessible=None, AutoMinorVersionUpgrade=None, LicenseModel=None, DBName=None, Engine=None, Iops=None, OptionGroupName=None, CopyTagsToSnapshot=None, Tags=None, StorageType=None, TdeCredentialArn=None, TdeCredentialPassword=None, Domain=None, DomainIAMRoleName=None, EnableIAMDatabaseAuthentication=None):\n    pass", "response": "This function restores a DB instance to an arbitrary point in time."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate an existing health check.", "response": "def update_health_check(HealthCheckId=None, HealthCheckVersion=None, IPAddress=None, Port=None, ResourcePath=None, FullyQualifiedDomainName=None, SearchString=None, FailureThreshold=None, Inverted=None, HealthThreshold=None, ChildHealthChecks=None, EnableSNI=None, Regions=None, AlarmIdentifier=None, InsufficientDataHealthStatus=None):\n    \"\"\"\n    Updates an existing health check. Note that some values can't be updated.\n    For more information about updating health checks, see Creating, Updating, and Deleting Health Checks in the Amazon Route 53 Developer Guide .\n    See also: AWS API Documentation\n    \n    \n    :example: response = client.update_health_check(\n        HealthCheckId='string',\n        HealthCheckVersion=123,\n        IPAddress='string',\n        Port=123,\n        ResourcePath='string',\n        FullyQualifiedDomainName='string',\n        SearchString='string',\n        FailureThreshold=123,\n        Inverted=True|False,\n        HealthThreshold=123,\n        ChildHealthChecks=[\n            'string',\n        ],\n        EnableSNI=True|False,\n        Regions=[\n            'us-east-1'|'us-west-1'|'us-west-2'|'eu-west-1'|'ap-southeast-1'|'ap-southeast-2'|'ap-northeast-1'|'sa-east-1',\n        ],\n        AlarmIdentifier={\n            'Region': 'us-east-1'|'us-east-2'|'us-west-1'|'us-west-2'|'ca-central-1'|'eu-central-1'|'eu-west-1'|'eu-west-2'|'ap-south-1'|'ap-southeast-1'|'ap-southeast-2'|'ap-northeast-1'|'ap-northeast-2'|'sa-east-1',\n            'Name': 'string'\n        },\n        InsufficientDataHealthStatus='Healthy'|'Unhealthy'|'LastKnownStatus'\n    )\n    \n    \n    :type HealthCheckId: string\n    :param HealthCheckId: [REQUIRED]\n            The ID for the health check for which you want detailed information. When you created the health check, CreateHealthCheck returned the ID in the response, in the HealthCheckId element.\n            \n\n    :type HealthCheckVersion: integer\n    :param HealthCheckVersion: A sequential counter that Amazon Route 53 sets to 1 when you create a health check and increments by 1 each time you update settings for the health check.\n            We recommend that you use GetHealthCheck or ListHealthChecks to get the current value of HealthCheckVersion for the health check that you want to update, and that you include that value in your UpdateHealthCheck request. This prevents Amazon Route 53 from overwriting an intervening update:\n            If the value in the UpdateHealthCheck request matches the value of HealthCheckVersion in the health check, Amazon Route 53 updates the health check with the new settings.\n            If the value of HealthCheckVersion in the health check is greater, the health check was changed after you got the version number. Amazon Route 53 does not update the health check, and it returns a HealthCheckVersionMismatch error.\n            \n\n    :type IPAddress: string\n    :param IPAddress: The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for IPAddress , Amazon Route 53 sends a DNS request to resolve the domain name that you specify in FullyQualifiedDomainName at the interval that you specify in RequestInterval . Using an IP address that is returned by DNS, Amazon Route 53 then checks the health of the endpoint.\n            Use one of the following formats for the value of IPAddress :\n            IPv4 address : four values between 0 and 255, separated by periods (.), for example, 192.0.2.44 .\n            IPv6 address : eight groups of four hexadecimal values, separated by colons (:), for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345 . You can also shorten IPv6 addresses as described in RFC 5952, for example, 2001:db8:85a3::abcd:1:2345 .\n            If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for IPAddress . This ensures that the IP address of your instance never changes. For more information, see the applicable documentation:\n            Linux: Elastic IP Addresses (EIP) in the Amazon EC2 User Guide for Linux Instances\n            Windows: Elastic IP Addresses (EIP) in the Amazon EC2 User Guide for Windows Instances\n            Note\n            If a health check already has a value for IPAddress , you can change the value. However, you can't update an existing health check to add or remove the value of IPAddress .\n            For more information, see UpdateHealthCheckRequest$FullyQualifiedDomainName .\n            Constraints: Amazon Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:\n            RFC 5735, Special Use IPv4 Addresses\n            RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space\n            RFC 5156, Special-Use IPv6 Addresses\n            \n\n    :type Port: integer\n    :param Port: The port on the endpoint on which you want Amazon Route 53 to perform health checks.\n\n    :type ResourcePath: string\n    :param ResourcePath: The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.\n            Specify this value only if you want to change it.\n            \n\n    :type FullyQualifiedDomainName: string\n    :param FullyQualifiedDomainName: Amazon Route 53 behavior depends on whether you specify a value for IPAddress .\n            Note\n            If a health check already has a value for IPAddress , you can change the value. However, you can't update an existing health check to add or remove the value of IPAddress .\n            If you specify a value for IPAddress :\n            Amazon Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of FullyQualifiedDomainName in the Host header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Amazon Route 53 to perform health checks.\n            When Amazon Route 53 checks the health of an endpoint, here is how it constructs the Host header:\n            If you specify a value of 80 for Port and HTTP or HTTP_STR_MATCH for Type , Amazon Route 53 passes the value of FullyQualifiedDomainName to the endpoint in the Host header.\n            If you specify a value of 443 for Port and HTTPS or HTTPS_STR_MATCH for Type , Amazon Route 53 passes the value of FullyQualifiedDomainName to the endpoint in the Host header.\n            If you specify another value for Port and any value except TCP for Type , Amazon Route 53 passes * FullyQualifiedDomainName :Port * to the endpoint in the Host header.\n            If you don't specify a value for FullyQualifiedDomainName , Amazon Route 53 substitutes the value of IPAddress in the Host header in each of the above cases.\n            If you don't specify a value for IPAddress :\n            If you don't specify a value for IPAddress , Amazon Route 53 sends a DNS request to the domain that you specify in FullyQualifiedDomainName at the interval you specify in RequestInterval . Using an IPv4 address that is returned by DNS, Amazon Route 53 then checks the health of the endpoint.\n            Note\n            If you don't specify a value for IPAddress , Amazon Route 53 uses only IPv4 to send health checks to the endpoint. If there's no resource record set with a type of A for the name that you specify for FullyQualifiedDomainName , the health check fails with a 'DNS resolution failed' error.\n            If you want to check the health of weighted, latency, or failover resource record sets and you choose to specify the endpoint only by FullyQualifiedDomainName , we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of FullyQualifiedDomainName , specify the domain name of the server (such as us-east-2-www.example.com ), not the name of the resource record sets (www.example.com).\n            Warning\n            In this configuration, if the value of FullyQualifiedDomainName matches the name of the resource record sets and you then associate the health check with those resource record sets, health check results will be unpredictable.\n            In addition, if the value of Type is HTTP , HTTPS , HTTP_STR_MATCH , or HTTPS_STR_MATCH , Amazon Route 53 passes the value of FullyQualifiedDomainName in the Host header, as it does when you specify a value for IPAddress . If the value of Type is TCP , Amazon Route 53 doesn't pass a Host header.\n            \n\n    :type SearchString: string\n    :param SearchString: If the value of Type is HTTP_STR_MATCH or HTTP_STR_MATCH , the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Amazon Route 53 considers the resource healthy. (You can't change the value of Type when you update a health check.)\n\n    :type FailureThreshold: integer\n    :param FailureThreshold: The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see How Amazon Route 53 Determines Whether an Endpoint Is Healthy in the Amazon Route 53 Developer Guide .\n            If you don't specify a value for FailureThreshold , the default value is three health checks.\n            \n\n    :type Inverted: boolean\n    :param Inverted: Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.\n\n    :type HealthThreshold: integer\n    :param HealthThreshold: The number of child health checks that are associated with a CALCULATED health that Amazon Route 53 must consider healthy for the CALCULATED health check to be considered healthy. To specify the child health checks that you want to associate with a CALCULATED health check, use the ChildHealthChecks and ChildHealthCheck elements.\n            Note the following:\n            If you specify a number greater than the number of child health checks, Amazon Route 53 always considers this health check to be unhealthy.\n            If you specify 0 , Amazon Route 53 always considers this health check to be healthy.\n            \n\n    :type ChildHealthChecks: list\n    :param ChildHealthChecks: A complex type that contains one ChildHealthCheck element for each health check that you want to associate with a CALCULATED health check.\n            (string) --\n            \n\n    :type EnableSNI: boolean\n    :param EnableSNI: Specify whether you want Amazon Route 53 to send the value of FullyQualifiedDomainName to the endpoint in the client_hello message during TLS negotiation. This allows the endpoint to respond to HTTPS health check requests with the applicable SSL/TLS certificate.\n            Some endpoints require that HTTPS requests include the host name in the client_hello message. If you don't enable SNI, the status of the health check will be SSL alert handshake_failure . A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.\n            The SSL/TLS certificate on your endpoint includes a domain name in the Common Name field and possibly several more in the Subject Alternative Names field. One of the domain names in the certificate should match the value that you specify for FullyQualifiedDomainName . If the endpoint responds to the client_hello message with a certificate that does not include the domain name that you specified in FullyQualifiedDomainName , a health checker will retry the handshake. In the second attempt, the health checker will omit FullyQualifiedDomainName from the client_hello message.\n            \n\n    :type Regions: list\n    :param Regions: A complex type that contains one Region element for each region that you want Amazon Route 53 health checkers to check the specified endpoint from.\n            (string) --\n            \n\n    :type AlarmIdentifier: dict\n    :param AlarmIdentifier: A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.\n            Region (string) -- [REQUIRED]A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.\n            For the current list of CloudWatch regions, see Amazon CloudWatch in the AWS Regions and Endpoints chapter of the Amazon Web Services General Reference .\n            Name (string) -- [REQUIRED]The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.\n            \n\n    :type InsufficientDataHealthStatus: string\n    :param InsufficientDataHealthStatus: When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:\n            Healthy : Amazon Route 53 considers the health check to be healthy.\n            Unhealthy : Amazon Route 53 considers the health check to be unhealthy.\n            LastKnownStatus : Amazon Route 53 uses the status of the health check from the last time CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the default status for the health check is healthy.\n            \n\n    :rtype: dict\n    :return: {\n        'HealthCheck': {\n            'Id': 'string',\n            'CallerReference': 'string',\n            'HealthCheckConfig': {\n                'IPAddress': 'string',\n                'Port': 123,\n                'Type': 'HTTP'|'HTTPS'|'HTTP_STR_MATCH'|'HTTPS_STR_MATCH'|'TCP'|'CALCULATED'|'CLOUDWATCH_METRIC',\n                'ResourcePath': 'string',\n                'FullyQualifiedDomainName': 'string',\n                'SearchString': 'string',\n                'RequestInterval': 123,\n                'FailureThreshold': 123,\n                'MeasureLatency': True|False,\n                'Inverted': True|False,\n                'HealthThreshold': 123,\n                'ChildHealthChecks': [\n                    'string',\n                ],\n                'EnableSNI': True|False,\n                'Regions': [\n                    'us-east-1'|'us-west-1'|'us-west-2'|'eu-west-1'|'ap-southeast-1'|'ap-southeast-2'|'ap-northeast-1'|'sa-east-1',\n                ],\n                'AlarmIdentifier': {\n                    'Region': 'us-east-1'|'us-east-2'|'us-west-1'|'us-west-2'|'ca-central-1'|'eu-central-1'|'eu-west-1'|'eu-west-2'|'ap-south-1'|'ap-southeast-1'|'ap-southeast-2'|'ap-northeast-1'|'ap-northeast-2'|'sa-east-1',\n                    'Name': 'string'\n                },\n                'InsufficientDataHealthStatus': 'Healthy'|'Unhealthy'|'LastKnownStatus'\n            },\n            'HealthCheckVersion': 123,\n            'CloudWatchAlarmConfiguration': {\n                'EvaluationPeriods': 123,\n                'Threshold': 123.0,\n                'ComparisonOperator': 'GreaterThanOrEqualToThreshold'|'GreaterThanThreshold'|'LessThanThreshold'|'LessThanOrEqualToThreshold',\n                'Period': 123,\n                'MetricName': 'string',\n                'Namespace': 'string',\n                'Statistic': 'Average'|'Sum'|'SampleCount'|'Maximum'|'Minimum',\n                'Dimensions': [\n                    {\n                        'Name': 'string',\n                        'Value': 'string'\n                    },\n                ]\n            }\n        }\n    }\n    \n    \n    :returns: \n    IPv4 address : four values between 0 and 255, separated by periods (.), for example, 192.0.2.44 .\n    IPv6 address : eight groups of four hexadecimal values, separated by colons (:), for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345 . You can also shorten IPv6 addresses as described in RFC 5952, for example, 2001:db8:85a3::abcd:1:2345 .\n    \n    \"\"\"\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_qualification_type(Name=None, Keywords=None, Description=None, QualificationTypeStatus=None, RetryDelayInSeconds=None, Test=None, AnswerKey=None, TestDurationInSeconds=None, AutoGranted=None, AutoGrantedValue=None):\n    pass", "response": "This function creates a new QualificationType in Amazon Mechanical Turk."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the name of a hash algorithm as described in the OATH specifications to a python object handling the digest algorithm interface PEP - xxx.", "response": "def str2hashalgo(description):\n    '''Convert the name of a hash algorithm as described in the OATH\n       specifications, to a python object handling the digest algorithm\n       interface, PEP-xxx.\n\n       :param description\n           the name of the hash algorithm, example\n       :rtype: a hash algorithm class constructor\n    '''\n    algo = getattr(hashlib, description.lower(), None)\n    if not callable(algo):\n        raise ValueError('Unknown hash algorithm %s' % description)\n    return algo"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting an OCRA crypto function description into a CryptoFunction object", "response": "def str2cryptofunction(crypto_function_description):\n    '''\n       Convert an OCRA crypto function description into a CryptoFunction\n       instance\n\n       :param crypto_function_description:\n       :returns:\n           the CryptoFunction object\n       :rtype: CryptoFunction\n    '''\n    s = crypto_function_description.split('-')\n    if len(s) != 3:\n        raise ValueError('CryptoFunction description must be triplet separated by -')\n    if s[0] != HOTP:\n        raise ValueError('Unknown CryptoFunction kind %s' % s[0])\n    algo = str2hashalgo(s[1])\n    try:\n        truncation_length = int(s[2])\n        if truncation_length < 0 or truncation_length > 10:\n            raise ValueError()\n    except ValueError:\n        raise ValueError('Invalid truncation length %s' % s[2])\n    return CryptoFunction(algo, truncation_length)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes a HOTP value as prescribed by RFC4226 :param key: the HOTP secret key given as an hexadecimal string :param counter: the OTP generation counter :param format: the output format, can be: - hex, for a variable length hexadecimal format, - hex-notrunc, for a 40 characters hexadecimal non-truncated format, - dec4, for a 4 characters decimal format, - dec6, - dec7, or - dec8 it defaults to dec6. :param hash: the hash module (usually from the hashlib package) to use, it defaults to hashlib.sha1. :returns: a string representation of the OTP value (as instructed by the format parameter). Examples: >>> hotp('343434', 2, format='dec6') '791903'", "response": "def hotp(key,counter,format='dec6',hash=hashlib.sha1):\n    '''\n       Compute a HOTP value as prescribed by RFC4226\n\n       :param key:\n           the HOTP secret key given as an hexadecimal string\n       :param counter:\n           the OTP generation counter\n       :param format:\n           the output format, can be:\n              - hex, for a variable length hexadecimal format,\n              - hex-notrunc, for a 40 characters hexadecimal non-truncated format,\n              - dec4, for a 4 characters decimal format,\n              - dec6,\n              - dec7, or\n              - dec8\n           it defaults to dec6.\n       :param hash:\n           the hash module (usually from the hashlib package) to use,\n           it defaults to hashlib.sha1.\n\n       :returns:\n           a string representation of the OTP value (as instructed by the format parameter).\n\n       Examples:\n\n        >>> hotp('343434', 2, format='dec6')\n            '791903'\n    '''\n    bin_hotp = __hotp(key, counter, hash)\n\n    if format == 'dec4':\n        return dec(bin_hotp, 4)\n    elif format == 'dec6':\n        return dec(bin_hotp, 6)\n    elif format == 'dec7':\n        return dec(bin_hotp, 7)\n    elif format == 'dec8':\n        return dec(bin_hotp, 8)\n    elif format == 'hex':\n        return '%x' % truncated_value(bin_hotp)\n    elif format == 'hex-notrunc':\n        return _utils.tohex(bin_hotp)\n    elif format == 'bin':\n        return bin_hotp\n    elif format == 'dec':\n        return str(truncated_value(bin_hotp))\n    else:\n        raise ValueError('unknown format')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate a HOTP value inside a window of HOTP tokens.", "response": "def accept_hotp(key, response, counter, format='dec6', hash=hashlib.sha1,\n        drift=3, backward_drift=0):\n    '''\n       Validate a HOTP value inside a window of\n       [counter-backward_drift:counter+forward_drift]\n\n       :param key:\n           the shared secret\n       :type key:\n           hexadecimal string of even length\n       :param response:\n           the OTP to check\n       :type response:\n           ASCII string\n       :param counter:\n           value of the counter running inside an HOTP token, usually it is\n           just the count of HOTP value accepted so far for a given shared\n           secret; see the specifications of HOTP for more details;\n       :param format:\n           the output format, can be:\n             - hex40, for a 40 characters hexadecimal format,\n             - dec4, for a 4 characters decimal format,\n             - dec6,\n             - dec7, or\n             - dec8\n           it defaults to dec6.\n       :param hash:\n           the hash module (usually from the hashlib package) to use,\n           it defaults to hashlib.sha1.\n       :param drift:\n           how far we can look forward from the current value of the counter\n       :param backward_drift:\n           how far we can look backward from the current counter value to\n           match the response, default to zero as it is usually a bad idea to\n           look backward as the counter is only advanced when a valid value is\n           checked (and so the counter on the token side should have been\n           incremented too)\n\n       :returns:\n           a pair of a boolean and an integer:\n            - first is True if the response is validated and False otherwise,\n            - second is the new value for the counter; it can be more than\n              counter + 1 if the drift window was used; you must store it if\n              the response was validated.\n\n       >>> accept_hotp('343434', '122323', 2, format='dec6')\n           (False, 2)\n\n       >>> hotp('343434', 2, format='dec6')\n           '791903'\n\n       >>> accept_hotp('343434', '791903', 2, format='dec6')\n           (True, 3)\n\n       >>> hotp('343434', 3, format='dec6')\n           '907279'\n\n       >>> accept_hotp('343434', '907279', 2, format='dec6')\n           (True, 4)\n    '''\n\n    for i in range(-backward_drift, drift+1):\n        if _utils.compare_digest(hotp(key, counter+i, format=format, hash=hash), str(response)):\n            return True, counter+i+1\n    return False,counter"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes a TOTP value from a TOTP key and a time.", "response": "def totp(key, format='dec6', period=30, t=None, hash=hashlib.sha1):\n    '''\n       Compute a TOTP value as prescribed by OATH specifications.\n\n       :param key:\n           the TOTP key given as an hexadecimal string\n       :param format:\n           the output format, can be:\n              - hex, for a variable length hexadecimal format,\n              - hex-notrunc, for a 40 characters hexadecimal non-truncated format,\n              - dec4, for a 4 characters decimal format,\n              - dec6,\n              - dec7, or\n              - dec8\n           it defaults to dec6.\n       :param period:\n           a positive integer giving the period between changes of the OTP\n           value, as seconds, it defaults to 30.\n       :param t:\n           a positive integer giving the current time as seconds since EPOCH\n           (1st January 1970 at 00:00 GMT), if None we use time.time(); it\n           defaults to None;\n       :param hash:\n           the hash module (usually from the hashlib package) to use,\n           it defaults to hashlib.sha1.\n\n       :returns:\n           a string representation of the OTP value (as instructed by the format parameter).\n       :type: str\n    '''\n    if t is None:\n        t = int(time.time())\n    else:\n        if isinstance(t, datetime.datetime):\n            t = calendar.timegm(t.utctimetuple())\n        else:\n            t = int(t)\n    T = int(t/period)\n    return hotp(key, T, format=format, hash=hash)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate a TOTP value inside a window of", "response": "def accept_totp(key, response, format='dec6', period=30, t=None,\n        hash=hashlib.sha1, forward_drift=1, backward_drift=1, drift=0):\n    '''\n       Validate a TOTP value inside a window of \n       [drift-bacward_drift:drift+forward_drift] of time steps.\n       Where drift is the drift obtained during the last call to accept_totp.\n\n       :param response:\n           a string representing the OTP to check, its format should correspond\n           to the format parameter (it's not mandatory, it is part of the\n           checks),\n       :param key:\n           the TOTP key given as an hexadecimal string\n       :param format:\n           the output format, can be:\n              - hex40, for a 40 characters hexadecimal format,\n              - dec4, for a 4 characters decimal format,\n              - dec6,\n              - dec7, or\n              - dec8\n           it default to dec6.\n       :param period:\n           a positive integer giving the period between changes of the OTP\n           value, as seconds, it defaults to 30.\n       :param t:\n           a positive integer giving the current time as seconds since EPOCH\n           (1st January 1970 at 00:00 GMT), if None we use time.time(); it\n           defaults to None;\n       :param hash:\n           the hash module (usually from the hashlib package) to use,\n           it defaults to hashlib.sha1.\n       :param forward_drift:\n           how much we accept the client clock to advance, as a number of\n           periods,  i.e. if the period is 30 seconds, a forward_drift of 2,\n           allows at most a clock a drift of 90 seconds;\n\n                   Schema:\n                          .___ Current time\n                          |\n                   0      v       + 30s         +60s              +90s\n                   [ current_period |   period+1  |   period+2     [\n\n           it defaults to 1.\n\n       :param backward_drift:\n           how much we accept the client clock to backstep; it defaults to 1.\n       :param drift:\n           an absolute drift of the local clock to the client clock; use it to\n           keep track of an augmenting drift with a client without augmenting\n           the size of the window given by forward_drift and backward_dript; it\n           defaults to 0, you should usually give as value the last value\n           returned by accept_totp for this client (read further).\n\n       :returns:\n           a pair (v,d) where v is a boolean giving the result, and d the\n           needed drift to validate the value. The drift value should be saved\n           relative to the current client. This saved value SHOULD be used in\n           later calls to accept_totp in order to accept a slowly accumulating\n           drift in the client token clock; on the server side you should use\n           reliable source of time like an NTP server.\n       :rtype: a two element tuple\n    '''\n    if t is None:\n        t = int(time.time())\n    for i in range(max(-divmod(t, period)[0],-backward_drift),forward_drift+1):\n        d = (drift+i) * period\n        if _utils.compare_digest(totp(key, format=format, period=period, hash=hash, t=t+d), response):\n            return True, drift+i\n    return False, 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_b32key(b32_key, state=None):\n    '''Some phone app directly accept a partial b32 encoding, we try to emulate that'''\n    try:\n        lenient_b32decode(b32_key)\n    except TypeError:\n        raise ValueError('invalid base32 value')\n    return GoogleAuthenticator('otpauth://totp/xxx?%s' %\n            urlencode({'secret': b32_key}), state=state)", "response": "Create a new instance of GoogleAuthenticator from a base32 encoded base32 key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(self,\n                 secret,\n                 type='totp',\n                 account='alex',\n                 issuer=None,\n                 algo='sha1',\n                 digits=6,\n                 init_counter=None):\n        \"\"\"\n        https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n        \"\"\"\n\n        args = {}\n        uri = 'otpauth://{0}/{1}?{2}'\n\n        try:\n            # converts the secret to a 16 cars string\n            a = binascii.unhexlify(secret)\n            args[SECRET] = base64.b32encode(a).decode('ascii')\n        except binascii.Error as ex:\n            raise ValueError(str(ex))\n        except Exception as ex:\n            print(ex)\n            raise ValueError('invalid secret format')\n\n        if type not in [TOTP, HOTP]:\n            raise ValueError('type should be totp or hotp, got ',\n                             type)\n        if type != TOTP:\n            args['type'] = type\n\n        if algo not in ['sha1', 'sha256', 'sha512']:\n            raise ValueError('algo should be sha1, sha256 or sha512, got ',\n                             algo)\n        if algo != 'sha1':\n            args['algorithm'] = algo\n\n        if init_counter is not None:\n            if type != HOTP:\n                raise ValueError('type should be hotp when ',\n                                 'setting init_counter')\n\n            if int(init_counter) < 0:\n                raise ValueError('init_counter should be positive')\n            args[COUNTER] = int(init_counter)\n\n        digits = int(digits)\n        if digits != 6 and digits != 8:\n            raise ValueError('digits should be 6 or 8')\n        if digits != 6:\n            args[DIGITS] = digits\n\n        args[PERIOD] = 30\n\n        account = quote(account)\n        if issuer is not None:\n            account = quote(issuer) + ':' + account\n            args[ISSUER] = issuer\n\n        uri = uri.format(type, account, urlencode(args).replace(\"+\", \"%20\"))\n\n        return uri", "response": "Generate a key URI for a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert from onnx operator to mxnet operator.", "response": "def _convert_operator(op_name, attrs, identity_list=None, convert_map=None):\n    \"\"\"Convert from onnx operator to mxnet operator.\n    The converter must specify conversions explicitly for incompatible name, and\n    apply handlers to operator attributes.\n\n    Parameters\n    ----------\n    op_name : str\n        Operator name, such as Convolution, FullyConnected\n    attrs : dict\n        Dict of operator attributes\n    identity_list : list\n        List of operators that don't require conversion\n    convert_map : dict\n        Dict of name : callable, where name is the op's name that\n        require conversion to mxnet, callable are functions which\n        take attrs and return (new_op_name, new_attrs)\n\n    Returns\n    -------\n    (op_name, attrs)\n        Converted (op_name, attrs) for mxnet.\n    \"\"\"\n    identity_list = identity_list if identity_list else _identity_list\n    convert_map = convert_map if convert_map else _convert_map\n    if op_name in identity_list:\n        pass\n    elif op_name in convert_map:\n        op_name, attrs = convert_map[op_name](attrs)\n    else:\n        raise NotImplementedError(\"Operator {} not implemented.\".format(op_name))\n    op = getattr(mx.sym, op_name, None)\n    if not op:\n        raise RuntimeError(\"Unable to map op_name {} to sym\".format(op_name))\n    return op, attrs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_onnx(self, graph):\n        # parse network inputs, aka parameters\n        for init_tensor in graph.initializer:\n            if not init_tensor.name.strip():\n                raise ValueError(\"Tensor's name is required.\")\n            self._params[init_tensor.name] = self._parse_array(init_tensor)\n\n        # converting GraphProto message\n        for i in graph.input:\n            if i.name in self._params:\n                # i is a param instead of input\n                name_param = 'param_{}'.format(self._num_param)\n                self._num_param += 1\n                self._params[name_param] = self._params.pop(i.name)\n                self._nodes[name_param] = mx.sym.Variable(name=name_param,\n                                                          shape=self._params[name_param].shape)\n                self._renames[i.name] = name_param\n            else:\n                name_input = 'input_{}'.format(self._num_input)\n                self._num_input += 1\n                self._nodes[name_input] = mx.sym.Variable(name=name_input)\n                self._renames[i.name] = name_input\n\n        # constructing nodes, nodes are stored as directed acyclic graph\n        # converting NodeProto message\n        for node in graph.node:\n            op_name = node.op_type\n            node_name = node.name.strip()\n            node_name = node_name if node_name else None\n            onnx_attr = self._parse_attr(node.attribute)\n            new_op, mx_attr = _convert_operator(op_name, onnx_attr)\n            inputs = [self._nodes[self._renames.get(i, i)] for i in node.input]\n\n            # some workarounds for inconsistencies in onnx and mxnet conventions.\n            mx_attr = self._fix_bias(new_op, mx_attr, len(inputs))\n            mx_attr = self._fix_channels(new_op, mx_attr, list(node.input))\n            self._fix_bias_shape(node.op_type, node.input, onnx_attr)\n\n            # calling again to get new symbols after some workarounds\n            inputs = [self._nodes[self._renames.get(i, i)] for i in node.input]\n\n            # onnx's Gemm operator also supports broadcasting C input which\n            # mxnet's equivalent linalg_gemm doesn't. So using combination of\n            # transpose and FullyConnected operators.\n            if op_name == 'Gemm':\n                new_op, inputs, mx_attr = self._fix_gemm('FullyConnected', inputs, onnx_attr)\n\n            # onnx slice works on multiple axes whereas mxnet's slice_axis is for single axis\n            if op_name == 'Slice':\n                op = self._fix_slice(inputs, mx_attr)\n            elif op_name == 'AveragePool' and onnx_attr.get('pads') is not None or \\\n                                    op_name == 'MaxPool' and onnx_attr.get('pads') is not None:\n                op = self._fix_pooling(op_name, inputs, onnx_attr)\n            elif op_name == 'Squeeze':\n                op = self._fix_squeeze(inputs, mx_attr)\n            elif op_name == 'Max' or op_name == 'Min':\n                op = self._fix_max_min(op_name, inputs)\n            elif node_name is None:\n                op = new_op(*inputs, **mx_attr)\n            else:\n                op = new_op(name=node_name, *inputs, **mx_attr)\n\n            node_output = self._fix_outputs(op_name, node.output)\n\n            assert len(node_output) == len(op.list_outputs()), (\n                \"Number of output mismatch {} vs {} in {}.\".format(\n                    len(node_output), len(op.list_outputs()), op_name))\n            for k, i in zip(list(node_output), range(len(node_output))):\n                self._nodes[k] = op[i]\n        # now return the outputs\n        out = [self._nodes[i.name] for i in graph.output]\n        if len(out) > 1:\n            out = mx.sym.Group(out)\n        else:\n            out = out[0]\n        return out, self._params", "response": "Construct a symbol from onnx graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _fix_slice(self, inputs, new_attr):\n        begin = new_attr.get('begin')\n        end = new_attr.get('end')\n        axes = new_attr.get('axis', tuple(range(len(begin))))\n        slice_op = mx.sym.slice_axis(inputs[0], axis=axes[0], begin=begin[0], end=end[0])\n        if len(axes) > 1:\n            for i, axis in enumerate(axes):\n                slice_op = mx.sym.slice_axis(slice_op, axis=axis, begin=begin[i], end=end[i])\n        return slice_op", "response": "onnx slice provides slicing on multiple axes from mxnet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing FullyConnected operator in place of linalg_gemm to perform same operation", "response": "def _fix_gemm(self, op_name, inputs, old_attr):\n        \"\"\"Using FullyConnected operator in place of linalg_gemm to perform same operation\"\"\"\n        op = getattr(mx.sym, op_name, None)\n        alpha = float(old_attr.get('alpha', 1.0))\n        beta = float(old_attr.get('beta', 1.0))\n        transA = int(old_attr.get('transA', 0))\n        transB = int(old_attr.get('transB', 0))\n        if transA:\n            inputs[0] = mx.sym.transpose(inputs[0], axes=(1, 0))\n        if not transB:\n            inputs[1] = mx.sym.transpose(inputs[1], axes=(1, 0))\n        new_inputs = [alpha*inputs[0], inputs[1], beta*inputs[2]]\n        new_attr = {'num_hidden' : self._params[inputs[2].name].shape[0]}\n        return op, new_inputs, new_attr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_array(self, tensor_proto):\n        try:\n            from onnx.numpy_helper import to_array\n        except ImportError as e:\n            raise ImportError(\"Unable to import onnx which is required {}\".format(e))\n        np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims))\n        return mx.nd.array(np_array)", "response": "Grab data in TensorProto and convert to numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a list of AttributeProto to a dict with names as keys.", "response": "def _parse_attr(self, attr_proto):\n        \"\"\"Convert a list of AttributeProto to a dict, with names as keys.\"\"\"\n        attrs = {}\n        for a in attr_proto:\n            for f in ['f', 'i', 's']:\n                if a.HasField(f):\n                    attrs[a.name] = getattr(a, f)\n            for f in ['floats', 'ints', 'strings']:\n                if list(getattr(a, f)):\n                    assert a.name not in attrs, \"Only one type of attr is allowed\"\n                    attrs[a.name] = tuple(getattr(a, f))\n            for f in ['t', 'g']:\n                if a.HasField(f):\n                    attrs[a.name] = getattr(a, f)\n            for f in ['tensors', 'graphs']:\n                if list(getattr(a, f)):\n                    raise NotImplementedError(\"Filed {} is not supported in mxnet.\".format(f))\n            if a.name not in attrs:\n                raise ValueError(\"Cannot parse attribute: \\n{}\\n.\".format(a))\n        return attrs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fix_outputs(self, op, outputs):\n        if op == 'Dropout':\n            assert len(outputs) == 2, \"ONNX have two outputs for dropout layer.\"\n            outputs = outputs[:-1]\n        return outputs", "response": "A workaround to handle dropout or similar operator that have more than one out\n        in ONNX."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _fix_bias_shape(self, op_name, inputs, attrs):\n        if (op_name == 'Add' or op_name == 'Mul') and (int(len(self._params)) > 0) and \\\n                ('broadcast' in attrs and attrs['broadcast'] == 1):\n            assert len(list(inputs)) == 2\n            bias_name = self._renames.get(inputs[1], inputs[1])\n            bias = self._params[bias_name]\n            assert len(bias.shape) == 1\n            # reshape to (1, n)\n            bias = mx.nd.array(bias.asnumpy().reshape((1, -1, 1, 1)))\n            # broadcast_add expects shape with sym.variable\n            self._nodes[bias_name] = mx.sym.Variable(name=bias_name, shape=bias.shape)\n            self._params[bias_name] = bias", "response": "A workaround to reshape bias term to 1 num_channel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _fix_channels(self, op, attrs, inputs):\n        if op not in [mx.sym.Convolution, mx.sym.Deconvolution, mx.sym.FullyConnected]:\n            return attrs\n        weight_name = self._renames[inputs[1]]\n        if not weight_name in self._params:\n            raise ValueError(\"Unable to get channels/units attr from onnx graph.\")\n        else:\n            wshape = self._params[weight_name].shape\n            assert len(wshape) >= 2, \"Weights shape is invalid: {}\".format(wshape)\n\n            if op in [mx.sym.FullyConnected]:\n                attrs['num_hidden'] = wshape[0]\n            else:\n                if op == mx.sym.Convolution:\n                    # Weight shape for Conv and FC: (M x C x kH x kW) : M is number of\n                    # feature maps/hidden  and C is number of channels\n                    attrs['num_filter'] = wshape[0]\n                elif op == mx.sym.Deconvolution:\n                    # Weight shape for DeConv : (C x M x kH x kW) : M is number of\n                    # feature maps/filters and C is number of channels\n                    attrs['num_filter'] = wshape[1]\n        return attrs", "response": "A workaround for getting channels or units since onnx don t provide them. We check the shape of weights and set the number of channels and units."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning model inference and return the result", "response": "def run(self, inputs, **kwargs):\n        \"\"\"Run model inference and return the result\n\n        Parameters\n        ----------\n        inputs : numpy array\n            input to run a layer on\n\n        Returns\n        -------\n        params : numpy array\n            result obtained after running the inference on mxnet\n        \"\"\"\n        input_data = np.asarray(inputs[0], dtype='f')\n\n        # create module, passing cpu context\n        if self.device == 'CPU':\n            ctx = mx.cpu()\n        else:\n            raise NotImplementedError(\"Only CPU context is supported for now\")\n\n        mod = mx.mod.Module(symbol=self.symbol, data_names=['input_0'], context=ctx,\n                            label_names=None)\n        mod.bind(for_training=False, data_shapes=[('input_0', input_data.shape)],\n                 label_shapes=None)\n        mod.set_params(arg_params=self.params, aux_params=None)\n\n        # run inference\n        batch = namedtuple('Batch', ['data'])\n\n        mod.forward(batch([mx.nd.array(input_data)]))\n        result = mod.get_outputs()[0].asnumpy()\n        return [result]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap for getting required attributes.", "response": "def _required_attr(self, attr, key):\n        \"\"\"Wrapper for getting required attributes.\"\"\"\n        assert isinstance(attr, dict)\n        if key not in attr:\n            raise AttributeError(\"Required attribute {} not found.\".format(key))\n        return attr[key]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_graph(node, inputs):\n        initializer = []\n        tensor_input_info = []\n        tensor_output_info = []\n\n        # Adding input tensor info.\n        for index in range(len(node.input)):\n            tensor_input_info.append(\n                helper.make_tensor_value_info(str(node.input[index]), TensorProto.FLOAT, [1]))\n\n            # Creating an initializer for Weight params.\n            # Assumes that weight params is named as 'W'.\n            # TODO: Handle multiple weight params.\n            # TODO: Add for \"bias\" if needed\n            if node.input[index] == 'W':\n                dim = inputs[index].shape\n                param_tensor = helper.make_tensor(\n                    name=node.input[index],\n                    data_type=TensorProto.FLOAT,\n                    dims=dim,\n                    vals=inputs[index].flatten())\n\n                initializer.append(param_tensor)\n\n        # Adding output tensor info.\n        for index in range(len(node.output)):\n            tensor_output_info.append(\n                helper.make_tensor_value_info(str(node.output[index]), TensorProto.FLOAT, [1]))\n\n        # creating graph proto object.\n        graph_proto = helper.make_graph(\n            [node],\n            \"test\",\n            tensor_input_info,\n            tensor_output_info,\n            initializer=initializer)\n\n        return graph_proto", "response": "Creates ONNX GraphProto from node and inputs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_node(cls, node, inputs, device='CPU'):  # pylint: disable=arguments-differ\n        graph = GraphProto()\n        sym, _ = graph.from_onnx(MXNetBackend.make_graph(node, inputs))\n        data_names = [i for i in sym.get_internals().list_inputs()]\n        data_shapes = []\n        reduce_op_types = set(['ReduceMin', 'ReduceMax', 'ReduceMean',\n                               'ReduceProd', 'ReduceSum', 'Slice', 'Pad',\n                               'Squeeze', 'Upsample', 'Reshape', 'Conv', 'ConvTranspose'])\n\n        # Adding extra dimension of batch_size 1 if the batch_size is different for multiple inputs.\n        for idx, input_name in enumerate(data_names):\n            batch_size = 1\n            if len(inputs[idx].shape) < 4 and len(inputs) > 1 and \\\n                            len(set(x.shape[0] for x in inputs)) != 1:\n                tuples = ((batch_size,), inputs[idx].shape)\n                new_shape = sum(tuples, ())\n                data_shapes.append((input_name, new_shape))\n            else:\n                data_shapes.append((input_name, inputs[idx].shape))\n\n        # create module, passing cpu context\n        if device == 'CPU':\n            ctx = mx.cpu()\n        else:\n            raise NotImplementedError(\"Only CPU context is supported for now\")\n\n        # create a module\n        mod = mx.mod.Module(symbol=sym, data_names=data_names, context=ctx, label_names=None)\n        mod.bind(for_training=False, data_shapes=data_shapes, label_shapes=None)\n\n        # initializing parameters for calculating result of each individual node\n        mod.init_params()\n\n        data_forward = []\n        for idx, input_name in enumerate(data_names):\n            # slice and pad operator tests needs 1 less dimension in forward pass\n            # otherwise it will throw an error.\n            # for squeeze operator, need to retain shape of input as provided\n            val = inputs[idx]\n            if node.op_type in reduce_op_types:\n                data_forward.append(mx.nd.array(val))\n            else:\n                data_forward.append(mx.nd.array([val]))\n\n        mod.forward(mx.io.DataBatch(data_forward))\n        result = mod.get_outputs()[0].asnumpy()\n        if node.op_type in reduce_op_types:\n            return [result]\n        return result", "response": "This method runs an individual node inference on onnx test infrastructure and returns the result to onnx test infrastructure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare MXNetBackendRep object for running end to end model", "response": "def prepare(cls, model, device='CPU', **kwargs):\n        \"\"\"For running end to end model(used for onnx test backend)\n\n        Parameters\n        ----------\n        model  : onnx ModelProto object\n            loaded onnx graph\n        device : 'CPU'\n            specifying device to run test on\n        kwargs :\n            other arguments\n\n        Returns\n        -------\n        MXNetBackendRep : object\n            Returns object of MXNetBackendRep class which will be in turn\n            used to run inference on the input model and return the result for comparison.\n        \"\"\"\n        graph = GraphProto()\n        sym, params = graph.from_onnx(model.graph)\n        return MXNetBackendRep(sym, params, device)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _revert_caffe2_pad(attr):\n    if len(attr) == 4:\n        attr = attr[:2]\n    elif len(attr) == 2:\n        pass\n    else:\n        raise ValueError(\"Invalid caffe2 type padding: {}\".format(attr))\n    return attr", "response": "Removes extra padding from Caffe2."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _pad_sequence_fix(attr, kernelDim=None):\n    new_attr = ()\n    if len(attr) % 2 == 0:\n        for index in range(int(len(attr) / 2)):\n            new_attr = new_attr + attr[index::int(len(attr) / 2)]\n        # Making sure pad values  are in the attr for all axes.\n        if kernelDim is not None:\n            while len(new_attr) < kernelDim*2:\n                new_attr = new_attr + (0, 0)\n\n    return new_attr", "response": "Fix padding sequence to match with mxnet s pad_width\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_model(model_file):\n    graph = GraphProto()\n\n    # loads model file and returns ONNX protobuf object\n    model_proto = onnx.load(model_file)\n    sym, params = graph.from_onnx(model_proto.graph)\n    return sym, params", "response": "Imports the supplied ONNX model file into MXNet symbol and parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encrypt_file(self, inpath, force_nocompress=False, force_compress=False, armored=False, checksum=False):\n        if armored:\n            if force_compress:\n                command_stub = self.command_maxcompress_armored\n            elif force_nocompress:\n                command_stub = self.command_nocompress_armored\n            else:\n                if self._is_compress_filetype(inpath):\n                    command_stub = self.command_default_armored\n                else:\n                    command_stub = self.command_nocompress_armored\n        else:\n            if force_compress:\n                command_stub = self.command_maxcompress\n            elif force_nocompress:\n                command_stub = self.command_nocompress\n            else:\n                if self._is_compress_filetype(inpath):\n                    command_stub = self.command_default\n                else:\n                    command_stub = self.command_nocompress\n\n        encrypted_outpath = self._create_outfilepath(inpath)\n        system_command = command_stub + encrypted_outpath + \" --passphrase \" + quote(self.passphrase) + \" --symmetric \" + quote(inpath)\n\n        try:\n            response = muterun(system_command)\n            # check returned status code\n            if response.exitcode == 0:\n                stdout(encrypted_outpath + \" was generated from \" + inpath)\n                if checksum:  # add a SHA256 hash digest of the encrypted file - requested by user --hash flag in command\n                    from crypto.library import hash\n                    encrypted_file_hash = hash.generate_hash(encrypted_outpath)\n                    if len(encrypted_file_hash) == 64:\n                        stdout(\"SHA256 hash digest for \" + encrypted_outpath + \" :\")\n                        stdout(encrypted_file_hash)\n                    else:\n                        stdout(\"Unable to generate a SHA256 hash digest for the file \" + encrypted_outpath)\n            else:\n                stderr(response.stderr, 0)\n                stderr(\"Encryption failed\")\n                sys.exit(1)\n        except Exception as e:\n            stderr(\"There was a problem with the execution of gpg. Encryption failed. Error: [\" + str(e) + \"]\")\n            sys.exit(1)", "response": "public method for single file encryption with optional compression ASCII armored formatting and file hash digest generation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _is_common_binary(self, inpath):\n        # make local variables for the available char numbers in the suffix types to be tested\n        two_suffix = inpath[-3:]\n        three_suffix = inpath[-4:]\n        four_suffix = inpath[-5:]\n        \n        # test for inclusion in the instance variable common_binaries (defined in __init__)\n        if two_suffix in self.common_binaries:\n            return True\n        elif three_suffix in self.common_binaries:\n            return True\n        elif four_suffix in self.common_binaries:\n            return True\n        else:\n            return False", "response": "private method to compare file path mime type to common binary file types"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef knn_impute_few_observed(\n        X, missing_mask, k, verbose=False, print_interval=100):\n    \"\"\"\n    Seems to be the fastest kNN implementation. Pre-sorts each rows neighbors\n    and then filters these sorted indices using each columns mask of\n    observed values.\n\n    Important detail: If k observed values are not available then uses fewer\n    than k neighboring rows.\n\n    Parameters\n    ----------\n    X : np.ndarray\n        Matrix to fill of shape (n_samples, n_features)\n\n    missing_mask : np.ndarray\n        Boolean array of same shape as X\n\n    k : int\n\n    verbose : bool\n    \"\"\"\n    start_t = time.time()\n    n_rows, n_cols = X.shape\n    # put the missing mask in column major order since it's accessed\n    # one column at a time\n    missing_mask_column_major = np.asarray(missing_mask, order=\"F\")\n    observed_mask_column_major = ~missing_mask_column_major\n    X_column_major = X.copy(order=\"F\")\n    X_row_major, D, effective_infinity = \\\n        knn_initialize(X, missing_mask, verbose=verbose)\n    # get rid of infinities, replace them with a very large number\n    D_sorted = np.argsort(D, axis=1)\n    inv_D = 1.0 / D\n    D_valid_mask = D < effective_infinity\n    valid_distances_per_row = D_valid_mask.sum(axis=1)\n\n    # trim the number of other rows we consider to exclude those\n    # with infinite distances\n    D_sorted = [\n        D_sorted[i, :count]\n        for i, count in enumerate(valid_distances_per_row)\n    ]\n\n    dot = np.dot\n    for i in range(n_rows):\n        missing_row = missing_mask[i, :]\n        missing_indices = np.where(missing_row)[0]\n        row_weights = inv_D[i, :]\n        if verbose and i % print_interval == 0:\n            print(\n                \"Imputing row %d/%d with %d missing, elapsed time: %0.3f\" % (\n                    i + 1,\n                    n_rows,\n                    len(missing_indices),\n                    time.time() - start_t))\n        candidate_neighbor_indices = D_sorted[i]\n\n        for j in missing_indices:\n            observed = observed_mask_column_major[:, j]\n            sorted_observed = observed[candidate_neighbor_indices]\n            observed_neighbor_indices = candidate_neighbor_indices[sorted_observed]\n            k_nearest_indices = observed_neighbor_indices[:k]\n            weights = row_weights[k_nearest_indices]\n            weight_sum = weights.sum()\n            if weight_sum > 0:\n                column = X_column_major[:, j]\n                values = column[k_nearest_indices]\n                X_row_major[i, j] = dot(values, weights) / weight_sum\n    return X_row_major", "response": "This function is used to compute the kNN implementation for a new set of observed values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the knn matrix for a given set of entries.", "response": "def knn_initialize(\n        X,\n        missing_mask,\n        verbose=False,\n        min_dist=1e-6,\n        max_dist_multiplier=1e6):\n    \"\"\"\n    Fill X with NaN values if necessary, construct the n_samples x n_samples\n    distance matrix and set the self-distance of each row to infinity.\n\n    Returns contents of X laid out in row-major, the distance matrix,\n    and an \"effective infinity\" which is larger than any entry of the\n    distance matrix.\n    \"\"\"\n    X_row_major = X.copy(\"C\")\n    if missing_mask.sum() != np.isnan(X_row_major).sum():\n        # if the missing values have already been zero-filled need\n        # to put NaN's back in the data matrix for the distances function\n        X_row_major[missing_mask] = np.nan\n    D = all_pairs_normalized_distances(X_row_major)\n    D_finite_flat = D[np.isfinite(D)]\n    if len(D_finite_flat) > 0:\n        max_dist = max_dist_multiplier * max(1, D_finite_flat.max())\n    else:\n        max_dist = max_dist_multiplier\n    # set diagonal of distance matrix to a large value since we don't want\n    # points considering themselves as neighbors\n    np.fill_diagonal(D, max_dist)\n    D[D < min_dist] = min_dist  # prevents 0s\n    D[D > max_dist] = max_dist  # prevents infinities\n    return X_row_major, D, max_dist"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef knn_impute_optimistic(\n        X,\n        missing_mask,\n        k,\n        verbose=False,\n        print_interval=100):\n    \"\"\"\n    Fill in the given incomplete matrix using k-nearest neighbor imputation.\n\n    This version assumes that most of the time the same neighbors will be\n    used so first performs the weighted average of a row's k-nearest neighbors\n    and checks afterward whether it was valid (due to possible missing values).\n\n    Has been observed to be a lot faster for 1/4 missing images matrix\n    with 1000 rows and ~9000 columns.\n\n    Parameters\n    ----------\n    X : np.ndarray\n        Matrix to fill of shape (n_samples, n_features)\n\n    missing_mask : np.ndarray\n        Boolean array of same shape as X\n\n    k : int\n\n    verbose : bool\n\n    Modifies X by replacing its missing values with weighted averages of\n    similar rows. Returns the modified X.\n    \"\"\"\n    start_t = time.time()\n    n_rows, n_cols = X.shape\n    X_row_major, D, _ = knn_initialize(X, missing_mask, verbose=verbose)\n    D_sorted_indices = np.argsort(D, axis=1)\n    X_column_major = X_row_major.copy(order=\"F\")\n\n    dot = np.dot\n\n    # preallocate array to prevent repeated creation in the following loops\n    neighbor_weights = np.ones(k, dtype=X.dtype)\n\n    missing_mask_column_major = np.asarray(missing_mask, order=\"F\")\n    observed_mask_column_major = ~missing_mask_column_major\n\n    for i in range(n_rows):\n        missing_columns = np.where(missing_mask[i])[0]\n        if verbose and i % print_interval == 0:\n            print(\n                \"Imputing row %d/%d with %d missing, elapsed time: %0.3f\" % (\n                    i + 1,\n                    n_rows,\n                    len(missing_columns),\n                    time.time() - start_t))\n        n_missing_columns = len(missing_columns)\n        if n_missing_columns == 0:\n            continue\n\n        row_distances = D[i, :]\n        neighbor_indices = D_sorted_indices[i, :]\n        X_missing_columns = X_column_major[:, missing_columns]\n\n        # precompute these for the fast path where the k nearest neighbors\n        # are not missing the feature value we're currently trying to impute\n        k_nearest_indices = neighbor_indices[:k]\n        np.divide(1.0, row_distances[k_nearest_indices], out=neighbor_weights)\n        # optimistically impute all the columns from the k nearest neighbors\n        # we'll have to back-track for some of the columns for which\n        # one of the neighbors did not have a value\n        X_knn = X_missing_columns[k_nearest_indices, :]\n        weighted_average_of_neighboring_rows = dot(\n            X_knn.T,\n            neighbor_weights)\n        sum_weights = neighbor_weights.sum()\n        weighted_average_of_neighboring_rows /= sum_weights\n        imputed_values = weighted_average_of_neighboring_rows\n\n        observed_mask_missing_columns = observed_mask_column_major[:, missing_columns]\n        observed_mask_missing_columns_sorted = observed_mask_missing_columns[\n            neighbor_indices, :]\n\n        # We can determine the maximum number of other rows that must be\n        # inspected across all features missing for this row by\n        # looking at the column-wise running sums of the observed feature\n        # matrix.\n        observed_cumulative_sum = observed_mask_missing_columns_sorted.cumsum(axis=0)\n        sufficient_rows = (observed_cumulative_sum == k)\n        n_rows_needed = sufficient_rows.argmax(axis=0) + 1\n        max_rows_needed = n_rows_needed.max()\n\n        if max_rows_needed == k:\n            # if we never needed more than k rows then we're done after the\n            # optimistic averaging above, so go on to the next sample\n            X[i, missing_columns] = imputed_values\n            continue\n\n        # truncate all the sorted arrays to only include the necessary\n        # number of rows (should significantly speed up the \"slow\" path)\n        necessary_indices = neighbor_indices[:max_rows_needed]\n        d_sorted = row_distances[necessary_indices]\n        X_missing_columns_sorted = X_missing_columns[necessary_indices, :]\n        observed_mask_missing_columns_sorted = observed_mask_missing_columns_sorted[\n            :max_rows_needed, :]\n\n        for missing_column_idx in range(n_missing_columns):\n            # since all the arrays we're looking into have already been\n            # sliced out at the missing features, we need to address these\n            # features from 0..n_missing using missing_idx rather than j\n            if n_rows_needed[missing_column_idx] == k:\n                assert np.isfinite(imputed_values[missing_column_idx]), \\\n                    \"Expected finite imputed value #%d (column #%d for row %d)\" % (\n                        missing_column_idx,\n                        missing_columns[missing_column_idx],\n                        i)\n                continue\n            row_mask = observed_mask_missing_columns_sorted[:, missing_column_idx]\n            sorted_column_values = X_missing_columns_sorted[:, missing_column_idx]\n            neighbor_distances = d_sorted[row_mask][:k]\n\n            # may not have enough values in a column for all k neighbors\n            k_or_less = len(neighbor_distances)\n            usable_weights = neighbor_weights[:k_or_less]\n            np.divide(\n                1.0,\n                neighbor_distances, out=usable_weights)\n            neighbor_values = sorted_column_values[row_mask][:k_or_less]\n\n            imputed_values[missing_column_idx] = (\n                dot(neighbor_values, usable_weights) / usable_weights.sum())\n\n        X[i, missing_columns] = imputed_values\n    return X", "response": "This function performs an optimized k - nearest neighbor imputation on the given incomplete matrix X."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_pairs_normalized_distances(X):\n    n_rows, n_cols = X.shape\n\n    # matrix of mean squared difference between between samples\n    D = np.ones((n_rows, n_rows), dtype=\"float32\", order=\"C\") * np.inf\n\n    # we can cheaply determine the number of columns that two rows share\n    # by taking the dot product between their finite masks\n    observed_elements = np.isfinite(X).astype(int)\n    n_shared_features_for_pairs_of_rows = np.dot(\n        observed_elements,\n        observed_elements.T)\n    no_overlapping_features_rows = n_shared_features_for_pairs_of_rows == 0\n    number_incomparable_rows = no_overlapping_features_rows.sum(axis=1)\n    row_overlaps_every_other_row = (number_incomparable_rows == 0)\n    row_overlaps_no_other_rows = number_incomparable_rows == n_rows\n    valid_rows_mask = ~row_overlaps_no_other_rows\n    valid_row_indices = np.where(valid_rows_mask)[0]\n\n    # preallocate all the arrays that we would otherwise create in the\n    # following loop and pass them as \"out\" parameters to NumPy ufuncs\n    diffs = np.zeros_like(X)\n    missing_differences = np.zeros_like(diffs, dtype=bool)\n    valid_rows = np.zeros(n_rows, dtype=bool)\n    ssd = np.zeros(n_rows, dtype=X.dtype)\n\n    for i in valid_row_indices:\n        x = X[i, :]\n        np.subtract(X, x.reshape((1, n_cols)), out=diffs)\n        np.isnan(diffs, out=missing_differences)\n\n        # zero out all NaN's\n        diffs[missing_differences] = 0\n\n        # square each difference\n        diffs **= 2\n\n        observed_counts_per_row = n_shared_features_for_pairs_of_rows[i]\n\n        if row_overlaps_every_other_row[i]:\n            # add up all the non-missing squared differences\n            diffs.sum(axis=1, out=D[i, :])\n            D[i, :] /= observed_counts_per_row\n        else:\n            np.logical_not(no_overlapping_features_rows[i], out=valid_rows)\n\n            # add up all the non-missing squared differences\n            diffs.sum(axis=1, out=ssd)\n            ssd[valid_rows] /= observed_counts_per_row[valid_rows]\n            D[i, valid_rows] = ssd[valid_rows]\n    return D", "response": "This function calculates all pairs of normalized distances over the incomplete data X."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_pairs_normalized_distances_reference(X):\n    n_samples, n_cols = X.shape\n    # matrix of mean squared difference between between samples\n    D = np.ones((n_samples, n_samples), dtype=\"float32\") * np.inf\n    for i in range(n_samples):\n        diffs = X - X[i, :].reshape((1, n_cols))\n        missing_diffs = np.isnan(diffs)\n        missing_counts_per_row = missing_diffs.sum(axis=1)\n        valid_rows = missing_counts_per_row < n_cols\n        D[i, valid_rows] = np.nanmean(\n            diffs[valid_rows, :] ** 2,\n            axis=1)\n    return D", "response": "Reference implementation of normalized all - pairs distance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfills in the given incomplete matrix using k-nearest neighbor imputation. This version is a simpler algorithm meant primarily for testing but surprisingly it's faster for many (but not all) dataset sizes, particularly when most of the columns are missing in any given row. The crucial bottleneck is the call to numpy.argpartition for every missing element in the array. Parameters ---------- X : np.ndarray Matrix to fill of shape (n_samples, n_features) missing_mask : np.ndarray Boolean array of same shape as X k : int verbose : bool Returns a row-major copy of X with imputed values.", "response": "def knn_impute_with_argpartition(\n        X,\n        missing_mask,\n        k,\n        verbose=False,\n        print_interval=100):\n    \"\"\"\n    Fill in the given incomplete matrix using k-nearest neighbor imputation.\n\n    This version is a simpler algorithm meant primarily for testing but\n    surprisingly it's faster for many (but not all) dataset sizes, particularly\n    when most of the columns are missing in any given row. The crucial\n    bottleneck is the call to numpy.argpartition for every missing element\n    in the array.\n\n    Parameters\n    ----------\n    X : np.ndarray\n        Matrix to fill of shape (n_samples, n_features)\n\n    missing_mask : np.ndarray\n        Boolean array of same shape as X\n\n    k : int\n\n    verbose : bool\n\n    Returns a row-major copy of X with imputed values.\n    \"\"\"\n    start_t = time.time()\n    n_rows, n_cols = X.shape\n    # put the missing mask in column major order since it's accessed\n    # one column at a time\n    missing_mask_column_major = np.asarray(missing_mask, order=\"F\")\n    X_row_major, D, effective_infinity = \\\n        knn_initialize(X, missing_mask, verbose=verbose)\n    D_reciprocal = 1.0 / D\n\n    dot = np.dot\n    array = np.array\n    argpartition = np.argpartition\n\n    for i in range(n_rows):\n        missing_indices = np.where(missing_mask[i])[0]\n\n        if verbose and i % print_interval == 0:\n            print(\n                \"Imputing row %d/%d with %d missing, elapsed time: %0.3f\" % (\n                    i + 1,\n                    n_rows,\n                    len(missing_indices),\n                    time.time() - start_t))\n        d = D[i, :]\n        inv_d = D_reciprocal[i, :]\n        for j in missing_indices:\n            # move rows which lack this feature to be infinitely far away\n            d_copy = d.copy()\n            d_copy[missing_mask_column_major[:, j]] = effective_infinity\n\n            neighbor_indices = argpartition(d_copy, k)[:k]\n            if d_copy[neighbor_indices].max() >= effective_infinity:\n                # if there aren't k rows with the feature of interest then\n                # we need to filter out indices of points at infinite distance\n                neighbor_indices = array([\n                    neighbor_index\n                    for neighbor_index in neighbor_indices\n                    if d_copy[neighbor_index] < effective_infinity\n                ])\n            n_current_neighbors = len(neighbor_indices)\n\n            if n_current_neighbors > 0:\n                neighbor_weights = inv_d[neighbor_indices]\n                X_row_major[i, j] = (\n                    dot(X[:, j][neighbor_indices], neighbor_weights) /\n                    neighbor_weights.sum()\n                )\n    return X_row_major"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreferencing implementation of kNN imputation logic.", "response": "def knn_impute_reference(\n        X,\n        missing_mask,\n        k,\n        verbose=False,\n        print_interval=100):\n    \"\"\"\n    Reference implementation of kNN imputation logic.\n    \"\"\"\n    n_rows, n_cols = X.shape\n    X_result, D, effective_infinity = \\\n        knn_initialize(X, missing_mask, verbose=verbose)\n\n    for i in range(n_rows):\n        for j in np.where(missing_mask[i, :])[0]:\n            distances = D[i, :].copy()\n\n            # any rows that don't have the value we're currently trying\n            # to impute are set to infinite distances\n            distances[missing_mask[:, j]] = effective_infinity\n            neighbor_indices = np.argsort(distances)\n            neighbor_distances = distances[neighbor_indices]\n\n            # get rid of any infinite distance neighbors in the top k\n            valid_distances = neighbor_distances < effective_infinity\n            neighbor_distances = neighbor_distances[valid_distances][:k]\n            neighbor_indices = neighbor_indices[valid_distances][:k]\n\n            weights = 1.0 / neighbor_distances\n            weight_sum = weights.sum()\n\n            if weight_sum > 0:\n                column = X[:, j]\n                values = column[neighbor_indices]\n                X_result[i, j] = np.dot(values, weights) / weight_sum\n    return X_result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef active(self, registered_only=True):\n        \"Returns all active users, e.g. not logged and non-expired session.\"\n        visitors = self.filter(\n            expiry_time__gt=timezone.now(),\n            end_time=None\n        )\n        if registered_only:\n            visitors = visitors.filter(user__isnull=False)\n        return visitors", "response": "Returns all active users e. g. not logged and non - expired session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stats(self, start_date, end_date, registered_only=False):\n        visitors = self.filter(\n            start_time__gte=start_date,\n            start_time__lt=end_date\n        )\n\n        stats = {\n            'total': 0,\n            'unique': 0,\n            'return_ratio': 0,\n        }\n\n        # All visitors\n        stats['total'] = total_count = visitors.count()\n        unique_count = 0\n\n        # No visitors! Nothing more to do.\n        if not total_count:\n            return stats\n\n        # Avg time on site\n        total_time_on_site = visitors.aggregate(\n            avg_tos=Avg('time_on_site'))['avg_tos']\n        stats['time_on_site'] = timedelta(seconds=int(total_time_on_site))\n\n        # Registered user sessions\n        registered_visitors = visitors.filter(user__isnull=False)\n        registered_total_count = registered_visitors.count()\n\n        if registered_total_count:\n            registered_unique_count = registered_visitors.values(\n                'user'\n            ).distinct().count()\n            # Avg time on site\n            time_on_site = registered_visitors.aggregate(\n                avg_tos=Avg('time_on_site'))['avg_tos']\n\n            # Update the total unique count..\n            unique_count += registered_unique_count\n\n            # Set the registered stats..\n            returns = (registered_total_count - registered_unique_count)\n            stats['registered'] = {\n                'total': registered_total_count,\n                'unique': registered_unique_count,\n                'return_ratio': (returns / registered_total_count) * 100,\n                'time_on_site': timedelta(seconds=int(time_on_site)),\n            }\n\n        # Get stats for our guests..\n        if TRACK_ANONYMOUS_USERS and not registered_only:\n            guests = visitors.filter(user__isnull=True)\n            guest_total_count = guests.count()\n\n            if guest_total_count:\n                guest_unique_count = guests.values(\n                    'ip_address'\n                ).distinct().count()\n                # Avg time on site\n                guest_time_on_site = guests.aggregate(\n                    avg_tos=Avg('time_on_site'))['avg_tos']\n                # return rate\n                returns = (guest_total_count - guest_unique_count)\n                return_ratio = (returns / guest_total_count) * 100\n                time_on_site = timedelta(seconds=int(guest_time_on_site))\n            else:\n                guest_total_count = 0\n                guest_unique_count = 0\n                return_ratio = 0.0\n                time_on_site = timedelta(0)\n\n            # Update the total unique count\n            unique_count += guest_unique_count\n            stats['guests'] = {\n                'total': guest_total_count,\n                'unique': guest_unique_count,\n                'return_ratio': return_ratio,\n                'time_on_site': time_on_site,\n            }\n\n        # Finish setting the total visitor counts\n        returns = (total_count - unique_count)\n        stats['unique'] = unique_count\n        stats['return_ratio'] = (returns / total_count) * 100\n\n        # If pageviews are being tracked, add the aggregate pages-per-visit\n        if TRACK_PAGEVIEWS:\n            if 'registered' in stats:\n                pages_per_visit = registered_visitors.annotate(\n                    page_count=Count('pageviews')\n                ).filter(page_count__gt=0).aggregate(\n                    pages_per_visit=Avg('page_count'))['pages_per_visit']\n                stats['registered']['pages_per_visit'] = pages_per_visit\n\n            if TRACK_ANONYMOUS_USERS and not registered_only:\n                stats['guests']['pages_per_visit'] = guests.annotate(\n                    page_count=Count('pageviews')\n                ).filter(page_count__gt=0).aggregate(\n                    pages_per_visit=Avg('page_count'))['pages_per_visit']\n\n                total_per_visit = visitors.annotate(\n                    page_count=Count('pageviews')\n                ).filter(page_count__gt=0).aggregate(\n                    pages_per_visit=Avg('page_count'))['pages_per_visit']\n            else:\n                if 'registered' in stats:\n                    total_per_visit = stats['registered']['pages_per_visit']\n                else:\n                    total_per_visit = 0\n\n            stats['pages_per_visit'] = total_per_visit\n\n        return stats", "response": "Returns a dictionary of stats for the given date range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary of pageviews including the total pageviews registered users and guests.", "response": "def stats(self, start_date=None, end_date=None, registered_only=False):\n        \"\"\"Returns a dictionary of pageviews including:\n\n            * total pageviews\n\n        for all users, registered users and guests.\n        \"\"\"\n        pageviews = self.filter(\n            visitor__start_time__lt=end_date,\n            visitor__start_time__gte=start_date,\n        ).select_related('visitor')\n\n        stats = {\n            'total': 0,\n            'unique': 0,\n        }\n\n        stats['total'] = total_views = pageviews.count()\n        unique_count = 0\n\n        if not total_views:\n            return stats\n\n        # Registered user sessions\n        registered_pageviews = pageviews.filter(visitor__user__isnull=False)\n        registered_count = registered_pageviews.count()\n\n        if registered_count:\n            registered_unique_count = registered_pageviews.values(\n                'visitor', 'url').distinct().count()\n\n            # Update the total unique count...\n            unique_count += registered_unique_count\n\n            stats['registered'] = {\n                'total': registered_count,\n                'unique': registered_unique_count,\n            }\n\n        if TRACK_ANONYMOUS_USERS and not registered_only:\n            guest_pageviews = pageviews.filter(visitor__user__isnull=True)\n            guest_count = guest_pageviews.count()\n\n            if guest_count:\n                guest_unique_count = guest_pageviews.values(\n                    'visitor', 'url').distinct().count()\n\n                # Update the total unique count...\n                unique_count += guest_unique_count\n\n                stats['guests'] = {\n                    'total': guest_count,\n                    'unique': guest_unique_count,\n                }\n\n        # Finish setting the total visitor counts\n        stats['unique'] = unique_count\n\n        return stats"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dashboard(request):\n    \"Counts, aggregations and more!\"\n    end_time = now()\n    start_time = end_time - timedelta(days=7)\n    defaults = {'start': start_time, 'end': end_time}\n\n    form = DashboardForm(data=request.GET or defaults)\n    if form.is_valid():\n        start_time = form.cleaned_data['start']\n        end_time = form.cleaned_data['end']\n\n    # determine when tracking began\n    try:\n        obj = Visitor.objects.order_by('start_time')[0]\n        track_start_time = obj.start_time\n    except (IndexError, Visitor.DoesNotExist):\n        track_start_time = now()\n\n    # If the start_date is before tracking began, warn about incomplete data\n    warn_incomplete = (start_time < track_start_time)\n\n    # queries take `date` objects (for now)\n    user_stats = Visitor.objects.user_stats(start_time, end_time)\n    visitor_stats = Visitor.objects.stats(start_time, end_time)\n    if TRACK_PAGEVIEWS:\n        pageview_stats = Pageview.objects.stats(start_time, end_time)\n    else:\n        pageview_stats = None\n\n    context = {\n        'form': form,\n        'track_start_time': track_start_time,\n        'warn_incomplete': warn_incomplete,\n        'user_stats': user_stats,\n        'visitor_stats': visitor_stats,\n        'pageview_stats': pageview_stats,\n    }\n    return render(request, 'tracking/dashboard.html', context)", "response": "Counts aggregations and more!"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef geoip_data(self):\n        if not HAS_GEOIP or not TRACK_USING_GEOIP:\n            return\n\n        if not hasattr(self, '_geoip_data'):\n            self._geoip_data = None\n            try:\n                gip = GeoIP(cache=GEOIP_CACHE_TYPE)\n                self._geoip_data = gip.city(self.ip_address)\n            except GeoIPException:\n                msg = 'Error getting GeoIP data for IP \"{0}\"'.format(\n                    self.ip_address)\n                log.exception(msg)\n\n        return self._geoip_data", "response": "Attempt to retrieve MaxMind GeoIP data based on visitor s IP."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef escape(s):\n    if hasattr(s, '__html__'):\n        return s.__html__()\n    if isinstance(s, six.binary_type):\n        s = six.text_type(str(s), 'utf8')\n    elif isinstance(s, six.text_type):\n        s = s\n    else:\n        s = str(s)\n\n    return (s\n        .replace('&', '&amp;')\n        .replace('>', '&gt;')\n        .replace('<', '&lt;')\n        .replace(\"'\", '&#39;')\n        .replace('\"', '&#34;')\n    )", "response": "Convert the characters & and < and > and return a HTML - safe version of the string s."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\njade iteration supports \"for 'value' [, key]?\" iteration only. PyJade has implicitly supported value unpacking instead, without the list indexes. Trying to not break existing code, the following rules are applied: 1. If the object is a mapping type, return it as-is, and assume the caller has the correct set of keys defined. 2. If the object's values are iterable (and not string-like): a. If the number of keys matches the cardinality of the object's values, return the object as-is. b. If the number of keys is one more than the cardinality of values, return a list of [v(0), v(1), ... v(n), index] 3. Else the object's values are not iterable, or are string like: a. if there's only one key, return the list b. otherwise return a list of (value,index) tuples", "response": "def iteration(obj, num_keys):\n    \"\"\"\n    Jade iteration supports \"for 'value' [, key]?\" iteration only.\n    PyJade has implicitly supported value unpacking instead, without\n    the list indexes. Trying to not break existing code, the following\n    rules are applied:\n\n      1. If the object is a mapping type, return it as-is, and assume\n         the caller has the correct set of keys defined.\n\n      2. If the object's values are iterable (and not string-like):\n         a. If the number of keys matches the cardinality of the object's\n            values, return the object as-is.\n         b. If the number of keys is one more than the cardinality of\n            values, return a list of [v(0), v(1), ... v(n), index]\n\n      3. Else the object's values are not iterable, or are string like:\n         a. if there's only one key, return the list\n         b. otherwise return a list of (value,index) tuples\n\n    \"\"\"\n\n    # If the object is a mapping type, return it as-is\n    if is_mapping(obj):\n        return obj\n\n    _marker = []\n\n    iter_obj = iter(obj)\n    head = next(iter_obj, _marker)\n    iter_obj = chain([head], iter_obj)\n\n    if head is _marker:\n        # Empty list\n        return []\n\n    if is_iterable(head):\n        if num_keys == get_cardinality(head) + 1:\n            return (tuple(item) + (ix,) for ix, item in enumerate(iter_obj))\n        else:\n            return iter_obj\n\n    elif num_keys == 2:\n        return ((item, ix) for ix, item in enumerate(iter_obj))\n\n    else:\n        return iter_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_evaluate(parser, token):\n  '''Calls an arbitrary method on an object.'''\n  code = token.contents\n  firstspace = code.find(' ')\n  if firstspace >= 0:\n    code = code[firstspace+1:]\n  return Evaluator(code)", "response": "Calls an arbitrary method on an object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_set(parser, token):\n  '''Calls an arbitrary method on an object.'''\n  code = token.contents\n  firstspace = code.find(' ')\n  if firstspace >= 0:\n    code = code[firstspace+1:]\n  return Setter(code)", "response": "Calls an arbitrary method on an object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nevaluate the code in the page and returns the result", "response": "def render(self, context):\n    '''Evaluates the code in the page and returns the result'''\n    modules = {\n      'pyjade': __import__('pyjade')\n    }\n    context['false'] = False\n    context['true'] = True\n    try:\n        return six.text_type(eval('pyjade.runtime.attrs(%s)'%self.code,modules,context))\n    except NameError:\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nevaluating the code in the page and returns the result", "response": "def render(self, context):\n    '''Evaluates the code in the page and returns the result'''\n    modules = {\n    }\n    context['false'] = False\n    context['true'] = True\n    new_ctx = eval('dict(%s)'%self.code,modules,context)\n    context.update(new_ctx)\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sprite_filepath_build(sprite_type, sprite_id, **kwargs):\n\n    options = parse_sprite_options(sprite_type, **kwargs)\n\n    filename = '.'.join([str(sprite_id), SPRITE_EXT])\n    filepath = os.path.join(sprite_type, *options, filename)\n\n    return filepath", "response": "returns the filepath of the sprite relative to SPRITE_CACHE"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking an object and returns a corresponding API class.", "response": "def _make_obj(obj):\n    \"\"\"Takes an object and returns a corresponding API class.\n\n    The names and values of the data will match exactly with those found\n    in the online docs at https://pokeapi.co/docsv2/ . In some cases, the data\n    may be of a standard type, such as an integer or string. For those cases,\n    the input value is simply returned, unchanged.\n\n    :param obj: the object to be converted\n    :return either the same value, if it does not need to be converted, or a\n    APIResource or APIMetadata instance, depending on the data inputted.\n    \"\"\"\n\n    if isinstance(obj, dict):\n        if 'url' in obj.keys():\n            url = obj['url']\n            id_ = int(url.split('/')[-2])      # ID of the data.\n            endpoint = url.split('/')[-3]  # Where the data is located.\n            return APIResource(endpoint, id_, lazy_load=True)\n\n        return APIMetadata(obj)\n\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load(self):\n\n        data = get_data(self.endpoint, self.id_, force_lookup=self.__force_lookup)\n\n        # Make our custom objects from the data.\n        for key, val in data.items():\n\n            if key == 'location_area_encounters' \\\n                    and self.endpoint == 'pokemon':\n\n                params = val.split('/')[-3:]\n                ep, id_, subr = params\n                encounters = get_data(ep, int(id_), subr)\n                data[key] = [_make_obj(enc) for enc in encounters]\n                continue\n\n            if isinstance(val, dict):\n                data[key] = _make_obj(val)\n\n            elif isinstance(val, list):\n                data[key] = [_make_obj(i) for i in val]\n\n        self.__dict__.update(data)\n\n        return None", "response": "Function to collect reference data and connect it to the instance attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef safe_make_dirs(path, mode=0o777):\n    try:\n        os.makedirs(path, mode)\n    except OSError as error:\n        if error.errno != 17:  # File exists\n            raise\n\n    return path", "response": "Create a leaf directory and all intermediate ones in a safe way."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_default_cache():\n\n    xdg_cache_home = os.environ.get('XDG_CACHE_HOME') or \\\n        os.path.join(os.path.expanduser('~'), '.cache')\n\n    return os.path.join(xdg_cache_home, 'pokebase')", "response": "Get the default cache location."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_cache(new_path=None):\n\n    global CACHE_DIR, API_CACHE, SPRITE_CACHE\n\n    if new_path is None:\n        new_path = get_default_cache()\n\n    CACHE_DIR = safe_make_dirs(os.path.abspath(new_path))\n    API_CACHE = os.path.join(CACHE_DIR, 'api.cache')\n    SPRITE_CACHE = safe_make_dirs(os.path.join(CACHE_DIR, 'sprite'))\n\n    return CACHE_DIR, API_CACHE, SPRITE_CACHE", "response": "Simple function to change the cache location."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attach(self, lun_or_snap, skip_hlu_0=False):\n\n        # `UnityResourceAlreadyAttachedError` check was removed due to there\n        # is a host cache existing in Cinder driver. If the lun was attached to\n        # the host and the info was stored in the cache, wrong hlu would be\n        # returned.\n        # And attaching a lun to a host twice would success, if Cinder retry\n        # triggers another attachment of same lun to the host, the cost would\n        # be one more rest request of `modifyLun` and one for host instance\n        # query.\n        try:\n            return self._attach_with_retry(lun_or_snap, skip_hlu_0)\n\n        except ex.SystemAPINotSupported:\n            # Attaching snap to host not support before 4.1.\n            raise\n        except ex.UnityAttachExceedLimitError:\n            # The number of luns exceeds system limit\n            raise\n        except:  # noqa\n            # other attach error, remove this lun if already attached\n            self.detach(lun_or_snap)\n            raise", "response": "Attaches lun snap or member snap to host."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_hlu(self, lun_or_snap, cg_member=None):\n        hlu = self.get_hlu(lun_or_snap, cg_member=cg_member)\n        return hlu is not None", "response": "Returns True if lun_or_snap is attached to the host."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_host_lun(self, lun_or_snap, cg_member=None):\n        import storops.unity.resource.lun as lun_module\n        import storops.unity.resource.snap as snap_module\n        which = None\n        if isinstance(lun_or_snap, lun_module.UnityLun):\n            which = self._get_host_luns(lun=lun_or_snap)\n        elif isinstance(lun_or_snap, snap_module.UnitySnap):\n            if lun_or_snap.is_cg_snap():\n                if cg_member is None:\n                    log.debug('None host lun for CG snap {}. '\n                              'Use its member snap instead or pass in '\n                              'cg_member.'.format(lun_or_snap.id))\n                    return None\n                lun_or_snap = lun_or_snap.get_member_snap(cg_member)\n                which = self._get_host_luns(lun=cg_member, snap=lun_or_snap)\n            else:\n                which = self._get_host_luns(snap=lun_or_snap)\n        if not which:\n            log.debug('Resource(LUN or Snap) {} is not attached to host {}'\n                      .format(lun_or_snap.name, self.name))\n            return None\n        return which[0]", "response": "Gets the host lun of a lun snap cg snap or member snap of cg snap."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the hlu number of a resource and cg snap.", "response": "def get_hlu(self, resource, cg_member=None):\n        \"\"\"Gets the hlu number of a lun, lun snap, cg snap or a member snap of\n        cg snap.\n\n        :param resource: can be lun, lun snap, cg snap or a member snap of cg\n            snap.\n        :param cg_member: the member lun of cg if `lun_or_snap` is cg snap.\n        :return: the hlu number.\n        \"\"\"\n        host_lun = self.get_host_lun(resource, cg_member=cg_member)\n        return host_lun if host_lun is None else host_lun.hlu"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_initiators(self, iqns=None, wwns=None):\n        # First get current iqns\n        iqns = set(iqns) if iqns else set()\n        current_iqns = set()\n        if self.iscsi_host_initiators:\n            current_iqns = {initiator.initiator_id\n                            for initiator in self.iscsi_host_initiators}\n        # Then get current wwns\n        wwns = set(wwns) if wwns else set()\n        current_wwns = set()\n        if self.fc_host_initiators:\n            current_wwns = {initiator.initiator_id\n                            for initiator in self.fc_host_initiators}\n        updater = UnityHostInitiatorUpdater(\n            self, current_iqns | current_wwns, iqns | wwns)\n        return updater.update()", "response": "Update the iSCSI and FC initiators if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Pandas Series of every file for the chosen satellite.", "response": "def list_files(tag=None, sat_id=None, data_path=None, format_str=None,\n               supported_tags=None, fake_daily_files_from_monthly=False,\n               two_digit_year_break=None):\n    \"\"\"Return a Pandas Series of every file for chosen satellite data.\n    \n    This routine is intended to be used by pysat instrument modules supporting\n    a particular NASA CDAWeb dataset.\n\n    Parameters\n    -----------\n    tag : (string or NoneType)\n        Denotes type of file to load.  Accepted types are <tag strings>. (default=None)\n    sat_id : (string or NoneType)\n        Specifies the satellite ID for a constellation.  Not used.\n        (default=None)\n    data_path : (string or NoneType)\n        Path to data directory.  If None is specified, the value previously\n        set in Instrument.files.data_path is used.  (default=None)\n    format_str : (string or NoneType)\n        User specified file format.  If None is specified, the default\n        formats associated with the supplied tags are used. (default=None)\n    supported_tags : (dict or NoneType)\n        keys are tags supported by list_files routine. Values are the\n        default format_str values for key. (default=None)\n    fake_daily_files_from_monthly : bool\n        Some CDAWeb instrument data files are stored by month, interfering\n        with pysat's functionality of loading by day. This flag, when true,\n        appends daily dates to monthly files internally. These dates are\n        used by load routine in this module to provide data by day. \n\n    Returns\n    --------\n    pysat.Files.from_os : (pysat._files.Files)\n        A class containing the verified available files\n\n    Examples\n    --------\n    :: \n\n        fname = 'cnofs_vefi_bfield_1sec_{year:04d}{month:02d}{day:02d}_v05.cdf'\n        supported_tags = {'dc_b':fname}\n        list_files = functools.partial(nasa_cdaweb_methods.list_files, \n                                       supported_tags=supported_tags)\n\n        ivm_fname = 'cnofs_cindi_ivm_500ms_{year:4d}{month:02d}{day:02d}_v01.cdf'\n        supported_tags = {'':ivm_fname}\n        list_files = functools.partial(cdw.list_files, \n                                       supported_tags=supported_tags)\n    \n    \"\"\"\n\n    if data_path is not None:\n        if format_str is None:\n                try:\n                    format_str = supported_tags[sat_id][tag]\n                except KeyError:\n                    raise ValueError('Unknown tag')\n        out = pysat.Files.from_os(data_path=data_path, \n                                  format_str=format_str)\n\n        if (not out.empty) and fake_daily_files_from_monthly:\n            out.ix[out.index[-1] + pds.DateOffset(months=1) -\n                                   pds.DateOffset(days=1)] = out.iloc[-1]  \n            out = out.asfreq('D', 'pad')\n            out = out + '_' + out.index.strftime('%Y-%m-%d')  \n            return out\n\n        return out\n    else:\n        estr = 'A directory must be passed to the loading routine for <Instrument Code>'\n        raise ValueError (estr)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(fnames, tag=None, sat_id=None, \n         fake_daily_files_from_monthly=False,\n         flatten_twod=True):\n    \"\"\"Load NASA CDAWeb CDF files.\n    \n    This routine is intended to be used by pysat instrument modules supporting\n    a particular NASA CDAWeb dataset.\n\n    Parameters\n    ------------\n    fnames : (pandas.Series)\n        Series of filenames\n    tag : (str or NoneType)\n        tag or None (default=None)\n    sat_id : (str or NoneType)\n        satellite id or None (default=None)\n    fake_daily_files_from_monthly : bool\n        Some CDAWeb instrument data files are stored by month, interfering\n        with pysat's functionality of loading by day. This flag, when true,\n        parses of daily dates to monthly files that were added internally\n        by the list_files routine, when flagged. These dates are\n        used here to provide data by day. \n\n    Returns\n    ---------\n    data : (pandas.DataFrame)\n        Object containing satellite data\n    meta : (pysat.Meta)\n        Object containing metadata such as column names and units\n        \n    Examples\n    --------\n    ::\n    \n        # within the new instrument module, at the top level define\n        # a new variable named load, and set it equal to this load method\n        # code below taken from cnofs_ivm.py.\n        \n        # support load routine\n        # use the default CDAWeb method\n        load = cdw.load\n\n        \n    \"\"\"\n    \n    import pysatCDF\n\n    if len(fnames) <= 0 :\n        return pysat.DataFrame(None), None\n    else:\n        # going to use pysatCDF to load the CDF and format\n        # data and metadata for pysat using some assumptions.\n        # Depending upon your needs the resulting pandas DataFrame may\n        # need modification \n        # currently only loads one file, which handles more situations via pysat\n        # than you may initially think\n        \n        if fake_daily_files_from_monthly:\n            # parse out date from filename\n            fname = fnames[0][0:-11]\n            date = pysat.datetime.strptime(fnames[0][-10:], '%Y-%m-%d')\n            with pysatCDF.CDF(fname) as cdf:\n                # convert data to pysat format\n                data, meta = cdf.to_pysat(flatten_twod=flatten_twod)\n                # select data from monthly\n                data = data.ix[date:date+pds.DateOffset(days=1) - pds.DateOffset(microseconds=1),:]\n                return data, meta     \n        else:\n            # basic data return \n            with pysatCDF.CDF(fnames[0]) as cdf:     \n                return cdf.to_pysat(flatten_twod=flatten_twod)", "response": "Load NASA CDAWeb CDF files into a new DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an instance of HttpError or subclass based on response.", "response": "def from_response(response, method, url):\n    \"\"\"Returns an instance of :class:`HttpError` or subclass based on response.\n\n    :param response: instance of `requests.Response` class\n    :param method: HTTP method used for request\n    :param url: URL used for request\n    \"\"\"\n\n    req_id = response.headers.get(\"x-openstack-request-id\")\n    # NOTE(hdd) true for older versions of nova and cinder\n    if not req_id:\n        req_id = response.headers.get(\"x-compute-request-id\")\n    kwargs = {\n        \"http_status\": response.status_code,\n        \"response\": response,\n        \"method\": method,\n        \"url\": url,\n        \"request_id\": req_id,\n    }\n    if \"retry-after\" in response.headers:\n        kwargs[\"retry_after\"] = response.headers[\"retry-after\"]\n\n    content_type = response.headers.get(\"Content-Type\", \"\")\n    if content_type.startswith(\"application/json\"):\n        try:\n            body = response.json()\n        except ValueError:\n            pass\n        else:\n            if isinstance(body, dict):\n                error = body.get(list(body)[0])\n                if isinstance(error, dict):\n                    kwargs[\"message\"] = (error.get(\"message\") or\n                                         error.get(\"faultstring\"))\n                    kwargs[\"details\"] = (error.get(\"details\") or\n                                         six.text_type(body))\n    elif content_type.startswith(\"text/\"):\n        kwargs[\"details\"] = response.text\n\n    try:\n        cls = _code_map[response.status_code]\n    except KeyError:\n        if 500 <= response.status_code < 600:\n            cls = HttpServerError\n        elif 400 <= response.status_code < 500:\n            cls = HTTPClientError\n        else:\n            cls = HttpError\n    return cls(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate pool based on RaidGroupParameter.", "response": "def create_pool(self, name, raid_groups, description=None, **kwargs):\n        \"\"\"Create pool based on RaidGroupParameter.\n\n        :param name: pool name\n        :param raid_groups: a list of *RaidGroupParameter*\n        :param description: pool description\n        :param alert_threshold: Threshold at which the system will generate\n               alerts about the free space in the pool, specified as\n               a percentage.\n        :param is_harvest_enabled:\n               True - Enable pool harvesting for the pool.\n               False - Disable pool harvesting for the pool.\n        :param is_snap_harvest_enabled:\n               True - Enable snapshot harvesting for the pool.\n               False - Disable snapshot harvesting for the pool.\n        :param pool_harvest_high_threshold: Pool used space high threshold at\n               which the system will automatically starts to delete snapshots\n               in the pool\n        :param pool_harvest_low_threshold: Pool used space low threshold under\n               which the system will automatically stop deletion of snapshots\n               in the pool\n        :param snap_harvest_high_threshold: Snapshot used space high threshold\n               at which the system automatically starts to delete snapshots\n               in the pool\n        :param snap_harvest_low_threshold: Snapshot used space low threshold\n               below which the system will stop automatically deleting\n               snapshots in the pool\n        :param is_fast_cache_enabled:\n               True - FAST Cache will be enabled for this pool.\n               False - FAST Cache will be disabled for this pool.\n        :param is_fastvp_enabled:\n               True - Enable scheduled data relocations for the pool.\n               False - Disable scheduled data relocations for the pool.\n        :param pool_type:\n               StoragePoolTypeEnum.TRADITIONAL - Create traditional pool.\n               StoragePoolTypeEnum.DYNAMIC - Create dynamic pool. (default)\n        \"\"\"\n        return UnityPool.create(self._cli, name=name, description=description,\n                                raid_groups=raid_groups, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning list of file ports.", "response": "def get_file_port(self):\n        \"\"\"Returns ports list can be used by File\n\n        File ports includes ethernet ports and link aggregation ports.\n        \"\"\"\n        eths = self.get_ethernet_port(bond=False)\n        las = self.get_link_aggregation()\n        return eths + las"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a remote system for remote replication.", "response": "def create_remote_system(self, management_address,\n                             local_username=None, local_password=None,\n                             remote_username=None, remote_password=None,\n                             connection_type=None):\n        \"\"\"\n        Configures a remote system for remote replication.\n\n        :param management_address: the management IP address of the remote\n            system.\n        :param local_username: administrative username of local system.\n        :param local_password: administrative password of local system.\n        :param remote_username: administrative username of remote system.\n        :param remote_password: administrative password of remote system.\n        :param connection_type: `ReplicationCapabilityEnum`. Replication\n            connection type to the remote system.\n        :return: the newly created remote system.\n        \"\"\"\n        return UnityRemoteSystem.create(self._cli, management_address,\n                                        local_username=local_username,\n                                        local_password=local_password,\n                                        remote_username=remote_username,\n                                        remote_password=remote_password,\n                                        connection_type=connection_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a replication interface.", "response": "def create_replication_interface(self, sp, ip_port, ip_address,\n                                     netmask=None, v6_prefix_length=None,\n                                     gateway=None, vlan_id=None):\n        \"\"\"\n        Creates a replication interface.\n\n        :param sp: `UnityStorageProcessor` object. Storage processor on which\n            the replication interface is running.\n        :param ip_port: `UnityIpPort` object. Physical port or link aggregation\n            on the storage processor on which the interface is running.\n        :param ip_address: IP address of the replication interface.\n        :param netmask: IPv4 netmask for the replication interface, if it uses\n            an IPv4 address.\n        :param v6_prefix_length: IPv6 prefix length for the interface, if it\n            uses an IPv6 address.\n        :param gateway: IPv4 or IPv6 gateway address for the replication\n            interface.\n        :param vlan_id: VLAN identifier for the interface.\n        :return: the newly create replication interface.\n        \"\"\"\n        return UnityReplicationInterface.create(\n            self._cli, sp, ip_port, ip_address, netmask=netmask,\n            v6_prefix_length=v6_prefix_length, gateway=gateway,\n            vlan_id=vlan_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef geo2mag(incoord):\n\n    from numpy import pi, cos, sin, arctan2, sqrt, dot\n\n    # SOME 'constants' for location of northern mag pole\n    lat = 80.08#79.3\n    lon = -72.211+360.#287.789 # or 71.41W\n    r = 1.0\n\n    # convert first to radians\n    lon, lat = [x*pi/180 for x in lon, lat]\n\n    glat = incoord[0] * pi / 180.0\n    glon = incoord[1] * pi / 180.0\n    galt = glat * 0. + r\n\n    coord = np.vstack([glat,glon,galt])\n\n    # convert to rectangular coordinates\n    x = coord[2]*cos(coord[0])*cos(coord[1])\n    y = coord[2]*cos(coord[0])*sin(coord[1])\n    z = coord[2]*sin(coord[0])\n    xyz = np.vstack((x,y,z))\n\n    # computer 1st rotation matrix:\n    geo2maglon = np.zeros((3,3), dtype='float64')\n    geo2maglon[0,0] = cos(lon)\n    geo2maglon[0,1] = sin(lon)\n    geo2maglon[1,0] = -sin(lon)\n    geo2maglon[1,1] = cos(lon)\n    geo2maglon[2,2] = 1.\n    out = dot(geo2maglon , xyz)\n\n    tomaglat = np.zeros((3,3), dtype='float64')\n    tomaglat[0,0] = cos(.5*pi-lat)\n    tomaglat[0,2] = -sin(.5*pi-lat)\n    tomaglat[2,0] = sin(.5*pi-lat)\n    tomaglat[2,2] = cos(.5*pi-lat)\n    tomaglat[1,1] = 1.\n    out = dot(tomaglat , out)\n\n    mlat = arctan2(out[2],\n            sqrt(out[0]*out[0] + out[1]*out[1]))\n    mlat = mlat * 180 / pi\n    mlon = arctan2(out[1], out[0])\n    mlon = mlon * 180 / pi\n\n    outcoord = np.vstack((mlat, mlon))\n    return outcoord", "response": "geographic coordinate to magnetic coordinate"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrestore a snapshot. :param res_id: the LUN number of primary LUN or snapshot mount point to be restored. :param backup_snap: the name of a backup snapshot to be created before restoring.", "response": "def restore(self, res_id, backup_snap=None):\n        \"\"\"\n        Restores a snapshot.\n        :param res_id: the LUN number of primary LUN or snapshot mount point to\n            be restored.\n        :param backup_snap: the name of a backup snapshot to be created before\n            restoring.\n        \"\"\"\n        name = self._get_name()\n        out = self._cli.restore_snap(name, res_id, backup_snap)\n        ex.raise_if_err(out, 'failed to restore snap {}.'.format(name),\n                        default=ex.VNXSnapError)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a Pandas Series of every file for chosen SuperMAG data.", "response": "def list_files(tag='', sat_id=None, data_path=None, format_str=None):\n    \"\"\"Return a Pandas Series of every file for chosen SuperMAG data\n\n    Parameters\n    -----------\n    tag : (string or NoneType)\n        Denotes type of file to load.  Accepted types are 'indices', 'all',\n        'stations', and '' (for just magnetometer measurements). (default='')\n    sat_id : (string or NoneType)\n        Specifies the satellite ID for a constellation.  Not used.\n        (default=None)\n    data_path : (string or NoneType)\n        Path to data directory.  If None is specified, the value previously\n        set in Instrument.files.data_path is used.  (default=None)\n    format_str : (string or NoneType)\n        User specified file format.  If None is specified, the default\n        formats associated with the supplied tags are used. (default=None)\n\n    Returns\n    --------\n    pysat.Files.from_os : (pysat._files.Files)\n        A class containing the verified available files\n        \n    \"\"\"\n    if format_str is None and data_path is not None:\n        file_base = 'supermag_magnetometer'\n        if tag == \"indices\" or tag == \"all\":\n            file_base += '_all' # Can't just download indices\n\n            if tag == \"indices\":\n                psplit = path.split(data_path[:-1])\n                data_path = path.join(psplit[0], \"all\", \"\")\n\n        if tag == \"stations\":\n            min_fmt = '_'.join([file_base, '{year:4d}.???'])\n            doff = pds.DateOffset(years=1)\n        else:\n            min_fmt = '_'.join([file_base, '{year:4d}{month:02d}{day:02d}.???'])\n            doff = pds.DateOffset(days=1)\n        files = pysat.Files.from_os(data_path=data_path, format_str=min_fmt)\n\n        # station files are once per year but we need to\n        # create the illusion there is a file per year        \n        if not files.empty:\n            files = files.sort_index()\n\n            if tag == \"stations\":\n                orig_files = files.copy()\n                new_files = []\n                # Assigns the validity of each station file to be 1 year\n                for orig in orig_files.iteritems():\n                    files.ix[orig[0] + doff - pds.DateOffset(days=1)] = orig[1]\n                    files = files.sort_index()\n                    new_files.append(files.ix[orig[0]: orig[0] + doff - \\\n                            pds.DateOffset(days=1)].asfreq('D', method='pad'))\n                files = pds.concat(new_files)\n\n                files = files.dropna()\n                files = files.sort_index()\n            # add the date to the filename\n            files = files + '_' + files.index.strftime('%Y-%m-%d')\n        return files\n    elif format_str is None:\n        estr = 'A directory must be passed to the loading routine for SuperMAG'\n        raise ValueError (estr)\n    else:\n        return pysat.Files.from_os(data_path=data_path, format_str=format_str)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the SuperMAG files into a single DataFrame.", "response": "def load(fnames, tag='', sat_id=None):\n    \"\"\" Load the SuperMAG files\n\n    Parameters\n    -----------\n    fnames : (list)\n        List of filenames\n    tag : (str or NoneType)\n        Denotes type of file to load.  Accepted types are 'indices', 'all',\n        'stations', and '' (for just magnetometer measurements). (default='')\n    sat_id : (str or NoneType)\n        Satellite ID for constellations, not used. (default=None)\n\n    Returns\n    --------\n    data : (pandas.DataFrame)\n        Object containing satellite data\n    meta : (pysat.Meta)\n        Object containing metadata such as column names and units\n        \n    \"\"\"\n\n    # Ensure that there are files to load\n    if len(fnames) <= 0 :\n        return pysat.DataFrame(None), pysat.Meta(None)\n\n    # Ensure that the files are in a list\n    if isinstance(fnames, str):\n        fnames = [fnames]\n\n    # Initialise the output data\n    data = pds.DataFrame()\n    baseline = list()\n\n    # Cycle through the files\n    for fname in fnames:\n        fname = fname[:-11] # Remove date index from end of filename\n        file_type = path.splitext(fname)[1].lower()\n\n        # Open and load the files for each file type\n        if file_type == \".csv\":\n            if tag != \"indices\":\n                temp = load_csv_data(fname, tag)\n        else:\n            temp, bline = load_ascii_data(fname, tag)\n\n            if bline is not None:\n                baseline.append(bline)\n\n        # Save the loaded data in the output data structure\n        if len(temp.columns) > 0:\n            data = pds.concat([data, temp], axis=0)\n        del temp\n\n    # If data was loaded, update the meta data\n    if len(data.columns) > 0:\n        meta = pysat.Meta()\n        for cc in data.columns:\n            meta[cc] = update_smag_metadata(cc)\n\n        meta.info = {'baseline':format_baseline_list(baseline)}\n    else:\n        meta = pysat.Meta(None)\n\n    return data, meta"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_csv_data(fname, tag):\n    import re\n\n    if tag == \"stations\":\n        # Because there may be multiple operators, the default pandas reader\n        # cannot be used.\n        ddict = dict()\n        dkeys = list()\n        date_list = list()\n\n        # Open and read the file\n        with open(fname, \"r\") as fopen:\n            dtime = pds.datetime.strptime(fname.split(\"_\")[-1].split(\".\")[0],\n                                          \"%Y\")\n\n            for fline in fopen.readlines():\n                sline = [ll for ll in re.split(r'[,\\n]+', fline) if len(ll) > 0]\n\n                if len(ddict.items()) == 0:\n                    for kk in sline:\n                        kk = re.sub(\"-\", \"_\", kk)\n                        ddict[kk] = list()\n                        dkeys.append(kk)\n                else:\n                    date_list.append(dtime)\n                    for i,ll in enumerate(sline):\n                        if i >= 1 and i <= 4:\n                            ddict[dkeys[i]].append(float(ll))\n                        elif i == 6:\n                            ddict[dkeys[i]].append(int(ll))\n                        elif i < len(dkeys):\n                            ddict[dkeys[i]].append(ll)\n                        else:\n                            ddict[dkeys[-1]][-1] += \" {:s}\".format(ll)\n                            \n        # Create a data frame for this file\n        data = pds.DataFrame(ddict, index=date_list, columns=ddict.keys())\n    else:\n        # Define the date parser\n        def parse_smag_date(dd):                                               \n            return pysat.datetime.strptime(dd, \"%Y-%m-%d %H:%M:%S\")\n\n        # Load the file into a data frame\n        data = pds.read_csv(fname, parse_dates={'datetime':[0]},\n                            date_parser=parse_smag_date, index_col='datetime')\n\n    return data", "response": "Load data from a comma separated SuperMAG file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading data from an ASCII SuperMAG file.", "response": "def load_ascii_data(fname, tag):\n    \"\"\"Load data from a self-documenting ASCII SuperMAG file\n\n    Parameters\n    ------------\n    fname : (str)\n        ASCII SuperMAG filename\n    tag : (str)\n        Denotes type of file to load.  Accepted types are 'indices', 'all',\n        'stations', and '' (for just magnetometer measurements).\n\n    Returns\n    --------\n    data : (pandas.DataFrame)\n        Pandas DataFrame\n    baseline : (list)\n        List of strings denoting the presence of a standard and file-specific\n        baselines for each file.  None of not present or not applicable.\n        \n    \"\"\"\n    import re\n    ndata = {\"indices\":2, \"\":4, \"all\":4, \"stations\":8}\n    dkeys = {'stations':list(), '':['IAGA', 'N', 'E', 'Z']}\n    data = pds.DataFrame(None)\n    baseline = None\n\n    # Ensure that the tag indicates a type of data we know how to load\n    if not tag in ndata.keys():\n        return data, baseline\n\n    # Read in the text data, processing the header, indices, and\n    # magnetometer data (as desired)\n    with open(fname, \"r\") as fopen:\n        # Set the processing flags\n        hflag = True  # header lines\n        pflag = False # parameter line\n        dflag = False if tag == \"stations\" else True  # date line\n        snum = 0      # number of magnetometer stations\n        ddict = dict()\n        date_list = list()\n\n        if tag == \"stations\":\n            dtime = pds.datetime.strptime(fname.split(\"_\")[-1].split(\".\")[0],\n                                          \"%Y\")\n\n        for fline in fopen.readlines():\n            # Cycle past the header\n            line_len = len(fline)\n\n            if hflag:\n                if pflag:\n                    pflag = False # Unset the flag\n                    if fline.find(\"-mlt\") > 0:\n                        ndata[''] += 2\n                        dkeys[''].extend(['MLT', 'MLAT'])\n                    if fline.find(\"-sza\") > 0:\n                        ndata[''] += 1\n                        dkeys[''].append('SZA')\n                    if fline.find(\"-decl\") > 0:\n                        ndata[''] += 1\n                        dkeys[''].append('IGRF_DECL')\n                    if tag == \"indices\" and fline.find(\"-envelope\") < 0:\n                        # Indices not included in this file\n                        break\n\n                    # Save the baseline information\n                    lsplit = fline.split()\n                    idelta = lsplit.index('-delta') + 1\n                    ibase = lsplit.index('-baseline') + 1\n                    isd = lsplit.index('-sd') + 1\n                    ist = lsplit.index('-st') + 1\n                    iex = lsplit.index('-ex') + 1\n                    baseline = \" \".join([lsplit[ibase], lsplit[idelta],\n                                         lsplit[isd], lsplit[ist], lsplit[iex]])\n\n                if fline.find(\"Selected parameters:\") >= 0:\n                    pflag = True\n                if fline.count(\"=\") == line_len - 1 and line_len > 2:\n                    hflag = False\n            else:\n                # Load the desired data\n                lsplit = [ll for ll in re.split(r'[\\t\\n]+', fline)\n                          if len(ll) > 0]\n\n                if dflag:\n                    dflag = False # Unset the date flag\n                    dstring = \" \".join(lsplit[:6])\n                    dtime = pysat.datetime.strptime(dstring,\n                                                    \"%Y %m %d %H %M %S\")\n                    snum = int(lsplit[6]) # Set the number of stations\n\n                    # Load the times\n                    if tag == \"indices\":\n                        date_list.append(dtime)\n                    else:\n                        date_list.extend([dtime for i in range(snum)])\n                elif len(lsplit) == ndata['indices']:\n                    if tag is not '':\n                        if lsplit[0] not in ddict.keys():\n                            ddict[lsplit[0]] = list()\n\n                        if tag == \"indices\":\n                            ddict[lsplit[0]].append(int(lsplit[1]))\n                        else:\n                            # This works because indices occur before\n                            # magnetometer measurements\n                            ddict[lsplit[0]].extend([int(lsplit[1])\n                                                     for i in range(snum)])\n                else:\n                    if tag == \"stations\" and len(lsplit) >= ndata[tag]:\n                        if len(dkeys[tag]) == 0:\n                            # Station files include column names and data files\n                            # do not.  Read in the column names here\n                            for ll in lsplit:\n                                ll = re.sub(\"-\", \"_\", ll)\n                                dkeys[tag].append(ll)\n                                ddict[ll] = list()\n                        else:\n                            # Because stations can have multiple operators,\n                            # ndata supplies the minimum number of columns\n                            date_list.append(dtime)\n                            for i,ll in enumerate(lsplit):\n                                if i >= 1 and i <= 4:\n                                    ddict[dkeys[tag][i]].append(float(ll))\n                                elif i == 6:\n                                    ddict[dkeys[tag][i]].append(int(ll))\n                                elif i < len(dkeys[tag]):\n                                    ddict[dkeys[tag][i]].append(ll)\n                                else:\n                                    ddict[dkeys[tag][-1]][-1] += \\\n                                                            \" {:s}\".format(ll)\n                    elif len(lsplit) == ndata['']:\n                        snum -= 1 # Mark the ingestion of a station\n                        if tag != \"indices\":\n                            if len(ddict.keys()) < ndata['']:\n                               for kk in dkeys['']:\n                                   ddict[kk] = list()\n                            for i,kk in enumerate(dkeys['']):\n                                if i == 0:\n                                    ddict[kk].append(lsplit[i])\n                                else:\n                                    ddict[kk].append(float(lsplit[i]))\n\n                if tag != \"stations\" and snum == 0 and len(ddict.items()) >= 2:\n                    # The previous value was the last value, prepare for\n                    # next block\n                    dflag = True\n\n        # Create a data frame for this file\n        data = pds.DataFrame(ddict, index=date_list, columns=ddict.keys())\n\n        fopen.close()\n\n    return data, baseline"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates SuperMAG metadata for a given column.", "response": "def update_smag_metadata(col_name):\n    \"\"\"Update SuperMAG metadata\n\n    Parameters\n    -----------\n    col_name : (str)\n        Data column name\n\n    Returns\n    --------\n    col_dict : (dict)\n       Dictionary of strings detailing the units and long-form name of the data\n       \n    \"\"\"\n\n    smag_units = {'IAGA':'none', 'N':'nT', 'E':'nT', 'Z':'nT', 'MLT':'hours',\n                  'MLAT':'degrees', 'SZA':'degrees', 'IGRF_DECL':'degrees',\n                  'SMU':'none', 'SML':'none', 'datetime':'YYYY-MM-DD HH:MM:SS',\n                  'GEOLON':'degrees', 'GEOLAT':'degrees', 'AACGMLON':'degrees',\n                  'AACGMLAT':'degrees', 'STATION_NAME':'none',\n                  'OPERATOR_NUM':'none', 'OPERATORS':'none'}\n    smag_name = {'IAGA':'Station Code', 'N':'B along local magnetic North',\n                 'E':'B along local magnetic East', 'Z':'B vertically downward',\n                 'MLT':'Magnetic Local Time', 'MLAT':'Magnetic Latitude',\n                 'SZA':'Solar Zenith Angle',\n                 'IGRF_DECL':'IGRF magnetic declination',\n                 'SMU': 'Maximum eastward auroral electrojets strength.\\n'\n                 'Upper envelope of N-component for stations between 40 and '\n                 '80 degrees magnetic north.',\n                 'SML':'Maximum westward auroral electrojets strength.\\n'\n                 'Lower envelope of N-component for stations between 40 and 80'\n                 ' degrees magnetic north.', 'datetime':'UT date and time',\n                 'GEOLON':'geographic longitude',\n                 'GEOLAT':'geographic latitude',\n                 'AACGMLON':'Altitude-Adjusted Corrected Geomagnetic longitude',\n                 'AACGMLAT':'Altitude-Adjusted Corrected Geomagnetic latitude',\n                 'STATION_NAME':'Long form station name',\n                 'OPERATOR_NUM':'Number of station operators',\n                 'OPERATORS':'Station operator name(s)',}\n    \n    ackn = \"When using this data please include the following reference:\\n\"\n    ackn += \"Gjerloev, J. W., The SuperMAG data processing technique, \"\n    ackn += \"Geophys. Res., 117, A09213, doi:10.1029/2012JA017683, 2012\\n\\n\"\n    ackn += \"For publications and presentations, please include the following\"\n    ackn += \"acknowledgement:\\nFor the ground magnetometer data we gratefully \"\n    ackn += \"acknowledge: Intermagnet; USGS, Jeffrey J. Love; CARISMA, PI Ian \"\n    ackn += \"Mann; CANMOS; The S-RAMP Database, PI K. Yumoto and Dr. K. \"\n    ackn += \"Shiokawa; The SPIDR database; AARI, PI Oleg Troshichev; The \"\n    ackn += \"MACCS program, PI M. Engebretson, Geomagnetism Unit of the \"\n    ackn += \"Geological Survey of Canada; GIMA; MEASURE, UCLA IGPP and Florida\"\n    ackn += \" Institute of Technology; SAMBA, PI Eftyhia Zesta; 210 Chain, PI \"\n    ackn += \"K. Yumoto; SAMNET, PI Farideh Honary; The institutes who maintain\"\n    ackn += \" the IMAGE magnetometer array, PI Eija Tanskanen; PENGUIN; AUTUMN,\"\n    ackn += \" PI Martin Connors; DTU Space, PI Dr. Rico Behlke; South Pole and \"\n    ackn += \" McMurdo Magnetometer, PI's Louis J. Lanzarotti and Alan T. \"\n    ackn += \"Weatherwax; ICESTAR; RAPIDMAG; PENGUIn; British Artarctic Survey; \"\n    ackn += \"McMac, PI Dr. Peter Chi; BGS, PI Dr. Susan Macmillan; Pushkov \"\n    ackn += \"Institute of Terrestrial Magnetism, Ionosphere and Radio Wave \"\n    ackn += \"Propagation (IZMIRAN); GFZ, PI Dr. Juergen Matzka; MFGI, PI B. \"\n    ackn += \"Heilig; IGFPAS, PI J. Reda; University of L\u2019Aquila, PI M. \"\n    ackn += \"Vellante; BCMT, V. Lesur and A. Chambodut; Data obtained in \"\n    ackn += \"cooperation with Geoscience Australia, PI Marina Costelloe; \"\n    ackn += \"SuperMAG, PI Jesper W. Gjerloev.\"\n    \n    col_dict = {'units':smag_units[col_name], 'long_name':smag_name[col_name],\n                'acknowledgements':ackn}\n\n    return col_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat the list of baseline information from the loaded files into a base string", "response": "def format_baseline_list(baseline_list):\n    \"\"\"Format the list of baseline information from the loaded files into a\n    cohesive, informative string\n\n    Parameters\n    ------------\n    baseline_list : (list)\n        List of strings specifying the baseline information for each\n        SuperMAG file\n\n    Returns\n    ---------\n    base_string : (str)\n        Single string containing the relevent data\n        \n    \"\"\"\n\n    uniq_base = dict()\n    uniq_delta = dict()\n\n    for bline in baseline_list:\n        bsplit = bline.split()\n        bdate = \" \".join(bsplit[2:])\n        if bsplit[0] not in uniq_base.keys():\n            uniq_base[bsplit[0]] = \"\"\n        if bsplit[1] not in uniq_delta.keys():\n            uniq_delta[bsplit[1]] = \"\"\n\n        uniq_base[bsplit[0]] += \"{:s}, \".format(bdate)\n        uniq_delta[bsplit[1]] += \"{:s}, \".format(bdate)\n\n    if len(uniq_base.items()) == 1:\n        base_string = \"Baseline {:s}\".format(list(uniq_base.keys())[0])\n    else:\n        base_string = \"Baseline \"\n\n        for i,kk in enumerate(uniq_base.keys()):\n            if i == 1:\n                base_string += \"{:s}: {:s}\".format(kk, uniq_base[kk][:-2])\n            else:\n                base_string += \"         {:s}: {:s}\".format(kk,\n                                                            uniq_base[kk][:-2])\n        else:\n            base_string += \"unknown\"\n\n    if len(uniq_delta.items()) == 1:\n        base_string += \"\\nDelta    {:s}\".format(list(uniq_delta.keys())[0])\n    else:\n        base_string += \"\\nDelta    \"\n\n        for i,kk in enumerate(uniq_delta.keys()):\n            if i == 1:\n                base_string += \"{:s}: {:s}\".format(kk, uniq_delta[kk][:-2])\n            else:\n                base_string += \"         {:s}: {:s}\".format(kk,\n                                                            uniq_delta[kk][:-2])\n        else:\n            base_string += \"unknown\"\n\n    return base_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends data to the SuperMAG files in order to be used in the SuperMAG file.", "response": "def append_data(file_strings, file_fmt, tag):\n    \"\"\" Load the SuperMAG files\n\n    Parameters\n    -----------\n    file_strings : array-like\n        Lists or arrays of strings, where each string contains one file of data\n    file_fmt : str\n        String denoting file type (ascii or csv)\n    tag : string\n        String denoting the type of file to load, accepted values are 'indices',\n        'all', 'stations', and '' (for only magnetometer data)\n\n    Returns\n    -------\n    out_string : string\n        String with all data, ready for output to a file\n        \n    \"\"\"\n    # Determine the right appending routine for the file type\n    if file_fmt.lower() == \"csv\":\n        return append_csv_data(file_strings)\n    else:\n        return append_ascii_data(file_strings, tag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends data from multiple files for the same time period and return the new file name", "response": "def append_ascii_data(file_strings, tag):\n    \"\"\" Append data from multiple files for the same time period\n\n    Parameters\n    -----------\n    file_strings : array-like\n        Lists or arrays of strings, where each string contains one file of data\n    tag : string\n        String denoting the type of file to load, accepted values are 'indices',\n        'all', 'stations', and None (for only magnetometer data)\n\n    Returns\n    -------\n    out_string : string\n        String with all data, ready for output to a file\n        \n    \"\"\"\n    import re\n    \n    # Start with data from the first list element\n    out_lines = file_strings[0].split('\\n')\n    iparam = -1 # Index for the parameter line\n    ihead = -1 # Index for the last header line\n    idates = list() # Indices for the date lines\n    date_list = list() # List of dates\n    num_stations = list() # Number of stations for each date line\n    ind_num = 2 if tag in ['all', 'indices', ''] else 0\n    # ind_num = 2 if tag == '' else ind_num\n\n    # Find the index information for the data\n    for i,line in enumerate(out_lines):\n        if line == \"Selected parameters:\":\n            iparam = i + 1\n        elif line.count(\"=\") == len(line) and len(line) > 2:\n            ihead = i\n            break\n\n    # Find the time indices and number of stations for each date line\n    i = ihead + 1\n    while i < len(out_lines) - 1:\n        idates.append(i)\n        lsplit = re.split('\\t+', out_lines[i])\n        dtime = pds.datetime.strptime(\" \".join(lsplit[0:-1]),\n                                      \"%Y %m %d %H %M %S\")\n        date_list.append(dtime)\n        num_stations.append(int(lsplit[-1]))\n        i += num_stations[-1] + 1 + ind_num\n    idates = np.array(idates)\n\n    # Initialize a list of station names\n    station_names = list()\n    \n    # Cycle through each additional set of file strings\n    for ff in range(len(file_strings)-1):\n        file_lines = file_strings[ff+1].split('\\n')\n\n        # Find the index information for the data\n        head = True\n        snum = 0\n        for i,line in enumerate(file_lines):\n            if head:\n                if line.count(\"=\") == len(line) and len(line) > 2:\n                    head = False\n            elif len(line) > 0:\n                lsplit = re.split('\\t+', line)\n                if snum == 0:\n                    dtime = pds.datetime.strptime(\" \".join(lsplit[0:-1]),\n                                                  \"%Y %m %d %H %M %S\")\n                    try:\n                        idate = date_list.index(dtime)\n                    except:\n                        # SuperMAG outputs date lines regardless of the\n                        # number of stations.  These files shouldn't be\n                        # appended together.\n                        raise ValueError(\"Unexpected date \", dtime)\n\n                    snum = int(lsplit[-1])\n                    onum = num_stations[idate]\n                    inum = ind_num\n\n                    # Adjust reference data for new number of station lines\n                    idates[idate+1:] += snum\n                    num_stations[idate] += snum\n\n                    # Adjust date line for new number of station lines\n                    oline = \"{:s}\\t{:d}\".format( \\\n                                    dtime.strftime(\"%Y\\t%m\\t%d\\t%H\\t%M\\t%S\"),\n                                                 num_stations[idate])\n                    out_lines[idates[idate]] = oline\n                else:\n                    if inum > 0:\n                        inum -= 1\n                    else:\n                        # Insert the station line to the end of the date section\n                        onum += 1\n                        snum -= 1\n                        out_lines.insert(idates[idate]+onum, line)\n\n                        # Save the station name to update the parameter line\n                        if not lsplit[0] in station_names:\n                            station_names.append(lsplit[0])\n\n    # Update the parameter line\n    out_lines[iparam] += \",\" + \",\".join(station_names)\n\n    # Join the output lines into a single string\n    out_string = \"\\n\".join(out_lines)\n\n    return out_string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends data from multiple csv files for the same time period and return the new string", "response": "def append_csv_data(file_strings):\n    \"\"\" Append data from multiple csv files for the same time period\n\n    Parameters\n    -----------\n    file_strings : array-like\n        Lists or arrays of strings, where each string contains one file of data\n\n    Returns\n    -------\n    out_string : string\n        String with all data, ready for output to a file\n        \n    \"\"\"\n    # Start with data from the first list element\n    out_lines = list()\n    head_line = None\n\n    # Cycle through the lists of file strings, creating a list of line strings\n    for fstrings in file_strings:\n        file_lines = fstrings.split('\\n')\n\n        # Remove and save the header line\n        head_line = file_lines.pop(0)\n\n        # Save the data lines\n        out_lines.extend(file_lines)\n\n    # Sort the output lines by date and station (first two columns) in place\n    out_lines.sort()\n\n    # Remove all zero-length lines from front, add one to back, and add header\n    i = 0\n    while len(out_lines[i]) == 0:\n        out_lines.pop(i)\n\n    out_lines.insert(0, head_line)\n    out_lines.append('')\n\n    # Join the output lines into a single string\n    out_string = \"\\n\".join(out_lines)\n\n    return out_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init(self):\n    \n    self.custom.add(add_quasi_dipole_coordinates, 'modify')\n    self.custom.add(add_aacgm_coordinates, 'modify')\n    self.custom.add(calculate_ecef_velocity, 'modify')\n    self.custom.add(add_sc_attitude_vectors, 'modify')\n    self.custom.add(add_iri_thermal_plasma, 'modify')\n    self.custom.add(add_hwm_winds_and_ecef_vectors, 'modify')\n    self.custom.add(add_igrf, 'modify')\n    # project simulated vectors onto s/c basis\n    # IGRF\n    # create metadata to be added along with vector projection\n    in_meta = {'desc':'IGRF geomagnetic field expressed in the s/c basis.',\n               'units':'nT'}\n    # project IGRF\n    self.custom.add(project_ecef_vector_onto_sc, 'modify', 'end', 'B_ecef_x', 'B_ecef_y', 'B_ecef_z',\n                                                           'B_sc_x', 'B_sc_y', 'B_sc_z',\n                                                           meta=[in_meta.copy(), in_meta.copy(), in_meta.copy()])\n    # project total wind vector\n    self.custom.add(project_hwm_onto_sc, 'modify')\n    # neutral parameters\n    self.custom.add(add_msis, 'modify')", "response": "Initializes the base class for the base class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(fnames, tag=None, sat_id=None, obs_long=0., obs_lat=0., obs_alt=0., \n                                        TLE1=None, TLE2=None):\n    \"\"\"\t\t          \n    Returns data and metadata in the format required by pysat. Finds position\t\t\n    of satellite in both ECI and ECEF co-ordinates.\n    \n    Routine is directly called by pysat and not the user.\t\t\n    \t\t\n    Parameters\t\t\n    ----------\t\t\n    fnames : list-like collection\t\t\n        File name that contains date in its name. \t\t\n    tag : string\t\t\n        Identifies a particular subset of satellite data\t\t\n    sat_id : string\t\t\n        Satellite ID\t\t\t\n    obs_long: float\t\t\n        Longitude of the observer on the Earth's surface\t\t\n    obs_lat: float\t\t\n        Latitude of the observer on the Earth's surface\t\t\t\n    obs_alt: float\t\t\n        Altitude of the observer on the Earth's surface\t\t\n    TLE1 : string\n        First string for Two Line Element. Must be in TLE format\t          \n    TLE2 : string\n        Second string for Two Line Element. Must be in TLE format\t          \n        \n    Example\n    -------\n      inst = pysat.Instrument('pysat', 'sgp4', \n              TLE1='1 25544U 98067A   18135.61844383  .00002728  00000-0  48567-4 0  9998',\n              TLE2='2 25544  51.6402 181.0633 0004018  88.8954  22.2246 15.54059185113452')\n      inst.load(2018, 1)\n      \n    \"\"\"          \n    \n    import sgp4\n    # wgs72 is the most commonly used gravity model in satellite tracking community\n    from sgp4.earth_gravity import wgs72\n    from sgp4.io import twoline2rv\n    import ephem\n    import pysatMagVect\n\n    # TLEs (Two Line Elements for ISS)   \n    # format of TLEs is fixed and available from wikipedia... \n    # lines encode list of orbital elements of an Earth-orbiting object \n    # for a given point in time        \n    line1 = ('1 25544U 98067A   18135.61844383  .00002728  00000-0  48567-4 0  9998')\n    line2 = ('2 25544  51.6402 181.0633 0004018  88.8954  22.2246 15.54059185113452')\n    # use ISS defaults if not provided by user\n    if TLE1 is not None:\n        line1 = TLE1\n    if TLE2 is not None:\n        line2 = TLE2\n    \n    # create satellite from TLEs and assuming a gravity model\n    # according to module webpage, wgs72 is common\n    satellite = twoline2rv(line1, line2, wgs72)\n\n    # grab date from filename\n    parts = os.path.split(fnames[0])[-1].split('-')\n    yr = int(parts[0])\n    month = int(parts[1])\n    day = int(parts[2][0:2])\n    date = pysat.datetime(yr, month, day)\n    \n    # create timing at 1 Hz (for 1 day)\n    times = pds.date_range(start=date, end=date+pds.DateOffset(seconds=86399), freq='1S')\n    # reduce requirements if on testing server\n    # TODO Remove this when testing resources are higher\n    on_travis = os.environ.get('ONTRAVIS') == 'True'\n    if on_travis:\n        times = times[0:100]\n        \n    # create list to hold satellite position, velocity\n    position = []\n    velocity = []\n    for time in times:\n        # orbit propagator - computes x,y,z position and velocity\n        pos, vel = satellite.propagate(time.year, time.month, time.day, \n                                       time.hour, time.minute, time.second)\n        # print (pos)\n        position.extend(pos)\n        velocity.extend(vel)\n        \n    # put data into DataFrame\n    data = pysat.DataFrame({'position_eci_x': position[::3], \n                            'position_eci_y': position[1::3], \n                            'position_eci_z': position[2::3],\n                            'velocity_eci_x': velocity[::3], \n                            'velocity_eci_y': velocity[1::3], \n                            'velocity_eci_z': velocity[2::3]}, \n                            index=times)\n    data.index.name = 'Epoch'\n    \n    # add position and velocity in ECEF\n    # add call for GEI/ECEF translation here\n    # instead, since available, I'll use an orbit predictor from another\n    # package that outputs in ECEF\n    # it also supports ground station calculations\n    \n    # the observer's (ground station) position on the Earth surface\n    site = ephem.Observer()\n    site.lon = str(obs_long)   \n    site.lat = str(obs_lat)   \n    site.elevation = obs_alt \n    \n    # The first parameter in readtle() is the satellite name\n    sat = ephem.readtle('pysat' , line1, line2)\n    output_params = []\n    for time in times:\n        lp = {}\n        site.date = time\n        sat.compute(site)\n        # parameters relative to the ground station\n        lp['obs_sat_az_angle'] = ephem.degrees(sat.az)\n        lp['obs_sat_el_angle'] = ephem.degrees(sat.alt)\n        # total distance away\n        lp['obs_sat_slant_range'] = sat.range\n        # satellite location \n        # sub latitude point\n        lp['glat'] = np.degrees(sat.sublat)\n        # sublongitude point\n        lp['glong'] = np.degrees(sat.sublong)\n        # elevation of sat in m, stored as km\n        lp['alt'] = sat.elevation/1000.\n        # get ECEF position of satellite\n        lp['x'], lp['y'], lp['z'] = pysatMagVect.geodetic_to_ecef(lp['glat'], lp['glong'], lp['alt'])\n        output_params.append(lp)\n    output = pds.DataFrame(output_params, index=times)\n    # modify input object to include calculated parameters\n    data[['glong', 'glat', 'alt']] = output[['glong', 'glat', 'alt']]\n    data[['position_ecef_x', 'position_ecef_y', 'position_ecef_z']] = output[['x', 'y', 'z']]\n    data['obs_sat_az_angle'] = output['obs_sat_az_angle']\n    data['obs_sat_el_angle'] = output['obs_sat_el_angle']\n    data['obs_sat_slant_range'] = output['obs_sat_slant_range']\n    return data, meta.copy()", "response": "Load data and metadata from a list - like file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_files(tag=None, sat_id=None, data_path=None, format_str=None):\n    \n    index = pds.date_range(pysat.datetime(2017,12,1), pysat.datetime(2018,12,1)) \n    # file list is effectively just the date in string format - '%D' works only in Mac. '%x' workins in both Windows and Mac\n    names = [ data_path+date.strftime('%Y-%m-%d')+'.nofile' for date in index]\n    return pysat.Series(names, index=index)", "response": "Produce a fake list of files spanning a year"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_sc_attitude_vectors(inst):\n    \n    \"\"\"\n    Add attitude vectors for spacecraft assuming ram pointing. \n     \n    Presumes spacecraft is pointed along the velocity vector (x), z is\n    generally nadir pointing (positive towards Earth), and y completes the \n    right handed system (generally southward).\n    \n    Notes\n    -----\n        Expects velocity and position of spacecraft in Earth Centered\n        Earth Fixed (ECEF) coordinates to be in the instrument object\n        and named velocity_ecef_* (*=x,y,z) and position_ecef_* (*=x,y,z)\n    \n        Adds attitude vectors for spacecraft in the ECEF basis by calculating the scalar\n        product of each attitude vector with each component of ECEF. \n\n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Instrument object\n        \n    Returns\n    -------\n    None\n        Modifies pysat.Instrument object in place to include S/C attitude unit\n        vectors, expressed in ECEF basis. Vectors are named sc_(x,y,z)hat_ecef_(x,y,z).\n        sc_xhat_ecef_x is the spacecraft unit vector along x (positive along velocity vector)\n        reported in ECEF, ECEF x-component.\n\n    \"\"\"\n    import pysatMagVect\n\n    # ram pointing is along velocity vector\n    inst['sc_xhat_ecef_x'], inst['sc_xhat_ecef_y'], inst['sc_xhat_ecef_z'] = \\\n        pysatMagVect.normalize_vector(inst['velocity_ecef_x'], inst['velocity_ecef_y'], inst['velocity_ecef_z'])\n    \n    # begin with z along Nadir (towards Earth)\n    # if orbit isn't perfectly circular, then the s/c z vector won't\n    # point exactly along nadir. However, nadir pointing is close enough\n    # to the true z (in the orbital plane) that we can use it to get y, \n    # and use x and y to get the real z\n    inst['sc_zhat_ecef_x'], inst['sc_zhat_ecef_y'], inst['sc_zhat_ecef_z'] = \\\n        pysatMagVect.normalize_vector(-inst['position_ecef_x'], -inst['position_ecef_y'], -inst['position_ecef_z'])    \n    \n    # get y vector assuming right hand rule\n    # Z x X = Y\n    inst['sc_yhat_ecef_x'], inst['sc_yhat_ecef_y'], inst['sc_yhat_ecef_z'] = \\\n        pysatMagVect.cross_product(inst['sc_zhat_ecef_x'], inst['sc_zhat_ecef_y'], inst['sc_zhat_ecef_z'],\n                                   inst['sc_xhat_ecef_x'], inst['sc_xhat_ecef_y'], inst['sc_xhat_ecef_z'])\n    # normalize since Xhat and Zhat from above may not be orthogonal\n    inst['sc_yhat_ecef_x'], inst['sc_yhat_ecef_y'], inst['sc_yhat_ecef_z'] = \\\n        pysatMagVect.normalize_vector(inst['sc_yhat_ecef_x'], inst['sc_yhat_ecef_y'], inst['sc_yhat_ecef_z'])\n    \n    # strictly, need to recalculate Zhat so that it is consistent with RHS\n    # just created\n    # Z = X x Y      \n    inst['sc_zhat_ecef_x'], inst['sc_zhat_ecef_y'], inst['sc_zhat_ecef_z'] = \\\n        pysatMagVect.cross_product(inst['sc_xhat_ecef_x'], inst['sc_xhat_ecef_y'], inst['sc_xhat_ecef_z'],\n                                   inst['sc_yhat_ecef_x'], inst['sc_yhat_ecef_y'], inst['sc_yhat_ecef_z'])\n    \n    # Adding metadata\n    inst.meta['sc_xhat_ecef_x'] = {'units':'', \n                                   'desc':'S/C attitude (x-direction, ram) unit vector, expressed in ECEF basis, x-component'}\n    inst.meta['sc_xhat_ecef_y'] = {'units':'',\n                                   'desc':'S/C attitude (x-direction, ram) unit vector, expressed in ECEF basis, y-component'}\n    inst.meta['sc_xhat_ecef_z'] = {'units':'',\n                                   'desc':'S/C attitude (x-direction, ram) unit vector, expressed in ECEF basis, z-component'}\n    \n    inst.meta['sc_zhat_ecef_x'] = {'units':'',\n                                   'desc':'S/C attitude (z-direction, generally nadir) unit vector, expressed in ECEF basis, x-component'}\n    inst.meta['sc_zhat_ecef_y'] = {'units':'',\n                                   'desc':'S/C attitude (z-direction, generally nadir) unit vector, expressed in ECEF basis, y-component'}\n    inst.meta['sc_zhat_ecef_z'] = {'units':'',\n                                   'desc':'S/C attitude (z-direction, generally nadir) unit vector, expressed in ECEF basis, z-component'}\n    \n    inst.meta['sc_yhat_ecef_x'] = {'units':'',\n                                   'desc':'S/C attitude (y-direction, generally south) unit vector, expressed in ECEF basis, x-component'}\n    inst.meta['sc_yhat_ecef_y'] = {'units':'',\n                                   'desc':'S/C attitude (y-direction, generally south) unit vector, expressed in ECEF basis, y-component'}\n    inst.meta['sc_yhat_ecef_z'] = {'units':'',\n                                   'desc':'S/C attitude (y-direction, generally south) unit vector, expressed in ECEF basis, z-component'}    \n    \n    # check what magnitudes we get\n    mag = np.sqrt(inst['sc_zhat_ecef_x']**2 + inst['sc_zhat_ecef_y']**2 + \n                    inst['sc_zhat_ecef_z']**2)\n    idx, = np.where( (mag < .999999999) | (mag > 1.000000001))\n    if len(idx) > 0:\n        print (mag[idx])\n        raise RuntimeError('Unit vector generation failure. Not sufficently orthogonal.')\n\n    return", "response": "Adds the vector vectors for spacecraft assuming ram pointing."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_ecef_velocity(inst):\n    \n    x = inst['position_ecef_x']\n    vel_x = (x.values[2:] - x.values[0:-2])/2.\n\n    y = inst['position_ecef_y']\n    vel_y = (y.values[2:] - y.values[0:-2])/2.\n\n    z = inst['position_ecef_z']\n    vel_z = (z.values[2:] - z.values[0:-2])/2.\n    \n    inst[1:-1, 'velocity_ecef_x'] = vel_x\n    inst[1:-1, 'velocity_ecef_y'] = vel_y\n    inst[1:-1, 'velocity_ecef_z'] = vel_z\n    \n    inst.meta['velocity_ecef_x'] = {'units':'km/s',\n                                    'desc':'Velocity of satellite calculated with respect to ECEF frame.'}\n    inst.meta['velocity_ecef_y'] = {'units':'km/s',\n                                    'desc':'Velocity of satellite calculated with respect to ECEF frame.'}\n    inst.meta['velocity_ecef_z'] = {'units':'km/s',\n                                    'desc':'Velocity of satellite calculated with respect to ECEF frame.'}\n    return", "response": "Calculates the spacecraft velocity in ECEF frame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding quasi - dipole coordinates to an existing object.", "response": "def add_quasi_dipole_coordinates(inst, glat_label='glat', glong_label='glong', \n                                       alt_label='alt'):\n    \"\"\" \n    Uses Apexpy package to add quasi-dipole coordinates to instrument object.\n    \n    The Quasi-Dipole coordinate system includes both the tilt and offset of the \n    geomagnetic field to calculate the latitude, longitude, and local time\n    of the spacecraft with respect to the geomagnetic field.\n    \n    This system is preferred over AACGM near the equator for LEO satellites.\n    \n    Example\n    -------\n        # function added velow modifies the inst object upon every inst.load call\n        inst.custom.add(add_quasi_dipole_coordinates, 'modify', glat_label='custom_label')\n    \n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Designed with pysat_sgp4 in mind\n    glat_label : string\n        label used in inst to identify WGS84 geodetic latitude (degrees)\n    glong_label : string\n        label used in inst to identify WGS84 geodetic longitude (degrees)\n    alt_label : string\n        label used in inst to identify WGS84 geodetic altitude (km, height above surface)\n        \n    Returns\n    -------\n    inst\n        Input pysat.Instrument object modified to include quasi-dipole coordinates, 'qd_lat'\n        for magnetic latitude, 'qd_long' for longitude, and 'mlt' for magnetic local time.\n        \n    \"\"\"\n        \n    import apexpy\n    ap = apexpy.Apex(date=inst.date)\n    \n    qd_lat = []; qd_lon = []; mlt = []\n    for lat, lon, alt, time in zip(inst[glat_label], inst[glong_label], inst[alt_label], \n                                   inst.data.index):\n        # quasi-dipole latitude and longitude from geodetic coords\n        tlat, tlon = ap.geo2qd(lat, lon, alt)\n        qd_lat.append(tlat)\n        qd_lon.append(tlon)\n        mlt.append(ap.mlon2mlt(tlon, time))\n        \n    inst['qd_lat'] = qd_lat\n    inst['qd_long'] = qd_lon\n    inst['mlt'] = mlt\n    \n    inst.meta['qd_lat'] = {'units':'degrees','long_name':'Quasi dipole latitude'}\n    inst.meta['qd_long'] = {'units':'degrees','long_name':'Quasi dipole longitude'}\n    inst.meta['qd_mlt'] = {'units':'hrs','long_name':'Magnetic local time'}    \n    \n    return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_aacgm_coordinates(inst, glat_label='glat', glong_label='glong', \n                                       alt_label='alt'):\n    \"\"\" \n    Uses AACGMV2 package to add AACGM coordinates to instrument object.\n    \n    The Altitude Adjusted Corrected Geomagnetic Coordinates library is used\n    to calculate the latitude, longitude, and local time\n    of the spacecraft with respect to the geomagnetic field.\n    \n    Example\n    -------\n        # function added velow modifies the inst object upon every inst.load call\n        inst.custom.add(add_quasi_dipole_coordinates, 'modify', glat_label='custom_label')\n    \n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Designed with pysat_sgp4 in mind\n    glat_label : string\n        label used in inst to identify WGS84 geodetic latitude (degrees N)\n    glong_label : string\n        label used in inst to identify WGS84 geodetic longitude (degrees E)\n    alt_label : string\n        label used in inst to identify WGS84 geodetic altitude (km, height above surface)\n        \n    Returns\n    -------\n    inst\n        Input pysat.Instrument object modified to include quasi-dipole coordinates, 'aacgm_lat'\n        for magnetic latitude, 'aacgm_long' for longitude, and 'aacgm_mlt' for magnetic local time.\n        \n    \"\"\"\n        \n    import aacgmv2\n\n    aalat = []; aalon = []; mlt = []\n    for lat, lon, alt, time in zip(inst[glat_label], inst[glong_label], inst[alt_label], \n                                   inst.data.index):\n        # aacgmv2 latitude and longitude from geodetic coords\n        tlat, tlon, tmlt = aacgmv2.get_aacgm_coord(lat, lon, alt, time)\n        aalat.append(tlat)\n        aalon.append(tlon)\n        mlt.append(tmlt)\n        \n    inst['aacgm_lat'] = aalat\n    inst['aacgm_long'] = aalon\n    inst['aacgm_mlt'] = mlt\n    \n    inst.meta['aacgm_lat'] = {'units':'degrees','long_name':'AACGM latitude'}\n    inst.meta['aacgm_long'] = {'units':'degrees','long_name':'AACGM longitude'}\n    inst.meta['aacgm_mlt'] = {'units':'hrs','long_name':'AACGM Magnetic local time'}    \n    \n    return", "response": "Adds quasi - dipole coordinates to the AACGM V2 library."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new thermal plasma parameter to an existing object.", "response": "def add_iri_thermal_plasma(inst, glat_label='glat', glong_label='glong', \n                                 alt_label='alt'):\n    \"\"\" \n    Uses IRI (International Reference Ionosphere) model to simulate an ionosphere.\n    \n    Uses pyglow module to run IRI. Configured to use actual solar parameters to run \n    model.\n    \n    Example\n    -------\n        # function added velow modifies the inst object upon every inst.load call\n        inst.custom.add(add_iri_thermal_plasma, 'modify', glat_label='custom_label')\n    \n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Designed with pysat_sgp4 in mind\n    glat_label : string\n        label used in inst to identify WGS84 geodetic latitude (degrees)\n    glong_label : string\n        label used in inst to identify WGS84 geodetic longitude (degrees)\n    alt_label : string\n        label used in inst to identify WGS84 geodetic altitude (km, height above surface)\n        \n    Returns\n    -------\n    inst\n        Input pysat.Instrument object modified to include thermal plasma parameters.\n        'ion_temp' for ion temperature in Kelvin\n        'e_temp' for electron temperature in Kelvin\n        'ion_dens' for the total ion density (O+ and H+)\n        'frac_dens_o' for the fraction of total density that is O+\n        'frac_dens_h' for the fraction of total density that is H+\n        \n    \"\"\"\n\n    import pyglow\n    from pyglow.pyglow import Point\n    \n    iri_params = []\n    # print 'IRI Simulations'\n    for time,lat,lon,alt in zip(inst.data.index, inst[glat_label], inst[glong_label], inst[alt_label]):\n        # Point class is instantiated. Its parameters are a function of time and spatial location\n        pt = Point(time,lat,lon,alt)\n        pt.run_iri()\n        iri = {}\n        # After the model is run, its members like Ti, ni[O+], etc. can be accessed\n        iri['ion_temp'] = pt.Ti\n        iri['e_temp'] = pt.Te\n        iri['ion_dens'] = pt.ni['O+'] + pt.ni['H+'] + pt.ni['HE+']#pt.ne - pt.ni['NO+'] - pt.ni['O2+'] - pt.ni['HE+']\n        iri['frac_dens_o'] = pt.ni['O+']/iri['ion_dens']\n        iri['frac_dens_h'] = pt.ni['H+']/iri['ion_dens']\n        iri['frac_dens_he'] = pt.ni['HE+']/iri['ion_dens']\n        iri_params.append(iri)        \n    # print 'Complete.'\n    iri = pds.DataFrame(iri_params)\n    iri.index = inst.data.index\n    inst[iri.keys()] = iri\n    \n    inst.meta['ion_temp'] = {'units':'Kelvin','long_name':'Ion Temperature'}\n    inst.meta['ion_dens'] = {'units':'N/cc','long_name':'Ion Density',\n                             'desc':'Total ion density including O+ and H+ from IRI model run.'}\n    inst.meta['frac_dens_o'] = {'units':'','long_name':'Fractional O+ Density'}\n    inst.meta['frac_dens_h'] = {'units':'','long_name':'Fractional H+ Density'}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the HWM winds and ECEF vectors to the base solar model.", "response": "def add_hwm_winds_and_ecef_vectors(inst, glat_label='glat', glong_label='glong', \n                                         alt_label='alt'):\n    \"\"\" \n    Uses HWM (Horizontal Wind Model) model to obtain neutral wind details.\n    \n    Uses pyglow module to run HWM. Configured to use actual solar parameters to run \n    model.\n    \n    Example\n    -------\n        # function added velow modifies the inst object upon every inst.load call\n        inst.custom.add(add_hwm_winds_and_ecef_vectors, 'modify', glat_label='custom_label')\n    \n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Designed with pysat_sgp4 in mind\n    glat_label : string\n        label used in inst to identify WGS84 geodetic latitude (degrees)\n    glong_label : string\n        label used in inst to identify WGS84 geodetic longitude (degrees)\n    alt_label : string\n        label used in inst to identify WGS84 geodetic altitude (km, height above surface)\n        \n    Returns\n    -------\n    inst\n        Input pysat.Instrument object modified to include HWM winds.\n        'zonal_wind' for the east/west winds (u in model) in m/s\n        'meiridional_wind' for the north/south winds (v in model) in m/s\n        'unit_zonal_wind_ecef_*' (*=x,y,z) is the zonal vector expressed in the ECEF basis\n        'unit_mer_wind_ecef_*' (*=x,y,z) is the meridional vector expressed in the ECEF basis\n        'sim_inst_wind_*' (*=x,y,z) is the projection of the total wind vector onto s/c basis\n        \n    \"\"\"\n\n    import pyglow\n    import pysatMagVect\n\n    hwm_params = []\n    for time,lat,lon,alt in zip(inst.data.index, inst[glat_label], inst[glong_label], inst[alt_label]):\n        # Point class is instantiated. \n        # Its parameters are a function of time and spatial location\n        pt = pyglow.Point(time,lat,lon,alt)\n        pt.run_hwm()\n        hwm = {}\n        hwm['zonal_wind'] = pt.u\n        hwm['meridional_wind'] = pt.v\n        hwm_params.append(hwm)        \n    # print 'Complete.'\n    hwm = pds.DataFrame(hwm_params)\n    hwm.index = inst.data.index\n    inst[['zonal_wind', 'meridional_wind']] = hwm[['zonal_wind', 'meridional_wind']]\n    \n    # calculate zonal unit vector in ECEF\n    # zonal wind: east - west; positive east\n    # EW direction is tangent to XY location of S/C in ECEF coordinates\n    mag = np.sqrt(inst['position_ecef_x']**2 + inst['position_ecef_y']**2)\n    inst['unit_zonal_wind_ecef_x'] = -inst['position_ecef_y']/mag\n    inst['unit_zonal_wind_ecef_y'] = inst['position_ecef_x']/mag\n    inst['unit_zonal_wind_ecef_z'] = 0*inst['position_ecef_x']\n    \n    # calculate meridional unit vector in ECEF\n    # meridional wind: north - south; positive north\n    # mer direction completes RHS of position and zonal vector\n    unit_pos_x, unit_pos_y, unit_pos_z = \\\n        pysatMagVect.normalize_vector(-inst['position_ecef_x'], -inst['position_ecef_y'], -inst['position_ecef_z'])    \n    \n    # mer = r x zonal\n    inst['unit_mer_wind_ecef_x'], inst['unit_mer_wind_ecef_y'], inst['unit_mer_wind_ecef_z'] = \\\n        pysatMagVect.cross_product(unit_pos_x, unit_pos_y, unit_pos_z,\n                                   inst['unit_zonal_wind_ecef_x'], inst['unit_zonal_wind_ecef_y'], inst['unit_zonal_wind_ecef_z'])\n    \n    # Adding metadata information                                \n    inst.meta['zonal_wind'] = {'units':'m/s','long_name':'Zonal Wind', \n                               'desc':'HWM model zonal wind'}\n    inst.meta['meridional_wind'] = {'units':'m/s','long_name':'Meridional Wind', \n                                    'desc':'HWM model meridional wind'}\n    inst.meta['unit_zonal_wind_ecef_x'] = {'units':'',\n                                           'long_name':'Zonal Wind Unit ECEF x-vector', \n                                           'desc':'x-value of zonal wind unit vector in ECEF co ordinates'}\n    inst.meta['unit_zonal_wind_ecef_y'] = {'units':'', \n                                           'long_name':'Zonal Wind Unit ECEF y-vector', \n                                           'desc':'y-value of zonal wind unit vector in ECEF co ordinates'}\n    inst.meta['unit_zonal_wind_ecef_z'] = {'units':'',\n                                           'long_name':'Zonal Wind Unit ECEF z-vector', \n                                           'desc':'z-value of zonal wind unit vector in ECEF co ordinates'}\n    inst.meta['unit_mer_wind_ecef_x'] = {'units':'',\n                                         'long_name':'Meridional Wind Unit ECEF x-vector', \n                                         'desc':'x-value of meridional wind unit vector in ECEF co ordinates'}\n    inst.meta['unit_mer_wind_ecef_y'] = {'units':'',\n                                         'long_name':'Meridional Wind Unit ECEF y-vector', \n                                         'desc':'y-value of meridional wind unit vector in ECEF co ordinates'}\n    inst.meta['unit_mer_wind_ecef_z'] = {'units':'',\n                                         'long_name':'Meridional Wind Unit ECEF z-vector', \n                                         'desc':'z-value of meridional wind unit vector in ECEF co ordinates'}\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_igrf(inst, glat_label='glat', glong_label='glong', \n                                       alt_label='alt'):\n    \"\"\" \n    Uses International Geomagnetic Reference Field (IGRF) model to obtain geomagnetic field values.\n    \n    Uses pyglow module to run IGRF. Configured to use actual solar parameters to run \n    model.\n    \n    Example\n    -------\n        # function added velow modifies the inst object upon every inst.load call\n        inst.custom.add(add_igrf, 'modify', glat_label='custom_label')\n    \n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Designed with pysat_sgp4 in mind\n    glat_label : string\n        label used in inst to identify WGS84 geodetic latitude (degrees)\n    glong_label : string\n        label used in inst to identify WGS84 geodetic longitude (degrees)\n    alt_label : string\n        label used in inst to identify WGS84 geodetic altitude (km, height above surface)\n        \n    Returns\n    -------\n    inst\n        Input pysat.Instrument object modified to include HWM winds.\n        'B' total geomagnetic field\n        'B_east' Geomagnetic field component along east/west directions (+ east)\n        'B_north' Geomagnetic field component along north/south directions (+ north)\n        'B_up' Geomagnetic field component along up/down directions (+ up)\n        'B_ecef_x' Geomagnetic field component along ECEF x\n        'B_ecef_y' Geomagnetic field component along ECEF y\n        'B_ecef_z' Geomagnetic field component along ECEF z\n        \n    \"\"\"\n    \n    import pyglow\n    from pyglow.pyglow import Point\n    import pysatMagVect\n    \n    igrf_params = []\n    # print 'IRI Simulations'\n    for time,lat,lon,alt in zip(inst.data.index, inst[glat_label], inst[glong_label], inst[alt_label]):\n        pt = Point(time,lat,lon,alt)\n        pt.run_igrf()\n        igrf = {}\n        igrf['B'] = pt.B\n        igrf['B_east'] = pt.Bx\n        igrf['B_north'] = pt.By\n        igrf['B_up'] = pt.Bz\n        igrf_params.append(igrf)        \n    # print 'Complete.'\n    igrf = pds.DataFrame(igrf_params)\n    igrf.index = inst.data.index\n    inst[igrf.keys()] = igrf\n    \n    # convert magnetic field in East/north/up to ECEF basis\n    x, y, z = pysatMagVect.enu_to_ecef_vector(inst['B_east'], inst['B_north'], inst['B_up'],\n                                              inst[glat_label], inst[glong_label])\n    inst['B_ecef_x'] = x\n    inst['B_ecef_y'] = y\n    inst['B_ecef_z'] = z\n    \n    # metadata\n    inst.meta['B'] = {'units':'nT',\n                      'desc':'Total geomagnetic field from IGRF.'}\n    inst.meta['B_east'] = {'units':'nT',\n                           'desc':'Geomagnetic field from IGRF expressed using the East/North/Up (ENU) basis.'}\n    inst.meta['B_north'] = {'units':'nT',\n                            'desc':'Geomagnetic field from IGRF expressed using the East/North/Up (ENU) basis.'}\n    inst.meta['B_up'] = {'units':'nT',\n                         'desc':'Geomagnetic field from IGRF expressed using the East/North/Up (ENU) basis.'}\n\n    inst.meta['B_ecef_x'] = {'units':'nT',\n                             'desc':'Geomagnetic field from IGRF expressed using the Earth Centered Earth Fixed (ECEF) basis.'}\n    inst.meta['B_ecef_y'] = {'units':'nT',\n                             'desc':'Geomagnetic field from IGRF expressed using the Earth Centered Earth Fixed (ECEF) basis.'}\n    inst.meta['B_ecef_z'] = {'units':'nT',\n                             'desc':'Geomagnetic field from IGRF expressed using the Earth Centered Earth Fixed (ECEF) basis.'}\n    return", "response": "Adds IGRF model to run IGRF model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_msis(inst, glat_label='glat', glong_label='glong', \n                                       alt_label='alt'):\n    \"\"\" \n    Uses MSIS model to obtain thermospheric values.\n    \n    Uses pyglow module to run MSIS. Configured to use actual solar parameters to run \n    model.\n    \n    Example\n    -------\n        # function added velow modifies the inst object upon every inst.load call\n        inst.custom.add(add_msis, 'modify', glat_label='custom_label')\n    \n    Parameters\n    ----------\n    inst : pysat.Instrument\n        Designed with pysat_sgp4 in mind\n    glat_label : string\n        label used in inst to identify WGS84 geodetic latitude (degrees)\n    glong_label : string\n        label used in inst to identify WGS84 geodetic longitude (degrees)\n    alt_label : string\n        label used in inst to identify WGS84 geodetic altitude (km, height above surface)\n        \n    Returns\n    -------\n    inst\n        Input pysat.Instrument object modified to include MSIS values winds.\n        'Nn' total neutral density particles/cm^3\n        'Nn_N' Nitrogen number density (particles/cm^3)\n        'Nn_N2' N2 number density (particles/cm^3)\n        'Nn_O' Oxygen number density (particles/cm^3)\n        'Nn_O2' O2 number density (particles/cm^3)\n        'Tn_msis' Temperature from MSIS (Kelvin)\n        \n    \"\"\"\n    \n    import pyglow\n    from pyglow.pyglow import Point\n    \n    msis_params = []\n    # print 'IRI Simulations'\n    for time,lat,lon,alt in zip(inst.data.index, inst[glat_label], inst[glong_label], inst[alt_label]):\n        pt = Point(time,lat,lon,alt)\n        pt.run_msis()\n        msis = {}\n        total = 0\n        for key in pt.nn.keys():\n            total += pt.nn[key]\n        msis['Nn'] = total\n        msis['Nn_N'] = pt.nn['N']\n        msis['Nn_N2'] = pt.nn['N2']\n        msis['Nn_O'] = pt.nn['O']\n        msis['Nn_O2'] = pt.nn['O2']\n        msis['Tn_msis'] = pt.Tn_msis\n        msis_params.append(msis)        \n    # print 'Complete.'\n    msis = pds.DataFrame(msis_params)\n    msis.index = inst.data.index\n    inst[msis.keys()] = msis\n    \n    # metadata\n    inst.meta['Nn'] = {'units':'cm^-3',\n                       'desc':'Total neutral number particle density from MSIS.'}\n    inst.meta['Nn_N'] = {'units':'cm^-3',\n                         'desc':'Total nitrogen number particle density from MSIS.'}\n    inst.meta['Nn_N2'] = {'units':'cm^-3',\n                          'desc':'Total N2 number particle density from MSIS.'}\n    inst.meta['Nn_O'] = {'units':'cm^-3',\n                         'desc':'Total oxygen number particle density from MSIS.'}\n    inst.meta['Nn_O2'] = {'units':'cm^-3',\n                          'desc':'Total O2 number particle density from MSIS.'}\n    inst.meta['Tn_msis'] = {'units':'K',\n                            'desc':'Neutral temperature from MSIS.'}\n\n    return", "response": "Adds MSIS values to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprojecting an ECEF vector onto the SC basis.", "response": "def project_ecef_vector_onto_sc(inst, x_label, y_label, z_label, \n                                new_x_label, new_y_label, new_z_label,\n                                meta=None):\n    \"\"\"Express input vector using s/c attitude directions\n    \n    x - ram pointing\n    y - generally southward\n    z - generally nadir\n    \n    Parameters\n    ----------\n    x_label : string\n        Label used to get ECEF-X component of vector to be projected\n    y_label : string\n        Label used to get ECEF-Y component of vector to be projected\n    z_label : string\n        Label used to get ECEF-Z component of vector to be projected\n    new_x_label : string\n        Label used to set X component of projected vector\n    new_y_label : string\n        Label used to set Y component of projected vector\n    new_z_label : string\n        Label used to set Z component of projected vector\n    meta : array_like of dicts (None)\n        Dicts contain metadata to be assigned.\n    \"\"\"\n    \n    import pysatMagVect\n\n    x, y, z = pysatMagVect.project_ecef_vector_onto_basis(inst[x_label], inst[y_label], inst[z_label],\n                                                          inst['sc_xhat_ecef_x'], inst['sc_xhat_ecef_y'], inst['sc_xhat_ecef_z'],\n                                                          inst['sc_yhat_ecef_x'], inst['sc_yhat_ecef_y'], inst['sc_yhat_ecef_z'],\n                                                          inst['sc_zhat_ecef_x'], inst['sc_zhat_ecef_y'], inst['sc_zhat_ecef_z'])\n    inst[new_x_label] = x\n    inst[new_y_label] = y\n    inst[new_z_label] = z\n    \n    if meta is not None:\n        inst.meta[new_x_label] = meta[0]\n        inst.meta[new_y_label] = meta[1]\n        inst.meta[new_z_label] = meta[2]\n    \n    return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scatterplot(inst, labelx, labely, data_label, datalim, xlim=None, ylim=None):\n\n    # interactive plotting off\n    plt.ioff()\n    \n    # create figures for plotting\n    figs = []\n    axs = []\n    \n    # check if doing multiple data quantities\n    if type(data_label) is str:\n        # max of one data type\n        figs.append( plt.figure() )\n        ax1 = figs[0].add_subplot(211, projection='3d')\n        ax2 = figs[0].add_subplot(212)\n        axs.append((ax1, ax2))\n        plt.suptitle(data_label)\n        if xlim is not None:\n            ax1.set_xlim(xlim)\n        ax2.set_xlim(xlim)\n        if ylim is not None:\n            ax1.set_ylim(ylim)\n        ax2.set_ylim(ylim)\n        data_label = [data_label]\n        plt.hold(True)\n    else:\n        # multiple data to be plotted\n        for i in np.arange(len(data_label)):\n            figs.append( plt.figure() )\n            ax1 = figs[i].add_subplot(211, projection='3d')\n            ax2 = figs[i].add_subplot(212)\n            axs.append((ax1, ax2))\n            #axs.append( figs[i].add_subplot(111, projection='3d') )\n            plt.suptitle(data_label[i])              \n            if xlim is not None:\n               ax1.set_xlim(xlim)\n            ax2.set_xlim(xlim)\n            if ylim is not None:\n               ax1.set_ylim(ylim)\n            ax2.set_ylim(ylim)\n            plt.hold(True)\n                \n    # norm method so that data may be scaled to colors appropriately\n    norm = colors.Normalize(vmin=datalim[0], vmax=datalim[1])    \n    p = [i for i in np.arange(len(figs))]\n    for i,inst in enumerate(inst):\n        for j, (fig, ax) in enumerate(zip(figs, axs)):\n            if len(inst.data) > 0:\n                if (len(inst.data[labelx]) > 0) & (len(inst.data[labely]) > 0) & (len(inst.data[data_label[j]]) > 0):\n                    p[j]=ax[0].scatter(inst.data[labelx], inst.data[labely], inst.data[data_label[j]],\n                                       zdir='z', c=inst.data[data_label[j]], cmap=cm.jet, norm=norm,\n                                       linewidth='0', edgecolors=None)\n                    ax[1].scatter(inst.data[labelx], inst.data[labely], c=inst.data[data_label[j]],\n                                  cmap=cm.jet, norm=norm, linewidth=0.00000000001, alpha=0.5, edgecolor=None)\n                \n    for j, (fig, ax) in enumerate(zip(figs, axs)):\n        try:\n            cbar = plt.colorbar(p[j],ax=ax[0], label='Amplitude (m/s)')\n        except:\n            print('Tried colorbar but failed, thus no colorbar.')\n        ax[0].elev=30.\n    # interactive plotting back on\n    plt.ion()\n    return figs", "response": "Returns a list of scatter plots of data_label over a season."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable console logging. This is a utils method for try run with storops. :param level: log level, default to DEBUG", "response": "def enable_log(level=logging.DEBUG):\n    \"\"\"Enable console logging.\n\n    This is a utils method for try run with storops.\n    :param level: log level, default to DEBUG\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    logger.setLevel(level)\n    if not logger.handlers:\n        logger.info('enabling logging to console.')\n        logger.addHandler(logging.StreamHandler(sys.stdout))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a Pandas Series of every file for the chosen satellite data.", "response": "def list_files(tag=None, sat_id=None, data_path=None, format_str=None):\n    \"\"\"Return a Pandas Series of every file for chosen satellite data\n\n    Parameters\n    -----------\n    tag : (string or NoneType)\n        Denotes type of file to load.  Accepted types are '' and 'ascii'.\n        If '' is specified, the primary data type (ascii) is loaded.\n        (default=None)\n    sat_id : (string or NoneType)\n        Specifies the satellite ID for a constellation.  Not used.\n        (default=None)\n    data_path : (string or NoneType)\n        Path to data directory.  If None is specified, the value previously\n        set in Instrument.files.data_path is used.  (default=None)\n    format_str : (NoneType)\n        User specified file format not supported. (default=None)\n\n    Returns\n    --------\n    pysat.Files.from_os : (pysat._files.Files)\n        A class containing the verified available files\n    \"\"\"\n    import sys\n    #if tag == 'ionprf':\n    #    # from_os constructor currently doesn't work because of the variable \n    #    # filename components at the end of each string.....\n    #    ion_fmt = '*/ionPrf_*.{year:04d}.{day:03d}.{hour:02d}.{min:02d}*_nc'\n    #    return pysat.Files.from_os(dir_path=os.path.join('cosmic', 'ionprf'),\n    #                               format_str=ion_fmt)\n    estr = 'Building a list of COSMIC files, which can possibly take time. '\n    estr = '{:s}~1s per 100K files'.format(estr)\n    print(estr)\n    sys.stdout.flush()\n\n    # number of files may be large\n    # only select file that are the cosmic data files and end with _nc\n    cosmicFiles = glob.glob(os.path.join(data_path, '*/*_nc'))\n    # need to get date and time from filename to generate index\n    num = len(cosmicFiles) \n    if num != 0:\n        print('Estimated time:', num*1.E-5,'seconds')\n        sys.stdout.flush()\n        # preallocate lists\n        year=[None]*num; days=[None]*num; hours=[None]*num; \n        minutes=[None]*num; microseconds=[None]*num;\n        for i,f in enumerate(cosmicFiles):\n            f2 = f.split('.')\n            year[i]=f2[-6]\n            days[i]=f2[-5]\n            hours[i]=f2[-4]\n            minutes[i]=f2[-3]\n            microseconds[i]=i\n    \n        year=np.array(year).astype(int)\n        days=np.array(days).astype(int)\n        uts=np.array(hours).astype(int)*3600.+np.array(minutes).astype(int)*60.\n        # adding microseconds to ensure each time is unique, not allowed to\n        # pass 1.E-3 s\n        uts+=np.mod(np.array(microseconds).astype(int)*4, 8000)*1.E-5\n        index = pysat.utils.create_datetime_index(year=year, day=days, uts=uts)\n        file_list = pysat.Series(cosmicFiles, index=index)\n        return file_list\n    else:\n        print('Found no files, check your path or download them.')\n        return pysat.Series(None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nround the number to the multiple of 60", "response": "def round_60(value):\n    \"\"\" round the number to the multiple of 60\n\n    Say a random value is represented by: 60 * n + r\n    n is an integer and r is an integer between 0 and 60.\n    if r < 30, the result is 60 * n.\n    otherwise, the result is 60 * (n + 1)\n\n    The use of this function is that the counter refreshment on\n    VNX is always 1 minute.  So the delta time between samples of\n    counters must be the multiple of 60.\n    :param value: the value to be rounded.\n    :return: result\n    \"\"\"\n    t = 60\n    if value is not None:\n        r = value % t\n        if r > t / 2:\n            ret = value + (t - r)\n        else:\n            ret = value - r\n    else:\n        ret = NaN\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef utilization(prev, curr, counters):\n    busy_prop, idle_prop = counters\n\n    pb = getattr(prev, busy_prop)\n    pi = getattr(prev, idle_prop)\n\n    cb = getattr(curr, busy_prop)\n    ci = getattr(curr, idle_prop)\n\n    db = minus(cb, pb)\n    di = minus(ci, pi)\n\n    return mul(div(db, add(db, di)), 100)", "response": "calculate utilization of a resource node in a resource tree"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the delta per second of one counter formula", "response": "def delta_ps(prev, curr, counters):\n    \"\"\" calculate the delta per second of one counter\n\n    formula: (curr - prev) / delta_time\n    :param prev: previous resource\n    :param curr: current resource\n    :param counters: the counter to do delta and per second, one only\n    :return: value, NaN if invalid.\n    \"\"\"\n    counter = get_counter(counters)\n\n    pv = getattr(prev, counter)\n    cv = getattr(curr, counter)\n    return minus(cv, pv)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef io_size_kb(prev, curr, counters):\n    bw_stats, io_stats = counters\n    size_mb = div(getattr(curr, bw_stats), getattr(curr, io_stats))\n    return mul(size_mb, 1024)", "response": "calculate the io size based on bandwidth and throughput"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_files(tag='', sat_id=None, data_path=None, format_str=None):\n\n    if format_str is None and tag is not None:\n        if tag == '' or tag == 'ascii':\n            ascii_fmt = 'Density_3deg_{year:02d}_{doy:03d}.ascii'\n            return pysat.Files.from_os(data_path=data_path,\n                                       format_str=ascii_fmt)\n        else:\n            raise ValueError('Unrecognized tag name for CHAMP STAR')\n    elif format_str is None:\n        estr = 'A tag name must be passed to the loading routine for CHAMP'\n        raise ValueError(estr)\n    else:\n        return pysat.Files.from_os(data_path=data_path, format_str=format_str)", "response": "Returns a Pandas Series of every file for the chosen satellite."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a CHAMP STAR file into a Pandas DataFrame.", "response": "def load(fnames, tag=None, sat_id=None):\n    \"\"\"Load CHAMP STAR files\n\n    Parameters\n    ------------\n    fnames : (pandas.Series)\n        Series of filenames\n    tag : (str or NoneType)\n        tag or None (default=None)\n    sat_id : (str or NoneType)\n        satellite id or None (default=None)\n\n    Returns\n    ---------\n    data : (pandas.DataFrame)\n        Object containing satellite data\n    meta : (pysat.Meta)\n        Object containing metadata such as column names and units\n    \"\"\"\n    import re\n    if len(fnames) <= 0:\n        return pysat.DataFrame(None), pysat.Meta(None)\n\n    if isinstance(fnames, str):\n        fnames = [fnames]\n\n    # Define the CHAMP STAR data types by column\n    champ_labels = { 'Two-digit Year (years)' : \"year\",\n                     'Day of the Year (days)' : \"doy\",\n                     'Second of the Day (GPS time,sec)' : \"sod\",\n                     'Center Latitude of 3-degree Bin (deg)' : \"bin_lat\",\n                     'Satellite Geodetic Latitude (deg)' : \"sat_glat\",\n                     'Satellite Longitude (deg)' : \"sat_lon\",\n                     'Satellite Height (km)' : \"sat_h\",\n                     'Satellite Local Time (hours)' : \"sat_lt\",\n                     'Satellite Quasi-Dipole Latitude (deg)' : \"sat_qdlat\",\n                     'Satellite Magnetic Longitude (deg)' : \"sat_mlon\",\n                     'Satellite Magnetic Local Time (hours)' : \"sat_mlt\",\n                     'Neutral Density (kg/m^3)' : \"ndens\",\n                     'Neutral Density Normalized to 400km using NRLMSISe00' :\n                     \"ndens400\",\n                     'Neutral Density Normalized to 410km using NRLMSISe00' :\n                     \"ndens410\",\n                     'NRLMSISe00 Neutral Density at Satellite Height' :\n                     \"nrlmsis_ndens\",\n                     'Uncertainty in Neutral Density (kg/m^3)' : \"ndens_err\",\n                     'Number of Data Points in Current Averaging Bin' :\n                     \"npnts\", \\\n    'Number of Points in Current Averaging Bin that Required Interpolation' :\n                     \"npnts_interp\", \\\n    'Average Coefficient of Drag Used in Current Averaging Bin' :\n                     \"avg_drag_coeff\", }\n\n    champ_dtypes = { 'year' : np.int32, 'doy' : np.int32, 'sod' : float,\n                     'bin_lat' : float, 'sat_glat' : float, 'sat_lon' : float,\n                     'sat_h' : float, 'sat_lt' : float, 'sat_qdlat' : float,\n                     'sat_mlon' : float, 'sat_mlt' : float, 'ndens' : float,\n                     'ndens400' : float, 'ndens410' : float,\n                     'nrlmsis_ndens' : float, 'ndens_err' : float,\n                     'npnts' : int, 'npnts_interp' : float,\n                     'avg_drag_coeff' : float, }\n\n    champ_units = { 'year' : \"2-digit years\", 'doy' : \"day of year\",\n                    'sod' : \"seconds of day\", 'bin_lat' : \"degrees\",\n                    'sat_glat' : \"degrees\", 'sat_lon' : \"degrees\",\n                    'sat_h' : \"km\", 'sat_lt' : \"hours\", 'sat_qdlat' : \"degrees\",\n                    'sat_mlon' : \"degrees\", 'sat_mlt' : \"hours\",\n                    'ndens' : \"km m^{-3}\", 'ndens400' : \"km m^{-3}\",\n                    'ndens410' : \"km m^{-3}\", 'nrlmsis_ndens' : \"km m^{-3}\",\n                    'ndens_err' : \"km m^{-3}\", 'npnts' : \"number\",\n                    'npnts_interp' : \"number\", 'avg_drag_coeff' : \"unitless\", }\n\n    # Define the routine needed to create datetime object from the\n    # CHAMP time (YY DDD SSSSS)\n    def parse_champdate(y, d, s):\n        '''parse CHAMP date string (YY DDD SSSSS) into a datetime object\n        '''\n        import datetime as dt\n\n        t = dt.datetime.strptime(\"{:02d} {:03d}\".format(int(y),int(d)), \"%y %j\")\n        fsec = float(s)\n        isec = np.floor(fsec)\n        microsec = (fsec - isec) * 1.0e6\n        t += dt.timedelta(seconds=isec, microseconds=microsec)\n        return(t)\n\n    # The header is formatted differently from the rest of the file, read it in\n    # first to obtain the necessary meta data\n    f = open(fnames[0], \"r\")\n    vdata = re.split( \";|\\n\", f.readline())\n    hdata = re.split( \";|\\n\", f.readline())\n    f.close()\n    try:\n        hdata.pop(hdata.index(''))\n    except:\n        pass\n\n    # If there are files, read in the data\n    data = pds.read_csv(fnames[0], delim_whitespace=True, skiprows=2,\n                        header=None, names=[champ_labels[h] for h in hdata],\n                        keep_date_col=True, index_col='datetime',\n                        parse_dates={'datetime': [0,1,2]},\n                        date_parser=parse_champdate)\n\n    # Initialize the meta data\n    meta = pysat.Meta()\n\n    # Because the native dtype declaration interferred with datetime indexing,\n    # define the data types here.  Also set the meta data\n    for h in hdata:\n        col = champ_labels[h]\n        data[col].astype(champ_dtypes[col])\n        meta[col] = {\"units\":champ_units[col], \"long_name\":h}\n\n    # Return data frame and metadata object\n    return data, meta"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _assign_funcs(self, by_name=False, inst_module=None):        \n        import importlib\n        # set defaults\n        self._list_rtn = self._pass_func\n        self._load_rtn = self._pass_func\n        self._default_rtn = self._pass_func\n        self._clean_rtn = self._pass_func\n        self._init_rtn = self._pass_func\n        self._download_rtn = self._pass_func\n        # default params\n        self.directory_format = None\n        self.file_format = None\n        self.multi_file_day = False\n        self.orbit_info = None\n                        \n        if by_name: \n            # look for code with filename name, any errors passed up\n            inst = importlib.import_module(''.join(('.', self.platform, '_',\n                                           self.name)),\n                                           package='pysat.instruments')\n        elif inst_module is not None:\n            # user supplied an object with relevant instrument routines\n            inst = inst_module\n        else:\n            # no module or name info, default pass functions assigned\n            return\n\n        try:\n            self._load_rtn = inst.load\n            self._list_rtn = inst.list_files\n            self._download_rtn = inst.download\n        except AttributeError:\n            estr = 'A load, file_list, and download routine are required for '\n            raise AttributeError('{:s}every instrument.'.format(estr))\n        try:\n            self._default_rtn = inst.default\n        except AttributeError:\n            pass\n        try:\n            self._init_rtn = inst.init\n        except AttributeError:\n            pass   \n        try:\n            self._clean_rtn = inst.clean\n        except AttributeError:\n            pass\n\n        # look for instrument default parameters\n        try:\n            self.directory_format = inst.directory_format\n        except AttributeError:\n            pass\n        try:\n            self.multi_file_day = inst.multi_file_day\n        except AttributeError:\n            pass\n        try:\n            self.orbit_info = inst.orbit_info\n        except AttributeError:\n            pass\n\n        return", "response": "Assign all external science instrument methods to Instrument object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_data(self, date=None, fid=None):\n\n        if fid is not None:\n            # get filename based off of index value\n            fname = self.files[fid:fid+1]\n        elif date is not None:\n            fname = self.files[date: date+pds.DateOffset(days=1)]\n        else:\n            raise ValueError('Must supply either a date or file id number.')\n   \n        if len(fname) > 0:    \n            load_fname = [os.path.join(self.files.data_path, f) for f in fname]\n            data, mdata = self._load_rtn(load_fname, tag=self.tag,\n                                         sat_id=self.sat_id, **self.kwargs)\n\n            # ensure units and name are named consistently in new Meta\n            # object as specified by user upon Instrument instantiation\n            mdata.accept_default_labels(self)\n\n        else:\n            data = DataFrame(None)\n            mdata = _meta.Meta(units_label=self.units_label, name_label=self.name_label,\n                        notes_label = self.notes_label, desc_label = self.desc_label,\n                        plot_label = self.plot_label, axis_label = self.axis_label,\n                        scale_label = self.scale_label, min_label = self.min_label,\n                        max_label = self.max_label, fill_label=self.fill_label)\n\n        output_str = '{platform} {name} {tag} {sat_id}'\n        output_str = output_str.format(platform=self.platform,\n                                       name=self.name, tag=self.tag, \n                                       sat_id=self.sat_id)\n        if not data.empty: \n            if not isinstance(data, DataFrame):\n                raise TypeError(' '.join(('Data returned by instrument load',\n                                'routine must be a pandas.DataFrame')))\n            if not isinstance(mdata, _meta.Meta):\n                raise TypeError('Metadata returned must be a pysat.Meta object')\n            if date is not None:\n                output_str = ' '.join(('Returning', output_str, 'data for',\n                                       date.strftime('%x')))\n            else:\n                if len(fname) == 1:\n                    # this check was zero\n                    output_str = ' '.join(('Returning', output_str, 'data from',\n                                           fname[0]))\n                else:\n                    output_str = ' '.join(('Returning', output_str, 'data from',\n                                           fname[0], '::', fname[-1]))\n        else:\n            # no data signal\n            output_str = ' '.join(('No', output_str, 'data for',\n                                   date.strftime('%m/%d/%y')))\n        # remove extra spaces, if any\n        output_str = \" \".join(output_str.split())\n        print (output_str)                \n        return data, mdata", "response": "Load data for an instrument on given date or fid."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the next days data or file.", "response": "def _load_next(self):\n        \"\"\"Load the next days data (or file) without incrementing the date.\n        Repeated calls will not advance date/file and will produce the same data\n        \n        Uses info stored in object to either increment the date, \n        or the file. Looks for self._load_by_date flag. \n         \n        \"\"\"\n        if self._load_by_date:\n            next_date = self.date + pds.DateOffset(days=1)\n            return self._load_data(date=next_date)\n        else:\n            return self._load_data(fid=self._fid+1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load_prev(self):\n\n        if self._load_by_date:\n            prev_date = self.date - pds.DateOffset(days=1)\n            return self._load_data(date=prev_date)\n        else:\n            return self._load_data(fid=self._fid-1)", "response": "Load the previous data or file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the data for a chosen instrument into the object. data.", "response": "def load(self, yr=None, doy=None, date=None, fname=None, fid=None, \n             verifyPad=False):\n        \"\"\"Load instrument data into Instrument object .data.\n\n        Parameters\n        ----------\n        yr : integer\n            year for desired data\n        doy : integer\n            day of year\n        date : datetime object\n            date to load\n        fname : 'string'\n            filename to be loaded\n        verifyPad : boolean \n            if True, padding data not removed (debug purposes)\n\n        Returns\n        --------\n        Void.  Data is added to self.data\n\n        Note\n        ----\n        Loads data for a chosen instrument into .data. Any functions chosen\n        by the user and added to the custom processing queue (.custom.add)\n        are automatically applied to the data before it is available to \n        user in .data.\n        \n        \"\"\"\n        # set options used by loading routine based upon user input\n        if date is not None:\n            self._set_load_parameters(date=date, fid=None)\n            # increment \n            inc = pds.DateOffset(days=1)\n            curr = date\n        elif (yr is not None) & (doy is not None):\n            date = pds.datetime(yr, 1, 1) + pds.DateOffset(days=(doy-1))\n            self._set_load_parameters(date=date, fid=None)\n            # increment \n            inc = pds.DateOffset(days=1)\n            curr = self.date\n        elif fname is not None:\n            # date will have to be set later by looking at the data\n            self._set_load_parameters(date=None,\n                                      fid=self.files.get_index(fname))\n            # increment one file at a time\n            inc = 1\n            curr = self._fid.copy()\n        elif fid is not None:\n            self._set_load_parameters(date=None, fid=fid)\n            # increment one file at a time\n            inc = 1\n            curr = fid\n        else:\n            estr = 'Must supply a yr,doy pair, or datetime object, or filename'\n            estr = '{:s} to load data from.'.format(estr)\n            raise TypeError(estr)\n\n        self.orbits._reset()\n        # if pad  or multi_file_day is true, need to have a three day/file load\n        loop_pad = self.pad if self.pad is not None else pds.DateOffset(seconds=0)   \n        if (self.pad is not None) | self.multi_file_day:\n            if self._next_data.empty & self._prev_data.empty:\n                # data has not already been loaded for previous and next days\n                # load data for all three\n                print('Initializing three day/file window')\n                # using current date or fid\n                self._prev_data, self._prev_meta = self._load_prev()\n                self._curr_data, self._curr_meta = \\\n                    self._load_data(date=self.date, fid=self._fid)\n                self._next_data, self._next_meta = self._load_next()\n            else:\n                # moving forward in time\n                if self._next_data_track == curr:\n                    del self._prev_data\n                    self._prev_data = self._curr_data\n                    self._prev_meta = self._curr_meta\n                    self._curr_data = self._next_data\n                    self._curr_meta = self._next_meta\n                    self._next_data, self._next_meta = self._load_next()\n                # moving backward in time\n                elif self._prev_data_track == curr:\n                    del self._next_data\n                    self._next_data = self._curr_data\n                    self._next_meta = self._curr_meta\n                    self._curr_data = self._prev_data\n                    self._curr_meta = self._prev_meta\n                    self._prev_data, self._prev_meta = self._load_prev()\n                # jumped in time/or switched from filebased to date based access\n                else:\n                    del self._prev_data\n                    del self._curr_data\n                    del self._next_data\n                    self._prev_data, self._prev_meta = self._load_prev()\n                    self._curr_data, self._curr_meta = \\\n                                self._load_data(date=self.date, fid=self._fid)\n                    self._next_data, self._next_meta = self._load_next()\n\n            # make sure datetime indices for all data is monotonic\n            if not self._prev_data.index.is_monotonic_increasing:\n                self._prev_data.sort_index(inplace=True)\n            if not self._curr_data.index.is_monotonic_increasing:\n                self._curr_data.sort_index(inplace=True)\n            if not self._next_data.index.is_monotonic_increasing:\n                self._next_data.sort_index(inplace=True)\n                \n            # make tracking indexes consistent with new loads\n            self._next_data_track = curr + inc\n            self._prev_data_track = curr - inc\n            # attach data to object\n            if not self._curr_data.empty:\n                self.data = self._curr_data.copy()\n                self.meta = self._curr_meta.copy()\n            else:\n                self.data = DataFrame(None)\n                # line below removed as it would delete previous meta, if any\n                # if you end a seasonal analysis with a day with no data, then\n                # no meta: self.meta = _meta.Meta()\n            \n            # multi file days can extend past a single day, only want data from \n            # specific date if loading by day\n            # set up times for the possible data padding coming up\n            if self._load_by_date:\n                #print ('double trouble')\n                first_time = self.date \n                first_pad = self.date - loop_pad\n                last_time = self.date + pds.DateOffset(days=1) \n                last_pad = self.date + pds.DateOffset(days=1) + loop_pad\n                want_last_pad = False\n            # loading by file, can't be a multi_file-day flag situation\n            elif (not self._load_by_date) and (not self.multi_file_day):\n                #print ('single trouble')\n                first_time = self._curr_data.index[0]\n                first_pad = first_time - loop_pad\n                last_time = self._curr_data.index[-1]\n                last_pad = last_time + loop_pad\n                want_last_pad = True\n            else:\n                raise ValueError(\"multi_file_day and loading by date are \" + \n                                 \"effectively equivalent.  Can't have \" +\n                                 \"multi_file_day and load by file.\")\n            #print (first_pad, first_time, last_time, last_pad)\n\n            # pad data based upon passed parameter\n            if (not self._prev_data.empty) & (not self.data.empty):\n                padLeft = self._prev_data.loc[first_pad : self.data.index[0]]\n                if len(padLeft) > 0:\n                    if (padLeft.index[-1] == self.data.index[0]) :\n                        padLeft = padLeft.iloc[:-1, :]\n                    self.data = pds.concat([padLeft, self.data])\n\n            if (not self._next_data.empty) & (not self.data.empty):\n                padRight = self._next_data.loc[self.data.index[-1] : last_pad]\n                if len(padRight) > 0:\n                    if (padRight.index[0] == self.data.index[-1]) :\n                        padRight = padRight.iloc[1:, :]\n                    self.data = pds.concat([self.data, padRight])\n                    \n            self.data = self.data.ix[first_pad : last_pad]\n            # want exclusive end slicing behavior from above\n            if not self.empty:\n                if (self.data.index[-1] == last_pad) & (not want_last_pad):\n                    self.data = self.data.iloc[:-1, :]\n   \n            ## drop any possible duplicate index times\n            ##self.data.drop_duplicates(inplace=True)\n            #self.data = self.data[~self.data.index.duplicated()]\n            \n        # if self.pad is False, load single day\n        else:\n            self.data, meta = self._load_data(date=self.date, fid=self._fid) \n            if not self.data.empty:\n                self.meta = meta   \n               \n        # check if load routine actually returns meta\n        if self.meta.data.empty:\n            self.meta[self.data.columns] = {self.name_label: self.data.columns,\n                                            self.units_label: [''] *\n                                            len(self.data.columns)}\n        # if loading by file set the yr, doy, and date\n        if not self._load_by_date:\n            if self.pad is not None:\n                temp = first_time\n            else:\n                temp = self.data.index[0]\n            self.date = pds.datetime(temp.year, temp.month, temp.day)\n            self.yr, self.doy = utils.getyrdoy(self.date)\n\n        if not self.data.empty:\n            self._default_rtn(self)\n        # clean\n        if (not self.data.empty) & (self.clean_level != 'none'):\n            self._clean_rtn(self)   \n        # apply custom functions\n        if not self.data.empty:\n            self.custom._apply_all(self)\n            \n        # remove the excess padding, if any applied\n        if (self.pad is not None) & (not self.data.empty) & (not verifyPad):\n            self.data = self.data[first_time: last_time]\n            if not self.empty:\n                if (self.data.index[-1] == last_time) & (not want_last_pad):\n                    self.data = self.data.iloc[:-1, :]\n\n        # transfer any extra attributes in meta to the Instrument object\n        self.meta.transfer_attributes_to_instrument(self)\n        sys.stdout.flush()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download(self, start, stop, freq='D', user=None, password=None,\n                 **kwargs):\n        \"\"\"Download data for given Instrument object from start to stop.\n        \n        Parameters\n        ----------\n        start : pandas.datetime\n            start date to download data\n        stop : pandas.datetime\n            stop date to download data\n        freq : string\n            Stepsize between dates for season, 'D' for daily, 'M' monthly \n            (see pandas)\n        user : string\n            username, if required by instrument data archive\n        password : string\n            password, if required by instrument data archive\n        **kwargs : dict\n            Dictionary of keywords that may be options for specific instruments\n            \n        Note\n        ----\n        Data will be downloaded to pysat_data_dir/patform/name/tag\n        \n        If Instrument bounds are set to defaults they are updated\n        after files are downloaded.\n        \n        \"\"\"\n        import errno\n        # make sure directories are there, otherwise create them\n        try:\n            os.makedirs(self.files.data_path)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n        print('Downloading data to: ', self.files.data_path)\n        date_array = utils.season_date_range(start, stop, freq=freq)\n        if user is None:\n            self._download_rtn(date_array,\n                               tag=self.tag,\n                               sat_id=self.sat_id,\n                               data_path=self.files.data_path,\n                               **kwargs)\n        else:\n            self._download_rtn(date_array,\n                               tag=self.tag,\n                               sat_id=self.sat_id,\n                               data_path=self.files.data_path,\n                               user=user,\n                               password=password, **kwargs)\n        # get current file date range\n        first_date = self.files.start_date\n        last_date = self.files.stop_date\n            \n        print('Updating pysat file list')\n        self.files.refresh()\n\n        # if instrument object has default bounds, update them\n        if len(self.bounds[0]) == 1:\n            if(self.bounds[0][0] == first_date and\n               self.bounds[1][0] == last_date):\n                print('Updating instrument object bounds.')\n                self.bounds = None", "response": "Download data for given instrument object from start to stop."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next(self, verifyPad=False):\n        \n        if self._iter_type == 'date':\n            if self.date is not None:\n                idx, = np.where(self._iter_list == self.date)\n                if (len(idx) == 0):\n                    raise StopIteration('File list is empty. Nothing to be done.')\n                elif idx[-1]+1 >= len(self._iter_list):\n                    raise StopIteration('Outside the set date boundaries.')\n                else:\n                    idx += 1\n                    self.load(date=self._iter_list[idx[0]], verifyPad=verifyPad)\n            else:\n                self.load(date=self._iter_list[0], verifyPad=verifyPad)\n\n        elif self._iter_type == 'file':\n            if self._fid is not None:\n                first = self.files.get_index(self._iter_list[0])\n                last = self.files.get_index(self._iter_list[-1])\n                if (self._fid < first) | (self._fid+1 > last):\n                    raise StopIteration('Outside the set file boundaries.')\n                else:\n                    self.load(fname=self._iter_list[self._fid+1-first],\n                              verifyPad=verifyPad)\n            else:\n                self.load(fname=self._iter_list[0], verifyPad=verifyPad)", "response": "Manually iterate through the data loaded in Instrument object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetermines the two - character type code for a given variable type", "response": "def _get_var_type_code(self, coltype):\n        '''Determines the two-character type code for a given variable type\n\n        Parameters\n        ----------\n        coltype : type or np.dtype\n            The type of the variable\n\n        Returns\n        -------\n        str\n            The variable type code for the given type'''\n\n        if type(coltype) is np.dtype:\n            var_type = coltype.kind + str(coltype.itemsize)\n            return var_type\n        else:\n            if coltype is np.int64:\n                return 'i8'\n            elif coltype is np.int32:\n                return 'i4'\n            elif coltype is np.int16:\n                return 'i2'\n            elif coltype is np.int8:\n                return 'i1'\n            elif coltype is np.uint64:\n                return 'u8'\n            elif coltype is np.uint32:\n                return 'u4'\n            elif coltype is np.uint16:\n                return 'u2'\n            elif coltype is np.uint8:\n                return 'u1'\n            elif coltype is np.float64:\n                return 'f8'\n            elif coltype is np.float32:\n                return 'f4'\n            elif issubclass(coltype, basestring):\n                return 'S1'\n            else:\n                raise TypeError('Unknown Variable Type' + str(coltype))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsupporting file writing by determiniing data type and other options", "response": "def _get_data_info(self, data, file_format):\n        \"\"\"Support file writing by determiniing data type and other options\n\n        Parameters\n        ----------\n        data : pandas object\n            Data to be written\n        file_format : basestring\n            String indicating netCDF3 or netCDF4\n\n        Returns\n        -------\n        data_flag, datetime_flag, old_format\n        \"\"\"\n        # get type of data\n        data_type = data.dtype\n        # check if older file_format\n        # if file_format[:7] == 'NETCDF3':\n        if file_format != 'NETCDF4':\n            old_format = True\n        else:\n            old_format = False\n        # check for object type\n        if data_type != np.dtype('O'):\n            # simple data, not an object\n            \n            # no 64bit ints in netCDF3\n            if (data_type == np.int64) & old_format:\n                data = data.astype(np.int32)\n                data_type = np.int32\n                   \n            if data_type == np.dtype('<M8[ns]'):\n                if not old_format:\n                    data_type = np.int64\n                else:\n                    data_type = np.float\n                datetime_flag = True\n            else:\n                datetime_flag = False\n        else:\n            # dealing with a more complicated object\n            # iterate over elements until we hit something that is something,\n            # and not NaN\n            data_type = type(data.iloc[0])\n            for i in np.arange(len(data)):\n                if len(data.iloc[i]) > 0:\n                    data_type = type(data.iloc[i])\n                    if not isinstance(data_type, np.float):\n                        break\n            datetime_flag = False\n            \n        return data, data_type, datetime_flag"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters metadata properties to be consistent with netCDF4.", "response": "def _filter_netcdf4_metadata(self, mdata_dict, coltype, remove=False):\n        \"\"\"Filter metadata properties to be consistent with netCDF4.\n        \n        Notes\n        -----\n        removed forced to True if coltype consistent with a string type\n        \n        Parameters\n        ----------\n        mdata_dict : dict\n            Dictionary equivalent to Meta object info\n        coltype : type\n            Type provided by _get_data_info\n        remove : boolean (False)\n            Removes FillValue and associated parameters disallowed for strings\n            \n        Returns\n        -------\n        dict\n            Modified as needed for netCDf4\n        \n        \"\"\"\n        # Coerce boolean types to integers\n        for key in mdata_dict:\n            if type(mdata_dict[key]) == bool:\n                mdata_dict[key] = int(mdata_dict[key])\n        if (coltype == type(' ')) or (coltype == type(u' ')):\n            remove = True\n        # print ('coltype', coltype, remove, type(coltype), )\n        if u'_FillValue' in mdata_dict.keys():\n            # make sure _FillValue is the same type as the data\n            if remove:\n                mdata_dict.pop('_FillValue')\n            else:\n                mdata_dict['_FillValue'] = np.array(mdata_dict['_FillValue']).astype(coltype)\n        if u'FillVal' in mdata_dict.keys():\n            # make sure _FillValue is the same type as the data\n            if remove:\n                mdata_dict.pop('FillVal')\n            else:\n                mdata_dict['FillVal'] = np.array(mdata_dict['FillVal']).astype(coltype)\n        return mdata_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generic_meta_translator(self, meta_to_translate):\n        '''Translates the metadate contained in an object into a dictionary\n        suitable for export.\n\n        Parameters\n        ----------\n        meta_to_translate : Meta\n            The metadata object to translate\n\n        Returns\n        -------\n        dict\n            A dictionary of the metadata for each variable of an output file\n            e.g. netcdf4'''\n        export_dict = {}\n        if self._meta_translation_table is not None:\n            # Create a translation table for the actual values of the meta labels.\n            # The instrument specific translation table only stores the names of the\n            # attributes that hold the various meta labels\n            translation_table = {}\n            for key in self._meta_translation_table:\n                translation_table[getattr(self, key)] = self._meta_translation_table[key]\n        else:\n            translation_table = None\n        #First Order Data\n        for key in meta_to_translate.data.index:\n            if translation_table is None:\n                export_dict[key] = meta_to_translate.data.loc[key].to_dict()\n            else:\n                # Translate each key if a translation is provided\n                export_dict[key] = {}\n                meta_dict = meta_to_translate.data.loc[key].to_dict()\n                for original_key in meta_dict:\n                    if original_key in translation_table:\n                        for translated_key in translation_table[original_key]:\n                            export_dict[key][translated_key] = meta_dict[original_key]\n                    else:\n                        export_dict[key][original_key] = meta_dict[original_key]\n\n\n        #Higher Order Data\n        for key in meta_to_translate.ho_data:\n            if key not in export_dict:\n                export_dict[key] = {}\n            for ho_key in meta_to_translate.ho_data[key].data.index:\n                if translation_table is None:\n                    export_dict[key+'_'+ho_key] = meta_to_translate.ho_data[key].data.loc[ho_key].to_dict()\n                else:\n                    #Translate each key if a translation is provided\n                    export_dict[key+'_'+ho_key] = {}\n                    meta_dict = meta_to_translate.ho_data[key].data.loc[ho_key].to_dict()\n                    for original_key in meta_dict:\n                        if original_key in translation_table:\n                            for translated_key in translation_table[original_key]:\n                                export_dict[key+'_'+ho_key][translated_key] = meta_dict[original_key]\n                        else:\n                            export_dict[key+'_'+ho_key][original_key] = meta_dict[original_key]\n\n        return export_dict", "response": "Translates the metadate contained in an object into a dictionary that can be exported to a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_netcdf4(self, fname=None, base_instrument=None, epoch_name='Epoch',\n                   zlib=False, complevel=4, shuffle=True):\n        \"\"\"Stores loaded data into a netCDF4 file.\n        \n        Parameters\n        ----------\n        fname : string\n            full path to save instrument object to\n        base_instrument : pysat.Instrument\n            used as a comparison, only attributes that are present with\n            self and not on base_instrument are written to netCDF\n        epoch_name : str\n            Label in file for datetime index of Instrument object\n        zlib : boolean\n            Flag for engaging zlib compression (True - compression on)\n        complevel : int\n            an integer between 1 and 9 describing the level of compression\n            desired (default 4). Ignored if zlib=False\n        shuffle : boolean\n            the HDF5 shuffle filter will be applied before compressing the data (default True).\n            This significantly improves compression. Default is True. Ignored if zlib=False.\n\n        Note\n        ----\n\n        Stores 1-D data along dimension 'epoch' - the date time index.\n        \n        Stores higher order data (e.g. dataframes within series) separately\n                    \n         - The name of the main variable column is used to prepend subvariable\n           names within netCDF, var_subvar_sub\n         - A netCDF4 dimension is created for each main variable column\n           with higher order data; first dimension Epoch\n         - The index organizing the data stored as a dimension variable \n         - from_netcdf4 uses the variable dimensions to reconstruct data structure\n            \n        \n        All attributes attached to instrument meta are written to netCDF attrs.\n        \n        \"\"\"\n        \n        import netCDF4\n        import pysat\n\n        file_format = 'NETCDF4'\n        # base_instrument used to define the standard attributes attached\n        # to the instrument object. Any additional attributes added\n        # to the main input Instrument will be written to the netCDF4\n        base_instrument = Instrument() if base_instrument is None else base_instrument\n        \n        # begin processing metadata for writing to the file\n        # look to see if user supplied a list of export keys\n        # corresponding to internally tracked metadata within pysat\n        export_meta = self.generic_meta_translator(self.meta)\n        if self._meta_translation_table is None:\n            # didn't find a translation table, using the strings\n            # attached to the supplied pysat.Instrument object\n            export_name_labels = [self.name_label]\n            export_units_labels = [self.units_label]\n            export_desc_labels = [self.desc_label]\n            export_notes_labels = [self.notes_label]\n        else:\n            # user supplied labels in translation table\n            export_name_labels = self._meta_translation_table['name_label']\n            export_units_labels = self._meta_translation_table['units_label']\n            export_desc_labels = self._meta_translation_table['desc_label']\n            export_notes_labels = self._meta_translation_table['notes_label']\n            print('Using Metadata Translation Table: ', self._meta_translation_table)\n        # Apply instrument specific post-processing to the export_meta\n        if hasattr(self._export_meta_post_processing, '__call__'):\n            export_meta = self._export_meta_post_processing(export_meta)\n\n\n        # general process for writing data is this\n        # first, take care of the EPOCH information\n        # second, iterate over the variable colums in Instrument.data\n        # check the type of data\n        # if 1D column, do simple write (type is not an object)\n        # if it is an object, then check if writing strings, if not strings, then\n        # if column is a Series of Frames, write as 2D variables\n        # metadata must be filtered before writing to netCDF4, string variables \n        # can't have a fill value\n        with netCDF4.Dataset(fname, mode='w', format=file_format) as out_data:\n            # number of items, yeah\n            num = len(self.data.index)\n            # write out the datetime index\n            out_data.createDimension(epoch_name, num)\n            cdfkey = out_data.createVariable(epoch_name, 'i8',\n                                             dimensions=(epoch_name),\n                                             zlib=zlib,\n                                             complevel=complevel,\n                                             shuffle=shuffle) \n            # grab existing metadata for Epoch or create suitable info\n            if epoch_name in self.meta:\n                new_dict = export_meta[self.meta.var_case_name(epoch_name)]\n            else:\n                # create empty shell\n                new_dict = {}\n                \n            # update required and basic information if not present\n            for export_name_label in export_name_labels:\n                if export_name_label not in new_dict:\n                    new_dict[export_name_label] = epoch_name\n            for export_units_label in export_units_labels:\n                if export_units_label not in new_dict:\n                    new_dict[export_units_label] = 'Milliseconds since 1970-1-1 00:00:00'\n            for export_desc_label in export_desc_labels:\n                if export_desc_label not in new_dict:\n                    new_dict[export_desc_label] = 'Milliseconds since 1970-1-1 00:00:00'\n            for export_notes_label in export_notes_labels:\n                if export_notes_label not in new_dict:\n                    new_dict[export_notes_label] = ''\n            new_dict['calendar'] = 'standard'\n            new_dict['Format'] = 'i8'\n            new_dict['Var_Type'] = 'data'\n            if self.data.index.is_monotonic_increasing:\n                new_dict['MonoTon'] = 'increase'\n            elif self.data.index.is_monotonic_decreasing:\n                new_dict['MonoTon'] = 'decrease' \n            new_dict['Time_Base'] = 'Milliseconds since 1970-1-1 00:00:00'\n            new_dict['Time_Scale'] = 'UTC'\n            new_dict = self._filter_netcdf4_metadata(new_dict, np.int64)\n            # attach metadata\n            cdfkey.setncatts(new_dict)\n\n            # attach data\n            cdfkey[:] = (self.data.index.values.astype(np.int64) *\n                         1.E-6).astype(np.int64)\n                            \n            # iterate over all of the columns in the Instrument dataframe\n            # check what kind of data we are dealing with, then store\n            for key in self.data.columns:\n                # print (key)\n                # get information on type data we are dealing with\n                # data is data in proer type( multiformat support)\n                # coltype is the direct type, np.int64\n                # and datetime_flag lets you know if the data is full of time\n                # information\n                data, coltype, datetime_flag = self._get_data_info(self[key],\n                                                                   file_format)\n                # operate on data based upon type\n                if self[key].dtype != np.dtype('O'):\n                    # not an object, normal basic 1D data\n                    # print(key, coltype, file_format)\n                    cdfkey = out_data.createVariable(key,\n                                                     coltype,\n                                                     dimensions=(epoch_name),\n                                                     zlib=zlib,\n                                                     complevel=complevel,\n                                                     shuffle=shuffle) #, chunksizes=1)\n                    # attach any meta data, after filtering for standards\n                    try:\n                        # attach dimension metadata\n                        new_dict = export_meta[key]\n                        new_dict['Depend_0'] = epoch_name\n                        new_dict['Display_Type'] = 'Time Series'\n                        new_dict['Format'] = self._get_var_type_code(coltype)\n                        new_dict['Var_Type'] = 'data'\n                        new_dict = self._filter_netcdf4_metadata(new_dict,\n                                                                 coltype)\n                        cdfkey.setncatts(new_dict)\n                    except KeyError:\n                        print(', '.join(('Unable to find MetaData for', key)))\n                    # assign data\n                    if datetime_flag:\n                        # datetime is in nanoseconds, storing milliseconds\n                        cdfkey[:] = (data.values.astype(coltype)\n                                     * 1.E-6).astype(coltype)\n                    else:\n                        # not datetime data, just store as is\n                        cdfkey[:] = data.values.astype(coltype)\n                        \n                # back to main check on type of data to write\n                else:\n                    # it is a Series of objects, need to figure out\n                    # what the actual objects are, then act as needed\n                    \n                    # use info in coltype to get real datatype of object\n                    # isinstance isn't working here because of something with coltype\n                    if (coltype == type(' ')) or (coltype == type(u' ')):\n                        # dealing with a string\n                        cdfkey = out_data.createVariable(key, coltype, \\\n                                            dimensions=(epoch_name), zlib=zlib, \\\n                                            complevel=complevel, shuffle=shuffle) \n                        # attach any meta data\n                        try:\n                            # attach dimension metadata\n                            new_dict = export_meta[key]\n                            new_dict['Depend_0'] = epoch_name\n                            new_dict['Display_Type'] = 'Time Series'\n                            new_dict['Format'] = self._get_var_type_code(coltype)\n                            new_dict['Var_Type'] = 'data'\n                            # no FillValue or FillVal allowed for strings\n                            new_dict = self._filter_netcdf4_metadata(new_dict, \\\n                                                        coltype, remove=True)\n                            # really attach metadata now\n                            cdfkey.setncatts(new_dict)\n                        except KeyError:\n                            print(', '.join(('Unable to find MetaData for',\n                                             key)))\n\n                        # time to actually write the data now\n                        cdfkey[:] = data.values\n                        \n                    # still dealing with an object, not just a series\n                    # of strings\n                    # maps to if check on coltypes being stringbased\n                    else:\n                        # presuming a series with a dataframe or series in each location\n                        # start by collecting some basic info on dimensions\n                        # sizes, names, then create corresponding netCDF4 dimensions\n                        # total dimensions stored for object are epoch plus ones\n                        # created below\n                        dims = np.shape(self[key].iloc[0])\n                        obj_dim_names = []\n                        if len(dims) == 1:\n                            # generally working with higher dimensional data\n                            # pad dimensions so that the rest of the code works\n                            # for either a Series or a Frame\n                            dims = (dims[0], 0)\n                        for i, dim in enumerate(dims[:-1]):\n                            # don't need to go over last dimension value,\n                            # it covers number of columns (if a frame)\n                            obj_dim_names.append(key)\n                            out_data.createDimension(obj_dim_names[-1], dim)                            \n                        # create simple tuple with information needed to create\n                        # the right dimensions for variables that will\n                        # be written to file\n                        var_dim = tuple([epoch_name] + obj_dim_names)\n                        \n                        # We need to do different things if a series or dataframe\n                        # stored\n                        try:\n                            # start by assuming it is a dataframe\n                            # get list of subvariables\n                            iterable = self[key].iloc[0].columns\n                            # store our newfound knowledge, we are dealing with\n                            # a series of DataFrames\n                            is_frame = True\n                        except AttributeError:\n                            # turns out data is Series of Series \n                            # which doesn't have columns\n                            iterable = [self[key].iloc[0].name]\n                            is_frame = False\n\n                        # find location within main variable\n                        # that actually has subvariable data (not just empty frame/series)\n                        # so we can determine what the real underlying data types are\n                        good_data_loc = 0\n                        for jjj in np.arange(len(self.data)):\n                            if len(self.data[key].iloc[0]) > 0:\n                                data_loc = jjj\n                                break\n                        # found a place with data, if there is one\n                        # now iterate over the subvariables, get data info\n                        # create netCDF4 variables and store the data \n                        # stored name is variable_subvariable\n                        for col in iterable:\n                            if is_frame:\n                                # we are working with a dataframe\n                                # so multiple subvariables stored under a single\n                                # main variable heading\n                                data, coltype, _ = self._get_data_info(self[key].iloc[good_data_loc][col], file_format)\n                                cdfkey = out_data.createVariable(key + '_' + col,\n                                                                 coltype,\n                                                                 dimensions=var_dim,\n                                                                 zlib=zlib,\n                                                                 complevel=complevel,\n                                                                 shuffle=shuffle)\n                                # attach any meta data\n                                try:\n                                    new_dict = export_meta[key+'_'+col]\n                                    new_dict['Depend_0'] = epoch_name\n                                    new_dict['Depend_1'] = obj_dim_names[-1]\n                                    new_dict['Display_Type'] = 'Spectrogram'            \n                                    new_dict['Format'] = self._get_var_type_code(coltype)\n                                    new_dict['Var_Type'] = 'data'\n                                    # print('Frame Writing ', key, col, export_meta[key].children[col])\n                                    new_dict = self._filter_netcdf4_metadata(new_dict, coltype)\n                                    # print ('mid2 ', new_dict)\n                                    cdfkey.setncatts(new_dict)\n                                except KeyError:\n                                    print(', '.join(('Unable to find MetaData for', key, col)) )\n                                # attach data\n                                # it may be slow to repeatedly call the store\n                                # method as well astype method below collect\n                                # data into a numpy array, then write the full\n                                # array in one go\n                                # print(coltype, dims)\n                                temp_cdf_data = np.zeros((num, dims[0])).astype(coltype)\n                                for i in range(num):\n                                    temp_cdf_data[i, :] = self[key].iloc[i][col].values\n                                # write data\n                                cdfkey[:, :] = temp_cdf_data.astype(coltype)\n\n                            else:\n                                # we are dealing with a Series\n                                # get information about information within series\n                                data, coltype, _ = self._get_data_info(self[key].iloc[good_data_loc], file_format)\n                                cdfkey = out_data.createVariable(key + '_data',\n                                                                coltype,\n                                                                dimensions=var_dim,\n                                                                zlib=zlib,\n                                                                complevel=complevel,\n                                                                shuffle=shuffle) #, chunksizes=1)\n                                # attach any meta data\n                                try:\n                                    new_dict = export_meta[key]\n                                    new_dict['Depend_0'] = epoch_name\n                                    new_dict['Depend_1'] =  obj_dim_names[-1]\n                                    new_dict['Display_Type'] = 'Spectrogram' \n                                    new_dict['Format'] = self._get_var_type_code(coltype)\n                                    new_dict['Var_Type'] = 'data'\n                                    new_dict = self._filter_netcdf4_metadata(new_dict, coltype)\n                                    # really attach metadata now\n                                    # print ('mid3 ', new_dict)\n                                    cdfkey.setncatts(new_dict)\n                                except KeyError:\n                                    print(', '.join(('Unable to find MetaData for', key)))\n                                # attach data\n                                temp_cdf_data = np.zeros((num, dims[0])).astype(coltype)\n                                for i in range(num):\n                                    temp_cdf_data[i, :] = self[i, key].values\n                                # write data\n                                cdfkey[:, :] = temp_cdf_data.astype(coltype)\n\n                        # we are done storing the actual data for the given higher\n                        # order variable, now we need to store the index for all\n                        # of that fancy data\n                        \n                        # get index information\n                        data, coltype, datetime_flag = self._get_data_info(self[key].iloc[good_data_loc].index, file_format)\n                        # create dimension variable for to store index in netCDF4\n                        cdfkey = out_data.createVariable(key,\n                                                         coltype, dimensions=var_dim,\n                                                         zlib=zlib,\n                                                         complevel=complevel,\n                                                         shuffle=shuffle)\n                        # work with metadata\n                        new_dict = export_meta[key]\n                        new_dict['Depend_0'] = epoch_name\n                        new_dict['Depend_1'] =  obj_dim_names[-1]  \n                        new_dict['Display_Type'] = 'Time Series'  \n                        new_dict['Format'] = self._get_var_type_code(coltype)\n                        new_dict['Var_Type'] = 'data'\n                        \n                        if datetime_flag:\n                            #print('datetime flag')                            \n                            for export_name_label in export_name_labels:\n                                new_dict[export_name_label] = epoch_name\n                            for export_units_label in export_units_labels:\n                                new_dict[export_units_label] = 'Milliseconds since 1970-1-1 00:00:00'\n                            new_dict = self._filter_netcdf4_metadata(new_dict, coltype)\n                            # set metadata dict\n                            cdfkey.setncatts(new_dict)\n                            # set data\n                            temp_cdf_data = np.zeros((num,\n                                                      dims[0])).astype(coltype)\n                            for i in range(num):\n                                temp_cdf_data[i, :] = self[i, key].index.values\n                            cdfkey[:, :] = (temp_cdf_data.astype(coltype) *\n                                            1.E-6).astype(coltype)\n \n                        else:\n                            if self[key].iloc[data_loc].index.name is not None:\n                                for export_name_label in export_name_labels:\n                                    new_dict[export_name_label] = self[key].iloc[data_loc].index.name\n                            else:\n                                for export_name_label in export_name_labels:\n                                    new_dict[export_name_label] = key\n                            new_dict = self._filter_netcdf4_metadata(new_dict, coltype)\n                            # assign metadata dict\n                            cdfkey.setncatts(new_dict)\n                            # set data\n                            temp_cdf_data = np.zeros((num, dims[0])).astype(coltype)\n                            for i in range(num):\n                                temp_cdf_data[i, :] = self[key].iloc[i].index.to_native_types()\n                            cdfkey[:, :] = temp_cdf_data.astype(coltype)\n                            \n            # store any non standard attributes\n            # compare this Instrument's attributes to base object\n            base_attrb = dir(base_instrument)\n            this_attrb = dir(self)\n            # filter out any 'private' attributes\n            # those that start with a _\n            adict = {}\n            for key in this_attrb:\n                if key not in base_attrb:\n                    if key[0] != '_':\n                        adict[key] = self.__getattribute__(key)\n            # store any non-standard attributes attached to meta\n            base_attrb = dir(base_instrument.meta)\n            this_attrb = dir(self.meta)\n            for key in this_attrb:\n                if key not in base_attrb:\n                    if key[0] != '_':\n                        adict[key] = self.meta.__getattribute__(key)\n            adict['pysat_version'] = pysat.__version__\n            if 'Conventions' not in adict:\n                adict['Conventions'] = 'SPDF ISTP/IACG Modified for NetCDF'\n            if 'Text_Supplement' not in adict:\n                adict['Text_Supplement'] = ''\n\n            adict['Date_Start'] = pysat.datetime.strftime(self.data.index[0], '%a, %d %b %Y,  %Y-%m-%dT%H:%M:%S.%f UTC')\n            adict['Date_End'] = pysat.datetime.strftime(self.data.index[-1], '%a, %d %b %Y,  %Y-%m-%dT%H:%M:%S.%f UTC')\n            adict['File'] = os.path.split(fname)\n            adict['Generation_Date'] = pysat.datetime.utcnow().strftime('%Y%m%d')\n            adict['Logical_File_ID'] = os.path.split(fname)[-1].split('.')[:-1]\n            # check for binary types\n            for key in adict.keys():\n                if isinstance(adict[key], bool):\n                    adict[key] = int(adict[key])\n            # print('adict', adict)\n            out_data.setncatts(adict)\n        return", "response": "Stores loaded data into a netCDF4 file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_alu_hlu_map(input_str):\n    ret = {}\n    if input_str is not None:\n        pattern = re.compile(r'(\\d+)\\s*(\\d+)')\n        for line in input_str.split('\\n'):\n            line = line.strip()\n            if len(line) == 0:\n                continue\n            matched = re.search(pattern, line)\n            if matched is None or len(matched.groups()) < 2:\n                continue\n            else:\n                hlu = matched.group(1)\n                alu = matched.group(2)\n                ret[int(alu)] = int(hlu)\n    return ret", "response": "Convert input string into a alu - hlu map"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts input to disk indices", "response": "def to_disk_indices(value):\n    \"\"\"Convert following input to disk indices\n\n    Sample input:\n\n    ```\n    Disks:\n    Bus 0 Enclosure 0 Disk 9\n    Bus 1 Enclosure 0 Disk 12\n    Bus 1 Enclosure 0 Disk 9\n    Bus 0 Enclosure 0 Disk 4\n    Bus 0 Enclosure 0 Disk 7\n    ```\n\n    :param value: disk list\n    :return: disk indices in list\n    \"\"\"\n    ret = []\n    p = re.compile(r'Bus\\s+(\\w+)\\s+Enclosure\\s+(\\w+)\\s+Disk\\s+(\\w+)')\n    if value is not None:\n        for line in value.split('\\n'):\n            line = line.strip()\n            if len(line) == 0:\n                continue\n            matched = re.search(p, line)\n            if matched is None or len(matched.groups()) < 3:\n                continue\n            else:\n                ret.append('{}_{}_{}'.format(*matched.groups()))\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url_to_host(url):\n\n    regex_url = r\"([a-z][a-z0-9+\\-.]*://)?\" + \\\n                r\"([a-z0-9\\-._~%!$&'()*+,;=]+@)?\" + \\\n                r\"([a-z0-9\\-._~%]+\" + \\\n                r\"|\\[[a-z0-9\\-._~%!$&'()*+,;=:]+\\])?\" + \\\n                r\"(:(?P<port>[0-9]+))?\"\n\n    m = re.match(regex_url, url, re.IGNORECASE)\n    if m and m.group(3):\n        return url[m.start(3): m.end(3)]\n    else:\n        raise ValueError(\"URL without a valid host or ip\")", "response": "converts a url to a host"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing host address to get domain name ipv4 ipv6 address and net mask code string if given a subnet address", "response": "def parse_host_address(addr):\n    \"\"\"\n    parse host address to get domain name or ipv4/v6 address,\n    cidr prefix and net mask code string if given a subnet address\n\n    :param addr:\n    :type addr: str\n    :return: parsed domain name/ipv4 address/ipv6 address,\n             cidr prefix if there is,\n             net mask code string if there is\n    :rtype: (string, int, string)\n    \"\"\"\n\n    if addr.startswith('[') and addr.endswith(']'):\n        addr = addr[1:-1]\n\n    parts = addr.split('/')\n    if len(parts) == 1:\n        return parts[0], None, None\n    if len(parts) > 2:\n        raise ValueError(\"Illegal host address\")\n    else:\n        domain_or_ip, prefix = parts\n        prefix = int(prefix)\n        if re.match(r\"^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$\", domain_or_ip):\n            return domain_or_ip, prefix, ipv4_prefix_to_mask(prefix)\n        elif ':' in domain_or_ip:\n            return domain_or_ip, prefix, ipv6_prefix_to_mask(prefix)\n        else:\n            return domain_or_ip, None, None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a cidr prefix to a net mask", "response": "def ipv4_prefix_to_mask(prefix):\n    \"\"\"\n    ipv4 cidr prefix to net mask\n\n    :param prefix: cidr prefix , rang in (0, 32)\n    :type prefix: int\n    :return: dot separated ipv4 net mask code, eg: 255.255.255.0\n    :rtype: str\n    \"\"\"\n    if prefix > 32 or prefix < 0:\n        raise ValueError(\"invalid cidr prefix for ipv4\")\n    else:\n        mask = ((1 << 32) - 1) ^ ((1 << (32 - prefix)) - 1)\n        eight_ones = 255  # 0b11111111\n        mask_str = ''\n        for i in range(0, 4):\n            mask_str = str(mask & eight_ones) + mask_str\n            mask = mask >> 8\n            if i != 3:\n                mask_str = '.' + mask_str\n        return mask_str"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ipv6_prefix_to_mask(prefix):\n    if prefix > 128 or prefix < 0:\n        raise ValueError(\"invalid cidr prefix for ipv6\")\n    else:\n        mask = ((1 << 128) - 1) ^ ((1 << (128 - prefix)) - 1)\n        f = 15  # 0xf or 0b1111\n        hex_mask_str = ''\n        for i in range(0, 32):\n            hex_mask_str = format((mask & f), 'x') + hex_mask_str\n            mask = mask >> 4\n            if i != 31 and i & 3 == 3:\n                hex_mask_str = ':' + hex_mask_str\n        return hex_mask_str", "response": "returns a comma separated ipv6 net mask code from a given cidr prefix"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expand(self, new_size):\n        ret = self.size_total\n        resp = self.modify(size=new_size)\n        resp.raise_if_err()\n        return ret", "response": "expand the LUN to a new size in bytes"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the hosts for the lun if needed.", "response": "def update_hosts(self, host_names):\n\n        \"\"\"Primarily for puppet-unity use.\n\n        Update the hosts for the lun if needed.\n\n        :param host_names: specify the new hosts which access the LUN.\n        \"\"\"\n\n        if self.host_access:\n            curr_hosts = [access.host.name for access in self.host_access]\n        else:\n            curr_hosts = []\n\n        if set(curr_hosts) == set(host_names):\n            log.info('Hosts for updating is equal to current hosts, '\n                     'skip modification.')\n            return None\n\n        new_hosts = [UnityHostList.get(cli=self._cli, name=host_name)[0]\n                     for host_name in host_names]\n        new_access = [{'host': item,\n                       'accessMask': HostLUNAccessEnum.PRODUCTION}\n                      for item in new_hosts]\n        resp = self.modify(host_access=new_access)\n        resp.raise_if_err()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replicate(self, dst_lun_id, max_time_out_of_sync,\n                  replication_name=None, replicate_existing_snaps=None,\n                  remote_system=None):\n        \"\"\"\n        Creates a replication session with a existing lun as destination.\n\n        :param dst_lun_id: destination lun id.\n        :param max_time_out_of_sync: maximum time to wait before syncing the\n            source and destination. Value `-1` means the automatic sync is not\n            performed. `0` means it is a sync replication.\n        :param replication_name: replication name.\n        :param replicate_existing_snaps: whether to replicate existing snaps.\n        :param remote_system: `UnityRemoteSystem` object. The remote system to\n            which the replication is being configured. When not specified, it\n            defaults to local system.\n        :return: created replication session.\n        \"\"\"\n\n        return UnityReplicationSession.create(\n            self._cli, self.get_id(), dst_lun_id, max_time_out_of_sync,\n            name=replication_name,\n            replicate_existing_snaps=replicate_existing_snaps,\n            remote_system=remote_system)", "response": "Creates a replication session with a destination lun."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replicate_with_dst_resource_provisioning(self, max_time_out_of_sync,\n                                                 dst_pool_id,\n                                                 dst_lun_name=None,\n                                                 remote_system=None,\n                                                 replication_name=None,\n                                                 dst_size=None, dst_sp=None,\n                                                 is_dst_thin=None,\n                                                 dst_tiering_policy=None,\n                                                 is_dst_compression=None):\n        \"\"\"\n        Creates a replication session with destination lun provisioning.\n\n        :param max_time_out_of_sync: maximum time to wait before syncing the\n            source and destination. Value `-1` means the automatic sync is not\n            performed. `0` means it is a sync replication.\n        :param dst_pool_id: id of pool to allocate destination lun.\n        :param dst_lun_name: destination lun name.\n        :param remote_system: `UnityRemoteSystem` object. The remote system to\n            which the replication is being configured. When not specified, it\n            defaults to local system.\n        :param replication_name: replication name.\n        :param dst_size: destination lun size.\n        :param dst_sp: `NodeEnum` value. Default storage processor of\n            destination lun.\n        :param is_dst_thin: indicates whether destination lun is thin or not.\n        :param dst_tiering_policy: `TieringPolicyEnum` value. Tiering policy of\n            destination lun.\n        :param is_dst_compression: indicates whether destination lun is\n            compression enabled or not.\n        :return: created replication session.\n        \"\"\"\n\n        dst_size = self.size_total if dst_size is None else dst_size\n\n        dst_resource = UnityResourceConfig.to_embedded(\n            name=dst_lun_name, pool_id=dst_pool_id,\n            size=dst_size, default_sp=dst_sp,\n            tiering_policy=dst_tiering_policy, is_thin_enabled=is_dst_thin,\n            is_compression_enabled=is_dst_compression)\n        return UnityReplicationSession.create_with_dst_resource_provisioning(\n            self._cli, self.get_id(), dst_resource, max_time_out_of_sync,\n            remote_system=remote_system, name=replication_name)", "response": "Creates a replication session with destination resource provisioning."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the link aggregation object or the ethernet port object.", "response": "def get_physical_port(self):\n        \"\"\"Returns the link aggregation object or the ethernet port object.\"\"\"\n        obj = None\n        if self.is_link_aggregation():\n            obj = UnityLinkAggregation.get(self._cli, self.get_id())\n        else:\n            obj = UnityEthernetPort.get(self._cli, self.get_id())\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_embedded(pool_id=None, is_thin_enabled=None,\n                    is_deduplication_enabled=None, is_compression_enabled=None,\n                    is_backup_only=None, size=None, tiering_policy=None,\n                    request_id=None, src_id=None, name=None, default_sp=None,\n                    replication_resource_type=None):\n        \"\"\"\n        Constructs an embeded object of `UnityResourceConfig`.\n\n        :param pool_id: storage pool of the resource.\n        :param is_thin_enabled: is thin type or not.\n        :param is_deduplication_enabled: is deduplication enabled or not.\n        :param is_compression_enabled: is in-line compression (ILC) enabled or\n            not.\n        :param is_backup_only: is backup only or not.\n        :param size: size of the resource.\n        :param tiering_policy: `TieringPolicyEnum` value. Tiering policy\n            for the resource.\n        :param request_id: unique request ID for the configuration.\n        :param src_id: storage resource if it already exists.\n        :param name: name of the storage resource.\n        :param default_sp: `NodeEnum` value. Default storage processor for\n            the resource.\n        :param replication_resource_type: `ReplicationEndpointResourceTypeEnum`\n            value. Replication resource type.\n        :return:\n        \"\"\"\n        return {'poolId': pool_id, 'isThinEnabled': is_thin_enabled,\n                'isDeduplicationEnabled': is_deduplication_enabled,\n                'isCompressionEnabled': is_compression_enabled,\n                'isBackupOnly': is_backup_only, 'size': size,\n                'tieringPolicy': tiering_policy, 'requestId': request_id,\n                'srcId': src_id, 'name': name, 'defaultSP': default_sp,\n                'replicationResourceType': replication_resource_type}", "response": "Constructs an embeded object of UnityResourceConfig."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(cls, cli, src_resource_id, dst_resource_id,\n               max_time_out_of_sync, name=None, members=None,\n               auto_initiate=None, hourly_snap_replication_policy=None,\n               daily_snap_replication_policy=None,\n               replicate_existing_snaps=None, remote_system=None,\n               src_spa_interface=None, src_spb_interface=None,\n               dst_spa_interface=None, dst_spb_interface=None):\n        \"\"\"\n        Creates a replication session.\n\n        :param cli: the rest cli.\n        :param src_resource_id: id of the replication source, could be\n            lun/fs/cg.\n        :param dst_resource_id: id of the replication destination.\n        :param max_time_out_of_sync: maximum time to wait before syncing the\n            source and destination. Value `-1` means the automatic sync is not\n            performed. `0` means it is a sync replication.\n        :param name: name of the replication.\n        :param members: list of `UnityLunMemberReplication` object. If\n            `src_resource` is cg, `lunMemberReplication` list need to pass in\n            to this parameter as member lun pairing between source and\n            destination cg.\n        :param auto_initiate: indicates whether to perform the first\n            replication sync automatically.\n            True - perform the first replication sync automatically.\n            False - perform the first replication sync manually.\n        :param hourly_snap_replication_policy: `UnitySnapReplicationPolicy`\n            object. The policy for replicating hourly scheduled snaps of the\n            source resource.\n        :param daily_snap_replication_policy: `UnitySnapReplicationPolicy`\n            object. The policy for replicating daily scheduled snaps of the\n            source resource.\n        :param replicate_existing_snaps: indicates whether or not to replicate\n            snapshots already existing on the resource.\n        :param remote_system: `UnityRemoteSystem` object. The remote system of\n            remote replication.\n        :param src_spa_interface: `UnityRemoteInterface` object. The\n            replication interface for source SPA.\n        :param src_spb_interface: `UnityRemoteInterface` object. The\n            replication interface for source SPB.\n        :param dst_spa_interface: `UnityRemoteInterface` object. The\n            replication interface for destination SPA.\n        :param dst_spb_interface: `UnityRemoteInterface` object. The\n            replication interface for destination SPB.\n        :return: the newly created replication session.\n        \"\"\"\n\n        req_body = cli.make_body(\n            srcResourceId=src_resource_id, dstResourceId=dst_resource_id,\n            maxTimeOutOfSync=max_time_out_of_sync, members=members,\n            autoInitiate=auto_initiate, name=name,\n            hourlySnapReplicationPolicy=hourly_snap_replication_policy,\n            dailySnapReplicationPolicy=daily_snap_replication_policy,\n            replicateExistingSnaps=replicate_existing_snaps,\n            remoteSystem=remote_system,\n            srcSPAInterface=src_spa_interface,\n            srcSPBInterface=src_spb_interface,\n            dstSPAInterface=dst_spa_interface,\n            dstSPBInterface=dst_spb_interface)\n\n        resp = cli.post(cls().resource_class, **req_body)\n        resp.raise_if_err()\n        return cls.get(cli, resp.resource_id)", "response": "Creates a new replication session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_with_dst_resource_provisioning(\n            cls, cli, src_resource_id, dst_resource_config,\n            max_time_out_of_sync, name=None, remote_system=None,\n            src_spa_interface=None, src_spb_interface=None,\n            dst_spa_interface=None, dst_spb_interface=None,\n            dst_resource_element_configs=None, auto_initiate=None,\n            hourly_snap_replication_policy=None,\n            daily_snap_replication_policy=None, replicate_existing_snaps=None):\n        \"\"\"\n        Create a replication session along with destination resource\n        provisioning.\n\n        :param cli: the rest cli.\n        :param src_resource_id: id of the replication source, could be\n            lun/fs/cg.\n        :param dst_resource_config: `UnityResourceConfig` object. The user\n            chosen config for destination resource provisioning. `pool_id` and\n            `size` are required for creation.\n        :param max_time_out_of_sync: maximum time to wait before syncing the\n            source and destination. Value `-1` means the automatic sync is not\n            performed. `0` means it is a sync replication.\n        :param name: name of the replication.\n        :param remote_system: `UnityRemoteSystem` object. The remote system to\n            which the replication is being configured. When not specified, it\n            defaults to local system.\n        :param src_spa_interface: `UnityRemoteInterface` object. The\n            replication interface for source SPA.\n        :param src_spb_interface: `UnityRemoteInterface` object. The\n            replication interface for source SPB.\n        :param dst_spa_interface: `UnityRemoteInterface` object. The\n            replication interface for destination SPA.\n        :param dst_spb_interface: `UnityRemoteInterface` object. The\n            replication interface for destination SPB.\n        :param dst_resource_element_configs: List of `UnityResourceConfig`\n            objects. The user chose config for each of the member element of\n            the destination resource.\n        :param auto_initiate: indicates whether to perform the first\n            replication sync automatically.\n            True - perform the first replication sync automatically.\n            False - perform the first replication sync manually.\n        :param hourly_snap_replication_policy: `UnitySnapReplicationPolicy`\n            object. The policy for replicating hourly scheduled snaps of the\n            source resource.\n        :param daily_snap_replication_policy: `UnitySnapReplicationPolicy`\n            object. The policy for replicating daily scheduled snaps of the\n            source resource.\n        :param replicate_existing_snaps: indicates whether or not to replicate\n            snapshots already existing on the resource.\n        :return: the newly created replication session.\n        \"\"\"\n\n        req_body = cli.make_body(\n            srcResourceId=src_resource_id,\n            dstResourceConfig=dst_resource_config,\n            maxTimeOutOfSync=max_time_out_of_sync,\n            name=name, remoteSystem=remote_system,\n            srcSPAInterface=src_spa_interface,\n            srcSPBInterface=src_spb_interface,\n            dstSPAInterface=dst_spa_interface,\n            dstSPBInterface=dst_spb_interface,\n            dstResourceElementConfigs=dst_resource_element_configs,\n            autoInitiate=auto_initiate,\n            hourlySnapReplicationPolicy=hourly_snap_replication_policy,\n            dailySnapReplicationPolicy=daily_snap_replication_policy,\n            replicateExistingSnaps=replicate_existing_snaps)\n\n        resp = cli.type_action(\n            cls().resource_class,\n            'createReplicationSessionWDestResProvisioning',\n            **req_body)\n        resp.raise_if_err()\n        # response is like:\n        # \"content\": {\n        #     \"id\": {\n        #         \"id\": \"42949676351_FNM00150600267_xxxx\"\n        #     }\n        session_resp = resp.first_content['id']\n        return cls.get(cli, _id=session_resp['id'])", "response": "Creates a replication session along with destination resource provisioning."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmodifying properties of a replication session.", "response": "def modify(self, max_time_out_of_sync=None, name=None,\n               hourly_snap_replication_policy=None,\n               daily_snap_replication_policy=None,\n               src_spa_interface=None, src_spb_interface=None,\n               dst_spa_interface=None, dst_spb_interface=None):\n        \"\"\"\n        Modifies properties of a replication session.\n\n        :param max_time_out_of_sync: same as the one in `create` method.\n        :param name: same as the one in `create` method.\n        :param hourly_snap_replication_policy: same as the one in `create`\n            method.\n        :param daily_snap_replication_policy: same as the one in `create`\n            method.\n        :param src_spa_interface: same as the one in `create` method.\n        :param src_spb_interface: same as the one in `create` method.\n        :param dst_spa_interface: same as the one in `create` method.\n        :param dst_spb_interface: same as the one in `create` method.\n        \"\"\"\n        req_body = self._cli.make_body(\n            maxTimeOutOfSync=max_time_out_of_sync, name=name,\n            hourlySnapReplicationPolicy=hourly_snap_replication_policy,\n            dailySnapReplicationPolicy=daily_snap_replication_policy,\n            srcSPAInterface=src_spa_interface,\n            srcSPBInterface=src_spb_interface,\n            dstSPAInterface=dst_spa_interface,\n            dstSPBInterface=dst_spb_interface)\n\n        resp = self.action('modify', **req_body)\n        resp.raise_if_err()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresumes a replication session.", "response": "def resume(self, force_full_copy=None,\n               src_spa_interface=None, src_spb_interface=None,\n               dst_spa_interface=None, dst_spb_interface=None):\n        \"\"\"\n        Resumes a replication session.\n\n        This can be applied on replication session when it's operational status\n        is reported as Failed over, or Paused.\n\n        :param force_full_copy: needed when replication session goes out of\n            sync due to a fault.\n            True - replicate all data.\n            False - replicate changed data only.\n        :param src_spa_interface: same as the one in `create` method.\n        :param src_spb_interface: same as the one in `create` method.\n        :param dst_spa_interface: same as the one in `create` method.\n        :param dst_spb_interface: same as the one in `create` method.\n        \"\"\"\n        req_body = self._cli.make_body(forceFullCopy=force_full_copy,\n                                       srcSPAInterface=src_spa_interface,\n                                       srcSPBInterface=src_spb_interface,\n                                       dstSPAInterface=dst_spa_interface,\n                                       dstSPBInterface=dst_spb_interface)\n\n        resp = self.action('resume', **req_body)\n        resp.raise_if_err()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef failover(self, sync=None, force=None):\n        req_body = self._cli.make_body(sync=sync, force=force)\n        resp = self.action('failover', **req_body)\n        resp.raise_if_err()\n        return resp", "response": "This method is used to fail a replication session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef failback(self, force_full_copy=None):\n        req_body = self._cli.make_body(forceFullCopy=force_full_copy)\n        resp = self.action('failback', **req_body)\n        resp.raise_if_err()\n        return resp", "response": "This method will fail back a replication session."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprepare data structure for breaking data into orbits. Not intended for end user.", "response": "def _calcOrbits(self):\n        \"\"\"Prepares data structure for breaking data into orbits. Not intended\n        for end user.\"\"\"\n        # if the breaks between orbit have not been defined, define them\n        # also, store the data so that grabbing different orbits does not\n        # require reloads of whole dataset\n        if len(self._orbit_breaks) == 0:\n            # determine orbit breaks\n            self._detBreaks()\n            # store a copy of data\n            self._fullDayData = self.sat.data.copy()\n            # set current orbit counter to zero (default)\n            self._current = 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _equaBreaks(self, orbit_index_period=24.):\n\n        if self.orbit_index is None:\n            raise ValueError('Orbit properties must be defined at ' +\n                             'pysat.Instrument object instantiation.' + \n                             'See Instrument docs.')\n        else:\n            try:\n                self.sat[self.orbit_index]\n            except ValueError:\n                raise ValueError('Provided orbit index does not exist in ' +\n                                 'loaded data')\n        # get difference in orbit index around the orbit\n        lt_diff = self.sat[self.orbit_index].diff()\n        # universal time values, from datetime index\n        ut_vals = Series(self.sat.data.index)\n        # UT difference\n        ut_diff = ut_vals.diff()\n\n        # get locations where orbit index derivative is less than 0\n        # then do some basic checks on these locations\n        ind, = np.where((lt_diff < -0.1))\n        if len(ind) > 0:\n            ind = np.hstack((ind, np.array([len(self.sat[self.orbit_index])])))\n            # look at distance between breaks\n            dist = ind[1:] - ind[0:-1]\n            # only keep orbit breaks with a distance greater than 1\n            # done for robustness\n            if len(ind) > 1:\n                if min(dist) == 1:\n                    print('There are orbit breaks right next to each other')\n                ind = ind[:-1][dist > 1]\n\n            # check for large positive gradients around the break that would\n            # suggest not a true orbit break, but rather bad orbit_index values\n            new_ind = []\n            for idx in ind:\n                tidx, = np.where(lt_diff[idx - 5:idx + 6] > 0.1)\n\n                if len(tidx) != 0:\n                    # there are large changes, suggests a false alarm\n                    # iterate over samples and check\n                    for tidx in tidx:\n                        # look at time change vs local time change\n                        if(ut_diff[idx - 5:idx + 6].iloc[tidx] <\n                           lt_diff[idx - 5:idx + 6].iloc[tidx] /\n                           orbit_index_period * self.orbit_period):\n                            # change in ut is small compared to the change in\n                            # the orbit index this is flagged as a false alarm,\n                            # or dropped from consideration\n                            pass\n                        else:\n                            # change in UT is significant, keep orbit break\n                            new_ind.append(idx)\n                            break\n                else:\n                    # no large positive gradients, current orbit break passes\n                    # the first test\n                    new_ind.append(idx)\n            # replace all breaks with those that are 'good'\n            ind = np.array(new_ind)\n\n        # now, assemble some orbit breaks that are not triggered by changes in\n        # the orbit index\n\n        # check if there is a UT break that is larger than orbital period, aka\n        # a time gap\n        ut_change_vs_period = ( ut_diff > self.orbit_period )\n        # characterize ut change using orbital period\n        norm_ut = ut_diff / self.orbit_period\n        # now, look for breaks because the length of time between samples is\n        # too large, thus there is no break in slt/mlt/etc, lt_diff is small\n        # but UT change is big\n        norm_ut_vs_norm_lt = norm_ut.gt(np.abs(lt_diff.values /\n                                               orbit_index_period))\n        # indices when one or other flag is true\n        ut_ind, = np.where(ut_change_vs_period | (norm_ut_vs_norm_lt &\n                                                  (norm_ut > 0.95)))\n        # added the or and check after or on 10/20/2014\n        # & lt_diff.notnull() ))# & (lt_diff != 0)  ) )\n\n        # combine these UT determined orbit breaks with the orbit index orbit\n        # breaks\n        if len(ut_ind) > 0:\n            ind = np.hstack((ind, ut_ind))\n            ind = np.sort(ind)\n            ind = np.unique(ind)\n            print('Time Gap')\n\n        # now that most problems in orbits should have been caught, look at\n        # the time difference between orbits (not individual orbits)\n        orbit_ut_diff = ut_vals[ind].diff()\n        orbit_lt_diff = self.sat[self.orbit_index][ind].diff()\n        # look for time gaps between partial orbits. The full orbital time\n        # period is not required between end of one orbit and begining of next\n        # if first orbit is partial.  Also provides another general test of the\n        # orbital breaks determined.\n        idx, = np.where((orbit_ut_diff / self.orbit_period -\n                         orbit_lt_diff.values / orbit_index_period) > 0.97)\n        # pull out breaks that pass the test, need to make sure the first one\n        # is always included it gets dropped via the nature of diff\n        if len(idx) > 0:\n            if idx[0] != 0:\n                idx = np.hstack((0, idx))\n        else:\n            idx = np.array([0])\n        # only keep the good indices\n        if len(ind) > 0:\n            ind = ind[idx]\n            # create orbitbreak index, ensure first element is always 0\n            if ind[0] != 0:\n                ind = np.hstack((np.array([0]), ind))\n        else:\n            ind = np.array([0])\n        # number of orbits\n        num_orbits = len(ind)\n        # set index of orbit breaks\n        self._orbit_breaks = ind\n        # set number of orbits for the day\n        self.num = num_orbits", "response": "Determine where breaks in an equatorial satellite orbit occur."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining where breaks in a polar orbiting satellite orbit occur.", "response": "def _polarBreaks(self):\n        \"\"\"Determine where breaks in a polar orbiting satellite orbit occur.\n\n        Looks for sign changes in latitude (magnetic or geographic) as well as \n        breaks in UT.\n        \"\"\"\n\n        if self.orbit_index is None:\n            raise ValueError('Orbit properties must be defined at ' +\n                             'pysat.Instrument object instantiation.' + \n                             'See Instrument docs.')\n        else:\n            try:\n                self.sat[self.orbit_index]\n            except ValueError:\n                raise ValueError('Provided orbit index does not appear to ' +\n                                 'exist in loaded data')\n\n        # determine where orbit index goes from positive to negative\n        pos = (self.sat[self.orbit_index] >= 0)\n        npos = -pos\n        change = (pos.values[:-1] & npos.values[1:]) | (npos.values[:-1] &\n                                                        pos.values[1:])\n\n        ind, = np.where(change)\n        ind += 1\n\n        ut_diff = Series(self.sat.data.index).diff()\n        ut_ind, = np.where(ut_diff / self.orbit_period > 0.95)\n\n        if len(ut_ind) > 0:\n            ind = np.hstack((ind, ut_ind))\n            ind = np.sort(ind)\n            ind = np.unique(ind)\n            # print 'Time Gap'\n\n        # create orbitbreak index, ensure first element is always 0\n        if ind[0] != 0:\n            ind = np.hstack((np.array([0]), ind))\n        # number of orbits\n        num_orbits = len(ind)\n        # set index of orbit breaks\n        self._orbit_breaks = ind\n        # set number of orbits for the day\n        self.num = num_orbits"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine where orbital breaks occur in a dataset with orbit numbers occur.", "response": "def _orbitNumberBreaks(self):\n        \"\"\"Determine where orbital breaks in a dataset with orbit numbers occur.\n\n        Looks for changes in unique values.\n\n        \"\"\"\n\n        if self.orbit_index is None:\n            raise ValueError('Orbit properties must be defined at ' +\n                             'pysat.Instrument object instantiation.' +\n                             'See Instrument docs.')\n        else:\n            try:\n                self.sat[self.orbit_index]\n            except ValueError:\n                raise ValueError('Provided orbit index does not appear to ' +\n                                 'exist in loaded data')\n\n        # determine where the orbit index changes from one value to the next\n        uniq_vals = self.sat[self.orbit_index].unique()\n        orbit_index = []\n        for val in uniq_vals:\n            idx, = np.where(val == self.sat[self.orbit_index].values)\n            orbit_index.append(idx[0])\n\n        # create orbitbreak index, ensure first element is always 0\n        if orbit_index[0] != 0:\n            ind = np.hstack((np.array([0]), orbit_index))\n        else:\n            ind = orbit_index\n        # number of orbits\n        num_orbits = len(ind)\n        # set index of orbit breaks\n        self._orbit_breaks = ind\n        # set number of orbits for the day\n        self.num = num_orbits"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getBasicOrbit(self, orbit=None):\n        # ensure data exists\n        if not self.sat.empty:\n            # ensure proper orbit metadata present\n            self._calcOrbits()\n\n            # ensure user is requesting a particular orbit\n            if orbit is not None:\n                # pull out requested orbit\n                if orbit == -1:\n                    # load orbit data into data\n                    self.sat.data = self._fullDayData[self._orbit_breaks[self.num + orbit]:]\n                    self._current = self.num + orbit + 1\n                elif ((orbit < 0) & (orbit >= -self.num)):\n                    # load orbit data into data\n                    self.sat.data = self._fullDayData[\n                                    self._orbit_breaks[self.num + orbit]:self._orbit_breaks[self.num + orbit + 1]]\n                    self._current = self.num + orbit + 1\n                elif (orbit < self.num) & (orbit != 0):\n                    # load orbit data into data\n                    self.sat.data = self._fullDayData[self._orbit_breaks[orbit - 1]:self._orbit_breaks[orbit]]\n                    self._current = orbit\n                elif orbit == self.num:\n                    self.sat.data = self._fullDayData[self._orbit_breaks[orbit - 1]:]\n                    # recent addition, wondering why it wasn't there before,\n                    # could just be a bug that is now fixed.\n                    self._current = orbit\n                elif orbit == 0:\n                    raise ValueError('Orbits internally indexed by 1, 0 not ' +\n                                     'allowed')\n                else:\n                    # gone too far\n                    self.sat.data = []\n                    raise ValueError('Requested an orbit past total orbits ' +\n                                     'for day')\n            else:\n                raise ValueError('Must set an orbit')", "response": "Load a particular orbit into. data for loaded day."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a particular orbit into the data for the current day.", "response": "def load(self, orbit=None):\n        \"\"\"Load a particular orbit into .data for loaded day.\n\n        Parameters\n        ----------\n        orbit : int\n            orbit number, 1 indexed\n\n        Note\n        ----    \n        A day of data must be loaded before this routine functions properly.\n        If the last orbit of the day is requested, it will automatically be\n        padded with data from the next day. The orbit counter will be \n        reset to 1.\n        \"\"\"\n        if not self.sat.empty:  # ensure data exists\n            # set up orbit metadata\n            self._calcOrbits()\n            # ensure user supplied an orbit\n            if orbit is not None:\n                # pull out requested orbit\n                if orbit < 0:\n                    # negative indexing consistent with numpy, -1 last,\n                    # -2 second to last, etc.\n                    orbit = self.num + 1 + orbit\n\n                if orbit == 1:\n                    # change from orig copied from _core, didn't look correct.\n                    # self._getBasicOrbit(orbit=2)\n                    try:\n                        true_date = self.sat.date  # .copy()\n\n                        self.sat.prev()\n                        # if and else added becuase of CINDI turn off \n                        # 6/5/2013, turn on 10/22/2014\n                        # crashed when starting on 10/22/2014\n                        # prev returned empty data\n                        if not self.sat.empty:\n                            self.load(orbit=-1)\n                        else:\n                            self.sat.next()\n                            self._getBasicOrbit(orbit=1)\n                        # check that this orbit should end on the current day\n                        delta = true_date - self.sat.data.index[0]\n                        # print 'checking if first orbit should land on requested day'\n                        # print self.sat.date, self.sat.data.index[0], delta, delta >= self.orbit_period\n                        if delta >= self.orbit_period:\n                            # the orbit loaded isn't close enough to date\n                            # to be the first orbit of the day, move forward\n                            self.next()\n                    except StopIteration:\n                        # print 'going for basic orbit'\n                        self._getBasicOrbit(orbit=1)\n                        # includes hack to appear to be zero indexed\n                        print('Loaded Orbit:%i' % (self._current - 1))\n                        # check if the first orbit is also the last orbit\n\n                elif orbit == self.num:\n                    # we get here if user asks for last orbit\n                    # make sure that orbit data goes across daybreak as needed\n                    # load previous orbit\n                    if self.num != 1:\n                        self._getBasicOrbit(self.num - 1)\n                        self.next()\n                    else:\n                        self._getBasicOrbit(orbit=-1)\n\n                elif orbit < self.num:\n                    # load orbit data into data\n                    self._getBasicOrbit(orbit)\n                    # includes hack to appear to be zero indexed\n                    print('Loaded Orbit:%i' % (self._current - 1))\n\n                else:\n                    # gone too far\n                    self.sat.data = DataFrame()\n                    raise Exception('Requested an orbit past total orbits for day')\n            else:\n                raise Exception('Must set an orbit')\n        else:\n            print('No data loaded in instrument object to determine orbits.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the next orbit into. data.", "response": "def next(self, *arg, **kwarg):\n        \"\"\"Load the next orbit into .data.\n\n        Note\n        ----\n        Forms complete orbits across day boundaries. If no data loaded\n        then the first orbit from the first date of data is returned.\n        \"\"\"\n\n        # first, check if data exists\n        if not self.sat.empty:\n            # set up orbit metadata\n            self._calcOrbits()\n\n            # if current orbit near the last, must be careful\n            if self._current == (self.num - 1):\n                # first, load last orbit data\n                self._getBasicOrbit(orbit=-1)\n                # End of orbit may occur on the next day\n                load_next = True\n                if self.sat._iter_type == 'date':\n                    delta = self.sat.date - self.sat.data.index[-1] \\\n                            + pds.Timedelta('1 day')\n                    if delta >= self.orbit_period:\n                        # don't need to load the next day because this orbit\n                        # ends more than a orbital period from the next date\n                        load_next = False\n\n                if load_next:\n                    # the end of the user's desired orbit occurs tomorrow, need\n                    # to form a complete orbit save this current orbit, load\n                    # the next day, combine data, select the correct orbit\n                    temp_orbit_data = self.sat.data.copy()\n                    try:\n                        # loading next day/file clears orbit breaks info\n                        self.sat.next()\n                        if not self.sat.empty:\n                            # combine this next day's data with previous last\n                            # orbit, grab the first one\n                            self.sat.data = pds.concat(\n                                [temp_orbit_data[:self.sat.data.index[0] -\n                                                 pds.DateOffset(microseconds=1)],\n                                 self.sat.data])\n                            self._getBasicOrbit(orbit=1)\n                        else:\n                            # no data, go back a day and grab the last orbit.\n                            # As complete as orbit can be\n                            self.sat.prev()\n                            self._getBasicOrbit(orbit=-1)\n                    except StopIteration:\n                        pass\n                    del temp_orbit_data\n                # includes hack to appear to be zero indexed\n                print('Loaded Orbit:%i' % (self._current - 1))\n\n            elif self._current == (self.num):\n                # at the last orbit, need to be careful about getting the next\n                # orbit save this current orbit and load the next day\n                temp_orbit_data = self.sat.data.copy()\n                # load next day, which clears orbit breaks info\n                self.sat.next()\n                # combine this next day orbit with previous last orbit to\n                # ensure things are correct\n                if not self.sat.empty:\n                    pad_next = True\n                    # check if data padding is really needed, only works when\n                    # loading by date\n                    if self.sat._iter_type == 'date':\n                        delta = self.sat.date - temp_orbit_data.index[-1]\n                        if delta >= self.orbit_period:\n                            # the end of the previous orbit is more than an\n                            # orbit away from today we don't have to worry\n                            # about it\n                            pad_next = False\n                    if pad_next:\n                        # orbit went across day break, stick old orbit onto new\n                        # data and grab second orbit (first is old)\n                        self.sat.data = pds.concat(\n                            [temp_orbit_data[:self.sat.data.index[0] -\n                                             pds.DateOffset(microseconds=1)],\n                             self.sat.data])\n                        # select second orbit of combined data\n                        self._getBasicOrbit(orbit=2)\n                    else:\n                        # padding from the previous orbit wasn't needed, can\n                        # just grab the first orbit of loaded data\n                        self._getBasicOrbit(orbit=1)\n                        if self.sat._iter_type == 'date':\n                            delta = self.sat.date + pds.DateOffset(days=1) \\\n                                    - self.sat.data.index[0]\n\n                            if delta < self.orbit_period:\n                                # this orbits end occurs on the next day, though\n                                # we grabbed the first orbit, missing data\n                                # means the first available orbit in the data\n                                # is actually the last for the day. Resetting to\n                                # the second to last orbit and then calling\n                                # next() will get the last orbit, accounting\n                                # for tomorrow's data as well.\n                                self._current = self.num - 1\n                                self.next()\n                else:\n                    # no data for the next day\n                    # continue loading data until there is some\n                    # nextData raises StopIteration when it reaches the end,\n                    # leaving this function\n                    while self.sat.empty:\n                        self.sat.next()\n                    self._getBasicOrbit(orbit=1)\n\n                del temp_orbit_data\n                # includes hack to appear to be zero indexed\n                print('Loaded Orbit:%i' % (self._current - 1))\n\n            elif self._current == 0:\n                # no current orbit set, grab the first one\n                # using load command to specify the first orbit, which\n                # automatically loads prev day if needed to form complete orbit\n                self.load(orbit=1)\n\n            elif self._current < (self.num - 1):\n                # since we aren't close to the last orbit, just pull the next\n                # orbit\n                self._getBasicOrbit(orbit=self._current + 1)\n                # includes hack to appear to be zero indexed\n                print('Loaded Orbit:%i' % (self._current - 1))\n\n            else:\n                raise Exception('You ended up where nobody should ever be. ' +\n                                'Talk to someone about this fundamental ' +\n                                'failure.')\n\n        else:  # no data\n            while self.sat.empty:\n                # keep going until data is found\n                # next raises stopIteration at end of data set, no more data\n                # possible\n                self.sat.next()\n            # we've found data, grab the next orbit\n            self.next()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(fnames, tag=None, sat_id=None):\n\n    data = pds.DataFrame()\n    \n    for filename in fnames:\n        # need to remove date appended to dst filename\n        fname = filename[0:-11]\n        #f = open(fname)\n        with open(fname) as f:\n            lines = f.readlines()\n            idx = 0\n            # check if all lines are good\n            max_lines=0\n            for line in lines:\n                if len(line) > 1:\n                    max_lines+=1\n            yr = np.zeros(max_lines*24, dtype=int)\n            mo = np.zeros(max_lines*24, dtype=int)\n            day = np.zeros(max_lines*24, dtype=int)\n            ut = np.zeros(max_lines*24, dtype=int)\n            dst = np.zeros(max_lines*24, dtype=int)\n            for line in lines:\n                if len(line) > 1:\n                    temp_year = int(line[14:16] + line[3:5]) \n                    if temp_year > 57:\n                        temp_year += 1900\n                    else:\n                        temp_year += 2000\n                        \n                    yr[idx:idx+24] = temp_year\n                    mo[idx:idx+24] = int(line[5:7])\n                    day[idx:idx+24] = int(line[8:10])\n                    ut[idx:idx+24] = np.arange(24)\n                    temp = line.strip()[20:-4]\n                    temp2 = [temp[4*i:4*(i+1)] for i in np.arange(24)]\n                    dst[idx:idx+24] = temp2\n                    idx += 24   \n    \n            #f.close()\n    \n            \n            start = pds.datetime(yr[0], mo[0], day[0], ut[0])\n            stop = pds.datetime(yr[-1], mo[-1], day[-1], ut[-1])\n            dates = pds.date_range(start, stop, freq='H') \n            \n            new_data = pds.DataFrame(dst, index=dates, columns=['dst'])\n            # pull out specific day \n            new_date = pysat.datetime.strptime(filename[-10:], '%Y-%m-%d')\n            idx, = np.where((new_data.index >= new_date) & (new_data.index < new_date+pds.DateOffset(days=1)))\n            new_data = new_data.iloc[idx,:]\n            # add specific day to all data loaded for filenames\n            data = pds.concat([data, new_data], axis=0) \n        \n    return data, pysat.Meta()", "response": "Load Kp index files into a Pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse(yr, mo, day):\n    \n    yr = '20'+yr\n    yr = int(yr)\n    mo = int(mo)\n    day = int(day)\n    return pds.datetime(yr, mo, day)", "response": "Basic parser to deal with date format of the Kp file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload Kp index files into a single DataFrame.", "response": "def load(fnames, tag=None, sat_id=None):\n    \"\"\"Load Kp index files\n\n    Parameters\n    ------------\n    fnames : (pandas.Series)\n        Series of filenames\n    tag : (str or NoneType)\n        tag or None (default=None)\n    sat_id : (str or NoneType)\n        satellite id or None (default=None)\n\n    Returns\n    ---------\n    data : (pandas.DataFrame)\n        Object containing satellite data\n    meta : (pysat.Meta)\n        Object containing metadata such as column names and units\n\n    Notes\n    -----\n    Called by pysat. Not intended for direct use by user.\n    \n    \"\"\"\n\n    # Kp data stored monthly, need to return data daily\n    # the daily date is attached to filename\n    # parse off the last date, load month of data, downselect to desired day\n    data = pds.DataFrame()\n    #set up fixed width format for these files\n    colspec = [(0,2),(2,4),(4,6),(7,10),(10,13),(13,16),(16,19),(19,23),(23,26),(26,29),(29,32),(32,50)]\n    for filename in fnames:\n        # the daily date is attached to filename\n        # parse off the last date, load month of data, downselect to desired day\n        fname = filename[0:-11]\n        date = pysat.datetime.strptime(filename[-10:], '%Y-%m-%d')\n\n        temp = pds.read_fwf(fname, colspecs=colspec, skipfooter=4,header=None, \n                            parse_dates=[[0,1,2]], date_parser=_parse, \n                            index_col='0_1_2')\n        idx, = np.where((temp.index >= date) & (temp.index < date+pds.DateOffset(days=1)))\n        temp = temp.iloc[idx,:]\n        data = pds.concat([data,temp], axis=0)\n        \n    # drop last column as it has data I don't care about\n    data = data.iloc[:,0:-1]\n    \n    # each column increments UT by three hours\n    # produce a single data series that has Kp value monotonically increasing in time\n    # with appropriate datetime indices\n    s = pds.Series()\n    for i in np.arange(8):\n        temp = pds.Series(data.iloc[:,i].values, \n                          index=data.index+pds.DateOffset(hours=int(3*i))  )\n        #print temp\n        s = s.append(temp) \n    s = s.sort_index()\n    s.index.name = 'time'\n    \n    # now, Kp comes in non-user friendly values\n    # 2-, 2o, and 2+ relate to 1.6, 2.0, 2.3\n    # will convert for user friendliness\n    first = np.array([float(x[0]) for x in s])\n    flag = np.array([x[1] for x in s])\n\n    ind, = np.where(flag == '+')\n    first[ind] += 1./3.\n    ind, = np.where(flag == '-')\n    first[ind] -= 1./3.\n    \n    result = pds.DataFrame(first, columns=['kp'], index=s.index)\n        \n    return result, pysat.Meta()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download(date_array, tag, sat_id, data_path, user=None, password=None):\n\n    import ftplib\n    from ftplib import FTP\n    import sys\n    ftp = FTP('ftp.gfz-potsdam.de')   # connect to host, default port\n    ftp.login()               # user anonymous, passwd anonymous@\n    ftp.cwd('/pub/home/obs/kp-ap/tab')\n\n    for date in date_array:\n        fname = 'kp{year:02d}{month:02d}.tab'\n        fname = fname.format(year=(date.year - date.year//100*100), month=date.month)\n        local_fname = fname\n        saved_fname = os.path.join(data_path,local_fname) \n        try:\n            print('Downloading file for '+date.strftime('%D'))\n            sys.stdout.flush()\n            ftp.retrbinary('RETR '+fname, open(saved_fname,'wb').write)\n        except ftplib.error_perm as exception:\n            # if exception[0][0:3] != '550':\n            if str(exception.args[0]).split(\" \", 1)[0] != '550':\n                raise\n            else:\n                os.remove(saved_fname)\n                print('File not available for '+date.strftime('%D'))\n    \n    ftp.close()\n    return", "response": "Download Kp index data for a given date array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter pysat. Instrument data for given time after Kp drops below gate.", "response": "def filter_geoquiet(sat, maxKp=None, filterTime=None, kpData=None, kp_inst=None):\n    \"\"\"Filters pysat.Instrument data for given time after Kp drops below gate.\n    \n    Loads Kp data for the same timeframe covered by sat and sets sat.data to\n    NaN for times when Kp > maxKp and for filterTime after Kp drops below maxKp.\n    \n    Parameters\n    ----------\n    sat : pysat.Instrument\n        Instrument to be filtered\n    maxKp : float\n        Maximum Kp value allowed. Kp values above this trigger\n        sat.data filtering.\n    filterTime : int\n        Number of hours to filter data after Kp drops below maxKp\n    kpData : pysat.Instrument (optional)\n        Kp pysat.Instrument object with data already loaded\n    kp_inst : pysat.Instrument (optional)\n        Kp pysat.Instrument object ready to load Kp data.Overrides kpData.\n        \n    Returns\n    -------\n    None : NoneType\n        sat Instrument object modified in place\n        \n    \"\"\"\n    if kp_inst is not None:\n        kp_inst.load(date=sat.date, verifyPad=True)\n        kpData = kp_inst\n    elif kpData is None:\n        kp = pysat.Instrument('sw', 'kp', pad=pds.DateOffset(days=1))\n        kp.load(date=sat.date, verifyPad=True)\n        kpData = kp\n        \n    \n    if maxKp is None:\n        maxKp = 3+ 1./3.\n        \n    if filterTime is None:\n        filterTime = 24\n        \n    # now the defaults are ensured, let's do some filtering\n    # date of satellite data\n    date = sat.date\n    selData = kpData[date-pds.DateOffset(days=1):date+pds.DateOffset(days=1)]\n    ind, = np.where(selData['kp'] >= maxKp)\n    for lind in ind:\n        sat.data[selData.index[lind]:(selData.index[lind]+pds.DateOffset(hours=filterTime) )] = np.NaN\n        sat.data = sat.data.dropna(axis=0, how='all')\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding converter function reference by name", "response": "def _get_converter(self, converter_str):\n        \"\"\"find converter function reference by name\n\n        find converter by name, converter name follows this convention:\n\n            Class.method\n\n        or:\n\n            method\n\n        The first type of converter class/function must be available in\n        current module.\n        The second type of converter must be available in `__builtin__`\n        (or `builtins` in python3) module.\n\n        :param converter_str: string representation of the converter func\n        :return: function reference\n        \"\"\"\n        ret = None\n        if converter_str is not None:\n            converter_desc_list = converter_str.split('.')\n            if len(converter_desc_list) == 1:\n                converter = converter_desc_list[0]\n                # default to `converter`\n                ret = getattr(cvt, converter, None)\n\n                if ret is None:\n                    # try module converter\n                    ret = self.get_converter(converter)\n\n                if ret is None:\n                    ret = self.get_resource_clz_by_name(converter)\n\n                if ret is None:\n                    ret = self.get_enum_by_name(converter)\n\n                if ret is None:\n                    # try parser config\n                    ret = self.get(converter)\n\n            if ret is None and converter_str is not None:\n                raise ValueError(\n                    'Specified converter not supported: {}'.format(\n                        converter_str))\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy_file_to_remote(self, local_path, remote_path):\n        sftp_client = self.transport.open_sftp_client()\n        LOG.debug('Copy the local file to remote. '\n                  'Source=%(src)s. Target=%(target)s.' %\n                  {'src': local_path, 'target': remote_path})\n        try:\n            sftp_client.put(local_path, remote_path)\n        except Exception as ex:\n            LOG.error('Failed to copy the local file to remote. '\n                      'Reason: %s.' % six.text_type(ex))\n            raise SFtpExecutionError(err=ex)", "response": "Copy the local file to remote folder."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_remote_file(self, remote_path, local_path):\n        sftp_client = self.transport.open_sftp_client()\n        LOG.debug('Get the remote file. '\n                  'Source=%(src)s. Target=%(target)s.' %\n                  {'src': remote_path, 'target': local_path})\n        try:\n            sftp_client.get(remote_path, local_path)\n        except Exception as ex:\n            LOG.error('Failed to secure copy. Reason: %s.' %\n                      six.text_type(ex))\n            raise SFtpExecutionError(err=ex)", "response": "Fetch the remote file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclosing the ssh connection.", "response": "def close(self):\n        \"\"\"Closes the ssh connection.\"\"\"\n        if 'isLive' in self.__dict__ and self.isLive:\n            self.transport.close()\n            self.isLive = False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xml_request(check_object=False, check_invalid_data_mover=False):\n\n    def decorator(f):\n        @functools.wraps(f)\n        def func_wrapper(self, *argv, **kwargs):\n            request = f(self, *argv, **kwargs)\n            return self.request(\n                request, check_object=check_object,\n                check_invalid_data_mover=check_invalid_data_mover)\n\n        return func_wrapper\n\n    return decorator", "response": "Decorator for the request method that returns a xml api response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nas_command(f):\n\n    @functools.wraps(f)\n    def func_wrapper(self, *argv, **kwargs):\n        commands = f(self, *argv, **kwargs)\n        return self.ssh_execute(['env', 'NAS_DB=/nas'] + commands)\n\n    return func_wrapper", "response": "indicate it s a command of nas command run with ssh\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restore(self, backup=None, delete_backup=False):\n        resp = self._cli.action(self.resource_class, self.get_id(),\n                                'restore', copyName=backup)\n        resp.raise_if_err()\n        backup = resp.first_content['backup']\n        backup_snap = UnitySnap(_id=backup['id'], cli=self._cli)\n\n        if delete_backup:\n            log.info(\"Deleting the backup snap {} as the restoration \"\n                     \"succeeded.\".format(backup['id']))\n            backup_snap.delete()\n\n        return backup_snap", "response": "Restores the snapshot to the associated storage resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new thin clone from this snapshot.", "response": "def thin_clone(self, name, io_limit_policy=None, description=None):\n        \"\"\"Creates a new thin clone from this snapshot.\n        .. note:: this snapshot should not enable Auto-Delete.\n        \"\"\"\n        if self.is_member_snap():\n            raise UnityCGMemberActionNotSupportError()\n\n        if self.lun and not self.lun.is_thin_enabled:\n            raise UnityThinCloneNotAllowedError()\n\n        return TCHelper.thin_clone(self._cli, self, name, io_limit_policy,\n                                   description)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, async_mode=False, even_attached=False):\n        try:\n            return super(UnitySnap, self).delete(async_mode=async_mode)\n        except UnityDeleteAttachedSnapError:\n            if even_attached:\n                log.debug(\"Force delete the snapshot even if it is attached. \"\n                          \"First detach the snapshot from hosts, then delete \"\n                          \"again.\")\n                # Currently `detach_from` doesn't process `host` parameter.\n                # It always detaches the snapshot from all hosts. So pass in\n                # `None` here.\n                self.detach_from(None)\n                return super(UnitySnap, self).delete(async_mode=async_mode)\n            else:\n                raise", "response": "Deletes the snapshot.\n\n        :param async_mode: whether to delete the snapshot in async mode.\n        :param even_attached: whether to delete the snapshot even it is\n            attached to hosts."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all resource class objects.", "response": "def get_all(self, type_name, base_fields=None, the_filter=None,\n                nested_fields=None):\n        \"\"\"Get the resource by resource id.\n\n        :param nested_fields: nested resource fields\n        :param base_fields: fields of this resource\n        :param the_filter: dictionary of filter like `{'name': 'abc'}`\n        :param type_name: Resource type. For example, pool, lun, nasServer.\n        :return: List of resource class objects\n        \"\"\"\n        fields = self.get_fields(type_name, base_fields, nested_fields)\n        the_filter = self.dict_to_filter_string(the_filter)\n\n        url = '/api/types/{}/instances'.format(type_name)\n\n        resp = self.rest_get(url, fields=fields, filter=the_filter)\n        ret = resp\n        while resp.has_next_page:\n            resp = self.rest_get(url, fields=fields, filter=the_filter,\n                                 page=resp.next_page)\n            ret.entries.extend(resp.entries)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the resource by resource id.", "response": "def get(self, type_name, obj_id, base_fields=None, nested_fields=None):\n        \"\"\"Get the resource by resource id.\n\n        :param nested_fields: nested resource fields.\n        :param type_name: Resource type. For example, pool, lun, nasServer.\n        :param obj_id: Resource id\n        :param base_fields: Resource fields to return\n        :return: List of tuple [(name, res_inst)]\n        \"\"\"\n        base_fields = self.get_fields(type_name, base_fields, nested_fields)\n        url = '/api/instances/{}/{}'.format(type_name, obj_id)\n        return self.rest_get(url, fields=base_fields)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if there are any snapshots in the destroying state.", "response": "def has_snap(self):\n        \"\"\" This method won't count the snaps in \"destroying\" state!\n\n        :return: false if no snaps or all snaps are destroying.\n        \"\"\"\n        return len(list(filter(lambda s: s.state != SnapStateEnum.DESTROYING,\n                               self.snapshots))) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a 2D median accessed by data_label over a season.", "response": "def median2D(const, bin1, label1, bin2, label2, data_label, \n             returnData=False):\n    \"\"\"Return a 2D average of data_label over a season and label1, label2.\n\n    Parameters\n    ----------\n        const: Constellation or Instrument\n        bin#: [min, max, number of bins]\n        label#: string \n            identifies data product for bin#\n        data_label: list-like \n            contains strings identifying data product(s) to be averaged\n\n    Returns\n    -------\n    median : dictionary\n        2D median accessed by data_label as a function of label1 and label2\n        over the season delineated by bounds of passed instrument objects.\n        Also includes 'count' and 'avg_abs_dev' as well as the values of\n        the bin edges in 'bin_x' and 'bin_y'.\n    \n    \"\"\"\n\n    # const is either an Instrument or a Constellation, and we want to \n    #  iterate over it. \n    # If it's a Constellation, then we can do that as is, but if it's\n    #  an Instrument, we just have to put that Instrument into something\n    #  that will yeild that Instrument, like a list.\n    if isinstance(const, pysat.Instrument):\n        const = [const]\n    elif not isinstance(const, pysat.Constellation):\n        raise ValueError(\"Parameter must be an Instrument or a Constellation.\")\n\n    # create bins\n    #// seems to create the boundaries used for sorting into bins\n    binx = np.linspace(bin1[0], bin1[1], bin1[2]+1)\n    biny = np.linspace(bin2[0], bin2[1], bin2[2]+1)\n\n    #// how many bins are used\n    numx = len(binx)-1\n    numy = len(biny)-1\n    #// how many different data products\n    numz = len(data_label)\n\n    # create array to store all values before taking median\n    #// the indices of the bins/data products? used for looping.\n    yarr = np.arange(numy)\n    xarr = np.arange(numx)\n    zarr = np.arange(numz)\n    #// 3d array:  stores the data that is sorted into each bin? - in a deque\n    ans = [ [ [collections.deque() for i in xarr] for j in yarr] for k in zarr]\n\n    for inst in const:\n        # do loop to iterate over instrument season\n        #// probably iterates by date but that all depends on the\n        #// configuration of that particular instrument. \n        #// either way, it iterates over the instrument, loading successive\n        #// data between start and end bounds\n        for inst in inst:\n            # collect data in bins for averaging\n            if len(inst.data) != 0:\n                #// sort the data into bins (x) based on label 1\n                #// (stores bin indexes in xind)\n                xind = np.digitize(inst.data[label1], binx)-1\n                #// for each possible x index\n                for xi in xarr:\n                    #// get the indicies of those pieces of data in that bin\n                    xindex, = np.where(xind==xi)\n                    if len(xindex) > 0:\n                        #// look up the data along y (label2) at that set of indicies (a given x)\n                        yData = inst.data.iloc[xindex]\n                        #// digitize that, to sort data into bins along y (label2) (get bin indexes)\n                        yind = np.digitize(yData[label2], biny)-1\n                        #// for each possible y index\n                        for yj in yarr:\n                            #// select data with this y index (and we already filtered for this x index)\n                            yindex, = np.where(yind==yj)\n                            if len(yindex) > 0:\n                                #// for each data product label zk\n                                for zk in zarr:\n                                    #// take the data (already filtered by x); filter it by y and \n                                    #// select the data product, put it in a list, and extend the deque\n                                    ans[zk][yj][xi].extend( yData.ix[yindex,data_label[zk]].tolist() )\n\n    return _calc_2d_median(ans, data_label, binx, biny, xarr, yarr, zarr, numx, numy, numz, returnData)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of resource list to collect based on clz list", "response": "def get_rsc_list_2(self, rsc_clz_list=None):\n        \"\"\"get the list of resource list to collect based on clz list\n\n        :param rsc_clz_list: the list of classes to collect\n        :return: filtered list of resource list,\n                 like [VNXLunList(), VNXDiskList()]\n        \"\"\"\n        rsc_list_2 = self._default_rsc_list_with_perf_stats()\n        if rsc_clz_list is None:\n            rsc_clz_list = ResourceList.get_rsc_clz_list(rsc_list_2)\n\n        return [rsc_list\n                for rsc_list in rsc_list_2\n                if rsc_list.get_resource_class() in rsc_clz_list]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads cosmic data from list of cosmic files", "response": "def load(cosmicFiles, tag=None, sat_id=None):\n    \"\"\"\n    cosmic data load routine, called by pysat\n    \"\"\"   \n    import netCDF4\n\n    num = len(cosmicFiles)\n    # make sure there are files to read\n    if num != 0:\n        # call separate load_files routine, segemented for possible\n        # multiprocessor load, not included and only benefits about 20%\n        output = pysat.DataFrame(load_files(cosmicFiles, tag=tag, sat_id=sat_id))\n        output.index = pysat.utils.create_datetime_index(year=output.year, \n                month=output.month, day=output.day, \n                uts=output.hour*3600.+output.minute*60.+output.second)\n        # make sure UTS strictly increasing\n        output.sort_index(inplace=True)\n        # use the first available file to pick out meta information\n        meta = pysat.Meta()\n        ind = 0\n        repeat = True\n        while repeat:\n            try:\n                data = netCDF4.Dataset(cosmicFiles[ind]) \n                ncattrsList = data.ncattrs()\n                for d in ncattrsList:\n                    meta[d] = {'units':'', 'long_name':d}\n                keys = data.variables.keys()\n                for key in keys:\n                    meta[key] = {'units':data.variables[key].units, \n                                'long_name':data.variables[key].long_name}  \n                repeat = False                  \n            except RuntimeError:\n                # file was empty, try the next one by incrementing ind\n                ind+=1\n                                    \n        return output, meta\n    else:\n        # no data\n        return pysat.DataFrame(None), pysat.Meta()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload a list of COSMIC data files supplied by user.", "response": "def load_files(files, tag=None, sat_id=None):\n    '''Loads a list of COSMIC data files, supplied by user.\n    \n    Returns a list of dicts, a dict for each file.\n    '''\n       \n    output = [None]*len(files)\n    drop_idx = []\n    for (i,file) in enumerate(files):\n        try:\n            data = netCDF4.Dataset(file)    \n            # build up dictionary will all ncattrs\n            new = {} \n            # get list of file attributes\n            ncattrsList = data.ncattrs()\n            for d in ncattrsList:\n                new[d] = data.getncattr(d)            \n            # load all of the variables in the netCDF\n            loadedVars={}\n            keys = data.variables.keys()\n            for key in keys:\n                loadedVars[key] = data.variables[key][:]               \n            new['profiles'] = pysat.DataFrame(loadedVars)\n            if tag == 'ionprf':\n                new['profiles'].index = new['profiles']['MSL_alt']\n            output[i] = new   \n            data.close()\n        except RuntimeError:\n            # some of the S4 files have zero bytes, which causes a read error\n            # this stores the index of these zero byte files so I can drop \n            # the Nones the gappy file leaves behind\n            drop_idx.append(i)\n\n    # drop anything that came from the zero byte files\n    drop_idx.reverse()\n    for i in drop_idx:\n        del output[i]\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads data from Madrigal.", "response": "def download(date_array, tag, sat_id, data_path=None, user=None, password=None):\n    \"\"\"Downloads data from Madrigal.\n    \n    The user's names should be provided in field user. John Malkovich should be \n    entered as John+Malkovich \n    \n    The password field should be the user's email address. These parameters\n    are passed to Madrigal when downloading.\n    \n    The affiliation field is set to pysat to enable tracking of pysat downloads.\n    \n    Parameters\n    ----------\n    \n    \n    \"\"\"\n    import subprocess\n    \n    # currently passes things along if no user and password supplied\n    # need to do this for testing\n    # TODO, implement user and password values in test code\n    # specific to DMSP\n    if user is None:\n        print ('No user information supplied for download.')\n        user = 'pysat_testing'\n    if password is None:\n        print ('Please provide email address in password field.')\n        password = 'pysat_testing@not_real_email.org'\n\n    a = subprocess.check_output([\"globalDownload.py\", \"--verbose\", \n                    \"--url=http://cedar.openmadrigal.org\",\n                    '--outputDir='+data_path,\n                    '--user_fullname='+user,\n                    '--user_email='+password,\n                    '--user_affiliation=pysat',\n                    '--format=hdf5',\n                    '--startDate='+date_array[0].strftime('%m/%d/%Y'),\n                    '--endDate='+date_array[-1].strftime('%m/%d/%Y'),\n                    '--inst=8100',\n                    '--kindat='+str(madrigal_tag[sat_id])])\n    print ('Feedback from openMadrigal ', a)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(cls, cli, management_address,\n               local_username=None, local_password=None,\n               remote_username=None, remote_password=None,\n               connection_type=None):\n        \"\"\"\n        Configures a remote system for remote replication.\n\n        :param cls: this class.\n        :param cli: the rest client.\n        :param management_address: the management IP address of the remote\n            system.\n        :param local_username: administrative username of local system.\n        :param local_password: administrative password of local system.\n        :param remote_username: administrative username of remote system.\n        :param remote_password: administrative password of remote system.\n        :param connection_type: `ReplicationCapabilityEnum`. Replication\n            connection type to the remote system.\n        :return: the newly created remote system.\n        \"\"\"\n\n        req_body = cli.make_body(\n            managementAddress=management_address, localUsername=local_username,\n            localPassword=local_password, remoteUsername=remote_username,\n            remotePassword=remote_password, connectionType=connection_type)\n\n        resp = cli.post(cls().resource_class, **req_body)\n        resp.raise_if_err()\n        return cls.get(cli, resp.resource_id)", "response": "Creates a new replication system for the given local system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmodifying a remote system for remote replication.", "response": "def modify(self, management_address=None, username=None, password=None,\n               connection_type=None):\n        \"\"\"\n        Modifies a remote system for remote replication.\n\n        :param management_address: same as the one in `create` method.\n        :param username: username for accessing the remote system.\n        :param password: password for accessing the remote system.\n        :param connection_type: same as the one in `create` method.\n        \"\"\"\n        req_body = self._cli.make_body(\n            managementAddress=management_address, username=username,\n            password=password, connectionType=connection_type)\n\n        resp = self.action('modify', **req_body)\n        resp.raise_if_err()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nverifies and updates the remote system settings.", "response": "def verify(self, connection_type=None):\n        \"\"\"\n        Verifies and update the remote system settings.\n\n        :param connection_type: same as the one in `create` method.\n        \"\"\"\n        req_body = self._cli.make_body(connectionType=connection_type)\n\n        resp = self.action('verify', **req_body)\n        resp.raise_if_err()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(cls, cli, sp, ip_port, ip_address, netmask=None,\n               v6_prefix_length=None, gateway=None, vlan_id=None):\n        \"\"\"\n        Creates a replication interface.\n\n        :param cls: this class.\n        :param cli: the rest cli.\n        :param sp: `UnityStorageProcessor` object. Storage processor on which\n            the replication interface is running.\n        :param ip_port: `UnityIpPort` object. Physical port or link aggregation\n            on the storage processor on which the interface is running.\n        :param ip_address: IP address of the replication interface.\n        :param netmask: IPv4 netmask for the replication interface, if it uses\n            an IPv4 address.\n        :param v6_prefix_length: IPv6 prefix length for the interface, if it\n            uses an IPv6 address.\n        :param gateway: IPv4 or IPv6 gateway address for the replication\n            interface.\n        :param vlan_id: VLAN identifier for the interface.\n        :return: the newly create replication interface.\n        \"\"\"\n        req_body = cli.make_body(sp=sp, ipPort=ip_port,\n                                 ipAddress=ip_address, netmask=netmask,\n                                 v6PrefixLength=v6_prefix_length,\n                                 gateway=gateway, vlanId=vlan_id)\n\n        resp = cli.post(cls().resource_class, **req_body)\n        resp.raise_if_err()\n        return cls.get(cli, resp.resource_id)", "response": "Creates a replication interface."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmodify a replication interface.", "response": "def modify(self, sp=None, ip_port=None, ip_address=None, netmask=None,\n               v6_prefix_length=None, gateway=None, vlan_id=None):\n        \"\"\"\n        Modifies a replication interface.\n\n        :param sp: same as the one in `create` method.\n        :param ip_port: same as the one in `create` method.\n        :param ip_address: same as the one in `create` method.\n        :param netmask: same as the one in `create` method.\n        :param v6_prefix_length: same as the one in `create` method.\n        :param gateway: same as the one in `create` method.\n        :param vlan_id: same as the one in `create` method.\n        \"\"\"\n        req_body = self._cli.make_body(sp=sp, ipPort=ip_port,\n                                       ipAddress=ip_address, netmask=netmask,\n                                       v6PrefixLength=v6_prefix_length,\n                                       gateway=gateway, vlanId=vlan_id)\n\n        resp = self.action('modify', **req_body)\n        resp.raise_if_err()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sp_sum_values(self):\n        if self.values is None:\n            ret = IdValues()\n        else:\n            ret = IdValues({k: sum(int(x) for x in v.values()) for k, v in\n                            self.values.items()})\n        return ret", "response": "return sp level values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sum_sp_values(self):\n        if self.values is None:\n            ret = IdValues()\n        else:\n            ret = IdValues({'0': sum(int(x) for x in self.values.values())})\n        return ret", "response": "return system level values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncombine numeric values of the two sets of attributes.", "response": "def combine_numeric_values(self, other):\n        \"\"\"\n        numeric_values * sp_values\n        \"\"\"\n        if self.values is None:\n            ret = IdValues()\n        else:\n            ret = sum([IdValues(\n                {k: int(v) * int(other.values[key]) for k, v in value.items()})\n                for key, value in self.values.items()])\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef combine_sp_values(self, other):\n        if self.values is None:\n            ret = IdValues()\n        else:\n            ret = IdValues({k: int(v) * int(other.values[k]) for k, v in\n                            self.values.items()})\n        return ret", "response": "Combine the set of values from self and other into a single set of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sum_combined_sp_values(self, other):\n        if self.values is None:\n            ret = IdValues()\n        else:\n            ret = IdValues({'0': sum(int(x) for x in\n                                     {k: int(v) * int(other.values[k]) for k, v\n                                      in self.values.items()}.values())})\n        return ret", "response": "Sums the sp values of two sets of attributes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a function to a specific entry in the custom processing queue.", "response": "def add(self, function, kind='add', at_pos='end',*args, **kwargs):\n        \"\"\"Add a function to custom processing queue. \n        \n        Custom functions are applied automatically to associated\n        pysat instrument whenever instrument.load command called.\n\n        Parameters\n        ----------\n            function : string or function object\n                name of function or function object to be added to queue\n            \n            kind : {'add', 'modify', 'pass}\n                add \n                    Adds data returned from function to instrument object. \n                    A copy of pysat instrument object supplied to routine. \n                modify  \n                    pysat instrument object supplied to routine. Any and all\n                    changes to object are retained.\n                pass  \n                    A copy of pysat object is passed to function. No \n                    data is accepted from return.\n                       \n            at_pos : string or int \n                insert at position. (default, insert at end).\n            args : extra arguments\n                extra arguments are passed to the custom function (once)\n            kwargs : extra keyword arguments\n                extra keyword args are passed to the custom function (once)\n\n        Note\n        ----\n        Allowed `add` function returns:\n\n        - {'data' : pandas Series/DataFrame/array_like,\n          'units' : string/array_like of strings, \n          'long_name' : string/array_like of strings,\n          'name' : string/array_like of strings (iff data array_like)} \n\n        - pandas DataFrame, names of columns are used\n\n        - pandas Series, .name required \n\n        - (string/list of strings, numpy array/list of arrays) \n        \"\"\"\n\n        if isinstance(function, str):\n            # convert string to function object\n            function=eval(function)\n\n        if (at_pos == 'end') | (at_pos == len(self._functions)):\n            # store function object\n            self._functions.append(function)\n            self._args.append(args)\n            self._kwargs.append(kwargs)\n            self._kind.append(kind.lower())\n        elif at_pos < len(self._functions):\n            # user picked a specific location to insert\n            self._functions.insert(at_pos, function)\n            self._args.insert(at_pos, args)\n            self._kwargs.insert(at_pos, kwargs)\n            self._kind.insert(at_pos, kind)\n        else:\n            raise TypeError('Must enter an index between 0 and %i' %\n                            len(self._functions))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying all of the custom functions to the satellite data object.", "response": "def _apply_all(self, sat):\n        \"\"\"\n        Apply all of the custom functions to the satellite data object.\n        \"\"\"\n        if len(self._functions) > 0:\n            for func, arg, kwarg, kind in zip(self._functions, self._args, \n                                                self._kwargs, self._kind):\n                if len(sat.data) > 0:     \n                    if kind == 'add':\n                        # apply custom functions that add data to the\n                        # instrument object\n                        tempd = sat.copy()\n                        newData = func(tempd, *arg, **kwarg)\n                        del tempd\n\n                        # process different types of data returned by the\n                        # function if a dict is returned, data in 'data'\n                        if isinstance(newData,dict):\n                            # if DataFrame returned, add Frame to existing frame\n                            if isinstance(newData['data'], pds.DataFrame):\n                                sat[newData['data'].columns] = newData\n                            # if a series is returned, add it as a column\n                            elif isinstance(newData['data'], pds.Series):\n                                # look for name attached to series first\n                                if newData['data'].name is not None:\n                                    sat[newData['data'].name] = newData\n                                # look if name is provided as part of dict\n                                # returned from function\n                                elif 'name' in newData.keys():\n                                    name = newData.pop('name')\n                                    sat[name] = newData\n                                # couldn't find name information\n                                else:\n                                    raise ValueError('Must assign a name to ' +\n                                                     'Series or return a ' +\n                                                     '\"name\" in dictionary.')\n\n                            # some kind of iterable was returned\n                            elif hasattr(newData['data'], '__iter__'):\n                                # look for name in returned dict\n                                if 'name' in newData.keys():\n                                    name = newData.pop('name')\n                                    sat[name] = newData\n                                else:\n                                    raise ValueError('Must include \"name\" in ' +\n                                                     'returned dictionary.')\n\n                        # bare DataFrame is returned\n                        elif isinstance(newData, pds.DataFrame):\n                            sat[newData.columns] = newData\n                        # bare Series is returned, name must be attached to\n                        # Series\n                        elif isinstance(newData, pds.Series):\n                            sat[newData.name] = newData      \n\n                        # some kind of iterable returned,\n                        # presuming (name, data)\n                        # or ([name1,...], [data1,...])                      \n                        elif hasattr(newData, '__iter__'):\n                            # falling back to older behavior\n                            # unpack tuple/list that was returned\n                            newName = newData[0]\n                            newData = newData[1]\n                            if len(newData)>0:\n                                # doesn't really check ensure data, there could\n                                # be multiple empty arrays returned, [[],[]]\n                                if isinstance(newName, str):\n                                    # one item to add\n                                    sat[newName] = newData\n                                else:    \t\t\n                                    # multiple items\n                                    for name, data in zip(newName, newData):\n                                        if len(data)>0:        \n                                            # fixes up the incomplete check\n                                            # from before\n                                            sat[name] = data\n                        else:\n                            raise ValueError(\"kernel doesn't know what to do \" +\n                                             \"with returned data.\")\n\n                    # modifying loaded data\n                    if kind == 'modify':\n                        t = func(sat,*arg,**kwarg)\n                        if t is not None:\n                            raise ValueError('Modify functions should not ' +\n                                             'return any information via ' +\n                                             'return. Information may only be' +\n                                             ' propagated back by modifying ' +\n                                             'supplied pysat object.')\n\n                    # pass function (function runs, no data allowed back)\n                    if kind == 'pass':\n                        tempd = sat.copy()\n                        t = func(tempd,*arg,**kwarg)\n                        del tempd\n                        if t is not None:\n                            raise ValueError('Pass functions should not ' +\n                                             'return any information via ' +\n                                             'return.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears the custom function list.", "response": "def clear(self):\n        \"\"\"Clear custom function list.\"\"\"\n        self._functions=[]\n        self._args=[]\n        self._kwargs=[]\n        self._kind=[]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Pandas Series of every file for the chosen satellite.", "response": "def list_files(tag='north', sat_id=None, data_path=None, format_str=None):\n    \"\"\"Return a Pandas Series of every file for chosen satellite data\n\n    Parameters\n    -----------\n    tag : (string)\n        Denotes type of file to load.  Accepted types are 'north' and 'south'.\n        (default='north')\n    sat_id : (string or NoneType)\n        Specifies the satellite ID for a constellation.  Not used.\n        (default=None)\n    data_path : (string or NoneType)\n        Path to data directory.  If None is specified, the value previously\n        set in Instrument.files.data_path is used.  (default=None)\n    format_str : (string or NoneType)\n        User specified file format.  If None is specified, the default\n        formats associated with the supplied tags are used. (default=None)\n\n    Returns\n    --------\n    pysat.Files.from_os : (pysat._files.Files)\n        A class containing the verified available files\n    \"\"\"\n\n    if format_str is None and tag is not None:\n        if tag == 'north' or tag == 'south':\n            hemi_fmt = ''.join(('{year:4d}{month:02d}{day:02d}.', tag, '.grdex'))\n            return pysat.Files.from_os(data_path=data_path, format_str=hemi_fmt)\n        else:\n            estr = 'Unrecognized tag name for SuperDARN, north or south.'\n            raise ValueError(estr)                  \n    elif format_str is None:\n        estr = 'A tag name must be passed to SuperDARN.'\n        raise ValueError (estr)\n    else:\n        return pysat.Files.from_os(data_path=data_path, format_str=format_str)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads SuperDARN data from Virginia Tech organized for loading by pysat.", "response": "def download(date_array, tag, sat_id, data_path, user=None, password=None):\n    \"\"\"\n    Download SuperDARN data from Virginia Tech organized for loading by pysat.\n\n    \"\"\"\n\n    import sys\n    import os\n    import pysftp\n    import davitpy\n    \n    if user is None:\n        user = os.environ['DBREADUSER']\n    if password is None:\n        password = os.environ['DBREADPASS']\n        \n    with pysftp.Connection(\n            os.environ['VTDB'], \n            username=user,\n            password=password) as sftp:\n            \n        for date in date_array:\n            myDir = '/data/'+date.strftime(\"%Y\")+'/grdex/'+tag+'/'\n            fname = date.strftime(\"%Y%m%d\")+'.' + tag + '.grdex'\n            local_fname = fname+'.bz2'\n            saved_fname = os.path.join(data_path,local_fname) \n            full_fname = os.path.join(data_path,fname) \n            try:\n                print('Downloading file for '+date.strftime('%D'))\n                sys.stdout.flush()\n                sftp.get(myDir+local_fname, saved_fname)\n                os.system('bunzip2 -c '+saved_fname+' > '+ full_fname)\n                os.system('rm ' + saved_fname)\n            except IOError:\n                print('File not available for '+date.strftime('%D'))\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef same_disks(self, count=2):\n        ret = self\n        if len(self) > 0:\n            type_counter = Counter(self.drive_type)\n            drive_type, counts = type_counter.most_common()[0]\n            self.set_drive_type(drive_type)\n\n        if len(self) > 0:\n            size_counter = Counter(self.capacity)\n            size, counts = size_counter.most_common()[0]\n            self.set_capacity(size)\n\n        if len(self) >= count:\n            indices = self.index[:count]\n            self.set_indices(indices)\n        else:\n            self.set_indices('N/A')\n        return ret", "response": "filter self to the required number of disks with same size and type and same size and type and same size and type"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_bounds(self, start, stop):\n        for instrument in self.instruments:\n            instrument.bounds = (start, stop)", "response": "Sets the boundaries for all instruments in constellation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data_mod(self, *args, **kwargs):\n\n        for instrument in self.instruments:\n            instrument.custom.add(*args, **kwargs)", "response": "Register a function to modify the data of a specific member Instrument."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(self, *args, **kwargs):\n\n        for instrument in self.instruments:\n            instrument.load(*args, **kwargs)", "response": "Load data into instrument object. data\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, bounds1, label1, bounds2, label2, bin3, label3,\n            data_label):\n        \"\"\"\n        Combines signals from multiple instruments within\n        given bounds.\n\n        Parameters\n        ----------\n        bounds1 : (min, max)\n            Bounds for selecting data on the axis of label1\n            Data points with label1 in [min, max) will be considered.\n        label1 : string\n            Data label for bounds1 to act on.\n        bounds2 : (min, max)\n            Bounds for selecting data on the axis of label2\n            Data points with label1 in [min, max) will be considered.\n        label2 : string\n            Data label for bounds2 to act on.\n        bin3 : (min, max, #bins)\n            Min and max bounds and number of bins for third axis.\n        label3 : string\n            Data label for third axis.\n        data_label : array of strings\n            Data label(s) for data product(s) to be averaged.\n\n        Returns\n        -------\n        median : dictionary\n            Dictionary indexed by data label, each value of which is a \n            dictionary with keys 'median', 'count', 'avg_abs_dev', and \n            'bin' (the values of the bin edges.) \n        \"\"\"\n\n        # TODO Update for 2.7 compatability.\n        if isinstance(data_label, str):\n            data_label = [data_label, ]\n        elif not isinstance(data_label, collections.Sequence):\n            raise ValueError(\"Please pass data_label as a string or \"\n                             \"collection of strings.\")\n\n        # Modeled after pysat.ssnl.median2D\n\n        # Make bin boundaries.\n        # y: values at label3\n        # z: *data_labels\n        biny = np.linspace(bin3[0], bin3[1], bin3[2]+1)\n\n        numy = len(biny)-1\n        numz = len(data_label)\n\n        # Ranges\n        yarr, zarr = map(np.arange, (numy, numz))\n\n        # Store data here.\n        ans = [[[collections.deque()] for j in yarr] for k in zarr]\n\n        # Filter data by bounds and bin it.\n        # Idiom for loading all of the data in an instrument's bounds.\n        for inst in self:\n            for inst in inst:\n                if len(inst.data) != 0:\n                    # Select indicies for each piece of data we're interest in.\n                    # Not all of this data is in bounds on label3 but we'll\n                    #  sort this later.\n                    min1, max1 = bounds1\n                    min2, max2 = bounds2\n                    data1 = inst.data[label1]\n                    data2 = inst.data[label2]\n                    in_bounds, = np.where((min1 <= data1) & (data1 < max1) &\n                                          (min2 <= data2) & (data2 < max2))\n                    # Grab the data in bounds on data1, data2.\n                    data_considered = inst.data.iloc[in_bounds]\n\n                    y_indexes = np.digitize(data_considered[label3], biny) - 1\n\n                    # Iterate over the bins along y\n                    for yj in yarr:\n                        # Indicies of data in this bin\n                        yindex, = np.where(y_indexes == yj)\n\n                        # If there's data in this bin\n                        if len(yindex) > 0:\n\n                            # For each data label, add the points.\n                            for zk in zarr:\n                                ans[zk][yj][0].extend(\n                                    data_considered.ix[yindex, data_label[zk]].tolist())\n\n        # Now for the averaging.\n        # Let's, try .. packing the answers for the 2d function.\n        numx = 1\n        xarr = np.arange(numx)\n        binx = None\n\n        # TODO modify output\n        out_2d = _calc_2d_median(ans, data_label, binx, biny, xarr, yarr, zarr, numx, numy, numz)\n\n        # Transform output\n        output = {}\n        for i, label in enumerate(data_label):\n            median = [r[0] for r in out_2d[label]['median']]\n            count  = [r[0] for r in out_2d[label]['count']]\n            dev    = [r[0] for r in out_2d[label]['avg_abs_dev']]\n            output[label] = {'median':  median,\n                             'count':   count,\n                             'avg_abs_dev': dev,\n                             'bin':     out_2d[label]['bin_y']}\n        return output", "response": "Adds a set of signals from multiple instruments within a given bounds."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the difference in signals from two instruments within the given bounds.", "response": "def difference(self, instrument1, instrument2, bounds, data_labels,\n                   cost_function):\n        \"\"\"\n        Calculates the difference in signals from multiple\n        instruments within the given bounds.\n\n        Parameters\n        ----------\n        instrument1 : Instrument\n            Information must already be loaded into the\n            instrument.\n\n        instrument2 : Instrument\n            Information must already be loaded into the\n            instrument.\n\n        bounds : list of tuples in the form (inst1_label, inst2_label,\n            min, max, max_difference)\n            inst1_label are inst2_label are labels for the data in\n            instrument1 and instrument2\n            min and max are bounds on the data considered\n            max_difference is the maximum difference between two points\n            for the difference to be calculated\n\n        data_labels : list of tuples of data labels\n            The first key is used to access data in s1\n            and the second data in s2.\n\n        cost_function : function\n            function that operates on two rows of the instrument data.\n            used to determine the distance between two points for finding\n            closest points\n\n        Returns\n        -------\n        data_df: pandas DataFrame\n            Each row has a point from instrument1, with the keys\n            preceded by '1_', and a point within bounds on that point\n            from instrument2 with the keys preceded by '2_', and the \n            difference between the instruments' data for all the labels\n            in data_labels\n\n        Created as part of a Spring 2018 UTDesign project.\n        \"\"\"\n        \n        \"\"\"\n        Draft Pseudocode\n        ----------------\n        Check integrity of inputs.\n\n        Let STD_LABELS be the constant tuple:\n        (\"time\", \"lat\", \"long\", \"alt\")\n\n        Note: modify so that user can override labels for time,\n        lat, long, data for each satelite.\n\n        // We only care about the data currently loaded\n           into each object.\n\n        Let start be the later of the datetime of the\n         first piece of data loaded into s1, the first\n         piece of data loaded into s2, and the user\n         supplied start bound.\n\n        Let end be the later of the datetime of the first\n         piece of data loaded into s1, the first piece\n         of data loaded into s2, and the user supplied\n         end bound.\n\n        If start is after end, raise an error.\n\n        // Let data be the 2D array of deques holding each piece\n        //  of data, sorted into bins by lat/long/alt.\n\n        Let s1_data (resp s2_data) be data from s1.data, s2.data\n        filtered by user-provided lat/long/alt bounds, time bounds\n        calculated.\n\n        Let data be a dictionary of lists with the keys\n        [ dl1 for dl1, dl2 in data_labels ] +\n        STD_LABELS +\n        [ lb+\"2\" for lb in STD_LABELS ]\n\n        For each piece of data s1_point in s1_data:\n\n            # Hopefully np.where is very good, because this\n            #  runs O(n) times.\n            # We could try reusing selections, maybe, if needed.\n            #  This would probably involve binning.\n            Let s2_near be the data from s2.data within certain\n             bounds on lat/long/alt/time using 8 statements to\n             numpy.where. We can probably get those defaults from\n             the user or handy constants / config?\n\n            # We could try a different algorithm for closest pairs\n            # of points.\n\n            Let distance be the numpy array representing the\n             distance between s1_point and each point in s2_near.\n\n            # S: Difference for others: change this line.\n            For each of those, calculate the spatial difference\n             from the s1 using lat/long/alt. If s2_near is\n             empty; break loop.\n\n            Let s2_nearest be the point in s2_near corresponding\n             to the lowest distance.\n\n            Append to data: a point, indexed by the time from\n             s1_point, containing the following data:\n\n            # note\n            Let n be the length of data[\"time\"].\n            For each key in data:\n                Assert len(data[key]) == n\n            End for.\n\n            # Create data row to pass to pandas.\n            Let row be an empty dict.\n            For dl1, dl2 in data_labels:\n                Append s1_point[dl1] - s2_nearest[dl2] to data[dl1].\n\n            For key in STD_LABELS:\n                Append s1_point[translate[key]] to data[key]\n                key = key+\"2\"\n                Append s2_nearest[translate[key]] to data[key]\n\n        Let data_df be a pandas dataframe created from the data\n        in data.\n\n        return { 'data': data_df, 'start':start, 'end':end }\n        \"\"\"\n\n        labels = [dl1 for dl1, dl2 in data_labels] + ['1_'+b[0] for b in bounds] + ['2_'+b[1] for b in bounds] + ['dist']\n        data = {label: [] for label in labels}\n\n        # Apply bounds\n        inst1 = instrument1.data\n        inst2 = instrument2.data\n        for b in bounds:\n            label1 = b[0]\n            label2 = b[1]\n            low = b[2]\n            high = b[3]\n\n            data1 = inst1[label1]\n            ind1 = np.where((data1 >= low) & (data1 < high))\n            inst1 = inst1.iloc[ind1]\n\n            data2 = inst2[label2]\n            ind2 = np.where((data2 >= low) & (data2 < high))\n            inst2 = inst2.iloc[ind2]\n\n        for i, s1_point in inst1.iterrows():\n            # Gets points in instrument2 within the given bounds\n            s2_near = instrument2.data\n            for b in bounds:\n                label1 = b[0]\n                label2 = b[1]\n                s1_val = s1_point[label1]\n                max_dist = b[4]\n                minbound = s1_val - max_dist\n                maxbound = s1_val + max_dist\n\n                data2 = s2_near[label2]\n                indices = np.where((data2 >= minbound) & (data2 < maxbound))\n                s2_near = s2_near.iloc[indices]\n\n            # Finds nearest point to s1_point in s2_near\n            s2_nearest = None\n            min_dist = float('NaN')\n            for j, s2_point in s2_near.iterrows():\n                dist = cost_function(s1_point, s2_point)\n                if dist < min_dist or min_dist != min_dist:\n                    min_dist = dist\n                    s2_nearest = s2_point\n\n            data['dist'].append(min_dist)\n\n            # Append difference to data dict\n            for dl1, dl2 in data_labels:\n                if s2_nearest is not None:\n                    data[dl1].append(s1_point[dl1] - s2_nearest[dl2])\n                else:\n                    data[dl1].append(float('NaN'))\n\n            # Append the rest of the row\n            for b in bounds:\n                label1 = b[0]\n                label2 = b[1]\n                data['1_'+label1].append(s1_point[label1])\n                if s2_nearest is not None:\n                    data['2_'+label2].append(s2_nearest[label2])\n                else:\n                    data['2_'+label2].append(float('NaN'))\n\n        data_df = pds.DataFrame(data=data)\n        return data_df"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a 3D occurrence tree for a given data label.", "response": "def daily3D(inst, bin1, label1, bin2, label2, bin3, label3, \n            data_label, gate, returnBins=False):\n    \"\"\"3D Daily Occurrence Probability of data_label > gate over a season.\n    \n    If data_label is greater than gate atleast once per day, \n    then a 100% occurrence probability results. Season delineated by \n    the bounds attached to Instrument object.\n    Prob = (# of times with at least one hit)/(# of times in bin)\n\n    Parameters\n    ----------\n    inst: pysat.Instrument()\n        Instrument to use for calculating occurrence probability\n    binx: list\n        [min, max, number of bins]\n    labelx: string \n        name for data product for binx\n    data_label: list of strings \n        identifies data product(s) to calculate occurrence probability\n    gate: list of values \n        values that data_label must achieve to be counted as an occurrence\n    returnBins: Boolean\n        if True, return arrays with values of bin edges, useful for pcolor\n\n    Returns\n    -------\n    occur_prob : dictionary\n        A dict of dicts indexed by data_label. Each entry is dict with entries\n        'prob' for the probability and 'count' for the number of days with any\n        data; 'bin_x', 'bin_y', and 'bin_z' are also returned if requested. Note\n        that arrays are organized for direct plotting, z,y,x.\n\n    Note\n    ----\n    Season delineated by the bounds attached to Instrument object.    \n            \n    \"\"\"\n        \n    return _occurrence3D(inst, bin1, label1, bin2, label2, bin3, label3, \n                        data_label, gate, returnBins=returnBins, by_orbit=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef computational_form(data):\n\n    if isinstance(data.iloc[0], DataFrame):\n        dslice = Panel.from_dict(dict([(i,data.iloc[i])\n                                       for i in xrange(len(data))]))\n    elif isinstance(data.iloc[0], Series):\n        dslice = DataFrame(data.tolist())\n        dslice.index = data.index\n    else:\n        dslice = data\n    return dslice", "response": "This function creates a new object of the correct type for the next page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the top level directory pysat uses to look for data and reload.", "response": "def set_data_dir(path=None, store=None):\n    \"\"\"\n    Set the top level directory pysat uses to look for data and reload.\n\n    Parameters\n    ----------\n    path : string\n        valid path to directory pysat uses to look for data\n    store : bool\n        if True, store data directory for future runs\n    \"\"\"\n    import sys\n    import os\n    import pysat\n    if sys.version_info[0] >= 3:\n        if sys.version_info[1] < 4:\n            import imp\n            re_load = imp.reload\n        else:\n            import importlib\n            re_load = importlib.reload\n    else:\n        re_load = reload\n    if store is None:\n        store = True    \n    if os.path.isdir(path):\n        if store:\n            with open(os.path.join(os.path.expanduser('~'), '.pysat',\n                                   'data_path.txt'), 'w') as f:\n                f.write(path)\n        pysat.data_dir = path\n        pysat._files = re_load(pysat._files)\n        pysat._instrument = re_load(pysat._instrument)\n    else:\n        raise ValueError('Path %s does not lead to a valid directory.' % path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_netcdf4(fnames=None, strict_meta=False, file_format=None, epoch_name='Epoch',\n                 units_label='units', name_label='long_name', \n                 notes_label='notes', desc_label='desc',\n                 plot_label='label', axis_label='axis', \n                 scale_label='scale',\n                 min_label='value_min', max_label='value_max',\n                 fill_label='fill'):\n                    # unix_time=False, **kwargs):\n    \"\"\"Load netCDF-3/4 file produced by pysat.\n\n    Parameters\n    ----------\n    fnames : string or array_like of strings\n        filenames to load\n    strict_meta : boolean\n        check if metadata across fnames is the same\n    file_format : string\n        file_format keyword passed to netCDF4 routine\n        NETCDF3_CLASSIC, NETCDF3_64BIT, NETCDF4_CLASSIC, and NETCDF4\n\n    Returns\n    --------\n    out : pandas.core.frame.DataFrame\n        DataFrame output\n    mdata : pysat._meta.Meta\n        Meta data\n    \"\"\"\n    import netCDF4\n    import string\n    import pysat\n\n    if fnames is None:\n        raise ValueError(\"Must supply a filename/list of filenames\")\n    if isinstance(fnames, basestring): \n        fnames = [fnames]\n\n    if file_format is None:\n        file_format = 'NETCDF4'\n    else:\n        file_format = file_format.upper()\n\n    saved_mdata = None\n    running_idx = 0\n    running_store=[]\n    two_d_keys = []; two_d_dims = []; three_d_keys = []; three_d_dims = [];\n    for fname in fnames:\n        with netCDF4.Dataset(fname, mode='r', format=file_format) as data:\n            # build up dictionary with all global ncattrs\n            # and add those attributes to a pysat meta object\n            ncattrsList = data.ncattrs()\n            mdata = pysat.Meta(units_label=units_label, name_label=name_label,\n                               notes_label=notes_label, desc_label=desc_label,\n                               plot_label=plot_label, axis_label=axis_label,\n                               scale_label=scale_label,\n                               min_label=min_label, max_label=max_label,\n                               fill_label=fill_label)\n            for d in ncattrsList:\n                if hasattr(mdata, d):\n                    mdata.__setattr__(d+'_', data.getncattr(d))\n                else:\n                    mdata.__setattr__(d, data.getncattr(d))\n\n            # loadup all of the variables in the netCDF\n            loadedVars = {}\n            for key in data.variables.keys():\n                # load up metadata.  From here group unique \n                # dimensions and act accordingly, 1D, 2D, 3D  \n                if len(data.variables[key].dimensions) == 1:\n                    # load 1D data variable\n                    # assuming basic time dimension\n                    loadedVars[key] = data.variables[key][:] \n                    # if key != epoch_name:\n                    # load up metadata\n                    meta_dict = {}\n                    for nc_key in data.variables[key].ncattrs():\n                        meta_dict[nc_key] = data.variables[key].getncattr(nc_key)\n                    mdata[key] = meta_dict\n                if len(data.variables[key].dimensions) == 2:\n                    # part of dataframe within dataframe\n                    two_d_keys.append(key)\n                    two_d_dims.append(data.variables[key].dimensions)\n\n                if len(data.variables[key].dimensions) == 3:\n                    # part of full/dedicated dataframe within dataframe\n                    three_d_keys.append(key)\n                    three_d_dims.append(data.variables[key].dimensions)\n\n            # we now have a list of keys that need to go into a dataframe,\n            # could be more than one, collect unique dimensions for 2D keys\n            for dim in set(two_d_dims):\n                # first dimension should be epoch\n                # second dimension name used as variable name\n                obj_key_name = dim[1]\n                # collect variable names associated with dimension\n                idx_bool = [dim == i for i in two_d_dims]\n                idx, = np.where(np.array(idx_bool))\n                obj_var_keys = []\n                clean_var_keys = []\n                for i in idx:\n                    obj_var_keys.append(two_d_keys[i])\n                    clean_var_keys.append(two_d_keys[i].split(obj_key_name+'_')[-1])\n\n                # figure out how to index this data, it could provide its own\n                # index - or we may have to create simple integer based DataFrame access\n                # if the dimension is stored as its own variable then use that info for index\n                if obj_key_name in obj_var_keys:\n                    # string used to indentify dimension also in data.variables \n                    # will be used as an index \n                    index_key_name = obj_key_name \n                    # if the object index uses UNIX time, process into datetime index  \n                    if data.variables[obj_key_name].getncattr(name_label) == epoch_name:\n                        # name to be used in DataFrame index\n                        index_name = epoch_name\n                        time_index_flag = True\n                    else:\n                        time_index_flag = False\n                        # label to be used in DataFrame index\n                        index_name = data.variables[obj_key_name].getncattr(name_label)\n                else:\n                    # dimension is not itself a variable\n                    index_key_name  = None                \n\n                # iterate over the variables and grab metadata\n                dim_meta_data = pysat.Meta(units_label=units_label, name_label=name_label,\n                                           notes_label=notes_label, desc_label=desc_label,\n                                           plot_label=plot_label, axis_label=axis_label,\n                                           scale_label=scale_label,\n                                           min_label=min_label, max_label=max_label,\n                                           fill_label=fill_label)\n                for key, clean_key in zip(obj_var_keys, clean_var_keys):\n                    # store attributes in metadata, exept for dim name\n                    meta_dict = {}\n                    for nc_key in data.variables[key].ncattrs():\n                        meta_dict[nc_key] = data.variables[key].getncattr(nc_key)\n                    dim_meta_data[clean_key] = meta_dict\n\n                # print (dim_meta_data)\n                dim_meta_dict = {'meta':dim_meta_data}\n                if index_key_name is not None:\n                    # add top level meta\n                    for nc_key in data.variables[obj_key_name].ncattrs():\n                        dim_meta_dict[nc_key] = data.variables[obj_key_name].getncattr(nc_key)\n                    mdata[obj_key_name] = dim_meta_dict\n                \n                # iterate over all variables with this dimension and store data\n                # data storage, whole shebang\n                loop_dict = {}\n                # list holds a series of slices, parsed from dict above\n                loop_list = []\n                for key, clean_key in zip(obj_var_keys, clean_var_keys):\n                    # data\n                    loop_dict[clean_key] = data.variables[key][:,:].flatten(order='C')                \n                # number of values in time\n                loop_lim = data.variables[obj_var_keys[0]].shape[0]\n                # number of values per time\n                step_size = len(data.variables[obj_var_keys[0]][0,:])\n                # check if there is an index we should use\n                if not (index_key_name is None):\n                    # an index was found\n                    time_var = loop_dict.pop(index_key_name)\n                    if time_index_flag:\n                        # create datetime index from data\n                        if file_format == 'NETCDF4':\n                            time_var = pds.to_datetime(1E6*time_var)\n                        else:\n                            time_var = pds.to_datetime(1E6*time_var)\n                    new_index = time_var\n                    new_index_name = index_name\n                else:\n                    # using integer indexing\n                    new_index = np.arange(loop_lim*step_size, dtype=int) % step_size\n                    new_index_name = 'index'\n                # load all data into frame\n                if len(loop_dict.keys()) > 1:\n                    loop_frame = pds.DataFrame(loop_dict, columns=clean_var_keys)\n                    if obj_key_name in loop_frame:\n                        del loop_frame[obj_key_name]\n                    # break massive frame into bunch of smaller frames\n                    for i in np.arange(loop_lim, dtype=int):\n                        loop_list.append(loop_frame.iloc[step_size*i:step_size*(i+1),:])\n                        loop_list[-1].index = new_index[step_size*i:step_size*(i+1)]\n                        loop_list[-1].index.name = new_index_name             \n                else:\n                    loop_frame = pds.Series(loop_dict[clean_var_keys[0]], name=obj_var_keys[0])\n                    # break massive series into bunch of smaller series\n                    for i in np.arange(loop_lim, dtype=int):\n                        loop_list.append(loop_frame.iloc[step_size*i:step_size*(i+1)])\n                        loop_list[-1].index = new_index[step_size*i:step_size*(i+1)]\n                        loop_list[-1].index.name = new_index_name\n                # print (loop_frame.columns)\n                        \n                # add 2D object data, all based on a unique dimension within\n                # netCDF, to loaded data dictionary\n                loadedVars[obj_key_name] = loop_list\n                del loop_list\n\n            # we now have a list of keys that need to go into a dataframe,\n            # could be more than one, collect unique dimensions for 2D keys\n            for dim in set(three_d_dims):\n                # collect variable names associated with dimension\n                idx_bool = [dim == i for i in three_d_dims]\n                idx, = np.where(np.array(idx_bool))\n                obj_var_keys = []\n                for i in idx:\n                    obj_var_keys.append(three_d_keys[i])\n                    \n                for obj_key_name in obj_var_keys:\n                    # store attributes in metadata\n                    meta_dict = {}\n                    for nc_key in data.variables[obj_key_name].ncattrs():\n                        meta_dict[nc_key] = data.variables[obj_key_name].getncattr(nc_key)\n                    mdata[obj_key_name] = meta_dict\n                    \n                    # iterate over all variables with this dimension and store data\n                    # data storage, whole shebang\n                    loop_dict = {}\n                    # list holds a series of slices, parsed from dict above\n                    loop_list = []\n                    loop_dict[obj_key_name] = data.variables[obj_key_name][:,:,:]                \n                    # number of values in time\n                    loop_lim = data.variables[obj_key_name].shape[0]\n                    # number of values per time\n                    step_size_x = len(data.variables[obj_key_name][0, :, 0])\n                    step_size_y = len(data.variables[obj_key_name][0, 0, :])\n                    step_size = step_size_x\n                    loop_dict[obj_key_name] = loop_dict[obj_key_name].reshape((loop_lim*step_size_x, step_size_y))\n                    # check if there is an index we should use\n                    if not (index_key_name is None):\n                        # an index was found\n                        time_var = loop_dict.pop(index_key_name)\n                        if time_index_flag:\n                            # create datetime index from data\n                            if file_format == 'NETCDF4':\n                                time_var = pds.to_datetime(1E6*time_var)\n                            else:\n                                time_var = pds.to_datetime(1E6*time_var)\n                        new_index = time_var\n                        new_index_name = index_name\n                    else:\n                        # using integer indexing\n                        new_index = np.arange(loop_lim*step_size, dtype=int) % step_size\n                        new_index_name = 'index'\n                    # load all data into frame\n                    loop_frame = pds.DataFrame(loop_dict[obj_key_name])\n                    # del loop_frame['dimension_1']\n                    # break massive frame into bunch of smaller frames\n                    for i in np.arange(loop_lim, dtype=int):\n                        loop_list.append(loop_frame.iloc[step_size*i:step_size*(i+1),:])\n                        loop_list[-1].index = new_index[step_size*i:step_size*(i+1)]\n                        loop_list[-1].index.name = new_index_name                                 \n                            \n                    # add 2D object data, all based on a unique dimension within netCDF,\n                    # to loaded data dictionary\n                    loadedVars[obj_key_name] = loop_list\n                    del loop_list\n                                                                \n            # prepare dataframe index for this netcdf file\n            time_var = loadedVars.pop(epoch_name)\n\n            # convert from GPS seconds to seconds used in pandas (unix time,\n            # no leap)\n            #time_var = convert_gps_to_unix_seconds(time_var)\n            if file_format == 'NETCDF4':\n                loadedVars[epoch_name] = pds.to_datetime((1E6 *\n                                                          time_var).astype(int))\n            else:\n                loadedVars[epoch_name] = pds.to_datetime((time_var *\n                                                          1E6).astype(int))\n            #loadedVars[epoch_name] = pds.to_datetime((time_var*1E6).astype(int))\n            running_store.append(loadedVars)\n            running_idx += len(loadedVars[epoch_name])\n\n            if strict_meta:\n                if saved_mdata is None:\n                    saved_mdata = copy.deepcopy(mdata)\n                elif (mdata != saved_mdata):\n                    raise ValueError('Metadata across filenames is not the ' +\n                                     'same.')\n\n    # combine all of the data loaded across files together\n    out = []\n    for item in running_store:\n        out.append(pds.DataFrame.from_records(item, index=epoch_name))\n    out = pds.concat(out, axis=0)\n    return out, mdata", "response": "Load a single entry in the n - tuple format of a netCDF - 4 file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of year day of year for a supplied datetime object.", "response": "def getyrdoy(date):\n    \"\"\"Return a tuple of year, day of year for a supplied datetime object.\"\"\"\n\n    try:\n        doy = date.toordinal()-datetime(date.year,1,1).toordinal()+1\n    except AttributeError:\n        raise AttributeError(\"Must supply a pandas datetime object or \" +\n                             \"equivalent\")\n    else:\n        return date.year, doy"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning array of datetime objects using input frequency from start to stop", "response": "def season_date_range(start, stop, freq='D'):\n    \"\"\"\n    Return array of datetime objects using input frequency from start to stop\n\n    Supports single datetime object or list, tuple, ndarray of start and \n    stop dates.\n\n    freq codes correspond to pandas date_range codes, D daily, M monthly,\n    S secondly\n    \"\"\"\n\n    if hasattr(start, '__iter__'):  \n        # missing check for datetime\n        season = pds.date_range(start[0], stop[0], freq=freq)\n        for (sta,stp) in zip(start[1:], stop[1:]):\n            season = season.append(pds.date_range(sta, stp, freq=freq))\n    else:\n        season = pds.date_range(start, stop, freq=freq)\n    return season"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_datetime_index(year=None, month=None, day=None, uts=None):\n    # need a timeseries index for storing satellite data in pandas but\n    # creating a datetime object for everything is too slow\n    # so I calculate the number of nanoseconds elapsed since first sample, \n    # and create timeseries index from that. \n    # Factor of 20 improvement compared to previous method,\n    # which itself was an order of magnitude faster than datetime.\n \n    #get list of unique year, and month\n    if not hasattr(year, '__iter__'):\n        raise ValueError('Must provide an iterable for all inputs.')\n    if len(year) == 0:\n        raise ValueError('Length of array must be larger than 0.')\n    year = year.astype(int)\n    if month is None:\n        month = np.ones(len(year), dtype=int)\n    else:\n        month = month.astype(int)\n\n    if uts is None:\n        uts = np.zeros(len(year))\n    if day is None:\n        day = np.ones(len(year))\n    day = day.astype(int)\n    # track changes in seconds\n    uts_del = uts.copy().astype(float)\n    # determine where there are changes in year and month that need to be \n    # accounted for    \n    _,idx = np.unique(year*100.+month, return_index=True)\n    # create another index array for faster algorithm below\n    idx2 = np.hstack((idx,len(year)+1))   \n    # computes UTC seconds offset for each unique set of year and month\n    for _idx,_idx2 in zip(idx[1:],idx2[2:]):\n        temp = (datetime(year[_idx],month[_idx],1)\n                - datetime(year[0],month[0],1))\n        uts_del[_idx:_idx2] += temp.total_seconds()\n\n    # add in UTC seconds for days, ignores existence of leap seconds\n    uts_del += (day-1)*86400\n    # add in seconds since unix epoch to first day\n    uts_del += (datetime(year[0],month[0],1)-datetime(1970,1,1)).total_seconds()\n    # going to use routine that defaults to nanseconds for epoch\n    uts_del *= 1E9\n    return pds.to_datetime(uts_del)", "response": "Create a Pandas timeseries index using supplied year month day and ut in\n    seconds."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nan_circmean(samples, high=2.0*np.pi, low=0.0, axis=None):\n\n    samples = np.asarray(samples)\n    samples = samples[~np.isnan(samples)]\n    if samples.size == 0:\n        return np.nan\n\n    # Ensure the samples are in radians\n    ang = (samples - low) * 2.0 * np.pi / (high - low)\n\n    # Calculate the means of the sine and cosine, as well as the length\n    # of their unit vector\n    ssum = np.sin(ang).sum(axis=axis)\n    csum = np.cos(ang).sum(axis=axis)\n    res = np.arctan2(ssum, csum)\n\n    # Bring the range of the result between 0 and 2 pi\n    mask = res < 0.0\n\n    if mask.ndim > 0:\n        res[mask] += 2.0 * np.pi\n    elif mask:\n        res += 2.0 * np.pi\n\n    # Calculate the circular standard deviation\n    circmean = res * (high - low) / (2.0 * np.pi) + low\n    return circmean", "response": "NaN insensitive version of scipy s circular mean routine"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nan_circstd(samples, high=2.0*np.pi, low=0.0, axis=None):\n\n    samples = np.asarray(samples)\n    samples = samples[~np.isnan(samples)]\n    if samples.size == 0:\n        return np.nan\n\n    # Ensure the samples are in radians\n    ang = (samples - low) * 2.0 * np.pi / (high - low)\n\n    # Calculate the means of the sine and cosine, as well as the length\n    # of their unit vector\n    smean = np.sin(ang).mean(axis=axis)\n    cmean = np.cos(ang).mean(axis=axis)\n    rmean = np.sqrt(smean**2 + cmean**2)\n\n    # Calculate the circular standard deviation\n    circstd = (high - low) * np.sqrt(-2.0 * np.log(rmean)) / (2.0 * np.pi)\n    return circstd", "response": "NaN insensitive version of scipy s circular standard deviation routine\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef default(inst):\n    import pysat.instruments.icon_ivm as icivm\n    inst.tag = 'level_2'\n    icivm.remove_icon_names(inst, target='ICON_L2_EUV_Daytime_OP_')", "response": "Default routine to be applied when loading data. Removes redundant naming\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of ICON EUV files.", "response": "def list_files(tag=None, sat_id=None, data_path=None, format_str=None):\n    \"\"\"Produce a list of ICON EUV files.\n\n    Notes\n    -----\n    Currently fixed to level-2\n\n    \"\"\"\n\n    desc = None\n    level = tag\n    if level == 'level_1':\n        code = 'L1'\n        desc = None\n    elif level == 'level_2':\n        code = 'L2'\n        desc = None\n    else:\n        raise ValueError('Unsupported level supplied: ' + level)\n\n    if format_str is None:\n        format_str = 'ICON_'+code+'_EUV_Daytime'\n        if desc is not None:\n            format_str += '_' + desc +'_'\n        format_str += '_{year:4d}-{month:02d}-{day:02d}_v{version:02d}r{revision:03d}.NC'\n\n    return pysat.Files.from_os(data_path=data_path,\n                                format_str=format_str)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a copy of the resource with same raw data", "response": "def shadow_copy(self):\n        \"\"\" Return a copy of the resource with same raw data\n\n        :return: copy of the resource\n        \"\"\"\n        ret = self.__class__()\n        if not self._is_updated():\n            # before copy, make sure source is updated.\n            self.update()\n        ret._parsed_resource = self._parsed_resource\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(fnames, tag=None, sat_id=None, **kwargs):\n    \n    return pysat.utils.load_netcdf4(fnames, **kwargs)", "response": "Loads data using pysat. utils. load_netcdf4."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nproduces a list of files corresponding to format_str located at data_path. This routine is invoked by pysat and is not intended for direct use by the end user. Multiple data levels may be supported via the 'tag' and 'sat_id' input strings. Parameters ---------- tag : string ('') tag name used to identify particular data set to be loaded. This input is nominally provided by pysat itself. sat_id : string ('') Satellite ID used to identify particular data set to be loaded. This input is nominally provided by pysat itself. data_path : string Full path to directory containing files to be loaded. This is provided by pysat. The user may specify their own data path at Instrument instantiation and it will appear here. format_str : string (None) String template used to parse the datasets filenames. If a user supplies a template string at Instrument instantiation then it will appear here, otherwise defaults to None. Returns ------- pandas.Series Series of filename strings, including the path, indexed by datetime. Examples -------- :: If a filename is SPORT_L2_IVM_2019-01-01_v01r0000.NC then the template is 'SPORT_L2_IVM_{year:04d}-{month:02d}-{day:02d}_v{version:02d}r{revision:04d}.NC' Note ---- The returned Series should not have any duplicate datetimes. If there are multiple versions of a file the most recent version should be kept and the rest discarded. This routine uses the pysat.Files.from_os constructor, thus the returned files are up to pysat specifications. Normally the format_str for each supported tag and sat_id is defined within this routine. However, as this is a generic routine, those definitions can't be made here. This method could be used in an instrument specific module where the list_files routine in the new package defines the format_str based upon inputs, then calls this routine passing both data_path and format_str. Alternately, the list_files routine in nasa_cdaweb_methods may also be used and has more built in functionality. Supported tages and format strings may be defined within the new instrument module and passed as arguments to nasa_cdaweb_methods.list_files . For an example on using this routine, see pysat/instrument/cnofs_ivm.py or cnofs_vefi, cnofs_plp, omni_hro, timed_see, etc.", "response": "def list_files(tag=None, sat_id=None, data_path=None, format_str=None):\n    \"\"\"Produce a list of files corresponding to format_str located at data_path.\n\n    This routine is invoked by pysat and is not intended for direct use by the end user.\n    \n    Multiple data levels may be supported via the 'tag' and 'sat_id' input strings.\n\n    Parameters\n    ----------\n    tag : string ('')\n        tag name used to identify particular data set to be loaded.\n        This input is nominally provided by pysat itself.\n    sat_id : string ('')\n        Satellite ID used to identify particular data set to be loaded.\n        This input is nominally provided by pysat itself.\n    data_path : string\n        Full path to directory containing files to be loaded. This\n        is provided by pysat. The user may specify their own data path\n        at Instrument instantiation and it will appear here.\n    format_str : string (None)\n        String template used to parse the datasets filenames. If a user\n        supplies a template string at Instrument instantiation\n        then it will appear here, otherwise defaults to None.\n    \n    Returns\n    -------\n    pandas.Series\n        Series of filename strings, including the path, indexed by datetime.\n    \n    Examples\n    --------\n    ::\n    \n        If a filename is SPORT_L2_IVM_2019-01-01_v01r0000.NC then the template\n        is 'SPORT_L2_IVM_{year:04d}-{month:02d}-{day:02d}_v{version:02d}r{revision:04d}.NC'\n    \n    Note\n    ----\n    The returned Series should not have any duplicate datetimes. If there are\n    multiple versions of a file the most recent version should be kept and the rest\n    discarded. This routine uses the pysat.Files.from_os constructor, thus\n    the returned files are up to pysat specifications.\n    \n    Normally the format_str for each supported tag and sat_id is defined within this routine.\n    However, as this is a generic routine, those definitions can't be made here. This method\n    could be used in an instrument specific module where the list_files routine in the\n    new package defines the format_str based upon inputs, then calls this routine passing\n    both data_path and format_str.\n    \n    Alternately, the list_files routine in nasa_cdaweb_methods may also be used and has\n    more built in functionality. Supported tages and format strings may be defined\n    within the new instrument module and passed as arguments to nasa_cdaweb_methods.list_files .\n    For an example on using this routine, see pysat/instrument/cnofs_ivm.py or cnofs_vefi, cnofs_plp,\n    omni_hro, timed_see, etc.\n    \n    \"\"\"\n    \n    return pysat.Files.from_os(data_path=data_path, format_str=format_str)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nindicate it s a command of naviseccli", "response": "def command(f):\n    \"\"\" indicate it's a command of naviseccli\n\n    :param f: function that returns the command in list\n    :return: command execution result\n    \"\"\"\n\n    @functools.wraps(f)\n    def func_wrapper(self, *argv, **kwargs):\n        if 'ip' in kwargs:\n            ip = kwargs['ip']\n            del kwargs['ip']\n        else:\n            ip = None\n\n        commands = _get_commands(f, self, *argv, **kwargs)\n        return self.execute(commands, ip=ip)\n\n    return func_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef duel_command(f):\n\n    @functools.wraps(f)\n    def func_wrapper(self, *argv, **kwargs):\n        commands = _get_commands(f, self, *argv, **kwargs)\n        return self.execute_dual(commands)\n\n    return func_wrapper", "response": "indicate it s a command need to be called on both SP\n    and SPCommandManager"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn new size accounting for the metadata.", "response": "def supplement_filesystem(old_size, user_cap=False):\n    \"\"\"Return new size accounting for the metadata.\"\"\"\n    new_size = old_size\n    if user_cap:\n        if old_size <= _GiB_to_Byte(1.5):\n            new_size = _GiB_to_Byte(3)\n        else:\n            new_size += _GiB_to_Byte(1.5)\n    return int(new_size)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef synchronized(cls, obj=None):\n\n        def get_key(f, o):\n            if o is None:\n                key = hash(f)\n            else:\n                key = hash(o)\n            return key\n\n        def get_lock(f, o):\n            key = get_key(f, o)\n            if key not in cls.lock_map:\n                with cls.lock_map_lock:\n                    if key not in cls.lock_map:\n                        cls.lock_map[key] = _init_lock()\n            return cls.lock_map[key]\n\n        def wrap(f):\n            @functools.wraps(f)\n            def new_func(*args, **kw):\n                with get_lock(f, obj):\n                    return f(*args, **kw)\n\n            return new_func\n\n        return wrap", "response": "synchronize on obj if obj is supplied."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef re_enqueue(self, item):\n        if 'retries' in item:\n            retries = item['retries']\n            if retries >= self.MAX_RETRIES:\n                log.warn(\"Failed to execute {} after {} retries, give it \"\n                         \" up.\".format(item['method'], retries))\n            else:\n                retries += 1\n                item['retries'] = retries\n                self._q.put_nowait(item)\n        else:\n            item['retries'] = 1\n            self._q.put_nowait(item)", "response": "Re - enqueue till reach max retries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _support_op(*args):\n        def inner(func):\n            for one_arg in args:\n                _op_mapping_[one_arg] = func\n            return func\n\n        return inner", "response": "Internal decorator to define an operation that can be used to compare the resource IDs of a resource."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean(inst):\n    \n    if (inst.clean_level == 'dusty') | (inst.clean_level == 'clean'):\n        idx, = np.where(inst['B_flag'] == 0)\n        inst.data = inst[idx, :]\n\n    return None", "response": "Routine to return VEFI data cleaned to the specified level"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves leading text on ICON project variable names on ICON associated pysat. Instrument object inst Target string optional", "response": "def remove_icon_names(inst, target=None):\n    \"\"\"Removes leading text on ICON project variable names\n\n    Parameters\n    ----------\n    inst : pysat.Instrument\n        ICON associated pysat.Instrument object\n    target : str\n        Leading string to remove. If none supplied,\n        ICON project standards are used to identify and remove\n        leading text\n\n    Returns\n    -------\n    None\n        Modifies Instrument object in place\n\n\n    \"\"\"\n  \n    if target is None:\n        lev = inst.tag\n        if lev == 'level_2':\n            lev = 'L2'\n        elif lev == 'level_0':\n            lev = 'L0'\n        elif lev == 'level_0p':\n            lev = 'L0P'\n        elif lev == 'level_1.5':\n            lev = 'L1-5'\n        elif lev == 'level_1':\n            lev = 'L1'\n        else:\n            raise ValueError('Uknown ICON data level')\n        \n        # get instrument code\n        sid = inst.sat_id.lower()\n        if sid == 'a':\n            sid = 'IVM_A'\n        elif sid == 'b':\n            sid = 'IVM_B'\n        else:\n            raise ValueError('Unknown ICON satellite ID')\n        prepend_str = '_'.join(('ICON', lev, sid)) + '_'\n    else:\n        prepend_str = target\n\n    inst.data.rename(columns=lambda x: x.split(prepend_str)[-1], inplace=True)\n    inst.meta.data.rename(index=lambda x: x.split(prepend_str)[-1], inplace=True)\n    orig_keys = inst.meta.keys_nD()  \n    for key in orig_keys:\n        new_key = key.split(prepend_str)[-1]\n        new_meta = inst.meta.pop(key)\n        new_meta.data.rename(index=lambda x: x.split(prepend_str)[-1], inplace=True)\n        inst.meta[new_key] = new_meta\n        \n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a Pandas Series of every file for the chosen satellite.", "response": "def list_files(tag=None, sat_id=None, data_path=None, format_str=None):\n    \"\"\"Return a Pandas Series of every file for chosen satellite data\n\n    Parameters\n    -----------\n    tag : (string or NoneType)\n        Denotes type of file to load.  Accepted types are '1min' and '5min'.\n        (default=None)\n    sat_id : (string or NoneType)\n        Specifies the satellite ID for a constellation.  Not used.\n        (default=None)\n    data_path : (string or NoneType)\n        Path to data directory.  If None is specified, the value previously\n        set in Instrument.files.data_path is used.  (default=None)\n    format_str : (string or NoneType)\n        User specified file format.  If None is specified, the default\n        formats associated with the supplied tags are used. (default=None)\n\n    Returns\n    --------\n    pysat.Files.from_os : (pysat._files.Files)\n        A class containing the verified available files\n    \"\"\"\n    if format_str is None and data_path is not None:\n        if (tag == '1min') | (tag == '5min'):\n            min_fmt = ''.join(['omni_hro_', tag,\n                               '{year:4d}{month:02d}{day:02d}_v01.cdf'])\n            files = pysat.Files.from_os(data_path=data_path, format_str=min_fmt)\n            # files are by month, just add date to monthly filename for\n            # each day of the month. load routine will use date to select out\n            # appropriate data\n            if not files.empty:\n                files.ix[files.index[-1] + pds.DateOffset(months=1) -\n                         pds.DateOffset(days=1)] = files.iloc[-1]\n                files = files.asfreq('D', 'pad')\n                # add the date to the filename\n                files = files + '_' + files.index.strftime('%Y-%m-%d')\n            return files\n        else:\n            raise ValueError('Unknown tag')\n    elif format_str is None:\n        estr = 'A directory must be passed to the loading routine for OMNI HRO'\n        raise ValueError (estr)\n    else:\n        return pysat.Files.from_os(data_path=data_path, format_str=format_str)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef time_shift_to_magnetic_poles(inst):\n    \n    # need to fill in Vx to get an estimate of what is going on\n    inst['Vx'] = inst['Vx'].interpolate('nearest')\n    inst['Vx'] = inst['Vx'].fillna(method='backfill')\n    inst['Vx'] = inst['Vx'].fillna(method='pad')\n\n    inst['BSN_x'] = inst['BSN_x'].interpolate('nearest')\n    inst['BSN_x'] = inst['BSN_x'].fillna(method='backfill')\n    inst['BSN_x'] = inst['BSN_x'].fillna(method='pad')\n\n    # make sure there are no gaps larger than a minute\n    inst.data = inst.data.resample('1T').interpolate('time')\n\n    time_x = inst['BSN_x']*6371.2/-inst['Vx']\n    idx, = np.where(np.isnan(time_x))\n    if len(idx) > 0:\n        print (time_x[idx])\n        print (time_x)\n    time_x_offset = [pds.DateOffset(seconds = time)\n                     for time in time_x.astype(int)]\n    new_index=[]\n    for i, time in enumerate(time_x_offset):\n        new_index.append(inst.data.index[i] + time)\n    inst.data.index = new_index\n    inst.data = inst.data.sort_index()    \n    \n    return", "response": "Time shifted to magnetic poles."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_clock_angle(inst):\n    \n    # Calculate clock angle in degrees\n    clock_angle = np.degrees(np.arctan2(inst['BY_GSM'], inst['BZ_GSM']))\n    clock_angle[clock_angle < 0.0] += 360.0\n    inst['clock_angle'] = pds.Series(clock_angle, index=inst.data.index)\n\n    # Calculate magnitude of IMF in Y-Z plane\n    inst['BYZ_GSM'] = pds.Series(np.sqrt(inst['BY_GSM']**2 +\n                                         inst['BZ_GSM']**2),\n                                       index=inst.data.index)\n\n    return", "response": "Calculates the IMF clock angle and magnitude of IMF in Y - Z plane and returns the object with the values set to the values set to the values set to the values of the IMF clock angle and magnitude of the IMF in Y - Z plane."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the IMF steadiness using the clock angle standard deviation and the maximum value of the B - magnitude in the GSM Y - Z plane.", "response": "def calculate_imf_steadiness(inst, steady_window=15, min_window_frac=0.75,\n                             max_clock_angle_std=90.0/np.pi, max_bmag_cv=0.5):\n    \"\"\" Calculate IMF steadiness using clock angle standard deviation and\n    the coefficient of variation of the IMF magnitude in the GSM Y-Z plane\n\n    Parameters\n    -----------\n    inst : pysat.Instrument\n        Instrument with OMNI HRO data\n    steady_window : int\n        Window for calculating running statistical moments in min (default=15)\n    min_window_frac : float\n        Minimum fraction of points in a window for steadiness to be calculated\n        (default=0.75)\n    max_clock_angle_std : float\n        Maximum standard deviation of the clock angle in degrees (default=22.5)\n    max_bmag_cv : float\n        Maximum coefficient of variation of the IMF magnitude in the GSM\n        Y-Z plane (default=0.5)\n    \"\"\"\n\n    # We are not going to interpolate through missing values\n    sample_rate = int(inst.tag[0])\n    max_wnum = np.floor(steady_window / sample_rate)\n    if max_wnum != steady_window / sample_rate:\n        steady_window = max_wnum * sample_rate\n        print(\"WARNING: sample rate is not a factor of the statistical window\")\n        print(\"new statistical window is {:.1f}\".format(steady_window))\n\n    min_wnum = int(np.ceil(max_wnum * min_window_frac))\n\n    # Calculate the running coefficient of variation of the BYZ magnitude\n    byz_mean = inst['BYZ_GSM'].rolling(min_periods=min_wnum, center=True,\n                                       window=steady_window).mean()\n    byz_std = inst['BYZ_GSM'].rolling(min_periods=min_wnum, center=True,\n                                      window=steady_window).std()\n    inst['BYZ_CV'] = pds.Series(byz_std / byz_mean, index=inst.data.index)\n\n    # Calculate the running circular standard deviation of the clock angle\n    circ_kwargs = {'high':360.0, 'low':0.0}\n    ca = inst['clock_angle'][~np.isnan(inst['clock_angle'])]\n    ca_std = inst['clock_angle'].rolling(min_periods=min_wnum,\n                                         window=steady_window, \\\n                center=True).apply(pysat.utils.nan_circstd, kwargs=circ_kwargs)\n    inst['clock_angle_std'] = pds.Series(ca_std, index=inst.data.index)\n\n    # Determine how long the clock angle and IMF magnitude are steady\n    imf_steady = np.zeros(shape=inst.data.index.shape)\n\n    steady = False\n    for i,cv in enumerate(inst.data['BYZ_CV']):\n        if steady:\n            del_min = int((inst.data.index[i] -\n                           inst.data.index[i-1]).total_seconds() / 60.0)\n            if np.isnan(cv) or np.isnan(ca_std[i]) or del_min > sample_rate:\n                # Reset the steadiness flag if fill values are encountered, or\n                # if an entry is missing\n                steady = False\n\n        if cv <= max_bmag_cv and ca_std[i] <= max_clock_angle_std:\n            # Steadiness conditions have been met\n            if steady:\n                imf_steady[i] = imf_steady[i-1]\n\n            imf_steady[i] += sample_rate\n            steady = True\n\n    inst['IMF_Steady'] = pds.Series(imf_steady, index=inst.data.index)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the dayside reconnection rate for a given instrument.", "response": "def calculate_dayside_reconnection(inst):\n    \"\"\" Calculate the dayside reconnection rate (Milan et al. 2014)\n\n    Parameters\n    -----------\n    inst : pysat.Instrument\n        Instrument with OMNI HRO data, requires BYZ_GSM and clock_angle\n\n    Notes\n    --------\n    recon_day = 3.8 Re (Vx / 4e5 m/s)^1/3 Vx B_yz (sin(theta/2))^9/2\n    \"\"\"\n    rearth = 6371008.8\n    sin_htheta = np.power(np.sin(np.radians(0.5 * inst['clock_angle'])), 4.5)\n    byz = inst['BYZ_GSM'] * 1.0e-9\n    vx = inst['flow_speed'] * 1000.0\n    \n    recon_day = 3.8 * rearth * vx * byz * sin_htheta * np.power((vx / 4.0e5),\n                                                                1.0/3.0)\n    inst['recon_day'] = pds.Series(recon_day, index=inst.data.index)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclearing all access entries of the share", "response": "def clear_access(self, white_list=None):\n        \"\"\" clear all ace entries of the share\n\n        :param white_list: list of username whose access entry won't be cleared\n        :return: sid list of ace entries removed successfully\n        \"\"\"\n        access_entries = self.get_ace_list()\n        sid_list = access_entries.sid_list\n\n        if white_list:\n            sid_white_list = [UnityAclUser.get_sid(self._cli,\n                                                   user,\n                                                   self.cifs_server.domain)\n                              for user in white_list]\n            sid_list = list(set(sid_list) - set(sid_white_list))\n\n        resp = self.delete_ace(sid=sid_list)\n        resp.raise_if_err()\n        return sid_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_ace(self, domain=None, user=None, sid=None):\n        if sid is None:\n            if domain is None:\n                domain = self.cifs_server.domain\n\n            sid = UnityAclUser.get_sid(self._cli, user=user, domain=domain)\n        if isinstance(sid, six.string_types):\n            sid = [sid]\n        ace_list = [self._make_remove_ace_entry(s) for s in sid]\n\n        resp = self.action(\"setACEs\", cifsShareACEs=ace_list)\n        resp.raise_if_err()\n        return resp", "response": "Delete ACE for the share."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef luns(self):\n        lun_list, smp_list = [], []\n        if self.ioclass_luns:\n            lun_list = map(lambda l: VNXLun(lun_id=l.lun_id, name=l.name,\n                                            cli=self._cli), self.ioclass_luns)\n        if self.ioclass_snapshots:\n            smp_list = map(lambda smp: VNXLun(name=smp.name, cli=self._cli),\n                           self.ioclass_snapshots)\n        return list(lun_list) + list(smp_list)", "response": "Aggregator for ioclass_luns and ioclass_snapshots."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef policy(self):\n        policies = VNXIOPolicy.get(cli=self._cli)\n        ret = None\n        for policy in policies:\n            contained = policy.ioclasses.name\n            if self._get_name() in contained:\n                ret = VNXIOPolicy.get(name=policy.name, cli=self._cli)\n                break\n        return ret", "response": "Returns the policy which contains this ioclass."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef modify(self, new_name=None, iotype=None, lun_ids=None, smp_names=None,\n               ctrlmethod=None, minsize=None, maxsize=None):\n        \"\"\"Overwrite the current properties for a VNX ioclass.\n\n        :param new_name: new name for the ioclass\n        :param iotype: can be 'rw', 'r' or 'w'\n        :param lun_ids: list of LUN IDs\n        :param smp_names: list of Snapshot Mount Point names\n        :param ctrlmethod: the new CtrlMethod\n        :param minsize: minimal size in kb\n        :param maxsize: maximum size in kb\n        \"\"\"\n        if not any([new_name, iotype, lun_ids, smp_names, ctrlmethod]):\n            raise ValueError('Cannot apply modification, please specify '\n                             'parameters to modify.')\n\n        def _do_modify():\n            out = self._cli.modify_ioclass(\n                self._get_name(), new_name, iotype, lun_ids, smp_names,\n                ctrlmethod, minsize, maxsize)\n            ex.raise_if_err(out, default=ex.VNXIOClassError)\n\n        try:\n            _do_modify()\n        except ex.VNXIOCLassRunningError:\n            with restart_policy(self.policy):\n                _do_modify()\n\n        return VNXIOClass(new_name if new_name else self._get_name(),\n                          self._cli)", "response": "Modify the properties of a VNX IOClass."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd one VNXIOClass instance to the policy.", "response": "def add_class(self, ioclass):\n        \"\"\"Add one VNXIOClass instance to policy.\n\n        .. note: due to the limitation of VNX, need to stop the policy first.\n        \"\"\"\n        current_ioclasses = self.ioclasses\n        if ioclass.name in current_ioclasses.name:\n            return\n        current_ioclasses.append(ioclass)\n        self.modify(new_ioclasses=current_ioclasses)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_class(self, ioclass):\n        current_ioclasses = self.ioclasses\n        new_ioclasses = filter(lambda x: x.name != ioclass.name,\n                               current_ioclasses)\n        self.modify(new_ioclasses=new_ioclasses)", "response": "Remove VNXIOClass instance from policy."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replace_lun(self, *lun_list):\n        lun_add = self._prepare_luns_add(lun_list)\n        lun_remove = self._prepare_luns_remove(lun_list, False)\n        return self.modify(lun_add=lun_add, lun_remove=lun_remove)", "response": "Replaces the exiting LUNs to lun_list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the LUNs in CG adding the ones in add_luns and removing the ones in remove_luns.", "response": "def update_lun(self, add_luns=None, remove_luns=None):\n        \"\"\"Updates the LUNs in CG, adding the ones in `add_luns` and removing\n        the ones in `remove_luns`\"\"\"\n        if not add_luns and not remove_luns:\n            log.debug(\"Empty add_luns and remove_luns passed in, \"\n                      \"skip update_lun.\")\n            return RESP_OK\n        lun_add = self._prepare_luns_add(add_luns)\n        lun_remove = self._prepare_luns_remove(remove_luns, True)\n        return self.modify(lun_add=lun_add, lun_remove=lun_remove)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean(inst):\n\n    inst.data.replace(-999., np.nan, inplace=True) # Te\n    inst.data.replace(-9.9999998e+30, np.nan, inplace=True) #Ni\n\n    return None", "response": "Routine to return FPMU data cleaned to the specified level"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nattaches info returned by instrument list_files routine to object.", "response": "def _attach_files(self, files_info):\n        \"\"\"Attaches info returned by instrument list_files routine to\n        Instrument object.\n        \"\"\"\n\n        if not files_info.empty:\n            if (len(files_info.index.unique()) != len(files_info)):\n                estr = 'WARNING! Duplicate datetimes in provided file '\n                estr = '{:s}information.\\nKeeping one of each '.format(estr)\n                estr = '{:s}of the duplicates, dropping the rest.'.format(estr)\n                print(estr)\n                print(files_info.index.get_duplicates())\n\n                idx = np.unique(files_info.index, return_index=True)\n                files_info = files_info.ix[idx[1]]\n                #raise ValueError('List of files must have unique datetimes.')\n\n            self.files = files_info.sort_index()\n            date = files_info.index[0]\n            self.start_date = pds.datetime(date.year, date.month, date.day)\n            date = files_info.index[-1]\n            self.stop_date = pds.datetime(date.year, date.month, date.day)\n        else:\n            self.start_date = None\n            self.stop_date = None\n            # convert to object type\n            # necessary if Series is empty, enables == checks with strings\n            self.files = files_info.astype(np.dtype('O'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstores currently loaded filelist for instrument onto filesystem", "response": "def _store(self):\n        \"\"\"Store currently loaded filelist for instrument onto filesystem\"\"\"\n\n        name = self.stored_file_name\n        # check if current file data is different than stored file list\n        # if so, move file list to previous file list, store current to file\n        # if not, do nothing\n        stored_files = self._load()\n        if len(stored_files) != len(self.files):\n            # # of items is different, things are new\n            new_flag = True\n        elif len(stored_files) == len(self.files):\n            # # of items equal, check specifically for equality\n            if stored_files.eq(self.files).all():\n                new_flag = False\n            else:\n                # not equal, there are new files\n                new_flag = True\n\n        if new_flag:\n            \n            if self.write_to_disk:\n                stored_files.to_csv(os.path.join(self.home_path,\n                                                 'previous_'+name),\n                                    date_format='%Y-%m-%d %H:%M:%S.%f')\n                self.files.to_csv(os.path.join(self.home_path, name),\n                                date_format='%Y-%m-%d %H:%M:%S.%f')\n            else:\n                self._previous_file_list = stored_files\n                self._current_file_list = self.files.copy()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load(self, prev_version=False):\n\n        fname = self.stored_file_name\n        if prev_version:\n            fname = os.path.join(self.home_path, 'previous_'+fname)\n        else:\n            fname = os.path.join(self.home_path, fname)\n\n        if os.path.isfile(fname) and (os.path.getsize(fname) > 0):\n            if self.write_to_disk:\n                return pds.read_csv(fname, index_col=0, parse_dates=True,\n                                    squeeze=True, header=None)\n            else:\n                # grab files from memory\n                if prev_version:\n                    return self._previous_file_list\n                else:\n                    return self._current_file_list\n        else:\n            return pds.Series([], dtype='a')", "response": "Load stored filelist and return as Pandas Series"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the list of files for the given science instrument.", "response": "def refresh(self):\n        \"\"\"Update list of files, if there are changes.\n        \n        Calls underlying list_rtn for the particular science instrument.\n        Typically, these routines search in the pysat provided path,\n        pysat_data_dir/platform/name/tag/,\n        where pysat_data_dir is set by pysat.utils.set_data_dir(path=path).\n        \n\n        \"\"\"\n\n        output_str = '{platform} {name} {tag} {sat_id}'\n        output_str = output_str.format(platform=self._sat.platform,\n                                       name=self._sat.name, tag=self._sat.tag, \n                                       sat_id=self._sat.sat_id)\n        output_str = \" \".join((\"pysat is searching for\", output_str, \"files.\"))\n        output_str = \" \".join(output_str.split())\n        print (output_str)\n        \n        info = self._sat._list_rtn(tag=self._sat.tag, sat_id=self._sat.sat_id,\n                                   data_path=self.data_path,\n                                   format_str=self.file_format)\n\n        if not info.empty:\n            print('Found {ll:d} of them.'.format(ll=len(info)))\n        else:\n            estr = \"Unable to find any files that match the supplied template. \"\n            estr += \"If you have the necessary files please check pysat \"\n            estr += \"settings and file locations (e.g. pysat.pysat_dir).\"\n            print(estr)\n        info = self._remove_data_dir_path(info)\n        self._attach_files(info)\n        self._store()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_new(self):\n\n        # refresh files\n        self.refresh()\n        # current files\n        new_info = self._load()\n        # previous set of files\n        old_info = self._load(prev_version=True)\n        new_files = new_info[-new_info.isin(old_info)]\n        return new_files", "response": "Get a list of all new files since last recorded file state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn index for a given filename.", "response": "def get_index(self, fname):\n        \"\"\"Return index for a given filename. \n        \n        Parameters\n        ----------\n        fname : string\n            filename\n        \n        Note\n        ----\n        If fname not found in the file information already attached \n        to the instrument.files instance, then a files.refresh() call \n        is made.\n        \n        \"\"\"\n\n        idx, = np.where(fname == self.files)\n        if len(idx) == 0:\n            # filename not in index, try reloading files from disk\n            self.refresh()\n            #print(\"DEBUG get_index:\", fname, self.files)\n            idx, = np.where(fname == np.array(self.files))\n\n            if len(idx) == 0:\n                raise ValueError('Could not find \"' + fname +\n                                 '\" in available file list. Valid Example: ' +\n                                 self.files.iloc[0])\n        # return a scalar rather than array - otherwise introduces array to\n        # index warnings.\n        return idx[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file_array(self, start, end):\n        if hasattr(start, '__iter__') & hasattr(end, '__iter__'):\n            files = []\n            for (sta,stp) in zip(start, end):\n                id1 = self.get_index(sta)\n                id2 = self.get_index(stp)\n                files.extend(self.files.iloc[id1 : id2+1])\n        elif hasattr(start, '__iter__') | hasattr(end, '__iter__'):\n            estr = 'Either both or none of the inputs need to be iterable'\n            raise ValueError(estr)\n        else:\n            id1 = self.get_index(start)\n            id2 = self.get_index(end)\n            files = self.files[id1:id2+1].to_list()\n        return files", "response": "Returns a list of filenames between start and end over all the available file intervals."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the data directory path from filenames", "response": "def _remove_data_dir_path(self, inp=None):\n        # import string\n        \"\"\"Remove the data directory path from filenames\"\"\"\n        # need to add a check in here to make sure data_dir path is actually in\n        # the filename\n        if inp is not None:\n            split_str = os.path.join(self.data_path, '')\n            return inp.apply(lambda x: x.split(split_str)[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new object of class Files from os. path.", "response": "def from_os(cls, data_path=None, format_str=None, \n                two_digit_year_break=None):\n        \"\"\"\n        Produces a list of files and and formats it for Files class.\n\n        Requires fixed_width filename\n        \n        Parameters\n        ----------\n        data_path : string\n            Top level directory to search files for. This directory\n            is provided by pysat to the instrument_module.list_files\n            functions as data_path.\n        format_str : string with python format codes\n            Provides the naming pattern of the instrument files and the \n            locations of date information so an ordered list may be produced.\n            Supports 'year', 'month', 'day', 'hour', 'min', 'sec', 'version',\n            and 'revision'\n            Ex: 'cnofs_cindi_ivm_500ms_{year:4d}{month:02d}{day:02d}_v01.cdf'\n        two_digit_year_break : int\n            If filenames only store two digits for the year, then\n            '1900' will be added for years >= two_digit_year_break\n            and '2000' will be added for years < two_digit_year_break.\n          \n        Note\n        ----\n        Does not produce a Files instance, but the proper output\n        from instrument_module.list_files method.\n\n        The '?' may be used to indicate a set number of spaces for a variable\n        part of the name that need not be extracted.\n        'cnofs_cindi_ivm_500ms_{year:4d}{month:02d}{day:02d}_v??.cdf'\n        \"\"\"\n\n        import collections\n        \n        from pysat.utils import create_datetime_index\n        \n        if format_str is None:\n            raise ValueError(\"Must supply a filename template (format_str).\")\n        if data_path is None:\n            raise ValueError(\"Must supply instrument directory path (dir_path)\")\n        \n        # parse format string to figure out the search string to use\n        # to identify files in the filesystem\n        search_str = ''\n        form = string.Formatter()\n        # stores the keywords extracted from format_string\n        keys = []\n        #, and length of string\n        snips = []\n        length = []\n        stored = collections.OrderedDict()\n        stored['year'] = []; stored['month'] = []; stored['day'] = [];\n        stored['hour'] = []; stored['min'] = []; stored['sec'] = [];\n        stored['version'] = []; stored['revision'] = [];\n        for snip in form.parse(format_str):\n            # collect all of the format keywords\n            # replace them in the string with the '*' wildcard\n            # then try and get width from format keywords so we know\n            # later on where to parse information out from\n            search_str += snip[0]\n            snips.append(snip[0])\n            if snip[1] is not None:\n                keys.append(snip[1])\n                search_str += '*'\n                # try and determine formatting width\n                temp = re.findall(r'\\d+', snip[2])\n                if temp:\n                    # there are items, try and grab width\n                    for i in temp:\n                        if i != 0:\n                            length.append(int(i))\n                            break\n                else:\n                    raise ValueError(\"Couldn't determine formatting width\")\n\n        abs_search_str = os.path.join(data_path, search_str)\n        files = glob.glob(abs_search_str)   \n        \n        # we have a list of files, now we need to extract the date information\n        # code below works, but only if the size of file string \n        # remains unchanged\n        \n        # determine the locations the date information in a filename is stored\n        # use these indices to slice out date from loaded filenames\n        # test_str = format_str.format(**periods)\n        if len(files) > 0:  \n            idx = 0\n            begin_key = []\n            end_key = []\n            for i,snip in enumerate(snips):\n                idx += len(snip)\n                if i < (len(length)):\n                    begin_key.append(idx)\n                    idx += length[i]\n                    end_key.append(idx)\n            max_len = idx\n            # setting up negative indexing to pick out filenames\n            key_str_idx = [np.array(begin_key, dtype=int) - max_len, \n                           np.array(end_key, dtype=int) - max_len]\n            # need to parse out dates for datetime index\n            for i,temp in enumerate(files):\n                for j,key in enumerate(keys):\n                    val = temp[key_str_idx[0][j]:key_str_idx[1][j]]\n                    stored[key].append(val)\n            # convert to numpy arrays\n            for key in stored.keys():\n                stored[key] = np.array(stored[key]).astype(int)\n                if len(stored[key]) == 0:\n                    stored[key]=None\n            # deal with the possibility of two digit years\n            # years above or equal to break are considered to be 1900+\n            # years below break are considered to be 2000+\n            if two_digit_year_break is not None:\n                idx, = np.where(np.array(stored['year']) >=\n                                two_digit_year_break)\n                stored['year'][idx] = stored['year'][idx] + 1900\n                idx, = np.where(np.array(stored['year']) < two_digit_year_break)\n                stored['year'][idx] = stored['year'][idx] + 2000 \n            # need to sort the information for things to work\n            rec_arr = [stored[key] for key in keys]\n            rec_arr.append(files)\n            # sort all arrays\n            val_keys = keys + ['files']\n            rec_arr = np.rec.fromarrays(rec_arr, names=val_keys)\n            rec_arr.sort(order=val_keys, axis=0)\n            # pull out sorted info\n            for key in keys:\n                stored[key] = rec_arr[key]\n            files = rec_arr['files']\n            # add hour and minute information to 'sec'\n            if stored['sec'] is None:\n                stored['sec'] = np.zeros(len(files))                \n            if stored['hour'] is not None:\n                stored['sec'] += 3600 * stored['hour']\n            if stored['min'] is not None:\n                stored['sec'] += 60 * stored['min']\n            # if stored['version'] is None:\n            #     stored['version'] = np.zeros(len(files))\n            if stored['revision'] is None:\n                stored['revision'] = np.zeros(len(files))\n\n            index = create_datetime_index(year=stored['year'],\n                                          month=stored['month'], \n                                          day=stored['day'], uts=stored['sec'])\n\n            # if version and revision are supplied\n            # use these parameters to weed out files that have been replaced\n            # with updated versions\n            # first, check for duplicate index times\n            dups = index.get_duplicates()\n            if (len(dups) > 0) and (stored['version'] is not None):\n                # we have duplicates\n                # keep the highest version/revision combo\n                version = pds.Series(stored['version'], index=index)\n                revision = pds.Series(stored['revision'], index=index)\n                revive = version*100000. + revision\n                frame = pds.DataFrame({'files':files, 'revive':revive,\n                                       'time':index}, index=index)\n                frame = frame.sort_values(by=['time', 'revive'],\n                                          ascending=[True, False])\n                frame = frame.drop_duplicates(subset='time', keep='first')\n\n                return frame['files']\n            else:\n                return pds.Series(files, index=index)\n        else:\n            return pds.Series(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge(self, other):\n        \n        for key in other.keys():\n            if key not in self:\n                # copies over both lower and higher dimensional data\n                self[key] = other[key]", "response": "Adds metadata variables from other to self but not in self."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef drop(self, names):\n        \n        # drop lower dimension data\n        self._data = self._data.drop(names, axis=0)\n        # drop higher dimension data\n        for name in names:\n            if name in self._ho_data:\n                _ = self._ho_data.pop(name)", "response": "Drops variables from metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keep(self, keep_names):\n        \n        current_names = self._data.columns\n        drop_names = []\n        for name in current_names:\n            if name not in keep_names:\n                drop_names.append(name)\n        self.drop(drop_names)", "response": "Keeps variables ( keep_names while dropping other parameters"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply_default_labels(self, other):\n        other_updated = other.copy()\n        other_updated.units_label = self.units_label\n        other_updated.name_label = self.name_label\n        other_updated.notes_label = self.notes_label\n        other_updated.desc_label = self.desc_label\n        other_updated.plot_label = self.plot_label\n        other_updated.axis_label = self.axis_label\n        other_updated.scale_label = self.scale_label\n        other_updated.min_label = self.min_label\n        other_updated.max_label = self.max_label\n        other_updated.fill_label = self.fill_label\n        return other", "response": "Applies default labels from self onto other."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply default labels for meta labels from other onto self.", "response": "def accept_default_labels(self, other):\n        \"\"\"Applies labels for default meta labels from other onto self.\n        \n        Parameters\n        ----------\n        other : Meta\n            Meta object to take default labels from\n        \n        Returns\n        -------\n        Meta\n        \n        \"\"\"\n\n        self.units_label = other.units_label\n        self.name_label = other.name_label\n        self.notes_label = other.notes_label\n        self.desc_label = other.desc_label\n        self.plot_label = other.plot_label\n        self.axis_label = other.axis_label\n        self.scale_label = other.scale_label\n        self.min_label = other.min_label\n        self.max_label = other.max_label\n        self.fill_label = other.fill_label\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _label_setter(self, new_label, current_label, attr_label, default=np.NaN, use_names_default=False):\n        \n        if new_label not in self.attrs():\n            # new label not in metadata, including case\n            # update existing label, if present\n            if current_label in self.attrs():\n                # old label exists and has expected case\n                self.data.loc[:, new_label] = self.data.loc[:, current_label]\n                self.data.drop(current_label, axis=1, inplace=True)\n            else:\n                if self.has_attr(current_label):\n                    # there is something like label, wrong case though\n                    current_label = self.attr_case_name(current_label)\n                    self.data.loc[:, new_label] = self.data.loc[:, current_label]\n                    self.data.drop(current_label, axis=1, inplace=True)\n                else:\n                    # there is no existing label\n                    # setting for the first time\n                    if use_names_default:\n                        self.data[new_label] = self.data.index\n                    else:\n                        self.data[new_label] = default\n            # check higher order structures as well\n            # recursively change labels here\n            for key in self.keys_nD():\n                setattr(self.ho_data[key], attr_label, new_label)\n\n        # now update 'hidden' attribute value\n        # current_label = new_label\n        setattr(self, ''.join(('_',attr_label)), new_label)", "response": "Generalized setter of meta attributes that actually stores metadata and the meta attributes that actually stores metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_attr(self, name):\n\n        if name.lower() in [i.lower() for i in self.data.columns]:\n            return True\n        return False", "response": "Returns boolean indicating presence of given attribute name Case - insensitive check\nobi."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn preserved case name for case insensitive value of name.", "response": "def attr_case_name(self, name):\n        \"\"\"Returns preserved case name for case insensitive value of name.\n        \n        Checks first within standard attributes. If not found there, checks\n        attributes for higher order data structures. If not found, returns\n        supplied name as it is available for use. Intended to be used to help\n        ensure that the same case is applied to all repetitions of a given\n        variable name.\n        \n        Parameters\n        ----------\n        name : str\n            name of variable to get stored case form\n\n        Returns\n        -------\n        str\n            name in proper case\n        \"\"\"\n\n        lower_name = name.lower()\n        for i in self.attrs():\n            if lower_name == i.lower():\n                return i\n        # check if attribute present in higher order structures\n        for key in self.keys_nD():\n            for i in self[key].children.attrs():\n                if lower_name == i.lower():\n                    return i\n        # nothing was found if still here\n        # pass name back, free to be whatever\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef concat(self, other, strict=False):\n\n        mdata = self.copy()\n        # checks\n        if strict:\n            for key in other.keys():\n                if key in mdata:\n                    raise RuntimeError('Duplicated keys (variable names) ' +\n                                       'across Meta objects in keys().')\n            for key in other.keys_nD():\n                if key in mdata:\n\n                    raise RuntimeError('Duplicated keys (variable names) across '\n                                        'Meta objects in keys_nD().')\n                                        \n        # make sure labels between the two objects are the same\n        other_updated = self.apply_default_labels(other)\n        # concat 1D metadata in data frames to copy of\n        # current metadata\n# <<<<<<< ho_meta_fix\n        for key in other_updated.keys():\n            mdata.data.loc[key] = other.data.loc[key]\n        # add together higher order data\n        for key in other_updated.keys_nD():\n            mdata.ho_data[key] = other.ho_data[key]\n# =======\n#         for key in other_updated.keys():\n#             mdata[key] = other_updated[key]\n#         # add together higher order data\n#         for key in other_updated.keys_nD():\n#             mdata[key] = other_updated[key]\n\n        return mdata", "response": "Returns a new MetaObject that is the concatenation of two Meta objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove and return metadata about variable name and return Series of metadata about variable name.", "response": "def pop(self, name):\n        \"\"\"Remove and return metadata about variable\n\n        Parameters\n        ----------\n        name : str\n            variable name\n\n        Returns\n        -------\n        pandas.Series\n            Series of metadata for variable\n        \"\"\"\n        # check if present\n        if name in self:\n            # get case preserved name for variable\n            new_name = self.var_case_name(name)\n            # check if 1D or nD\n            if new_name in self.keys():\n                output = self[new_name]\n                self.data.drop(new_name, inplace=True, axis=0)\n            else:\n                output = self.ho_data.pop(new_name)\n                \n            return output\n        else:\n            raise KeyError('Key not present in metadata variables')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transfer_attributes_to_instrument(self, inst, strict_names=False):\n\n        # base Instrument attributes\n        banned = inst._base_attr\n        # get base attribute set, and attributes attached to instance\n        base_attrb = self._base_attr\n        this_attrb = dir(self)\n        # collect these attributes into a dict\n        adict = {}\n        transfer_key = []\n        for key in this_attrb:\n            if key not in banned:\n                if key not in base_attrb:\n                    # don't store _ leading attributes\n                    if key[0] != '_':\n                        adict[key] = self.__getattribute__(key)\n                        transfer_key.append(key)\n\n        # store any non-standard attributes in Instrument\n        # get list of instrument objects attributes first\n        # to check if a duplicate\n        inst_attr = dir(inst)\n        for key in transfer_key:\n            if key not in banned:\n                if key not in inst_attr:\n                    inst.__setattr__(key, adict[key])\n                else:\n                    if not strict_names:\n                        # new_name = 'pysat_attr_'+key\n                        inst.__setattr__(key, adict[key])\n                    else:\n                        raise RuntimeError('Attribute ' + key +\n                                           'attached to Meta object can not be '\n                                           + 'transferred as it already exists'\n                                           + ' in the Instrument object.')", "response": "This routine transfers non - standard attributes in the Meta object to the Instrument object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_csv(cls, name=None, col_names=None, sep=None, **kwargs):\n        import pysat\n        req_names = ['name','long_name','units']\n        if col_names is None:\n            col_names = req_names\n        elif not all([i in col_names for i in req_names]):\n            raise ValueError('col_names must include name, long_name, units.')\n\n        if sep is None:\n            sep = ','\n\n        if name is None:\n            raise ValueError('Must supply an instrument name or file path.')\n        elif not isinstance(name, str):\n            raise ValueError('keyword name must be related to a string')\n        elif not os.path.isfile(name):\n                # Not a real file, assume input is a pysat instrument name\n                # and look in the standard pysat location.\n                test =  os.path.join(pysat.__path__[0],'instruments',name)\n                if os.path.isfile(test):\n                    name = test\n                else:\n                    #trying to form an absolute path for success\n                    test = os.path.abspath(name)\n                    if not os.path.isfile(test):\n                        raise ValueError(\"Unable to create valid file path.\")\n                    else:\n                        #success\n                        name = test\n\n        mdata = pds.read_csv(name, names=col_names, sep=sep, **kwargs) \n\n        if not mdata.empty:\n            # make sure the data name is the index\n            mdata.index = mdata['name']\n            del mdata['name']\n            return cls(metadata=mdata)\n        else:\n            raise ValueError('Unable to retrieve information from ' + name)", "response": "Create an instrument metadata object from a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean(self):\n\n    # cleans cindi data\n    if self.clean_level == 'clean':\n        # choose areas below 550km\n        # self.data = self.data[self.data.alt <= 550]\n        idx, = np.where(self.data.altitude <= 550)\n        self.data = self[idx,:]\n    \n    # make sure all -999999 values are NaN\n    self.data.replace(-999999., np.nan, inplace=True)\n\n    if (self.clean_level == 'clean') | (self.clean_level == 'dusty'):\n        try:\n            idx, = np.where(np.abs(self.data.ionVelmeridional) < 10000.)\n            self.data = self[idx,:]\n        except AttributeError:\n            pass\n        \n        if self.clean_level == 'dusty':\n            # take out all values where RPA data quality is > 1\n            idx, = np.where(self.data.RPAflag <= 1)\n            self.data = self[idx,:]\n            # IDM quality flags\n            self.data = self.data[ (self.data.driftMeterflag<= 3) ]\n        else:\n            # take out all values where RPA data quality is > 0\n            idx, = np.where(self.data.RPAflag <= 0)\n            self.data = self[idx,:] \n            # IDM quality flags\n            self.data = self.data[ (self.data.driftMeterflag<= 0) ]\n    if self.clean_level == 'dirty':\n        # take out all values where RPA data quality is > 4\n        idx, = np.where(self.data.RPAflag <= 4)\n        self.data = self[idx,:]\n        # IDM quality flags\n        self.data = self.data[ (self.data.driftMeterflag<= 6) ]\n        \n    # basic quality check on drifts and don't let UTS go above 86400.\n    idx, = np.where(self.data.time <= 86400.)\n    self.data = self[idx,:]\n    \n    # make sure MLT is between 0 and 24\n    idx, = np.where((self.data.mlt >= 0) & (self.data.mlt <= 24.))\n    self.data = self[idx,:]\n    return", "response": "Routine to return the C / NOFS IVM data cleaned to the specified level."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nonraw_instance(receiver):\n    @wraps(receiver)\n    def wrapper(sender, instance, raw, using, **kwargs):\n        if raw:\n            instance = sender._default_manager.using(using).get(pk=instance.pk)\n        return receiver(sender=sender, raw=raw, instance=instance, using=using,\n                        **kwargs)\n    return wrapper", "response": "A signal receiver that fetches the complete instance from db when\n            it s passed as raw\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef base_definition_pre_delete(sender, instance, **kwargs):\n    # see CASCADE_MARK_ORIGIN's docstring\n    cascade_deletion_origin = popattr(\n        instance._state, '_cascade_deletion_origin', None\n    )\n    if cascade_deletion_origin == 'model_def':\n        return\n    if (instance.base and issubclass(instance.base, models.Model) and\n            instance.base._meta.abstract):\n        instance._state._deletion = instance.model_def.model_class().render_state()", "response": "Called when a base definition is pre - deleted."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef base_definition_post_delete(sender, instance, **kwargs):\n    if hasattr(instance._state, '_deletion'):\n        # Make sure to flatten abstract bases since Django\n        # migrations can't deal with them.\n        model = popattr(instance._state, '_deletion')\n        for field in instance.base._meta.fields:\n            perform_ddl('remove_field', model, field)", "response": "Delete fields inherited from an abstract model base."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef field_definition_post_save(sender, instance, created, raw, **kwargs):\n    model_class = instance.model_def.model_class().render_state()\n    field = instance.construct_for_migrate()\n    field.model = model_class\n    if created:\n        if hasattr(instance._state, '_creation_default_value'):\n            field.default = instance._state._creation_default_value\n            delattr(instance._state, '_creation_default_value')\n        add_column = popattr(instance._state, '_add_column', True)\n        if add_column:\n            perform_ddl('add_field', model_class, field)\n            # If the field definition is raw we must re-create the model class\n            # since ModelDefinitionAttribute.save won't be called\n            if raw:\n                instance.model_def.model_class().mark_as_obsolete()\n    else:\n        old_field = instance._state._pre_save_field\n        delattr(instance._state, '_pre_save_field')\n        perform_ddl('alter_field', model_class, old_field, field, strict=True)", "response": "Called when a FieldDefinition is created or updated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an attribute from an object and remove it if it s part of it s dict.", "response": "def popattr(obj, attr, default=NOT_PROVIDED):\n    \"\"\"\n    Useful for retrieving an object attr and removing it if it's part of it's\n    dict while allowing retrieving from subclass.\n    i.e.\n    class A:\n        a = 'a'\n    class B(A):\n        b = 'b'\n    >>> popattr(B, 'a', None)\n    'a'\n    >>> A.a\n    'a'\n    \"\"\"\n    val = getattr(obj, attr, default)\n    try:\n        delattr(obj, attr)\n    except AttributeError:\n        if default is NOT_PROVIDED:\n            raise\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking sure all related model class are created and marked as dependency when a mutable model class is prepared", "response": "def mutable_model_prepared(signal, sender, definition, existing_model_class,\n                           **kwargs):\n    \"\"\"\n    Make sure all related model class are created and marked as dependency\n    when a mutable model class is prepared\n    \"\"\"\n    referenced_models = set()\n    # Collect all model class the obsolete model class was referring to\n    if existing_model_class:\n        for field in existing_model_class._meta.local_fields:\n            if isinstance(field, RelatedField):\n                remote_field_model = get_remote_field_model(field)\n                if not isinstance(remote_field_model, string_types):\n                    referenced_models.add(remote_field_model)\n    # Add sender as a dependency of all mutable models it refers to\n    for field in sender._meta.local_fields:\n        if isinstance(field, RelatedField):\n            remote_field_model = get_remote_field_model(field)\n            if not isinstance(remote_field_model, string_types):\n                referenced_models.add(remote_field_model)\n                if (issubclass(remote_field_model, MutableModel) and\n                        remote_field_model._definition != sender._definition):\n                    remote_field_model._dependencies.add(sender._definition)\n    # Mark all model referring to this one as dependencies\n    related_model_defs = ModelDefinition.objects.filter(\n        Q(fielddefinitions__foreignkeydefinition__to=definition) |\n        Q(fielddefinitions__manytomanyfielddefinition__to=definition)\n    ).distinct()\n    for model_def in related_model_defs:\n        if model_def != definition:\n            # Generate model class from definition and add it as a dependency\n            sender._dependencies.add(model_def.model_class()._definition)\n    # Clear the referenced models opts related cache\n    for model_class in referenced_models:\n        clear_opts_related_cache(model_class)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes sure the lookup makes sense", "response": "def clean(self):\n        \"\"\"\n        Make sure the lookup makes sense\n        \"\"\"\n        if self.lookup == '?':  # Randomly sort\n            return\n        else:\n            lookups = self.lookup.split(LOOKUP_SEP)\n            opts = self.model_def.model_class()._meta\n            valid = True\n            while len(lookups):\n                lookup = lookups.pop(0)\n                try:\n                    field = opts.get_field(lookup)\n                except FieldDoesNotExist:\n                    valid = False\n                else:\n                    if isinstance(field, models.ForeignKey):\n                        opts = get_remote_field_model(field)._meta\n                    elif len(lookups):  # Cannot go any deeper\n                        valid = False\n                finally:\n                    if not valid:\n                        msg = _(\"This field doesn't exist\")\n                        raise ValidationError({'lookup': [msg]})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lorentz_deriv((x, y, z), t0, sigma=10., beta=8./3, rho=28.0):\n    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]", "response": "Compute the time - derivative of a Lorentz system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding the parser for reading the command line arguments", "response": "def buildParser():\n    ''' Builds the parser for reading the command line arguments'''\n    parser = argparse.ArgumentParser(description='Bagfile reader')\n    parser.add_argument('-b', '--bag', help='Bag file to read',\n                        required=True, type=str)\n    parser.add_argument('-s', '--series',\n                        help='Msg data fields to graph',\n                        required=True, nargs='*')\n    parser.add_argument('-y ', '--ylim',\n                        help='Set min and max y lim',\n                        required=False, nargs=2)\n    parser.add_argument('-c', '--combined',\n                        help=\"Graph them all on one\",\n                        required=False, action=\"store_true\", dest=\"sharey\")\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_series_args(topics, fields):\n    '''Return which topics and which field keys need to be examined\n    for plotting'''\n    keys = {}\n    for field in fields:\n        for topic in topics:\n            if field.startswith(topic):\n                keys[field] = (topic, field[len(topic) + 1:])\n\n    return keys", "response": "Return which topics and which field keys need to be examined\n    for plotting"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads in a rosbag file and create a pandas dataframe object that represents the contents of the message in the rosbag file.", "response": "def bag_to_dataframe(bag_name, include=None, exclude=None, parse_header=False, seconds=False):\n    '''\n    Read in a rosbag file and create a pandas data frame that\n    is indexed by the time the message was recorded in the bag.\n\n    :bag_name: String name for the bag file\n    :include: None, String, or List  Topics to include in the dataframe\n               if None all topics added, if string it is used as regular\n                   expression, if list that list is used.\n    :exclude: None, String, or List  Topics to be removed from those added\n            using the include option using set difference.  If None no topics\n            removed. If String it is treated as a regular expression. A list\n            removes those in the list.\n\n    :seconds: time index is in seconds\n\n    :returns: a pandas dataframe object\n    '''\n    # get list of topics to parse\n    yaml_info = get_bag_info(bag_name)\n    bag_topics = get_topics(yaml_info)\n    bag_topics = prune_topics(bag_topics, include, exclude)\n    length = get_length(bag_topics, yaml_info)\n    msgs_to_read, msg_type = get_msg_info(yaml_info, bag_topics, parse_header)\n\n    bag = rosbag.Bag(bag_name)\n    dmap = create_data_map(msgs_to_read)\n\n    # create datastore\n    datastore = {}\n    for topic in dmap.keys():\n        for f, key in dmap[topic].iteritems():\n            t = msg_type[topic][f]\n            if isinstance(t, int) or isinstance(t, float):\n                arr = np.empty(length)\n                arr.fill(np.NAN)\n            elif isinstance(t, list):\n                arr = np.empty(length)\n                arr.fill(np.NAN)\n                for i in range(len(t)):\n                    key_i = '{0}{1}'.format(key, i)\n                    datastore[key_i] = arr.copy()\n                continue\n            else:\n                arr = np.empty(length, dtype=np.object)\n            datastore[key] = arr\n\n    # create the index\n    index = np.empty(length)\n    index.fill(np.NAN)\n\n    # all of the data is loaded\n    for idx, (topic, msg, mt) in enumerate(bag.read_messages(topics=bag_topics)):\n        try:\n            if seconds:\n                index[idx] = msg.header.stamp.to_sec()\n            else:\n                index[idx] = msg.header.stamp.to_nsec()\n        except:\n            if seconds:\n                index[idx] = mt.to_sec()\n            else:\n                index[idx] = mt.to_nsec()\n        fields = dmap[topic]\n        for f, key in fields.iteritems():\n            try:\n                d = get_message_data(msg, f)\n                if isinstance(d, tuple):\n                    for i, val in enumerate(d):\n                        key_i = '{0}{1}'.format(key, i)\n                        datastore[key_i][idx] = val\n                else:\n                    datastore[key][idx] = d\n            except:\n                pass\n\n    bag.close()\n\n    # convert the index\n    if not seconds:\n        index = pd.to_datetime(index, unit='ns')\n\n    # now we have read all of the messages its time to assemble the dataframe\n    return pd.DataFrame(data=datastore, index=index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the length of the messages in the created dataframe", "response": "def get_length(topics, yaml_info):\n    '''\n    Find the length (# of rows) in the created dataframe\n    '''\n    total = 0\n    info = yaml_info['topics']\n    for topic in topics:\n        for t in info:\n            if t['topic'] == topic:\n                total = total + t['messages']\n                break\n    return total"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_data_map(msgs_to_read):\n    '''\n    Create a data map for usage when parsing the bag\n    '''\n    dmap = {}\n    for topic in msgs_to_read.keys():\n        base_name = get_key_name(topic) + '__'\n        fields = {}\n        for f in msgs_to_read[topic]:\n            key = (base_name + f).replace('.', '_')\n            fields[f] = key\n        dmap[topic] = fields\n    return dmap", "response": "Create a data map for usage when parsing the bag\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprunes the topics. If include is None add all to the set of topics to use if include is a string regex match that string, if it is a list use the list If exclude is None do nothing, if string remove the topics with regex, if it is a list remove those topics", "response": "def prune_topics(bag_topics, include, exclude):\n    '''prune the topics.  If include is None add all to the set of topics to\n       use if include is a string regex match that string,\n       if it is a list use the list\n\n        If exclude is None do nothing, if string remove the topics with regex,\n        if it is a list remove those topics'''\n\n    topics_to_use = set()\n    # add all of the topics\n    if include is None:\n        for t in bag_topics:\n            topics_to_use.add(t)\n    elif isinstance(include, basestring):\n        check = re.compile(include)\n        for t in bag_topics:\n            if re.match(check, t) is not None:\n                topics_to_use.add(t)\n    else:\n        try:\n            # add all of the includes if it is in the topic\n            for topic in include:\n                if topic in bag_topics:\n                    topics_to_use.add(topic)\n        except:\n            warnings.warn('Error in topic selection Using All!')\n            topics_to_use = set()\n            for t in bag_topics:\n                topics_to_use.add(t)\n\n    to_remove = set()\n    # now exclude the exclusions\n    if exclude is None:\n        pass\n    elif isinstance(exclude, basestring):\n        check = re.compile(exclude)\n        for t in list(topics_to_use):\n            if re.match(check, t) is not None:\n                to_remove.add(t)\n    else:\n        for remove in exclude:\n            if remove in exclude:\n                to_remove.add(remove)\n\n    # final set stuff to get topics to use\n    topics_to_use = topics_to_use - to_remove\n    # return a list for the results\n    return list(topics_to_use)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_msg_info(yaml_info, topics, parse_header=True):\n    '''\n    Get info from all of the messages about what they contain\n    and will be added to the dataframe\n    '''\n    topic_info = yaml_info['topics']\n    msgs = {}\n    classes = {}\n\n    for topic in topics:\n        base_key = get_key_name(topic)\n        msg_paths = []\n        msg_types = {}\n        for info in topic_info:\n            if info['topic'] == topic:\n                msg_class = get_message_class(info['type'])\n                if msg_class is None:\n                    warnings.warn(\n                        'Could not find types for ' + topic + ' skpping ')\n                else:\n                    (msg_paths, msg_types) = get_base_fields(msg_class(), \"\",\n                                                             parse_header)\n                msgs[topic] = msg_paths\n                classes[topic] = msg_types\n    return (msgs, classes)", "response": "Get info from all of the messages about what they contain\n    and will be added to the dataframe\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bag_info(bag_file):\n    '''Get uamle dict of the bag information\n    by calling the subprocess -- used to create correct sized\n    arrays'''\n    # Get the info on the bag\n    bag_info = yaml.load(subprocess.Popen(\n        ['rosbag', 'info', '--yaml', bag_file],\n        stdout=subprocess.PIPE).communicate()[0])\n    return bag_info", "response": "Get uamle dict of the bag information\n    by calling subprocess. PIPE to create correct sized\n    arrays"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the names of all of the topics in the bag and prints them to stdout if requested", "response": "def get_topics(yaml_info):\n    ''' Returns the names of all of the topics in the bag, and prints them\n        to stdout if requested\n    '''\n    # Pull out the topic info\n    names = []\n    # Store all of the topics in a dictionary\n    topics = yaml_info['topics']\n    for topic in topics:\n        names.append(topic['topic'])\n\n    return names"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions to get the full names of every message field in the message", "response": "def get_base_fields(msg, prefix='', parse_header=True):\n    '''function to get the full names of every message field in the message'''\n    slots = msg.__slots__\n    ret_val = []\n    msg_types = dict()\n    for i in slots:\n        slot_msg = getattr(msg, i)\n        if not parse_header and i == 'header':\n            continue\n        if hasattr(slot_msg, '__slots__'):\n                (subs, type_map) = get_base_fields(\n                    slot_msg, prefix=prefix + i + '.',\n                    parse_header=parse_header,\n                )\n\n                for i in subs:\n                    ret_val.append(i)\n                for k, v in type_map.items():\n                    msg_types[k] = v\n        else:\n            ret_val.append(prefix + i)\n            msg_types[prefix + i] = slot_msg\n    return (ret_val, msg_types)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_message_data(msg, key):\n    '''get the datapoint from the dot delimited message field key\n    e.g. translation.x looks up translation than x and returns the value found\n    in x'''\n    data = msg\n    paths = key.split('.')\n    for i in paths:\n        data = getattr(data, i)\n    return data", "response": "get the datapoint from the dot delimited message field keye. g. translation. x looks up translation than x returns the value found\n    in x"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds the parser for reading the command line arguments", "response": "def buildParser():\n    ''' Builds the parser for reading the command line arguments'''\n    parser = argparse.ArgumentParser(\n        description='Script to parse bagfile to csv file')\n    parser.add_argument('bag', help='Bag file to read',\n                        type=str)\n    parser.add_argument('-i', '--include',\n                        help='list or regex for topics to include',\n                        nargs='*')\n    parser.add_argument('-e', '--exclude',\n                        help='list or regex for topics to exclude',\n                        nargs='*')\n    parser.add_argument('-o', '--output',\n                        help='name of the output file',\n                        nargs='*')\n    parser.add_argument('-f', '--fill',\n                        help='Fill the bag forward and backwards so no missing values when present',\n                        action='store_true')\n    parser.add_argument('--include-header',\n                        help='Include the header fields.  By default they are excluded',\n                        action='store_true')\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef jsonify_payload(self):\n        # Assume already json serialized\n        if isinstance(self.payload, string_types):\n            return self.payload\n        return json.dumps(self.payload, cls=StandardJSONEncoder)", "response": "Dump the payload to JSON"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _send(self):\n\n        payload = self.payload\n        sending_metadata = {'success': False}\n        post_attributes = {'timeout': self.timeout}\n\n        if self.custom_headers:\n            post_attributes['headers'] = self.custom_headers\n        if not post_attributes.get('headers', None):\n            post_attributes['headers'] = {}\n        post_attributes['headers']['Content-Type'] = self.encoding\n\n        post_attributes['data'] = self.format_payload()\n\n        if self.signing_secret:\n            post_attributes['headers']['x-hub-signature'] = self.create_signature(post_attributes['data'], \\\n                                                                                  self.signing_secret)\n\n        for i, wait in enumerate(range(len(self.attempts) - 1)):\n\n            self.attempt = i + 1\n            sending_metadata['attempt'] = self.attempt\n\n            try:\n                print(self.url)\n                self.response = requests.post(self.url, **post_attributes)\n\n                if sys.version > '3':\n                    # Converts bytes object to str object in Python 3+\n                    self.response_content = self.response.content.decode('utf-8')\n                else:\n                    self.response_content = self.response.content\n\n                sending_metadata['status_code'] = self.response.status_code\n\n                # anything with a 200 status code  is a success\n                if self.response.status_code >= 200 and self.response.status_code < 300:\n                    # Exit the sender method.  Here we provide the payload as a result.\n                    #   This is useful for reporting.\n                    self.notify(\"Attempt {}: Successfully sent webhook {}\".format(\n                        self.attempt, self.hash_value)\n                    )\n                    sending_metadata['response'] = self.response_content\n                    sending_metadata['success'] = True\n                    break\n                else:\n                    self.error = \"Status code (%d). Message: %s\" % (self.response.status_code, self.response.text)\n\n\n            except Exception as ex:\n                err_formatted = str(ex).replace('\"',\"'\")\n                sending_metadata['response'] = '{\"status_code\": 500, \"status\":\"failure\",\"error\":\"'+err_formatted+'\"}'\n                self.error = err_formatted\n\n            self.notify(\"Attempt {}: Could not send webhook {}\".format(\n                    self.attempt, self.hash_value)\n            )\n            self.notify_debug(\"Webhook {}. Body: {}\".format(\n                    self.hash_value, self.payload)\n            )\n\n            # If last attempt\n            if self.attempt == (len(self.attempts) - 1):\n                self.notify_error(\"Failed to send webhook {}. Body: {}\".format(\n                    self.hash_value, self.payload)\n                )\n            else:\n                # Wait a bit before the next attempt\n                sleep(wait)\n\n        sending_metadata['error'] = None if sending_metadata['success'] or not self.error else self.error\n        sending_metadata['post_attributes'] = post_attributes\n        merged_dict = sending_metadata.copy()\n        if isinstance(payload, string_types):\n            payload = {'payload': payload}\n\n        # Add the hash value if there is one.\n        if self.hash_value is not None and len(self.hash_value) > 0:\n            payload['hash'] = self.hash_value\n\n        merged_dict.update(payload)\n        return merged_dict", "response": "Send the webhook method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nverifying that the signature is correct.", "response": "def verifySignature(self, signatureKey):\n        \"\"\"\n        :type signatureKey: ECPublicKey\n        \"\"\"\n        try:\n            parts = ByteUtil.split(self.serialized,\n                                   len(self.serialized) - self.__class__.SIGNATURE_LENGTH,\n                                   self.__class__.SIGNATURE_LENGTH)\n\n            if not Curve.verifySignature(signatureKey, parts[0], parts[1]):\n                raise InvalidMessageException(\"Invalid signature!\")\n        except InvalidKeyException as e:\n            raise InvalidMessageException(e)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getSignature(self, signatureKey, serialized):\n        try:\n            return Curve.calculateSignature(signatureKey, serialized)\n        except InvalidKeyException as e:\n            raise AssertionError(e)", "response": "Calculates the signature of the passed in serialized data."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses the prekey whisper message.", "response": "def process(self, sessionRecord, message):\n        \"\"\"\n        :param sessionRecord:\n        :param message:\n        :type message: PreKeyWhisperMessage\n        \"\"\"\n\n        messageVersion = message.getMessageVersion()\n        theirIdentityKey = message.getIdentityKey()\n\n        unsignedPreKeyId = None\n\n        if not self.identityKeyStore.isTrustedIdentity(self.recipientId, theirIdentityKey):\n            raise UntrustedIdentityException(self.recipientId, theirIdentityKey)\n\n        if messageVersion == 2:\n            unsignedPreKeyId = self.processV2(sessionRecord, message)\n        elif messageVersion == 3:\n            unsignedPreKeyId = self.processV3(sessionRecord, message)\n        else:\n            raise AssertionError(\"Unkown version %s\" % messageVersion)\n\n        self.identityKeyStore.saveIdentity(self.recipientId, theirIdentityKey)\n\n        return unsignedPreKeyId"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef processV2(self, sessionRecord, message):\n\n        if message.getPreKeyId() is None:\n            raise InvalidKeyIdException(\"V2 message requires one time prekey id!\")\n\n        if not self.preKeyStore.containsPreKey(message.getPreKeyId()) and \\\n                self.sessionStore.containsSession(self.recipientId, self.deviceId):\n            logging.warn(\"We've already processed the prekey part of this V2 session, \"\n                         \"letting bundled message fall through...\")\n            return None\n\n        ourPreKey = self.preKeyStore.loadPreKey(message.getPreKeyId()).getKeyPair()\n\n        parameters = BobAxolotlParameters.newBuilder()\n\n        parameters.setOurIdentityKey(self.identityKeyStore.getIdentityKeyPair())\\\n            .setOurSignedPreKey(ourPreKey)\\\n            .setOurRatchetKey(ourPreKey)\\\n            .setOurOneTimePreKey(None)\\\n            .setTheirIdentityKey(message.getIdentityKey())\\\n            .setTheirBaseKey(message.getBaseKey())\n\n        if not sessionRecord.isFresh():\n            sessionRecord.archiveCurrentState()\n\n        RatchetingSession.initializeSessionAsBob(sessionRecord.getSessionState(),\n                                                 message.getMessageVersion(),\n                                                 parameters.create())\n\n        sessionRecord.getSessionState().setLocalRegistrationId(self.identityKeyStore.getLocalRegistrationId())\n        sessionRecord.getSessionState().setRemoteRegistrationId(message.getRegistrationId())\n        sessionRecord.getSessionState().setAliceBaseKey(message.getBaseKey().serialize())\n\n        if message.getPreKeyId() != Medium.MAX_VALUE:\n            return message.getPreKeyId()\n        else:\n            return None", "response": "Process a V2 message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef processV3(self, sessionRecord, message):\n\n        if sessionRecord.hasSessionState(message.getMessageVersion(), message.getBaseKey().serialize()):\n            logger.warn(\"We've already setup a session for this V3 message, letting bundled message fall through...\")\n            return None\n\n        ourSignedPreKey = self.signedPreKeyStore.loadSignedPreKey(message.getSignedPreKeyId()).getKeyPair()\n        parameters = BobAxolotlParameters.newBuilder()\n        parameters.setTheirBaseKey(message.getBaseKey())\\\n            .setTheirIdentityKey(message.getIdentityKey())\\\n            .setOurIdentityKey(self.identityKeyStore.getIdentityKeyPair())\\\n            .setOurSignedPreKey(ourSignedPreKey)\\\n            .setOurRatchetKey(ourSignedPreKey)\n\n        if message.getPreKeyId() is not None:\n            parameters.setOurOneTimePreKey(self.preKeyStore.loadPreKey(message.getPreKeyId()).getKeyPair())\n        else:\n            parameters.setOurOneTimePreKey(None)\n\n        if not sessionRecord.isFresh():\n            sessionRecord.archiveCurrentState()\n\n        RatchetingSession.initializeSessionAsBob(sessionRecord.getSessionState(),\n                                                 message.getMessageVersion(),\n                                                 parameters.create())\n        sessionRecord.getSessionState().setLocalRegistrationId(self.identityKeyStore.getLocalRegistrationId())\n        sessionRecord.getSessionState().setRemoteRegistrationId(message.getRegistrationId())\n        sessionRecord.getSessionState().setAliceBaseKey(message.getBaseKey().serialize())\n\n        if message.getPreKeyId() is not None and message.getPreKeyId() != Medium.MAX_VALUE:\n            return message.getPreKeyId()\n        else:\n            return None", "response": "Process a V3 message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef processPreKeyBundle(self, preKey):\n        if not self.identityKeyStore.isTrustedIdentity(self.recipientId, preKey.getIdentityKey()):\n            raise UntrustedIdentityException(self.recipientId, preKey.getIdentityKey())\n\n        if preKey.getSignedPreKey() is not None and\\\n            not Curve.verifySignature(preKey.getIdentityKey().getPublicKey(),\n                                      preKey.getSignedPreKey().serialize(),\n                                      preKey.getSignedPreKeySignature()):\n            raise InvalidKeyException(\"Invalid signature on device key!\")\n\n        if preKey.getSignedPreKey() is None and preKey.getPreKey() is None:\n            raise InvalidKeyException(\"Both signed and unsigned prekeys are absent!\")\n\n        supportsV3 = preKey.getSignedPreKey() is not None\n        sessionRecord = self.sessionStore.loadSession(self.recipientId, self.deviceId)\n        ourBaseKey = Curve.generateKeyPair()\n        theirSignedPreKey = preKey.getSignedPreKey() if supportsV3 else preKey.getPreKey()\n        theirOneTimePreKey = preKey.getPreKey()\n        theirOneTimePreKeyId = preKey.getPreKeyId() if theirOneTimePreKey is not None else None\n\n        parameters = AliceAxolotlParameters.newBuilder()\n\n        parameters.setOurBaseKey(ourBaseKey)\\\n            .setOurIdentityKey(self.identityKeyStore.getIdentityKeyPair())\\\n            .setTheirIdentityKey(preKey.getIdentityKey())\\\n            .setTheirSignedPreKey(theirSignedPreKey)\\\n            .setTheirRatchetKey(theirSignedPreKey)\\\n            .setTheirOneTimePreKey(theirOneTimePreKey if supportsV3 else None)\n\n        if not sessionRecord.isFresh():\n            sessionRecord.archiveCurrentState()\n\n        RatchetingSession.initializeSessionAsAlice(sessionRecord.getSessionState(),\n                                                   3 if supportsV3 else 2,\n                                                   parameters.create())\n\n        sessionRecord.getSessionState().setUnacknowledgedPreKeyMessage(theirOneTimePreKeyId,\n                                                                       preKey.getSignedPreKeyId(),\n                                                                       ourBaseKey.getPublicKey())\n        sessionRecord.getSessionState().setLocalRegistrationId(self.identityKeyStore.getLocalRegistrationId())\n        sessionRecord.getSessionState().setRemoteRegistrationId(preKey.getRegistrationId())\n        sessionRecord.getSessionState().setAliceBaseKey(ourBaseKey.getPublicKey().serialize())\n        self.sessionStore.storeSession(self.recipientId, self.deviceId, sessionRecord)\n        self.identityKeyStore.saveIdentity(self.recipientId, preKey.getIdentityKey())", "response": "Processes a prekey bundle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing a single sender key.", "response": "def process(self, senderKeyName, senderKeyDistributionMessage):\n        \"\"\"\n        :type senderKeyName: SenderKeyName\n        :type senderKeyDistributionMessage: SenderKeyDistributionMessage\n        \"\"\"\n        senderKeyRecord = self.senderKeyStore.loadSenderKey(senderKeyName)\n        senderKeyRecord.addSenderKeyState(senderKeyDistributionMessage.getId(),\n                                          senderKeyDistributionMessage.getIteration(),\n                                          senderKeyDistributionMessage.getChainKey(),\n                                          senderKeyDistributionMessage.getSignatureKey())\n        self.senderKeyStore.storeSenderKey(senderKeyName, senderKeyRecord)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new SenderKeyDistributionMessage for the specified senderKeyName.", "response": "def create(self, senderKeyName):\n        \"\"\"\n        :type senderKeyName: SenderKeyName\n        \"\"\"\n        try:\n            senderKeyRecord = self.senderKeyStore.loadSenderKey(senderKeyName);\n\n            if senderKeyRecord.isEmpty() :\n                senderKeyRecord.setSenderKeyState(KeyHelper.generateSenderKeyId(),\n                                                0,\n                                                KeyHelper.generateSenderKey(),\n                                                KeyHelper.generateSenderSigningKey());\n                self.senderKeyStore.storeSenderKey(senderKeyName, senderKeyRecord);\n\n            state = senderKeyRecord.getSenderKeyState();\n\n            return SenderKeyDistributionMessage(state.getKeyId(),\n                                                state.getSenderChainKey().getIteration(),\n                                                state.getSenderChainKey().getSeed(),\n                                                state.getSigningKeyPublic());\n        except (InvalidKeyException, InvalidKeyIdException) as e:\n            raise AssertionError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initializeSession(sessionState, sessionVersion, parameters):\n        if RatchetingSession.isAlice(parameters.getOurBaseKey().getPublicKey(), parameters.getTheirBaseKey()):\n            aliceParameters = AliceAxolotlParameters.newBuilder()\n            aliceParameters.setOurBaseKey(parameters.getOurBaseKey()) \\\n                .setOurIdentityKey(parameters.getOurIdentityKey()) \\\n                .setTheirRatchetKey(parameters.getTheirRatchetKey()) \\\n                .setTheirIdentityKey(parameters.getTheirIdentityKey()) \\\n                .setTheirSignedPreKey(parameters.getTheirBaseKey()) \\\n                .setTheirOneTimePreKey(None)\n            RatchetingSession.initializeSessionAsAlice(sessionState, sessionVersion, aliceParameters.create())\n        else:\n            bobParameters = BobAxolotlParameters.newBuilder()\n            bobParameters.setOurIdentityKey(parameters.getOurIdentityKey()) \\\n                .setOurRatchetKey(parameters.getOurRatchetKey()) \\\n                .setOurSignedPreKey(parameters.getOurBaseKey()) \\\n                .setOurOneTimePreKey(None) \\\n                .setTheirBaseKey(parameters.getTheirBaseKey()) \\\n                .setTheirIdentityKey(parameters.getTheirIdentityKey())\n            RatchetingSession.initializeSessionAsBob(sessionState, sessionVersion, bobParameters.create())", "response": "Initializes the session with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initializeSessionAsAlice(sessionState, sessionVersion, parameters):\n        sessionState.setSessionVersion(sessionVersion)\n        sessionState.setRemoteIdentityKey(parameters.getTheirIdentityKey())\n        sessionState.setLocalIdentityKey(parameters.getOurIdentityKey().getPublicKey())\n\n        sendingRatchetKey = Curve.generateKeyPair()\n        secrets = bytearray()\n\n        if sessionVersion >= 3:\n            secrets.extend(RatchetingSession.getDiscontinuityBytes())\n\n        secrets.extend(Curve.calculateAgreement(parameters.getTheirSignedPreKey(),\n                                                parameters.getOurIdentityKey().getPrivateKey()))\n        secrets.extend(Curve.calculateAgreement(parameters.getTheirIdentityKey().getPublicKey(),\n                                                parameters.getOurBaseKey().getPrivateKey()))\n        secrets.extend(Curve.calculateAgreement(parameters.getTheirSignedPreKey(),\n                                                parameters.getOurBaseKey().getPrivateKey()))\n\n        if sessionVersion >= 3 and parameters.getTheirOneTimePreKey() is not None:\n            secrets.extend(Curve.calculateAgreement(parameters.getTheirOneTimePreKey(),\n                                                    parameters.getOurBaseKey().getPrivateKey()))\n\n        derivedKeys = RatchetingSession.calculateDerivedKeys(sessionVersion, secrets)\n        sendingChain = derivedKeys.getRootKey().createChain(parameters.getTheirRatchetKey(), sendingRatchetKey)\n\n        sessionState.addReceiverChain(parameters.getTheirRatchetKey(), derivedKeys.getChainKey())\n        sessionState.setSenderChain(sendingRatchetKey, sendingChain[1])\n        sessionState.setRootKey(sendingChain[0])", "response": "Initializes the session as alice."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initializeSessionAsBob(sessionState, sessionVersion, parameters):\n        sessionState.setSessionVersion(sessionVersion)\n        sessionState.setRemoteIdentityKey(parameters.getTheirIdentityKey())\n        sessionState.setLocalIdentityKey(parameters.getOurIdentityKey().getPublicKey())\n\n        secrets = bytearray()\n\n        if sessionVersion >= 3:\n            secrets.extend(RatchetingSession.getDiscontinuityBytes())\n\n        secrets.extend(Curve.calculateAgreement(parameters.getTheirIdentityKey().getPublicKey(),\n                                                parameters.getOurSignedPreKey().getPrivateKey()))\n\n        secrets.extend(Curve.calculateAgreement(parameters.getTheirBaseKey(),\n                                                parameters.getOurIdentityKey().getPrivateKey()))\n        secrets.extend(Curve.calculateAgreement(parameters.getTheirBaseKey(),\n                                                parameters.getOurSignedPreKey().getPrivateKey()))\n\n        if sessionVersion >= 3 and parameters.getOurOneTimePreKey() is not None:\n            secrets.extend(Curve.calculateAgreement(parameters.getTheirBaseKey(),\n                                                    parameters.getOurOneTimePreKey().getPrivateKey()))\n\n        derivedKeys = RatchetingSession.calculateDerivedKeys(sessionVersion, secrets)\n        sessionState.setSenderChain(parameters.getOurRatchetKey(), derivedKeys.getChainKey())\n        sessionState.setRootKey(derivedKeys.getRootKey())", "response": "Initializes the session as a bare session."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a sender key state to the list of sender key states.", "response": "def addSenderKeyState(self, id, iteration, chainKey, signatureKey):\n        \"\"\"\n        :type id: int\n        :type iteration: int\n        :type chainKey: bytearray\n        :type signatureKey: ECPublicKey\n        \"\"\"\n        self.senderKeyStates.append(SenderKeyState(id, iteration, chainKey, signatureKey))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setSenderKeyState(self, id, iteration, chainKey, signatureKey):\n        del self.senderKeyStates[:]\n        self.senderKeyStates.append(SenderKeyState(id, iteration, chainKey, signatureKeyPair=signatureKey))", "response": "set the sender key state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decryptMsg(self, ciphertext, textMsg=True):\n\n        if not self.sessionStore.containsSession(self.recipientId, self.deviceId):\n            raise NoSessionException(\"No session for: %s, %s\" % (self.recipientId, self.deviceId))\n\n        sessionRecord = self.sessionStore.loadSession(self.recipientId, self.deviceId)\n        plaintext = self.decryptWithSessionRecord(sessionRecord, ciphertext)\n\n        self.sessionStore.storeSession(self.recipientId, self.deviceId, sessionRecord)\n\n        return plaintext", "response": ":type ciphertext: WhisperMessage\n        :type textMsg: Bool set this to False if you are decrypting bytes\n                       instead of string"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the ciphertext for the given version of the object.", "response": "def getCiphertext(self, version, messageKeys, plainText):\n        \"\"\"\n        :type version: int\n        :type messageKeys: MessageKeys\n        :type  plainText: bytearray\n        \"\"\"\n        cipher = None\n        if version >= 3:\n            cipher = self.getCipher(messageKeys.getCipherKey(), messageKeys.getIv())\n        else:\n            cipher = self.getCipher_v2(messageKeys.getCipherKey(), messageKeys.getCounter())\n\n        return cipher.encrypt(bytes(plainText))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the agreement of a public key and a private key.", "response": "def calculateAgreement(publicKey, privateKey):\n        \"\"\"\n        :type publicKey: ECPublicKey\n        :type privateKey: ECPrivateKey\n        \"\"\"\n        if publicKey.getType() != privateKey.getType():\n            raise InvalidKeyException(\"Public and private keys must be of the same type!\")\n\n        if publicKey.getType() == Curve.DJB_TYPE:\n            return _curve.calculateAgreement(privateKey.getPrivateKey(), publicKey.getPublicKey())\n        else:\n            raise InvalidKeyException(\"Unknown type: %s\" % publicKey.getType())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies the signature of a message.", "response": "def verifySignature(ecPublicSigningKey, message, signature):\n        \"\"\"\n        :type ecPublicSigningKey: ECPublicKey\n        :type message: bytearray\n        :type signature: bytearray\n        \"\"\"\n\n        if ecPublicSigningKey.getType() == Curve.DJB_TYPE:\n            result = _curve.verifySignature(ecPublicSigningKey.getPublicKey(), message, signature)\n            return result == 0\n        else:\n            raise InvalidKeyException(\"Unknown type: %s\" % ecPublicSigningKey.getType())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the signature of a message.", "response": "def calculateSignature(privateSigningKey, message):\n        \"\"\"\n        :type privateSigningKey: ECPrivateKey\n        :type  message: bytearray\n        \"\"\"\n        if privateSigningKey.getType() == Curve.DJB_TYPE:\n            rand = os.urandom(64)\n            res = _curve.calculateSignature(rand, privateSigningKey.getPrivateKey(), message)\n            return res\n        else:\n            raise InvalidKeyException(\"Unknown type: %s\" % privateSigningKey.getType())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nencrypt a message with the sender key", "response": "def encrypt(self, paddedPlaintext):\n        \"\"\"\n        :type paddedPlaintext: str\n        \"\"\"\n        # TODO: make this less ugly and python 2 and 3 compatible\n        # paddedMessage = bytearray(paddedMessage.encode() if (sys.version_info >= (3, 0) and not type(paddedMessage) in (bytes, bytearray)) or type(paddedMessage) is unicode else paddedMessage)\n        if (sys.version_info >= (3, 0) and\n                not type(paddedPlaintext) in (bytes, bytearray)) or type(paddedPlaintext) is unicode:\n            paddedPlaintext = bytearray(paddedPlaintext.encode())\n        else:\n            paddedPlaintext = bytearray(paddedPlaintext)\n        try:\n            record = self.senderKeyStore.loadSenderKey(self.senderKeyName)\n            senderKeyState = record.getSenderKeyState()\n            senderKey = senderKeyState.getSenderChainKey().getSenderMessageKey()\n            ciphertext = self.getCipherText(senderKey.getIv(), senderKey.getCipherKey(), paddedPlaintext)\n\n            senderKeyMessage = SenderKeyMessage(senderKeyState.getKeyId(),\n                                                senderKey.getIteration(),\n                                                ciphertext,\n                                                senderKeyState.getSigningKeyPrivate())\n\n            senderKeyState.setSenderChainKey(senderKeyState.getSenderChainKey().getNext())\n            self.senderKeyStore.storeSenderKey(self.senderKeyName, record)\n\n            return senderKeyMessage.serialize()\n        except InvalidKeyIdException as e:\n            raise NoSessionException(e)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decrypt(self, senderKeyMessageBytes):\n        try:\n            record = self.senderKeyStore.loadSenderKey(self.senderKeyName)\n            if record.isEmpty():\n                raise NoSessionException(\"No sender key for: %s\" % self.senderKeyName)\n            senderKeyMessage = SenderKeyMessage(serialized = bytes(senderKeyMessageBytes))\n            senderKeyState = record.getSenderKeyState(senderKeyMessage.getKeyId())\n\n            senderKeyMessage.verifySignature(senderKeyState.getSigningKeyPublic())\n\n            senderKey = self.getSenderKey(senderKeyState, senderKeyMessage.getIteration())\n\n            plaintext = self.getPlainText(senderKey.getIv(), senderKey.getCipherKey(), senderKeyMessage.getCipherText())\n\n            self.senderKeyStore.storeSenderKey(self.senderKeyName, record)\n\n            return plaintext\n        except (InvalidKeyException, InvalidKeyIdException) as e:\n            raise InvalidMessageException(e)", "response": "This method decrypts a byte array of senderKeyMessage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getPlainText(self, iv, key, ciphertext):\n        try:\n            cipher = AESCipher(key, iv)\n            plaintext = cipher.decrypt(ciphertext)\n            if sys.version_info >= (3, 0):\n                return plaintext.decode()\n            return plaintext\n        except Exception as e:\n            raise InvalidMessageException(e)", "response": "This method decrypts and returns the plaintext text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getCipherText(self, iv, key, plaintext):\n        cipher = AESCipher(key, iv)\n        return cipher.encrypt(bytes(plaintext))", "response": "getCipherText - Get the cipher text for the current session"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the pending key exchange for the current session.", "response": "def setPendingKeyExchange(self, sequence, ourBaseKey, ourRatchetKey, ourIdentityKey):\n        \"\"\"\n        :type sequence: int\n        :type ourBaseKey: ECKeyPair\n        :type ourRatchetKey: ECKeyPair\n        :type  ourIdentityKey: IdentityKeyPair\n        \"\"\"\n        structure = self.sessionStructure.PendingKeyExchange()\n        structure.sequence = sequence\n        structure.localBaseKey = ourBaseKey.getPublicKey().serialize()\n        structure.localBaseKeyPrivate = ourBaseKey.getPrivateKey().serialize()\n        structure.localRatchetKey = ourRatchetKey.getPublicKey().serialize()\n        structure.localRatchetKeyPrivate = ourRatchetKey.getPrivateKey().serialize()\n        structure.localIdentityKey = ourIdentityKey.getPublicKey().serialize()\n        structure.localIdentityKeyPrivate = ourIdentityKey.getPrivateKey().serialize()\n\n        self.sessionStructure.pendingKeyExchange.MergeFrom(structure)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setUnacknowledgedPreKeyMessage(self, preKeyId, signedPreKeyId, baseKey):\n        self.sessionStructure.pendingPreKey.signedPreKeyId = signedPreKeyId\n        self.sessionStructure.pendingPreKey.baseKey = baseKey.serialize()\n\n        if preKeyId is not None:\n            self.sessionStructure.pendingPreKey.preKeyId = preKeyId", "response": "Set the unacknowledged pre key message."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an identity key pair.", "response": "def generateIdentityKeyPair():\n        \"\"\"\n        Generate an identity key pair.  Clients should only do this once,\n        at install time.\n        @return the generated IdentityKeyPair.\n        \"\"\"\n        keyPair = Curve.generateKeyPair()\n        publicKey = IdentityKey(keyPair.getPublicKey())\n        serialized = '0a21056e8936e8367f768a7bba008ade7cf58407bdc7a6aae293e2c' \\\n                     'b7c06668dcd7d5e12205011524f0c15467100dd603e0d6020f4d293' \\\n                     'edfbcd82129b14a88791ac81365c'\n        serialized = binascii.unhexlify(serialized.encode())\n        identityKeyPair = IdentityKeyPair(publicKey, keyPair.getPrivateKey())\n        return identityKeyPair"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a list of PreKeys.", "response": "def generatePreKeys(start, count):\n        \"\"\"\n        Generate a list of PreKeys.  Clients should do this at install time, and\n        subsequently any time the list of PreKeys stored on the server runs low.\n\n        PreKey IDs are shorts, so they will eventually be repeated.  Clients should\n        store PreKeys in a circular buffer, so that they are repeated as infrequently\n        as possible.\n\n        @param start The starting PreKey ID, inclusive.\n        @param count The number of PreKeys to generate.\n        @return the list of generated PreKeyRecords.\n        \"\"\"\n        results = []\n        start -= 1\n        for i in range(0, count):\n            preKeyId = ((start + i) % (Medium.MAX_VALUE - 1)) + 1\n            results.append(PreKeyRecord(preKeyId, Curve.generateKeyPair()))\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of tuples for Enum", "response": "def choices(cls, blank=False):\n        \"\"\" Choices for Enum\n        :return: List of tuples (<value>, <human-readable value>)\n        :rtype: list\n        \"\"\"\n        choices = sorted([(key, value) for key, value in cls.values.items()], key=lambda x: x[0])\n        if blank:\n            choices.insert(0, ('', Enum.Value('', None, '', cls)))\n        return choices"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(cls, name_or_numeric):\n        if isinstance(name_or_numeric, six.string_types):\n            name_or_numeric = getattr(cls, name_or_numeric.upper())\n\n        return cls.values.get(name_or_numeric)", "response": "Get the value of the attribute name_or_numeric."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of tuples consisting of every enum value in the form [ NAME value... ]", "response": "def items(cls):\n        \"\"\"\n        :return: List of tuples consisting of every enum value in the form [('NAME', value), ...]\n        :rtype: list\n        \"\"\"\n        items = [(value.name, key) for key, value in cls.values.items()]\n        return sorted(items, key=lambda x: x[1])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if to_value is a valid transition from from_value. Returns True if it is a valid transition.", "response": "def is_valid_transition(cls, from_value, to_value):\n        \"\"\" Will check if to_value is a valid transition from from_value. Returns true if it is a valid transition.\n        :param from_value: Start transition point\n        :param to_value: End transition point\n        :type from_value: int\n        :type to_value: int\n        :return: Success flag\n        :rtype: bool\n        \"\"\"\n        try:\n            return from_value == to_value or from_value in cls.transition_origins(to_value)\n        except KeyError:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _setup_validation(self, sender, **kwargs):\n        att_name = self.get_attname()\n        private_att_name = '_enum_%s' % att_name\n        enum = self.enum\n\n        def set_enum(self, new_value):\n            if hasattr(self, private_att_name):\n                # Fetch previous value from private enum attribute.\n                old_value = getattr(self, private_att_name)\n            else:\n                # First setattr no previous value on instance.\n                old_value = new_value\n            # Update private enum attribute with new value\n            setattr(self, private_att_name, new_value)\n            self.__dict__[att_name] = new_value\n            # Run validation for new value.\n            validators.validate_valid_transition(enum, old_value, new_value)\n\n        def get_enum(self):\n            return getattr(self, private_att_name)\n\n        def delete_enum(self):\n            self.__dict__[att_name] = None\n            return setattr(self, private_att_name, None)\n\n        if not sender._meta.abstract:\n            setattr(sender, att_name, property(get_enum, set_enum, delete_enum))", "response": "Setup validation for the current value of the attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_valid_transition(enum, from_value, to_value):\n    validate_available_choice(enum, to_value)\n    if hasattr(enum, '_transitions') and not enum.is_valid_transition(from_value, to_value):\n        message = _(six.text_type('{enum} can not go from \"{from_value}\" to \"{to_value}\"'))\n        raise InvalidStatusOperationError(message.format(\n            enum=enum.__name__,\n            from_value=enum.name(from_value),\n            to_value=enum.name(to_value) or to_value\n        ))", "response": "Validate that from_value is a valid transition from to_value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_available_choice(enum, to_value):\n    if to_value is None:\n        return\n\n    if type(to_value) is not int:\n        try:\n            to_value = int(to_value)\n        except ValueError:\n            message_str = \"'{value}' cannot be converted to int\"\n            message = _(six.text_type(message_str))\n            raise InvalidStatusOperationError(message.format(value=to_value))\n\n    if to_value not in list(dict(enum.choices()).keys()):\n        message = _(six.text_type('Select a valid choice. {value} is not one of the available choices.'))\n        raise InvalidStatusOperationError(message.format(value=to_value))", "response": "Validate that to_value is defined as a value in enum."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a diff between running config and a proposed file.", "response": "def _get_diff(self, cp_file):\n        \"\"\"Get a diff between running config and a proposed file.\"\"\"\n        diff = []\n        self._create_sot_file()\n        diff_out = self.device.show(\n            'show diff rollback-patch file {0} file {1}'.format(\n                'sot_file', self.replace_file.split('/')[-1]), raw_text=True)\n        try:\n            diff_out = diff_out.split(\n                '#Generating Rollback Patch')[1].replace(\n                    'Rollback Patch is Empty', '').strip()\n            for line in diff_out.splitlines():\n                if line:\n                    if line[0].strip() != '!':\n                        diff.append(line.rstrip(' '))\n        except (AttributeError, KeyError):\n            raise ReplaceConfigException(\n                'Could not calculate diff. It\\'s possible the given file doesn\\'t exist.')\n        return '\\n'.join(diff)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the current running config to the given file.", "response": "def _save_config(self, filename):\n        \"\"\"Save the current running config to the given file.\"\"\"\n        self.device.show('checkpoint file {}'.format(filename), raw_text=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nopen the connection wit the device.", "response": "def open(self):\n        \"\"\"Open the connection wit the device.\"\"\"\n        try:\n            self.device.open()\n        except ConnectTimeoutError as cte:\n            raise ConnectionException(cte.message)\n        self.device.timeout = self.timeout\n        self.device._conn._session.transport.set_keepalive(self.keepalive)\n        if hasattr(self.device, \"cu\"):\n            # make sure to remove the cu attr from previous session\n            # ValueError: requested attribute name cu already exists\n            del self.device.cu\n        self.device.bind(cu=Config)\n        if self.config_lock:\n            self._lock()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlock the config DB.", "response": "def _lock(self):\n        \"\"\"Lock the config DB.\"\"\"\n        if not self.locked:\n            self.device.cu.lock()\n            self.locked = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunlock the config DB.", "response": "def _unlock(self):\n        \"\"\"Unlock the config DB.\"\"\"\n        if self.locked:\n            self.device.cu.unlock()\n            self.locked = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compare_config(self):\n        diff = self.device.cu.diff()\n\n        if diff is None:\n            return ''\n        else:\n            return diff.strip()", "response": "Compare candidate config with running."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef discard_config(self):\n        self.device.cu.rollback(rb_id=0)\n        if not self.config_lock:\n            self._unlock()", "response": "Discard changes from the device."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_facts(self):\n        output = self.device.facts\n\n        uptime = self.device.uptime or -1\n\n        interfaces = junos_views.junos_iface_table(self.device)\n        interfaces.get()\n        interface_list = interfaces.keys()\n\n        return {\n            'vendor': u'Juniper',\n            'model': py23_compat.text_type(output['model']),\n            'serial_number': py23_compat.text_type(output['serialnumber']),\n            'os_version': py23_compat.text_type(output['version']),\n            'hostname': py23_compat.text_type(output['hostname']),\n            'fqdn': py23_compat.text_type(output['fqdn']),\n            'uptime': uptime,\n            'interface_list': interface_list\n        }", "response": "Return the facts of the device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the details of all the interfaces in the device.", "response": "def get_interfaces(self):\n        \"\"\"Return interfaces details.\"\"\"\n        result = {}\n\n        interfaces = junos_views.junos_iface_table(self.device)\n        interfaces.get()\n\n        # convert all the tuples to our pre-defined dict structure\n        for iface in interfaces.keys():\n            result[iface] = {\n                'is_up': interfaces[iface]['is_up'],\n                'is_enabled': interfaces[iface]['is_enabled'],\n                'description': (interfaces[iface]['description'] or u''),\n                'last_flapped': float((interfaces[iface]['last_flapped'] or -1)),\n                'mac_address': napalm_base.helpers.convert(\n                    napalm_base.helpers.mac,\n                    interfaces[iface]['mac_address'],\n                    py23_compat.text_type(interfaces[iface]['mac_address'])),\n                'speed': -1\n            }\n            # result[iface]['last_flapped'] = float(result[iface]['last_flapped'])\n\n            match = re.search(r'(\\d+)(\\w*)', interfaces[iface]['speed'] or u'')\n            if match is None:\n                continue\n            speed_value = napalm_base.helpers.convert(int, match.group(1), -1)\n            if speed_value == -1:\n                continue\n            speed_unit = match.group(2)\n            if speed_unit.lower() == 'gbps':\n                speed_value *= 1000\n            result[iface]['speed'] = speed_value\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction to derive the address family from a junos routing table name.", "response": "def _get_address_family(table):\n        \"\"\"\n        Function to derive address family from a junos table name.\n\n        :params table: The name of the routing table\n        :returns: address family\n        \"\"\"\n        address_family_mapping = {\n            'inet': 'ipv4',\n            'inet6': 'ipv6',\n            'inetflow': 'flow'\n        }\n        family = table.split('.')[-2]\n        try:\n            address_family = address_family_mapping[family]\n        except KeyError:\n            address_family = family\n        return address_family"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_bgp_neighbors(self):\n        bgp_neighbor_data = {}\n        default_neighbor_details = {\n            'local_as': 0,\n            'remote_as': 0,\n            'remote_id': '',\n            'is_up': False,\n            'is_enabled': False,\n            'description': '',\n            'uptime': 0,\n            'address_family': {}\n        }\n        keys = default_neighbor_details.keys()\n\n        uptime_table = junos_views.junos_bgp_uptime_table(self.device)\n        bgp_neighbors_table = junos_views.junos_bgp_table(self.device)\n\n        uptime_table_lookup = {}\n\n        def _get_uptime_table(instance):\n            if instance not in uptime_table_lookup:\n                uptime_table_lookup[instance] = uptime_table.get(instance=instance).items()\n            return uptime_table_lookup[instance]\n\n        def _get_bgp_neighbors_core(neighbor_data, instance=None, uptime_table_items=None):\n            '''\n            Make sure to execute a simple request whenever using\n            junos > 13. This is a helper used to avoid code redundancy\n            and reuse the function also when iterating through the list\n            BGP neighbors under a specific routing instance,\n            also when the device is capable to return the routing\n            instance name at the BGP neighbor level.\n            '''\n            for bgp_neighbor in neighbor_data:\n                peer_ip = napalm_base.helpers.ip(bgp_neighbor[0].split('+')[0])\n                neighbor_details = deepcopy(default_neighbor_details)\n                neighbor_details.update(\n                    {elem[0]: elem[1] for elem in bgp_neighbor[1] if elem[1] is not None}\n                )\n                if not instance:\n                    # not instance, means newer Junos version,\n                    # as we request everything in a single request\n                    peer_fwd_rti = neighbor_details.pop('peer_fwd_rti')\n                    instance = peer_fwd_rti\n                else:\n                    # instance is explicitly requests,\n                    # thus it's an old Junos, so we retrieve the BGP neighbors\n                    # under a certain routing instance\n                    peer_fwd_rti = neighbor_details.pop('peer_fwd_rti', '')\n                instance_name = 'global' if instance == 'master' else instance\n                if instance_name not in bgp_neighbor_data:\n                    bgp_neighbor_data[instance_name] = {}\n                if 'router_id' not in bgp_neighbor_data[instance_name]:\n                    # we only need to set this once\n                    bgp_neighbor_data[instance_name]['router_id'] = \\\n                        py23_compat.text_type(neighbor_details.get('local_id', ''))\n                peer = {\n                    key: self._parse_value(value)\n                    for key, value in neighbor_details.items()\n                    if key in keys\n                }\n                peer['local_as'] = napalm_base.helpers.as_number(peer['local_as'])\n                peer['remote_as'] = napalm_base.helpers.as_number(peer['remote_as'])\n                peer['address_family'] = self._parse_route_stats(neighbor_details)\n                if 'peers' not in bgp_neighbor_data[instance_name]:\n                    bgp_neighbor_data[instance_name]['peers'] = {}\n                bgp_neighbor_data[instance_name]['peers'][peer_ip] = peer\n                if not uptime_table_items:\n                    uptime_table_items = _get_uptime_table(instance)\n                for neighbor, uptime in uptime_table_items:\n                    if neighbor not in bgp_neighbor_data[instance_name]['peers']:\n                        bgp_neighbor_data[instance_name]['peers'][neighbor] = {}\n                    bgp_neighbor_data[instance_name]['peers'][neighbor]['uptime'] = uptime[0][1]\n\n        # Commenting out the following sections, till Junos\n        #   will provide a way to identify the routing instance name\n        #   from the details of the BGP neighbor\n        #   currently, there are Junos 15 version having a field called `peer_fwd_rti`\n        #   but unfortunately, this is not consistent.\n        # Junos 17 might have this fixed, but this needs to be revisited later.\n        # In the definition below, `old_junos` means a version that does not provide\n        #   the forwarding RTI information.\n        #\n        # old_junos = napalm_base.helpers.convert(\n        #     int, self.device.facts.get('version', '0.0').split('.')[0], 0) < 15\n\n        # if old_junos:\n        instances = junos_views.junos_route_instance_table(self.device).get()\n        for instance, instance_data in instances.items():\n            if instance.startswith('__'):\n                # junos internal instances\n                continue\n            bgp_neighbor_data[instance] = {'peers': {}}\n            instance_neighbors = bgp_neighbors_table.get(instance=instance).items()\n            uptime_table_items = uptime_table.get(instance=instance).items()\n            _get_bgp_neighbors_core(instance_neighbors,\n                                    instance=instance,\n                                    uptime_table_items=uptime_table_items)\n        # If the OS provides the `peer_fwd_rti` or any way to identify the\n        #   rotuing instance name (see above), the performances of this getter\n        #   can be significantly improved, as we won't execute one request\n        #   for each an every RT.\n        # However, this improvement would only be beneficial for multi-VRF envs.\n        #\n        # else:\n        #     instance_neighbors = bgp_neighbors_table.get().items()\n        #     _get_bgp_neighbors_core(instance_neighbors)\n        bgp_tmp_dict = {}\n        for k, v in bgp_neighbor_data.items():\n            if bgp_neighbor_data[k]['peers']:\n                bgp_tmp_dict[k] = v\n        return bgp_tmp_dict", "response": "Return BGP neighbors details."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lldp_neighbors(self):\n        lldp = junos_views.junos_lldp_table(self.device)\n        try:\n            lldp.get()\n        except RpcError as rpcerr:\n            # this assumes the library runs in an environment\n            # able to handle logs\n            # otherwise, the user just won't see this happening\n            log.error('Unable to retrieve the LLDP neighbors information:')\n            log.error(rpcerr.message)\n            return {}\n        result = lldp.items()\n\n        neighbors = {}\n        for neigh in result:\n            if neigh[0] not in neighbors.keys():\n                neighbors[neigh[0]] = []\n            neighbors[neigh[0]].append({x[0]: py23_compat.text_type(x[1]) for x in neigh[1]})\n\n        return neighbors", "response": "Return LLDP neighbors details."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetailing view of the LLDP neighbors.", "response": "def get_lldp_neighbors_detail(self, interface=''):\n        \"\"\"Detailed view of the LLDP neighbors.\"\"\"\n        lldp_neighbors = {}\n\n        lldp_table = junos_views.junos_lldp_neighbors_detail_table(self.device)\n        try:\n            lldp_table.get()\n        except RpcError as rpcerr:\n            # this assumes the library runs in an environment\n            # able to handle logs\n            # otherwise, the user just won't see this happening\n            log.error('Unable to retrieve the LLDP neighbors information:')\n            log.error(rpcerr.message)\n            return {}\n        interfaces = lldp_table.get().keys()\n\n        # get lldp neighbor by interface rpc for EX Series, QFX Series, J Series\n        # and SRX Series is get-lldp-interface-neighbors-information,\n        # and rpc for M, MX, and T Series is get-lldp-interface-neighbors\n        # ref1: https://apps.juniper.net/xmlapi/operTags.jsp  (Junos 13.1 and later)\n        # ref2: https://www.juniper.net/documentation/en_US/junos12.3/information-products/topic-collections/junos-xml-ref-oper/index.html  (Junos 12.3) # noqa\n        lldp_table.GET_RPC = 'get-lldp-interface-neighbors'\n        if self.device.facts.get('personality') not in ('MX', 'M', 'T'):\n            lldp_table.GET_RPC = 'get-lldp-interface-neighbors-information'\n\n        for interface in interfaces:\n            if self.device.facts.get('personality') not in ('MX', 'M', 'T'):\n                lldp_table.get(interface_name=interface)\n            else:\n                lldp_table.get(interface_device=interface)\n            for item in lldp_table:\n                if interface not in lldp_neighbors.keys():\n                    lldp_neighbors[interface] = []\n                lldp_neighbors[interface].append({\n                    'parent_interface': item.parent_interface,\n                    'remote_port': item.remote_port,\n                    'remote_chassis_id': napalm_base.helpers.convert(\n                        napalm_base.helpers.mac, item.remote_chassis_id, item.remote_chassis_id),\n                    'remote_port_description': napalm_base.helpers.convert(\n                        py23_compat.text_type, item.remote_port_description),\n                    'remote_system_name': item.remote_system_name,\n                    'remote_system_description': item.remote_system_description,\n                    'remote_system_capab': item.remote_system_capab,\n                    'remote_system_enable_capab': item.remote_system_enable_capab\n                })\n\n        return lldp_neighbors"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_arp_table(self):\n        # could use ArpTable\n        # from jnpr.junos.op.phyport import ArpTable\n        # and simply use it\n        # but\n        # we need:\n        #   - filters\n        #   - group by VLAN ID\n        #   - hostname & TTE fields as well\n\n        arp_table = []\n\n        arp_table_raw = junos_views.junos_arp_table(self.device)\n        arp_table_raw.get()\n        arp_table_items = arp_table_raw.items()\n\n        for arp_table_entry in arp_table_items:\n            arp_entry = {\n                elem[0]: elem[1] for elem in arp_table_entry[1]\n            }\n            arp_entry['mac'] = napalm_base.helpers.mac(arp_entry.get('mac'))\n            arp_entry['ip'] = napalm_base.helpers.ip(arp_entry.get('ip'))\n            arp_table.append(arp_entry)\n\n        return arp_table", "response": "Return the ARP table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the NTP peers configured on the device.", "response": "def get_ntp_peers(self):\n        \"\"\"Return the NTP peers configured on the device.\"\"\"\n        ntp_table = junos_views.junos_ntp_peers_config_table(self.device)\n        ntp_table.get()\n\n        ntp_peers = ntp_table.items()\n\n        if not ntp_peers:\n            return {}\n\n        return {napalm_base.helpers.ip(peer[0]): {} for peer in ntp_peers}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the NTP servers configured on the device.", "response": "def get_ntp_servers(self):\n        \"\"\"Return the NTP servers configured on the device.\"\"\"\n        ntp_table = junos_views.junos_ntp_servers_config_table(self.device)\n        ntp_table.get()\n\n        ntp_servers = ntp_table.items()\n\n        if not ntp_servers:\n            return {}\n\n        return {napalm_base.helpers.ip(server[0]): {} for server in ntp_servers}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn NTP stats (associations).", "response": "def get_ntp_stats(self):\n        \"\"\"Return NTP stats (associations).\"\"\"\n        # NTP Peers does not have XML RPC defined\n        # thus we need to retrieve raw text and parse...\n        # :(\n\n        ntp_stats = []\n\n        REGEX = (\n            '^\\s?(\\+|\\*|x|-)?([a-zA-Z0-9\\.+-:]+)'\n            '\\s+([a-zA-Z0-9\\.]+)\\s+([0-9]{1,2})'\n            '\\s+(-|u)\\s+([0-9h-]+)\\s+([0-9]+)'\n            '\\s+([0-9]+)\\s+([0-9\\.]+)\\s+([0-9\\.-]+)'\n            '\\s+([0-9\\.]+)\\s?$'\n        )\n\n        ntp_assoc_output = self.device.cli('show ntp associations no-resolve')\n        ntp_assoc_output_lines = ntp_assoc_output.splitlines()\n\n        for ntp_assoc_output_line in ntp_assoc_output_lines[3:]:  # except last line\n            line_search = re.search(REGEX, ntp_assoc_output_line, re.I)\n            if not line_search:\n                continue  # pattern not found\n            line_groups = line_search.groups()\n            try:\n                ntp_stats.append({\n                    'remote': napalm_base.helpers.ip(line_groups[1]),\n                    'synchronized': (line_groups[0] == '*'),\n                    'referenceid': py23_compat.text_type(line_groups[2]),\n                    'stratum': int(line_groups[3]),\n                    'type': py23_compat.text_type(line_groups[4]),\n                    'when': py23_compat.text_type(line_groups[5]),\n                    'hostpoll': int(line_groups[6]),\n                    'reachability': int(line_groups[7]),\n                    'delay': float(line_groups[8]),\n                    'offset': float(line_groups[9]),\n                    'jitter': float(line_groups[10])\n                })\n            except Exception:\n                continue  # jump to next line\n\n        return ntp_stats"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the MAC address table.", "response": "def get_mac_address_table(self):\n        \"\"\"Return the MAC address table.\"\"\"\n        mac_address_table = []\n\n        if self.device.facts.get('personality', '') in ['SWITCH']:  # for EX & QFX devices\n            if self.device.facts.get('switch_style', '') in ['VLAN_L2NG']:  # for L2NG devices\n                mac_table = junos_views.junos_mac_address_table_switch_l2ng(self.device)\n            else:\n                mac_table = junos_views.junos_mac_address_table_switch(self.device)\n        else:\n            mac_table = junos_views.junos_mac_address_table(self.device)\n\n        mac_table.get()\n        mac_table_items = mac_table.items()\n\n        default_values = {\n            'mac': u'',\n            'interface': u'',\n            'vlan': 0,\n            'static': False,\n            'active': True,\n            'moves': 0,\n            'last_move': 0.0\n        }\n\n        for mac_table_entry in mac_table_items:\n            mac_entry = default_values.copy()\n            mac_entry.update(\n                {elem[0]: elem[1] for elem in mac_table_entry[1]}\n            )\n            mac = mac_entry.get('mac')\n\n            # JUNOS returns '*' for Type = Flood\n            if mac == '*':\n                continue\n\n            mac_entry['mac'] = napalm_base.helpers.mac(mac)\n            mac_address_table.append(mac_entry)\n\n        return mac_address_table"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_probes_config(self):\n        probes = {}\n\n        probes_table = junos_views.junos_rpm_probes_config_table(self.device)\n        probes_table.get()\n        probes_table_items = probes_table.items()\n\n        for probe_test in probes_table_items:\n            test_name = py23_compat.text_type(probe_test[0])\n            test_details = {\n                p[0]: p[1] for p in probe_test[1]\n            }\n            probe_name = napalm_base.helpers.convert(\n                py23_compat.text_type, test_details.pop('probe_name'))\n            target = napalm_base.helpers.convert(\n                py23_compat.text_type, test_details.pop('target', ''))\n            test_interval = napalm_base.helpers.convert(int, test_details.pop('test_interval', '0'))\n            probe_count = napalm_base.helpers.convert(int, test_details.pop('probe_count', '0'))\n            probe_type = napalm_base.helpers.convert(\n                py23_compat.text_type, test_details.pop('probe_type', ''))\n            source = napalm_base.helpers.convert(\n                py23_compat.text_type, test_details.pop('source_address', ''))\n            if probe_name not in probes.keys():\n                probes[probe_name] = {}\n            probes[probe_name][test_name] = {\n                'probe_type': probe_type,\n                'target': target,\n                'source': source,\n                'probe_count': probe_count,\n                'test_interval': test_interval\n            }\n\n        return probes", "response": "Return the configuration of the RPM probes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the results of the RPM probes.", "response": "def get_probes_results(self):\n        \"\"\"Return the results of the RPM probes.\"\"\"\n        probes_results = {}\n\n        probes_results_table = junos_views.junos_rpm_probes_results_table(self.device)\n        probes_results_table.get()\n        probes_results_items = probes_results_table.items()\n\n        for probe_result in probes_results_items:\n            probe_name = py23_compat.text_type(probe_result[0])\n            test_results = {\n                p[0]: p[1] for p in probe_result[1]\n            }\n            test_results['last_test_loss'] = napalm_base.helpers.convert(\n                int, test_results.pop('last_test_loss'), 0)\n            for test_param_name, test_param_value in test_results.items():\n                if isinstance(test_param_value, float):\n                    test_results[test_param_name] = test_param_value * 1e-3\n                    # convert from useconds to mseconds\n            test_name = test_results.pop('test_name', '')\n            source = test_results.get('source', u'')\n            if source is None:\n                test_results['source'] = u''\n            if probe_name not in probes_results.keys():\n                probes_results[probe_name] = {}\n            probes_results[probe_name][test_name] = test_results\n\n        return probes_results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef traceroute(self,\n                   destination,\n                   source=C.TRACEROUTE_SOURCE,\n                   ttl=C.TRACEROUTE_TTL,\n                   timeout=C.TRACEROUTE_TIMEOUT,\n                   vrf=C.TRACEROUTE_VRF):\n        \"\"\"Execute traceroute and return results.\"\"\"\n        traceroute_result = {}\n\n        # calling form RPC does not work properly :(\n        # but defined junos_route_instance_table just in case\n\n        source_str = ''\n        maxttl_str = ''\n        wait_str = ''\n        vrf_str = ''\n\n        if source:\n            source_str = ' source {source}'.format(source=source)\n        if ttl:\n            maxttl_str = ' ttl {ttl}'.format(ttl=ttl)\n        if timeout:\n            wait_str = ' wait {timeout}'.format(timeout=timeout)\n        if vrf:\n            vrf_str = ' routing-instance {vrf}'.format(vrf=vrf)\n\n        traceroute_command = 'traceroute {destination}{source}{maxttl}{wait}{vrf}'.format(\n            destination=destination,\n            source=source_str,\n            maxttl=maxttl_str,\n            wait=wait_str,\n            vrf=vrf_str\n        )\n\n        traceroute_rpc = E('command', traceroute_command)\n        rpc_reply = self.device._conn.rpc(traceroute_rpc)._NCElement__doc\n        # make direct RPC call via NETCONF\n        traceroute_results = rpc_reply.find('.//traceroute-results')\n\n        traceroute_failure = napalm_base.helpers.find_txt(\n            traceroute_results, 'traceroute-failure', '')\n        error_message = napalm_base.helpers.find_txt(\n            traceroute_results, 'rpc-error/error-message', '')\n\n        if traceroute_failure and error_message:\n            return {'error': '{}: {}'.format(traceroute_failure, error_message)}\n\n        traceroute_result['success'] = {}\n        for hop in traceroute_results.findall('hop'):\n            ttl_value = napalm_base.helpers.convert(\n                int, napalm_base.helpers.find_txt(hop, 'ttl-value'), 1)\n            if ttl_value not in traceroute_result['success']:\n                traceroute_result['success'][ttl_value] = {'probes': {}}\n            for probe in hop.findall('probe-result'):\n                probe_index = napalm_base.helpers.convert(\n                    int, napalm_base.helpers.find_txt(probe, 'probe-index'), 0)\n                ip_address = napalm_base.helpers.convert(\n                    napalm_base.helpers.ip, napalm_base.helpers.find_txt(probe, 'ip-address'), '*')\n                host_name = py23_compat.text_type(\n                    napalm_base.helpers.find_txt(probe, 'host-name', '*'))\n                rtt = napalm_base.helpers.convert(\n                    float, napalm_base.helpers.find_txt(probe, 'rtt'), 0) * 1e-3  # ms\n                traceroute_result['success'][ttl_value]['probes'][probe_index] = {\n                    'ip_address': ip_address,\n                    'host_name': host_name,\n                    'rtt': rtt\n                }\n\n        return traceroute_result", "response": "Execute a traceroute and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a single entry from show interfaces output.", "response": "def parse_intf_section(interface):\n    \"\"\"Parse a single entry from show interfaces output.\n\n    Different cases:\n    mgmt0 is up\n    admin state is up\n\n    Ethernet2/1 is up\n    admin state is up, Dedicated Interface\n\n    Vlan1 is down (Administratively down), line protocol is down, autostate enabled\n\n    Ethernet154/1/48 is up (with no 'admin state')\n    \"\"\"\n    interface = interface.strip()\n    re_protocol = r\"^(?P<intf_name>\\S+?)\\s+is\\s+(?P<status>.+?)\" \\\n                  r\",\\s+line\\s+protocol\\s+is\\s+(?P<protocol>\\S+).*$\"\n    re_intf_name_state = r\"^(?P<intf_name>\\S+) is (?P<intf_state>\\S+).*\"\n    re_is_enabled_1 = r\"^admin state is (?P<is_enabled>\\S+)$\"\n    re_is_enabled_2 = r\"^admin state is (?P<is_enabled>\\S+), \"\n    re_is_enabled_3 = r\"^.* is down.*Administratively down.*$\"\n    re_mac = r\"^\\s+Hardware.*address:\\s+(?P<mac_address>\\S+) \"\n    re_speed = r\"^\\s+MTU .*, BW (?P<speed>\\S+) (?P<speed_unit>\\S+), \"\n    re_description = r\"^\\s+Description:\\s+(?P<description>.*)$\"\n\n    # Check for 'protocol is ' lines\n    match = re.search(re_protocol, interface, flags=re.M)\n    if match:\n        intf_name = match.group('intf_name')\n        status = match.group('status')\n        protocol = match.group('protocol')\n\n        if 'admin' in status.lower():\n            is_enabled = False\n        else:\n            is_enabled = True\n        is_up = bool('up' in protocol)\n\n    else:\n        # More standard is up, next line admin state is lines\n        match = re.search(re_intf_name_state, interface)\n        intf_name = match.group('intf_name')\n        intf_state = match.group('intf_state').strip()\n        is_up = True if intf_state == 'up' else False\n\n        admin_state_present = re.search(\"admin state is\", interface)\n        if admin_state_present:\n            # Parse cases where 'admin state' string exists\n            for x_pattern in [re_is_enabled_1, re_is_enabled_2]:\n                match = re.search(x_pattern, interface, flags=re.M)\n                if match:\n                    is_enabled = match.group('is_enabled').strip()\n                    is_enabled = True if is_enabled == 'up' else False\n                    break\n            else:\n                msg = \"Error parsing intf, 'admin state' never detected:\\n\\n{}\".format(interface)\n                raise ValueError(msg)\n        else:\n            # No 'admin state' should be 'is up' or 'is down' strings\n            # If interface is up; it is enabled\n            is_enabled = True\n            if not is_up:\n                match = re.search(re_is_enabled_3, interface, flags=re.M)\n                if match:\n                    is_enabled = False\n\n    match = re.search(re_mac, interface, flags=re.M)\n    if match:\n        mac_address = match.group('mac_address')\n        mac_address = napalm_base.helpers.mac(mac_address)\n    else:\n        mac_address = \"\"\n\n    match = re.search(re_speed, interface, flags=re.M)\n    speed = int(match.group('speed'))\n    speed_unit = match.group('speed_unit')\n    # This was alway in Kbit (in the data I saw)\n    if speed_unit != \"Kbit\":\n        msg = \"Unexpected speed unit in show interfaces parsing:\\n\\n{}\".format(interface)\n        raise ValueError(msg)\n    speed = int(round(speed / 1000.0))\n\n    description = ''\n    match = re.search(re_description, interface, flags=re.M)\n    if match:\n        description = match.group('description')\n\n    return {\n             intf_name: {\n                    'description': description,\n                    'is_enabled': is_enabled,\n                    'is_up': is_up,\n                    'last_flapped': -1.0,\n                    'mac_address': mac_address,\n                    'speed': speed}\n           }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_diff(self):\n        diff = []\n        self._create_sot_file()\n        command = ('show diff rollback-patch file {0} file {1}'.format(\n                   'sot_file', self.replace_file.split('/')[-1]))\n        diff_out = self.device.send_command(command)\n        try:\n            diff_out = diff_out.split(\n                '#Generating Rollback Patch')[1].replace(\n                    'Rollback Patch is Empty', '').strip()\n            for line in diff_out.splitlines():\n                if line:\n                    if line[0].strip() != '!' and line[0].strip() != '.':\n                        diff.append(line.rstrip(' '))\n        except (AttributeError, KeyError):\n            raise ReplaceConfigException(\n                'Could not calculate diff. It\\'s possible the given file doesn\\'t exist.')\n        return '\\n'.join(diff)", "response": "Get a diff between running config and a proposed file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _save_to_checkpoint(self, filename):\n        command = 'checkpoint file {}'.format(filename)\n        self.device.send_command(command)", "response": "Save the current running config to the given file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a set of facts from the devices.", "response": "def get_facts(self):\n        \"\"\"Return a set of facts from the devices.\"\"\"\n        # default values.\n        vendor = u'Cisco'\n        uptime = -1\n        serial_number, fqdn, os_version, hostname, domain_name = ('',) * 5\n\n        # obtain output from device\n        show_ver = self.device.send_command('show version')\n        show_hosts = self.device.send_command('show hosts')\n        show_int_status = self.device.send_command('show interface status')\n        show_hostname = self.device.send_command('show hostname')\n\n        # uptime/serial_number/IOS version\n        for line in show_ver.splitlines():\n            if ' uptime is ' in line:\n                _, uptime_str = line.split(' uptime is ')\n                uptime = self.parse_uptime(uptime_str)\n\n            if 'Processor Board ID' in line:\n                _, serial_number = line.split(\"Processor Board ID \")\n                serial_number = serial_number.strip()\n\n            if 'system: ' in line:\n                line = line.strip()\n                os_version = line.split()[2]\n                os_version = os_version.strip()\n\n            if 'cisco' in line and 'Chassis' in line:\n                _, model = line.split()[:2]\n                model = model.strip()\n\n        hostname = show_hostname.strip()\n\n        # Determine domain_name and fqdn\n        for line in show_hosts.splitlines():\n            if 'Default domain' in line:\n                _, domain_name = re.split(r\".*Default domain.*is \", line)\n                domain_name = domain_name.strip()\n                break\n        if hostname.count(\".\") >= 2:\n            fqdn = hostname\n        elif domain_name:\n            fqdn = '{}.{}'.format(hostname, domain_name)\n\n        # interface_list filter\n        interface_list = []\n        show_int_status = show_int_status.strip()\n        for line in show_int_status.splitlines():\n            if line.startswith(' ') or line.startswith('-') or line.startswith('Port '):\n                continue\n            interface = line.split()[0]\n            interface_list.append(interface)\n\n        return {\n            'uptime': int(uptime),\n            'vendor': vendor,\n            'os_version': py23_compat.text_type(os_version),\n            'serial_number': py23_compat.text_type(serial_number),\n            'model': py23_compat.text_type(model),\n            'hostname': py23_compat.text_type(hostname),\n            'fqdn': fqdn,\n            'interface_list': interface_list\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting arp table information.", "response": "def get_arp_table(self):\n        \"\"\"\n        Get arp table information.\n\n        Return a list of dictionaries having the following set of keys:\n            * interface (string)\n            * mac (string)\n            * ip (string)\n            * age (float)\n\n        For example::\n            [\n                {\n                    'interface' : 'MgmtEth0/RSP0/CPU0/0',\n                    'mac'       : '5c:5e:ab:da:3c:f0',\n                    'ip'        : '172.17.17.1',\n                    'age'       : 12.0\n                },\n                {\n                    'interface': 'MgmtEth0/RSP0/CPU0/0',\n                    'mac'       : '66:0e:94:96:e0:ff',\n                    'ip'        : '172.17.17.2',\n                    'age'       : 14.0\n                }\n            ]\n        \"\"\"\n        arp_table = []\n\n        command = 'show ip arp vrf default | exc INCOMPLETE'\n        output = self.device.send_command(command)\n\n        separator = r\"^Address\\s+Age.*Interface.*$\"\n        arp_list = re.split(separator, output, flags=re.M)\n        if len(arp_list) != 2:\n            raise ValueError(\"Error processing arp table output:\\n\\n{}\".format(output))\n\n        arp_entries = arp_list[1].strip()\n        for line in arp_entries.splitlines():\n            if len(line.split()) == 4:\n                address, age, mac, interface = line.split()\n            else:\n                raise ValueError(\"Unexpected output from: {}\".format(line.split()))\n\n            if age == '-':\n                age = -1.0\n            elif ':' not in age:\n                # Cisco sometimes returns a sub second arp time 0.411797\n                try:\n                    age = float(age)\n                except ValueError:\n                    age = -1.0\n            else:\n                age = convert_hhmmss(age)\n                age = float(age)\n            age = round(age, 1)\n\n            # Validate we matched correctly\n            if not re.search(RE_IPADDR, address):\n                raise ValueError(\"Invalid IP Address detected: {}\".format(address))\n            if not re.search(RE_MAC, mac):\n                raise ValueError(\"Invalid MAC Address detected: {}\".format(mac))\n            entry = {\n                'interface': interface,\n                'mac': napalm_base.helpers.mac(mac),\n                'ip': address,\n                'age': age\n            }\n            arp_table.append(entry)\n        return arp_table"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, request, format=None):\n        tokens = Token.objects.filter(user=request.user)\n        for token in tokens:\n            token.delete()\n        content = {'success': _('User logged out.')}\n        return Response(content, status=status.HTTP_200_OK)", "response": "Remove all auth tokens owned by request. user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets attributes to values so can access via dot notation.", "response": "def _set_attrs_to_values(self, response={}):\n        \"\"\" \n        Set attributes to dictionary values so can access via dot notation.\n        \"\"\"\n        for key in response.keys():\n            setattr(self, key, response[key])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a custom filter nl2br to jinja2 Replaces all newline to <BR >", "response": "def add_custom_nl2br_filters(self, app):\n        \"\"\"Add a custom filter nl2br to jinja2\n         Replaces all newline to <BR>\n        \"\"\"\n        _paragraph_re = re.compile(r'(?:\\r\\n|\\r|\\n){3,}')\n\n        @app.template_filter()\n        @evalcontextfilter\n        def nl2br(eval_ctx, value):\n            result = '\\n\\n'.join('%s' % p.replace('\\n', '<br>\\n')\n                                 for p in _paragraph_re.split(value))\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding flask route to automatic documentation for automatic documentation.", "response": "def doc(self, groups=None, set_location=True, **properties):\n        \"\"\"Add flask route to autodoc for automatic documentation\n\n        Any route decorated with this method will be added to the list of\n        routes to be documented by the generate() or html() methods.\n\n        By default, the route is added to the 'all' group.\n        By specifying group or groups argument, the route can be added to one\n        or multiple other groups as well, besides the 'all' group.\n\n        If set_location is True, the location of the function will be stored.\n        NOTE: this assumes that the decorator is placed just before the\n        function (in the normal way).\n\n        Custom parameters may also be passed in beyond groups, if they are\n        named something not already in the dict descibed in the docstring for\n        the generare() function, they will be added to the route's properties,\n        which can be accessed from the template.\n\n        If a parameter is passed in with a name that is already in the dict, but\n        not of a reserved name, the passed parameter overrides that dict value.\n        \"\"\"\n        def decorator(f):\n            # Get previous group list (if any)\n            if f in self.func_groups:\n                groupset = self.func_groups[f]\n            else:\n                groupset = set()\n\n            # Set group[s]\n            if type(groups) is list:\n                groupset.update(groups)\n            elif type(groups) is str:\n                groupset.add(groups)\n            groupset.add('all')\n            self.func_groups[f] = groupset\n            self.func_props[f] = properties\n\n            # Set location\n            if set_location:\n                caller_frame = inspect.stack()[1]\n                self.func_locations[f] = {\n                        'filename': caller_frame[1],\n                        'line':     caller_frame[2],\n                        }\n\n            return f\n        return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate(self, groups='all', sort=None):\n        groups_to_generate = list()\n        if type(groups) is list:\n            groups_to_generate = groups\n        elif type(groups) is str:\n            groups_to_generate.append(groups)\n\n        links = []\n        for rule in current_app.url_map.iter_rules():\n\n            if rule.endpoint == 'static':\n                continue\n\n            func = current_app.view_functions[rule.endpoint]\n            arguments = rule.arguments if rule.arguments else ['None']\n            func_groups = self.func_groups[func]\n            func_props = self.func_props[func] if func in self.func_props \\\n                else {}\n            location = self.func_locations.get(func, None)\n\n            if func_groups.intersection(groups_to_generate):\n                props = dict(\n                    methods=rule.methods,\n                    rule=\"%s\" % rule,\n                    endpoint=rule.endpoint,\n                    docstring=func.__doc__,\n                    args=arguments,\n                    defaults=rule.defaults,\n                    location=location,\n                )\n                for p in func_props:\n                    if p not in self.immutable_props:\n                        props[p] = func_props[p]\n                links.append(props)\n        if sort:\n            return sort(links)\n        else:\n            return sorted(links, key=itemgetter('rule'))", "response": "Generate a list of routes that are defined by the current application."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef html(self, groups='all', template=None, **context):\n        context['autodoc'] = context['autodoc'] if 'autodoc' in context \\\n            else self.generate(groups=groups)\n        context['defaults'] = context['defaults'] if 'defaults' in context \\\n            else self.default_props\n        if template:\n            return render_template(template, **context)\n        else:\n            filename = os.path.join(\n                os.path.dirname(__file__),\n                'templates',\n                'autodoc_default.html'\n            )\n            with open(filename) as file:\n                content = file.read()\n                with current_app.app_context():\n                    return render_template_string(content, **context)", "response": "Returns an html string of the routes specified by the doc method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if OK to continue with close or quit or whatever", "response": "def unsaved_files_dialog(\n            self, all_files=False, with_cancel=True, with_discard=True):\n        \"\"\"Return true if OK to continue with close or quit or whatever\"\"\"\n        for image in self.images:\n            if image.metadata.changed() and (all_files or image.selected):\n                break\n        else:\n            return True\n        dialog = QtWidgets.QMessageBox()\n        dialog.setWindowTitle(self.tr('Photini: unsaved data'))\n        dialog.setText(self.tr('<h3>Some images have unsaved metadata.</h3>'))\n        dialog.setInformativeText(self.tr('Do you want to save your changes?'))\n        dialog.setIcon(QtWidgets.QMessageBox.Warning)\n        buttons = QtWidgets.QMessageBox.Save\n        if with_cancel:\n            buttons |= QtWidgets.QMessageBox.Cancel\n        if with_discard:\n            buttons |= QtWidgets.QMessageBox.Discard\n        dialog.setStandardButtons(buttons)\n        dialog.setDefaultButton(QtWidgets.QMessageBox.Save)\n        result = dialog.exec_()\n        if result == QtWidgets.QMessageBox.Save:\n            self._save_files()\n            return True\n        return result == QtWidgets.QMessageBox.Discard"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_ISO_8601(cls, date_string, time_string, tz_string):\n        # parse tz_string\n        if tz_string:\n            tz_offset = (int(tz_string[1:3]) * 60) + int(tz_string[3:])\n            if tz_string[0] == '-':\n                tz_offset = -tz_offset\n        else:\n            tz_offset = None\n        if time_string == '000000':\n            # assume no time information\n            time_string = ''\n            tz_offset = None\n        datetime_string = date_string + time_string[:13]\n        precision = min((len(datetime_string) - 2) // 2, 7)\n        if precision <= 0:\n            return None\n        fmt = ''.join(('%Y', '%m', '%d', '%H', '%M', '%S', '.%f')[:precision])\n        return cls(\n            (datetime.strptime(datetime_string, fmt), precision, tz_offset))", "response": "Sufficiently general ISO 8601 parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post_post():\n    authorid = request.form.get('authorid', None)\n    Post(request.form['title'],\n         request.form['content'],\n         users[authorid])\n    return redirect(\"/posts\")", "response": "Create a new post."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds another node by XPath originating at the current node.", "response": "def xpath(self, xpath):\n    \"\"\" Finds another node by XPath originating at the current node. \"\"\"\n    return [self.get_node_factory().create(node_id)\n            for node_id in self._get_xpath_ids(xpath).split(\",\")\n            if node_id]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef css(self, css):\n    return [self.get_node_factory().create(node_id)\n            for node_id in self._get_css_ids(css).split(\",\")\n            if node_id]", "response": "Finds another node by a CSS selector relative to the current node."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the value of a boolean HTML attribute like checked or disabled.", "response": "def get_bool_attr(self, name):\n    \"\"\" Returns the value of a boolean HTML attribute like `checked` or `disabled`\n    \"\"\"\n    val = self.get_attr(name)\n    return val is not None and val.lower() in (\"true\", name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of an attribute.", "response": "def set_attr(self, name, value):\n    \"\"\" Sets the value of an attribute. \"\"\"\n    self.exec_script(\"node.setAttribute(%s, %s)\" % (repr(name), repr(value)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the node s value.", "response": "def value(self):\n    \"\"\" Returns the node's value. \"\"\"\n    if self.is_multi_select():\n      return [opt.value()\n              for opt in self.xpath(\".//option\")\n              if opt[\"selected\"]]\n    else:\n      return self._invoke(\"value\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_header(self, key, value):\n    self.conn.issue_command(\"Header\", _normalize_header(key), value)", "response": "Sets a HTTP header for future requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef headers(self):\n    headers = self.conn.issue_command(\"Headers\")\n    res = []\n    for header in headers.split(\"\\r\"):\n      key, value = header.split(\": \", 1)\n      for line in value.split(\"\\n\"):\n        res.append((_normalize_header(key), line))\n    return res", "response": "Returns a list of the last HTTP response headers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nevaluate a piece of Javascript in the current page and returns its value.", "response": "def eval_script(self, expr):\n    \"\"\" Evaluates a piece of Javascript in the context of the current page and\n    returns its value. \"\"\"\n    ret = self.conn.issue_command(\"Evaluate\", expr)\n    return json.loads(\"[%s]\" % ret)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(self, path, width = 1024, height = 1024):\n    self.conn.issue_command(\"Render\", path, width, height)", "response": "Renders the current page to a PNG file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all cookies in cookie string format.", "response": "def cookies(self):\n    \"\"\" Returns a list of all cookies in cookie string format. \"\"\"\n    return [line.strip()\n            for line in self.conn.issue_command(\"GetCookies\").split(\"\\n\")\n            if line.strip()]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset a custom attribute for our Webkit instance.", "response": "def set_attribute(self, attr, value = True):\n    \"\"\" Sets a custom attribute for our Webkit instance. Possible attributes are:\n\n      * ``auto_load_images``\n      * ``dns_prefetch_enabled``\n      * ``plugins_enabled``\n      * ``private_browsing_enabled``\n      * ``javascript_can_open_windows``\n      * ``javascript_can_access_clipboard``\n      * ``offline_storage_database_enabled``\n      * ``offline_web_application_cache_enabled``\n      * ``local_storage_enabled``\n      * ``local_storage_database_enabled``\n      * ``local_content_can_access_remote_urls``\n      * ``local_content_can_access_file_urls``\n      * ``accelerated_compositing_enabled``\n      * ``site_specific_quirks_enabled``\n\n    For all those options, ``value`` must be a boolean. You can find more\n    information about these options `in the QT docs\n    <http://developer.qt.nokia.com/doc/qt-4.8/qwebsettings.html#WebAttribute-enum>`_.\n    \"\"\"\n    value = \"true\" if value else \"false\"\n    self.conn.issue_command(\"SetAttribute\",\n                            self._normalize_attr(attr),\n                            value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets custom HTML in our Webkit session and allows to specify a fake URL.", "response": "def set_html(self, html, url = None):\n    \"\"\" Sets custom HTML in our Webkit session and allows to specify a fake URL.\n    Scripts and CSS is dynamically fetched as if the HTML had been loaded from\n    the given URL. \"\"\"\n    if url:\n      self.conn.issue_command('SetHtml', html, url)\n    else:\n      self.conn.issue_command('SetHtml', html)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting a custom HTTP proxy to use for future requests.", "response": "def set_proxy(self, host     = \"localhost\",\n                      port     = 0,\n                      user     = \"\",\n                      password = \"\"):\n    \"\"\" Sets a custom HTTP proxy to use for future requests. \"\"\"\n    self.conn.issue_command(\"SetProxy\", host, port, user, password)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new socket connection to this server.", "response": "def connect(self):\n    \"\"\" Returns a new socket connection to this server. \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"127.0.0.1\", self._port))\n    return sock"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconsumes one line from the stream.", "response": "def read_line(self):\n    \"\"\" Consume one line from the stream. \"\"\"\n    while True:\n      newline_idx = self.buf.find(b\"\\n\")\n      if newline_idx >= 0:\n        res = self.buf[:newline_idx]\n        self.buf = self.buf[newline_idx + 1:]\n        return res\n      chunk = self.f.recv(4096)\n      if not chunk:\n        raise EndOfStreamError()\n      self.buf += chunk"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self, n):\n    while len(self.buf) < n:\n      chunk = self.f.recv(4096)\n      if not chunk:\n        raise EndOfStreamError()\n      self.buf += chunk\n    res, self.buf = self.buf[:n], self.buf[n:]\n    return res", "response": "Consume n characters from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nissue a command to the server.", "response": "def issue_command(self, cmd, *args):\n    \"\"\" Sends and receives a message to/from the server \"\"\"\n    self._writeline(cmd)\n    self._writeline(str(len(args)))\n    for arg in args:\n      arg = str(arg)\n      self._writeline(str(len(arg)))\n      self._sock.sendall(arg.encode(\"utf-8\"))\n\n    return self._read_response()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads a complete response packet from the server.", "response": "def _read_response(self):\n    \"\"\" Reads a complete response packet from the server \"\"\"\n    result = self.buf.read_line().decode(\"utf-8\")\n    if not result:\n      raise NoResponseError(\"No response received from server.\")\n\n    msg = self._read_message()\n    if result != \"ok\":\n      raise InvalidResponseError(msg)\n\n    return msg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_message(self):\n    size = int(self.buf.read_line().decode(\"utf-8\"))\n    return self.buf.read(size).decode(\"utf-8\")", "response": "Reads a single message from the server"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets updated property details for a given zpid", "response": "def get_updated_property_details(self, zpid):\n        \"\"\"\n        GetUpdatedPropertyDetails API\n        \"\"\"\n        url = 'http://www.zillow.com/webservice/GetUpdatedPropertyDetails.htm'\n\n        params = {\n            'zpid': zpid,\n            'zws-id': self.api_key\n        }\n        return self.get_data(url, params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfix the orientation of an image.", "response": "def fix_orientation(img, save_over=False):\n    \"\"\"\n    `img` can be an Image instance or a path to an image file.\n    `save_over` indicates if the original image file should be replaced by the new image.\n    * Note: `save_over` is only valid if `img` is a file path.\n    \"\"\"\n    path = None\n    if not isinstance(img, Image.Image):\n        path = img\n        img = Image.open(path)\n    elif save_over:\n        raise ValueError(\"You can't use `save_over` when passing an Image instance.  Use a file path instead.\")\n    try:\n        orientation = img._getexif()[EXIF_ORIENTATION_TAG]\n    except (TypeError, AttributeError, KeyError):\n        raise ValueError(\"Image file has no EXIF data.\")\n    if orientation in [3,6,8]:\n        degrees = ORIENTATIONS[orientation][1]\n        img = img.transpose(degrees)\n        if save_over and path is not None:\n            try:\n                img.save(path, quality=95, optimize=1)\n            except IOError:\n                # Try again, without optimization (PIL can't optimize an image\n                # larger than ImageFile.MAXBLOCK, which is 64k by default).\n                # Setting ImageFile.MAXBLOCK should fix this....but who knows.\n                img.save(path, quality=95)\n        return (img, degrees)\n    else:\n        return (img, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an error message and optional user message to the error list", "response": "def log_error(self, error, message, detail=None, strip=4):\n        \"Add an error message and optional user message to the error list\"\n        if message:\n            msg = message + \": \" + error\n        else:\n            msg = error\n\n        tb = traceback.format_stack()\n        if sys.version_info >= (3, 0):\n            tb = tb[:-strip]\n        else:\n            tb = tb[strip:]\n\n        self.errors.append({\n            'message': msg,\n            'traceback': tb,\n            'detail': detail\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if two values are equal", "response": "def equal(self, a, b, message=None):\n        \"Check if two values are equal\"\n        if a != b:\n            self.log_error(\"{} != {}\".format(str(a), str(b)), message)\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if a value is not None", "response": "def is_not_none(self, a, message=None):\n        \"Check if a value is not None\"\n        if a is None:\n            self.log_error(\"{} is None\".format(str(a)), message)\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if a function raises an exception type", "response": "def raises(self, exception_type, function, *args, **kwargs):\n        \"\"\"\n            Check if a function raises a specified exception type,\n            *args and **kwargs are forwarded to the function\n        \"\"\"\n        try:\n            result = function(*args, **kwargs)\n            self.log_error(\"{} did not throw exception {}\".format(\n                function.__name__,\n                exception_type.__name__\n            ), None)\n            return result\n        except Exception as e:\n            if type(e) != exception_type:\n                self.log_error(\"{} did raise {}: {}\".format(\n                    function.__name__,\n                    type(e).__name__, e\n                ), None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if a function does not raise an exception", "response": "def does_not_raise(self, function, *args, **kwargs):\n        \"\"\"\n            Check if a function does not raise an exception,\n            *args and **kwargs are forwarded to the function\n        \"\"\"\n        try:\n            return function(*args, **kwargs)\n        except Exception as e:\n            self.log_error(\"{} did raise {}: {}\".format(\n                function.__name__,\n                type(e).__name__, e\n            ), None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting the raw R G B values to color temperature in degrees Kelvin.", "response": "def calculate_color_temperature(r, g, b):\n    \"\"\"Converts the raw R/G/B values to color temperature in degrees Kelvin.\"\"\"\n    # 1. Map RGB values to their XYZ counterparts.\n    # Based on 6500K fluorescent, 3000K fluorescent\n    # and 60W incandescent values for a wide range.\n    # Note: Y = Illuminance or lux\n    X = (-0.14282 * r) + (1.54924 * g) + (-0.95641 * b)\n    Y = (-0.32466 * r) + (1.57837 * g) + (-0.73191 * b)\n    Z = (-0.68202 * r) + (0.77073 * g) + ( 0.56332 * b)\n    # Check for divide by 0 (total darkness) and return None.\n    if (X + Y + Z) == 0:\n        return None\n    # 2. Calculate the chromaticity co-ordinates\n    xc = (X) / (X + Y + Z)\n    yc = (Y) / (X + Y + Z)\n    # Check for divide by 0 again and return None.\n    if (0.1858 - yc) == 0:\n        return None\n    # 3. Use McCamy's formula to determine the CCT\n    n = (xc - 0.3320) / (0.1858 - yc)\n    # Calculate the final CCT\n    cct = (449.0 * (n ** 3.0)) + (3525.0 *(n ** 2.0)) + (6823.3 * n) + 5520.33\n    return int(cct)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_lux(r, g, b):\n    illuminance = (-0.32466 * r) + (1.57837 * g) + (-0.73191 * b)\n    return int(illuminance)", "response": "Converts the raw R G B values to luminosity in lux."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _write8(self, reg, value):\n        self._device.write8(TCS34725_COMMAND_BIT | reg, value)", "response": "Write an 8 - bit value to a register."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisable the chip (power down).", "response": "def disable(self):\n        \"\"\"Disable the chip (power down).\"\"\"\n        # Flip off the power on and enable bits.\n        reg = self._readU8(TCS34725_ENABLE)\n        reg &= ~(TCS34725_ENABLE_PON | TCS34725_ENABLE_AEN)\n        self._write8(TCS34725_ENABLE, reg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the integration time for the TC34725.", "response": "def set_integration_time(self, integration_time):\n        \"\"\"Sets the integration time for the TC34725.  Provide one of these\n        constants:\n         - TCS34725_INTEGRATIONTIME_2_4MS  = 2.4ms - 1 cycle    - Max Count: 1024\n         - TCS34725_INTEGRATIONTIME_24MS   = 24ms  - 10 cycles  - Max Count: 10240\n         - TCS34725_INTEGRATIONTIME_50MS   = 50ms  - 20 cycles  - Max Count: 20480\n         - TCS34725_INTEGRATIONTIME_101MS  = 101ms - 42 cycles  - Max Count: 43008\n         - TCS34725_INTEGRATIONTIME_154MS  = 154ms - 64 cycles  - Max Count: 65535\n         - TCS34725_INTEGRATIONTIME_700MS  = 700ms - 256 cycles - Max Count: 65535\n        \"\"\"\n        self._integration_time = integration_time\n        self._write8(TCS34725_ATIME, integration_time)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_interrupt(self, enabled):\n        enable_reg = self._readU8(TCS34725_ENABLE)\n        if enabled:\n            enable_reg |= TCS34725_ENABLE_AIEN\n        else:\n            enable_reg &= ~TCS34725_ENABLE_AIEN\n        self._write8(TCS34725_ENABLE, enable_reg)\n        time.sleep(1)", "response": "Enable or disable interrupts by setting enabled to True or False."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the interrupt limits to provied unsigned 16 - bit threshold values.", "response": "def set_interrupt_limits(self, low, high):\n        \"\"\"Set the interrupt limits to provied unsigned 16-bit threshold values.\n        \"\"\"\n        self._device.write8(0x04, low & 0xFF)\n        self._device.write8(0x05, low >> 8)\n        self._device.write8(0x06, high & 0xFF)\n        self._device.write8(0x07, high >> 8)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert(json_input, build_direction=\"LEFT_TO_RIGHT\", table_attributes=None):\n    json_converter = JsonConverter(build_direction=build_direction, table_attributes=table_attributes)\n    return json_converter.convert(json_input)", "response": "Converts JSON object to HTML Table format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a dictionary into HTML Table format.", "response": "def convert(self, json_input):\n        \"\"\"\n        Converts JSON to HTML Table format.\n\n        Parameters\n        ----------\n        json_input : dict\n            JSON object to convert into HTML.\n\n        Returns\n        -------\n        str\n            String of converted HTML.\n        \"\"\"\n        html_output = self._table_opening_tag\n        if self._build_top_to_bottom:\n            html_output += self._markup_header_row(json_input.keys())\n            html_output += \"<tr>\"\n            for value in json_input.values():\n                if isinstance(value, list):\n                    # check if all keys in the list are identical\n                    # and group all values under a common column\n                    # heading if so, if not default to normal markup\n                    html_output += self._maybe_club(value)\n                else:\n                    html_output += self._markup_table_cell(value)\n            html_output += \"</tr>\"\n        else:\n            for key, value in iter(json_input.items()):\n                html_output += \"<tr><th>{:s}</th>\".format(self._markup(key))\n                if isinstance(value, list):\n                    html_output += self._maybe_club(value)\n                else:\n                    html_output += self._markup_table_cell(value)\n                html_output += \"</tr>\"\n        html_output += \"</table>\"\n        return html_output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dict_to_html_attributes(d):\n        if d is None:\n            return \"\"\n\n        return \"\".join(\" {}=\\\"{}\\\"\".format(key, value) for key, value in iter(d.items()))", "response": "Converts a dictionary to a string of html attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _list_of_dicts_to_column_headers(list_of_dicts):\n\n        if len(list_of_dicts) < 2 or not all(isinstance(item, dict) for item in list_of_dicts):\n            return None\n\n        column_headers = list_of_dicts[0].keys()\n        for d in list_of_dicts[1:]:\n            if len(d.keys()) != len(column_headers) or not all(header in d for header in column_headers):\n                return None\n        return column_headers", "response": "Returns the list of column headers from a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _maybe_club(self, list_of_dicts):\n        column_headers = JsonConverter._list_of_dicts_to_column_headers(list_of_dicts)\n        if column_headers is None:\n            # common headers not found, return normal markup\n            html_output = self._markup(list_of_dicts)\n        else:\n            html_output = self._table_opening_tag\n            html_output += self._markup_header_row(column_headers)\n            for list_entry in list_of_dicts:\n                html_output += \"<tr><td>\"\n                html_output += \"</td><td>\".join(self._markup(list_entry[column_header]) for column_header in column_headers)\n                html_output += \"</td></tr>\"\n            html_output += \"</table>\"\n\n        return self._markup_table_cell(html_output)", "response": "Given a list of dicts and a list of dicts return a HTML string that can be used to club the list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the voice notify.", "response": "def update_voice_notify(self, param, must=[APIKEY, TPL_ID, TPL_CONTENT]):\n        '''\u4fee\u6539\u8bed\u97f3\u901a\u77e5\u6a21\u7248\n        \n        \u6ce8\u610f\uff1a\u6a21\u677f\u6210\u529f\u4fee\u6539\u4e4b\u540e\u9700\u8981\u91cd\u65b0\u5ba1\u6838\u624d\u80fd\u4f7f\u7528\uff01\u540c\u65f6\u63d0\u9192\u60a8\u5982\u679c\u4fee\u6539\u4e86\u53d8\u91cf\uff0c\u52a1\u5fc5\u91cd\u65b0\u6d4b\u8bd5\uff0c\u4ee5\u514d\u66ff\u6362\u51fa\u9519!\n        \u53c2\u6570\uff1a\n        \u53c2\u6570\u540d    \u7c7b\u578b    \u662f\u5426\u5fc5\u987b    \u63cf\u8ff0    \u793a\u4f8b\n        apikey    String    \u662f    \u7528\u6237\u552f\u4e00\u6807\u8bc6    9b11127a9701975c734b8aee81ee3526\n        tpl_id    Long    \u662f    \u6a21\u677fid\uff0c64\u4f4d\u957f\u6574\u5f62\u3002\u6307\u5b9aid\u65f6\u8fd4\u56deid\u5bf9\u5e94\u7684\u6a21\u677f\u3002\u672a\u6307\u5b9a\u65f6\u8fd4\u56de\u6240\u6709\u6a21\u677f    9527\n        tpl_content    String    \u662f    \u6a21\u677fid\uff0c64\u4f4d\u957f\u6574\u5f62\u3002\u6307\u5b9aid\u65f6\u8fd4\u56deid\u5bf9\u5e94\u7684\u6a21\u677f\u3002\u672a\u6307\u5b9a\u65f6\u8fd4\u56de\u6240\u6709\u6a21\u677f\u6a21\u677f\u5185\u5bb9    \u60a8\u7684\u9a8c\u8bc1\u7801\u662f#code#\n        \n        Args:\n            param:  \n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V2:rsp}[self.version()])\n        return self.path('update_voice_notify.json').post(param, h, r)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset code of the current object", "response": "def code(self, code=None, ret_r=False):\n        '''\n        Args:\n            code: (Optional) set code\n            ret_r: (Optional) force to return Result. Default value is False\n        returns:\n            response code(0-success, others-failure) or self\n        '''\n        if code or ret_r:\n            self._code = code\n            return self\n        return self._code"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a specific resource from the API.", "response": "def get(self, param=None, must=[APIKEY]):\n        '''\u67e5\u8d26\u6237\u4fe1\u606f\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        \n        Args:\n            param: (Optional) \n        Results:\n            Result\n        '''\n        param = {} if param is None else param\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        handle = CommonResultHandler(lambda rsp: {VERSION_V1:rsp.get(USER), VERSION_V2:rsp}[self.version()])\n        return self.path('get.json').post(param, handle, r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes api by YunpianClient", "response": "def _init(self, clnt):\n        '''initialize api by YunpianClient'''\n        assert clnt, \"clnt is None\"\n        self._clnt = clnt\n        self._apikey = clnt.apikey()\n        self._version = clnt.conf(YP_VERSION, defval=VERSION_V2)\n        self._charset = clnt.conf(HTTP_CHARSET, defval=CHARSET_UTF8)\n        self._name = self.__class__.__module__.split('.')[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post(self, param, h, r):\n        '''\n        Args:\n            param: request parameters\n            h: ResultHandler\n            r: YunpianApiResult\n        '''\n        try:\n            rsp = self.client().post(self.uri(), param)\n            # print(rsp)\n            return self.result(rsp, h, r)\n        except ValueError as err:\n            return h.catch_exception(err, r)", "response": "POST a new object to the resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nverify that all keys in must are present in param", "response": "def verify_param(self, param, must=[], r=None):\n        '''return Code.ARGUMENT_MISSING if every key in must not found in param'''\n        if APIKEY not in param:\n            param[APIKEY] = self.apikey()\n\n        r = Result() if r is None else r\n        for p in must:\n            if p not in param:\n                r.code(Code.ARGUMENT_MISSING).detail('missing-' + p)\n                break\n\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef custom_conf(self, conf):\n        '''custom apikey and http parameters'''\n        if conf:\n            for (key, val) in conf.items():\n                self.__conf[key] = val\n        return self", "response": "custom apikey and http parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns special API by package s name", "response": "def api(self, name):\n        '''return special API by package's name'''\n\n        assert name, 'name is none'\n        if flow.__name__ == name:\n            api = flow.FlowApi()\n        elif sign.__name__ == name:\n            api = sign.SignApi()\n        elif sms.__name__ == name:\n            api = sms.SmsApi()\n        elif tpl.__name__ == name:\n            api = tpl.TplApi()\n        elif user.__name__ == name:\n            api = user.UserApi()\n        elif voice.__name__ == name:\n            api = voice.VoiceApi()\n\n        assert api, \"not found api-\" + name\n\n        api._init(self._clnt)\n        return api"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn value in YunpianConf if key = None else return value in YunpianConf", "response": "def conf(self, key=None, defval=None):\n        '''return YunpianConf if key=None, else return value in YunpianConf'''\n        if key is None:\n            return self._ypconf\n        val = self._ypconf.conf(key)\n        return defval if val is None else val"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nposts data to url", "response": "def post(self, url, data, charset=CHARSET_UTF8, headers={}):\n        '''response json text'''\n        if 'Api-Lang' not in headers:\n            headers['Api-Lang'] = 'python'\n        if 'Content-Type' not in headers:\n            headers['Content-Type'] = \"application/x-www-form-urlencoded;charset=\" + charset\n        rsp = requests.post(url, data, headers=headers,\n                            timeout=(int(self.conf(HTTP_CONN_TIMEOUT, '10')), int(self.conf(HTTP_SO_TIMEOUT, '30'))))\n        return json.loads(rsp.text)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef urlEncodeAndJoin(self, seq, sepr=','):\n        '''sepr.join(urlencode(seq))\n        Args:\n            seq: string list to be urlencoded\n            sepr: join seq with sepr\n        Returns:\n            str\n        '''\n        try:\n            from urllib.parse import quote_plus as encode\n            return sepr.join([encode(x, encoding=CHARSET_UTF8) for x in seq])\n        except ImportError:\n            from urllib import quote as encode\n            return sepr.join([i for i in map(lambda x: encode(x), seq)])", "response": "URL encode and join a list of strings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, param, must=[APIKEY, MOBILE, CODE]):\n        '''\u53d1\u8bed\u97f3\u9a8c\u8bc1\u7801\n\n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        mobile String \u662f \u63a5\u6536\u7684\u624b\u673a\u53f7\u3001\u56fa\u8bdd\uff08\u9700\u52a0\u533a\u53f7\uff09 15205201314 01088880000\n        code String \u662f \u9a8c\u8bc1\u7801\uff0c\u652f\u63014~6\u4f4d\u963f\u62c9\u4f2f\u6570\u5b57 1234\n        encrypt String \u5426 \u52a0\u5bc6\u65b9\u5f0f \u4f7f\u7528\u52a0\u5bc6 tea (\u4e0d\u518d\u4f7f\u7528)\n        _sign String \u5426 \u7b7e\u540d\u5b57\u6bb5 \u53c2\u8003\u4f7f\u7528\u52a0\u5bc6 393d079e0a00912335adfe46f4a2e10f (\u4e0d\u518d\u4f7f\u7528)\n        callback_url String \u5426 \u672c\u6761\u8bed\u97f3\u9a8c\u8bc1\u7801\u72b6\u6001\u62a5\u544a\u63a8\u9001\u5730\u5740 http://your_receive_url_address\n        display_num String \u5426 \u900f\u4f20\u53f7\u7801\uff0c\u4e3a\u4fdd\u8bc1\u5168\u56fd\u8303\u56f4\u7684\u547c\u901a\u7387\uff0c\u4e91\u7247\u4f1a\u81ea\u52a8\u9009\u62e9\u6700\u4f73\u7684\u7ebf\u8def\uff0c\u900f\u4f20\u7684\u4e3b\u53eb\u53f7\u7801\u4e5f\u4f1a\u76f8\u5e94\u53d8\u5316\u3002\n        \u5982\u9700\u900f\u4f20\u56fa\u5b9a\u53f7\u7801\u5219\u9700\u8981\u5355\u72ec\u6ce8\u518c\u62a5\u5907\uff0c\u4e3a\u4e86\u786e\u4fdd\u53f7\u7801\u771f\u5b9e\u6709\u6548\uff0c\u5ba2\u670d\u5c06\u8981\u6c42\u60a8\u4f7f\u7528\u62a5\u5907\u7684\u53f7\u7801\u62e8\u6253\u4e00\u6b21\u5ba2\u670d\u7535\u8bdd\n\n        Args:\n            param:  \n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp.get(RESULT), VERSION_V2:rsp}[self.version()])\n        return self.path('send.json').post(param, h, r)", "response": "send a message to the server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef single_send(self, param, must=[APIKEY, MOBILE, TEXT]):\n        '''\u5355\u6761\u53d1\u9001\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        mobile String \u662f\n        \u63a5\u6536\u7684\u624b\u673a\u53f7\uff1b\u4ec5\u652f\u6301\u5355\u53f7\u7801\u53d1\u9001\uff1b\u56fd\u9645\u53f7\u7801\u9700\u5305\u542b\u56fd\u9645\u5730\u533a\u524d\u7f00\u53f7\u7801\uff0c\u683c\u5f0f\u5fc5\u987b\u662f\"+\"\u53f7\u5f00\u5934(\"+\"\u53f7\u9700\u8981urlencode\u5904\u7406\uff0c\u5426\u5219\u4f1a\u51fa\u73b0\u683c\u5f0f\u9519\u8bef)\uff0c\u56fd\u9645\u53f7\u7801\u4e0d\u4ee5\"+\"\u5f00\u5934\u5c06\u88ab\u8ba4\u4e3a\u662f\u4e2d\u56fd\u5730\u533a\u7684\u53f7\u7801\n        \uff08\u9488\u5bf9\u56fd\u9645\u77ed\u4fe1\uff0cmobile\u53c2\u6570\u4f1a\u81ea\u52a8\u683c\u5f0f\u5316\u5230E.164\u683c\u5f0f\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u4f20\u5165mobile\u53c2\u6570\u8ddf\u540e\u7eed\u7684\u72b6\u6001\u62a5\u544a\u4e2d\u7684\u53f7\u7801\u4e0d\u4e00\u81f4\u3002E.164\u683c\u5f0f\u8bf4\u660e\uff0c\u53c2\u89c1\uff1a\n        https://en.wikipedia.org/wiki/E.164\uff09 \u56fd\u5185\u53f7\u7801\uff1a15205201314\n        \u56fd\u9645\u53f7\u7801\uff1aurlencode(\"+93701234567\");\n        text String \u662f \u77ed\u4fe1\u5185\u5bb9 \u3010\u4e91\u7247\u7f51\u3011\u60a8\u7684\u9a8c\u8bc1\u7801\u662f1234\n        extend String \u5426 \u6269\u5c55\u53f7\u3002\u9ed8\u8ba4\u4e0d\u5f00\u653e\uff0c\u5982\u6709\u9700\u8981\u8bf7\u8054\u7cfb\u5ba2\u670d\u7533\u8bf7 001\n        uid String \u5426 \u8be5\u6761\u77ed\u4fe1\u5728\u60a8\u4e1a\u52a1\u7cfb\u7edf\u5185\u7684ID\uff0c\u6bd4\u5982\u8ba2\u5355\u53f7\u6216\u8005\u77ed\u4fe1\u53d1\u9001\u8bb0\u5f55\u7684\u6d41\u6c34\u53f7\u3002\u586b\u5199\u540e\u53d1\u9001\u72b6\u6001\u8fd4\u56de\u503c\u5185\u5c06\u5305\u542b\u8fd9\u4e2aID\n        \u9ed8\u8ba4\u4e0d\u5f00\u653e\uff0c\u5982\u6709\u9700\u8981\u8bf7\u8054\u7cfb\u5ba2\u670d\u7533\u8bf7 10001\n        callback_url String \u5426\n        \u672c\u6761\u77ed\u4fe1\u72b6\u6001\u62a5\u544a\u63a8\u9001\u5730\u5740\u3002\u77ed\u4fe1\u53d1\u9001\u540e\u5c06\u5411\u8fd9\u4e2a\u5730\u5740\u63a8\u9001\u77ed\u4fe1\u53d1\u9001\u62a5\u544a\u3002\"\u540e\u53f0-\u7cfb\u7edf\u8bbe\u7f6e-\u6570\u636e\u63a8\u9001\u4e0e\u83b7\u53d6\u201d\u53ef\u4ee5\u505a\u6279\u91cf\u8bbe\u7f6e\u3002\u5982\u679c\u540e\u53f0\u5df2\u7ecf\u8bbe\u7f6e\u5730\u5740\u7684\u60c5\u51b5\u4e0b\uff0c\u5355\u6b21\u8bf7\u6c42\u5185\u4e5f\u5305\u542b\u6b64\u53c2\u6570\uff0c\u5c06\u4ee5\u8bf7\u6c42\u5185\u7684\u63a8\u9001\u5730\u5740\u4e3a\u51c6\u3002\n        http://your_receive_url_address\n        \n        Args:\n            param: \n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V2:rsp}[self.version()])\n        return self.path('single_send.json').post(param, h, r)", "response": "sends a single request to the server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pull_reply(self, param=None, must=[APIKEY]):\n        '''\u83b7\u53d6\u56de\u590d\u77ed\u4fe1\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        page_size Integer \u5426 \u6bcf\u9875\u4e2a\u6570\uff0c\u6700\u5927100\u4e2a\uff0c\u9ed8\u8ba420\u4e2a 20\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        param = {} if param is None else param\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp[SMS_REPLY] if SMS_REPLY in rsp else None, VERSION_V2:rsp}[self.version()])\n        return self.path('pull_reply.json').post(param, h, r)", "response": "pull reply from a user"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget reply from a user.", "response": "def get_reply(self, param, must=[APIKEY, START_TIME, END_TIME, PAGE_NUM, PAGE_SIZE]):\n        '''\u67e5\u56de\u590d\u7684\u77ed\u4fe1\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        start_time String \u662f \u77ed\u4fe1\u56de\u590d\u5f00\u59cb\u65f6\u95f4 2013-08-11 00:00:00\n        end_time String \u662f \u77ed\u4fe1\u56de\u590d\u7ed3\u675f\u65f6\u95f4 2013-08-12 00:00:00\n        page_num Integer \u662f \u9875\u7801\uff0c\u9ed8\u8ba4\u503c\u4e3a1 1\n        page_size Integer \u662f \u6bcf\u9875\u4e2a\u6570\uff0c\u6700\u5927100\u4e2a 20\n        mobile String \u5426 \u586b\u5199\u65f6\u53ea\u67e5\u8be5\u624b\u673a\u53f7\u7684\u56de\u590d\uff0c\u4e0d\u586b\u65f6\u67e5\u6240\u6709\u7684\u56de\u590d 15205201314\n        return_fields \u5426 \u8fd4\u56de\u5b57\u6bb5\uff08\u6682\u672a\u5f00\u653e\n        sort_fields \u5426 \u6392\u5e8f\u5b57\u6bb5\uff08\u6682\u672a\u5f00\u653e\uff09 \u9ed8\u8ba4\u6309\u63d0\u4ea4\u65f6\u95f4\u964d\u5e8f\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp[SMS_REPLY] if SMS_REPLY in rsp else None, VERSION_V2:rsp}[self.version()])\n        return self.path('get_reply.json').post(param, h, r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_record(self, param, must=[APIKEY, START_TIME, END_TIME]):\n        '''\u67e5\u77ed\u4fe1\u53d1\u9001\u8bb0\u5f55\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        mobile String \u5426 \u9700\u8981\u67e5\u8be2\u7684\u624b\u673a\u53f7 15205201314\n        start_time String \u662f \u77ed\u4fe1\u53d1\u9001\u5f00\u59cb\u65f6\u95f4 2013-08-11 00:00:00\n        end_time String \u662f \u77ed\u4fe1\u53d1\u9001\u7ed3\u675f\u65f6\u95f4 2013-08-12 00:00:00\n        page_num Integer \u5426 \u9875\u7801\uff0c\u9ed8\u8ba4\u503c\u4e3a1 1\n        page_size Integer \u5426 \u6bcf\u9875\u4e2a\u6570\uff0c\u6700\u5927100\u4e2a 20\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp[SMS] if SMS in rsp else None, VERSION_V2:rsp}[self.version()])\n        return self.path('get_record.json').post(param, h, r)", "response": "Get a record from a user s account."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncounting the number of items in a resource.", "response": "def count(self, param, must=[APIKEY, START_TIME, END_TIME]):\n        '''\u7edf\u8ba1\u77ed\u4fe1\u6761\u6570\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        start_time String \u662f \u77ed\u4fe1\u53d1\u9001\u5f00\u59cb\u65f6\u95f4 2013-08-11 00:00:00\n        end_time String \u662f \u77ed\u4fe1\u53d1\u9001\u7ed3\u675f\u65f6\u95f4 2013-08-12 00:00:00\n        mobile String \u5426 \u9700\u8981\u67e5\u8be2\u7684\u624b\u673a\u53f7 15205201314\n        page_num Integer \u5426 \u9875\u7801\uff0c\u9ed8\u8ba4\u503c\u4e3a1 1\n        page_size Integer \u5426 \u6bcf\u9875\u4e2a\u6570\uff0c\u6700\u5927100\u4e2a 20\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: int(rsp[TOTAL]) if TOTAL in rsp else 0)\n        return self.path('count.json').post(param, h, r)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tpl_send(self, param, must=[APIKEY, MOBILE, TPL_ID, TPL_VALUE]):\n        '''\u6307\u5b9a\u6a21\u677f\u53d1\u9001 only v1 deprecated\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        mobile String \u662f \u63a5\u6536\u7684\u624b\u673a\u53f7 15205201314\n        tpl_id Long \u662f \u6a21\u677fid 1\n        tpl_value String \u662f \u53d8\u91cf\u540d\u548c\u53d8\u91cf\u503c\u5bf9\u3002\u8bf7\u5148\u5bf9\u60a8\u7684\u53d8\u91cf\u540d\u548c\u53d8\u91cf\u503c\u5206\u522b\u8fdb\u884curlencode\u518d\u4f20\u9012\u3002\u4f7f\u7528\u53c2\u8003\uff1a\u4ee3\u7801\u793a\u4f8b\u3002\n        \u6ce8\uff1a\u53d8\u91cf\u540d\u548c\u53d8\u91cf\u503c\u90fd\u4e0d\u80fd\u4e3a\u7a7a \u6a21\u677f\uff1a \u3010#company#\u3011\u60a8\u7684\u9a8c\u8bc1\u7801\u662f#code#\u3002 \u6700\u7ec8\u53d1\u9001\u7ed3\u679c\uff1a \u3010\u4e91\u7247\u7f51\u3011\u60a8\u7684\u9a8c\u8bc1\u7801\u662f1234\u3002\n        tplvalue=urlencode(\"#code#\") + \"=\" + urlencode(\"1234\") + \"&amp;\" +\n        urlencode(\"#company#\") + \"=\" + urlencode(\"\u4e91\u7247\u7f51\"); \u82e5\u60a8\u76f4\u63a5\u53d1\u9001\u62a5\u6587\u8bf7\u6c42\u5219\u4f7f\u7528\u4e0b\u9762\u8fd9\u79cd\u5f62\u5f0f\n        tplvalue=urlencode(urlencode(\"#code#\") + \"=\" + urlencode(\"1234\") + \"&amp;\" +\n        urlencode(\"#company#\") + \"=\" + urlencode(\"\u4e91\u7247\u7f51\"));\n        extend String \u5426 \u6269\u5c55\u53f7\u3002\u9ed8\u8ba4\u4e0d\u5f00\u653e\uff0c\u5982\u6709\u9700\u8981\u8bf7\u8054\u7cfb\u5ba2\u670d\u7533\u8bf7 001\n        uid String \u5426 \u7528\u6237\u81ea\u5b9a\u4e49\u552f\u4e00id\u3002\u6700\u5927\u957f\u5ea6\u4e0d\u8d85\u8fc7256\u7684\u5b57\u7b26\u4e32\u3002 \u9ed8\u8ba4\u4e0d\u5f00\u653e\uff0c\u5982\u6709\u9700\u8981\u8bf7\u8054\u7cfb\u5ba2\u670d\u7533\u8bf7 10001\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp.get(RESULT)}[self.version()])\n        return self.path('tpl_send.json').post(param, h, r)", "response": "sends a message to the TPL"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a single message to the server", "response": "def tpl_single_send(self, param, must=[APIKEY, MOBILE, TPL_ID, TPL_VALUE]):\n        '''\u6307\u5b9a\u6a21\u677f\u5355\u53d1 only v2 deprecated\n\n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        mobile String \u662f\n        \u63a5\u6536\u7684\u624b\u673a\u53f7\uff08\u9488\u5bf9\u56fd\u9645\u77ed\u4fe1\uff0cmobile\u53c2\u6570\u4f1a\u81ea\u52a8\u683c\u5f0f\u5316\u5230E.164\u683c\u5f0f\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u4f20\u5165mobile\u53c2\u6570\u8ddf\u540e\u7eed\u7684\u72b6\u6001\u62a5\u544a\u4e2d\u7684\u53f7\u7801\u4e0d\u4e00\u81f4\u3002E.164\u683c\u5f0f\u8bf4\u660e\uff0c\u53c2\u89c1\uff1a\n        https://en.wikipedia.org/wiki/E.164\uff09 15205201314\n        tpl_id Long \u662f \u6a21\u677fid 1\n        tpl_value String \u662f \u53d8\u91cf\u540d\u548c\u53d8\u91cf\u503c\u5bf9\u3002\u8bf7\u5148\u5bf9\u60a8\u7684\u53d8\u91cf\u540d\u548c\u53d8\u91cf\u503c\u5206\u522b\u8fdb\u884curlencode\u518d\u4f20\u9012\u3002\u4f7f\u7528\u53c2\u8003\uff1a\u4ee3\u7801\u793a\u4f8b\u3002\n        \u6ce8\uff1a\u53d8\u91cf\u540d\u548c\u53d8\u91cf\u503c\u90fd\u4e0d\u80fd\u4e3a\u7a7a \u6a21\u677f\uff1a \u3010#company#\u3011\u60a8\u7684\u9a8c\u8bc1\u7801\u662f#code#\u3002 \u6700\u7ec8\u53d1\u9001\u7ed3\u679c\uff1a \u3010\u4e91\u7247\u7f51\u3011\u60a8\u7684\u9a8c\u8bc1\u7801\u662f1234\u3002\n        tplvalue=urlencode(\"#code#\") + \"=\" + urlencode(\"1234\") + \"&amp;\" +\n        urlencode(\"#company#\") + \"=\" + urlencode(\"\u4e91\u7247\u7f51\"); \u82e5\u60a8\u76f4\u63a5\u53d1\u9001\u62a5\u6587\u8bf7\u6c42\u5219\u4f7f\u7528\u4e0b\u9762\u8fd9\u79cd\u5f62\u5f0f\n        tplvalue=urlencode(urlencode(\"#code#\") + \"=\" + urlencode(\"1234\") + \"&amp;\" +\n        urlencode(\"#company#\") + \"=\" + urlencode(\"\u4e91\u7247\u7f51\"));\n        extend String \u5426 \u6269\u5c55\u53f7\u3002\u9ed8\u8ba4\u4e0d\u5f00\u653e\uff0c\u5982\u6709\u9700\u8981\u8bf7\u8054\u7cfb\u5ba2\u670d\u7533\u8bf7 001\n        uid String \u5426 \u7528\u6237\u81ea\u5b9a\u4e49\u552f\u4e00id\u3002\u6700\u5927\u957f\u5ea6\u4e0d\u8d85\u8fc7256\u7684\u5b57\u7b26\u4e32\u3002 \u9ed8\u8ba4\u4e0d\u5f00\u653e\uff0c\u5982\u6709\u9700\u8981\u8bf7\u8054\u7cfb\u5ba2\u670d\u7533\u8bf7 10001\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V2:rsp}[self.version()])\n        return self.path('tpl_single_send.json').post(param, h, r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a specific package from the API.", "response": "def get_package(self, param=None, must=[APIKEY]):\n        '''\u67e5\u8be2\u6d41\u91cf\u5305\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        carrier String \u5426 \u8fd0\u8425\u5546ID \u4f20\u5165\u8be5\u53c2\u6570\u5219\u83b7\u53d6\u6307\u5b9a\u8fd0\u8425\u5546\u7684\u6d41\u91cf\u5305\uff0c \u5426\u5219\u83b7\u53d6\u6240\u6709\u8fd0\u8425\u5546\u7684\u6d41\u91cf\u5305 \u79fb\u52a8\uff1a10086 \u8054\u901a\uff1a10010 \u7535\u4fe1\uff1a10000\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        param = {} if param is None else param\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp[FLOW_PACKAGE] if FLOW_PACKAGE in rsp else None, VERSION_V2:rsp}[self.version()])\n        return self.path('get_package.json').post(param, h, r)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef recharge(self, param, must=[APIKEY, MOBILE, SN]):\n        '''\u5145\u503c\u6d41\u91cf\n        \n        \u53c2\u6570\u540d \u7c7b\u578b \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey String \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        mobile String \u662f \u63a5\u6536\u7684\u624b\u673a\u53f7\uff08\u4ec5\u652f\u6301\u5927\u9646\u53f7\u7801\uff09 15205201314\n        sn String \u662f \u6d41\u91cf\u5305\u7684\u552f\u4e00ID \u70b9\u51fb\u67e5\u770b 1008601\n        callback_url String \u5426 \u672c\u6761\u6d41\u91cf\u5145\u503c\u7684\u72b6\u6001\u62a5\u544a\u63a8\u9001\u5730\u5740 http://your_receive_url_address\n        encrypt String \u5426 \u52a0\u5bc6\u65b9\u5f0f \u4f7f\u7528\u52a0\u5bc6 tea (\u4e0d\u518d\u4f7f\u7528)\n        _sign String \u5426 \u7b7e\u540d\u5b57\u6bb5 \u53c2\u8003\u4f7f\u7528\u52a0\u5bc6 393d079e0a00912335adfe46f4a2e10f (\u4e0d\u518d\u4f7f\u7528)\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp[RESULT] if RESULT in rsp else None, VERSION_V2:rsp}[self.version()])\n        return self.path('recharge.json').post(param, h, r)", "response": "recharge a user s log entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the status of a specific resource from the server.", "response": "def pull_status(self, param=None, must=[APIKEY]):\n        '''\u83b7\u53d6\u72b6\u6001\u62a5\u544a\n        \n        \u53c2\u6570\u540d \u662f\u5426\u5fc5\u987b \u63cf\u8ff0 \u793a\u4f8b\n        apikey \u662f \u7528\u6237\u552f\u4e00\u6807\u8bc6 9b11127a9701975c734b8aee81ee3526\n        page_size \u5426 \u6bcf\u9875\u4e2a\u6570\uff0c\u6700\u5927100\u4e2a\uff0c\u9ed8\u8ba420\u4e2a 20\n        \n        Args:\n            param:\n        Results:\n            Result\n        '''\n        param = {} if param is None else param\n        r = self.verify_param(param, must)\n        if not r.is_succ():\n            return r\n        h = CommonResultHandler(lambda rsp: {VERSION_V1:rsp[FLOW_STATUS] if FLOW_STATUS in rsp else None, VERSION_V2:rsp}[self.version()])\n        return self.path('pull_status.json').post(param, h, r)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a command and returns the return info.", "response": "def run_command(*args, raise_exception=True, cwd=None):\n    '''\n    Runs a command, piping all output to the DMP log.\n    The args should be separate arguments so paths and subcommands can have spaces in them:\n\n        ret = run_command('ls', '-l', '/Users/me/My Documents')\n        print(ret.code)\n        print(ret.stdout)\n        print(ret.stderr)\n\n    On Windows, the PATH is not followed.  This can be overcome with:\n\n        import shutil\n        run_command(shutil.which('program'), '-l', '/Users/me/My Documents')\n    '''\n    args = [ str(a) for a in args ]\n    log.info('running %s', ' '.join(args))\n    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, cwd=cwd)\n    stdout, stderr = p.communicate()\n    returninfo = ReturnInfo(p.returncode, stdout.decode('utf8'), stderr.decode('utf8'))\n    if stdout:\n        log.info('%s', returninfo.stdout)\n    if raise_exception and returninfo.code != 0:\n        raise CommandError(' '.join(args), returninfo)\n    return returninfo"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a *Django * API template object for the given template name.", "response": "def get_template(self, template, def_name=None):\n        '''Retrieve a *Django* API template object for the given template name, using the app_path and template_subdir\n           settings in this object.  This method still uses the corresponding Mako template and engine, but it\n           gives a Django API wrapper around it so you can use it the same as any Django template.\n\n           If def_name is provided, template rendering will be limited to the named def/block (see Mako docs).\n\n           This method corresponds to the Django templating system API.\n           A Django exception is raised if the template is not found or cannot compile.\n        '''\n        try:\n            # wrap the mako template in an adapter that gives the Django template API\n            return MakoTemplateAdapter(self.get_mako_template(template), def_name)\n\n        except (TopLevelLookupException, TemplateLookupException) as e: # Mako exception raised\n            tdne = TemplateDoesNotExist('Template \"%s\" not found in search path: %s.' % (template, self.template_search_dirs))\n            if settings.DEBUG:\n                tdne.template_debug = get_template_debug(template, e)\n            raise tdne from e\n\n        except (CompileException, SyntaxException) as e: # Mako exception raised\n            tse = TemplateSyntaxError('Template \"%s\" raised an error: %s' % (template, e))\n            if settings.DEBUG:\n                tse.template_debug = get_template_debug(template, e)\n            raise tse from e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the real Mako template object for the given template name without any wrapper.", "response": "def get_mako_template(self, template, force=False):\n        '''Retrieve the real *Mako* template object for the given template name without any wrapper,\n           using the app_path and template_subdir settings in this object.\n\n           This method is an alternative to get_template().  Use it when you need the actual Mako template object.\n           This method raises a Mako exception if the template is not found or cannot compile.\n\n           If force is True, an empty Mako template will be created when the file does not exist.\n           This option is used by the providers part of DMP and normally be left False.\n        '''\n        if template is None:\n            raise TemplateLookupException('Template \"%s\" not found in search path: %s.' % (template, self.template_search_dirs))\n        # get the template\n        try:\n            template_obj = self.tlookup.get_template(template)\n        except TemplateLookupException:\n            if not force:\n                raise\n            template_obj = Template('', filename=os.path.join(self.template_dir, template))\n\n        # get the template\n        return template_obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef app_resolver(app_name=None, pattern_kwargs=None, name=None):\n    '''\n    Registers the given app_name with DMP and adds convention-based\n    url patterns for it.\n\n    This function is meant to be called in a project's urls.py.\n    '''\n    urlconf = URLConf(app_name, pattern_kwargs)\n    resolver = re_path(\n        '^{}/?'.format(app_name) if app_name is not None else '',\n        include(urlconf),\n        name=urlconf.app_name,\n    )\n    # this next line is a workaround for Django's URLResolver class not having\n    # a `name` attribute, which is expected in Django's technical_404.html.\n    resolver.name = getattr(resolver, 'name', name or app_name)\n    return resolver", "response": "Returns a new URLResolver instance that can be used to resolve the given app_name with DMP."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dmp_paths_for_app(app_name, pattern_kwargs=None, pretty_app_name=None):\n    '''Utility function that creates the default patterns for an app'''\n    dmp = apps.get_app_config('django_mako_plus')\n    # Because these patterns are subpatterns within the app's resolver,\n    # we don't include the /app/ in the pattern -- it's already been\n    # handled by the app's resolver.\n    #\n    # Also note how the each pattern below defines the four kwargs--\n    # either as 1) a regex named group or 2) in kwargs.\n    return [\n        # page.function/urlparams\n        dmp_path(\n            r'^(?P<dmp_page>[_a-zA-Z0-9\\-]+)\\.(?P<dmp_function>[_a-zA-Z0-9\\.\\-]+)/(?P<dmp_urlparams>.+?)/?$',\n            merge_dicts({\n                'dmp_app': app_name or dmp.options['DEFAULT_APP'],\n            }, pattern_kwargs),\n            'DMP /{}/page.function/urlparams'.format(pretty_app_name),\n            app_name,\n        ),\n\n        # page.function\n        dmp_path(\n            r'^(?P<dmp_page>[_a-zA-Z0-9\\-]+)\\.(?P<dmp_function>[_a-zA-Z0-9\\.\\-]+)/?$',\n            merge_dicts({\n                'dmp_app': app_name or dmp.options['DEFAULT_APP'],\n                'dmp_urlparams': '',\n            }, pattern_kwargs),\n            'DMP /{}/page.function'.format(pretty_app_name),\n            app_name,\n        ),\n\n        # page/urlparams\n        dmp_path(\n            r'^(?P<dmp_page>[_a-zA-Z0-9\\-]+)/(?P<dmp_urlparams>.+?)/?$',\n            merge_dicts({\n                'dmp_app': app_name or dmp.options['DEFAULT_APP'],\n                'dmp_function': 'process_request',\n            }, pattern_kwargs),\n            'DMP /{}/page/urlparams'.format(pretty_app_name),\n            app_name,\n        ),\n\n        # page\n        dmp_path(\n            r'^(?P<dmp_page>[_a-zA-Z0-9\\-]+)/?$',\n            merge_dicts({\n                'dmp_app': app_name or dmp.options['DEFAULT_APP'],\n                'dmp_function': 'process_request',\n                'dmp_urlparams': '',\n            }, pattern_kwargs),\n            'DMP /{}/page'.format(pretty_app_name),\n            app_name,\n        ),\n\n        # empty\n        dmp_path(\n            r'^$',\n            merge_dicts({\n                'dmp_app': app_name or dmp.options['DEFAULT_APP'],\n                'dmp_function': 'process_request',\n                'dmp_urlparams': '',\n                'dmp_page': dmp.options['DEFAULT_PAGE'],\n            }, pattern_kwargs),\n            'DMP /{}'.format(pretty_app_name),\n            app_name,\n        ),\n    ]", "response": "Utility function that creates the default patterns for an app"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dmp_path(regex, kwargs=None, name=None, app_name=None):\n    '''\n    Creates a DMP-style, convention-based pattern that resolves\n    to various view functions based on the 'dmp_page' value.\n\n    The following should exist as 1) regex named groups or\n    2) items in the kwargs dict:\n        dmp_app         Should resolve to a name in INSTALLED_APPS.\n                        If missing, defaults to DEFAULT_APP.\n        dmp_page        The page name, which should resolve to a module:\n                        project_dir/{dmp_app}/views/{dmp_page}.py\n                        If missing, defaults to DEFAULT_PAGE.\n        dmp_function    The function name (or View class name) within the module.\n                        If missing, defaults to 'process_request'\n        dmp_urlparams   The urlparams string to parse.\n                        If missing, defaults to ''.\n\n    The reason for this convenience function is to be similar to\n    Django functions like url(), re_path(), and path().\n    '''\n    return PagePattern(regex, kwargs, name, app_name)", "response": "Creates a DMP - style convention - based pattern that resolves the URL of the current page."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef alternate_syntax(local, using, **kwargs):\n    '''\n    A Mako filter that renders a block of text using a different template engine\n    than Mako.  The named template engine must be listed in settings.TEMPLATES.\n\n    The template context variables are available in the embedded template.\n    Specify kwargs to add additional variables created within the template.\n\n    This is a kludge that should be used sparingly. The `dmp_include` template tag\n    is often a better option.\n\n    The following examples assume you have installed the django_mustache template\n    engine in settings.py:\n\n        ## Simple expression in Mustache syntax:\n        ${ '{{ name }}' | template_syntax(local, 'django_mustache') }\n\n        ## Embedded Mustache code block:\n        <%block filter=\"template_syntax(local, 'django_mustache')\">\n            {{#repo}}\n                <b>{{name}}</b>\n            {{/repo}}\n            {{^repo}}\n                No repos :(\n            {{/repo}}\n        </%block>\n\n    Rendering Django or Jinja2 templates should be done with `django_syntax` and\n    `jinja2_syntax` because it doesn't require the using parameter.\n    '''\n    # get the request (the MakoTemplateAdapter above places this in the context)\n    request = local.context['request'] if isinstance(local.context, RequestContext) else None\n    # get the current Mako template object so we can attach the compiled string for later use\n    # Mako caches and automatically recreates this if the file changes\n    mako_template = local.template\n    if not hasattr(mako_template, '__compiled_template_syntax'):\n        mako_template.__compiled_template_syntax = {}\n\n    # create a closure so we can still get to context and using (Mako filters take exactly one parameter: the string to filter)\n    def wrap(template_st):\n        # get the template object, or create and cache it\n        try:\n            template = mako_template.__compiled_template_syntax[template_st]\n        except KeyError:\n            engine = engines[using]\n            template = engine.from_string(template_st)\n            # using full string, even if long, as the key doesn't really affect performance of python's hash (see http://stackoverflow.com/questions/28150047/efficiency-of-long-str-keys-in-python-dictionary)\n            mako_template.__compiled_template_syntax[template_st] = template\n\n        # create a copy the context and add any kwargs to it\n        dcontext = dict(local.context)\n        dcontext.update(kwargs)\n\n        # print a debug statement to the log\n        log.debug('rendering embedded expression or block using %s template engine', using)\n\n        # render the template with the context\n        return template.render(context=dcontext, request=request)\n\n    # return the embedded function\n    return wrap", "response": "A filter that renders a block of text using a different template engine than Mako."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_view_function(module_name, function_name, fallback_app=None, fallback_template=None, verify_decorator=True):\n    '''\n    Retrieves a view function from the cache, finding it if the first time.\n    Raises ViewDoesNotExist if not found.  This is called by resolver.py.\n    '''\n    # first check the cache (without doing locks)\n    key = ( module_name, function_name )\n    try:\n        return CACHED_VIEW_FUNCTIONS[key]\n    except KeyError:\n        with rlock:\n            # try again now that we're locked\n            try:\n                return CACHED_VIEW_FUNCTIONS[key]\n            except KeyError:\n                # if we get here, we need to load the view function\n                func = find_view_function(module_name, function_name, fallback_app, fallback_template, verify_decorator)\n                # cache in production mode\n                if not settings.DEBUG:\n                    CACHED_VIEW_FUNCTIONS[key] = func\n                return func\n\n    # the code should never be able to get here\n    raise Exception(\"Django-Mako-Plus error: get_view_function() should not have been able to get to this point.  Please notify the owner of the DMP project.  Thanks.\")", "response": "Returns a view function from the cache if the first time. Raises ViewDoesNotExist if not found."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a view function in a module.", "response": "def find_view_function(module_name, function_name, fallback_app=None, fallback_template=None, verify_decorator=True):\n    '''\n    Finds a view function, class-based view, or template view.\n    Raises ViewDoesNotExist if not found.\n    '''\n    dmp = apps.get_app_config('django_mako_plus')\n\n    # I'm first calling find_spec first here beacuse I don't want import_module in\n    # a try/except -- there are lots of reasons that importing can fail, and I just want to\n    # know whether the file actually exists.  find_spec raises AttributeError if not found.\n    try:\n        spec = find_spec(module_name)\n    except ValueError:\n        spec = None\n    if spec is None:\n        # no view module, so create a view function that directly renders the template\n        try:\n            return create_view_for_template(fallback_app, fallback_template)\n        except TemplateDoesNotExist as e:\n            raise ViewDoesNotExist('view module {} not found, and fallback template {} could not be loaded ({})'.format(module_name, fallback_template, e))\n\n    # load the module and function\n    try:\n        module = import_module(module_name)\n        func = getattr(module, function_name)\n        func.view_type = 'function'\n    except ImportError as e:\n        raise ViewDoesNotExist('module \"{}\" could not be imported: {}'.format(module_name, e))\n    except AttributeError as e:\n        raise ViewDoesNotExist('module \"{}\" found successfully, but \"{}\" was not found: {}'.format(module_name, function_name, e))\n\n    # if class-based view, call as_view() to get a view function to it\n    if inspect.isclass(func) and issubclass(func, View):\n        func = func.as_view()\n        func.view_type = 'class'\n\n    # if regular view function, check the decorator\n    elif verify_decorator and not view_function.is_decorated(func):\n        raise ViewDoesNotExist(\"view {}.{} was found successfully, but it must be decorated with @view_function or be a subclass of django.views.generic.View.\".format(module_name, function_name))\n\n    # attach a converter to the view function\n    if dmp.options['PARAMETER_CONVERTER'] is not None:\n        try:\n            converter = import_qualified(dmp.options['PARAMETER_CONVERTER'])(func)\n            setattr(func, CONVERTER_ATTRIBUTE_NAME, converter)\n        except ImportError as e:\n            raise ImproperlyConfigured('Cannot find PARAMETER_CONVERTER: {}'.format(str(e)))\n\n    # return the function/class\n    return func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a view function for templates.", "response": "def create_view_for_template(app_name, template_name):\n    '''\n    Creates a view function for templates (used whe a view.py file doesn't exist but the .html does)\n    Raises TemplateDoesNotExist if the template doesn't exist.\n    '''\n    # ensure the template exists\n    apps.get_app_config('django_mako_plus').engine.get_template_loader(app_name).get_template(template_name)\n    # create the view function\n    def template_view(request, *args, **kwargs):\n        # not caching the template object (getting it each time) because Mako has its own cache\n        dmp = apps.get_app_config('django_mako_plus')\n        template = dmp.engine.get_template_loader(app_name).get_template(template_name)\n        return template.render_to_response(request=request, context=kwargs)\n    template_view.view_type = 'template'\n    return template_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_related(self):\n        '''\n        Generator function that iterates this object's related providers,\n        which includes this provider.\n        '''\n        for tpl in self.provider_run.templates:\n            yield tpl.providers[self.index]", "response": "Generator function that iterates this object s related providers and returns each of them"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cache_item(self):\n        '''Gets the cached item. Raises AttributeError if it hasn't been set.'''\n        if settings.DEBUG:\n            raise AttributeError('Caching disabled in DEBUG mode')\n        return getattr(self.template, self.options['template_cache_key'])", "response": "Gets the cached item. Raises AttributeError if it hasn t been set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten(*args):\n    '''Generator that recursively flattens embedded lists, tuples, etc.'''\n    for arg in args:\n        if isinstance(arg, collections.Iterable) and not isinstance(arg, (str, bytes)):\n            yield from flatten(*arg)\n        else:\n            yield arg", "response": "Generator that recursively flattens embedded lists tuples etc."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the CRC checksum for a file.", "response": "def crc32(filename):\n    '''\n    Calculates the CRC checksum for a file.\n    Using CRC32 because security isn't the issue and don't need perfect noncollisions.\n    We just need to know if a file has changed.\n\n    On my machine, crc32 was 20 times faster than any hashlib algorithm,\n    including blake and md5 algorithms.\n    '''\n    result = 0\n    with open(filename, 'rb') as fin:\n        while True:\n            chunk = fin.read(48)\n            if len(chunk) == 0:\n                break\n            result = zlib.crc32(chunk, result)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compile_mako_files(self, app_config):\n        '''Compiles the Mako templates within the apps of this system'''\n        # go through the files in the templates, scripts, and styles directories\n        for subdir_name in self.SEARCH_DIRS:\n            subdir = subdir_name.format(\n                app_path=app_config.path,\n                app_name=app_config.name,\n            )\n\n            def recurse_path(path):\n                self.message('searching for Mako templates in {}'.format(path), 1)\n                if os.path.exists(path):\n                    for filename in os.listdir(path):\n                        filepath = os.path.join(path, filename)\n                        _, ext = os.path.splitext(filename)\n                        if filename.startswith('__'):  # __dmpcache__, __pycache__\n                            continue\n\n                        elif os.path.isdir(filepath):\n                            recurse_path(filepath)\n\n                        elif ext.lower() in ( '.htm', '.html', '.mako' ):\n                            # create the template object, which creates the compiled .py file\n                            self.message('compiling {}'.format(filepath), 2)\n                            try:\n                                get_template_for_path(filepath)\n                            except TemplateSyntaxError:\n                                if not self.options.get('ignore_template_errors'):\n                                    raise\n\n            recurse_path(subdir)", "response": "Compiles the Mako templates within the apps of this system"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_string(self, template_code):\n        '''\n        Compiles a template from the given string.\n        This is one of the required methods of Django template engines.\n        '''\n        dmp = apps.get_app_config('django_mako_plus')\n        mako_template = Template(template_code, imports=dmp.template_imports, input_encoding=dmp.options['DEFAULT_TEMPLATE_ENCODING'])\n        return MakoTemplateAdapter(mako_template)", "response": "Returns a MakoTemplateAdapter instance from the given string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a template object from the pattern app_name / template. html.", "response": "def get_template(self, template_name):\n        '''\n        Retrieves a template object from the pattern \"app_name/template.html\".\n        This is one of the required methods of Django template engines.\n\n        Because DMP templates are always app-specific (Django only searches\n        a global set of directories), the template_name MUST be in the format:\n        \"app_name/template.html\" (even on Windows).  DMP splits the template_name\n        string on the slash to get the app name and template name.\n\n        Template rendering can be limited to a specific def/block within the template\n        by specifying `#def_name`, e.g. `myapp/mytemplate.html#myblockname`.\n        '''\n        dmp = apps.get_app_config('django_mako_plus')\n        match = RE_TEMPLATE_NAME.match(template_name)\n        if match is None or match.group(1) is None or match.group(3) is None:\n            raise TemplateDoesNotExist('Invalid template_name format for a DMP template.  This method requires that the template name be in app_name/template.html format (separated by slash).')\n        if not dmp.is_registered_app(match.group(1)):\n            raise TemplateDoesNotExist('Not a DMP app, so deferring to other template engines for this template')\n        return self.get_template_loader(match.group(1)).get_template(match.group(3), def_name=match.group(5))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a template loader object for the given app and subdirectory.", "response": "def get_template_loader(self, app, subdir='templates', create=False):\n        '''\n        Returns a template loader object for the given app name in the given subdir.\n        For example, get_template_loader('homepage', 'styles') will return\n        a loader for the styles/ directory in the homepage app.\n\n        The app parameter can be either an app name or an AppConfig instance.\n        The subdir parameter is normally 'templates', 'scripts', or 'styles',\n        but it can be any subdirectory name of the given app.\n\n        Normally, you should not have to call this method.  Django automatically\n        generates two shortcut functions for every DMP-registered apps,\n        and these shortcut functions are the preferred way to render templates.\n\n        This method is useful when you want a custom template loader to a directory\n        that does not conform to the app_dir/templates/* pattern.\n\n        If the loader is not found in the DMP cache, one of two things occur:\n          1. If create=True, it is created automatically and returned.  This overrides\n             the need to register the app as a DMP app.\n          2. If create=False, a TemplateDoesNotExist is raised.  This is the default\n             behavior.\n        '''\n        # ensure we have an AppConfig\n        if app is None:\n            raise TemplateDoesNotExist(\"Cannot locate loader when app is None\")\n        if not isinstance(app, AppConfig):\n            app = apps.get_app_config(app)\n\n        # get the loader with the path of this app+subdir\n        path = os.path.join(app.path, subdir)\n\n        # if create=False, the loader must already exist in the cache\n        if not create:\n            dmp = apps.get_app_config('django_mako_plus')\n            if not dmp.is_registered_app(app):\n                raise ValueError(\"{} is not registered with DMP [hint: check urls.py for include('django_mako_plus.urls')].\".format(app))\n\n        # return the template by path\n        return self.get_template_loader_for_path(path, use_cache=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a template loader object for the given path.", "response": "def get_template_loader_for_path(self, path, use_cache=True):\n        '''\n        Returns a template loader object for the given directory path.\n        For example, get_template_loader('/var/mytemplates/') will return\n        a loader for that specific directory.\n\n        Normally, you should not have to call this method.  Django automatically\n        adds request.dmp.render() and request.dmp.render_to_string() on each\n        request.\n\n        This method is useful when you want a custom template loader for a specific\n        directory that may be outside your project directory or that is otherwise\n        not contained in a normal Django app.  If the directory is inside an app,\n        call get_template_loader() instead.\n\n        Unless use_cache=False, this method caches template loaders in the DMP\n        cache for later use.\n        '''\n        # get from the cache if we are able\n        if use_cache:\n            try:\n                return self.template_loaders[path]\n            except KeyError:\n                pass  # not there, so we'll create\n\n        # create the loader\n        loader = MakoTemplateLoader(path, None)\n\n        # cache if we are allowed\n        if use_cache:\n            self.template_loaders[path] = loader\n\n        # return\n        return loader"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntrigger by the converter_function decorator", "response": "def _register_converter(cls, conv_func, conv_type):\n        '''Triggered by the @converter_function decorator'''\n        cls.converters.append(ConverterFunctionInfo(conv_func, conv_type, len(cls.converters)))\n        cls._sort_converters()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _sort_converters(cls, app_ready=False):\n        '''Sorts the converter functions'''\n        # app_ready is True when called from DMP's AppConfig.ready()\n        # we can't sort before then because models aren't ready\n        cls._sorting_enabled = cls._sorting_enabled or app_ready\n        if cls._sorting_enabled:\n            for converter in cls.converters:\n                converter.prepare_sort_key()\n            cls.converters.sort(key=attrgetter('sort_key'))", "response": "Sorts the converter functions"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_parameters(self, request, *args, **kwargs):\n        '''\n        Iterates the urlparams and converts them according to the\n        type hints in the current view function.  This is the primary\n        function of the class.\n        '''\n        args = list(args)\n        urlparam_i = 0\n\n        parameters = self.view_parameters.get(request.method.lower()) or self.view_parameters.get(None)\n        if parameters is not None:\n            # add urlparams into the arguments and convert the values\n            for parameter_i, parameter in enumerate(parameters):\n                # skip request object, *args, **kwargs\n                if parameter_i == 0 or parameter.kind is inspect.Parameter.VAR_POSITIONAL or parameter.kind is inspect.Parameter.VAR_KEYWORD:\n                    pass\n                # value in kwargs?\n                elif parameter.name in kwargs:\n                    kwargs[parameter.name] = self.convert_value(kwargs[parameter.name], parameter, request)\n                # value in args?\n                elif parameter_i - 1 < len(args):\n                    args[parameter_i - 1] = self.convert_value(args[parameter_i - 1], parameter, request)\n                # urlparam value?\n                elif urlparam_i < len(request.dmp.urlparams):\n                    kwargs[parameter.name] = self.convert_value(request.dmp.urlparams[urlparam_i], parameter, request)\n                    urlparam_i += 1\n                # can we assign a default value?\n                elif parameter.default is not inspect.Parameter.empty:\n                    kwargs[parameter.name] = self.convert_value(parameter.default, parameter, request)\n                # fallback is None\n                else:\n                    kwargs[parameter.name] = self.convert_value(None, parameter, request)\n\n        return args, kwargs", "response": "This function converts the urlparams of the current view function into the arguments and kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a value from the request object to the parameter object.", "response": "def convert_value(self, value, parameter, request):\n        '''\n        Converts a parameter value in the view function call.\n\n            value:      value from request.dmp.urlparams to convert\n                        The value will always be a string, even if empty '' (never None).\n\n            parameter:  an instance of django_mako_plus.ViewParameter that holds this parameter's\n                        name, type, position, etc.\n\n            request:    the current request object.\n\n        \"converter functions\" register with this class using the @parameter_converter\n        decorator.  See converters.py for the built-in converters.\n\n        This function goes through the list of registered converter functions,\n        selects the most-specific one that matches the parameter.type, and\n        calls it to convert the value.\n\n        If the converter function raises a ValueError, it is caught and\n        switched to an Http404 to tell the browser that the requested URL\n        doesn't resolve to a page.\n\n        Other useful exceptions that converter functions can raise are:\n\n            Any extension of BaseRedirectException (RedirectException,\n                InternalRedirectException, JavascriptRedirectException, ...)\n            Http404: returns a Django Http404 response\n        '''\n        try:\n            # we don't convert anything without type hints\n            if parameter.type is inspect.Parameter.empty:\n                if log.isEnabledFor(logging.DEBUG):\n                    log.debug('skipping conversion of parameter `%s` because it has no type hint', parameter.name)\n                return value\n\n            # find the converter method for this type\n            # I'm iterating through the list to find the most specific match first\n            # The list is sorted by specificity so subclasses come before their superclasses\n            for ci in self.converters:\n                if issubclass(parameter.type, ci.convert_type):\n                    if log.isEnabledFor(logging.DEBUG):\n                        log.debug('converting parameter `%s` using %s', parameter.name, ci.convert_func)\n                    return ci.convert_func(value, parameter)\n\n            # if we get here, there wasn't a converter or this type\n            raise ImproperlyConfigured(message='No parameter converter exists for type: {}. Do you need to add an @parameter_converter function for the type?'.format(parameter.type))\n\n        except (BaseRedirectException, Http404):\n            log.info('Exception raised during conversion of parameter %s (%s): %s', parameter.position, parameter.name, e)\n            raise   # allow these to pass through to the router\n\n        except ValueError as e:\n            log.info('ValueError raised during conversion of parameter %s (%s): %s', parameter.position, parameter.name, e)\n            raise ConverterHttp404(value, parameter, 'A parameter could not be converted - see the logs for more detail') from e\n\n        except Exception as e:\n            log.info('Exception raised during conversion of parameter %s (%s): %s', parameter.position, parameter.name, e)\n            raise ConverterException(value, parameter, 'A parameter could not be converted - see the logs for more detail') from e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an entry file for the given script map and enapps.", "response": "def create_entry_file(self, filename, script_map, enapps):\n        '''Creates an entry file for the given script map'''\n        if len(script_map) == 0:\n            return\n\n        # create the entry file\n        template = MakoTemplate('''\n<%! import os %>\n// dynamic imports are within functions so they don't happen until called\nDMP_CONTEXT.loadBundle({\n    %for (app, template), script_paths in script_map.items():\n\n    \"${ app }/${ template }\": () => [\n        %for path in script_paths:\n        import(/* webpackMode: \"eager\" */ \"./${ os.path.relpath(path, os.path.dirname(filename)) }\"),\n        %endfor\n    ],\n    %endfor\n\n})\n''')\n        content = template.render(\n            enapps=enapps,\n            script_map=script_map,\n            filename=filename,\n        ).strip()\n\n        # ensure the parent directories exist\n        if not os.path.exists(os.path.dirname(filename)):\n            os.makedirs(os.path.dirname(filename))\n\n        # if the file exists, then consider the options\n        file_exists = os.path.exists(filename)\n        if file_exists and self.running_inline:\n            # running inline means that we're in debug mode and webpack is likely watching, so\n            # we don't want to recreate the entry file (and cause webpack to constantly reload)\n            # unless we have changes\n            with open(filename, 'r') as fin:\n                if content == fin.read():\n                    return False\n        if file_exists and not self.options.get('overwrite'):\n            raise CommandError('Refusing to destroy existing file: {} (use --overwrite option or remove the file)'.format(filename))\n\n        # if we get here, write the file\n        self.message('Creating {}'.format(os.path.relpath(filename, settings.BASE_DIR)), level=3)\n        with open(filename, 'w') as fout:\n            fout.write(content)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmapping templates in this app to their scripts. This function deep searches app/templates/* for the templates of this app. Returns the following dictionary with absolute paths: { ( 'appname', 'template1' ): [ '/abs/path/to/scripts/template1.js', '/abs/path/to/scripts/supertemplate1.js' ], ( 'appname', 'template2' ): [ '/abs/path/to/scripts/template2.js', '/abs/path/to/scripts/supertemplate2.js', '/abs/path/to/scripts/supersuper2.js' ], ... } Any files or subdirectories starting with double-underscores (e.g. __dmpcache__) are skipped.", "response": "def generate_script_map(self, config):\n        '''\n        Maps templates in this app to their scripts.  This function deep searches\n        app/templates/* for the templates of this app.  Returns the following\n        dictionary with absolute paths:\n\n        {\n            ( 'appname', 'template1' ): [ '/abs/path/to/scripts/template1.js', '/abs/path/to/scripts/supertemplate1.js' ],\n            ( 'appname', 'template2' ): [ '/abs/path/to/scripts/template2.js', '/abs/path/to/scripts/supertemplate2.js', '/abs/path/to/scripts/supersuper2.js' ],\n            ...\n        }\n\n        Any files or subdirectories starting with double-underscores (e.g. __dmpcache__) are skipped.\n        '''\n        script_map = OrderedDict()\n        template_root = os.path.join(os.path.relpath(config.path, settings.BASE_DIR), 'templates')\n        def recurse(folder):\n            subdirs = []\n            if os.path.exists(folder):\n                for filename in os.listdir(folder):\n                    if filename.startswith('__'):\n                        continue\n                    filerel = os.path.join(folder, filename)\n                    if os.path.isdir(filerel):\n                        subdirs.append(filerel)\n\n                    elif os.path.isfile(filerel):\n                        template_name = os.path.relpath(filerel, template_root)\n                        scripts = self.template_scripts(config, template_name)\n                        key = ( config.name, os.path.splitext(template_name)[0] )\n                        self.message('Found template: {}; static files: {}'.format(key, scripts), level=3)\n                        script_map[key] = scripts\n\n            for subdir in subdirs:\n                recurse(subdir)\n\n        recurse(template_root)\n        return script_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef template_scripts(self, config, template_name):\n        '''\n        Returns a list of scripts used by the given template object AND its ancestors.\n\n        This runs a ProviderRun on the given template (as if it were being displayed).\n        This allows the WEBPACK_PROVIDERS to provide the JS files to us.\n        '''\n        dmp = apps.get_app_config('django_mako_plus')\n        template_obj = dmp.engine.get_template_loader(config, create=True).get_mako_template(template_name, force=True)\n        mako_context = create_mako_context(template_obj)\n        inner_run = WebpackProviderRun(mako_context['self'])\n        inner_run.run()\n        scripts = []\n        for tpl in inner_run.templates:\n            for p in tpl.providers:\n                if os.path.exists(p.absfilepath):\n                    scripts.append(p.absfilepath)\n        return scripts", "response": "Returns a list of scripts used by the given template object AND its ancestors."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_response(self, request, *args, **kwargs):\n        '''Returns the redirect response for this exception.'''\n        # normal process\n        response = HttpResponseRedirect(self.redirect_to)\n        response[REDIRECT_HEADER_KEY] = self.redirect_to\n        return response", "response": "Returns the redirect response for this exception."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the redirect response for this exception.", "response": "def get_response(self, request):\n        '''Returns the redirect response for this exception.'''\n        # the redirect key is already placed in the response by HttpResponseJavascriptRedirect\n        return HttpResponseJavascriptRedirect(self.redirect_to, *self.args, **self.kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a template loader instance for the given app.", "response": "def get_template_loader(app, subdir='templates'):\n    '''\n    Convenience method that calls get_template_loader() on the DMP\n    template engine instance.\n    '''\n    dmp = apps.get_app_config('django_mako_plus')\n    return dmp.engine.get_template_loader(app, subdir, create=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a template loader for the given path.", "response": "def get_template_loader_for_path(path, use_cache=True):\n    '''\n    Convenience method that calls get_template_loader_for_path() on the DMP\n    template engine instance.\n    '''\n    dmp = apps.get_app_config('django_mako_plus')\n    return dmp.engine.get_template_loader_for_path(path, use_cache)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qualified_name(obj):\n    '''Returns the fully-qualified name of the given object'''\n    if not hasattr(obj, '__module__'):\n        obj = obj.__class__\n    module = obj.__module__\n    if module is None or module == str.__class__.__module__:\n        return obj.__qualname__\n    return '{}.{}'.format(module, obj.__qualname__)", "response": "Returns the fully - qualified name of the given object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimport a fully - qualified name from a module.", "response": "def import_qualified(name):\n    '''\n    Imports a fully-qualified name from a module:\n\n        cls = import_qualified('homepage.views.index.MyForm')\n\n    Raises an ImportError if it can't be ipmorted.\n    '''\n    parts = name.rsplit('.', 1)\n    if len(parts) != 2:\n        raise ImportError('Invalid fully-qualified name: {}'.format(name))\n    try:\n        return getattr(import_module(parts[0]), parts[1])\n    except AttributeError:\n        raise ImportError('{} not found in module {}'.format(parts[1], parts[0]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the HTML for the given provider group or all groups.", "response": "def links(tself, group=None):\n    '''Returns the HTML for the given provider group (or all groups if None)'''\n    pr = ProviderRun(tself, group)\n    pr.run()\n    return mark_safe(pr.getvalue())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the HTML for the given provider group using an app and template name.", "response": "def template_links(request, app, template_name, context=None, group=None, force=True):\n    '''\n    Returns the HTML for the given provider group, using an app and template name.\n    This method should not normally be used (use links() instead).  The use of\n    this method is when provider need to be called from regular python code instead\n    of from within a rendering template environment.\n    '''\n    if isinstance(app, str):\n        app = apps.get_app_config(app)\n    if context is None:\n        context = {}\n    dmp = apps.get_app_config('django_mako_plus')\n    template_obj = dmp.engine.get_template_loader(app, create=True).get_mako_template(template_name, force=force)\n    return template_obj_links(request, template_obj, context, group)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef template_obj_links(request, template_obj, context=None, group=None):\n    '''\n    Returns the HTML for the given provider group, using a template object.\n    This method should not normally be used (use links() instead).  The use of\n    this method is when provider need to be called from regular python code instead\n    of from within a rendering template environment.\n    '''\n    # the template_obj can be a MakoTemplateAdapter or a Mako Template\n    # if our DMP-defined MakoTemplateAdapter, switch to the embedded Mako Template\n    template_obj = getattr(template_obj, 'mako_template', template_obj)\n    # create a mako context so it seems like we are inside a render\n    context_dict = {\n        'request': request,\n    }\n    if isinstance(context, Context):\n        for d in context:\n            context_dict.update(d)\n    elif context is not None:\n        context_dict.update(context)\n    mako_context = create_mako_context(template_obj, **context_dict)\n    return links(mako_context['self'], group=group)", "response": "Returns the HTML for the given provider group using a template object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls when link is not defined in the settings", "response": "def build_default_link(self):\n        '''Called when 'link' is not defined in the settings'''\n        attrs = {}\n        attrs[\"rel\"] = \"stylesheet\"\n        attrs[\"href\"] =\"{}?{:x}\".format(\n            os.path.join(settings.STATIC_URL, self.filepath).replace(os.path.sep, '/'),\n            self.version_id,\n        )\n        attrs.update(self.options['link_attrs'])\n        attrs[\"data-context\"] = self.provider_run.uid       # can't be overridden\n        return '<link{} />'.format(flatatt(attrs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_default_filepath(self):\n        '''Called when 'filepath' is not defined in the settings'''\n        return os.path.join(\n            self.app_config.name,\n            'scripts',\n            self.template_relpath + '.js',\n        )", "response": "Called when filepath is not defined in the settings"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef django_include(context, template_name, **kwargs):\n    '''\n    Mako tag to include a Django template withing the current DMP (Mako) template.\n    Since this is a Django template, it is search for using the Django search\n    algorithm (instead of the DMP app-based concept).\n    See https://docs.djangoproject.com/en/2.1/topics/templates/.\n\n    The current context is sent to the included template, which makes all context\n    variables available to the Django template. Any additional kwargs are added\n    to the context.\n    '''\n    try:\n        djengine = engines['django']\n    except KeyError as e:\n        raise TemplateDoesNotExist(\"Django template engine not configured in settings, so template cannot be found: {}\".format(template_name)) from e\n    djtemplate = djengine.get_template(template_name)\n    djcontext = {}\n    djcontext.update(context)\n    djcontext.update(kwargs)\n    return djtemplate.render(djcontext, context['request'])", "response": "Include a Django template with the current context."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a relative path but only if it doesn t start with a pretty parent directory \"..\"", "response": "def pretty_relpath(path, start):\n    '''\n    Returns a relative path, but only if it doesn't start with a non-pretty parent directory \"..\"\n    '''\n    relpath = os.path.relpath(path, start)\n    if relpath.startswith('..'):\n        return path\n    return relpath"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_decorated(cls, f):\n        '''Returns True if the given function is decorated with @view_function'''\n        real_func = inspect.unwrap(f)\n        return real_func in cls.DECORATED_FUNCTIONS", "response": "Returns True if the given function is decorated with @view_function"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initialize_providers(cls):\n        '''Initializes the providers (called from dmp app ready())'''\n        dmp = apps.get_app_config('django_mako_plus')\n        # regular content providers\n        cls.CONTENT_PROVIDERS = []\n        for provider_settings in dmp.options[cls.SETTINGS_KEY]:\n            # import the class for this provider\n            assert 'provider' in provider_settings, \"Invalid entry in settings.py: CONTENT_PROVIDERS item must have 'provider' key\"\n            provider_cls = import_string(provider_settings['provider'])\n            # combine options from all of its bases, then from settings.py\n            options = {}\n            for base in reversed(inspect.getmro(provider_cls)):\n                options.update(getattr(base, 'DEFAULT_OPTIONS', {}))\n            options.update(provider_settings)\n            # add to the list\n            if options['enabled']:\n                pe = ProviderEntry(provider_cls, options)\n                pe.options['template_cache_key'] = '_dmp_provider_{}_'.format(id(pe))\n                cls.CONTENT_PROVIDERS.append(pe)", "response": "Initializes the providers ( called from dmp app ready"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms the run through the templates and their providers and passes the results to the user.", "response": "def run(self):\n        '''Performs the run through the templates and their providers'''\n        for tpl in self.templates:\n            for provider in tpl.providers:\n                provider.provide()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, content):\n        '''Provider instances use this to write to the buffer'''\n        self.buffer.write(content)\n        if settings.DEBUG:\n            self.buffer.write('\\n')", "response": "Write the content to the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares the sort key for the current locale.", "response": "def prepare_sort_key(self):\n        '''\n        Triggered by view_function._sort_converters when our sort key should be created.\n        This can't be called in the constructor because Django models might not be ready yet.\n        '''\n        if isinstance(self.convert_type, str):\n            try:\n                app_name, model_name = self.convert_type.split('.')\n            except ValueError:\n                raise ImproperlyConfigured('\"{}\" is not a valid converter type. String-based converter types must be specified in \"app.Model\" format.'.format(self.convert_type))\n            try:\n                self.convert_type = apps.get_model(app_name, model_name)\n            except LookupError as e:\n                raise ImproperlyConfigured('\"{}\" is not a valid model name. {}'.format(self.convert_type, e))\n\n        # we reverse sort by ( len(mro), source code order ) so subclasses match first\n        # on same types, last declared method sorts first\n        self.sort_key = ( -1 * len(inspect.getmro(self.convert_type)), -1 * self.source_order )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the command to run as a list ( see subprocess module )", "response": "def build_command(self):\n        '''Returns the command to run, as a list (see subprocess module)'''\n        # if defined in settings, run the function or return the string\n        if self.options['command']:\n            return self.options['command'](self) if callable(self.options['command']) else self.options['command']\n        # build the default\n        return self.build_default_command()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef needs_compile(self):\n        '''Returns True if self.sourcepath is newer than self.targetpath'''\n        try:\n            source_mtime = os.stat(self.sourcepath).st_mtime\n        except OSError:  # no source for this template, so just return\n            return False\n        try:\n            target_mtime = os.stat(self.targetpath).st_mtime\n        except OSError: # target doesn't exist, so compile\n            return True\n        # both source and target exist, so compile if source newer\n        return source_mtime > target_mtime", "response": "Returns True if self. sourcepath is newer than self. targetpath"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef template_inheritance(obj):\n    '''\n    Generator that iterates the template and its ancestors.\n    The order is from most specialized (furthest descendant) to\n    most general (furthest ancestor).\n\n    obj can be either:\n        1. Mako Template object\n        2. Mako `self` object (available within a rendering template)\n    '''\n    if isinstance(obj, MakoTemplate):\n        obj = create_mako_context(obj)['self']\n    elif isinstance(obj, MakoContext):\n        obj = obj['self']\n    while obj is not None:\n        yield obj.template\n        obj = obj.inherits", "response": "Generator that iterates the template and its ancestors."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_template_debug(template_name, error):\n    '''\n    This structure is what Django wants when errors occur in templates.\n    It gives the user a nice stack trace in the error page during debug.\n    '''\n    # This is taken from mako.exceptions.html_error_template(), which has an issue\n    # in Py3 where files get loaded as bytes but `lines = src.split('\\n')` below\n    # splits with a string. Not sure if this is a bug or if I'm missing something,\n    # but doing a custom debugging template allows a workaround as well as a custom\n    # DMP look.\n    # I used to have a file in the templates directory for this, but too many users\n    # reported TemplateNotFound errors. This function is a bit of a hack, but it only\n    # happens during development (and mako.exceptions does this same thing).\n    #   /justification\n    stacktrace_template = MakoTemplate(r\"\"\"\n<%! from mako.exceptions import syntax_highlight, pygments_html_formatter %>\n<style>\n    .stacktrace { margin:5px 5px 5px 5px; }\n    .highlight { padding:0px 10px 0px 10px; background-color:#9F9FDF; }\n    .nonhighlight { padding:0px; background-color:#DFDFDF; }\n    .sample { padding:10px; margin:10px 10px 10px 10px;\n                font-family:monospace; }\n    .sampleline { padding:0px 10px 0px 10px; }\n    .sourceline { margin:5px 5px 10px 5px; font-family:monospace;}\n    .location { font-size:80%; }\n    .highlight { white-space:pre; }\n    .sampleline { white-space:pre; }\n\n    % if pygments_html_formatter:\n        ${pygments_html_formatter.get_style_defs() | n}\n        .linenos { min-width: 2.5em; text-align: right; }\n        pre { margin: 0; }\n        .syntax-highlighted { padding: 0 10px; }\n        .syntax-highlightedtable { border-spacing: 1px; }\n        .nonhighlight { border-top: 1px solid #DFDFDF;\n                        border-bottom: 1px solid #DFDFDF; }\n        .stacktrace .nonhighlight { margin: 5px 15px 10px; }\n        .sourceline { margin: 0 0; font-family:monospace; }\n        .code { background-color: #F8F8F8; width: 100%; }\n        .error .code { background-color: #FFBDBD; }\n        .error .syntax-highlighted { background-color: #FFBDBD; }\n    % endif\n\n    ## adjustments to Django css\n    table.source {\n        background-color: #fdfdfd;\n    }\n    table.source > tbody > tr > th {\n        width: auto;\n    }\n    table.source > tbody > tr > td {\n        font-family: inherit;\n        white-space: normal;\n        padding: 15px;\n    }\n    #template {\n        background-color: #b3daff;\n    }\n\n</style>\n<%\n\n    src = tback.source\n    line = tback.lineno\n    if isinstance(src, bytes):\n        src = src.decode()\n    if src:\n        lines = src.split('\\n')\n    else:\n        lines = None\n%>\n<h3>${tback.errorname}: ${tback.message}</h3>\n\n% if lines:\n    <div class=\"sample\">\n    <div class=\"nonhighlight\">\n    % for index in range(max(0, line-4),min(len(lines), line+5)):\n        <%\n        if pygments_html_formatter:\n            pygments_html_formatter.linenostart = index + 1\n        %>\n        % if index + 1 == line:\n        <%\n        if pygments_html_formatter:\n            old_cssclass = pygments_html_formatter.cssclass\n            pygments_html_formatter.cssclass = 'error ' + old_cssclass\n        %>\n            ${lines[index] | n,syntax_highlight(language='mako')}\n        <%\n        if pygments_html_formatter:\n            pygments_html_formatter.cssclass = old_cssclass\n        %>\n        % else:\n            ${lines[index] | n,syntax_highlight(language='mako')}\n        % endif\n    % endfor\n    </div>\n    </div>\n% endif\n\n<div class=\"stacktrace\">\n% for (filename, lineno, function, line) in tback.reverse_traceback:\n    <div class=\"location\">${filename}, line ${lineno}:</div>\n    <div class=\"nonhighlight\">\n    <%\n       if pygments_html_formatter:\n           pygments_html_formatter.linenostart = lineno\n    %>\n        <div class=\"sourceline\">${line | n,syntax_highlight(filename)}</div>\n    </div>\n% endfor\n</div>\n\"\"\")\n    tback = RichTraceback(error, error.__traceback__)\n    lines = stacktrace_template.render_unicode(tback=tback)\n    return {\n        'message': '',\n        'source_lines': [\n            ( '', mark_safe(lines) ),\n        ],\n        'before': '',\n        'during': '',\n        'after': '',\n        'top': 0,\n        'bottom': 0,\n        'total': 0,\n        'line': tback.lineno or 0,\n        'name': template_name,\n        'start': 0,\n        'end': 0,\n    }", "response": "Returns a MakoTemplate object that can be used to debug the error page."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the name of this template if created from a file or string if not", "response": "def name(self):\n        '''Returns the name of this template (if created from a file) or \"string\" if not'''\n        if self.mako_template.filename:\n            return os.path.basename(self.mako_template.filename)\n        return 'string'"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender a Mako template using the Mako system.", "response": "def render(self, context=None, request=None, def_name=None):\n        '''\n        Renders a template using the Mako system.  This method signature conforms to\n        the Django template API, which specifies that template.render() returns a string.\n\n            @context  A dictionary of name=value variables to send to the template page.  This can be a real dictionary\n                      or a Django Context object.\n            @request  The request context from Django.  If this is None, any TEMPLATE_CONTEXT_PROCESSORS defined in your settings\n                      file will be ignored but the template will otherwise render fine.\n            @def_name Limits output to a specific top-level Mako <%block> or <%def> section within the template.\n                      If the section is a <%def>, any parameters must be in the context dictionary.  For example,\n                      def_name=\"foo\" will call <%block name=\"foo\"></%block> or <%def name=\"foo()\"></def> within\n                      the template.\n\n        Returns the rendered template as a unicode string.\n\n        The method triggers two signals:\n            1. dmp_signal_pre_render_template: you can (optionally) return a new Mako Template object from a receiver to replace\n               the normal template object that is used for the render operation.\n            2. dmp_signal_post_render_template: you can (optionally) return a string to replace the string from the normal\n               template object render.\n        '''\n        dmp = apps.get_app_config('django_mako_plus')\n        # set up the context dictionary, which is the variables available throughout the template\n        context_dict = {}\n        # if request is None, add some default items because the context processors won't happen\n        if request is None:\n            context_dict['settings'] = settings\n            context_dict['STATIC_URL'] = settings.STATIC_URL\n        # let the context_processors add variables to the context.\n        if not isinstance(context, Context):\n            context = Context(context) if request is None else RequestContext(request, context)\n        with context.bind_template(self):\n            for d in context:\n                context_dict.update(d)\n        context_dict.pop('self', None)  # some contexts have self in them, and it messes up render_unicode below because we get two selfs\n\n        # send the pre-render signal\n        if dmp.options['SIGNALS'] and request is not None:\n            for receiver, ret_template_obj in dmp_signal_pre_render_template.send(sender=self, request=request, context=context, template=self.mako_template):\n                if ret_template_obj is not None:\n                    if isinstance(ret_template_obj, MakoTemplateAdapter):\n                        self.mako_template = ret_template_obj.mako_template   # if the signal function sends a MakoTemplateAdapter back, use the real mako template inside of it\n                    else:\n                        self.mako_template = ret_template_obj                 # if something else, we assume it is a mako.template.Template, so use it as the template\n\n        # do we need to limit down to a specific def?\n        # this only finds within the exact template (won't go up the inheritance tree)\n        render_obj = self.mako_template\n        if def_name is None:\n            def_name = self.def_name\n        if def_name:  # do we need to limit to just a def?\n            render_obj = self.mako_template.get_def(def_name)\n\n        # PRIMARY FUNCTION: render the template\n        if log.isEnabledFor(logging.INFO):\n            log.info('rendering template %s%s%s', self.name, ('::' if def_name else ''), def_name or '')\n        if settings.DEBUG:\n            try:\n                content = render_obj.render_unicode(**context_dict)\n            except Exception as e:\n                log.exception('exception raised during template rendering: %s', e)  # to the console\n                e.template_debug = get_template_debug('%s%s%s' % (self.name, ('::' if def_name else ''), def_name or ''), e)\n                raise\n        else:  # this is outside the above \"try\" loop because in non-DEBUG mode, we want to let the exception throw out of here (without having to re-raise it)\n            content = render_obj.render_unicode(**context_dict)\n\n        # send the post-render signal\n        if dmp.options['SIGNALS'] and request is not None:\n            for receiver, ret_content in dmp_signal_post_render_template.send(sender=self, request=request, context=context, template=self.mako_template, content=content):\n                if ret_content is not None:\n                    content = ret_content  # sets it to the last non-None return in the signal receiver chain\n\n        # return\n        return mark_safe(content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering the template and returns an HttpResponse object containing the rendered content.", "response": "def render_to_response(self, context=None, request=None, def_name=None, content_type=None, status=None, charset=None):\n        '''\n        Renders the template and returns an HttpRequest object containing its content.\n\n        This method returns a django.http.Http404 exception if the template is not found.\n        If the template raises a django_mako_plus.RedirectException, the browser is redirected to\n        the given page, and a new request from the browser restarts the entire DMP routing process.\n        If the template raises a django_mako_plus.InternalRedirectException, the entire DMP\n        routing process is restarted internally (the browser doesn't see the redirect).\n\n            @request      The request context from Django.  If this is None, any TEMPLATE_CONTEXT_PROCESSORS defined in your settings\n                          file will be ignored but the template will otherwise render fine.\n            @template     The template file path to render.  This is relative to the app_path/controller_TEMPLATES_DIR/ directory.\n                          For example, to render app_path/templates/page1, set template=\"page1.html\", assuming you have\n                          set up the variables as described in the documentation above.\n            @context      A dictionary of name=value variables to send to the template page.  This can be a real dictionary\n                          or a Django Context object.\n            @def_name     Limits output to a specific top-level Mako <%block> or <%def> section within the template.\n                          For example, def_name=\"foo\" will call <%block name=\"foo\"></%block> or <%def name=\"foo()\"></def> within the template.\n            @content_type The MIME type of the response.  Defaults to settings.DEFAULT_CONTENT_TYPE (usually 'text/html').\n            @status       The HTTP response status code.  Defaults to 200 (OK).\n            @charset      The charset to encode the processed template string (the output) with.  Defaults to settings.DEFAULT_CHARSET (usually 'utf-8').\n\n        The method triggers two signals:\n            1. dmp_signal_pre_render_template: you can (optionally) return a new Mako Template object from a receiver to replace\n               the normal template object that is used for the render operation.\n            2. dmp_signal_post_render_template: you can (optionally) return a string to replace the string from the normal\n               template object render.\n        '''\n        try:\n            if content_type is None:\n                content_type = mimetypes.types_map.get(os.path.splitext(self.mako_template.filename)[1].lower(), settings.DEFAULT_CONTENT_TYPE)\n            if charset is None:\n                charset = settings.DEFAULT_CHARSET\n            if status is None:\n                status = 200\n            content = self.render(context=context, request=request, def_name=def_name)\n            return HttpResponse(content.encode(charset), content_type='%s; charset=%s' % (content_type, charset), status=status)\n\n        except RedirectException: # redirect to another page\n            e = sys.exc_info()[1]\n            if request is None:\n                log.info('a template redirected processing to %s', e.redirect_to)\n            else:\n                log.info('view function %s.%s redirected processing to %s', request.dmp.module, request.dmp.function, e.redirect_to)\n            # send the signal\n            dmp = apps.get_app_config('django_mako_plus')\n            if dmp.options['SIGNALS']:\n                dmp_signal_redirect_exception.send(sender=sys.modules[__name__], request=request, exc=e)\n            # send the browser the redirect command\n            return e.get_response(request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves the given parser action object by its dest attribute", "response": "def get_action_by_dest(self, parser, dest):\n        '''Retrieves the given parser action object by its dest= attribute'''\n        for action in parser._actions:\n            if action.dest == dest:\n                return action\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplacing this in execute because then subclass handle doesn t have to call super", "response": "def execute(self, *args, **options):\n        '''Placing this in execute because then subclass handle() don't have to call super'''\n        if options['verbose']:\n            options['verbosity'] = 3\n        if options['quiet']:\n            options['verbosity'] = 0\n        self.verbosity = options.get('verbosity', 1)\n        super().execute(*args, **options)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef message(self, msg='', level=1, tab=0):\n        '''Print a message to the console'''\n        if self.verbosity >= level:\n            self.stdout.write('{}{}'.format('    ' * tab, msg))", "response": "Print a message to the console"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef b58enc(uid):\n    '''Encodes a UID to an 11-length string, encoded using base58 url-safe alphabet'''\n    # note: i tested a buffer array too, but string concat was 2x faster\n    if not isinstance(uid, int):\n        raise ValueError('Invalid integer: {}'.format(uid))\n    if uid == 0:\n        return BASE58CHARS[0]\n    enc_uid = \"\"\n    while uid:\n        uid, r = divmod(uid, 58)\n        enc_uid = BASE58CHARS[r] + enc_uid\n    return enc_uid", "response": "Encodes a UID to an 11 - length string encoded using base58 url - safe alphabet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecoding a UID from base58 url - safe alphabet back to int.", "response": "def b58dec(enc_uid):\n    '''Decodes a UID from base58, url-safe alphabet back to int.'''\n    if isinstance(enc_uid, str):\n        pass\n    elif isinstance(enc_uid, bytes):\n        enc_uid = enc_uid.decode('utf8')\n    else:\n        raise ValueError('Cannot decode this type: {}'.format(enc_uid))\n    uid = 0\n    try:\n        for i, ch in enumerate(enc_uid):\n            uid = (uid * 58) + BASE58INDEX[ch]\n    except KeyError:\n        raise ValueError('Invalid character: \"{}\" (\"{}\", index 5)'.format(ch, enc_uid, i))\n    return uid"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef minify(text, minifier):\n    '''Minifies the source text (if needed)'''\n    # there really isn't a good way to know if a file is already minified.\n    # our heuristic is if source is more than 50 bytes greater of dest OR\n    # if a hard return is found in the first 50 chars, we assume it is not minified.\n    minified = minifier(text)\n    if  abs(len(text) - len(minified)) > 50 or '\\n' in text[:50]:\n        return minified\n    return text", "response": "Minifies the source text ( if needed )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match(self, fname, flevel, ftype):\n        '''Returns the result score if the file matches this rule'''\n        # if filetype is the same\n        # and level isn't set or level is the same\n        # and pattern matche the filename\n        if self.filetype == ftype and (self.level is None or self.level == flevel) and fnmatch.fnmatch(fname, self.pattern):\n            return self.score\n        return 0", "response": "Returns the result score if the file matches this rule"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_rules(self):\n        '''Adds rules for the command line options'''\n        dmp = apps.get_app_config('django_mako_plus')\n        # the default\n        rules = [\n            # files are included by default\n            Rule('*',                                    level=None, filetype=TYPE_FILE,      score=1),\n            # files at the app level are skipped\n            Rule('*',                                    level=0,    filetype=TYPE_FILE,      score=-2),\n            # directories are recursed by default\n            Rule('*',                                    level=None, filetype=TYPE_DIRECTORY, score=1),\n            # directories at the app level are skipped\n            Rule('*',                                    level=0,    filetype=TYPE_DIRECTORY, score=-2),\n\n            # media, scripts, styles directories are what we want to copy\n            Rule('media',                                level=0,    filetype=TYPE_DIRECTORY, score=6),\n            Rule('scripts',                              level=0,    filetype=TYPE_DIRECTORY, score=6),\n            Rule('styles',                               level=0,    filetype=TYPE_DIRECTORY, score=6),\n\n            # ignore the template cache directories\n            Rule(dmp.options['TEMPLATES_CACHE_DIR'],     level=None, filetype=TYPE_DIRECTORY, score=-3),\n            # ignore python cache directories\n            Rule('__pycache__',                          level=None, filetype=TYPE_DIRECTORY, score=-3),\n            # ignore compiled python files\n            Rule('*.pyc',                                level=None, filetype=TYPE_FILE,      score=-3),\n        ]\n        # include rules have score of 50 because they trump all initial rules\n        for pattern in (self.options.get('include_dir') or []):\n            self.message('Setting rule - recurse directories: {}'.format(pattern), 1)\n            rules.append(Rule(pattern, level=None, filetype=TYPE_DIRECTORY, score=50))\n        for pattern in (self.options.get('include_file') or []):\n            self.message('Setting rule - include files: {}'.format(pattern), 1)\n            rules.append(Rule(pattern, level=None, filetype=TYPE_FILE, score=50))\n        # skip rules have score of 100 because they trump everything, including the includes from the command line\n        for pattern in (self.options.get('skip_dir') or []):\n            self.message('Setting rule - skip directories: {}'.format(pattern), 1)\n            rules.append(Rule(pattern, level=None, filetype=TYPE_DIRECTORY, score=-100))\n        for pattern in (self.options.get('skip_file') or []):\n            self.message('Setting rule - skip files: {}'.format(pattern), 1)\n            rules.append(Rule(pattern, level=None, filetype=TYPE_FILE, score=-100))\n        return rules", "response": "Adds rules for the command line options"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy the static files from one directory to another.", "response": "def copy_dir(self, source, dest, level=0):\n        '''Copies the static files from one directory to another.  If this command is run, we assume the user wants to overwrite any existing files.'''\n        encoding = settings.DEFAULT_CHARSET or 'utf8'\n        msglevel = 2 if level == 0 else 3\n        self.message('Directory: {}'.format(source), msglevel, level)\n\n        # create a directory for this app\n        if not os.path.exists(dest):\n            self.message('Creating directory: {}'.format(dest), msglevel, level+1)\n            os.mkdir(dest)\n\n        # go through the files in this app\n        for fname in os.listdir(source):\n            source_path = os.path.join(source, fname)\n            dest_path = os.path.join(dest, fname)\n            ext = os.path.splitext(fname)[1].lower()\n\n            # get the score for this file\n            score = 0\n            for rule in self.rules:\n                score += rule.match(fname, level, TYPE_DIRECTORY if os.path.isdir(source_path) else TYPE_FILE)\n\n            # if score is not above zero, we skip this file\n            if score <= 0:\n                self.message('Skipping file with score {}: {}'.format(score, source_path), msglevel, level+1)\n                continue\n\n            ### if we get here, we need to copy the file ###\n\n            # if a directory, recurse to it\n            if os.path.isdir(source_path):\n                self.message('Creating directory with score {}: {}'.format(score, source_path), msglevel, level+1)\n                # create it in the destination and recurse\n                if not os.path.exists(dest_path):\n                    os.mkdir(dest_path)\n                elif not os.path.isdir(dest_path):  # could be a file or link\n                    os.unlink(dest_path)\n                    os.mkdir(dest_path)\n                self.copy_dir(source_path, dest_path, level+1)\n\n            # if a regular Javscript file, run through the static file processors (scripts group)\n            elif ext == '.js' and not self.options.get('no_minify') and jsmin:\n                self.message('Including and minifying file with score {}: {}'.format(score, source_path), msglevel, level+1)\n                with open(source_path, encoding=encoding) as fin:\n                    with open(dest_path, 'w', encoding=encoding) as fout:\n                        minified = minify(fin.read(), jsmin)\n                        fout.write(minified)\n\n\n            # if a CSS file, run through the static file processors (styles group)\n            elif ext == '.css' and not self.options.get('no_minify') and cssmin:\n                self.message('Including and minifying file with score {}: {}'.format(score, source_path), msglevel, level+1)\n                with open(source_path, encoding=encoding) as fin:\n                    with open(dest_path, 'w', encoding=encoding) as fout:\n                        minified = minify(fin.read(), cssmin)\n                        fout.write(minified)\n\n            # otherwise, just copy the file\n            else:\n                self.message('Including file with score {}: {}'.format(score, source_path), msglevel, level+1)\n                shutil.copy2(source_path, dest_path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dmp_include(context, template_name, def_name=None, **kwargs):\n    '''\n    Includes a DMP (Mako) template into a normal django template.\n\n    context:        automatically provided\n    template_name:  specified as \"app/template\"\n    def_name:       optional block to render within the template\n\n    Example:\n        {% load django_mako_plus %}\n        {% dmp_include \"homepage/bsnav_dj.html\" %}\n        or\n        {% dmp_include \"homepage/bsnav_dj.html\" \"blockname\" %}\n    '''\n    dmp = apps.get_app_config('django_mako_plus')\n    template = dmp.engine.get_template(template_name)\n    dmpcontext = context.flatten()\n    dmpcontext.update(kwargs)\n    return mark_safe(template.render(\n        context=dmpcontext,\n        request=context.get('request'),\n        def_name=def_name\n    ))", "response": "Include a DMP template into a normal django template."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self, template, context=None, def_name=None, subdir='templates', content_type=None, status=None, charset=None):\n        '''App-specific render function that renders templates in the *current app*, attached to the request for convenience'''\n        template_adapter = self.get_template_loader(subdir).get_template(template)\n        return getattr(template_adapter, 'render_to_response')(context=context, request=self.request, def_name=def_name, content_type=content_type, status=status, charset=charset)", "response": "App - specific render function that renders templates in the current app attached to the request for convenience"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render_to_string(self, template, context=None, def_name=None, subdir='templates'):\n        '''App-specific render function that renders templates in the *current app*, attached to the request for convenience'''\n        template_adapter = self.get_template_loader(subdir).get_template(template)\n        return getattr(template_adapter, 'render')(context=context, request=self.request, def_name=def_name)", "response": "App - specific render function that renders templates in the current app attached to the request for convenience"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall by Django when the app is ready for use.", "response": "def ready(self):\n        '''Called by Django when the app is ready for use.'''\n        # set up the options\n        self.options = {}\n        self.options.update(DEFAULT_OPTIONS)\n        for template_engine in settings.TEMPLATES:\n            if template_engine.get('BACKEND', '').startswith('django_mako_plus'):\n                self.options.update(template_engine.get('OPTIONS', {}))\n\n        # dmp-enabled apps registry\n        self.registration_lock = threading.RLock()\n        self.registered_apps = {}\n\n        # init the template engine\n        self.engine = engines['django_mako_plus']\n\n        # default imports on every compiled template\n        self.template_imports = [\n            'import django_mako_plus',\n            'import django.utils.html',     # used in template.py\n        ]\n        self.template_imports.extend(self.options['DEFAULT_TEMPLATE_IMPORTS'])\n\n        # initialize the list of providers\n        ProviderRun.initialize_providers()\n\n        # set up the parameter converters (can't import until apps are set up)\n        from .converter.base import ParameterConverter\n        ParameterConverter._sort_converters(app_ready=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_app(self, app=None):\n        '''\n        Registers an app as a \"DMP-enabled\" app.  Normally, DMP does this\n        automatically when included in urls.py.\n\n        If app is None, the DEFAULT_APP is registered.\n        '''\n        app = app or self.options['DEFAULT_APP']\n        if not app:\n            raise ImproperlyConfigured('An app name is required because DEFAULT_APP is empty - please use a '\n                                        'valid app name or set the DEFAULT_APP in settings')\n        if isinstance(app, str):\n            app = apps.get_app_config(app)\n\n        # since this only runs at startup, this lock doesn't affect performance\n        with self.registration_lock:\n            # short circuit if already registered\n            if app.name in self.registered_apps:\n                return\n\n            # first time for this app, so add to our dictionary\n            self.registered_apps[app.name] = app\n\n            # set up the template, script, and style renderers\n            # these create and cache just by accessing them\n            self.engine.get_template_loader(app, 'templates', create=True)\n            self.engine.get_template_loader(app, 'scripts', create=True)\n            self.engine.get_template_loader(app, 'styles', create=True)\n\n            # send the registration signal\n            if self.options['SIGNALS']:\n                dmp_signal_register_app.send(sender=self, app_config=app)", "response": "Registers an app as a DMP - enabled app."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn true if the given app is registered with DMP", "response": "def is_registered_app(self, app):\n        '''Returns true if the given app/app name is registered with DMP'''\n        if app is None:\n            return False\n        if isinstance(app, AppConfig):\n            app = app.name\n        return app in self.registered_apps"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, idx, default=''):\n        '''Returns the element at idx, or default if idx is beyond the length of the list'''\n        # if the index is beyond the length of the list, return ''\n        if isinstance(idx, int) and (idx >= len(self) or idx < -1 * len(self)):\n            return default\n        # else do the regular list function (for int, slice types, etc.)\n        return super().__getitem__(idx)", "response": "Returns the element at idx or default if idx is beyond the length of the list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting value to int or float", "response": "def convert_int(value, parameter):\n    '''\n    Converts to int or float:\n        '', '-', None convert to parameter default\n        Anything else uses int() or float() constructor\n    '''\n    value = _check_default(value, parameter, ( '', '-', None ))\n    if value is None or isinstance(value, int):\n        return value\n    try:\n        return int(value)\n    except Exception as e:\n        raise ValueError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_float(value, parameter):\n    '''\n    Converts to int or float:\n        '', '-', None convert to parameter default\n        Anything else uses int() or float() constructor\n    '''\n    value = _check_default(value, parameter, ( '', '-', None ))\n    if value is None or isinstance(value, float):\n        return value\n    try:\n        return float(value)\n    except Exception as e:\n        raise ValueError(str(e))", "response": "Converts value to float or returns default value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts value to decimal. Decimal", "response": "def convert_decimal(value, parameter):\n    '''\n    Converts to decimal.Decimal:\n        '', '-', None convert to parameter default\n        Anything else uses Decimal constructor\n    '''\n    value = _check_default(value, parameter, ( '', '-', None ))\n    if value is None or isinstance(value, decimal.Decimal):\n        return value\n    try:\n        return decimal.Decimal(value)\n    except Exception as e:\n        raise ValueError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a string to boolean.", "response": "def convert_boolean(value, parameter, default=False):\n    '''\n    Converts to boolean (only the first char of the value is used):\n        '', '-', None convert to parameter default\n        'f', 'F', '0', False always convert to False\n        Anything else converts to True.\n    '''\n    value = _check_default(value, parameter, ( '', '-', None ))\n    if isinstance(value, bool):\n        return value\n    if isinstance(value, str) and len(value) > 0:\n        value = value[0]\n    return value not in ( 'f', 'F', '0', False, None )"}
